; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\cod_amr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cod_amr_id
CONST	SEGMENT
_cod_amr_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_gamma1	DW	07852H
	DW	0711aH
	DW	06a51H
	DW	063f0H
	DW	05df1H
	DW	0584eH
	DW	05302H
	DW	04e07H
	DW	04959H
	DW	044f2H
_gamma1_12k2 DW	07333H
	DW	067aeH
	DW	05d50H
	DW	053fbH
	DW	04b95H
	DW	04406H
	DW	03d38H
	DW	03719H
	DW	03196H
	DW	02ca1H
_gamma2	DW	04ccdH
	DW	02e15H
	DW	01ba6H
	DW	01097H
	DW	09f4H
	DW	05f9H
	DW	0395H
	DW	0226H
	DW	014aH
	DW	0c6H
CONST	ENDS
PUBLIC	_cod_amr_init
PUBLIC	_cod_amr_reset
PUBLIC	_cod_amr_exit
PUBLIC	_cod_amr_first
PUBLIC	_cod_amr
PUBLIC	??_C@_0CB@KMHLKBEK@cod_amr_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@MKDLNKIH@cod_amr_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@IALOCEE@cod_amr_reset?3?5invalid?5parameter@ ; `string'
EXTRN	_lpc_init:PROC
EXTRN	_lpc_reset:PROC
EXTRN	_lpc_exit:PROC
EXTRN	_lpc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_lsp_init:PROC
EXTRN	_lsp_reset:PROC
EXTRN	_lsp_exit:PROC
EXTRN	_lsp:PROC
EXTRN	_ton_stab_init:PROC
EXTRN	_ton_stab_reset:PROC
EXTRN	_ton_stab_exit:PROC
EXTRN	_check_lsp:PROC
EXTRN	_update_gp_clipping:PROC
EXTRN	_cl_ltp_init:PROC
EXTRN	_cl_ltp_reset:PROC
EXTRN	_cl_ltp_exit:PROC
EXTRN	_cl_ltp:PROC
EXTRN	_gainQuant_init:PROC
EXTRN	_gainQuant_reset:PROC
EXTRN	_gainQuant_exit:PROC
EXTRN	_gainQuant:PROC
EXTRN	_vad1_init:PROC
EXTRN	_vad1_reset:PROC
EXTRN	_vad1_exit:PROC
EXTRN	_vad_pitch_detection:PROC
EXTRN	_vad1:PROC
EXTRN	_p_ol_wgh_init:PROC
EXTRN	_p_ol_wgh_reset:PROC
EXTRN	_p_ol_wgh_exit:PROC
EXTRN	_dtx_enc_init:PROC
EXTRN	_dtx_enc_reset:PROC
EXTRN	_dtx_enc_exit:PROC
EXTRN	_dtx_enc:PROC
EXTRN	_dtx_buffer:PROC
EXTRN	_tx_dtx_handler:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_fwc:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Copy:PROC
EXTRN	_Set_zero:PROC
EXTRN	_pre_big:PROC
EXTRN	_ol_ltp:PROC
EXTRN	_subframePreProc:PROC
EXTRN	_Pred_lt_3or6:PROC
EXTRN	_subframePostProc:PROC
EXTRN	_cbsearch:PROC
EXTRN	_Convolve:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CC@IALOCEE@cod_amr_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@IALOCEE@cod_amr_reset?3?5invalid?5parameter@ DB 'cod_amr_reset:'
	DB	' invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MKDLNKIH@cod_amr_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@MKDLNKIH@cod_amr_init?3?5can?5not?5malloc?5sta@ DB 'cod_amr_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KMHLKBEK@cod_amr_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@KMHLKBEK@cod_amr_init?3?5invalid?5parameter?6@ DB 'cod_amr_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cod_amr.c
;	COMDAT _cod_amr
_TEXT	SEGMENT
_compute_sid_flag$ = -1532				; size = 2
_vad_flag$ = -1520					; size = 2
_gp_limit$ = -1508					; size = 2
_lsp_flag$ = -1496					; size = 2
_gain_code$ = -1484					; size = 2
_gain_pit$ = -1472					; size = 2
_T0_frac$ = -1460					; size = 2
_T0$ = -1448						; size = 2
_T_op$ = -1436						; size = 4
_subfrNr$ = -1424					; size = 2
_i_subfr$ = -1412					; size = 2
_gain_code_sf0$ = -1400					; size = 2
_gain_pit_sf0$ = -1388					; size = 2
_i_subfr_sf0$ = -1376					; size = 2
_T0_frac_sf0$ = -1364					; size = 2
_T0_sf0$ = -1352					; size = 2
_evenSubfr$ = -1340					; size = 2
_sharp_save$ = -1328					; size = 2
_mem_err_save$ = -1316					; size = 20
_mem_w0_save$ = -1288					; size = 20
_mem_syn_save$ = -1260					; size = 20
_h1_sf0$ = -1232					; size = 80
_code_sf0$ = -1144					; size = 80
_y2_sf0$ = -1056					; size = 80
_xn_sf0$ = -968						; size = 80
_res2$ = -880						; size = 80
_res$ = -792						; size = 80
_gCoeff$ = -704						; size = 12
_y2$ = -684						; size = 80
_y1$ = -596						; size = 80
_code$ = -508						; size = 80
_xn2$ = -420						; size = 80
_xn$ = -332						; size = 80
_lsp_new$ = -244					; size = 20
_Aq$ = -216						; size = 4
_A$ = -204						; size = 4
_Aq_t$ = -192						; size = 88
_A_t$ = -96						; size = 88
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_new_speech$ = 16					; size = 4
_ana$ = 20						; size = 4
_usedMode$ = 24						; size = 4
_synth$ = 28						; size = 4
_cod_amr PROC						; COMDAT

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 06 00
	00		 sub	 esp, 1728		; 000006c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1728]
  00012	b9 b0 01 00 00	 mov	 ecx, 432		; 000001b0H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 317  :    /* LPC coefficients */
; 318  :    Word16 A_t[(MP1) * 4];      /* A(z) unquantized for the 4 subframes */
; 319  :    Word16 Aq_t[(MP1) * 4];     /* A(z)   quantized for the 4 subframes */
; 320  :    Word16 *A, *Aq;             /* Pointer on A_t and Aq_t              */
; 321  :    Word16 lsp_new[M];
; 322  :    
; 323  :    /* Other vectors */
; 324  :    Word16 xn[L_SUBFR];         /* Target vector for pitch search       */
; 325  :    Word16 xn2[L_SUBFR];        /* Target vector for codebook search    */
; 326  :    Word16 code[L_SUBFR];       /* Fixed codebook excitation            */
; 327  :    Word16 y1[L_SUBFR];         /* Filtered adaptive excitation         */
; 328  :    Word16 y2[L_SUBFR];         /* Filtered fixed codebook excitation   */
; 329  :    Word16 gCoeff[6];           /* Correlations between xn, y1, & y2:   */
; 330  :    Word16 res[L_SUBFR];        /* Short term (LPC) prediction residual */
; 331  :    Word16 res2[L_SUBFR];       /* Long term (LTP) prediction residual  */
; 332  : 
; 333  :    /* Vector and scalars needed for the MR475 */
; 334  :    Word16 xn_sf0[L_SUBFR];     /* Target vector for pitch search       */
; 335  :    Word16 y2_sf0[L_SUBFR];     /* Filtered codebook innovation         */   
; 336  :    Word16 code_sf0[L_SUBFR];   /* Fixed codebook excitation            */
; 337  :    Word16 h1_sf0[L_SUBFR];     /* The impulse response of sf0          */
; 338  :    Word16 mem_syn_save[M];     /* Filter memory                        */
; 339  :    Word16 mem_w0_save[M];      /* Filter memory                        */
; 340  :    Word16 mem_err_save[M];     /* Filter memory                        */
; 341  :    Word16 sharp_save;          /* Sharpening                           */
; 342  :    Word16 evenSubfr;           /* Even subframe indicator              */ 
; 343  :    Word16 T0_sf0 = 0;          /* Integer pitch lag of sf0             */  

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 85 b8 fa
	ff ff		 mov	 WORD PTR _T0_sf0$[ebp], ax

; 344  :    Word16 T0_frac_sf0 = 0;     /* Fractional pitch lag of sf0          */  

  00031	33 c0		 xor	 eax, eax
  00033	66 89 85 ac fa
	ff ff		 mov	 WORD PTR _T0_frac_sf0$[ebp], ax

; 345  :    Word16 i_subfr_sf0 = 0;     /* Position in exc[] for sf0            */

  0003a	33 c0		 xor	 eax, eax
  0003c	66 89 85 a0 fa
	ff ff		 mov	 WORD PTR _i_subfr_sf0$[ebp], ax

; 346  :    Word16 gain_pit_sf0;        /* Quantized pitch gain for sf0         */
; 347  :    Word16 gain_code_sf0;       /* Quantized codebook gain for sf0      */
; 348  :     
; 349  :    /* Scalars */
; 350  :    Word16 i_subfr, subfrNr;
; 351  :    Word16 T_op[L_FRAME/L_FRAME_BY2];
; 352  :    Word16 T0, T0_frac;
; 353  :    Word16 gain_pit, gain_code;
; 354  : 
; 355  :    /* Flags */
; 356  :    Word16 lsp_flag = 0;        /* indicates resonance in LPC filter */   

  00043	33 c0		 xor	 eax, eax
  00045	66 89 85 28 fa
	ff ff		 mov	 WORD PTR _lsp_flag$[ebp], ax

; 357  :    Word16 gp_limit;            /* pitch gain limit value            */
; 358  :    Word16 vad_flag;            /* VAD decision flag                 */
; 359  :    Word16 compute_sid_flag;    /* SID analysis  flag                 */
; 360  : 
; 361  :    Copy(new_speech, st->new_speech, L_FRAME);

  0004c	68 a0 00 00 00	 push	 160			; 000000a0H
  00051	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00054	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  0005a	51		 push	 ecx
  0005b	8b 55 10	 mov	 edx, DWORD PTR _new_speech$[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _Copy
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  :    *usedMode = mode;                     move16 ();

  00067	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	e8 00 00 00 00	 call	 _move16

; 364  : 
; 365  :    /* DTX processing */
; 366  :    if (st->dtx)

  00074	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00077	83 b8 a8 08 00
	00 00		 cmp	 DWORD PTR [eax+2216], 0
  0007e	74 4f		 je	 SHORT $LN25@cod_amr

; 367  :    {  /* no test() call since this if is only in simulation env */
; 368  :       /* Find VAD decision */
; 369  : 
; 370  : #ifdef  VAD2
; 371  :       vad_flag = vad2 (st->new_speech,    st->vadSt);
; 372  :       vad_flag = vad2 (st->new_speech+80, st->vadSt) || vad_flag;      logic16();
; 373  : #else
; 374  :       vad_flag = vad1(st->vadSt, st->new_speech);     

  00080	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00083	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  00089	51		 push	 ecx
  0008a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0008d	8b 82 a4 08 00
	00		 mov	 eax, DWORD PTR [edx+2212]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _vad1
  00099	83 c4 08	 add	 esp, 8
  0009c	66 89 85 10 fa
	ff ff		 mov	 WORD PTR _vad_flag$[ebp], ax

; 375  : #endif
; 376  :       fwc ();                 /* function worst case */

  000a3	e8 00 00 00 00	 call	 _fwc

; 377  : 
; 378  :       /* NB! usedMode may change here */
; 379  :       compute_sid_flag = tx_dtx_handler(st->dtx_encSt,
; 380  :                                         vad_flag, 
; 381  :                                         usedMode);

  000a8	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  000ab	50		 push	 eax
  000ac	0f b7 8d 10 fa
	ff ff		 movzx	 ecx, WORD PTR _vad_flag$[ebp]
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000b7	8b 82 ac 08 00
	00		 mov	 eax, DWORD PTR [edx+2220]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _tx_dtx_handler
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	66 89 85 04 fa
	ff ff		 mov	 WORD PTR _compute_sid_flag$[ebp], ax

; 382  :    }
; 383  :    else 

  000cd	eb 0e		 jmp	 SHORT $LN24@cod_amr
$LN25@cod_amr:

; 384  :    {
; 385  :       compute_sid_flag = 0;              move16 ();

  000cf	33 c0		 xor	 eax, eax
  000d1	66 89 85 04 fa
	ff ff		 mov	 WORD PTR _compute_sid_flag$[ebp], ax
  000d8	e8 00 00 00 00	 call	 _move16
$LN24@cod_amr:

; 386  :    }
; 387  :    
; 388  :    /*------------------------------------------------------------------------*
; 389  :     *  - Perform LPC analysis:                                               *
; 390  :     *       * autocorrelation + lag windowing                                *
; 391  :     *       * Levinson-durbin algorithm to find a[]                          *
; 392  :     *       * convert a[] to lsp[]                                           *
; 393  :     *       * quantize and code the LSPs                                     *
; 394  :     *       * find the interpolated LSPs and convert to a[] for all          *
; 395  :     *         subframes (both quantized and unquantized)                     *
; 396  :     *------------------------------------------------------------------------*/
; 397  :    
; 398  :    /* LP analysis */
; 399  :    lpc(st->lpcSt, mode, st->p_window, st->p_window_12k2, A_t);

  000dd	8d 45 a0	 lea	 eax, DWORD PTR _A_t$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000e4	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ee	8b 88 84 02 00
	00		 mov	 ecx, DWORD PTR [eax+644]
  000f4	51		 push	 ecx
  000f5	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000fc	8b 88 8c 08 00
	00		 mov	 ecx, DWORD PTR [eax+2188]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _lpc
  00108	83 c4 14	 add	 esp, 20			; 00000014H

; 400  : 
; 401  :    fwc ();                 /* function worst case */

  0010b	e8 00 00 00 00	 call	 _fwc

; 402  : 
; 403  :    /* From A(z) to lsp. LSP quantization and interpolation */
; 404  :    lsp(st->lspSt, mode, *usedMode, A_t, Aq_t, lsp_new, &ana);

  00110	8d 45 14	 lea	 eax, DWORD PTR _ana$[ebp]
  00113	50		 push	 eax
  00114	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _lsp_new$[ebp]
  0011a	51		 push	 ecx
  0011b	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _Aq_t$[ebp]
  00121	52		 push	 edx
  00122	8d 45 a0	 lea	 eax, DWORD PTR _A_t$[ebp]
  00125	50		 push	 eax
  00126	8b 4d 18	 mov	 ecx, DWORD PTR _usedMode$[ebp]
  00129	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012b	52		 push	 edx
  0012c	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00133	8b 91 90 08 00
	00		 mov	 edx, DWORD PTR [ecx+2192]
  00139	52		 push	 edx
  0013a	e8 00 00 00 00	 call	 _lsp
  0013f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 405  :    
; 406  :    fwc ();                 /* function worst case */

  00142	e8 00 00 00 00	 call	 _fwc

; 407  : 
; 408  :    /* Buffer lsp's and energy */
; 409  :    dtx_buffer(st->dtx_encSt,
; 410  : 	      lsp_new,
; 411  : 	      st->new_speech);

  00147	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0014a	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  00150	51		 push	 ecx
  00151	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR _lsp_new$[ebp]
  00157	52		 push	 edx
  00158	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0015b	8b 88 ac 08 00
	00		 mov	 ecx, DWORD PTR [eax+2220]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _dtx_buffer
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 
; 413  :    /* Check if in DTX mode */
; 414  :    test();

  0016a	e8 00 00 00 00	 call	 _test

; 415  :    if (sub(*usedMode, MRDTX) == 0)

  0016f	6a 08		 push	 8
  00171	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00174	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _sub
  0017d	83 c4 08	 add	 esp, 8
  00180	0f bf d0	 movsx	 edx, ax
  00183	85 d2		 test	 edx, edx
  00185	0f 85 0b 01 00
	00		 jne	 $LN23@cod_amr

; 416  :    {
; 417  :       dtx_enc(st->dtx_encSt,
; 418  :               compute_sid_flag,
; 419  :               st->lspSt->qSt, 
; 420  :               st->gainQuantSt->gc_predSt,
; 421  :               &ana);

  0018b	8d 45 14	 lea	 eax, DWORD PTR _ana$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00192	8b 91 98 08 00
	00		 mov	 edx, DWORD PTR [ecx+2200]
  00198	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0019b	50		 push	 eax
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0019f	8b 91 90 08 00
	00		 mov	 edx, DWORD PTR [ecx+2192]
  001a5	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001a8	50		 push	 eax
  001a9	0f b7 8d 04 fa
	ff ff		 movzx	 ecx, WORD PTR _compute_sid_flag$[ebp]
  001b0	51		 push	 ecx
  001b1	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001b4	8b 82 ac 08 00
	00		 mov	 eax, DWORD PTR [edx+2220]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 _dtx_enc
  001c0	83 c4 14	 add	 esp, 20			; 00000014H

; 422  :       
; 423  :       Set_zero(st->old_exc,    PIT_MAX + L_INTERPOL);

  001c3	68 9a 00 00 00	 push	 154			; 0000009aH
  001c8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001cb	05 02 05 00 00	 add	 eax, 1282		; 00000502H
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _Set_zero
  001d6	83 c4 08	 add	 esp, 8

; 424  :       Set_zero(st->mem_w0,     M);

  001d9	6a 0a		 push	 10			; 0000000aH
  001db	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001de	05 c4 08 00 00	 add	 eax, 2244		; 000008c4H
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _Set_zero
  001e9	83 c4 08	 add	 esp, 8

; 425  :       Set_zero(st->mem_err,    M);

  001ec	6a 0a		 push	 10			; 0000000aH
  001ee	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001f1	05 ec 08 00 00	 add	 eax, 2284		; 000008ecH
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _Set_zero
  001fc	83 c4 08	 add	 esp, 8

; 426  :       Set_zero(st->zero,       L_SUBFR);

  001ff	6a 28		 push	 40			; 00000028H
  00201	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00204	8b 88 e4 07 00
	00		 mov	 ecx, DWORD PTR [eax+2020]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 _Set_zero
  00210	83 c4 08	 add	 esp, 8

; 427  :       Set_zero(st->hvec,       L_SUBFR);    /* set to zero "h1[-L_SUBFR..-1]" */

  00213	6a 28		 push	 40			; 00000028H
  00215	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00218	05 ec 07 00 00	 add	 eax, 2028		; 000007ecH
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _Set_zero
  00223	83 c4 08	 add	 esp, 8

; 428  :       /* Reset lsp states */
; 429  :       lsp_reset(st->lspSt);

  00226	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00229	8b 88 90 08 00
	00		 mov	 ecx, DWORD PTR [eax+2192]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _lsp_reset
  00235	83 c4 04	 add	 esp, 4

; 430  :       Copy(lsp_new, st->lspSt->lsp_old, M);

  00238	6a 0a		 push	 10			; 0000000aH
  0023a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0023d	8b 88 90 08 00
	00		 mov	 ecx, DWORD PTR [eax+2192]
  00243	51		 push	 ecx
  00244	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR _lsp_new$[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 _Copy
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :       Copy(lsp_new, st->lspSt->lsp_old_q, M);

  00253	6a 0a		 push	 10			; 0000000aH
  00255	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00258	8b 88 90 08 00
	00		 mov	 ecx, DWORD PTR [eax+2192]
  0025e	83 c1 14	 add	 ecx, 20			; 00000014H
  00261	51		 push	 ecx
  00262	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR _lsp_new$[ebp]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 _Copy
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  :       
; 433  :       /* Reset clLtp states */
; 434  :       cl_ltp_reset(st->clLtpSt);

  00271	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00274	8b 88 94 08 00
	00		 mov	 ecx, DWORD PTR [eax+2196]
  0027a	51		 push	 ecx
  0027b	e8 00 00 00 00	 call	 _cl_ltp_reset
  00280	83 c4 04	 add	 esp, 4

; 435  :       st->sharp = SHARPMIN;       move16 ();

  00283	33 c0		 xor	 eax, eax
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00288	66 89 81 54 09
	00 00		 mov	 WORD PTR [ecx+2388], ax
  0028f	e8 00 00 00 00	 call	 _move16

; 436  :    }
; 437  :    else

  00294	eb 28		 jmp	 SHORT $LN22@cod_amr
$LN23@cod_amr:

; 438  :    {
; 439  :        /* check resonance in the filter */
; 440  :       lsp_flag = check_lsp(st->tonStabSt, st->lspSt->lsp_old);  move16 ();

  00296	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00299	8b 88 90 08 00
	00		 mov	 ecx, DWORD PTR [eax+2192]
  0029f	51		 push	 ecx
  002a0	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  002a3	8b 82 a0 08 00
	00		 mov	 eax, DWORD PTR [edx+2208]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 _check_lsp
  002af	83 c4 08	 add	 esp, 8
  002b2	66 89 85 28 fa
	ff ff		 mov	 WORD PTR _lsp_flag$[ebp], ax
  002b9	e8 00 00 00 00	 call	 _move16
$LN22@cod_amr:

; 441  :    }
; 442  :    
; 443  :    /*----------------------------------------------------------------------*
; 444  :     * - Find the weighted input speech w_sp[] for the whole speech frame   *
; 445  :     * - Find the open-loop pitch delay for first 2 subframes               *
; 446  :     * - Set the range for searching closed-loop pitch in 1st subframe      *
; 447  :     * - Find the open-loop pitch delay for last 2 subframes                *
; 448  :     *----------------------------------------------------------------------*/
; 449  : 
; 450  : #ifdef VAD2
; 451  :    if (st->dtx)
; 452  :    {  /* no test() call since this if is only in simulation env */
; 453  :        st->vadSt->L_Rmax = 0;			move32 ();
; 454  :        st->vadSt->L_R0 = 0;			move32 ();
; 455  :    }
; 456  : #endif
; 457  :    for(subfrNr = 0, i_subfr = 0; 
; 458  :        subfrNr < L_FRAME/L_FRAME_BY2; 
; 459  :        subfrNr++, i_subfr += L_FRAME_BY2)

  002be	33 c0		 xor	 eax, eax
  002c0	66 89 85 70 fa
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax
  002c7	33 c9		 xor	 ecx, ecx
  002c9	66 89 8d 7c fa
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], cx
  002d0	eb 23		 jmp	 SHORT $LN21@cod_amr
$LN20@cod_amr:
  002d2	66 8b 85 70 fa
	ff ff		 mov	 ax, WORD PTR _subfrNr$[ebp]
  002d9	66 83 c0 01	 add	 ax, 1
  002dd	66 89 85 70 fa
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax
  002e4	0f bf 8d 7c fa
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  002eb	83 c1 50	 add	 ecx, 80			; 00000050H
  002ee	66 89 8d 7c fa
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], cx
$LN21@cod_amr:
  002f5	0f bf 85 70 fa
	ff ff		 movsx	 eax, WORD PTR _subfrNr$[ebp]
  002fc	83 f8 02	 cmp	 eax, 2
  002ff	0f 8d e8 00 00
	00		 jge	 $LN19@cod_amr

; 460  :    {
; 461  :       /* Pre-processing on 80 samples */
; 462  :       pre_big(mode, gamma1, gamma1_12k2, gamma2, A_t, i_subfr, st->speech,
; 463  :               st->mem_w, st->wsp);

  00305	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00308	8b 88 f0 04 00
	00		 mov	 ecx, DWORD PTR [eax+1264]
  0030e	51		 push	 ecx
  0030f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00312	81 c2 d8 08 00
	00		 add	 edx, 2264		; 000008d8H
  00318	52		 push	 edx
  00319	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0031c	8b 88 80 02 00
	00		 mov	 ecx, DWORD PTR [eax+640]
  00322	51		 push	 ecx
  00323	0f b7 95 7c fa
	ff ff		 movzx	 edx, WORD PTR _i_subfr$[ebp]
  0032a	52		 push	 edx
  0032b	8d 45 a0	 lea	 eax, DWORD PTR _A_t$[ebp]
  0032e	50		 push	 eax
  0032f	68 00 00 00 00	 push	 OFFSET _gamma2
  00334	68 00 00 00 00	 push	 OFFSET _gamma1_12k2
  00339	68 00 00 00 00	 push	 OFFSET _gamma1
  0033e	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  00341	51		 push	 ecx
  00342	e8 00 00 00 00	 call	 _pre_big
  00347	83 c4 24	 add	 esp, 36			; 00000024H

; 464  :     
; 465  :       test (); test ();

  0034a	e8 00 00 00 00	 call	 _test
  0034f	e8 00 00 00 00	 call	 _test

; 466  :       if ((sub(mode, MR475) != 0) && (sub(mode, MR515) != 0))

  00354	6a 00		 push	 0
  00356	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 _sub
  00360	83 c4 08	 add	 esp, 8
  00363	0f bf c8	 movsx	 ecx, ax
  00366	85 c9		 test	 ecx, ecx
  00368	74 7e		 je	 SHORT $LN18@cod_amr
  0036a	6a 01		 push	 1
  0036c	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 _sub
  00376	83 c4 08	 add	 esp, 8
  00379	0f bf c8	 movsx	 ecx, ax
  0037c	85 c9		 test	 ecx, ecx
  0037e	74 68		 je	 SHORT $LN18@cod_amr

; 467  :       {
; 468  :          /* Find open loop pitch lag for two subframes */
; 469  :          ol_ltp(st->pitchOLWghtSt, st->vadSt, mode, &st->wsp[i_subfr],
; 470  :                 &T_op[subfrNr], st->old_lags, st->ol_gain_flg, subfrNr,
; 471  :                 st->dtx);

  00380	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00383	8b 88 a8 08 00
	00		 mov	 ecx, DWORD PTR [eax+2216]
  00389	51		 push	 ecx
  0038a	0f b7 95 70 fa
	ff ff		 movzx	 edx, WORD PTR _subfrNr$[ebp]
  00391	52		 push	 edx
  00392	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00395	05 fe 04 00 00	 add	 eax, 1278		; 000004feH
  0039a	50		 push	 eax
  0039b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0039e	81 c1 f4 04 00
	00		 add	 ecx, 1268		; 000004f4H
  003a4	51		 push	 ecx
  003a5	0f bf 95 70 fa
	ff ff		 movsx	 edx, WORD PTR _subfrNr$[ebp]
  003ac	8d 84 55 64 fa
	ff ff		 lea	 eax, DWORD PTR _T_op$[ebp+edx*2]
  003b3	50		 push	 eax
  003b4	0f bf 8d 7c fa
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  003bb	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  003be	8b 82 f0 04 00
	00		 mov	 eax, DWORD PTR [edx+1264]
  003c4	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  003c7	51		 push	 ecx
  003c8	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  003cb	52		 push	 edx
  003cc	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  003cf	8b 88 a4 08 00
	00		 mov	 ecx, DWORD PTR [eax+2212]
  003d5	51		 push	 ecx
  003d6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  003d9	8b 82 9c 08 00
	00		 mov	 eax, DWORD PTR [edx+2204]
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 _ol_ltp
  003e5	83 c4 24	 add	 esp, 36			; 00000024H
$LN18@cod_amr:

; 472  :       }
; 473  :    }

  003e8	e9 e5 fe ff ff	 jmp	 $LN20@cod_amr
$LN19@cod_amr:

; 474  :    fwc ();                 /* function worst case */

  003ed	e8 00 00 00 00	 call	 _fwc

; 475  : 
; 476  :    test (); test();

  003f2	e8 00 00 00 00	 call	 _test
  003f7	e8 00 00 00 00	 call	 _test

; 477  :    if ((sub(mode, MR475) == 0) || (sub(mode, MR515) == 0))

  003fc	6a 00		 push	 0
  003fe	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00402	50		 push	 eax
  00403	e8 00 00 00 00	 call	 _sub
  00408	83 c4 08	 add	 esp, 8
  0040b	0f bf c8	 movsx	 ecx, ax
  0040e	85 c9		 test	 ecx, ecx
  00410	74 1a		 je	 SHORT $LN16@cod_amr
  00412	6a 01		 push	 1
  00414	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00418	50		 push	 eax
  00419	e8 00 00 00 00	 call	 _sub
  0041e	83 c4 08	 add	 esp, 8
  00421	0f bf c8	 movsx	 ecx, ax
  00424	85 c9		 test	 ecx, ecx
  00426	0f 85 86 00 00
	00		 jne	 $LN17@cod_amr
$LN16@cod_amr:

; 478  :    {
; 479  :       /* Find open loop pitch lag for ONE FRAME ONLY */
; 480  :       /* search on 160 samples */
; 481  :       
; 482  :       ol_ltp(st->pitchOLWghtSt, st->vadSt, mode, &st->wsp[0], &T_op[0],
; 483  :              st->old_lags, st->ol_gain_flg, 1, st->dtx);

  0042c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0042f	8b 88 a8 08 00
	00		 mov	 ecx, DWORD PTR [eax+2216]
  00435	51		 push	 ecx
  00436	6a 01		 push	 1
  00438	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0043b	81 c2 fe 04 00
	00		 add	 edx, 1278		; 000004feH
  00441	52		 push	 edx
  00442	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00445	05 f4 04 00 00	 add	 eax, 1268		; 000004f4H
  0044a	50		 push	 eax
  0044b	b9 02 00 00 00	 mov	 ecx, 2
  00450	6b d1 00	 imul	 edx, ecx, 0
  00453	8d 84 15 64 fa
	ff ff		 lea	 eax, DWORD PTR _T_op$[ebp+edx]
  0045a	50		 push	 eax
  0045b	b9 02 00 00 00	 mov	 ecx, 2
  00460	6b d1 00	 imul	 edx, ecx, 0
  00463	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00466	03 90 f0 04 00
	00		 add	 edx, DWORD PTR [eax+1264]
  0046c	52		 push	 edx
  0046d	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  00470	51		 push	 ecx
  00471	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00474	8b 82 a4 08 00
	00		 mov	 eax, DWORD PTR [edx+2212]
  0047a	50		 push	 eax
  0047b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0047e	8b 91 9c 08 00
	00		 mov	 edx, DWORD PTR [ecx+2204]
  00484	52		 push	 edx
  00485	e8 00 00 00 00	 call	 _ol_ltp
  0048a	83 c4 24	 add	 esp, 36			; 00000024H

; 484  :       T_op[1] = T_op[0];                                     move16 ();

  0048d	b8 02 00 00 00	 mov	 eax, 2
  00492	6b c8 00	 imul	 ecx, eax, 0
  00495	ba 02 00 00 00	 mov	 edx, 2
  0049a	c1 e2 00	 shl	 edx, 0
  0049d	66 8b 84 0d 64
	fa ff ff	 mov	 ax, WORD PTR _T_op$[ebp+ecx]
  004a5	66 89 84 15 64
	fa ff ff	 mov	 WORD PTR _T_op$[ebp+edx], ax
  004ad	e8 00 00 00 00	 call	 _move16
$LN17@cod_amr:

; 485  :    }         
; 486  :    fwc ();                 /* function worst case */

  004b2	e8 00 00 00 00	 call	 _fwc

; 487  :    
; 488  : #ifdef VAD2
; 489  :    if (st->dtx)
; 490  :    {  /* no test() call since this if is only in simulation env */
; 491  :       LTP_flag_update(st->vadSt, mode);
; 492  :    }
; 493  : #endif
; 494  : 
; 495  : #ifndef VAD2
; 496  :    /* run VAD pitch detection */
; 497  :    if (st->dtx)

  004b7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  004ba	83 b8 a8 08 00
	00 00		 cmp	 DWORD PTR [eax+2216], 0
  004c1	74 19		 je	 SHORT $LN15@cod_amr

; 498  :    {  /* no test() call since this if is only in simulation env */
; 499  :       vad_pitch_detection(st->vadSt, T_op);

  004c3	8d 85 64 fa ff
	ff		 lea	 eax, DWORD PTR _T_op$[ebp]
  004c9	50		 push	 eax
  004ca	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  004cd	8b 91 a4 08 00
	00		 mov	 edx, DWORD PTR [ecx+2212]
  004d3	52		 push	 edx
  004d4	e8 00 00 00 00	 call	 _vad_pitch_detection
  004d9	83 c4 08	 add	 esp, 8
$LN15@cod_amr:

; 500  :    } 
; 501  : #endif
; 502  :    fwc ();                 /* function worst case */

  004dc	e8 00 00 00 00	 call	 _fwc

; 503  : 
; 504  :    if (sub(*usedMode, MRDTX) == 0)

  004e1	6a 08		 push	 8
  004e3	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  004e6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 _sub
  004ef	83 c4 08	 add	 esp, 8
  004f2	0f bf d0	 movsx	 edx, ax
  004f5	85 d2		 test	 edx, edx
  004f7	75 05		 jne	 SHORT $LN14@cod_amr

; 505  :    {
; 506  :       goto the_end;

  004f9	e9 f8 09 00 00	 jmp	 $the_end$57
$LN14@cod_amr:

; 507  :    }
; 508  :    
; 509  :    /*------------------------------------------------------------------------*
; 510  :     *          Loop for every subframe in the analysis frame                 *
; 511  :     *------------------------------------------------------------------------*
; 512  :     *  To find the pitch and innovation parameters. The subframe size is     *
; 513  :     *  L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.               *
; 514  :     *     - find the weighted LPC coefficients                               *
; 515  :     *     - find the LPC residual signal res[]                               *
; 516  :     *     - compute the target signal for pitch search                       *
; 517  :     *     - compute impulse response of weighted synthesis filter (h1[])     *
; 518  :     *     - find the closed-loop pitch parameters                            *
; 519  :     *     - encode the pitch dealy                                           *
; 520  :     *     - update the impulse response h1[] by including fixed-gain pitch   *
; 521  :     *     - find target vector for codebook search                           *
; 522  :     *     - codebook search                                                  *
; 523  :     *     - encode codebook address                                          *
; 524  :     *     - VQ of pitch and codebook gains                                   *
; 525  :     *     - find synthesis speech                                            *
; 526  :     *     - update states of weighting filter                                *
; 527  :     *------------------------------------------------------------------------*/
; 528  : 
; 529  :    A = A_t;      /* pointer to interpolated LPC parameters */

  004fe	8d 45 a0	 lea	 eax, DWORD PTR _A_t$[ebp]
  00501	89 85 34 ff ff
	ff		 mov	 DWORD PTR _A$[ebp], eax

; 530  :    Aq = Aq_t;    /* pointer to interpolated quantized LPC parameters */

  00507	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _Aq_t$[ebp]
  0050d	89 85 28 ff ff
	ff		 mov	 DWORD PTR _Aq$[ebp], eax

; 531  : 
; 532  :    evenSubfr = 0;                                                  move16 ();

  00513	33 c0		 xor	 eax, eax
  00515	66 89 85 c4 fa
	ff ff		 mov	 WORD PTR _evenSubfr$[ebp], ax
  0051c	e8 00 00 00 00	 call	 _move16

; 533  :    subfrNr = -1;                                                   move16 ();

  00521	83 c8 ff	 or	 eax, -1
  00524	66 89 85 70 fa
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax
  0052b	e8 00 00 00 00	 call	 _move16

; 534  :    for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)

  00530	33 c0		 xor	 eax, eax
  00532	66 89 85 7c fa
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], ax
  00539	eb 11		 jmp	 SHORT $LN13@cod_amr
$LN12@cod_amr:
  0053b	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00542	83 c0 28	 add	 eax, 40			; 00000028H
  00545	66 89 85 7c fa
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], ax
$LN13@cod_amr:
  0054c	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00553	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00558	0f 8d 62 09 00
	00		 jge	 $LN11@cod_amr

; 535  :    {
; 536  :       subfrNr = add(subfrNr, 1);

  0055e	6a 01		 push	 1
  00560	0f b7 85 70 fa
	ff ff		 movzx	 eax, WORD PTR _subfrNr$[ebp]
  00567	50		 push	 eax
  00568	e8 00 00 00 00	 call	 _add
  0056d	83 c4 08	 add	 esp, 8
  00570	66 89 85 70 fa
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax

; 537  :       evenSubfr = sub(1, evenSubfr);

  00577	0f b7 85 c4 fa
	ff ff		 movzx	 eax, WORD PTR _evenSubfr$[ebp]
  0057e	50		 push	 eax
  0057f	6a 01		 push	 1
  00581	e8 00 00 00 00	 call	 _sub
  00586	83 c4 08	 add	 esp, 8
  00589	66 89 85 c4 fa
	ff ff		 mov	 WORD PTR _evenSubfr$[ebp], ax

; 538  : 
; 539  :       /* Save states for the MR475 mode */
; 540  :       test(); test();

  00590	e8 00 00 00 00	 call	 _test
  00595	e8 00 00 00 00	 call	 _test

; 541  :       if ((evenSubfr != 0) && (sub(*usedMode, MR475) == 0))

  0059a	0f bf 85 c4 fa
	ff ff		 movsx	 eax, WORD PTR _evenSubfr$[ebp]
  005a1	85 c0		 test	 eax, eax
  005a3	74 7a		 je	 SHORT $LN10@cod_amr
  005a5	6a 00		 push	 0
  005a7	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  005aa	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  005ad	51		 push	 ecx
  005ae	e8 00 00 00 00	 call	 _sub
  005b3	83 c4 08	 add	 esp, 8
  005b6	0f bf d0	 movsx	 edx, ax
  005b9	85 d2		 test	 edx, edx
  005bb	75 62		 jne	 SHORT $LN10@cod_amr

; 542  :       {
; 543  :          Copy(st->mem_syn, mem_syn_save, M);

  005bd	6a 0a		 push	 10			; 0000000aH
  005bf	8d 85 14 fb ff
	ff		 lea	 eax, DWORD PTR _mem_syn_save$[ebp]
  005c5	50		 push	 eax
  005c6	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  005c9	81 c1 b0 08 00
	00		 add	 ecx, 2224		; 000008b0H
  005cf	51		 push	 ecx
  005d0	e8 00 00 00 00	 call	 _Copy
  005d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 544  :          Copy(st->mem_w0, mem_w0_save, M);         

  005d8	6a 0a		 push	 10			; 0000000aH
  005da	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _mem_w0_save$[ebp]
  005e0	50		 push	 eax
  005e1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  005e4	81 c1 c4 08 00
	00		 add	 ecx, 2244		; 000008c4H
  005ea	51		 push	 ecx
  005eb	e8 00 00 00 00	 call	 _Copy
  005f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 545  :          Copy(st->mem_err, mem_err_save, M);         

  005f3	6a 0a		 push	 10			; 0000000aH
  005f5	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR _mem_err_save$[ebp]
  005fb	50		 push	 eax
  005fc	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  005ff	81 c1 ec 08 00
	00		 add	 ecx, 2284		; 000008ecH
  00605	51		 push	 ecx
  00606	e8 00 00 00 00	 call	 _Copy
  0060b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 546  :          sharp_save = st->sharp;

  0060e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00611	66 8b 88 54 09
	00 00		 mov	 cx, WORD PTR [eax+2388]
  00618	66 89 8d d0 fa
	ff ff		 mov	 WORD PTR _sharp_save$[ebp], cx
$LN10@cod_amr:

; 547  :       }
; 548  :       
; 549  :       /*-----------------------------------------------------------------*
; 550  :        * - Preprocessing of subframe                                     *
; 551  :        *-----------------------------------------------------------------*/
; 552  :       test();

  0061f	e8 00 00 00 00	 call	 _test

; 553  :       if (sub(*usedMode, MR475) != 0)

  00624	6a 00		 push	 0
  00626	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00629	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0062c	51		 push	 ecx
  0062d	e8 00 00 00 00	 call	 _sub
  00632	83 c4 08	 add	 esp, 8
  00635	0f bf d0	 movsx	 edx, ax
  00638	85 d2		 test	 edx, edx
  0063a	0f 84 a2 00 00
	00		 je	 $LN9@cod_amr

; 554  :       {
; 555  :          subframePreProc(*usedMode, gamma1, gamma1_12k2,
; 556  :                          gamma2, A, Aq, &st->speech[i_subfr],
; 557  :                          st->mem_err, st->mem_w0, st->zero,
; 558  :                          st->ai_zero, &st->exc[i_subfr],
; 559  :                          st->h1, xn, res, st->error);

  00640	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00643	8b 88 50 09 00
	00		 mov	 ecx, DWORD PTR [eax+2384]
  00649	51		 push	 ecx
  0064a	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR _res$[ebp]
  00650	52		 push	 edx
  00651	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00657	50		 push	 eax
  00658	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0065b	8b 91 e8 07 00
	00		 mov	 edx, DWORD PTR [ecx+2024]
  00661	52		 push	 edx
  00662	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00669	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0066c	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00672	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00675	50		 push	 eax
  00676	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00679	81 c1 7c 07 00
	00		 add	 ecx, 1916		; 0000077cH
  0067f	51		 push	 ecx
  00680	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00683	8b 82 e4 07 00
	00		 mov	 eax, DWORD PTR [edx+2020]
  00689	50		 push	 eax
  0068a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0068d	81 c1 c4 08 00
	00		 add	 ecx, 2244		; 000008c4H
  00693	51		 push	 ecx
  00694	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00697	81 c2 ec 08 00
	00		 add	 edx, 2284		; 000008ecH
  0069d	52		 push	 edx
  0069e	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  006a5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  006a8	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  006ae	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  006b1	50		 push	 eax
  006b2	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _Aq$[ebp]
  006b8	51		 push	 ecx
  006b9	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _A$[ebp]
  006bf	52		 push	 edx
  006c0	68 00 00 00 00	 push	 OFFSET _gamma2
  006c5	68 00 00 00 00	 push	 OFFSET _gamma1_12k2
  006ca	68 00 00 00 00	 push	 OFFSET _gamma1
  006cf	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  006d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  006d4	51		 push	 ecx
  006d5	e8 00 00 00 00	 call	 _subframePreProc
  006da	83 c4 40	 add	 esp, 64			; 00000040H

; 560  :       }
; 561  :       else

  006dd	e9 c5 00 00 00	 jmp	 $LN8@cod_amr
$LN9@cod_amr:

; 562  :       { /* MR475 */
; 563  :          subframePreProc(*usedMode, gamma1, gamma1_12k2, 
; 564  :                          gamma2, A, Aq, &st->speech[i_subfr],
; 565  :                          st->mem_err, mem_w0_save, st->zero,
; 566  :                          st->ai_zero, &st->exc[i_subfr],
; 567  :                          st->h1, xn, res, st->error);

  006e2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  006e5	8b 88 50 09 00
	00		 mov	 ecx, DWORD PTR [eax+2384]
  006eb	51		 push	 ecx
  006ec	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR _res$[ebp]
  006f2	52		 push	 edx
  006f3	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  006f9	50		 push	 eax
  006fa	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  006fd	8b 91 e8 07 00
	00		 mov	 edx, DWORD PTR [ecx+2024]
  00703	52		 push	 edx
  00704	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  0070b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0070e	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00714	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00717	50		 push	 eax
  00718	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0071b	81 c1 7c 07 00
	00		 add	 ecx, 1916		; 0000077cH
  00721	51		 push	 ecx
  00722	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00725	8b 82 e4 07 00
	00		 mov	 eax, DWORD PTR [edx+2020]
  0072b	50		 push	 eax
  0072c	8d 8d f8 fa ff
	ff		 lea	 ecx, DWORD PTR _mem_w0_save$[ebp]
  00732	51		 push	 ecx
  00733	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00736	81 c2 ec 08 00
	00		 add	 edx, 2284		; 000008ecH
  0073c	52		 push	 edx
  0073d	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00744	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00747	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  0074d	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00750	50		 push	 eax
  00751	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _Aq$[ebp]
  00757	51		 push	 ecx
  00758	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _A$[ebp]
  0075e	52		 push	 edx
  0075f	68 00 00 00 00	 push	 OFFSET _gamma2
  00764	68 00 00 00 00	 push	 OFFSET _gamma1_12k2
  00769	68 00 00 00 00	 push	 OFFSET _gamma1
  0076e	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00771	8b 08		 mov	 ecx, DWORD PTR [eax]
  00773	51		 push	 ecx
  00774	e8 00 00 00 00	 call	 _subframePreProc
  00779	83 c4 40	 add	 esp, 64			; 00000040H

; 568  : 
; 569  :          /* save impulse response (modified in cbsearch) */
; 570  :          test ();

  0077c	e8 00 00 00 00	 call	 _test

; 571  :          if (evenSubfr != 0)

  00781	0f bf 85 c4 fa
	ff ff		 movsx	 eax, WORD PTR _evenSubfr$[ebp]
  00788	85 c0		 test	 eax, eax
  0078a	74 1b		 je	 SHORT $LN8@cod_amr

; 572  :          {
; 573  :              Copy (st->h1, h1_sf0, L_SUBFR);

  0078c	6a 28		 push	 40			; 00000028H
  0078e	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _h1_sf0$[ebp]
  00794	50		 push	 eax
  00795	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00798	8b 91 e8 07 00
	00		 mov	 edx, DWORD PTR [ecx+2024]
  0079e	52		 push	 edx
  0079f	e8 00 00 00 00	 call	 _Copy
  007a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@cod_amr:

; 574  :          }
; 575  :       }
; 576  :       
; 577  :       /* copy the LP residual (res2 is modified in the CL LTP search)    */
; 578  :       Copy (res, res2, L_SUBFR);

  007a7	6a 28		 push	 40			; 00000028H
  007a9	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR _res2$[ebp]
  007af	50		 push	 eax
  007b0	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR _res$[ebp]
  007b6	51		 push	 ecx
  007b7	e8 00 00 00 00	 call	 _Copy
  007bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 579  : 
; 580  :       fwc ();                 /* function worst case */

  007bf	e8 00 00 00 00	 call	 _fwc

; 581  :     
; 582  :       /*-----------------------------------------------------------------*
; 583  :        * - Closed-loop LTP search                                        *
; 584  :        *-----------------------------------------------------------------*/
; 585  :       cl_ltp(st->clLtpSt, st->tonStabSt, *usedMode, i_subfr, T_op, st->h1, 
; 586  :              &st->exc[i_subfr], res2, xn, lsp_flag, xn2, y1, 
; 587  :              &T0, &T0_frac, &gain_pit, gCoeff, &ana,
; 588  :              &gp_limit);

  007c4	8d 85 1c fa ff
	ff		 lea	 eax, DWORD PTR _gp_limit$[ebp]
  007ca	50		 push	 eax
  007cb	8d 4d 14	 lea	 ecx, DWORD PTR _ana$[ebp]
  007ce	51		 push	 ecx
  007cf	8d 95 40 fd ff
	ff		 lea	 edx, DWORD PTR _gCoeff$[ebp]
  007d5	52		 push	 edx
  007d6	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  007dc	50		 push	 eax
  007dd	8d 8d 4c fa ff
	ff		 lea	 ecx, DWORD PTR _T0_frac$[ebp]
  007e3	51		 push	 ecx
  007e4	8d 95 58 fa ff
	ff		 lea	 edx, DWORD PTR _T0$[ebp]
  007ea	52		 push	 edx
  007eb	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  007f1	50		 push	 eax
  007f2	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR _xn2$[ebp]
  007f8	51		 push	 ecx
  007f9	0f b7 95 28 fa
	ff ff		 movzx	 edx, WORD PTR _lsp_flag$[ebp]
  00800	52		 push	 edx
  00801	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00807	50		 push	 eax
  00808	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR _res2$[ebp]
  0080e	51		 push	 ecx
  0080f	0f bf 95 7c fa
	ff ff		 movsx	 edx, WORD PTR _i_subfr$[ebp]
  00816	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00819	8b 88 78 07 00
	00		 mov	 ecx, DWORD PTR [eax+1912]
  0081f	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00822	52		 push	 edx
  00823	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00826	8b 88 e8 07 00
	00		 mov	 ecx, DWORD PTR [eax+2024]
  0082c	51		 push	 ecx
  0082d	8d 95 64 fa ff
	ff		 lea	 edx, DWORD PTR _T_op$[ebp]
  00833	52		 push	 edx
  00834	0f b7 85 7c fa
	ff ff		 movzx	 eax, WORD PTR _i_subfr$[ebp]
  0083b	50		 push	 eax
  0083c	8b 4d 18	 mov	 ecx, DWORD PTR _usedMode$[ebp]
  0083f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00841	52		 push	 edx
  00842	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00845	8b 88 a0 08 00
	00		 mov	 ecx, DWORD PTR [eax+2208]
  0084b	51		 push	 ecx
  0084c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0084f	8b 82 94 08 00
	00		 mov	 eax, DWORD PTR [edx+2196]
  00855	50		 push	 eax
  00856	e8 00 00 00 00	 call	 _cl_ltp
  0085b	83 c4 48	 add	 esp, 72			; 00000048H

; 589  : 
; 590  :       /* update LTP lag history */
; 591  :       move16 (); test(); test ();

  0085e	e8 00 00 00 00	 call	 _move16
  00863	e8 00 00 00 00	 call	 _test
  00868	e8 00 00 00 00	 call	 _test

; 592  :       if ((subfrNr == 0) && (st->ol_gain_flg[0] > 0))

  0086d	0f bf 85 70 fa
	ff ff		 movsx	 eax, WORD PTR _subfrNr$[ebp]
  00874	85 c0		 test	 eax, eax
  00876	75 36		 jne	 SHORT $LN6@cod_amr
  00878	b8 02 00 00 00	 mov	 eax, 2
  0087d	6b c8 00	 imul	 ecx, eax, 0
  00880	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00883	0f bf 84 0a fe
	04 00 00	 movsx	 eax, WORD PTR [edx+ecx+1278]
  0088b	85 c0		 test	 eax, eax
  0088d	7e 1f		 jle	 SHORT $LN6@cod_amr

; 593  :       {
; 594  :          st->old_lags[1] = T0;     move16 ();

  0088f	b8 02 00 00 00	 mov	 eax, 2
  00894	c1 e0 00	 shl	 eax, 0
  00897	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0089a	66 8b 95 58 fa
	ff ff		 mov	 dx, WORD PTR _T0$[ebp]
  008a1	66 89 94 01 f4
	04 00 00	 mov	 WORD PTR [ecx+eax+1268], dx
  008a9	e8 00 00 00 00	 call	 _move16
$LN6@cod_amr:

; 595  :       }
; 596  :       
; 597  :       move16 (); test(); test ();

  008ae	e8 00 00 00 00	 call	 _move16
  008b3	e8 00 00 00 00	 call	 _test
  008b8	e8 00 00 00 00	 call	 _test

; 598  :       if ((sub(subfrNr, 3) == 0) && (st->ol_gain_flg[1] > 0))

  008bd	6a 03		 push	 3
  008bf	0f b7 85 70 fa
	ff ff		 movzx	 eax, WORD PTR _subfrNr$[ebp]
  008c6	50		 push	 eax
  008c7	e8 00 00 00 00	 call	 _sub
  008cc	83 c4 08	 add	 esp, 8
  008cf	0f bf c8	 movsx	 ecx, ax
  008d2	85 c9		 test	 ecx, ecx
  008d4	75 36		 jne	 SHORT $LN5@cod_amr
  008d6	b8 02 00 00 00	 mov	 eax, 2
  008db	c1 e0 00	 shl	 eax, 0
  008de	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  008e1	0f bf 94 01 fe
	04 00 00	 movsx	 edx, WORD PTR [ecx+eax+1278]
  008e9	85 d2		 test	 edx, edx
  008eb	7e 1f		 jle	 SHORT $LN5@cod_amr

; 599  :       {
; 600  :          st->old_lags[0] = T0;     move16 ();

  008ed	b8 02 00 00 00	 mov	 eax, 2
  008f2	6b c8 00	 imul	 ecx, eax, 0
  008f5	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  008f8	66 8b 85 58 fa
	ff ff		 mov	 ax, WORD PTR _T0$[ebp]
  008ff	66 89 84 0a f4
	04 00 00	 mov	 WORD PTR [edx+ecx+1268], ax
  00907	e8 00 00 00 00	 call	 _move16
$LN5@cod_amr:

; 601  :       }      
; 602  : 
; 603  :       fwc ();                 /* function worst case */

  0090c	e8 00 00 00 00	 call	 _fwc

; 604  :       
; 605  :       /*-----------------------------------------------------------------*
; 606  :        * - Inovative codebook search (find index and gain)               *
; 607  :        *-----------------------------------------------------------------*/
; 608  :       cbsearch(xn2, st->h1, T0, st->sharp, gain_pit, res2, 
; 609  :                code, y2, &ana, *usedMode, subfrNr);

  00911	0f b7 85 70 fa
	ff ff		 movzx	 eax, WORD PTR _subfrNr$[ebp]
  00918	50		 push	 eax
  00919	8b 4d 18	 mov	 ecx, DWORD PTR _usedMode$[ebp]
  0091c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0091e	52		 push	 edx
  0091f	8d 45 14	 lea	 eax, DWORD PTR _ana$[ebp]
  00922	50		 push	 eax
  00923	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  00929	51		 push	 ecx
  0092a	8d 95 04 fe ff
	ff		 lea	 edx, DWORD PTR _code$[ebp]
  00930	52		 push	 edx
  00931	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR _res2$[ebp]
  00937	50		 push	 eax
  00938	0f b7 8d 40 fa
	ff ff		 movzx	 ecx, WORD PTR _gain_pit$[ebp]
  0093f	51		 push	 ecx
  00940	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00943	0f b7 82 54 09
	00 00		 movzx	 eax, WORD PTR [edx+2388]
  0094a	50		 push	 eax
  0094b	0f b7 8d 58 fa
	ff ff		 movzx	 ecx, WORD PTR _T0$[ebp]
  00952	51		 push	 ecx
  00953	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00956	8b 82 e8 07 00
	00		 mov	 eax, DWORD PTR [edx+2024]
  0095c	50		 push	 eax
  0095d	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR _xn2$[ebp]
  00963	51		 push	 ecx
  00964	e8 00 00 00 00	 call	 _cbsearch
  00969	83 c4 2c	 add	 esp, 44			; 0000002cH

; 610  :       
; 611  :       fwc ();                 /* function worst case */

  0096c	e8 00 00 00 00	 call	 _fwc

; 612  :     
; 613  :       /*------------------------------------------------------*
; 614  :        * - Quantization of gains.                             *
; 615  :        *------------------------------------------------------*/
; 616  :       gainQuant(st->gainQuantSt, *usedMode, res, &st->exc[i_subfr], code,
; 617  :                 xn, xn2,  y1, y2, gCoeff, evenSubfr, gp_limit,
; 618  :                 &gain_pit_sf0, &gain_code_sf0,
; 619  :                 &gain_pit, &gain_code, &ana);

  00971	8d 45 14	 lea	 eax, DWORD PTR _ana$[ebp]
  00974	50		 push	 eax
  00975	8d 8d 34 fa ff
	ff		 lea	 ecx, DWORD PTR _gain_code$[ebp]
  0097b	51		 push	 ecx
  0097c	8d 95 40 fa ff
	ff		 lea	 edx, DWORD PTR _gain_pit$[ebp]
  00982	52		 push	 edx
  00983	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR _gain_code_sf0$[ebp]
  00989	50		 push	 eax
  0098a	8d 8d 94 fa ff
	ff		 lea	 ecx, DWORD PTR _gain_pit_sf0$[ebp]
  00990	51		 push	 ecx
  00991	0f b7 95 1c fa
	ff ff		 movzx	 edx, WORD PTR _gp_limit$[ebp]
  00998	52		 push	 edx
  00999	0f b7 85 c4 fa
	ff ff		 movzx	 eax, WORD PTR _evenSubfr$[ebp]
  009a0	50		 push	 eax
  009a1	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR _gCoeff$[ebp]
  009a7	51		 push	 ecx
  009a8	8d 95 54 fd ff
	ff		 lea	 edx, DWORD PTR _y2$[ebp]
  009ae	52		 push	 edx
  009af	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  009b5	50		 push	 eax
  009b6	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR _xn2$[ebp]
  009bc	51		 push	 ecx
  009bd	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _xn$[ebp]
  009c3	52		 push	 edx
  009c4	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  009ca	50		 push	 eax
  009cb	0f bf 8d 7c fa
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  009d2	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  009d5	8b 82 78 07 00
	00		 mov	 eax, DWORD PTR [edx+1912]
  009db	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  009de	51		 push	 ecx
  009df	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR _res$[ebp]
  009e5	52		 push	 edx
  009e6	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  009e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  009eb	51		 push	 ecx
  009ec	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  009ef	8b 82 98 08 00
	00		 mov	 eax, DWORD PTR [edx+2200]
  009f5	50		 push	 eax
  009f6	e8 00 00 00 00	 call	 _gainQuant
  009fb	83 c4 44	 add	 esp, 68			; 00000044H

; 620  :       
; 621  :       fwc ();                 /* function worst case */

  009fe	e8 00 00 00 00	 call	 _fwc

; 622  : 
; 623  :       /* update gain history */
; 624  :       update_gp_clipping(st->tonStabSt, gain_pit);

  00a03	0f b7 85 40 fa
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  00a0a	50		 push	 eax
  00a0b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00a0e	8b 91 a0 08 00
	00		 mov	 edx, DWORD PTR [ecx+2208]
  00a14	52		 push	 edx
  00a15	e8 00 00 00 00	 call	 _update_gp_clipping
  00a1a	83 c4 08	 add	 esp, 8

; 625  :       
; 626  :       test(); 

  00a1d	e8 00 00 00 00	 call	 _test

; 627  :       if (sub(*usedMode, MR475) != 0)

  00a22	6a 00		 push	 0
  00a24	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00a27	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00a2a	51		 push	 ecx
  00a2b	e8 00 00 00 00	 call	 _sub
  00a30	83 c4 08	 add	 esp, 8
  00a33	0f bf d0	 movsx	 edx, ax
  00a36	85 d2		 test	 edx, edx
  00a38	0f 84 8c 00 00
	00		 je	 $LN4@cod_amr

; 628  :       {
; 629  :          /* Subframe Post Porcessing */
; 630  :          subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
; 631  :                           gain_code, Aq, synth, xn, code, y1, y2, st->mem_syn,
; 632  :                           st->mem_err, st->mem_w0, st->exc, &st->sharp);

  00a3e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00a41	05 54 09 00 00	 add	 eax, 2388		; 00000954H
  00a46	50		 push	 eax
  00a47	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00a4a	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00a50	52		 push	 edx
  00a51	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00a54	05 c4 08 00 00	 add	 eax, 2244		; 000008c4H
  00a59	50		 push	 eax
  00a5a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00a5d	81 c1 ec 08 00
	00		 add	 ecx, 2284		; 000008ecH
  00a63	51		 push	 ecx
  00a64	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00a67	81 c2 b0 08 00
	00		 add	 edx, 2224		; 000008b0H
  00a6d	52		 push	 edx
  00a6e	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _y2$[ebp]
  00a74	50		 push	 eax
  00a75	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _y1$[ebp]
  00a7b	51		 push	 ecx
  00a7c	8d 95 04 fe ff
	ff		 lea	 edx, DWORD PTR _code$[ebp]
  00a82	52		 push	 edx
  00a83	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00a89	50		 push	 eax
  00a8a	8b 4d 1c	 mov	 ecx, DWORD PTR _synth$[ebp]
  00a8d	51		 push	 ecx
  00a8e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _Aq$[ebp]
  00a94	52		 push	 edx
  00a95	0f b7 85 34 fa
	ff ff		 movzx	 eax, WORD PTR _gain_code$[ebp]
  00a9c	50		 push	 eax
  00a9d	0f b7 8d 40 fa
	ff ff		 movzx	 ecx, WORD PTR _gain_pit$[ebp]
  00aa4	51		 push	 ecx
  00aa5	0f b7 95 7c fa
	ff ff		 movzx	 edx, WORD PTR _i_subfr$[ebp]
  00aac	52		 push	 edx
  00aad	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00ab0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab2	51		 push	 ecx
  00ab3	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00ab6	8b 82 80 02 00
	00		 mov	 eax, DWORD PTR [edx+640]
  00abc	50		 push	 eax
  00abd	e8 00 00 00 00	 call	 _subframePostProc
  00ac2	83 c4 40	 add	 esp, 64			; 00000040H

; 633  :       }
; 634  :       else

  00ac5	e9 ce 03 00 00	 jmp	 $LN3@cod_amr
$LN4@cod_amr:

; 635  :       {
; 636  :          test();

  00aca	e8 00 00 00 00	 call	 _test

; 637  :          if (evenSubfr != 0)

  00acf	0f bf 85 c4 fa
	ff ff		 movsx	 eax, WORD PTR _evenSubfr$[ebp]
  00ad6	85 c0		 test	 eax, eax
  00ad8	0f 84 1e 01 00
	00		 je	 $LN2@cod_amr

; 638  :          {
; 639  :             i_subfr_sf0 = i_subfr;             move16 ();

  00ade	66 8b 85 7c fa
	ff ff		 mov	 ax, WORD PTR _i_subfr$[ebp]
  00ae5	66 89 85 a0 fa
	ff ff		 mov	 WORD PTR _i_subfr_sf0$[ebp], ax
  00aec	e8 00 00 00 00	 call	 _move16

; 640  :             Copy(xn, xn_sf0, L_SUBFR);

  00af1	6a 28		 push	 40			; 00000028H
  00af3	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR _xn_sf0$[ebp]
  00af9	50		 push	 eax
  00afa	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _xn$[ebp]
  00b00	51		 push	 ecx
  00b01	e8 00 00 00 00	 call	 _Copy
  00b06	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  :             Copy(y2, y2_sf0, L_SUBFR);          

  00b09	6a 28		 push	 40			; 00000028H
  00b0b	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _y2_sf0$[ebp]
  00b11	50		 push	 eax
  00b12	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR _y2$[ebp]
  00b18	51		 push	 ecx
  00b19	e8 00 00 00 00	 call	 _Copy
  00b1e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  :             Copy(code, code_sf0, L_SUBFR);

  00b21	6a 28		 push	 40			; 00000028H
  00b23	8d 85 88 fb ff
	ff		 lea	 eax, DWORD PTR _code_sf0$[ebp]
  00b29	50		 push	 eax
  00b2a	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR _code$[ebp]
  00b30	51		 push	 ecx
  00b31	e8 00 00 00 00	 call	 _Copy
  00b36	83 c4 0c	 add	 esp, 12			; 0000000cH

; 643  :             T0_sf0 = T0;                       move16 ();

  00b39	66 8b 85 58 fa
	ff ff		 mov	 ax, WORD PTR _T0$[ebp]
  00b40	66 89 85 b8 fa
	ff ff		 mov	 WORD PTR _T0_sf0$[ebp], ax
  00b47	e8 00 00 00 00	 call	 _move16

; 644  :             T0_frac_sf0 = T0_frac;             move16 ();

  00b4c	66 8b 85 4c fa
	ff ff		 mov	 ax, WORD PTR _T0_frac$[ebp]
  00b53	66 89 85 ac fa
	ff ff		 mov	 WORD PTR _T0_frac_sf0$[ebp], ax
  00b5a	e8 00 00 00 00	 call	 _move16

; 645  :             
; 646  :             /* Subframe Post Porcessing */
; 647  :             subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
; 648  :                              gain_code, Aq, synth, xn, code, y1, y2,
; 649  :                              mem_syn_save, st->mem_err, mem_w0_save,
; 650  :                              st->exc, &st->sharp);

  00b5f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00b62	05 54 09 00 00	 add	 eax, 2388		; 00000954H
  00b67	50		 push	 eax
  00b68	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00b6b	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00b71	52		 push	 edx
  00b72	8d 85 f8 fa ff
	ff		 lea	 eax, DWORD PTR _mem_w0_save$[ebp]
  00b78	50		 push	 eax
  00b79	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00b7c	81 c1 ec 08 00
	00		 add	 ecx, 2284		; 000008ecH
  00b82	51		 push	 ecx
  00b83	8d 95 14 fb ff
	ff		 lea	 edx, DWORD PTR _mem_syn_save$[ebp]
  00b89	52		 push	 edx
  00b8a	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _y2$[ebp]
  00b90	50		 push	 eax
  00b91	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _y1$[ebp]
  00b97	51		 push	 ecx
  00b98	8d 95 04 fe ff
	ff		 lea	 edx, DWORD PTR _code$[ebp]
  00b9e	52		 push	 edx
  00b9f	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00ba5	50		 push	 eax
  00ba6	8b 4d 1c	 mov	 ecx, DWORD PTR _synth$[ebp]
  00ba9	51		 push	 ecx
  00baa	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _Aq$[ebp]
  00bb0	52		 push	 edx
  00bb1	0f b7 85 34 fa
	ff ff		 movzx	 eax, WORD PTR _gain_code$[ebp]
  00bb8	50		 push	 eax
  00bb9	0f b7 8d 40 fa
	ff ff		 movzx	 ecx, WORD PTR _gain_pit$[ebp]
  00bc0	51		 push	 ecx
  00bc1	0f b7 95 7c fa
	ff ff		 movzx	 edx, WORD PTR _i_subfr$[ebp]
  00bc8	52		 push	 edx
  00bc9	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00bcc	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bce	51		 push	 ecx
  00bcf	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00bd2	8b 82 80 02 00
	00		 mov	 eax, DWORD PTR [edx+640]
  00bd8	50		 push	 eax
  00bd9	e8 00 00 00 00	 call	 _subframePostProc
  00bde	83 c4 40	 add	 esp, 64			; 00000040H

; 651  :             st->sharp = sharp_save;                         move16();

  00be1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00be4	66 8b 8d d0 fa
	ff ff		 mov	 cx, WORD PTR _sharp_save$[ebp]
  00beb	66 89 88 54 09
	00 00		 mov	 WORD PTR [eax+2388], cx
  00bf2	e8 00 00 00 00	 call	 _move16

; 652  :          }
; 653  :          else

  00bf7	e9 9c 02 00 00	 jmp	 $LN3@cod_amr
$LN2@cod_amr:

; 654  :          {
; 655  :             /* update both subframes for the MR475 */
; 656  :             
; 657  :             /* Restore states for the MR475 mode */
; 658  :             Copy(mem_err_save, st->mem_err, M);         

  00bfc	6a 0a		 push	 10			; 0000000aH
  00bfe	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00c01	05 ec 08 00 00	 add	 eax, 2284		; 000008ecH
  00c06	50		 push	 eax
  00c07	8d 8d dc fa ff
	ff		 lea	 ecx, DWORD PTR _mem_err_save$[ebp]
  00c0d	51		 push	 ecx
  00c0e	e8 00 00 00 00	 call	 _Copy
  00c13	83 c4 0c	 add	 esp, 12			; 0000000cH

; 659  :             
; 660  :             /* re-build excitation for sf 0 */
; 661  :             Pred_lt_3or6(&st->exc[i_subfr_sf0], T0_sf0, T0_frac_sf0,
; 662  :                          L_SUBFR, 1);

  00c16	6a 01		 push	 1
  00c18	6a 28		 push	 40			; 00000028H
  00c1a	0f b7 85 ac fa
	ff ff		 movzx	 eax, WORD PTR _T0_frac_sf0$[ebp]
  00c21	50		 push	 eax
  00c22	0f b7 8d b8 fa
	ff ff		 movzx	 ecx, WORD PTR _T0_sf0$[ebp]
  00c29	51		 push	 ecx
  00c2a	0f bf 95 a0 fa
	ff ff		 movsx	 edx, WORD PTR _i_subfr_sf0$[ebp]
  00c31	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00c34	8b 88 78 07 00
	00		 mov	 ecx, DWORD PTR [eax+1912]
  00c3a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00c3d	52		 push	 edx
  00c3e	e8 00 00 00 00	 call	 _Pred_lt_3or6
  00c43	83 c4 14	 add	 esp, 20			; 00000014H

; 663  :             Convolve(&st->exc[i_subfr_sf0], h1_sf0, y1, L_SUBFR);

  00c46	6a 28		 push	 40			; 00000028H
  00c48	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  00c4e	50		 push	 eax
  00c4f	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _h1_sf0$[ebp]
  00c55	51		 push	 ecx
  00c56	0f bf 95 a0 fa
	ff ff		 movsx	 edx, WORD PTR _i_subfr_sf0$[ebp]
  00c5d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00c60	8b 88 78 07 00
	00		 mov	 ecx, DWORD PTR [eax+1912]
  00c66	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00c69	52		 push	 edx
  00c6a	e8 00 00 00 00	 call	 _Convolve
  00c6f	83 c4 10	 add	 esp, 16			; 00000010H

; 664  :             
; 665  :             Aq -= MP1;

  00c72	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _Aq$[ebp]
  00c78	83 e8 16	 sub	 eax, 22			; 00000016H
  00c7b	89 85 28 ff ff
	ff		 mov	 DWORD PTR _Aq$[ebp], eax

; 666  :             subframePostProc(st->speech, *usedMode, i_subfr_sf0,
; 667  :                              gain_pit_sf0, gain_code_sf0, Aq,
; 668  :                              synth, xn_sf0, code_sf0, y1, y2_sf0,
; 669  :                              st->mem_syn, st->mem_err, st->mem_w0, st->exc,
; 670  :                              &sharp_save); /* overwrites sharp_save */

  00c81	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR _sharp_save$[ebp]
  00c87	50		 push	 eax
  00c88	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00c8b	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00c91	52		 push	 edx
  00c92	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00c95	05 c4 08 00 00	 add	 eax, 2244		; 000008c4H
  00c9a	50		 push	 eax
  00c9b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00c9e	81 c1 ec 08 00
	00		 add	 ecx, 2284		; 000008ecH
  00ca4	51		 push	 ecx
  00ca5	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00ca8	81 c2 b0 08 00
	00		 add	 edx, 2224		; 000008b0H
  00cae	52		 push	 edx
  00caf	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _y2_sf0$[ebp]
  00cb5	50		 push	 eax
  00cb6	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _y1$[ebp]
  00cbc	51		 push	 ecx
  00cbd	8d 95 88 fb ff
	ff		 lea	 edx, DWORD PTR _code_sf0$[ebp]
  00cc3	52		 push	 edx
  00cc4	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR _xn_sf0$[ebp]
  00cca	50		 push	 eax
  00ccb	8b 4d 1c	 mov	 ecx, DWORD PTR _synth$[ebp]
  00cce	51		 push	 ecx
  00ccf	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _Aq$[ebp]
  00cd5	52		 push	 edx
  00cd6	0f b7 85 88 fa
	ff ff		 movzx	 eax, WORD PTR _gain_code_sf0$[ebp]
  00cdd	50		 push	 eax
  00cde	0f b7 8d 94 fa
	ff ff		 movzx	 ecx, WORD PTR _gain_pit_sf0$[ebp]
  00ce5	51		 push	 ecx
  00ce6	0f b7 95 a0 fa
	ff ff		 movzx	 edx, WORD PTR _i_subfr_sf0$[ebp]
  00ced	52		 push	 edx
  00cee	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00cf1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cf3	51		 push	 ecx
  00cf4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00cf7	8b 82 80 02 00
	00		 mov	 eax, DWORD PTR [edx+640]
  00cfd	50		 push	 eax
  00cfe	e8 00 00 00 00	 call	 _subframePostProc
  00d03	83 c4 40	 add	 esp, 64			; 00000040H

; 671  :             Aq += MP1;

  00d06	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _Aq$[ebp]
  00d0c	83 c0 16	 add	 eax, 22			; 00000016H
  00d0f	89 85 28 ff ff
	ff		 mov	 DWORD PTR _Aq$[ebp], eax

; 672  :             
; 673  :             /* re-run pre-processing to get xn right (needed by postproc) */
; 674  :             /* (this also reconstructs the unsharpened h1 for sf 1)       */
; 675  :             subframePreProc(*usedMode, gamma1, gamma1_12k2,
; 676  :                             gamma2, A, Aq, &st->speech[i_subfr],
; 677  :                             st->mem_err, st->mem_w0, st->zero,
; 678  :                             st->ai_zero, &st->exc[i_subfr],
; 679  :                             st->h1, xn, res, st->error);

  00d15	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00d18	8b 88 50 09 00
	00		 mov	 ecx, DWORD PTR [eax+2384]
  00d1e	51		 push	 ecx
  00d1f	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR _res$[ebp]
  00d25	52		 push	 edx
  00d26	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00d2c	50		 push	 eax
  00d2d	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d30	8b 91 e8 07 00
	00		 mov	 edx, DWORD PTR [ecx+2024]
  00d36	52		 push	 edx
  00d37	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00d3e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d41	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00d47	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00d4a	50		 push	 eax
  00d4b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d4e	81 c1 7c 07 00
	00		 add	 ecx, 1916		; 0000077cH
  00d54	51		 push	 ecx
  00d55	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00d58	8b 82 e4 07 00
	00		 mov	 eax, DWORD PTR [edx+2020]
  00d5e	50		 push	 eax
  00d5f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d62	81 c1 c4 08 00
	00		 add	 ecx, 2244		; 000008c4H
  00d68	51		 push	 ecx
  00d69	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00d6c	81 c2 ec 08 00
	00		 add	 edx, 2284		; 000008ecH
  00d72	52		 push	 edx
  00d73	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00d7a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d7d	8b 91 80 02 00
	00		 mov	 edx, DWORD PTR [ecx+640]
  00d83	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00d86	50		 push	 eax
  00d87	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _Aq$[ebp]
  00d8d	51		 push	 ecx
  00d8e	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _A$[ebp]
  00d94	52		 push	 edx
  00d95	68 00 00 00 00	 push	 OFFSET _gamma2
  00d9a	68 00 00 00 00	 push	 OFFSET _gamma1_12k2
  00d9f	68 00 00 00 00	 push	 OFFSET _gamma1
  00da4	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00da7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00da9	51		 push	 ecx
  00daa	e8 00 00 00 00	 call	 _subframePreProc
  00daf	83 c4 40	 add	 esp, 64			; 00000040H

; 680  :             
; 681  :             /* re-build excitation sf 1 (changed if lag < L_SUBFR) */
; 682  :             Pred_lt_3or6(&st->exc[i_subfr], T0, T0_frac, L_SUBFR, 1);

  00db2	6a 01		 push	 1
  00db4	6a 28		 push	 40			; 00000028H
  00db6	0f b7 85 4c fa
	ff ff		 movzx	 eax, WORD PTR _T0_frac$[ebp]
  00dbd	50		 push	 eax
  00dbe	0f b7 8d 58 fa
	ff ff		 movzx	 ecx, WORD PTR _T0$[ebp]
  00dc5	51		 push	 ecx
  00dc6	0f bf 95 7c fa
	ff ff		 movsx	 edx, WORD PTR _i_subfr$[ebp]
  00dcd	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00dd0	8b 88 78 07 00
	00		 mov	 ecx, DWORD PTR [eax+1912]
  00dd6	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00dd9	52		 push	 edx
  00dda	e8 00 00 00 00	 call	 _Pred_lt_3or6
  00ddf	83 c4 14	 add	 esp, 20			; 00000014H

; 683  :             Convolve(&st->exc[i_subfr], st->h1, y1, L_SUBFR);

  00de2	6a 28		 push	 40			; 00000028H
  00de4	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _y1$[ebp]
  00dea	50		 push	 eax
  00deb	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00dee	8b 91 e8 07 00
	00		 mov	 edx, DWORD PTR [ecx+2024]
  00df4	52		 push	 edx
  00df5	0f bf 85 7c fa
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00dfc	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00dff	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00e05	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00e08	50		 push	 eax
  00e09	e8 00 00 00 00	 call	 _Convolve
  00e0e	83 c4 10	 add	 esp, 16			; 00000010H

; 684  :             
; 685  :             subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
; 686  :                              gain_code, Aq, synth, xn, code, y1, y2,
; 687  :                              st->mem_syn, st->mem_err, st->mem_w0,
; 688  :                              st->exc, &st->sharp);

  00e11	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00e14	05 54 09 00 00	 add	 eax, 2388		; 00000954H
  00e19	50		 push	 eax
  00e1a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00e1d	8b 91 78 07 00
	00		 mov	 edx, DWORD PTR [ecx+1912]
  00e23	52		 push	 edx
  00e24	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00e27	05 c4 08 00 00	 add	 eax, 2244		; 000008c4H
  00e2c	50		 push	 eax
  00e2d	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00e30	81 c1 ec 08 00
	00		 add	 ecx, 2284		; 000008ecH
  00e36	51		 push	 ecx
  00e37	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00e3a	81 c2 b0 08 00
	00		 add	 edx, 2224		; 000008b0H
  00e40	52		 push	 edx
  00e41	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _y2$[ebp]
  00e47	50		 push	 eax
  00e48	8d 8d ac fd ff
	ff		 lea	 ecx, DWORD PTR _y1$[ebp]
  00e4e	51		 push	 ecx
  00e4f	8d 95 04 fe ff
	ff		 lea	 edx, DWORD PTR _code$[ebp]
  00e55	52		 push	 edx
  00e56	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _xn$[ebp]
  00e5c	50		 push	 eax
  00e5d	8b 4d 1c	 mov	 ecx, DWORD PTR _synth$[ebp]
  00e60	51		 push	 ecx
  00e61	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _Aq$[ebp]
  00e67	52		 push	 edx
  00e68	0f b7 85 34 fa
	ff ff		 movzx	 eax, WORD PTR _gain_code$[ebp]
  00e6f	50		 push	 eax
  00e70	0f b7 8d 40 fa
	ff ff		 movzx	 ecx, WORD PTR _gain_pit$[ebp]
  00e77	51		 push	 ecx
  00e78	0f b7 95 7c fa
	ff ff		 movzx	 edx, WORD PTR _i_subfr$[ebp]
  00e7f	52		 push	 edx
  00e80	8b 45 18	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00e83	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e85	51		 push	 ecx
  00e86	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00e89	8b 82 80 02 00
	00		 mov	 eax, DWORD PTR [edx+640]
  00e8f	50		 push	 eax
  00e90	e8 00 00 00 00	 call	 _subframePostProc
  00e95	83 c4 40	 add	 esp, 64			; 00000040H
$LN3@cod_amr:

; 689  :          }
; 690  :       }      
; 691  :                
; 692  :       fwc ();                 /* function worst case */

  00e98	e8 00 00 00 00	 call	 _fwc

; 693  :           
; 694  :       A += MP1;    /* interpolated LPC parameters for next subframe */

  00e9d	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _A$[ebp]
  00ea3	83 c0 16	 add	 eax, 22			; 00000016H
  00ea6	89 85 34 ff ff
	ff		 mov	 DWORD PTR _A$[ebp], eax

; 695  :       Aq += MP1;

  00eac	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _Aq$[ebp]
  00eb2	83 c0 16	 add	 eax, 22			; 00000016H
  00eb5	89 85 28 ff ff
	ff		 mov	 DWORD PTR _Aq$[ebp], eax

; 696  :    }

  00ebb	e9 7b f6 ff ff	 jmp	 $LN12@cod_amr
$LN11@cod_amr:

; 697  : 
; 698  :    Copy(&st->old_exc[L_FRAME], &st->old_exc[0], PIT_MAX + L_INTERPOL);

  00ec0	68 9a 00 00 00	 push	 154			; 0000009aH
  00ec5	b8 02 00 00 00	 mov	 eax, 2
  00eca	6b c8 00	 imul	 ecx, eax, 0
  00ecd	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00ed0	8d 84 0a 02 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx+1282]
  00ed7	50		 push	 eax
  00ed8	b9 02 00 00 00	 mov	 ecx, 2
  00edd	69 d1 a0 00 00
	00		 imul	 edx, ecx, 160
  00ee3	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00ee6	8d 8c 10 02 05
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1282]
  00eed	51		 push	 ecx
  00eee	e8 00 00 00 00	 call	 _Copy
  00ef3	83 c4 0c	 add	 esp, 12			; 0000000cH
$the_end$57:

; 699  :    
; 700  : the_end:
; 701  :    
; 702  :    /*--------------------------------------------------*
; 703  :     * Update signal for next frame.                    *
; 704  :     *--------------------------------------------------*/
; 705  :    Copy(&st->old_wsp[L_FRAME], &st->old_wsp[0], PIT_MAX);

  00ef6	68 8f 00 00 00	 push	 143			; 0000008fH
  00efb	b8 02 00 00 00	 mov	 eax, 2
  00f00	6b c8 00	 imul	 ecx, eax, 0
  00f03	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00f06	8d 84 0a 90 02
	00 00		 lea	 eax, DWORD PTR [edx+ecx+656]
  00f0d	50		 push	 eax
  00f0e	b9 02 00 00 00	 mov	 ecx, 2
  00f13	69 d1 a0 00 00
	00		 imul	 edx, ecx, 160
  00f19	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00f1c	8d 8c 10 90 02
	00 00		 lea	 ecx, DWORD PTR [eax+edx+656]
  00f23	51		 push	 ecx
  00f24	e8 00 00 00 00	 call	 _Copy
  00f29	83 c4 0c	 add	 esp, 12			; 0000000cH

; 706  :    
; 707  :    Copy(&st->old_speech[L_FRAME], &st->old_speech[0], L_TOTAL - L_FRAME);

  00f2c	68 a0 00 00 00	 push	 160			; 000000a0H
  00f31	b8 02 00 00 00	 mov	 eax, 2
  00f36	6b c8 00	 imul	 ecx, eax, 0
  00f39	03 4d 08	 add	 ecx, DWORD PTR _st$[ebp]
  00f3c	51		 push	 ecx
  00f3d	ba 02 00 00 00	 mov	 edx, 2
  00f42	69 c2 a0 00 00
	00		 imul	 eax, edx, 160
  00f48	03 45 08	 add	 eax, DWORD PTR _st$[ebp]
  00f4b	50		 push	 eax
  00f4c	e8 00 00 00 00	 call	 _Copy
  00f51	83 c4 0c	 add	 esp, 12			; 0000000cH

; 708  : 
; 709  :    fwc ();                 /* function worst case */

  00f54	e8 00 00 00 00	 call	 _fwc

; 710  :        
; 711  :    return 0;

  00f59	33 c0		 xor	 eax, eax

; 712  : }

  00f5b	52		 push	 edx
  00f5c	8b cd		 mov	 ecx, ebp
  00f5e	50		 push	 eax
  00f5f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN56@cod_amr
  00f65	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00f6a	58		 pop	 eax
  00f6b	5a		 pop	 edx
  00f6c	5f		 pop	 edi
  00f6d	5e		 pop	 esi
  00f6e	5b		 pop	 ebx
  00f6f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f72	33 cd		 xor	 ecx, ebp
  00f74	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f79	81 c4 c0 06 00
	00		 add	 esp, 1728		; 000006c0H
  00f7f	3b ec		 cmp	 ebp, esp
  00f81	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f86	8b e5		 mov	 esp, ebp
  00f88	5d		 pop	 ebp
  00f89	c3		 ret	 0
  00f8a	8b ff		 npad	 2
$LN56@cod_amr:
  00f8c	1b 00 00 00	 DD	 27			; 0000001bH
  00f90	00 00 00 00	 DD	 $LN55@cod_amr
$LN55@cod_amr:
  00f94	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00f98	58 00 00 00	 DD	 88			; 00000058H
  00f9c	00 00 00 00	 DD	 $LN28@cod_amr
  00fa0	40 ff ff ff	 DD	 -192			; ffffff40H
  00fa4	58 00 00 00	 DD	 88			; 00000058H
  00fa8	00 00 00 00	 DD	 $LN29@cod_amr
  00fac	0c ff ff ff	 DD	 -244			; ffffff0cH
  00fb0	14 00 00 00	 DD	 20			; 00000014H
  00fb4	00 00 00 00	 DD	 $LN30@cod_amr
  00fb8	b4 fe ff ff	 DD	 -332			; fffffeb4H
  00fbc	50 00 00 00	 DD	 80			; 00000050H
  00fc0	00 00 00 00	 DD	 $LN31@cod_amr
  00fc4	5c fe ff ff	 DD	 -420			; fffffe5cH
  00fc8	50 00 00 00	 DD	 80			; 00000050H
  00fcc	00 00 00 00	 DD	 $LN32@cod_amr
  00fd0	04 fe ff ff	 DD	 -508			; fffffe04H
  00fd4	50 00 00 00	 DD	 80			; 00000050H
  00fd8	00 00 00 00	 DD	 $LN33@cod_amr
  00fdc	ac fd ff ff	 DD	 -596			; fffffdacH
  00fe0	50 00 00 00	 DD	 80			; 00000050H
  00fe4	00 00 00 00	 DD	 $LN34@cod_amr
  00fe8	54 fd ff ff	 DD	 -684			; fffffd54H
  00fec	50 00 00 00	 DD	 80			; 00000050H
  00ff0	00 00 00 00	 DD	 $LN35@cod_amr
  00ff4	40 fd ff ff	 DD	 -704			; fffffd40H
  00ff8	0c 00 00 00	 DD	 12			; 0000000cH
  00ffc	00 00 00 00	 DD	 $LN36@cod_amr
  01000	e8 fc ff ff	 DD	 -792			; fffffce8H
  01004	50 00 00 00	 DD	 80			; 00000050H
  01008	00 00 00 00	 DD	 $LN37@cod_amr
  0100c	90 fc ff ff	 DD	 -880			; fffffc90H
  01010	50 00 00 00	 DD	 80			; 00000050H
  01014	00 00 00 00	 DD	 $LN38@cod_amr
  01018	38 fc ff ff	 DD	 -968			; fffffc38H
  0101c	50 00 00 00	 DD	 80			; 00000050H
  01020	00 00 00 00	 DD	 $LN39@cod_amr
  01024	e0 fb ff ff	 DD	 -1056			; fffffbe0H
  01028	50 00 00 00	 DD	 80			; 00000050H
  0102c	00 00 00 00	 DD	 $LN40@cod_amr
  01030	88 fb ff ff	 DD	 -1144			; fffffb88H
  01034	50 00 00 00	 DD	 80			; 00000050H
  01038	00 00 00 00	 DD	 $LN41@cod_amr
  0103c	30 fb ff ff	 DD	 -1232			; fffffb30H
  01040	50 00 00 00	 DD	 80			; 00000050H
  01044	00 00 00 00	 DD	 $LN42@cod_amr
  01048	14 fb ff ff	 DD	 -1260			; fffffb14H
  0104c	14 00 00 00	 DD	 20			; 00000014H
  01050	00 00 00 00	 DD	 $LN43@cod_amr
  01054	f8 fa ff ff	 DD	 -1288			; fffffaf8H
  01058	14 00 00 00	 DD	 20			; 00000014H
  0105c	00 00 00 00	 DD	 $LN44@cod_amr
  01060	dc fa ff ff	 DD	 -1316			; fffffadcH
  01064	14 00 00 00	 DD	 20			; 00000014H
  01068	00 00 00 00	 DD	 $LN45@cod_amr
  0106c	d0 fa ff ff	 DD	 -1328			; fffffad0H
  01070	02 00 00 00	 DD	 2
  01074	00 00 00 00	 DD	 $LN46@cod_amr
  01078	94 fa ff ff	 DD	 -1388			; fffffa94H
  0107c	02 00 00 00	 DD	 2
  01080	00 00 00 00	 DD	 $LN47@cod_amr
  01084	88 fa ff ff	 DD	 -1400			; fffffa88H
  01088	02 00 00 00	 DD	 2
  0108c	00 00 00 00	 DD	 $LN48@cod_amr
  01090	64 fa ff ff	 DD	 -1436			; fffffa64H
  01094	04 00 00 00	 DD	 4
  01098	00 00 00 00	 DD	 $LN49@cod_amr
  0109c	58 fa ff ff	 DD	 -1448			; fffffa58H
  010a0	02 00 00 00	 DD	 2
  010a4	00 00 00 00	 DD	 $LN50@cod_amr
  010a8	4c fa ff ff	 DD	 -1460			; fffffa4cH
  010ac	02 00 00 00	 DD	 2
  010b0	00 00 00 00	 DD	 $LN51@cod_amr
  010b4	40 fa ff ff	 DD	 -1472			; fffffa40H
  010b8	02 00 00 00	 DD	 2
  010bc	00 00 00 00	 DD	 $LN52@cod_amr
  010c0	34 fa ff ff	 DD	 -1484			; fffffa34H
  010c4	02 00 00 00	 DD	 2
  010c8	00 00 00 00	 DD	 $LN53@cod_amr
  010cc	1c fa ff ff	 DD	 -1508			; fffffa1cH
  010d0	02 00 00 00	 DD	 2
  010d4	00 00 00 00	 DD	 $LN54@cod_amr
$LN54@cod_amr:
  010d8	67		 DB	 103			; 00000067H
  010d9	70		 DB	 112			; 00000070H
  010da	5f		 DB	 95			; 0000005fH
  010db	6c		 DB	 108			; 0000006cH
  010dc	69		 DB	 105			; 00000069H
  010dd	6d		 DB	 109			; 0000006dH
  010de	69		 DB	 105			; 00000069H
  010df	74		 DB	 116			; 00000074H
  010e0	00		 DB	 0
$LN53@cod_amr:
  010e1	67		 DB	 103			; 00000067H
  010e2	61		 DB	 97			; 00000061H
  010e3	69		 DB	 105			; 00000069H
  010e4	6e		 DB	 110			; 0000006eH
  010e5	5f		 DB	 95			; 0000005fH
  010e6	63		 DB	 99			; 00000063H
  010e7	6f		 DB	 111			; 0000006fH
  010e8	64		 DB	 100			; 00000064H
  010e9	65		 DB	 101			; 00000065H
  010ea	00		 DB	 0
$LN52@cod_amr:
  010eb	67		 DB	 103			; 00000067H
  010ec	61		 DB	 97			; 00000061H
  010ed	69		 DB	 105			; 00000069H
  010ee	6e		 DB	 110			; 0000006eH
  010ef	5f		 DB	 95			; 0000005fH
  010f0	70		 DB	 112			; 00000070H
  010f1	69		 DB	 105			; 00000069H
  010f2	74		 DB	 116			; 00000074H
  010f3	00		 DB	 0
$LN51@cod_amr:
  010f4	54		 DB	 84			; 00000054H
  010f5	30		 DB	 48			; 00000030H
  010f6	5f		 DB	 95			; 0000005fH
  010f7	66		 DB	 102			; 00000066H
  010f8	72		 DB	 114			; 00000072H
  010f9	61		 DB	 97			; 00000061H
  010fa	63		 DB	 99			; 00000063H
  010fb	00		 DB	 0
$LN50@cod_amr:
  010fc	54		 DB	 84			; 00000054H
  010fd	30		 DB	 48			; 00000030H
  010fe	00		 DB	 0
$LN49@cod_amr:
  010ff	54		 DB	 84			; 00000054H
  01100	5f		 DB	 95			; 0000005fH
  01101	6f		 DB	 111			; 0000006fH
  01102	70		 DB	 112			; 00000070H
  01103	00		 DB	 0
$LN48@cod_amr:
  01104	67		 DB	 103			; 00000067H
  01105	61		 DB	 97			; 00000061H
  01106	69		 DB	 105			; 00000069H
  01107	6e		 DB	 110			; 0000006eH
  01108	5f		 DB	 95			; 0000005fH
  01109	63		 DB	 99			; 00000063H
  0110a	6f		 DB	 111			; 0000006fH
  0110b	64		 DB	 100			; 00000064H
  0110c	65		 DB	 101			; 00000065H
  0110d	5f		 DB	 95			; 0000005fH
  0110e	73		 DB	 115			; 00000073H
  0110f	66		 DB	 102			; 00000066H
  01110	30		 DB	 48			; 00000030H
  01111	00		 DB	 0
$LN47@cod_amr:
  01112	67		 DB	 103			; 00000067H
  01113	61		 DB	 97			; 00000061H
  01114	69		 DB	 105			; 00000069H
  01115	6e		 DB	 110			; 0000006eH
  01116	5f		 DB	 95			; 0000005fH
  01117	70		 DB	 112			; 00000070H
  01118	69		 DB	 105			; 00000069H
  01119	74		 DB	 116			; 00000074H
  0111a	5f		 DB	 95			; 0000005fH
  0111b	73		 DB	 115			; 00000073H
  0111c	66		 DB	 102			; 00000066H
  0111d	30		 DB	 48			; 00000030H
  0111e	00		 DB	 0
$LN46@cod_amr:
  0111f	73		 DB	 115			; 00000073H
  01120	68		 DB	 104			; 00000068H
  01121	61		 DB	 97			; 00000061H
  01122	72		 DB	 114			; 00000072H
  01123	70		 DB	 112			; 00000070H
  01124	5f		 DB	 95			; 0000005fH
  01125	73		 DB	 115			; 00000073H
  01126	61		 DB	 97			; 00000061H
  01127	76		 DB	 118			; 00000076H
  01128	65		 DB	 101			; 00000065H
  01129	00		 DB	 0
$LN45@cod_amr:
  0112a	6d		 DB	 109			; 0000006dH
  0112b	65		 DB	 101			; 00000065H
  0112c	6d		 DB	 109			; 0000006dH
  0112d	5f		 DB	 95			; 0000005fH
  0112e	65		 DB	 101			; 00000065H
  0112f	72		 DB	 114			; 00000072H
  01130	72		 DB	 114			; 00000072H
  01131	5f		 DB	 95			; 0000005fH
  01132	73		 DB	 115			; 00000073H
  01133	61		 DB	 97			; 00000061H
  01134	76		 DB	 118			; 00000076H
  01135	65		 DB	 101			; 00000065H
  01136	00		 DB	 0
$LN44@cod_amr:
  01137	6d		 DB	 109			; 0000006dH
  01138	65		 DB	 101			; 00000065H
  01139	6d		 DB	 109			; 0000006dH
  0113a	5f		 DB	 95			; 0000005fH
  0113b	77		 DB	 119			; 00000077H
  0113c	30		 DB	 48			; 00000030H
  0113d	5f		 DB	 95			; 0000005fH
  0113e	73		 DB	 115			; 00000073H
  0113f	61		 DB	 97			; 00000061H
  01140	76		 DB	 118			; 00000076H
  01141	65		 DB	 101			; 00000065H
  01142	00		 DB	 0
$LN43@cod_amr:
  01143	6d		 DB	 109			; 0000006dH
  01144	65		 DB	 101			; 00000065H
  01145	6d		 DB	 109			; 0000006dH
  01146	5f		 DB	 95			; 0000005fH
  01147	73		 DB	 115			; 00000073H
  01148	79		 DB	 121			; 00000079H
  01149	6e		 DB	 110			; 0000006eH
  0114a	5f		 DB	 95			; 0000005fH
  0114b	73		 DB	 115			; 00000073H
  0114c	61		 DB	 97			; 00000061H
  0114d	76		 DB	 118			; 00000076H
  0114e	65		 DB	 101			; 00000065H
  0114f	00		 DB	 0
$LN42@cod_amr:
  01150	68		 DB	 104			; 00000068H
  01151	31		 DB	 49			; 00000031H
  01152	5f		 DB	 95			; 0000005fH
  01153	73		 DB	 115			; 00000073H
  01154	66		 DB	 102			; 00000066H
  01155	30		 DB	 48			; 00000030H
  01156	00		 DB	 0
$LN41@cod_amr:
  01157	63		 DB	 99			; 00000063H
  01158	6f		 DB	 111			; 0000006fH
  01159	64		 DB	 100			; 00000064H
  0115a	65		 DB	 101			; 00000065H
  0115b	5f		 DB	 95			; 0000005fH
  0115c	73		 DB	 115			; 00000073H
  0115d	66		 DB	 102			; 00000066H
  0115e	30		 DB	 48			; 00000030H
  0115f	00		 DB	 0
$LN40@cod_amr:
  01160	79		 DB	 121			; 00000079H
  01161	32		 DB	 50			; 00000032H
  01162	5f		 DB	 95			; 0000005fH
  01163	73		 DB	 115			; 00000073H
  01164	66		 DB	 102			; 00000066H
  01165	30		 DB	 48			; 00000030H
  01166	00		 DB	 0
$LN39@cod_amr:
  01167	78		 DB	 120			; 00000078H
  01168	6e		 DB	 110			; 0000006eH
  01169	5f		 DB	 95			; 0000005fH
  0116a	73		 DB	 115			; 00000073H
  0116b	66		 DB	 102			; 00000066H
  0116c	30		 DB	 48			; 00000030H
  0116d	00		 DB	 0
$LN38@cod_amr:
  0116e	72		 DB	 114			; 00000072H
  0116f	65		 DB	 101			; 00000065H
  01170	73		 DB	 115			; 00000073H
  01171	32		 DB	 50			; 00000032H
  01172	00		 DB	 0
$LN37@cod_amr:
  01173	72		 DB	 114			; 00000072H
  01174	65		 DB	 101			; 00000065H
  01175	73		 DB	 115			; 00000073H
  01176	00		 DB	 0
$LN36@cod_amr:
  01177	67		 DB	 103			; 00000067H
  01178	43		 DB	 67			; 00000043H
  01179	6f		 DB	 111			; 0000006fH
  0117a	65		 DB	 101			; 00000065H
  0117b	66		 DB	 102			; 00000066H
  0117c	66		 DB	 102			; 00000066H
  0117d	00		 DB	 0
$LN35@cod_amr:
  0117e	79		 DB	 121			; 00000079H
  0117f	32		 DB	 50			; 00000032H
  01180	00		 DB	 0
$LN34@cod_amr:
  01181	79		 DB	 121			; 00000079H
  01182	31		 DB	 49			; 00000031H
  01183	00		 DB	 0
$LN33@cod_amr:
  01184	63		 DB	 99			; 00000063H
  01185	6f		 DB	 111			; 0000006fH
  01186	64		 DB	 100			; 00000064H
  01187	65		 DB	 101			; 00000065H
  01188	00		 DB	 0
$LN32@cod_amr:
  01189	78		 DB	 120			; 00000078H
  0118a	6e		 DB	 110			; 0000006eH
  0118b	32		 DB	 50			; 00000032H
  0118c	00		 DB	 0
$LN31@cod_amr:
  0118d	78		 DB	 120			; 00000078H
  0118e	6e		 DB	 110			; 0000006eH
  0118f	00		 DB	 0
$LN30@cod_amr:
  01190	6c		 DB	 108			; 0000006cH
  01191	73		 DB	 115			; 00000073H
  01192	70		 DB	 112			; 00000070H
  01193	5f		 DB	 95			; 0000005fH
  01194	6e		 DB	 110			; 0000006eH
  01195	65		 DB	 101			; 00000065H
  01196	77		 DB	 119			; 00000077H
  01197	00		 DB	 0
$LN29@cod_amr:
  01198	41		 DB	 65			; 00000041H
  01199	71		 DB	 113			; 00000071H
  0119a	5f		 DB	 95			; 0000005fH
  0119b	74		 DB	 116			; 00000074H
  0119c	00		 DB	 0
$LN28@cod_amr:
  0119d	41		 DB	 65			; 00000041H
  0119e	5f		 DB	 95			; 0000005fH
  0119f	74		 DB	 116			; 00000074H
  011a0	00		 DB	 0
_cod_amr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cod_amr.c
;	COMDAT _cod_amr_first
_TEXT	SEGMENT
_st$ = 8						; size = 4
_new_speech$ = 12					; size = 4
_cod_amr_first PROC					; COMDAT

; 277  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 278  :    Copy(new_speech,&st->new_speech[-L_NEXT], L_NEXT);

  0001e	6a 28		 push	 40			; 00000028H
  00020	b8 02 00 00 00	 mov	 eax, 2
  00025	6b c8 d8	 imul	 ecx, eax, -40
  00028	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0002b	03 8a 8c 02 00
	00		 add	 ecx, DWORD PTR [edx+652]
  00031	51		 push	 ecx
  00032	8b 45 0c	 mov	 eax, DWORD PTR _new_speech$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _Copy
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 279  :    /*   Copy(new_speech,st->new_speech,L_FRAME); */
; 280  :   
; 281  :    return 0;

  0003e	33 c0		 xor	 eax, eax

; 282  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_cod_amr_first ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cod_amr.c
;	COMDAT _cod_amr_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_cod_amr_exit PROC					; COMDAT

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 238  :    if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@cod_amr_ex
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 05		 jne	 SHORT $LN2@cod_amr_ex
$LN1@cod_amr_ex:

; 239  :       return;

  0002c	e9 c1 00 00 00	 jmp	 $LN3@cod_amr_ex
$LN2@cod_amr_ex:

; 240  :    
; 241  :    /* dealloc members */
; 242  :    lpc_exit(&(*state)->lpcSt);

  00031	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	81 c1 8c 08 00
	00		 add	 ecx, 2188		; 0000088cH
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _lpc_exit
  00042	83 c4 04	 add	 esp, 4

; 243  :    lsp_exit(&(*state)->lspSt);

  00045	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	81 c1 90 08 00
	00		 add	 ecx, 2192		; 00000890H
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _lsp_exit
  00056	83 c4 04	 add	 esp, 4

; 244  :    gainQuant_exit(&(*state)->gainQuantSt);

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	81 c1 98 08 00
	00		 add	 ecx, 2200		; 00000898H
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _gainQuant_exit
  0006a	83 c4 04	 add	 esp, 4

; 245  :    cl_ltp_exit(&(*state)->clLtpSt);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	81 c1 94 08 00
	00		 add	 ecx, 2196		; 00000894H
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _cl_ltp_exit
  0007e	83 c4 04	 add	 esp, 4

; 246  :    p_ol_wgh_exit(&(*state)->pitchOLWghtSt);

  00081	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	81 c1 9c 08 00
	00		 add	 ecx, 2204		; 0000089cH
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _p_ol_wgh_exit
  00092	83 c4 04	 add	 esp, 4

; 247  :    ton_stab_exit(&(*state)->tonStabSt);

  00095	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	81 c1 a0 08 00
	00		 add	 ecx, 2208		; 000008a0H
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _ton_stab_exit
  000a6	83 c4 04	 add	 esp, 4

; 248  : #ifndef VAD2
; 249  :    vad1_exit(&(*state)->vadSt);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	81 c1 a4 08 00
	00		 add	 ecx, 2212		; 000008a4H
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _vad1_exit
  000ba	83 c4 04	 add	 esp, 4

; 250  : #else
; 251  :    vad2_exit(&(*state)->vadSt);
; 252  : #endif 
; 253  :    dtx_enc_exit(&(*state)->dtx_encSt);

  000bd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	81 c1 ac 08 00
	00		 add	 ecx, 2220		; 000008acH
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _dtx_enc_exit
  000ce	83 c4 04	 add	 esp, 4

; 254  : 
; 255  :    /* deallocate memory */
; 256  :    free(*state);

  000d1	8b f4		 mov	 esi, esp
  000d3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d8	51		 push	 ecx
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000df	83 c4 04	 add	 esp, 4
  000e2	3b f4		 cmp	 esi, esp
  000e4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 257  :    *state = NULL;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ec	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@cod_amr_ex:

; 258  :    
; 259  :    return;
; 260  : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
_cod_amr_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cod_amr.c
;	COMDAT _cod_amr_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_cod_amr_reset PROC					; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 156  :    Word16 i;
; 157  :     
; 158  :    if (st == (cod_amrState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 38		 jne	 SHORT $LN4@cod_amr_re

; 159  :       fprintf(stderr, "cod_amr_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IALOCEE@cod_amr_reset?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 160  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 2c 02 00 00	 jmp	 $LN5@cod_amr_re
$LN4@cod_amr_re:

; 161  :    }
; 162  :   
; 163  :    /*-----------------------------------------------------------------------*
; 164  :     *          Initialize pointers to speech vector.                        *
; 165  :     *-----------------------------------------------------------------------*/
; 166  :       
; 167  :    st->new_speech = st->old_speech + L_TOTAL - L_FRAME;   /* New speech     */

  0005c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005f	05 40 01 00 00	 add	 eax, 320		; 00000140H
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00067	89 81 8c 02 00
	00		 mov	 DWORD PTR [ecx+652], eax

; 168  :    
; 169  :    st->speech = st->new_speech - L_NEXT;                  /* Present frame  */

  0006d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00070	8b 88 8c 02 00
	00		 mov	 ecx, DWORD PTR [eax+652]
  00076	83 e9 50	 sub	 ecx, 80			; 00000050H
  00079	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0007c	89 8a 80 02 00
	00		 mov	 DWORD PTR [edx+640], ecx

; 170  :    
; 171  :    st->p_window = st->old_speech + L_TOTAL - L_WINDOW;    /* For LPC window */

  00082	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00085	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0008d	89 81 84 02 00
	00		 mov	 DWORD PTR [ecx+644], eax

; 172  :    st->p_window_12k2 = st->p_window - L_NEXT; /* EFR LPC window: no lookahead */

  00093	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00096	8b 88 84 02 00
	00		 mov	 ecx, DWORD PTR [eax+644]
  0009c	83 e9 50	 sub	 ecx, 80			; 00000050H
  0009f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000a2	89 8a 88 02 00
	00		 mov	 DWORD PTR [edx+648], ecx

; 173  :    
; 174  :    /* Initialize static pointers */
; 175  :    
; 176  :    st->wsp = st->old_wsp + PIT_MAX;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ab	05 ae 03 00 00	 add	 eax, 942		; 000003aeH
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000b3	89 81 f0 04 00
	00		 mov	 DWORD PTR [ecx+1264], eax

; 177  :    st->exc = st->old_exc + PIT_MAX + L_INTERPOL;

  000b9	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000bc	05 36 06 00 00	 add	 eax, 1590		; 00000636H
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000c4	89 81 78 07 00
	00		 mov	 DWORD PTR [ecx+1912], eax

; 178  :    st->zero = st->ai_zero + MP1;

  000ca	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000cd	05 92 07 00 00	 add	 eax, 1938		; 00000792H
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000d5	89 81 e4 07 00
	00		 mov	 DWORD PTR [ecx+2020], eax

; 179  :    st->error = st->mem_err + M;

  000db	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000de	05 00 09 00 00	 add	 eax, 2304		; 00000900H
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000e6	89 81 50 09 00
	00		 mov	 DWORD PTR [ecx+2384], eax

; 180  :    st->h1 = &st->hvec[L_SUBFR];

  000ec	b8 02 00 00 00	 mov	 eax, 2
  000f1	6b c8 28	 imul	 ecx, eax, 40
  000f4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000f7	8d 84 0a ec 07
	00 00		 lea	 eax, DWORD PTR [edx+ecx+2028]
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00101	89 81 e8 07 00
	00		 mov	 DWORD PTR [ecx+2024], eax

; 181  :    
; 182  :    /* Static vectors to zero */
; 183  :    
; 184  :    Set_zero(st->old_speech, L_TOTAL);

  00107	68 40 01 00 00	 push	 320			; 00000140H
  0010c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _Set_zero
  00115	83 c4 08	 add	 esp, 8

; 185  :    Set_zero(st->old_exc,    PIT_MAX + L_INTERPOL);

  00118	68 9a 00 00 00	 push	 154			; 0000009aH
  0011d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00120	05 02 05 00 00	 add	 eax, 1282		; 00000502H
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _Set_zero
  0012b	83 c4 08	 add	 esp, 8

; 186  :    Set_zero(st->old_wsp,    PIT_MAX);

  0012e	68 8f 00 00 00	 push	 143			; 0000008fH
  00133	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00136	05 90 02 00 00	 add	 eax, 656		; 00000290H
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _Set_zero
  00141	83 c4 08	 add	 esp, 8

; 187  :    Set_zero(st->mem_syn,    M);

  00144	6a 0a		 push	 10			; 0000000aH
  00146	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00149	05 b0 08 00 00	 add	 eax, 2224		; 000008b0H
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _Set_zero
  00154	83 c4 08	 add	 esp, 8

; 188  :    Set_zero(st->mem_w,      M);

  00157	6a 0a		 push	 10			; 0000000aH
  00159	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0015c	05 d8 08 00 00	 add	 eax, 2264		; 000008d8H
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _Set_zero
  00167	83 c4 08	 add	 esp, 8

; 189  :    Set_zero(st->mem_w0,     M);

  0016a	6a 0a		 push	 10			; 0000000aH
  0016c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0016f	05 c4 08 00 00	 add	 eax, 2244		; 000008c4H
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _Set_zero
  0017a	83 c4 08	 add	 esp, 8

; 190  :    Set_zero(st->mem_err,    M);

  0017d	6a 0a		 push	 10			; 0000000aH
  0017f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00182	05 ec 08 00 00	 add	 eax, 2284		; 000008ecH
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _Set_zero
  0018d	83 c4 08	 add	 esp, 8

; 191  :    Set_zero(st->zero,       L_SUBFR);

  00190	6a 28		 push	 40			; 00000028H
  00192	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00195	8b 88 e4 07 00
	00		 mov	 ecx, DWORD PTR [eax+2020]
  0019b	51		 push	 ecx
  0019c	e8 00 00 00 00	 call	 _Set_zero
  001a1	83 c4 08	 add	 esp, 8

; 192  :    Set_zero(st->hvec,       L_SUBFR);    /* set to zero "h1[-L_SUBFR..-1]" */

  001a4	6a 28		 push	 40			; 00000028H
  001a6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001a9	05 ec 07 00 00	 add	 eax, 2028		; 000007ecH
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _Set_zero
  001b4	83 c4 08	 add	 esp, 8

; 193  : 
; 194  :    /* OL LTP states */
; 195  :    for (i = 0; i < 5; i++)

  001b7	33 c0		 xor	 eax, eax
  001b9	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  001bd	eb 0c		 jmp	 SHORT $LN3@cod_amr_re
$LN2@cod_amr_re:
  001bf	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  001c3	66 83 c0 01	 add	 ax, 1
  001c7	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@cod_amr_re:
  001cb	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001cf	83 f8 05	 cmp	 eax, 5
  001d2	7d 16		 jge	 SHORT $LN1@cod_amr_re

; 196  :    {
; 197  :       st->old_lags[i] = 40; 

  001d4	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001d8	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  001dd	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001e0	66 89 8c 42 f4
	04 00 00	 mov	 WORD PTR [edx+eax*2+1268], cx

; 198  :    }

  001e8	eb d5		 jmp	 SHORT $LN2@cod_amr_re
$LN1@cod_amr_re:

; 199  :    
; 200  :    /* Reset lpc states */
; 201  :    lpc_reset(st->lpcSt);

  001ea	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ed	8b 88 8c 08 00
	00		 mov	 ecx, DWORD PTR [eax+2188]
  001f3	51		 push	 ecx
  001f4	e8 00 00 00 00	 call	 _lpc_reset
  001f9	83 c4 04	 add	 esp, 4

; 202  :    
; 203  :    /* Reset lsp states */
; 204  :    lsp_reset(st->lspSt);

  001fc	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ff	8b 88 90 08 00
	00		 mov	 ecx, DWORD PTR [eax+2192]
  00205	51		 push	 ecx
  00206	e8 00 00 00 00	 call	 _lsp_reset
  0020b	83 c4 04	 add	 esp, 4

; 205  :     
; 206  :    /* Reset clLtp states */
; 207  :    cl_ltp_reset(st->clLtpSt);

  0020e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00211	8b 88 94 08 00
	00		 mov	 ecx, DWORD PTR [eax+2196]
  00217	51		 push	 ecx
  00218	e8 00 00 00 00	 call	 _cl_ltp_reset
  0021d	83 c4 04	 add	 esp, 4

; 208  :    
; 209  :    gainQuant_reset(st->gainQuantSt);

  00220	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00223	8b 88 98 08 00
	00		 mov	 ecx, DWORD PTR [eax+2200]
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 _gainQuant_reset
  0022f	83 c4 04	 add	 esp, 4

; 210  : 
; 211  :    p_ol_wgh_reset(st->pitchOLWghtSt);

  00232	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00235	8b 88 9c 08 00
	00		 mov	 ecx, DWORD PTR [eax+2204]
  0023b	51		 push	 ecx
  0023c	e8 00 00 00 00	 call	 _p_ol_wgh_reset
  00241	83 c4 04	 add	 esp, 4

; 212  : 
; 213  :    ton_stab_reset(st->tonStabSt);   

  00244	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00247	8b 88 a0 08 00
	00		 mov	 ecx, DWORD PTR [eax+2208]
  0024d	51		 push	 ecx
  0024e	e8 00 00 00 00	 call	 _ton_stab_reset
  00253	83 c4 04	 add	 esp, 4

; 214  : 
; 215  : #ifndef VAD2
; 216  :    vad1_reset(st->vadSt);

  00256	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00259	8b 88 a4 08 00
	00		 mov	 ecx, DWORD PTR [eax+2212]
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 _vad1_reset
  00265	83 c4 04	 add	 esp, 4

; 217  : #else
; 218  :    vad2_reset(st->vadSt);
; 219  : #endif 
; 220  :    
; 221  :    dtx_enc_reset(st->dtx_encSt);

  00268	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0026b	8b 88 ac 08 00
	00		 mov	 ecx, DWORD PTR [eax+2220]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 _dtx_enc_reset
  00277	83 c4 04	 add	 esp, 4

; 222  : 
; 223  :    st->sharp = SHARPMIN;

  0027a	33 c0		 xor	 eax, eax
  0027c	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0027f	66 89 81 54 09
	00 00		 mov	 WORD PTR [ecx+2388], ax

; 224  :    
; 225  :    return 0;

  00286	33 c0		 xor	 eax, eax
$LN5@cod_amr_re:

; 226  : }

  00288	5f		 pop	 edi
  00289	5e		 pop	 esi
  0028a	5b		 pop	 ebx
  0028b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00291	3b ec		 cmp	 ebp, esp
  00293	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00298	8b e5		 mov	 esp, ebp
  0029a	5d		 pop	 ebp
  0029b	c3		 ret	 0
_cod_amr_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cod_amr.c
;	COMDAT _cod_amr_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_dtx$ = 12						; size = 4
_cod_amr_init PROC					; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 98   :   cod_amrState* s;
; 99   : 
; 100  :   if (state == (cod_amrState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN4@cod_amr_in

; 101  :       fprintf(stderr, "cod_amr_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KMHLKBEK@cod_amr_init?3?5invalid?5parameter?6@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 102  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 a8 01 00 00	 jmp	 $LN5@cod_amr_in
$LN4@cod_amr_in:

; 103  :   }
; 104  :   *state = NULL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 105  :  
; 106  :   /* allocate memory */
; 107  :   if ((s= (cod_amrState *) malloc(sizeof(cod_amrState))) == NULL){

  00065	8b f4		 mov	 esi, esp
  00067	68 58 09 00 00	 push	 2392			; 00000958H
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007f	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00083	75 38		 jne	 SHORT $LN3@cod_amr_in

; 108  :       fprintf(stderr, "cod_amr_init: can not malloc state structure\n");

  00085	8b f4		 mov	 esi, esp
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MKDLNKIH@cod_amr_init?3?5can?5not?5malloc?5sta@
  0008c	8b fc		 mov	 edi, esp
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00094	3b fc		 cmp	 edi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a0	d1 e1		 shl	 ecx, 1
  000a2	03 c1		 add	 eax, ecx
  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000ab	83 c4 08	 add	 esp, 8
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 109  :       return -1;

  000b5	83 c8 ff	 or	 eax, -1
  000b8	e9 47 01 00 00	 jmp	 $LN5@cod_amr_in
$LN3@cod_amr_in:

; 110  :   }
; 111  : 
; 112  :   s->lpcSt = NULL;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000c0	c7 80 8c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2188], 0

; 113  :   s->lspSt = NULL;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000cd	c7 80 90 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2192], 0

; 114  :   s->clLtpSt = NULL;

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000da	c7 80 94 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2196], 0

; 115  :   s->gainQuantSt = NULL;

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000e7	c7 80 98 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2200], 0

; 116  :   s->pitchOLWghtSt = NULL;

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000f4	c7 80 9c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2204], 0

; 117  :   s->tonStabSt = NULL;    

  000fe	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00101	c7 80 a0 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2208], 0

; 118  :   s->vadSt = NULL;

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0010e	c7 80 a4 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2212], 0

; 119  :   s->dtx_encSt = NULL;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0011b	c7 80 ac 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2220], 0

; 120  :   s->dtx = dtx;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00128	8b 4d 0c	 mov	 ecx, DWORD PTR _dtx$[ebp]
  0012b	89 88 a8 08 00
	00		 mov	 DWORD PTR [eax+2216], ecx

; 121  :   
; 122  :   /* Init sub states */
; 123  :   if (cl_ltp_init(&s->clLtpSt) ||
; 124  :       lsp_init(&s->lspSt) ||
; 125  :       gainQuant_init(&s->gainQuantSt) ||
; 126  :       p_ol_wgh_init(&s->pitchOLWghtSt) ||
; 127  :       ton_stab_init(&s->tonStabSt) ||      
; 128  : #ifndef VAD2
; 129  :       vad1_init(&s->vadSt) ||
; 130  : #else
; 131  :       vad2_init(&s->vadSt) ||
; 132  : #endif
; 133  :       dtx_enc_init(&s->dtx_encSt) ||
; 134  :       lpc_init(&s->lpcSt)) {

  00131	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00134	05 94 08 00 00	 add	 eax, 2196		; 00000894H
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _cl_ltp_init
  0013f	83 c4 04	 add	 esp, 4
  00142	85 c0		 test	 eax, eax
  00144	0f 85 93 00 00
	00		 jne	 $LN1@cod_amr_in
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0014d	05 90 08 00 00	 add	 eax, 2192		; 00000890H
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _lsp_init
  00158	83 c4 04	 add	 esp, 4
  0015b	85 c0		 test	 eax, eax
  0015d	75 7e		 jne	 SHORT $LN1@cod_amr_in
  0015f	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00162	05 98 08 00 00	 add	 eax, 2200		; 00000898H
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _gainQuant_init
  0016d	83 c4 04	 add	 esp, 4
  00170	85 c0		 test	 eax, eax
  00172	75 69		 jne	 SHORT $LN1@cod_amr_in
  00174	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00177	05 9c 08 00 00	 add	 eax, 2204		; 0000089cH
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _p_ol_wgh_init
  00182	83 c4 04	 add	 esp, 4
  00185	85 c0		 test	 eax, eax
  00187	75 54		 jne	 SHORT $LN1@cod_amr_in
  00189	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0018c	05 a0 08 00 00	 add	 eax, 2208		; 000008a0H
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 _ton_stab_init
  00197	83 c4 04	 add	 esp, 4
  0019a	85 c0		 test	 eax, eax
  0019c	75 3f		 jne	 SHORT $LN1@cod_amr_in
  0019e	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001a1	05 a4 08 00 00	 add	 eax, 2212		; 000008a4H
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 _vad1_init
  001ac	83 c4 04	 add	 esp, 4
  001af	85 c0		 test	 eax, eax
  001b1	75 2a		 jne	 SHORT $LN1@cod_amr_in
  001b3	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001b6	05 ac 08 00 00	 add	 eax, 2220		; 000008acH
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _dtx_enc_init
  001c1	83 c4 04	 add	 esp, 4
  001c4	85 c0		 test	 eax, eax
  001c6	75 15		 jne	 SHORT $LN1@cod_amr_in
  001c8	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001cb	05 8c 08 00 00	 add	 eax, 2188		; 0000088cH
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _lpc_init
  001d6	83 c4 04	 add	 esp, 4
  001d9	85 c0		 test	 eax, eax
  001db	74 11		 je	 SHORT $LN2@cod_amr_in
$LN1@cod_amr_in:

; 135  :      cod_amr_exit(&s);

  001dd	8d 45 f8	 lea	 eax, DWORD PTR _s$[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 _cod_amr_exit
  001e6	83 c4 04	 add	 esp, 4

; 136  :      return -1;

  001e9	83 c8 ff	 or	 eax, -1
  001ec	eb 16		 jmp	 SHORT $LN5@cod_amr_in
$LN2@cod_amr_in:

; 137  :   }
; 138  :   
; 139  :   cod_amr_reset(s);

  001ee	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _cod_amr_reset
  001f7	83 c4 04	 add	 esp, 4

; 140  :   
; 141  :   *state = s;

  001fa	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00200	89 08		 mov	 DWORD PTR [eax], ecx

; 142  :   
; 143  :   return 0;

  00202	33 c0		 xor	 eax, eax
$LN5@cod_amr_in:

; 144  : }

  00204	52		 push	 edx
  00205	8b cd		 mov	 ecx, ebp
  00207	50		 push	 eax
  00208	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@cod_amr_in
  0020e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00213	58		 pop	 eax
  00214	5a		 pop	 edx
  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0021e	3b ec		 cmp	 ebp, esp
  00220	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
  00229	8d 49 00	 npad	 3
$LN9@cod_amr_in:
  0022c	01 00 00 00	 DD	 1
  00230	00 00 00 00	 DD	 $LN8@cod_amr_in
$LN8@cod_amr_in:
  00234	f8 ff ff ff	 DD	 -8			; fffffff8H
  00238	04 00 00 00	 DD	 4
  0023c	00 00 00 00	 DD	 $LN7@cod_amr_in
$LN7@cod_amr_in:
  00240	73		 DB	 115			; 00000073H
  00241	00		 DB	 0
_cod_amr_init ENDP
_TEXT	ENDS
END
