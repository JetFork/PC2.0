; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\preemph.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_preemph_id
CONST	SEGMENT
_preemph_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_preemphasis_init
PUBLIC	_preemphasis_reset
PUBLIC	_preemphasis_exit
PUBLIC	_preemphasis
PUBLIC	??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@ ; `string'
PUBLIC	??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@ ; `string'
PUBLIC	??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_sub:PROC
EXTRN	_mult:PROC
EXTRN	_move16:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@ DB 'preemphasis_r'
	DB	'eset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@ DB 'preemphasis_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@ DB 'preemphasis_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis
_TEXT	SEGMENT
tv77 = -242						; size = 2
_i$ = -44						; size = 2
_temp$ = -32						; size = 2
_p2$ = -20						; size = 4
_p1$ = -8						; size = 4
_st$ = 8						; size = 4
_signal$ = 12						; size = 4
_g$ = 16						; size = 2
_L$ = 20						; size = 2
_preemphasis PROC					; COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 130  :     Word16 *p1, *p2, temp, i;
; 131  : 
; 132  :     p1 = signal + L - 1;                    move16 (); 

  0001e	0f bf 45 14	 movsx	 eax, WORD PTR _L$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _signal$[ebp]
  00025	8d 54 41 fe	 lea	 edx, DWORD PTR [ecx+eax*2-2]
  00029	89 55 f8	 mov	 DWORD PTR _p1$[ebp], edx
  0002c	e8 00 00 00 00	 call	 _move16

; 133  :     p2 = p1 - 1;                            move16 (); 

  00031	8b 45 f8	 mov	 eax, DWORD PTR _p1$[ebp]
  00034	83 e8 02	 sub	 eax, 2
  00037	89 45 ec	 mov	 DWORD PTR _p2$[ebp], eax
  0003a	e8 00 00 00 00	 call	 _move16

; 134  :     temp = *p1;                             move16 (); 

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _p1$[ebp]
  00042	66 8b 08	 mov	 cx, WORD PTR [eax]
  00045	66 89 4d e0	 mov	 WORD PTR _temp$[ebp], cx
  00049	e8 00 00 00 00	 call	 _move16

; 135  : 
; 136  :     for (i = 0; i <= L - 2; i++)

  0004e	33 c0		 xor	 eax, eax
  00050	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
  00054	eb 0c		 jmp	 SHORT $LN3@preemphasi
$LN2@preemphasi:
  00056	66 8b 45 d4	 mov	 ax, WORD PTR _i$[ebp]
  0005a	66 83 c0 01	 add	 ax, 1
  0005e	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
$LN3@preemphasi:
  00062	0f bf 45 d4	 movsx	 eax, WORD PTR _i$[ebp]
  00066	0f bf 4d 14	 movsx	 ecx, WORD PTR _L$[ebp]
  0006a	83 e9 02	 sub	 ecx, 2
  0006d	3b c1		 cmp	 eax, ecx
  0006f	7f 54		 jg	 SHORT $LN1@preemphasi

; 137  :     {
; 138  :         *p1 = sub (*p1, mult (g, *p2--));   move16 (); 

  00071	8b 45 ec	 mov	 eax, DWORD PTR _p2$[ebp]
  00074	66 8b 08	 mov	 cx, WORD PTR [eax]
  00077	66 89 8d 0e ff
	ff ff		 mov	 WORD PTR tv77[ebp], cx
  0007e	8b 55 ec	 mov	 edx, DWORD PTR _p2$[ebp]
  00081	83 ea 02	 sub	 edx, 2
  00084	89 55 ec	 mov	 DWORD PTR _p2$[ebp], edx
  00087	0f b7 85 0e ff
	ff ff		 movzx	 eax, WORD PTR tv77[ebp]
  0008e	50		 push	 eax
  0008f	0f b7 4d 10	 movzx	 ecx, WORD PTR _g$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _mult
  00099	83 c4 08	 add	 esp, 8
  0009c	0f b7 d0	 movzx	 edx, ax
  0009f	52		 push	 edx
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _p1$[ebp]
  000a3	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _sub
  000ac	83 c4 08	 add	 esp, 8
  000af	8b 55 f8	 mov	 edx, DWORD PTR _p1$[ebp]
  000b2	66 89 02	 mov	 WORD PTR [edx], ax
  000b5	e8 00 00 00 00	 call	 _move16

; 139  :         p1--;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _p1$[ebp]
  000bd	83 e8 02	 sub	 eax, 2
  000c0	89 45 f8	 mov	 DWORD PTR _p1$[ebp], eax

; 140  :     }

  000c3	eb 91		 jmp	 SHORT $LN2@preemphasi
$LN1@preemphasi:

; 141  : 
; 142  :     *p1 = sub (*p1, mult (g, st->mem_pre));     move16 (); 

  000c5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c8	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000cb	51		 push	 ecx
  000cc	0f b7 55 10	 movzx	 edx, WORD PTR _g$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _mult
  000d6	83 c4 08	 add	 esp, 8
  000d9	0f b7 c0	 movzx	 eax, ax
  000dc	50		 push	 eax
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _p1$[ebp]
  000e0	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 _sub
  000e9	83 c4 08	 add	 esp, 8
  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _p1$[ebp]
  000ef	66 89 01	 mov	 WORD PTR [ecx], ax
  000f2	e8 00 00 00 00	 call	 _move16

; 143  : 
; 144  :     st->mem_pre = temp;                         move16 (); 

  000f7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000fa	66 8b 4d e0	 mov	 cx, WORD PTR _temp$[ebp]
  000fe	66 89 08	 mov	 WORD PTR [eax], cx
  00101	e8 00 00 00 00	 call	 _move16

; 145  : 
; 146  :     return 0;

  00106	33 c0		 xor	 eax, eax

; 147  : }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  00111	3b ec		 cmp	 ebp, esp
  00113	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_preemphasis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_preemphasis_exit PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 106  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@preemphasi
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@preemphasi
$LN1@preemphasi:

; 107  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@preemphasi
$LN2@preemphasi:

; 108  :  
; 109  :   /* deallocate memory */
; 110  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 111  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@preemphasi:

; 112  :   
; 113  :   return;
; 114  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_preemphasis_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_preemphasis_reset PROC					; COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 87   :   if (state == (preemphasisState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@preemphasi

; 88   :       fprintf(stderr, "preemphasis_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 89   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 0a		 jmp	 SHORT $LN2@preemphasi
$LN1@preemphasi:

; 90   :   }
; 91   :   
; 92   :   state->mem_pre = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 93   :  
; 94   :   return 0;

  00061	33 c0		 xor	 eax, eax
$LN2@preemphasi:

; 95   : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_preemphasis_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_preemphasis_init PROC					; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 58   :   preemphasisState* s;
; 59   :  
; 60   :   if (state == (preemphasisState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@preemphasi

; 61   :       fprintf(stderr, "preemphasis_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@preemphasi
$LN2@preemphasi:

; 63   :   }
; 64   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 65   :  
; 66   :   /* allocate memory */
; 67   :   if ((s= (preemphasisState *) malloc(sizeof(preemphasisState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 02		 push	 2
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@preemphasi

; 68   :       fprintf(stderr, "preemphasis_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@preemphasi
$LN1@preemphasi:

; 70   :   }
; 71   :   
; 72   :   preemphasis_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _preemphasis_reset
  000bd	83 c4 04	 add	 esp, 4

; 73   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 74   :   
; 75   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@preemphasi:

; 76   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_preemphasis_init ENDP
_TEXT	ENDS
END
