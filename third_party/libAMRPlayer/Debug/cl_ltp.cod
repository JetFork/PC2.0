; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\cl_ltp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cl_ltp_id
CONST	SEGMENT
_cl_ltp_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_cl_ltp_init
PUBLIC	_cl_ltp_reset
PUBLIC	_cl_ltp_exit
PUBLIC	_cl_ltp
PUBLIC	??_C@_0CA@JIHKJIBG@cl_ltp_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@HABNKFBK@cl_ltp_init?3?5can?5not?5malloc?5stat@ ; `string'
PUBLIC	??_C@_0CB@GKOCPOKC@cl_ltp_reset?3?5invalid?5parameter?6@ ; `string'
EXTRN	_Pitch_fr_init:PROC
EXTRN	_Pitch_fr_reset:PROC
EXTRN	_Pitch_fr_exit:PROC
EXTRN	_Pitch_fr:PROC
EXTRN	_check_gp_clipping:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_sub:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_L_shl:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Convolve:PROC
EXTRN	_G_pitch:PROC
EXTRN	_Pred_lt_3or6:PROC
EXTRN	_q_gain_pitch:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CB@GKOCPOKC@cl_ltp_reset?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@GKOCPOKC@cl_ltp_reset?3?5invalid?5parameter?6@ DB 'cl_ltp_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HABNKFBK@cl_ltp_init?3?5can?5not?5malloc?5stat@
CONST	SEGMENT
??_C@_0CN@HABNKFBK@cl_ltp_init?3?5can?5not?5malloc?5stat@ DB 'cl_ltp_init'
	DB	': can not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JIHKJIBG@cl_ltp_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0CA@JIHKJIBG@cl_ltp_init?3?5invalid?5parameter?6?$AA@ DB 'cl_ltp_in'
	DB	'it: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cl_ltp.c
;	COMDAT _cl_ltp
_TEXT	SEGMENT
_gpc_flag$ = -56					; size = 2
_resu3$ = -44						; size = 2
_L_temp$ = -32						; size = 4
_index$ = -20						; size = 2
_i$ = -8						; size = 2
_clSt$ = 8						; size = 4
_tonSt$ = 12						; size = 4
_mode$ = 16						; size = 4
_frameOffset$ = 20					; size = 2
_T_op$ = 24						; size = 4
_h1$ = 28						; size = 4
_exc$ = 32						; size = 4
_res2$ = 36						; size = 4
_xn$ = 40						; size = 4
_lsp_flag$ = 44						; size = 2
_xn2$ = 48						; size = 4
_y1$ = 52						; size = 4
_T0$ = 56						; size = 4
_T0_frac$ = 60						; size = 4
_gain_pit$ = 64						; size = 4
_g_coeff$ = 68						; size = 4
_anap$ = 72						; size = 4
_gp_limit$ = 76						; size = 4
_cl_ltp	PROC						; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 161  :     Word16 i;
; 162  :     Word16 index;
; 163  :     Word32 L_temp;     /* temporarily variable */
; 164  :     Word16 resu3;      /* flag for upsample resolution */
; 165  :     Word16 gpc_flag;
; 166  :     
; 167  :    /*----------------------------------------------------------------------*
; 168  :     *                 Closed-loop fractional pitch search                  *
; 169  :     *----------------------------------------------------------------------*/
; 170  :    *T0 = Pitch_fr(clSt->pitchSt,
; 171  :                   mode, T_op, exc, xn, h1, 
; 172  :                   L_SUBFR, frameOffset,
; 173  :                   T0_frac, &resu3, &index); move16 ();

  0001e	8d 45 ec	 lea	 eax, DWORD PTR _index$[ebp]
  00021	50		 push	 eax
  00022	8d 4d d4	 lea	 ecx, DWORD PTR _resu3$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 3c	 mov	 edx, DWORD PTR _T0_frac$[ebp]
  00029	52		 push	 edx
  0002a	0f b7 45 14	 movzx	 eax, WORD PTR _frameOffset$[ebp]
  0002e	50		 push	 eax
  0002f	6a 28		 push	 40			; 00000028H
  00031	8b 4d 1c	 mov	 ecx, DWORD PTR _h1$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 28	 mov	 edx, DWORD PTR _xn$[ebp]
  00038	52		 push	 edx
  00039	8b 45 20	 mov	 eax, DWORD PTR _exc$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 18	 mov	 ecx, DWORD PTR _T_op$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  00044	52		 push	 edx
  00045	8b 45 08	 mov	 eax, DWORD PTR _clSt$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _Pitch_fr
  00050	83 c4 2c	 add	 esp, 44			; 0000002cH
  00053	8b 55 38	 mov	 edx, DWORD PTR _T0$[ebp]
  00056	66 89 02	 mov	 WORD PTR [edx], ax
  00059	e8 00 00 00 00	 call	 _move16

; 174  :    
; 175  :    *(*anap)++ = index;                              move16 ();

  0005e	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	66 8b 55 ec	 mov	 dx, WORD PTR _index$[ebp]
  00067	66 89 11	 mov	 WORD PTR [ecx], dx
  0006a	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	83 c1 02	 add	 ecx, 2
  00072	8b 55 48	 mov	 edx, DWORD PTR _anap$[ebp]
  00075	89 0a		 mov	 DWORD PTR [edx], ecx
  00077	e8 00 00 00 00	 call	 _move16

; 176  :    
; 177  :    /*-----------------------------------------------------------------*
; 178  :     *   - find unity gain pitch excitation (adapitve codebook entry)  *
; 179  :     *     with fractional interpolation.                              *
; 180  :     *   - find filtered pitch exc. y1[]=exc[] convolve with h1[])     *
; 181  :     *   - compute pitch gain and limit between 0 and 1.2              *
; 182  :     *   - update target vector for codebook search                    *
; 183  :     *   - find LTP residual.                                          *
; 184  :     *-----------------------------------------------------------------*/
; 185  :    
; 186  :    Pred_lt_3or6(exc, *T0, *T0_frac, L_SUBFR, resu3);

  0007c	0f b7 45 d4	 movzx	 eax, WORD PTR _resu3$[ebp]
  00080	50		 push	 eax
  00081	6a 28		 push	 40			; 00000028H
  00083	8b 4d 3c	 mov	 ecx, DWORD PTR _T0_frac$[ebp]
  00086	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00089	52		 push	 edx
  0008a	8b 45 38	 mov	 eax, DWORD PTR _T0$[ebp]
  0008d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00090	51		 push	 ecx
  00091	8b 55 20	 mov	 edx, DWORD PTR _exc$[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 _Pred_lt_3or6
  0009a	83 c4 14	 add	 esp, 20			; 00000014H

; 187  :    
; 188  :    Convolve(exc, h1, y1, L_SUBFR);

  0009d	6a 28		 push	 40			; 00000028H
  0009f	8b 45 34	 mov	 eax, DWORD PTR _y1$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d 1c	 mov	 ecx, DWORD PTR _h1$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 20	 mov	 edx, DWORD PTR _exc$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _Convolve
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 189  :    
; 190  :    /* gain_pit is Q14 for all modes */
; 191  :    *gain_pit = G_pitch(mode, xn, y1, g_coeff, L_SUBFR); move16 ();

  000b3	6a 28		 push	 40			; 00000028H
  000b5	8b 45 44	 mov	 eax, DWORD PTR _g_coeff$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d 34	 mov	 ecx, DWORD PTR _y1$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 28	 mov	 edx, DWORD PTR _xn$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _G_pitch
  000ca	83 c4 14	 add	 esp, 20			; 00000014H
  000cd	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  000d0	66 89 01	 mov	 WORD PTR [ecx], ax
  000d3	e8 00 00 00 00	 call	 _move16

; 192  : 
; 193  :    
; 194  :    /* check if the pitch gain should be limit due to resonance in LPC filter */
; 195  :    gpc_flag = 0;                                        move16 ();

  000d8	33 c0		 xor	 eax, eax
  000da	66 89 45 c8	 mov	 WORD PTR _gpc_flag$[ebp], ax
  000de	e8 00 00 00 00	 call	 _move16

; 196  :    *gp_limit = MAX_16;                                  move16 ();

  000e3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000e8	8b 4d 4c	 mov	 ecx, DWORD PTR _gp_limit$[ebp]
  000eb	66 89 01	 mov	 WORD PTR [ecx], ax
  000ee	e8 00 00 00 00	 call	 _move16

; 197  :    test (); test ();

  000f3	e8 00 00 00 00	 call	 _test
  000f8	e8 00 00 00 00	 call	 _test

; 198  :    if ((lsp_flag != 0) &&
; 199  :        (sub(*gain_pit, GP_CLIP) > 0))

  000fd	0f bf 45 2c	 movsx	 eax, WORD PTR _lsp_flag$[ebp]
  00101	85 c0		 test	 eax, eax
  00103	74 37		 je	 SHORT $LN11@cl_ltp
  00105	68 cd 3c 00 00	 push	 15565			; 00003ccdH
  0010a	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  0010d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _sub
  00116	83 c4 08	 add	 esp, 8
  00119	0f bf d0	 movsx	 edx, ax
  0011c	85 d2		 test	 edx, edx
  0011e	7e 1c		 jle	 SHORT $LN11@cl_ltp

; 200  :    {
; 201  :        gpc_flag = check_gp_clipping(tonSt, *gain_pit);  move16 ();

  00120	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  00123	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00126	51		 push	 ecx
  00127	8b 55 0c	 mov	 edx, DWORD PTR _tonSt$[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 _check_gp_clipping
  00130	83 c4 08	 add	 esp, 8
  00133	66 89 45 c8	 mov	 WORD PTR _gpc_flag$[ebp], ax
  00137	e8 00 00 00 00	 call	 _move16
$LN11@cl_ltp:

; 202  :    }
; 203  : 
; 204  :    /* special for the MR475, MR515 mode; limit the gain to 0.85 to */
; 205  :    /* cope with bit errors in the decoder in a better way.         */
; 206  :    test (); test (); 

  0013c	e8 00 00 00 00	 call	 _test
  00141	e8 00 00 00 00	 call	 _test

; 207  :    if ((sub (mode, MR475) == 0) || (sub (mode, MR515) == 0)) {

  00146	6a 00		 push	 0
  00148	0f b7 45 10	 movzx	 eax, WORD PTR _mode$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _sub
  00152	83 c4 08	 add	 esp, 8
  00155	0f bf c8	 movsx	 ecx, ax
  00158	85 c9		 test	 ecx, ecx
  0015a	74 16		 je	 SHORT $LN9@cl_ltp
  0015c	6a 01		 push	 1
  0015e	0f b7 45 10	 movzx	 eax, WORD PTR _mode$[ebp]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _sub
  00168	83 c4 08	 add	 esp, 8
  0016b	0f bf c8	 movsx	 ecx, ax
  0016e	85 c9		 test	 ecx, ecx
  00170	75 4f		 jne	 SHORT $LN10@cl_ltp
$LN9@cl_ltp:

; 208  :       test ();

  00172	e8 00 00 00 00	 call	 _test

; 209  :       if ( sub (*gain_pit, 13926) > 0) {

  00177	68 66 36 00 00	 push	 13926			; 00003666H
  0017c	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  0017f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _sub
  00188	83 c4 08	 add	 esp, 8
  0018b	0f bf d0	 movsx	 edx, ax
  0018e	85 d2		 test	 edx, edx
  00190	7e 10		 jle	 SHORT $LN8@cl_ltp

; 210  :          *gain_pit = 13926;   /* 0.85 in Q14 */    move16 ();

  00192	b8 66 36 00 00	 mov	 eax, 13926		; 00003666H
  00197	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  0019a	66 89 01	 mov	 WORD PTR [ecx], ax
  0019d	e8 00 00 00 00	 call	 _move16
$LN8@cl_ltp:

; 211  :       }
; 212  : 
; 213  :       test ();

  001a2	e8 00 00 00 00	 call	 _test

; 214  :       if (gpc_flag != 0) {

  001a7	0f bf 45 c8	 movsx	 eax, WORD PTR _gpc_flag$[ebp]
  001ab	85 c0		 test	 eax, eax
  001ad	74 10		 je	 SHORT $LN7@cl_ltp

; 215  :           *gp_limit = GP_CLIP;                     move16 ();

  001af	b8 cd 3c 00 00	 mov	 eax, 15565		; 00003ccdH
  001b4	8b 4d 4c	 mov	 ecx, DWORD PTR _gp_limit$[ebp]
  001b7	66 89 01	 mov	 WORD PTR [ecx], ax
  001ba	e8 00 00 00 00	 call	 _move16
$LN7@cl_ltp:

; 216  :       }
; 217  :    }
; 218  :    else

  001bf	eb 7b		 jmp	 SHORT $LN6@cl_ltp
$LN10@cl_ltp:

; 219  :    {
; 220  :        test ();

  001c1	e8 00 00 00 00	 call	 _test

; 221  :        if (gpc_flag != 0)

  001c6	0f bf 45 c8	 movsx	 eax, WORD PTR _gpc_flag$[ebp]
  001ca	85 c0		 test	 eax, eax
  001cc	74 20		 je	 SHORT $LN5@cl_ltp

; 222  :        {
; 223  :            *gp_limit = GP_CLIP;                    move16 ();

  001ce	b8 cd 3c 00 00	 mov	 eax, 15565		; 00003ccdH
  001d3	8b 4d 4c	 mov	 ecx, DWORD PTR _gp_limit$[ebp]
  001d6	66 89 01	 mov	 WORD PTR [ecx], ax
  001d9	e8 00 00 00 00	 call	 _move16

; 224  :            *gain_pit = GP_CLIP;                    move16 ();

  001de	b8 cd 3c 00 00	 mov	 eax, 15565		; 00003ccdH
  001e3	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  001e6	66 89 01	 mov	 WORD PTR [ecx], ax
  001e9	e8 00 00 00 00	 call	 _move16
$LN5@cl_ltp:

; 225  :        }           
; 226  :        /* For MR122, gain_pit is quantized here and not in gainQuant */
; 227  :        if (test (), sub(mode, MR122)==0)

  001ee	e8 00 00 00 00	 call	 _test
  001f3	6a 07		 push	 7
  001f5	0f b7 45 10	 movzx	 eax, WORD PTR _mode$[ebp]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 _sub
  001ff	83 c4 08	 add	 esp, 8
  00202	0f bf c8	 movsx	 ecx, ax
  00205	85 c9		 test	 ecx, ecx
  00207	75 33		 jne	 SHORT $LN6@cl_ltp

; 228  :        {
; 229  :            *(*anap)++ = q_gain_pitch(MR122, *gp_limit, gain_pit,
; 230  :                                      NULL, NULL);

  00209	6a 00		 push	 0
  0020b	6a 00		 push	 0
  0020d	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  00210	50		 push	 eax
  00211	8b 4d 4c	 mov	 ecx, DWORD PTR _gp_limit$[ebp]
  00214	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00217	52		 push	 edx
  00218	6a 07		 push	 7
  0021a	e8 00 00 00 00	 call	 _q_gain_pitch
  0021f	83 c4 14	 add	 esp, 20			; 00000014H
  00222	8b 4d 48	 mov	 ecx, DWORD PTR _anap$[ebp]
  00225	8b 11		 mov	 edx, DWORD PTR [ecx]
  00227	66 89 02	 mov	 WORD PTR [edx], ax
  0022a	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  0022d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022f	83 c1 02	 add	 ecx, 2
  00232	8b 55 48	 mov	 edx, DWORD PTR _anap$[ebp]
  00235	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  :                                                    move16 ();

  00237	e8 00 00 00 00	 call	 _move16
$LN6@cl_ltp:

; 232  :        }
; 233  :    }
; 234  : 
; 235  :    /* update target vector und evaluate LTP residual */
; 236  :    for (i = 0; i < L_SUBFR; i++) {

  0023c	33 c0		 xor	 eax, eax
  0023e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00242	eb 0c		 jmp	 SHORT $LN3@cl_ltp
$LN2@cl_ltp:
  00244	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00248	66 83 c0 01	 add	 ax, 1
  0024c	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@cl_ltp:
  00250	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00254	83 f8 28	 cmp	 eax, 40			; 00000028H
  00257	0f 8d cb 00 00
	00		 jge	 $LN1@cl_ltp

; 237  :        L_temp = L_mult(y1[i], *gain_pit);

  0025d	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  00260	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00263	51		 push	 ecx
  00264	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00268	8b 45 34	 mov	 eax, DWORD PTR _y1$[ebp]
  0026b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 _L_mult
  00275	83 c4 08	 add	 esp, 8
  00278	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 238  :        L_temp = L_shl(L_temp, 1);

  0027b	6a 01		 push	 1
  0027d	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 _L_shl
  00286	83 c4 08	 add	 esp, 8
  00289	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 239  :        xn2[i] = sub(xn[i], extract_h(L_temp));     move16 ();

  0028c	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 _extract_h
  00295	83 c4 04	 add	 esp, 4
  00298	0f b7 c8	 movzx	 ecx, ax
  0029b	51		 push	 ecx
  0029c	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  002a0	8b 45 28	 mov	 eax, DWORD PTR _xn$[ebp]
  002a3	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  002a7	51		 push	 ecx
  002a8	e8 00 00 00 00	 call	 _sub
  002ad	83 c4 08	 add	 esp, 8
  002b0	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  002b4	8b 4d 30	 mov	 ecx, DWORD PTR _xn2$[ebp]
  002b7	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  002bb	e8 00 00 00 00	 call	 _move16

; 240  :       
; 241  :        L_temp = L_mult(exc[i], *gain_pit);

  002c0	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  002c3	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002c6	51		 push	 ecx
  002c7	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  002cb	8b 45 20	 mov	 eax, DWORD PTR _exc$[ebp]
  002ce	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  002d2	51		 push	 ecx
  002d3	e8 00 00 00 00	 call	 _L_mult
  002d8	83 c4 08	 add	 esp, 8
  002db	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 242  :        L_temp = L_shl(L_temp, 1);

  002de	6a 01		 push	 1
  002e0	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _L_shl
  002e9	83 c4 08	 add	 esp, 8
  002ec	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 243  :        res2[i] = sub(res2[i], extract_h(L_temp));  move16 ();

  002ef	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 _extract_h
  002f8	83 c4 04	 add	 esp, 4
  002fb	0f b7 c8	 movzx	 ecx, ax
  002fe	51		 push	 ecx
  002ff	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00303	8b 45 24	 mov	 eax, DWORD PTR _res2$[ebp]
  00306	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0030a	51		 push	 ecx
  0030b	e8 00 00 00 00	 call	 _sub
  00310	83 c4 08	 add	 esp, 8
  00313	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00317	8b 4d 24	 mov	 ecx, DWORD PTR _res2$[ebp]
  0031a	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  0031e	e8 00 00 00 00	 call	 _move16

; 244  :    }

  00323	e9 1c ff ff ff	 jmp	 $LN2@cl_ltp
$LN1@cl_ltp:

; 245  :    
; 246  :    return 0;

  00328	33 c0		 xor	 eax, eax

; 247  : }

  0032a	52		 push	 edx
  0032b	8b cd		 mov	 ecx, ebp
  0032d	50		 push	 eax
  0032e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@cl_ltp
  00334	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00339	58		 pop	 eax
  0033a	5a		 pop	 edx
  0033b	5f		 pop	 edi
  0033c	5e		 pop	 esi
  0033d	5b		 pop	 ebx
  0033e	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00344	3b ec		 cmp	 ebp, esp
  00346	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c3		 ret	 0
  0034f	90		 npad	 1
$LN17@cl_ltp:
  00350	02 00 00 00	 DD	 2
  00354	00 00 00 00	 DD	 $LN16@cl_ltp
$LN16@cl_ltp:
  00358	ec ff ff ff	 DD	 -20			; ffffffecH
  0035c	02 00 00 00	 DD	 2
  00360	00 00 00 00	 DD	 $LN14@cl_ltp
  00364	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00368	02 00 00 00	 DD	 2
  0036c	00 00 00 00	 DD	 $LN15@cl_ltp
$LN15@cl_ltp:
  00370	72		 DB	 114			; 00000072H
  00371	65		 DB	 101			; 00000065H
  00372	73		 DB	 115			; 00000073H
  00373	75		 DB	 117			; 00000075H
  00374	33		 DB	 51			; 00000033H
  00375	00		 DB	 0
$LN14@cl_ltp:
  00376	69		 DB	 105			; 00000069H
  00377	6e		 DB	 110			; 0000006eH
  00378	64		 DB	 100			; 00000064H
  00379	65		 DB	 101			; 00000065H
  0037a	78		 DB	 120			; 00000078H
  0037b	00		 DB	 0
_cl_ltp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cl_ltp.c
;	COMDAT _cl_ltp_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_cl_ltp_exit PROC					; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 120  :     if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@cl_ltp_exi
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@cl_ltp_exi
$LN1@cl_ltp_exi:

; 121  :         return;

  0002c	eb 2f		 jmp	 SHORT $LN3@cl_ltp_exi
$LN2@cl_ltp_exi:

; 122  : 
; 123  :     /* dealloc members */
; 124  :     Pitch_fr_exit(&(*state)->pitchSt);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _Pitch_fr_exit
  00039	83 c4 04	 add	 esp, 4

; 125  :     
; 126  :     /* deallocate memory */
; 127  :     free(*state);

  0003c	8b f4		 mov	 esi, esp
  0003e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	51		 push	 ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004a	83 c4 04	 add	 esp, 4
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 128  :     *state = NULL;

  00054	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@cl_ltp_exi:

; 129  :     
; 130  :     return;
; 131  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_cl_ltp_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cl_ltp.c
;	COMDAT _cl_ltp_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_cl_ltp_reset PROC					; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 100  :     if (state == (clLtpState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@cl_ltp_res

; 101  :         fprintf(stderr, "cl_ltp_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GKOCPOKC@cl_ltp_reset?3?5invalid?5parameter?6@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 102  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 10		 jmp	 SHORT $LN2@cl_ltp_res
$LN1@cl_ltp_res:

; 103  :     }
; 104  :     
; 105  :     /* Reset pitch search states */
; 106  :     Pitch_fr_reset (state->pitchSt);

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _Pitch_fr_reset
  00064	83 c4 04	 add	 esp, 4

; 107  :     
; 108  :     return 0;

  00067	33 c0		 xor	 eax, eax
$LN2@cl_ltp_res:

; 109  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_cl_ltp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cl_ltp.c
;	COMDAT _cl_ltp_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_cl_ltp_init PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   :     clLtpState* s;
; 65   :     
; 66   :     if (state == (clLtpState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN3@cl_ltp_ini

; 67   :         fprintf(stderr, "cl_ltp_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JIHKJIBG@cl_ltp_init?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 92 00 00 00	 jmp	 $LN4@cl_ltp_ini
$LN3@cl_ltp_ini:

; 69   :     }
; 70   :     *state = NULL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 71   :     
; 72   :     /* allocate memory */
; 73   :     if ((s= (clLtpState *) malloc(sizeof(clLtpState))) == NULL){

  00065	8b f4		 mov	 esi, esp
  00067	6a 04		 push	 4
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 35		 jne	 SHORT $LN2@cl_ltp_ini

; 74   :         fprintf(stderr, "cl_ltp_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HABNKFBK@cl_ltp_init?3?5can?5not?5malloc?5stat@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 75   :         return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 37		 jmp	 SHORT $LN4@cl_ltp_ini
$LN2@cl_ltp_ini:

; 76   :   }
; 77   :     
; 78   :     /* init the sub state */
; 79   :     if (Pitch_fr_init(&s->pitchSt)) {

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _Pitch_fr_init
  000c0	83 c4 04	 add	 esp, 4
  000c3	85 c0		 test	 eax, eax
  000c5	74 11		 je	 SHORT $LN1@cl_ltp_ini

; 80   :         cl_ltp_exit(&s);

  000c7	8d 45 f8	 lea	 eax, DWORD PTR _s$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _cl_ltp_exit
  000d0	83 c4 04	 add	 esp, 4

; 81   :         return -1;

  000d3	83 c8 ff	 or	 eax, -1
  000d6	eb 16		 jmp	 SHORT $LN4@cl_ltp_ini
$LN1@cl_ltp_ini:

; 82   :     }
; 83   :     
; 84   :     cl_ltp_reset(s);

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _cl_ltp_reset
  000e1	83 c4 04	 add	 esp, 4

; 85   :     
; 86   :     *state = s;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000ea	89 08		 mov	 DWORD PTR [eax], ecx

; 87   :     
; 88   :     return 0;

  000ec	33 c0		 xor	 eax, eax
$LN4@cl_ltp_ini:

; 89   : }

  000ee	52		 push	 edx
  000ef	8b cd		 mov	 ecx, ebp
  000f1	50		 push	 eax
  000f2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@cl_ltp_ini
  000f8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fd	58		 pop	 eax
  000fe	5a		 pop	 edx
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
  00102	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
  00113	90		 npad	 1
$LN8@cl_ltp_ini:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN7@cl_ltp_ini
$LN7@cl_ltp_ini:
  0011c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00120	04 00 00 00	 DD	 4
  00124	00 00 00 00	 DD	 $LN6@cl_ltp_ini
$LN6@cl_ltp_ini:
  00128	73		 DB	 115			; 00000073H
  00129	00		 DB	 0
_cl_ltp_init ENDP
_TEXT	ENDS
END
