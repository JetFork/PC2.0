; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\gain_q.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_gain_q_id
CONST	SEGMENT
_gain_q_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_gainQuant_init
PUBLIC	_gainQuant_reset
PUBLIC	_gainQuant_exit
PUBLIC	_gainQuant
PUBLIC	??_C@_0CD@GNFELPMI@gainQuant_init?3?5invalid?5paramete@ ; `string'
PUBLIC	??_C@_0DA@GNDNGKLH@gainQuant_init?3?5can?5not?5malloc?5s@ ; `string'
PUBLIC	??_C@_0CE@LHMCPFG@gainQuant_reset?3?5invalid?5paramet@ ; `string'
EXTRN	_gc_pred_init:PROC
EXTRN	_gc_pred_reset:PROC
EXTRN	_gc_pred_exit:PROC
EXTRN	_gc_pred_copy:PROC
EXTRN	_gc_pred:PROC
EXTRN	_gc_pred_update:PROC
EXTRN	_gain_adapt_init:PROC
EXTRN	_gain_adapt_reset:PROC
EXTRN	_gain_adapt_exit:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Qua_gain:PROC
EXTRN	_G_code:PROC
EXTRN	_q_gain_code:PROC
EXTRN	_calc_filt_energies:PROC
EXTRN	_calc_target_energy:PROC
EXTRN	_MR795_gain_quant:PROC
EXTRN	_MR475_update_unq_pred:PROC
EXTRN	_MR475_gain_quant:PROC
EXTRN	_Set_zero:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CE@LHMCPFG@gainQuant_reset?3?5invalid?5paramet@
CONST	SEGMENT
??_C@_0CE@LHMCPFG@gainQuant_reset?3?5invalid?5paramet@ DB 'gainQuant_rese'
	DB	't: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GNDNGKLH@gainQuant_init?3?5can?5not?5malloc?5s@
CONST	SEGMENT
??_C@_0DA@GNDNGKLH@gainQuant_init?3?5can?5not?5malloc?5s@ DB 'gainQuant_i'
	DB	'nit: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GNFELPMI@gainQuant_init?3?5invalid?5paramete@
CONST	SEGMENT
??_C@_0CD@GNFELPMI@gainQuant_init?3?5invalid?5paramete@ DB 'gainQuant_ini'
	DB	't: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gain_q.c
;	COMDAT _gainQuant
_TEXT	SEGMENT
_cod_gain_frac$ = -136					; size = 2
_cod_gain_exp$ = -124					; size = 2
_frac_en$ = -112					; size = 2
_exp_en$ = -100						; size = 2
_exp_coeff$ = -88					; size = 10
_frac_coeff$ = -68					; size = 10
_qua_ener$ = -48					; size = 2
_qua_ener_MR122$ = -36					; size = 2
_frac_gcode0$ = -24					; size = 2
_exp_gcode0$ = -12					; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_res$ = 16						; size = 4
_exc$ = 20						; size = 4
_code$ = 24						; size = 4
_xn$ = 28						; size = 4
_xn2$ = 32						; size = 4
_y1$ = 36						; size = 4
_Y2$ = 40						; size = 4
_g_coeff$ = 44						; size = 4
_even_subframe$ = 48					; size = 2
_gp_limit$ = 52						; size = 2
_sf0_gain_pit$ = 56					; size = 4
_sf0_gain_cod$ = 60					; size = 4
_gain_pit$ = 64						; size = 4
_gain_cod$ = 68						; size = 4
_anap$ = 72						; size = 4
_gainQuant PROC						; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00012	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 178  :     Word16 exp_gcode0;
; 179  :     Word16 frac_gcode0;
; 180  :     Word16 qua_ener_MR122;
; 181  :     Word16 qua_ener;
; 182  :     Word16 frac_coeff[5];
; 183  :     Word16 exp_coeff[5];
; 184  :     Word16 exp_en, frac_en;
; 185  :     Word16 cod_gain_exp, cod_gain_frac;
; 186  :             
; 187  :     test ();

  00028	e8 00 00 00 00	 call	 _test

; 188  :     if (sub (mode, MR475) == 0)

  0002d	6a 00		 push	 0
  0002f	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _sub
  00039	83 c4 08	 add	 esp, 8
  0003c	0f bf c8	 movsx	 ecx, ax
  0003f	85 c9		 test	 ecx, ecx
  00041	0f 85 07 02 00
	00		 jne	 $LN8@gainQuant

; 189  :     {
; 190  :         test ();

  00047	e8 00 00 00 00	 call	 _test

; 191  :         if (even_subframe != 0)

  0004c	0f bf 45 30	 movsx	 eax, WORD PTR _even_subframe$[ebp]
  00050	85 c0		 test	 eax, eax
  00052	0f 84 09 01 00
	00		 je	 $LN7@gainQuant

; 192  :         {
; 193  :             /* save position in output parameter stream and current
; 194  :                state of codebook gain predictor */
; 195  :             st->gain_idx_ptr = (*anap)++;

  00058	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005b	8b 4d 48	 mov	 ecx, DWORD PTR _anap$[ebp]
  0005e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00060	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  00063	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	83 c1 02	 add	 ecx, 2
  0006b	8b 55 48	 mov	 edx, DWORD PTR _anap$[ebp]
  0006e	89 0a		 mov	 DWORD PTR [edx], ecx

; 196  :             gc_pred_copy(st->gc_predSt, st->gc_predUnqSt);

  00070	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00073	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00076	51		 push	 ecx
  00077	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0007a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _gc_pred_copy
  00083	83 c4 08	 add	 esp, 8

; 197  :             
; 198  :             /* predict codebook gain (using "unquantized" predictor)*/
; 199  :             /* (note that code[] is unsharpened in MR475)           */
; 200  :             gc_pred(st->gc_predUnqSt, mode, code,
; 201  :                     &st->sf0_exp_gcode0, &st->sf0_frac_gcode0,
; 202  :                     &exp_en, &frac_en);

  00086	8d 45 90	 lea	 eax, DWORD PTR _frac_en$[ebp]
  00089	50		 push	 eax
  0008a	8d 4d 9c	 lea	 ecx, DWORD PTR _exp_en$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00091	83 c2 02	 add	 edx, 2
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000a4	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 _gc_pred
  000ad	83 c4 1c	 add	 esp, 28			; 0000001cH

; 203  :             
; 204  :             /* calculate energy coefficients for quantization
; 205  :                and store them in state structure (will be used
; 206  :                in next subframe when real quantizer is run) */
; 207  :             calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
; 208  :                                st->sf0_frac_coeff, st->sf0_exp_coeff,
; 209  :                                &cod_gain_frac, &cod_gain_exp);

  000b0	8d 45 84	 lea	 eax, DWORD PTR _cod_gain_exp$[ebp]
  000b3	50		 push	 eax
  000b4	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _cod_gain_frac$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000be	83 c2 08	 add	 edx, 8
  000c1	52		 push	 edx
  000c2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c5	83 c0 12	 add	 eax, 18			; 00000012H
  000c8	50		 push	 eax
  000c9	8b 4d 2c	 mov	 ecx, DWORD PTR _g_coeff$[ebp]
  000cc	51		 push	 ecx
  000cd	8b 55 28	 mov	 edx, DWORD PTR _Y2$[ebp]
  000d0	52		 push	 edx
  000d1	8b 45 24	 mov	 eax, DWORD PTR _y1$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 20	 mov	 ecx, DWORD PTR _xn2$[ebp]
  000d8	51		 push	 ecx
  000d9	8b 55 1c	 mov	 edx, DWORD PTR _xn$[ebp]
  000dc	52		 push	 edx
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _calc_filt_energies
  000e6	83 c4 28	 add	 esp, 40			; 00000028H

; 210  : 
; 211  :             /* store optimum codebook gain (Q1) */
; 212  :             *gain_cod = shl (cod_gain_frac, add (cod_gain_exp, 1));

  000e9	6a 01		 push	 1
  000eb	0f b7 45 84	 movzx	 eax, WORD PTR _cod_gain_exp$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _add
  000f5	83 c4 08	 add	 esp, 8
  000f8	0f b7 c8	 movzx	 ecx, ax
  000fb	51		 push	 ecx
  000fc	0f b7 95 78 ff
	ff ff		 movzx	 edx, WORD PTR _cod_gain_frac$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _shl
  00109	83 c4 08	 add	 esp, 8
  0010c	8b 4d 44	 mov	 ecx, DWORD PTR _gain_cod$[ebp]
  0010f	66 89 01	 mov	 WORD PTR [ecx], ax

; 213  :                                                          move16 ();

  00112	e8 00 00 00 00	 call	 _move16

; 214  : 
; 215  :             calc_target_energy(xn,
; 216  :                                &st->sf0_exp_target_en, &st->sf0_frac_target_en);

  00117	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0011a	83 c0 06	 add	 eax, 6
  0011d	50		 push	 eax
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00121	83 c1 04	 add	 ecx, 4
  00124	51		 push	 ecx
  00125	8b 55 1c	 mov	 edx, DWORD PTR _xn$[ebp]
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 _calc_target_energy
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 217  : 
; 218  :             /* calculate optimum codebook gain and update
; 219  :                "unquantized" predictor                    */
; 220  :             MR475_update_unq_pred(st->gc_predUnqSt,
; 221  :                                   st->sf0_exp_gcode0, st->sf0_frac_gcode0,
; 222  :                                   cod_gain_exp, cod_gain_frac);

  00131	0f b7 85 78 ff
	ff ff		 movzx	 eax, WORD PTR _cod_gain_frac$[ebp]
  00138	50		 push	 eax
  00139	0f b7 4d 84	 movzx	 ecx, WORD PTR _cod_gain_exp$[ebp]
  0013d	51		 push	 ecx
  0013e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00141	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00145	50		 push	 eax
  00146	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00149	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0014c	52		 push	 edx
  0014d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00150	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00153	51		 push	 ecx
  00154	e8 00 00 00 00	 call	 _MR475_update_unq_pred
  00159	83 c4 14	 add	 esp, 20			; 00000014H

; 223  :             
; 224  :             /* the real quantizer is not run here... */
; 225  :         }
; 226  :         else

  0015c	e9 e8 00 00 00	 jmp	 $LN6@gainQuant
$LN7@gainQuant:

; 227  :         {
; 228  :             /* predict codebook gain (using "unquantized" predictor) */
; 229  :             /* (note that code[] is unsharpened in MR475)            */
; 230  :             gc_pred(st->gc_predUnqSt, mode, code,
; 231  :                     &exp_gcode0, &frac_gcode0,
; 232  :                     &exp_en, &frac_en);

  00161	8d 45 90	 lea	 eax, DWORD PTR _frac_en$[ebp]
  00164	50		 push	 eax
  00165	8d 4d 9c	 lea	 ecx, DWORD PTR _exp_en$[ebp]
  00168	51		 push	 ecx
  00169	8d 55 e8	 lea	 edx, DWORD PTR _frac_gcode0$[ebp]
  0016c	52		 push	 edx
  0016d	8d 45 f4	 lea	 eax, DWORD PTR _exp_gcode0$[ebp]
  00170	50		 push	 eax
  00171	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  00174	51		 push	 ecx
  00175	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00178	52		 push	 edx
  00179	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0017c	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0017f	51		 push	 ecx
  00180	e8 00 00 00 00	 call	 _gc_pred
  00185	83 c4 1c	 add	 esp, 28			; 0000001cH

; 233  :             
; 234  :             /* calculate energy coefficients for quantization */
; 235  :             calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
; 236  :                                frac_coeff, exp_coeff,
; 237  :                                &cod_gain_frac, &cod_gain_exp);

  00188	8d 45 84	 lea	 eax, DWORD PTR _cod_gain_exp$[ebp]
  0018b	50		 push	 eax
  0018c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _cod_gain_frac$[ebp]
  00192	51		 push	 ecx
  00193	8d 55 a8	 lea	 edx, DWORD PTR _exp_coeff$[ebp]
  00196	52		 push	 edx
  00197	8d 45 bc	 lea	 eax, DWORD PTR _frac_coeff$[ebp]
  0019a	50		 push	 eax
  0019b	8b 4d 2c	 mov	 ecx, DWORD PTR _g_coeff$[ebp]
  0019e	51		 push	 ecx
  0019f	8b 55 28	 mov	 edx, DWORD PTR _Y2$[ebp]
  001a2	52		 push	 edx
  001a3	8b 45 24	 mov	 eax, DWORD PTR _y1$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d 20	 mov	 ecx, DWORD PTR _xn2$[ebp]
  001aa	51		 push	 ecx
  001ab	8b 55 1c	 mov	 edx, DWORD PTR _xn$[ebp]
  001ae	52		 push	 edx
  001af	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 _calc_filt_energies
  001b8	83 c4 28	 add	 esp, 40			; 00000028H

; 238  : 
; 239  :             calc_target_energy(xn, &exp_en, &frac_en);

  001bb	8d 45 90	 lea	 eax, DWORD PTR _frac_en$[ebp]
  001be	50		 push	 eax
  001bf	8d 4d 9c	 lea	 ecx, DWORD PTR _exp_en$[ebp]
  001c2	51		 push	 ecx
  001c3	8b 55 1c	 mov	 edx, DWORD PTR _xn$[ebp]
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 _calc_target_energy
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 240  : 
; 241  :             /* run real (4-dim) quantizer and update real gain predictor */
; 242  :             *st->gain_idx_ptr = MR475_gain_quant(
; 243  :                 st->gc_predSt,
; 244  :                 st->sf0_exp_gcode0, st->sf0_frac_gcode0, 
; 245  :                 st->sf0_exp_coeff,  st->sf0_frac_coeff,
; 246  :                 st->sf0_exp_target_en, st->sf0_frac_target_en,
; 247  :                 code,
; 248  :                 exp_gcode0, frac_gcode0, 
; 249  :                 exp_coeff, frac_coeff,
; 250  :                 exp_en, frac_en,
; 251  :                 gp_limit,
; 252  :                 sf0_gain_pit, sf0_gain_cod,   
; 253  :                 gain_pit, gain_cod);

  001cf	8b 45 44	 mov	 eax, DWORD PTR _gain_cod$[ebp]
  001d2	50		 push	 eax
  001d3	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  001d6	51		 push	 ecx
  001d7	8b 55 3c	 mov	 edx, DWORD PTR _sf0_gain_cod$[ebp]
  001da	52		 push	 edx
  001db	8b 45 38	 mov	 eax, DWORD PTR _sf0_gain_pit$[ebp]
  001de	50		 push	 eax
  001df	0f b7 4d 34	 movzx	 ecx, WORD PTR _gp_limit$[ebp]
  001e3	51		 push	 ecx
  001e4	0f b7 55 90	 movzx	 edx, WORD PTR _frac_en$[ebp]
  001e8	52		 push	 edx
  001e9	0f b7 45 9c	 movzx	 eax, WORD PTR _exp_en$[ebp]
  001ed	50		 push	 eax
  001ee	8d 4d bc	 lea	 ecx, DWORD PTR _frac_coeff$[ebp]
  001f1	51		 push	 ecx
  001f2	8d 55 a8	 lea	 edx, DWORD PTR _exp_coeff$[ebp]
  001f5	52		 push	 edx
  001f6	0f b7 45 e8	 movzx	 eax, WORD PTR _frac_gcode0$[ebp]
  001fa	50		 push	 eax
  001fb	0f b7 4d f4	 movzx	 ecx, WORD PTR _exp_gcode0$[ebp]
  001ff	51		 push	 ecx
  00200	8b 55 18	 mov	 edx, DWORD PTR _code$[ebp]
  00203	52		 push	 edx
  00204	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00207	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0020b	51		 push	 ecx
  0020c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0020f	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00213	50		 push	 eax
  00214	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00217	83 c1 12	 add	 ecx, 18			; 00000012H
  0021a	51		 push	 ecx
  0021b	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0021e	83 c2 08	 add	 edx, 8
  00221	52		 push	 edx
  00222	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00225	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00229	51		 push	 ecx
  0022a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0022d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00230	50		 push	 eax
  00231	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00234	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 _MR475_gain_quant
  0023d	83 c4 4c	 add	 esp, 76			; 0000004cH
  00240	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00243	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00246	66 89 02	 mov	 WORD PTR [edx], ax
$LN6@gainQuant:

; 254  :         }
; 255  :     }
; 256  :     else

  00249	e9 b3 01 00 00	 jmp	 $LN5@gainQuant
$LN8@gainQuant:

; 257  :     {
; 258  :         /*-------------------------------------------------------------------*
; 259  :          *  predict codebook gain and quantize                               *
; 260  :          *  (also compute normalized CB innovation energy for MR795)         *
; 261  :          *-------------------------------------------------------------------*/
; 262  :         gc_pred(st->gc_predSt, mode, code, &exp_gcode0, &frac_gcode0,
; 263  :                 &exp_en, &frac_en);

  0024e	8d 45 90	 lea	 eax, DWORD PTR _frac_en$[ebp]
  00251	50		 push	 eax
  00252	8d 4d 9c	 lea	 ecx, DWORD PTR _exp_en$[ebp]
  00255	51		 push	 ecx
  00256	8d 55 e8	 lea	 edx, DWORD PTR _frac_gcode0$[ebp]
  00259	52		 push	 edx
  0025a	8d 45 f4	 lea	 eax, DWORD PTR _exp_gcode0$[ebp]
  0025d	50		 push	 eax
  0025e	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  00261	51		 push	 ecx
  00262	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00265	52		 push	 edx
  00266	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00269	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0026c	51		 push	 ecx
  0026d	e8 00 00 00 00	 call	 _gc_pred
  00272	83 c4 1c	 add	 esp, 28			; 0000001cH

; 264  :         
; 265  :         test ();

  00275	e8 00 00 00 00	 call	 _test

; 266  :         if (sub(mode, MR122) == 0)

  0027a	6a 07		 push	 7
  0027c	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 _sub
  00286	83 c4 08	 add	 esp, 8
  00289	0f bf c8	 movsx	 ecx, ax
  0028c	85 c9		 test	 ecx, ecx
  0028e	75 5c		 jne	 SHORT $LN4@gainQuant

; 267  :         {
; 268  :             *gain_cod = G_code (xn2, Y2); move16 ();

  00290	8b 45 28	 mov	 eax, DWORD PTR _Y2$[ebp]
  00293	50		 push	 eax
  00294	8b 4d 20	 mov	 ecx, DWORD PTR _xn2$[ebp]
  00297	51		 push	 ecx
  00298	e8 00 00 00 00	 call	 _G_code
  0029d	83 c4 08	 add	 esp, 8
  002a0	8b 55 44	 mov	 edx, DWORD PTR _gain_cod$[ebp]
  002a3	66 89 02	 mov	 WORD PTR [edx], ax
  002a6	e8 00 00 00 00	 call	 _move16

; 269  :             *(*anap)++ = q_gain_code (mode, exp_gcode0, frac_gcode0,
; 270  :                                       gain_cod, &qua_ener_MR122, &qua_ener);

  002ab	8d 45 d0	 lea	 eax, DWORD PTR _qua_ener$[ebp]
  002ae	50		 push	 eax
  002af	8d 4d dc	 lea	 ecx, DWORD PTR _qua_ener_MR122$[ebp]
  002b2	51		 push	 ecx
  002b3	8b 55 44	 mov	 edx, DWORD PTR _gain_cod$[ebp]
  002b6	52		 push	 edx
  002b7	0f b7 45 e8	 movzx	 eax, WORD PTR _frac_gcode0$[ebp]
  002bb	50		 push	 eax
  002bc	0f b7 4d f4	 movzx	 ecx, WORD PTR _exp_gcode0$[ebp]
  002c0	51		 push	 ecx
  002c1	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  002c4	52		 push	 edx
  002c5	e8 00 00 00 00	 call	 _q_gain_code
  002ca	83 c4 18	 add	 esp, 24			; 00000018H
  002cd	8b 4d 48	 mov	 ecx, DWORD PTR _anap$[ebp]
  002d0	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d2	66 89 02	 mov	 WORD PTR [edx], ax
  002d5	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  002d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002da	83 c1 02	 add	 ecx, 2
  002dd	8b 55 48	 mov	 edx, DWORD PTR _anap$[ebp]
  002e0	89 0a		 mov	 DWORD PTR [edx], ecx

; 271  :             move16 ();

  002e2	e8 00 00 00 00	 call	 _move16

; 272  :         }
; 273  :         else

  002e7	e9 fc 00 00 00	 jmp	 $LN3@gainQuant
$LN4@gainQuant:

; 274  :         {
; 275  :             /* calculate energy coefficients for quantization */
; 276  :             calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
; 277  :                                frac_coeff, exp_coeff,
; 278  :                                &cod_gain_frac, &cod_gain_exp);

  002ec	8d 45 84	 lea	 eax, DWORD PTR _cod_gain_exp$[ebp]
  002ef	50		 push	 eax
  002f0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _cod_gain_frac$[ebp]
  002f6	51		 push	 ecx
  002f7	8d 55 a8	 lea	 edx, DWORD PTR _exp_coeff$[ebp]
  002fa	52		 push	 edx
  002fb	8d 45 bc	 lea	 eax, DWORD PTR _frac_coeff$[ebp]
  002fe	50		 push	 eax
  002ff	8b 4d 2c	 mov	 ecx, DWORD PTR _g_coeff$[ebp]
  00302	51		 push	 ecx
  00303	8b 55 28	 mov	 edx, DWORD PTR _Y2$[ebp]
  00306	52		 push	 edx
  00307	8b 45 24	 mov	 eax, DWORD PTR _y1$[ebp]
  0030a	50		 push	 eax
  0030b	8b 4d 20	 mov	 ecx, DWORD PTR _xn2$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 55 1c	 mov	 edx, DWORD PTR _xn$[ebp]
  00312	52		 push	 edx
  00313	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 _calc_filt_energies
  0031c	83 c4 28	 add	 esp, 40			; 00000028H

; 279  :             
; 280  :             test ();

  0031f	e8 00 00 00 00	 call	 _test

; 281  :             if (sub (mode, MR795) == 0)

  00324	6a 05		 push	 5
  00326	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 _sub
  00330	83 c4 08	 add	 esp, 8
  00333	0f bf c8	 movsx	 ecx, ax
  00336	85 c9		 test	 ecx, ecx
  00338	75 61		 jne	 SHORT $LN2@gainQuant

; 282  :             {
; 283  :                 MR795_gain_quant(st->adaptSt, res, exc, code,
; 284  :                                  frac_coeff, exp_coeff,
; 285  :                                  exp_en, frac_en,
; 286  :                                  exp_gcode0, frac_gcode0, L_SUBFR,
; 287  :                                  cod_gain_frac, cod_gain_exp,
; 288  :                                  gp_limit, gain_pit, gain_cod,
; 289  :                                  &qua_ener_MR122, &qua_ener,
; 290  :                                  anap);

  0033a	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  0033d	50		 push	 eax
  0033e	8d 4d d0	 lea	 ecx, DWORD PTR _qua_ener$[ebp]
  00341	51		 push	 ecx
  00342	8d 55 dc	 lea	 edx, DWORD PTR _qua_ener_MR122$[ebp]
  00345	52		 push	 edx
  00346	8b 45 44	 mov	 eax, DWORD PTR _gain_cod$[ebp]
  00349	50		 push	 eax
  0034a	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  0034d	51		 push	 ecx
  0034e	0f b7 55 34	 movzx	 edx, WORD PTR _gp_limit$[ebp]
  00352	52		 push	 edx
  00353	0f b7 45 84	 movzx	 eax, WORD PTR _cod_gain_exp$[ebp]
  00357	50		 push	 eax
  00358	0f b7 8d 78 ff
	ff ff		 movzx	 ecx, WORD PTR _cod_gain_frac$[ebp]
  0035f	51		 push	 ecx
  00360	6a 28		 push	 40			; 00000028H
  00362	0f b7 55 e8	 movzx	 edx, WORD PTR _frac_gcode0$[ebp]
  00366	52		 push	 edx
  00367	0f b7 45 f4	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  0036b	50		 push	 eax
  0036c	0f b7 4d 90	 movzx	 ecx, WORD PTR _frac_en$[ebp]
  00370	51		 push	 ecx
  00371	0f b7 55 9c	 movzx	 edx, WORD PTR _exp_en$[ebp]
  00375	52		 push	 edx
  00376	8d 45 a8	 lea	 eax, DWORD PTR _exp_coeff$[ebp]
  00379	50		 push	 eax
  0037a	8d 4d bc	 lea	 ecx, DWORD PTR _frac_coeff$[ebp]
  0037d	51		 push	 ecx
  0037e	8b 55 18	 mov	 edx, DWORD PTR _code$[ebp]
  00381	52		 push	 edx
  00382	8b 45 14	 mov	 eax, DWORD PTR _exc$[ebp]
  00385	50		 push	 eax
  00386	8b 4d 10	 mov	 ecx, DWORD PTR _res$[ebp]
  00389	51		 push	 ecx
  0038a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0038d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 _MR795_gain_quant
  00396	83 c4 4c	 add	 esp, 76			; 0000004cH

; 291  :             }
; 292  :             else

  00399	eb 4d		 jmp	 SHORT $LN3@gainQuant
$LN2@gainQuant:

; 293  :             {
; 294  :                 *(*anap)++ = Qua_gain(mode,
; 295  :                                       exp_gcode0, frac_gcode0,
; 296  :                                       frac_coeff, exp_coeff, gp_limit,
; 297  :                                       gain_pit, gain_cod,
; 298  :                                       &qua_ener_MR122, &qua_ener);

  0039b	8d 45 d0	 lea	 eax, DWORD PTR _qua_ener$[ebp]
  0039e	50		 push	 eax
  0039f	8d 4d dc	 lea	 ecx, DWORD PTR _qua_ener_MR122$[ebp]
  003a2	51		 push	 ecx
  003a3	8b 55 44	 mov	 edx, DWORD PTR _gain_cod$[ebp]
  003a6	52		 push	 edx
  003a7	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  003aa	50		 push	 eax
  003ab	0f b7 4d 34	 movzx	 ecx, WORD PTR _gp_limit$[ebp]
  003af	51		 push	 ecx
  003b0	8d 55 a8	 lea	 edx, DWORD PTR _exp_coeff$[ebp]
  003b3	52		 push	 edx
  003b4	8d 45 bc	 lea	 eax, DWORD PTR _frac_coeff$[ebp]
  003b7	50		 push	 eax
  003b8	0f b7 4d e8	 movzx	 ecx, WORD PTR _frac_gcode0$[ebp]
  003bc	51		 push	 ecx
  003bd	0f b7 55 f4	 movzx	 edx, WORD PTR _exp_gcode0$[ebp]
  003c1	52		 push	 edx
  003c2	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 _Qua_gain
  003cb	83 c4 28	 add	 esp, 40			; 00000028H
  003ce	8b 4d 48	 mov	 ecx, DWORD PTR _anap$[ebp]
  003d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d3	66 89 02	 mov	 WORD PTR [edx], ax
  003d6	8b 45 48	 mov	 eax, DWORD PTR _anap$[ebp]
  003d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003db	83 c1 02	 add	 ecx, 2
  003de	8b 55 48	 mov	 edx, DWORD PTR _anap$[ebp]
  003e1	89 0a		 mov	 DWORD PTR [edx], ecx

; 299  :                 move16 ();

  003e3	e8 00 00 00 00	 call	 _move16
$LN3@gainQuant:

; 300  :             }
; 301  :         }
; 302  :         
; 303  :         /*------------------------------------------------------------------*
; 304  :          *  update table of past quantized energies                         *
; 305  :          *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                         *
; 306  :          *  st->past_qua_en(Q10) = 20 * Log10(qua_gain_code) / constant     *
; 307  :          *                       = Log2(qua_gain_code)                      *
; 308  :          *                       = qua_ener                                 *
; 309  :          *                                           constant = 20*Log10(2) *
; 310  :          *------------------------------------------------------------------*/
; 311  :         gc_pred_update(st->gc_predSt, qua_ener_MR122, qua_ener);

  003e8	0f b7 45 d0	 movzx	 eax, WORD PTR _qua_ener$[ebp]
  003ec	50		 push	 eax
  003ed	0f b7 4d dc	 movzx	 ecx, WORD PTR _qua_ener_MR122$[ebp]
  003f1	51		 push	 ecx
  003f2	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  003f5	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 _gc_pred_update
  003fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gainQuant:

; 312  :     }
; 313  :         
; 314  :     return 0;

  00401	33 c0		 xor	 eax, eax

; 315  : }

  00403	52		 push	 edx
  00404	8b cd		 mov	 ecx, ebp
  00406	50		 push	 eax
  00407	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@gainQuant
  0040d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00412	58		 pop	 eax
  00413	5a		 pop	 edx
  00414	5f		 pop	 edi
  00415	5e		 pop	 esi
  00416	5b		 pop	 ebx
  00417	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041a	33 cd		 xor	 ecx, ebp
  0041c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00421	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00427	3b ec		 cmp	 ebp, esp
  00429	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042e	8b e5		 mov	 esp, ebp
  00430	5d		 pop	 ebp
  00431	c3		 ret	 0
  00432	8b ff		 npad	 2
$LN22@gainQuant:
  00434	0a 00 00 00	 DD	 10			; 0000000aH
  00438	00 00 00 00	 DD	 $LN21@gainQuant
$LN21@gainQuant:
  0043c	f4 ff ff ff	 DD	 -12			; fffffff4H
  00440	02 00 00 00	 DD	 2
  00444	00 00 00 00	 DD	 $LN11@gainQuant
  00448	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0044c	02 00 00 00	 DD	 2
  00450	00 00 00 00	 DD	 $LN12@gainQuant
  00454	dc ff ff ff	 DD	 -36			; ffffffdcH
  00458	02 00 00 00	 DD	 2
  0045c	00 00 00 00	 DD	 $LN13@gainQuant
  00460	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00464	02 00 00 00	 DD	 2
  00468	00 00 00 00	 DD	 $LN14@gainQuant
  0046c	bc ff ff ff	 DD	 -68			; ffffffbcH
  00470	0a 00 00 00	 DD	 10			; 0000000aH
  00474	00 00 00 00	 DD	 $LN15@gainQuant
  00478	a8 ff ff ff	 DD	 -88			; ffffffa8H
  0047c	0a 00 00 00	 DD	 10			; 0000000aH
  00480	00 00 00 00	 DD	 $LN16@gainQuant
  00484	9c ff ff ff	 DD	 -100			; ffffff9cH
  00488	02 00 00 00	 DD	 2
  0048c	00 00 00 00	 DD	 $LN17@gainQuant
  00490	90 ff ff ff	 DD	 -112			; ffffff90H
  00494	02 00 00 00	 DD	 2
  00498	00 00 00 00	 DD	 $LN18@gainQuant
  0049c	84 ff ff ff	 DD	 -124			; ffffff84H
  004a0	02 00 00 00	 DD	 2
  004a4	00 00 00 00	 DD	 $LN19@gainQuant
  004a8	78 ff ff ff	 DD	 -136			; ffffff78H
  004ac	02 00 00 00	 DD	 2
  004b0	00 00 00 00	 DD	 $LN20@gainQuant
$LN20@gainQuant:
  004b4	63		 DB	 99			; 00000063H
  004b5	6f		 DB	 111			; 0000006fH
  004b6	64		 DB	 100			; 00000064H
  004b7	5f		 DB	 95			; 0000005fH
  004b8	67		 DB	 103			; 00000067H
  004b9	61		 DB	 97			; 00000061H
  004ba	69		 DB	 105			; 00000069H
  004bb	6e		 DB	 110			; 0000006eH
  004bc	5f		 DB	 95			; 0000005fH
  004bd	66		 DB	 102			; 00000066H
  004be	72		 DB	 114			; 00000072H
  004bf	61		 DB	 97			; 00000061H
  004c0	63		 DB	 99			; 00000063H
  004c1	00		 DB	 0
$LN19@gainQuant:
  004c2	63		 DB	 99			; 00000063H
  004c3	6f		 DB	 111			; 0000006fH
  004c4	64		 DB	 100			; 00000064H
  004c5	5f		 DB	 95			; 0000005fH
  004c6	67		 DB	 103			; 00000067H
  004c7	61		 DB	 97			; 00000061H
  004c8	69		 DB	 105			; 00000069H
  004c9	6e		 DB	 110			; 0000006eH
  004ca	5f		 DB	 95			; 0000005fH
  004cb	65		 DB	 101			; 00000065H
  004cc	78		 DB	 120			; 00000078H
  004cd	70		 DB	 112			; 00000070H
  004ce	00		 DB	 0
$LN18@gainQuant:
  004cf	66		 DB	 102			; 00000066H
  004d0	72		 DB	 114			; 00000072H
  004d1	61		 DB	 97			; 00000061H
  004d2	63		 DB	 99			; 00000063H
  004d3	5f		 DB	 95			; 0000005fH
  004d4	65		 DB	 101			; 00000065H
  004d5	6e		 DB	 110			; 0000006eH
  004d6	00		 DB	 0
$LN17@gainQuant:
  004d7	65		 DB	 101			; 00000065H
  004d8	78		 DB	 120			; 00000078H
  004d9	70		 DB	 112			; 00000070H
  004da	5f		 DB	 95			; 0000005fH
  004db	65		 DB	 101			; 00000065H
  004dc	6e		 DB	 110			; 0000006eH
  004dd	00		 DB	 0
$LN16@gainQuant:
  004de	65		 DB	 101			; 00000065H
  004df	78		 DB	 120			; 00000078H
  004e0	70		 DB	 112			; 00000070H
  004e1	5f		 DB	 95			; 0000005fH
  004e2	63		 DB	 99			; 00000063H
  004e3	6f		 DB	 111			; 0000006fH
  004e4	65		 DB	 101			; 00000065H
  004e5	66		 DB	 102			; 00000066H
  004e6	66		 DB	 102			; 00000066H
  004e7	00		 DB	 0
$LN15@gainQuant:
  004e8	66		 DB	 102			; 00000066H
  004e9	72		 DB	 114			; 00000072H
  004ea	61		 DB	 97			; 00000061H
  004eb	63		 DB	 99			; 00000063H
  004ec	5f		 DB	 95			; 0000005fH
  004ed	63		 DB	 99			; 00000063H
  004ee	6f		 DB	 111			; 0000006fH
  004ef	65		 DB	 101			; 00000065H
  004f0	66		 DB	 102			; 00000066H
  004f1	66		 DB	 102			; 00000066H
  004f2	00		 DB	 0
$LN14@gainQuant:
  004f3	71		 DB	 113			; 00000071H
  004f4	75		 DB	 117			; 00000075H
  004f5	61		 DB	 97			; 00000061H
  004f6	5f		 DB	 95			; 0000005fH
  004f7	65		 DB	 101			; 00000065H
  004f8	6e		 DB	 110			; 0000006eH
  004f9	65		 DB	 101			; 00000065H
  004fa	72		 DB	 114			; 00000072H
  004fb	00		 DB	 0
$LN13@gainQuant:
  004fc	71		 DB	 113			; 00000071H
  004fd	75		 DB	 117			; 00000075H
  004fe	61		 DB	 97			; 00000061H
  004ff	5f		 DB	 95			; 0000005fH
  00500	65		 DB	 101			; 00000065H
  00501	6e		 DB	 110			; 0000006eH
  00502	65		 DB	 101			; 00000065H
  00503	72		 DB	 114			; 00000072H
  00504	5f		 DB	 95			; 0000005fH
  00505	4d		 DB	 77			; 0000004dH
  00506	52		 DB	 82			; 00000052H
  00507	31		 DB	 49			; 00000031H
  00508	32		 DB	 50			; 00000032H
  00509	32		 DB	 50			; 00000032H
  0050a	00		 DB	 0
$LN12@gainQuant:
  0050b	66		 DB	 102			; 00000066H
  0050c	72		 DB	 114			; 00000072H
  0050d	61		 DB	 97			; 00000061H
  0050e	63		 DB	 99			; 00000063H
  0050f	5f		 DB	 95			; 0000005fH
  00510	67		 DB	 103			; 00000067H
  00511	63		 DB	 99			; 00000063H
  00512	6f		 DB	 111			; 0000006fH
  00513	64		 DB	 100			; 00000064H
  00514	65		 DB	 101			; 00000065H
  00515	30		 DB	 48			; 00000030H
  00516	00		 DB	 0
$LN11@gainQuant:
  00517	65		 DB	 101			; 00000065H
  00518	78		 DB	 120			; 00000078H
  00519	70		 DB	 112			; 00000070H
  0051a	5f		 DB	 95			; 0000005fH
  0051b	67		 DB	 103			; 00000067H
  0051c	63		 DB	 99			; 00000063H
  0051d	6f		 DB	 111			; 0000006fH
  0051e	64		 DB	 100			; 00000064H
  0051f	65		 DB	 101			; 00000065H
  00520	30		 DB	 48			; 00000030H
  00521	00		 DB	 0
_gainQuant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gain_q.c
;	COMDAT _gainQuant_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gainQuant_exit PROC					; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 140  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@gainQuant_
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@gainQuant_
$LN1@gainQuant_:

; 141  :       return;

  0002c	eb 54		 jmp	 SHORT $LN3@gainQuant_
$LN2@gainQuant_:

; 142  :  
; 143  :   gc_pred_exit(&(*state)->gc_predSt);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	83 c1 20	 add	 ecx, 32			; 00000020H
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _gc_pred_exit
  0003c	83 c4 04	 add	 esp, 4

; 144  :   gc_pred_exit(&(*state)->gc_predUnqSt);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	83 c1 24	 add	 ecx, 36			; 00000024H
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _gc_pred_exit
  0004d	83 c4 04	 add	 esp, 4

; 145  :   gain_adapt_exit(&(*state)->adaptSt);

  00050	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	83 c1 28	 add	 ecx, 40			; 00000028H
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _gain_adapt_exit
  0005e	83 c4 04	 add	 esp, 4

; 146  : 
; 147  :   /* deallocate memory */
; 148  :   free(*state);

  00061	8b f4		 mov	 esi, esp
  00063	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	51		 push	 ecx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 149  :   *state = NULL;

  00079	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@gainQuant_:

; 150  :   
; 151  :   return;
; 152  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_gainQuant_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gain_q.c
;	COMDAT _gainQuant_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gainQuant_reset PROC					; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 109  :   
; 110  :   if (state == (gainQuantState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@gainQuant_

; 111  :       fprintf(stderr, "gainQuant_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LHMCPFG@gainQuant_reset?3?5invalid?5paramet@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 112  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 7e		 jmp	 SHORT $LN2@gainQuant_
$LN1@gainQuant_:

; 113  :   }
; 114  :   
; 115  :   state->sf0_exp_gcode0 = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 116  :   state->sf0_frac_gcode0 = 0;

  00061	33 c0		 xor	 eax, eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 117  :   state->sf0_exp_target_en = 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 118  :   state->sf0_frac_target_en = 0;

  00073	33 c0		 xor	 eax, eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00078	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 119  :   
; 120  :   Set_zero (state->sf0_exp_coeff, 5);

  0007c	6a 05		 push	 5
  0007e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00081	83 c0 08	 add	 eax, 8
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _Set_zero
  0008a	83 c4 08	 add	 esp, 8

; 121  :   Set_zero (state->sf0_frac_coeff, 5);

  0008d	6a 05		 push	 5
  0008f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00092	83 c0 12	 add	 eax, 18			; 00000012H
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _Set_zero
  0009b	83 c4 08	 add	 esp, 8

; 122  :   state->gain_idx_ptr = NULL;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 123  :   
; 124  :   gc_pred_reset(state->gc_predSt);

  000a8	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ab	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _gc_pred_reset
  000b4	83 c4 04	 add	 esp, 4

; 125  :   gc_pred_reset(state->gc_predUnqSt);

  000b7	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ba	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _gc_pred_reset
  000c3	83 c4 04	 add	 esp, 4

; 126  :   gain_adapt_reset(state->adaptSt);

  000c6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _gain_adapt_reset
  000d2	83 c4 04	 add	 esp, 4

; 127  :   
; 128  :   return 0;

  000d5	33 c0		 xor	 eax, eax
$LN2@gainQuant_:

; 129  : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e0	3b ec		 cmp	 ebp, esp
  000e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_gainQuant_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gain_q.c
;	COMDAT _gainQuant_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_gainQuant_init PROC					; COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 66   :   gainQuantState* s;
; 67   :  
; 68   :   if (state == (gainQuantState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN4@gainQuant_

; 69   :       fprintf(stderr, "gainQuant_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GNFELPMI@gainQuant_init?3?5invalid?5paramete@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 e6 00 00 00	 jmp	 $LN5@gainQuant_
$LN4@gainQuant_:

; 71   :   }
; 72   :   *state = NULL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 73   :  
; 74   :   /* allocate memory */
; 75   :   if ((s= (gainQuantState *) malloc(sizeof(gainQuantState))) == NULL){

  00065	8b f4		 mov	 esi, esp
  00067	6a 2c		 push	 44			; 0000002cH
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 38		 jne	 SHORT $LN3@gainQuant_

; 76   :       fprintf(stderr, "gainQuant_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@GNDNGKLH@gainQuant_init?3?5can?5not?5malloc?5s@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   :       return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	e9 88 00 00 00	 jmp	 $LN5@gainQuant_
$LN3@gainQuant_:

; 78   :   }
; 79   :   
; 80   :   s->gain_idx_ptr = NULL;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000bd	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 81   :   
; 82   :   s->gc_predSt = NULL;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000c7	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 83   :   s->gc_predUnqSt = NULL;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000d1	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 84   :   s->adaptSt = NULL;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000db	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 85   : 
; 86   :   /* Init sub states */
; 87   :   if (   gc_pred_init(&s->gc_predSt)
; 88   :       || gc_pred_init(&s->gc_predUnqSt)
; 89   :       || gain_adapt_init(&s->adaptSt)) {

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000e5	83 c0 20	 add	 eax, 32			; 00000020H
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _gc_pred_init
  000ee	83 c4 04	 add	 esp, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 26		 jne	 SHORT $LN1@gainQuant_
  000f5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000f8	83 c0 24	 add	 eax, 36			; 00000024H
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _gc_pred_init
  00101	83 c4 04	 add	 esp, 4
  00104	85 c0		 test	 eax, eax
  00106	75 13		 jne	 SHORT $LN1@gainQuant_
  00108	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0010b	83 c0 28	 add	 eax, 40			; 00000028H
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _gain_adapt_init
  00114	83 c4 04	 add	 esp, 4
  00117	85 c0		 test	 eax, eax
  00119	74 11		 je	 SHORT $LN2@gainQuant_
$LN1@gainQuant_:

; 90   :      gainQuant_exit(&s);

  0011b	8d 45 f8	 lea	 eax, DWORD PTR _s$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _gainQuant_exit
  00124	83 c4 04	 add	 esp, 4

; 91   :      return -1;

  00127	83 c8 ff	 or	 eax, -1
  0012a	eb 16		 jmp	 SHORT $LN5@gainQuant_
$LN2@gainQuant_:

; 92   :   }
; 93   :  
; 94   :   gainQuant_reset(s);

  0012c	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _gainQuant_reset
  00135	83 c4 04	 add	 esp, 4

; 95   :   *state = s;

  00138	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0013e	89 08		 mov	 DWORD PTR [eax], ecx

; 96   :   
; 97   :   return 0;

  00140	33 c0		 xor	 eax, eax
$LN5@gainQuant_:

; 98   : }

  00142	52		 push	 edx
  00143	8b cd		 mov	 ecx, ebp
  00145	50		 push	 eax
  00146	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@gainQuant_
  0014c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00151	58		 pop	 eax
  00152	5a		 pop	 edx
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0015c	3b ec		 cmp	 ebp, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
  00167	90		 npad	 1
$LN9@gainQuant_:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN8@gainQuant_
$LN8@gainQuant_:
  00170	f8 ff ff ff	 DD	 -8			; fffffff8H
  00174	04 00 00 00	 DD	 4
  00178	00 00 00 00	 DD	 $LN7@gainQuant_
$LN7@gainQuant_:
  0017c	73		 DB	 115			; 00000073H
  0017d	00		 DB	 0
_gainQuant_init ENDP
_TEXT	ENDS
END
