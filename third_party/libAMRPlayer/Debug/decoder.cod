; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\decoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_decoder_id
CONST	SEGMENT
_decoder_id DB	'@(#)$Id $', 00H
CONST	ENDS
PUBLIC	_main
PUBLIC	??_C@_07JMNHGAEA@Decoder?$AA@			; `string'
PUBLIC	??_C@_0CM@GCFMAGEK@?5Usage?3?6?6?5?5?5?$CFs?5?5bitstream_file?5s@ ; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0CD@KMCFLLGI@Input?5file?5?8?$CFs?8?5does?5not?5exist?5?$CB@ ; `string'
PUBLIC	??_C@_0BM@OEMNPHLI@Input?5bitstream?5file?3?5?5?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CD@JNJMBGAM@Cannot?5create?5output?5file?5?8?$CFs?8?5?$CB@ ; `string'
PUBLIC	??_C@_0BM@DKCEOFIF@Synthesis?5speech?5file?3?5?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@		; `string'
PUBLIC	??_C@_0BH@JBNCPBEB@Invalid?5magic?5number?3?5?$AA@ ; `string'
PUBLIC	??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0M@CBGIMEHO@?$ANframe?$DN?$CFd?5?5?$AA@	; `string'
PUBLIC	??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@ ; `string'
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__exit:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_proc_head:PROC
EXTRN	_Speech_Decode_Frame_init:PROC
EXTRN	_Speech_Decode_Frame_reset:PROC
EXTRN	_Speech_Decode_Frame_exit:PROC
EXTRN	_Speech_Decode_Frame:PROC
EXTRN	_UnpackBits:PROC
EXTRN	_decoder_homing_frame_test:PROC
EXTRN	_decoder_homing_frame_test_first:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@
CONST	SEGMENT
??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@ DB 0aH, '%d '
	DB	'frame(s) processed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@ DB 0aH, 'e'
	DB	'rror writing output file: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBGIMEHO@?$ANframe?$DN?$CFd?5?5?$AA@
CONST	SEGMENT
??_C@_0M@CBGIMEHO@?$ANframe?$DN?$CFd?5?5?$AA@ DB 0dH, 'frame=%d  ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@
CONST	SEGMENT
??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@ DB '%s%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBNCPBEB@Invalid?5magic?5number?3?5?$AA@
CONST	SEGMENT
??_C@_0BH@JBNCPBEB@Invalid?5magic?5number?3?5?$AA@ DB 'Invalid magic numb'
	DB	'er: ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
CONST	SEGMENT
??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@ DB '#!AMR', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DKCEOFIF@Synthesis?5speech?5file?3?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@DKCEOFIF@Synthesis?5speech?5file?3?5?5?$CFs?6?$AA@ DB 'Synthesi'
	DB	's speech file:  %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JNJMBGAM@Cannot?5create?5output?5file?5?8?$CFs?8?5?$CB@
CONST	SEGMENT
??_C@_0CD@JNJMBGAM@Cannot?5create?5output?5file?5?8?$CFs?8?5?$CB@ DB 'Can'
	DB	'not create output file ''%s'' !!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEMNPHLI@Input?5bitstream?5file?3?5?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@OEMNPHLI@Input?5bitstream?5file?3?5?5?5?$CFs?6?$AA@ DB 'Input b'
	DB	'itstream file:   %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KMCFLLGI@Input?5file?5?8?$CFs?8?5does?5not?5exist?5?$CB@
CONST	SEGMENT
??_C@_0CD@KMCFLLGI@Input?5file?5?8?$CFs?8?5does?5not?5exist?5?$CB@ DB 'In'
	DB	'put file ''%s'' does not exist !!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@GCFMAGEK@?5Usage?3?6?6?5?5?5?$CFs?5?5bitstream_file?5s@
CONST	SEGMENT
??_C@_0CM@GCFMAGEK@?5Usage?3?6?6?5?5?5?$CFs?5?5bitstream_file?5s@ DB ' Us'
	DB	'age:', 0aH, 0aH, '   %s  bitstream_file synth_file', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMNHGAEA@Decoder?$AA@
CONST	SEGMENT
??_C@_07JMNHGAEA@Decoder?$AA@ DB 'Decoder', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\decoder.c
;	COMDAT _main
_TEXT	SEGMENT
_packed_size$ = -1136					; size = 32
_packed_bits$ = -1096					; size = 32
_magic$ = -1056						; size = 8
_ft$ = -1037						; size = 1
_q$ = -1025						; size = 1
_toc$ = -1013						; size = 1
_i$ = -1004						; size = 2
_reset_flag_old$ = -992					; size = 2
_reset_flag$ = -980					; size = 2
_tx_type$ = -968					; size = 4
_rx_type$ = -956					; size = 4
_mode$ = -944						; size = 4
_rxframetypeMode$ = -932				; size = 4
_file_serial$ = -920					; size = 4
_file_syn$ = -908					; size = 4
_serialFileName$ = -896					; size = 4
_fileName$ = -884					; size = 4
_progname$ = -872					; size = 4
_frame$ = -860						; size = 4
_synth$ = -848						; size = 320
_serial$ = -520						; size = 500
_speech_decoder_state$ = -12				; size = 4
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 05 00
	00		 sub	 esp, 1332		; 00000534H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1332]
  00012	b9 4d 01 00 00	 mov	 ecx, 333		; 0000014dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 93   :   Speech_Decode_FrameState *speech_decoder_state = NULL;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _speech_decoder_state$[ebp], 0

; 94   :   
; 95   :   Word16 serial[SERIAL_FRAMESIZE];   /* coded bits                    */
; 96   :   Word16 synth[L_FRAME];             /* Synthesis                     */
; 97   :   Word32 frame;
; 98   : 
; 99   :   char *progname = argv[0];

  0002f	b8 04 00 00 00	 mov	 eax, 4
  00034	6b c8 00	 imul	 ecx, eax, 0
  00037	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  0003a	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0003d	89 85 98 fc ff
	ff		 mov	 DWORD PTR _progname$[ebp], eax

; 100  :   char *fileName = NULL;

  00043	c7 85 8c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileName$[ebp], 0

; 101  :   char *serialFileName = NULL;

  0004d	c7 85 80 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _serialFileName$[ebp], 0

; 102  :   
; 103  :   FILE *file_syn, *file_serial;
; 104  : 
; 105  :   int rxframetypeMode = 0;           /* use RX frame type codes       */

  00057	c7 85 5c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _rxframetypeMode$[ebp], 0

; 106  :   enum Mode mode = (enum Mode)0;

  00061	c7 85 50 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _mode$[ebp], 0

; 107  :   enum RXFrameType rx_type = (enum RXFrameType)0;

  0006b	c7 85 44 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _rx_type$[ebp], 0

; 108  :   enum TXFrameType tx_type = (enum TXFrameType)0;

  00075	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _tx_type$[ebp], 0

; 109  :      
; 110  :   Word16 reset_flag = 0;

  0007f	33 c0		 xor	 eax, eax
  00081	66 89 85 2c fc
	ff ff		 mov	 WORD PTR _reset_flag$[ebp], ax

; 111  :   Word16 reset_flag_old = 1;

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	66 89 85 20 fc
	ff ff		 mov	 WORD PTR _reset_flag_old$[ebp], ax

; 112  :   Word16 i;
; 113  :   
; 114  : #ifdef MMS_IO
; 115  :   UWord8 toc, q, ft;
; 116  :   Word8 magic[8];
; 117  :   UWord8 packed_bits[MAX_PACKED_SIZE];
; 118  :   Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};

  00094	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00099	66 89 85 90 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp], ax
  000a0	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  000a5	66 89 85 92 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+2], ax
  000ac	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  000b1	66 89 85 94 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+4], ax
  000b8	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  000bd	66 89 85 96 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+6], ax
  000c4	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  000c9	66 89 85 98 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+8], ax
  000d0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000d5	66 89 85 9a fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+10], ax
  000dc	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH
  000e1	66 89 85 9c fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+12], ax
  000e8	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  000ed	66 89 85 9e fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+14], ax
  000f4	b8 05 00 00 00	 mov	 eax, 5
  000f9	66 89 85 a0 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+16], ax
  00100	33 c0		 xor	 eax, eax
  00102	66 89 85 a2 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+18], ax
  00109	33 c0		 xor	 eax, eax
  0010b	66 89 85 a4 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+20], ax
  00112	33 c0		 xor	 eax, eax
  00114	66 89 85 a6 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+22], ax
  0011b	33 c0		 xor	 eax, eax
  0011d	66 89 85 a8 fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+24], ax
  00124	33 c0		 xor	 eax, eax
  00126	66 89 85 aa fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+26], ax
  0012d	33 c0		 xor	 eax, eax
  0012f	66 89 85 ac fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+28], ax
  00136	33 c0		 xor	 eax, eax
  00138	66 89 85 ae fb
	ff ff		 mov	 WORD PTR _packed_size$[ebp+30], ax

; 119  : #endif
; 120  : 
; 121  :    proc_head ("Decoder");

  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_07JMNHGAEA@Decoder?$AA@
  00144	e8 00 00 00 00	 call	 _proc_head
  00149	83 c4 04	 add	 esp, 4

; 122  : 
; 123  : #ifndef MMS_IO
; 124  :   /*----------------------------------------------------------------------*
; 125  :    * process command line options                                         *
; 126  :    *----------------------------------------------------------------------*/
; 127  :   while (argc > 1) {
; 128  :       if (strcmp(argv[1], "-rxframetype") == 0)
; 129  :           rxframetypeMode = 1;
; 130  :       else break;
; 131  : 
; 132  :       argc--;
; 133  :       argv++;
; 134  :   }
; 135  : #endif
; 136  : 
; 137  :   /*----------------------------------------------------------------------*
; 138  :    * check number of arguments                                            *
; 139  :    *----------------------------------------------------------------------*/
; 140  :   if (argc != 3)

  0014c	83 7d 08 03	 cmp	 DWORD PTR _argc$[ebp], 3
  00150	74 48		 je	 SHORT $LN25@main

; 141  :   {
; 142  :     fprintf (stderr,
; 143  :       " Usage:\n\n"
; 144  : #ifndef MMS_IO
; 145  :       "   %s  [-rxframetype] bitstream_file synth_file\n\n"
; 146  :       " -rxframetype expects the RX frame type in bitstream_file (instead of TX)\n\n",
; 147  : #else
; 148  :       "   %s  bitstream_file synth_file\n\n",
; 149  : #endif
; 150  :              progname);

  00152	8b f4		 mov	 esi, esp
  00154	8b 85 98 fc ff
	ff		 mov	 eax, DWORD PTR _progname$[ebp]
  0015a	50		 push	 eax
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@GCFMAGEK@?5Usage?3?6?6?5?5?5?$CFs?5?5bitstream_file?5s@
  00160	8b fc		 mov	 edi, esp
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00168	3b fc		 cmp	 edi, esp
  0016a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00174	d1 e1		 shl	 ecx, 1
  00176	03 c1		 add	 eax, ecx
  00178	50		 push	 eax
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	3b f4		 cmp	 esi, esp
  00184	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 151  :       exit (1);

  00189	8b f4		 mov	 esi, esp
  0018b	6a 01		 push	 1
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00193	3b f4		 cmp	 esi, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN25@main:

; 152  :   }
; 153  :   
; 154  :   serialFileName = argv[1];

  0019a	b8 04 00 00 00	 mov	 eax, 4
  0019f	c1 e0 00	 shl	 eax, 0
  001a2	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  001a5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001a8	89 95 80 fc ff
	ff		 mov	 DWORD PTR _serialFileName$[ebp], edx

; 155  :   fileName = argv[2];

  001ae	b8 04 00 00 00	 mov	 eax, 4
  001b3	d1 e0		 shl	 eax, 1
  001b5	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  001b8	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001bb	89 95 8c fc ff
	ff		 mov	 DWORD PTR _fileName$[ebp], edx

; 156  : 
; 157  :   /*----------------------------------------------------------------------*
; 158  :    * Open serial bit stream and output speech file                        *
; 159  :    *----------------------------------------------------------------------*/
; 160  :   if (strcmp(serialFileName, "-") == 0) {

  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  001c6	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR _serialFileName$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _strcmp
  001d2	83 c4 08	 add	 esp, 8
  001d5	85 c0		 test	 eax, eax
  001d7	75 21		 jne	 SHORT $LN24@main

; 161  :      file_serial = stdin;

  001d9	8b f4		 mov	 esi, esp
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  001e1	3b f4		 cmp	 esi, esp
  001e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001ed	6b d1 00	 imul	 edx, ecx, 0
  001f0	03 c2		 add	 eax, edx
  001f2	89 85 68 fc ff
	ff		 mov	 DWORD PTR _file_serial$[ebp], eax
  001f8	eb 7a		 jmp	 SHORT $LN23@main
$LN24@main:

; 162  :   }
; 163  :   else if (fopen_s (&file_serial, serialFileName, "rb") || file_serial == NULL)

  001fa	8b f4		 mov	 esi, esp
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00201	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR _serialFileName$[ebp]
  00207	50		 push	 eax
  00208	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _file_serial$[ebp]
  0020e	51		 push	 ecx
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH
  00218	3b f4		 cmp	 esi, esp
  0021a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021f	85 c0		 test	 eax, eax
  00221	75 09		 jne	 SHORT $LN21@main
  00223	83 bd 68 fc ff
	ff 00		 cmp	 DWORD PTR _file_serial$[ebp], 0
  0022a	75 48		 jne	 SHORT $LN23@main
$LN21@main:

; 164  :   {
; 165  :       fprintf (stderr, "Input file '%s' does not exist !!\n", serialFileName);

  0022c	8b f4		 mov	 esi, esp
  0022e	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR _serialFileName$[ebp]
  00234	50		 push	 eax
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KMCFLLGI@Input?5file?5?8?$CFs?8?5does?5not?5exist?5?$CB@
  0023a	8b fc		 mov	 edi, esp
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00242	3b fc		 cmp	 edi, esp
  00244	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00249	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0024e	d1 e1		 shl	 ecx, 1
  00250	03 c1		 add	 eax, ecx
  00252	50		 push	 eax
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00259	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025c	3b f4		 cmp	 esi, esp
  0025e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 166  :       exit (0);

  00263	8b f4		 mov	 esi, esp
  00265	6a 00		 push	 0
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0026d	3b f4		 cmp	 esi, esp
  0026f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@main:

; 167  :   }
; 168  :   fprintf (stderr, "Input bitstream file:   %s\n", serialFileName);

  00274	8b f4		 mov	 esi, esp
  00276	8b 85 80 fc ff
	ff		 mov	 eax, DWORD PTR _serialFileName$[ebp]
  0027c	50		 push	 eax
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OEMNPHLI@Input?5bitstream?5file?3?5?5?5?$CFs?6?$AA@
  00282	8b fc		 mov	 edi, esp
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0028a	3b fc		 cmp	 edi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00291	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00296	d1 e1		 shl	 ecx, 1
  00298	03 c1		 add	 eax, ecx
  0029a	50		 push	 eax
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  002a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a4	3b f4		 cmp	 esi, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  : 
; 170  :   if (strcmp(fileName, "-") == 0) {

  002ab	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  002b0	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _fileName$[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 _strcmp
  002bc	83 c4 08	 add	 esp, 8
  002bf	85 c0		 test	 eax, eax
  002c1	75 21		 jne	 SHORT $LN20@main

; 171  :      file_syn = stdout;

  002c3	8b f4		 mov	 esi, esp
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  002cb	3b f4		 cmp	 esi, esp
  002cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002d7	c1 e1 00	 shl	 ecx, 0
  002da	03 c1		 add	 eax, ecx
  002dc	89 85 74 fc ff
	ff		 mov	 DWORD PTR _file_syn$[ebp], eax
  002e2	eb 7a		 jmp	 SHORT $LN19@main
$LN20@main:

; 172  :   }
; 173  :   else if (fopen_s (&file_syn, fileName, "wb") || file_syn == NULL)

  002e4	8b f4		 mov	 esi, esp
  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  002eb	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _fileName$[ebp]
  002f1	50		 push	 eax
  002f2	8d 8d 74 fc ff
	ff		 lea	 ecx, DWORD PTR _file_syn$[ebp]
  002f8	51		 push	 ecx
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  002ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00302	3b f4		 cmp	 esi, esp
  00304	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00309	85 c0		 test	 eax, eax
  0030b	75 09		 jne	 SHORT $LN17@main
  0030d	83 bd 74 fc ff
	ff 00		 cmp	 DWORD PTR _file_syn$[ebp], 0
  00314	75 48		 jne	 SHORT $LN19@main
$LN17@main:

; 174  :   {
; 175  :       fprintf (stderr, "Cannot create output file '%s' !!\n", fileName);

  00316	8b f4		 mov	 esi, esp
  00318	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _fileName$[ebp]
  0031e	50		 push	 eax
  0031f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JNJMBGAM@Cannot?5create?5output?5file?5?8?$CFs?8?5?$CB@
  00324	8b fc		 mov	 edi, esp
  00326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0032c	3b fc		 cmp	 edi, esp
  0032e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00333	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00338	d1 e1		 shl	 ecx, 1
  0033a	03 c1		 add	 eax, ecx
  0033c	50		 push	 eax
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00343	83 c4 0c	 add	 esp, 12			; 0000000cH
  00346	3b f4		 cmp	 esi, esp
  00348	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 176  :       exit (0);

  0034d	8b f4		 mov	 esi, esp
  0034f	6a 00		 push	 0
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00357	3b f4		 cmp	 esi, esp
  00359	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@main:

; 177  :   }
; 178  :   fprintf (stderr, "Synthesis speech file:  %s\n", fileName);

  0035e	8b f4		 mov	 esi, esp
  00360	8b 85 8c fc ff
	ff		 mov	 eax, DWORD PTR _fileName$[ebp]
  00366	50		 push	 eax
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DKCEOFIF@Synthesis?5speech?5file?3?5?5?$CFs?6?$AA@
  0036c	8b fc		 mov	 edi, esp
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00374	3b fc		 cmp	 edi, esp
  00376	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00380	d1 e1		 shl	 ecx, 1
  00382	03 c1		 add	 eax, ecx
  00384	50		 push	 eax
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0038b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038e	3b f4		 cmp	 esi, esp
  00390	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 179  : 
; 180  : #ifdef MMS_IO
; 181  :    /* read and verify magic number */
; 182  :   fread(magic, sizeof(Word8), strlen(AMR_MAGIC_NUMBER), file_serial);

  00395	8b f4		 mov	 esi, esp
  00397	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _file_serial$[ebp]
  0039d	50		 push	 eax
  0039e	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  003a3	e8 00 00 00 00	 call	 _strlen
  003a8	83 c4 04	 add	 esp, 4
  003ab	50		 push	 eax
  003ac	6a 01		 push	 1
  003ae	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _magic$[ebp]
  003b4	51		 push	 ecx
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  003bb	83 c4 10	 add	 esp, 16			; 00000010H
  003be	3b f4		 cmp	 esi, esp
  003c0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 183  :   if (strncmp((const char *)magic, AMR_MAGIC_NUMBER, strlen(AMR_MAGIC_NUMBER)))

  003c5	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  003ca	e8 00 00 00 00	 call	 _strlen
  003cf	83 c4 04	 add	 esp, 4
  003d2	8b f4		 mov	 esi, esp
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  003da	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _magic$[ebp]
  003e0	50		 push	 eax
  003e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  003e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ea	3b f4		 cmp	 esi, esp
  003ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f1	85 c0		 test	 eax, eax
  003f3	74 78		 je	 SHORT $LN16@main

; 184  :   {
; 185  : 	   fprintf(stderr, "%s%s\n", "Invalid magic number: ", magic);

  003f5	8b f4		 mov	 esi, esp
  003f7	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _magic$[ebp]
  003fd	50		 push	 eax
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JBNCPBEB@Invalid?5magic?5number?3?5?$AA@
  00403	68 00 00 00 00	 push	 OFFSET ??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@
  00408	8b fc		 mov	 edi, esp
  0040a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00410	3b fc		 cmp	 edi, esp
  00412	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00417	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0041c	d1 e1		 shl	 ecx, 1
  0041e	03 c1		 add	 eax, ecx
  00420	50		 push	 eax
  00421	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00427	83 c4 10	 add	 esp, 16			; 00000010H
  0042a	3b f4		 cmp	 esi, esp
  0042c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 186  : 	   fclose(file_serial);

  00431	8b f4		 mov	 esi, esp
  00433	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _file_serial$[ebp]
  00439	50		 push	 eax
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00440	83 c4 04	 add	 esp, 4
  00443	3b f4		 cmp	 esi, esp
  00445	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 187  : 	   fclose(file_syn);

  0044a	8b f4		 mov	 esi, esp
  0044c	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _file_syn$[ebp]
  00452	50		 push	 eax
  00453	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00459	83 c4 04	 add	 esp, 4
  0045c	3b f4		 cmp	 esi, esp
  0045e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 188  : 	   return 1;

  00463	b8 01 00 00 00	 mov	 eax, 1
  00468	e9 68 03 00 00	 jmp	 $LN27@main
$LN16@main:

; 189  :    }
; 190  : #endif
; 191  : 
; 192  :   /*-----------------------------------------------------------------------*
; 193  :    * Initialization of decoder                                             *
; 194  :    *-----------------------------------------------------------------------*/
; 195  :   if (Speech_Decode_Frame_init(&speech_decoder_state, "Decoder"))

  0046d	68 00 00 00 00	 push	 OFFSET ??_C@_07JMNHGAEA@Decoder?$AA@
  00472	8d 45 f4	 lea	 eax, DWORD PTR _speech_decoder_state$[ebp]
  00475	50		 push	 eax
  00476	e8 00 00 00 00	 call	 _Speech_Decode_Frame_init
  0047b	83 c4 08	 add	 esp, 8
  0047e	85 c0		 test	 eax, eax
  00480	74 11		 je	 SHORT $LN15@main

; 196  :       exit(-1);

  00482	8b f4		 mov	 esi, esp
  00484	6a ff		 push	 -1
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0048c	3b f4		 cmp	 esi, esp
  0048e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@main:

; 197  :     
; 198  :   /*-----------------------------------------------------------------------*
; 199  :    * process serial bitstream frame by frame                               *
; 200  :    *-----------------------------------------------------------------------*/
; 201  :   frame = 0;

  00493	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _frame$[ebp], 0
$LN14@main:

; 202  : 
; 203  : #ifndef MMS_IO
; 204  :   while (fread (serial, sizeof (Word16), SERIAL_FRAMESIZE, file_serial)
; 205  :          == SERIAL_FRAMESIZE)
; 206  :   {
; 207  :      /* get frame type and mode information from frame */
; 208  :      if (rxframetypeMode) {
; 209  :          rx_type = (enum RXFrameType)serial[0];
; 210  :      } else {
; 211  :          tx_type = (enum TXFrameType)serial[0];
; 212  :          rx_type = tx_to_rx (tx_type);
; 213  :      }
; 214  :      mode = (enum Mode) serial[1+MAX_SERIAL_SIZE];
; 215  : 
; 216  : #else
; 217  : 
; 218  :   while (fread (&toc, sizeof(UWord8), 1, file_serial) == 1)

  0049d	8b f4		 mov	 esi, esp
  0049f	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _file_serial$[ebp]
  004a5	50		 push	 eax
  004a6	6a 01		 push	 1
  004a8	6a 01		 push	 1
  004aa	8d 8d 0b fc ff
	ff		 lea	 ecx, DWORD PTR _toc$[ebp]
  004b0	51		 push	 ecx
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  004b7	83 c4 10	 add	 esp, 16			; 00000010H
  004ba	3b f4		 cmp	 esi, esp
  004bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c1	83 f8 01	 cmp	 eax, 1
  004c4	0f 85 c6 02 00
	00		 jne	 $LN13@main

; 219  :   {
; 220  : 	  /* read rest of the frame based on ToC byte */
; 221  : 	  q  = (toc >> 2) & 0x01;

  004ca	0f b6 85 0b fc
	ff ff		 movzx	 eax, BYTE PTR _toc$[ebp]
  004d1	c1 f8 02	 sar	 eax, 2
  004d4	83 e0 01	 and	 eax, 1
  004d7	88 85 ff fb ff
	ff		 mov	 BYTE PTR _q$[ebp], al

; 222  : 	  ft = (toc >> 3) & 0x0F;

  004dd	0f b6 85 0b fc
	ff ff		 movzx	 eax, BYTE PTR _toc$[ebp]
  004e4	c1 f8 03	 sar	 eax, 3
  004e7	83 e0 0f	 and	 eax, 15			; 0000000fH
  004ea	88 85 f3 fb ff
	ff		 mov	 BYTE PTR _ft$[ebp], al

; 223  : 	  fread (packed_bits, sizeof(UWord8), packed_size[ft], file_serial);

  004f0	8b f4		 mov	 esi, esp
  004f2	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _file_serial$[ebp]
  004f8	50		 push	 eax
  004f9	0f b6 8d f3 fb
	ff ff		 movzx	 ecx, BYTE PTR _ft$[ebp]
  00500	0f bf 94 4d 90
	fb ff ff	 movsx	 edx, WORD PTR _packed_size$[ebp+ecx*2]
  00508	52		 push	 edx
  00509	6a 01		 push	 1
  0050b	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _packed_bits$[ebp]
  00511	50		 push	 eax
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00518	83 c4 10	 add	 esp, 16			; 00000010H
  0051b	3b f4		 cmp	 esi, esp
  0051d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 224  : 
; 225  : 	  rx_type = UnpackBits(q, ft, packed_bits, &mode, &serial[1]);

  00522	b8 02 00 00 00	 mov	 eax, 2
  00527	c1 e0 00	 shl	 eax, 0
  0052a	8d 8c 05 f8 fd
	ff ff		 lea	 ecx, DWORD PTR _serial$[ebp+eax]
  00531	51		 push	 ecx
  00532	8d 95 50 fc ff
	ff		 lea	 edx, DWORD PTR _mode$[ebp]
  00538	52		 push	 edx
  00539	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _packed_bits$[ebp]
  0053f	50		 push	 eax
  00540	66 0f b6 8d f3
	fb ff ff	 movzx	 cx, BYTE PTR _ft$[ebp]
  00548	0f b7 d1	 movzx	 edx, cx
  0054b	52		 push	 edx
  0054c	0f b6 85 ff fb
	ff ff		 movzx	 eax, BYTE PTR _q$[ebp]
  00553	50		 push	 eax
  00554	e8 00 00 00 00	 call	 _UnpackBits
  00559	83 c4 14	 add	 esp, 20			; 00000014H
  0055c	89 85 44 fc ff
	ff		 mov	 DWORD PTR _rx_type$[ebp], eax

; 226  : 
; 227  : #endif
; 228  : 
; 229  :      ++frame;

  00562	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  00568	83 c0 01	 add	 eax, 1
  0056b	89 85 a4 fc ff
	ff		 mov	 DWORD PTR _frame$[ebp], eax

; 230  :      if ( (frame%50) == 0) {

  00571	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  00577	99		 cdq
  00578	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  0057d	f7 f9		 idiv	 ecx
  0057f	85 d2		 test	 edx, edx
  00581	75 37		 jne	 SHORT $LN12@main

; 231  :         fprintf (stderr, "\rframe=%d  ", frame);

  00583	8b f4		 mov	 esi, esp
  00585	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  0058b	50		 push	 eax
  0058c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CBGIMEHO@?$ANframe?$DN?$CFd?5?5?$AA@
  00591	8b fc		 mov	 edi, esp
  00593	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00599	3b fc		 cmp	 edi, esp
  0059b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005a0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  005a5	d1 e1		 shl	 ecx, 1
  005a7	03 c1		 add	 eax, ecx
  005a9	50		 push	 eax
  005aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  005b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b3	3b f4		 cmp	 esi, esp
  005b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@main:

; 232  :      }
; 233  : 
; 234  :      if (rx_type == RX_NO_DATA) {

  005ba	83 bd 44 fc ff
	ff 07		 cmp	 DWORD PTR _rx_type$[ebp], 7
  005c1	75 0e		 jne	 SHORT $LN11@main

; 235  :        mode = speech_decoder_state->prev_mode;

  005c3	8b 45 f4	 mov	 eax, DWORD PTR _speech_decoder_state$[ebp]
  005c6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  005c9	89 8d 50 fc ff
	ff		 mov	 DWORD PTR _mode$[ebp], ecx

; 236  :      }
; 237  :      else {

  005cf	eb 0c		 jmp	 SHORT $LN10@main
$LN11@main:

; 238  :        speech_decoder_state->prev_mode = mode;

  005d1	8b 45 f4	 mov	 eax, DWORD PTR _speech_decoder_state$[ebp]
  005d4	8b 8d 50 fc ff
	ff		 mov	 ecx, DWORD PTR _mode$[ebp]
  005da	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN10@main:

; 239  :      }
; 240  : 
; 241  :      /* if homed: check if this frame is another homing frame */
; 242  :      if (reset_flag_old == 1)

  005dd	0f bf 85 20 fc
	ff ff		 movsx	 eax, WORD PTR _reset_flag_old$[ebp]
  005e4	83 f8 01	 cmp	 eax, 1
  005e7	75 26		 jne	 SHORT $LN9@main

; 243  :      {
; 244  :          /* only check until end of first subframe */
; 245  :          reset_flag = decoder_homing_frame_test_first(&serial[1], mode);

  005e9	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _mode$[ebp]
  005ef	50		 push	 eax
  005f0	b9 02 00 00 00	 mov	 ecx, 2
  005f5	c1 e1 00	 shl	 ecx, 0
  005f8	8d 94 0d f8 fd
	ff ff		 lea	 edx, DWORD PTR _serial$[ebp+ecx]
  005ff	52		 push	 edx
  00600	e8 00 00 00 00	 call	 _decoder_homing_frame_test_first
  00605	83 c4 08	 add	 esp, 8
  00608	66 89 85 2c fc
	ff ff		 mov	 WORD PTR _reset_flag$[ebp], ax
$LN9@main:

; 246  :      }
; 247  :      /* produce encoder homing frame if homed & input=decoder homing frame */
; 248  :      if ((reset_flag != 0) && (reset_flag_old != 0))

  0060f	0f bf 85 2c fc
	ff ff		 movsx	 eax, WORD PTR _reset_flag$[ebp]
  00616	85 c0		 test	 eax, eax
  00618	74 4e		 je	 SHORT $LN8@main
  0061a	0f bf 85 20 fc
	ff ff		 movsx	 eax, WORD PTR _reset_flag_old$[ebp]
  00621	85 c0		 test	 eax, eax
  00623	74 43		 je	 SHORT $LN8@main

; 249  :      {
; 250  :          for (i = 0; i < L_FRAME; i++)

  00625	33 c0		 xor	 eax, eax
  00627	66 89 85 14 fc
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0062e	eb 12		 jmp	 SHORT $LN7@main
$LN6@main:
  00630	66 8b 85 14 fc
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00637	66 83 c0 01	 add	 ax, 1
  0063b	66 89 85 14 fc
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@main:
  00642	0f bf 85 14 fc
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00649	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0064e	7d 16		 jge	 SHORT $LN5@main

; 251  :          {
; 252  :              synth[i] = EHF_MASK;

  00650	0f bf 85 14 fc
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00657	b9 08 00 00 00	 mov	 ecx, 8
  0065c	66 89 8c 45 b0
	fc ff ff	 mov	 WORD PTR _synth$[ebp+eax*2], cx

; 253  :          }

  00664	eb ca		 jmp	 SHORT $LN6@main
$LN5@main:

; 254  :      }
; 255  :      else

  00666	eb 31		 jmp	 SHORT $LN4@main
$LN8@main:

; 256  :      {     
; 257  :          /* decode frame */
; 258  :          Speech_Decode_Frame(speech_decoder_state, mode, &serial[1],
; 259  :                              rx_type, synth);

  00668	8d 85 b0 fc ff
	ff		 lea	 eax, DWORD PTR _synth$[ebp]
  0066e	50		 push	 eax
  0066f	8b 8d 44 fc ff
	ff		 mov	 ecx, DWORD PTR _rx_type$[ebp]
  00675	51		 push	 ecx
  00676	ba 02 00 00 00	 mov	 edx, 2
  0067b	c1 e2 00	 shl	 edx, 0
  0067e	8d 84 15 f8 fd
	ff ff		 lea	 eax, DWORD PTR _serial$[ebp+edx]
  00685	50		 push	 eax
  00686	8b 8d 50 fc ff
	ff		 mov	 ecx, DWORD PTR _mode$[ebp]
  0068c	51		 push	 ecx
  0068d	8b 55 f4	 mov	 edx, DWORD PTR _speech_decoder_state$[ebp]
  00690	52		 push	 edx
  00691	e8 00 00 00 00	 call	 _Speech_Decode_Frame
  00696	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@main:

; 260  :      }
; 261  :      
; 262  :      /* write synthesized speech to file */
; 263  :      if (fwrite (synth, sizeof (Word16), L_FRAME, file_syn) != L_FRAME) {

  00699	8b f4		 mov	 esi, esp
  0069b	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _file_syn$[ebp]
  006a1	50		 push	 eax
  006a2	68 a0 00 00 00	 push	 160			; 000000a0H
  006a7	6a 02		 push	 2
  006a9	8d 8d b0 fc ff
	ff		 lea	 ecx, DWORD PTR _synth$[ebp]
  006af	51		 push	 ecx
  006b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  006b6	83 c4 10	 add	 esp, 16			; 00000010H
  006b9	3b f4		 cmp	 esi, esp
  006bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006c0	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  006c5	74 55		 je	 SHORT $LN3@main

; 264  :          fprintf(stderr, "\nerror writing output file: %s\n",
; 265  :                  strerror(errno));

  006c7	8b f4		 mov	 esi, esp
  006c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  006cf	3b f4		 cmp	 esi, esp
  006d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006d6	8b f4		 mov	 esi, esp
  006d8	8b 00		 mov	 eax, DWORD PTR [eax]
  006da	50		 push	 eax
  006db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  006e1	83 c4 04	 add	 esp, 4
  006e4	3b f4		 cmp	 esi, esp
  006e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006eb	8b f4		 mov	 esi, esp
  006ed	50		 push	 eax
  006ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@
  006f3	8b fc		 mov	 edi, esp
  006f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  006fb	3b fc		 cmp	 edi, esp
  006fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00702	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00707	d1 e1		 shl	 ecx, 1
  00709	03 c1		 add	 eax, ecx
  0070b	50		 push	 eax
  0070c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00712	83 c4 0c	 add	 esp, 12			; 0000000cH
  00715	3b f4		 cmp	 esi, esp
  00717	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@main:

; 266  :      };
; 267  :      fflush(file_syn);

  0071c	8b f4		 mov	 esi, esp
  0071e	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _file_syn$[ebp]
  00724	50		 push	 eax
  00725	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0072b	83 c4 04	 add	 esp, 4
  0072e	3b f4		 cmp	 esi, esp
  00730	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 268  : 
; 269  :      /* if not homed: check whether current frame is a homing frame */
; 270  :      if (reset_flag_old == 0)

  00735	0f bf 85 20 fc
	ff ff		 movsx	 eax, WORD PTR _reset_flag_old$[ebp]
  0073c	85 c0		 test	 eax, eax
  0073e	75 26		 jne	 SHORT $LN2@main

; 271  :      {
; 272  :          /* check whole frame */
; 273  :          reset_flag = decoder_homing_frame_test(&serial[1], mode);

  00740	8b 85 50 fc ff
	ff		 mov	 eax, DWORD PTR _mode$[ebp]
  00746	50		 push	 eax
  00747	b9 02 00 00 00	 mov	 ecx, 2
  0074c	c1 e1 00	 shl	 ecx, 0
  0074f	8d 94 0d f8 fd
	ff ff		 lea	 edx, DWORD PTR _serial$[ebp+ecx]
  00756	52		 push	 edx
  00757	e8 00 00 00 00	 call	 _decoder_homing_frame_test
  0075c	83 c4 08	 add	 esp, 8
  0075f	66 89 85 2c fc
	ff ff		 mov	 WORD PTR _reset_flag$[ebp], ax
$LN2@main:

; 274  :      }
; 275  :      /* reset decoder if current frame is a homing frame */
; 276  :      if (reset_flag != 0)

  00766	0f bf 85 2c fc
	ff ff		 movsx	 eax, WORD PTR _reset_flag$[ebp]
  0076d	85 c0		 test	 eax, eax
  0076f	74 0c		 je	 SHORT $LN1@main

; 277  :      {
; 278  :          Speech_Decode_Frame_reset(speech_decoder_state);

  00771	8b 45 f4	 mov	 eax, DWORD PTR _speech_decoder_state$[ebp]
  00774	50		 push	 eax
  00775	e8 00 00 00 00	 call	 _Speech_Decode_Frame_reset
  0077a	83 c4 04	 add	 esp, 4
$LN1@main:

; 279  :      }
; 280  :      reset_flag_old = reset_flag;

  0077d	66 8b 85 2c fc
	ff ff		 mov	 ax, WORD PTR _reset_flag$[ebp]
  00784	66 89 85 20 fc
	ff ff		 mov	 WORD PTR _reset_flag_old$[ebp], ax

; 281  : 
; 282  :   }

  0078b	e9 0d fd ff ff	 jmp	 $LN14@main
$LN13@main:

; 283  :   fprintf (stderr, "\n%d frame(s) processed\n", frame);

  00790	8b f4		 mov	 esi, esp
  00792	8b 85 a4 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  00798	50		 push	 eax
  00799	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@
  0079e	8b fc		 mov	 edi, esp
  007a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  007a6	3b fc		 cmp	 edi, esp
  007a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007ad	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  007b2	d1 e1		 shl	 ecx, 1
  007b4	03 c1		 add	 eax, ecx
  007b6	50		 push	 eax
  007b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  007bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  007c0	3b f4		 cmp	 esi, esp
  007c2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 284  :   
; 285  :   /*-----------------------------------------------------------------------*
; 286  :    * Close down speech decoder                                             *
; 287  :    *-----------------------------------------------------------------------*/
; 288  :   Speech_Decode_Frame_exit(&speech_decoder_state);

  007c7	8d 45 f4	 lea	 eax, DWORD PTR _speech_decoder_state$[ebp]
  007ca	50		 push	 eax
  007cb	e8 00 00 00 00	 call	 _Speech_Decode_Frame_exit
  007d0	83 c4 04	 add	 esp, 4

; 289  :   
; 290  :   return 0;

  007d3	33 c0		 xor	 eax, eax
$LN27@main:

; 291  : }

  007d5	52		 push	 edx
  007d6	8b cd		 mov	 ecx, ebp
  007d8	50		 push	 eax
  007d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN39@main
  007df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007e4	58		 pop	 eax
  007e5	5a		 pop	 edx
  007e6	5f		 pop	 edi
  007e7	5e		 pop	 esi
  007e8	5b		 pop	 ebx
  007e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ec	33 cd		 xor	 ecx, ebp
  007ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f3	81 c4 34 05 00
	00		 add	 esp, 1332		; 00000534H
  007f9	3b ec		 cmp	 ebp, esp
  007fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00800	8b e5		 mov	 esp, ebp
  00802	5d		 pop	 ebp
  00803	c3		 ret	 0
$LN39@main:
  00804	0a 00 00 00	 DD	 10			; 0000000aH
  00808	00 00 00 00	 DD	 $LN38@main
$LN38@main:
  0080c	f4 ff ff ff	 DD	 -12			; fffffff4H
  00810	04 00 00 00	 DD	 4
  00814	00 00 00 00	 DD	 $LN28@main
  00818	f8 fd ff ff	 DD	 -520			; fffffdf8H
  0081c	f4 01 00 00	 DD	 500			; 000001f4H
  00820	00 00 00 00	 DD	 $LN29@main
  00824	b0 fc ff ff	 DD	 -848			; fffffcb0H
  00828	40 01 00 00	 DD	 320			; 00000140H
  0082c	00 00 00 00	 DD	 $LN30@main
  00830	74 fc ff ff	 DD	 -908			; fffffc74H
  00834	04 00 00 00	 DD	 4
  00838	00 00 00 00	 DD	 $LN31@main
  0083c	68 fc ff ff	 DD	 -920			; fffffc68H
  00840	04 00 00 00	 DD	 4
  00844	00 00 00 00	 DD	 $LN32@main
  00848	50 fc ff ff	 DD	 -944			; fffffc50H
  0084c	04 00 00 00	 DD	 4
  00850	00 00 00 00	 DD	 $LN33@main
  00854	0b fc ff ff	 DD	 -1013			; fffffc0bH
  00858	01 00 00 00	 DD	 1
  0085c	00 00 00 00	 DD	 $LN34@main
  00860	e0 fb ff ff	 DD	 -1056			; fffffbe0H
  00864	08 00 00 00	 DD	 8
  00868	00 00 00 00	 DD	 $LN35@main
  0086c	b8 fb ff ff	 DD	 -1096			; fffffbb8H
  00870	20 00 00 00	 DD	 32			; 00000020H
  00874	00 00 00 00	 DD	 $LN36@main
  00878	90 fb ff ff	 DD	 -1136			; fffffb90H
  0087c	20 00 00 00	 DD	 32			; 00000020H
  00880	00 00 00 00	 DD	 $LN37@main
$LN37@main:
  00884	70		 DB	 112			; 00000070H
  00885	61		 DB	 97			; 00000061H
  00886	63		 DB	 99			; 00000063H
  00887	6b		 DB	 107			; 0000006bH
  00888	65		 DB	 101			; 00000065H
  00889	64		 DB	 100			; 00000064H
  0088a	5f		 DB	 95			; 0000005fH
  0088b	73		 DB	 115			; 00000073H
  0088c	69		 DB	 105			; 00000069H
  0088d	7a		 DB	 122			; 0000007aH
  0088e	65		 DB	 101			; 00000065H
  0088f	00		 DB	 0
$LN36@main:
  00890	70		 DB	 112			; 00000070H
  00891	61		 DB	 97			; 00000061H
  00892	63		 DB	 99			; 00000063H
  00893	6b		 DB	 107			; 0000006bH
  00894	65		 DB	 101			; 00000065H
  00895	64		 DB	 100			; 00000064H
  00896	5f		 DB	 95			; 0000005fH
  00897	62		 DB	 98			; 00000062H
  00898	69		 DB	 105			; 00000069H
  00899	74		 DB	 116			; 00000074H
  0089a	73		 DB	 115			; 00000073H
  0089b	00		 DB	 0
$LN35@main:
  0089c	6d		 DB	 109			; 0000006dH
  0089d	61		 DB	 97			; 00000061H
  0089e	67		 DB	 103			; 00000067H
  0089f	69		 DB	 105			; 00000069H
  008a0	63		 DB	 99			; 00000063H
  008a1	00		 DB	 0
$LN34@main:
  008a2	74		 DB	 116			; 00000074H
  008a3	6f		 DB	 111			; 0000006fH
  008a4	63		 DB	 99			; 00000063H
  008a5	00		 DB	 0
$LN33@main:
  008a6	6d		 DB	 109			; 0000006dH
  008a7	6f		 DB	 111			; 0000006fH
  008a8	64		 DB	 100			; 00000064H
  008a9	65		 DB	 101			; 00000065H
  008aa	00		 DB	 0
$LN32@main:
  008ab	66		 DB	 102			; 00000066H
  008ac	69		 DB	 105			; 00000069H
  008ad	6c		 DB	 108			; 0000006cH
  008ae	65		 DB	 101			; 00000065H
  008af	5f		 DB	 95			; 0000005fH
  008b0	73		 DB	 115			; 00000073H
  008b1	65		 DB	 101			; 00000065H
  008b2	72		 DB	 114			; 00000072H
  008b3	69		 DB	 105			; 00000069H
  008b4	61		 DB	 97			; 00000061H
  008b5	6c		 DB	 108			; 0000006cH
  008b6	00		 DB	 0
$LN31@main:
  008b7	66		 DB	 102			; 00000066H
  008b8	69		 DB	 105			; 00000069H
  008b9	6c		 DB	 108			; 0000006cH
  008ba	65		 DB	 101			; 00000065H
  008bb	5f		 DB	 95			; 0000005fH
  008bc	73		 DB	 115			; 00000073H
  008bd	79		 DB	 121			; 00000079H
  008be	6e		 DB	 110			; 0000006eH
  008bf	00		 DB	 0
$LN30@main:
  008c0	73		 DB	 115			; 00000073H
  008c1	79		 DB	 121			; 00000079H
  008c2	6e		 DB	 110			; 0000006eH
  008c3	74		 DB	 116			; 00000074H
  008c4	68		 DB	 104			; 00000068H
  008c5	00		 DB	 0
$LN29@main:
  008c6	73		 DB	 115			; 00000073H
  008c7	65		 DB	 101			; 00000065H
  008c8	72		 DB	 114			; 00000072H
  008c9	69		 DB	 105			; 00000069H
  008ca	61		 DB	 97			; 00000061H
  008cb	6c		 DB	 108			; 0000006cH
  008cc	00		 DB	 0
$LN28@main:
  008cd	73		 DB	 115			; 00000073H
  008ce	70		 DB	 112			; 00000070H
  008cf	65		 DB	 101			; 00000065H
  008d0	65		 DB	 101			; 00000065H
  008d1	63		 DB	 99			; 00000063H
  008d2	68		 DB	 104			; 00000068H
  008d3	5f		 DB	 95			; 0000005fH
  008d4	64		 DB	 100			; 00000064H
  008d5	65		 DB	 101			; 00000065H
  008d6	63		 DB	 99			; 00000063H
  008d7	6f		 DB	 111			; 0000006fH
  008d8	64		 DB	 100			; 00000064H
  008d9	65		 DB	 101			; 00000065H
  008da	72		 DB	 114			; 00000072H
  008db	5f		 DB	 95			; 0000005fH
  008dc	73		 DB	 115			; 00000073H
  008dd	74		 DB	 116			; 00000074H
  008de	61		 DB	 97			; 00000061H
  008df	74		 DB	 116			; 00000074H
  008e0	65		 DB	 101			; 00000065H
  008e1	00		 DB	 0
_main	ENDP
_TEXT	ENDS
END
