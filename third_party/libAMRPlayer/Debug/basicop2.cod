; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\basicop2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Overflow
PUBLIC	_Carry
_BSS	SEGMENT
_Overflow DD	01H DUP (?)
_Carry	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_add
PUBLIC	_sub
PUBLIC	_abs_s
PUBLIC	_shl
PUBLIC	_shr
PUBLIC	_mult
PUBLIC	_L_mult
PUBLIC	_negate
PUBLIC	_extract_h
PUBLIC	_extract_l
PUBLIC	_round
PUBLIC	_L_mac
PUBLIC	_L_msu
PUBLIC	_L_macNs
PUBLIC	_L_msuNs
PUBLIC	_L_add
PUBLIC	_L_sub
PUBLIC	_L_add_c
PUBLIC	_L_sub_c
PUBLIC	_L_negate
PUBLIC	_mult_r
PUBLIC	_L_shl
PUBLIC	_L_shr
PUBLIC	_shr_r
PUBLIC	_mac_r
PUBLIC	_msu_r
PUBLIC	_L_deposit_h
PUBLIC	_L_deposit_l
PUBLIC	_L_shr_r
PUBLIC	_L_abs
PUBLIC	_L_sat
PUBLIC	_norm_s
PUBLIC	_div_s
PUBLIC	_norm_l
PUBLIC	_saturate
PUBLIC	??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@ ; `string'
PUBLIC	??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@ ; `string'
EXTRN	__imp__printf:PROC
EXTRN	__imp__abort:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@
CONST	SEGMENT
??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@ DB 'Division '
	DB	'by 0, Fatal error ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@
CONST	SEGMENT
??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@ DB 'D'
	DB	'ivision Error var1=%d  var2=%d', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _saturate
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var1$ = 8						; size = 4
_saturate PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 77   :     Word16 var_out;
; 78   : 
; 79   :     if (L_var1 > 0X00007fffL)

  0001e	81 7d 08 ff 7f
	00 00		 cmp	 DWORD PTR _L_var1$[ebp], 32767 ; 00007fffH
  00025	7e 15		 jle	 SHORT $LN4@saturate

; 80   :     {
; 81   :         Overflow = 1;

  00027	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00031	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00036	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
  0003a	eb 2e		 jmp	 SHORT $LN3@saturate
$LN4@saturate:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0003c	81 7d 08 00 80
	ff ff		 cmp	 DWORD PTR _L_var1$[ebp], -32768 ; ffff8000H
  00043	7d 15		 jge	 SHORT $LN2@saturate

; 85   :     {
; 86   :         Overflow = 1;

  00045	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0004f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00054	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 88   :     }
; 89   :     else

  00058	eb 10		 jmp	 SHORT $LN3@saturate
$LN2@saturate:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0005a	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _extract_l
  00063	83 c4 04	 add	 esp, 4
  00066	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN3@saturate:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);

  0006a	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 98   : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_saturate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _norm_l
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var1$ = 8						; size = 4
_norm_l	PROC						; COMDAT

; 2106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2107 :     Word16 var_out;
; 2108 : 
; 2109 :     if (L_var1 == 0)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00022	75 08		 jne	 SHORT $LN8@norm_l

; 2110 :     {
; 2111 :         var_out = 0;

  00024	33 c0		 xor	 eax, eax
  00026	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2112 :     }
; 2113 :     else

  0002a	eb 46		 jmp	 SHORT $LN7@norm_l
$LN8@norm_l:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  0002c	83 7d 08 ff	 cmp	 DWORD PTR _L_var1$[ebp], -1
  00030	75 0b		 jne	 SHORT $LN6@norm_l

; 2116 :         {
; 2117 :             var_out = 31;

  00032	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00037	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2118 :         }
; 2119 :         else

  0003b	eb 35		 jmp	 SHORT $LN7@norm_l
$LN6@norm_l:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  0003d	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00041	7d 08		 jge	 SHORT $LN4@norm_l

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00043	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00046	f7 d0		 not	 eax
  00048	89 45 08	 mov	 DWORD PTR _L_var1$[ebp], eax
$LN4@norm_l:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  0004b	33 c0		 xor	 eax, eax
  0004d	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
  00051	eb 0c		 jmp	 SHORT $LN3@norm_l
$LN2@norm_l:
  00053	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]
  00057	66 83 c0 01	 add	 ax, 1
  0005b	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN3@norm_l:
  0005f	81 7d 08 00 00
	00 40		 cmp	 DWORD PTR _L_var1$[ebp], 1073741824 ; 40000000H
  00066	7d 0a		 jge	 SHORT $LN7@norm_l

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00068	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0006b	d1 e0		 shl	 eax, 1
  0006d	89 45 08	 mov	 DWORD PTR _L_var1$[ebp], eax

; 2128 :             }

  00070	eb e1		 jmp	 SHORT $LN2@norm_l
$LN7@norm_l:

; 2129 :         }
; 2130 :     }
; 2131 : 
; 2132 : #if (WMOPS)
; 2133 :     multiCounter[currCounter].norm_l++;
; 2134 : #endif
; 2135 :     return (var_out);

  00072	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 2136 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_norm_l	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _div_s
_TEXT	SEGMENT
_L_denom$ = -44						; size = 4
_L_num$ = -32						; size = 4
_iteration$ = -20					; size = 2
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_div_s	PROC						; COMDAT

; 2009 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2010 :     Word16 var_out = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2011 :     Word16 iteration;
; 2012 :     Word32 L_num;
; 2013 :     Word32 L_denom;
; 2014 : 
; 2015 :     if ((var1 > var2) || (var1 < 0) || (var2 < 0))

  00024	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00028	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  0002c	3b c1		 cmp	 eax, ecx
  0002e	7f 10		 jg	 SHORT $LN10@div_s
  00030	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00034	85 c0		 test	 eax, eax
  00036	7c 08		 jl	 SHORT $LN10@div_s
  00038	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0003c	85 c0		 test	 eax, eax
  0003e	7d 30		 jge	 SHORT $LN11@div_s
$LN10@div_s:

; 2016 :     {
; 2017 :         printf ("Division Error var1=%d  var2=%d\n", var1, var2);

  00040	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00044	8b f4		 mov	 esi, esp
  00046	50		 push	 eax
  00047	0f bf 4d 08	 movsx	 ecx, WORD PTR _var1$[ebp]
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2018 :         abort(); /* exit (0); */

  00061	8b f4		 mov	 esi, esp
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@div_s:

; 2019 :     }
; 2020 :     if (var2 == 0)

  00070	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00074	85 c0		 test	 eax, eax
  00076	75 26		 jne	 SHORT $LN9@div_s

; 2021 :     {
; 2022 :         printf ("Division by 0, Fatal error \n");

  00078	8b f4		 mov	 esi, esp
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00085	83 c4 04	 add	 esp, 4
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2023 :         abort(); /* exit (0); */

  0008f	8b f4		 mov	 esi, esp
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
  00097	3b f4		 cmp	 esi, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@div_s:

; 2024 :     }
; 2025 :     if (var1 == 0)

  0009e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  000a2	85 c0		 test	 eax, eax
  000a4	75 0b		 jne	 SHORT $LN8@div_s

; 2026 :     {
; 2027 :         var_out = 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2028 :     }
; 2029 :     else

  000ac	e9 9a 00 00 00	 jmp	 $LN7@div_s
$LN8@div_s:

; 2030 :     {
; 2031 :         if (var1 == var2)

  000b1	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  000b5	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  000b9	3b c1		 cmp	 eax, ecx
  000bb	75 0e		 jne	 SHORT $LN6@div_s

; 2032 :         {
; 2033 :             var_out = MAX_16;

  000bd	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000c2	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2034 :         }
; 2035 :         else

  000c6	e9 80 00 00 00	 jmp	 $LN7@div_s
$LN6@div_s:

; 2036 :         {
; 2037 :             L_num = L_deposit_l (var1);

  000cb	0f b7 45 08	 movzx	 eax, WORD PTR _var1$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _L_deposit_l
  000d5	83 c4 04	 add	 esp, 4
  000d8	89 45 e0	 mov	 DWORD PTR _L_num$[ebp], eax

; 2038 : #if (WMOPS)
; 2039 :             multiCounter[currCounter].L_deposit_l--;
; 2040 : #endif
; 2041 :             L_denom = L_deposit_l (var2);

  000db	0f b7 45 0c	 movzx	 eax, WORD PTR _var2$[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _L_deposit_l
  000e5	83 c4 04	 add	 esp, 4
  000e8	89 45 d4	 mov	 DWORD PTR _L_denom$[ebp], eax

; 2042 : #if (WMOPS)
; 2043 :             multiCounter[currCounter].L_deposit_l--;
; 2044 : #endif
; 2045 : 
; 2046 :             for (iteration = 0; iteration < 15; iteration++)

  000eb	33 c0		 xor	 eax, eax
  000ed	66 89 45 ec	 mov	 WORD PTR _iteration$[ebp], ax
  000f1	eb 0c		 jmp	 SHORT $LN4@div_s
$LN3@div_s:
  000f3	66 8b 45 ec	 mov	 ax, WORD PTR _iteration$[ebp]
  000f7	66 83 c0 01	 add	 ax, 1
  000fb	66 89 45 ec	 mov	 WORD PTR _iteration$[ebp], ax
$LN4@div_s:
  000ff	0f bf 45 ec	 movsx	 eax, WORD PTR _iteration$[ebp]
  00103	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00106	7d 43		 jge	 SHORT $LN7@div_s

; 2047 :             {
; 2048 :                 var_out <<= 1;

  00108	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]
  0010c	66 d1 e0	 shl	 ax, 1
  0010f	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 2049 :                 L_num <<= 1;

  00113	8b 45 e0	 mov	 eax, DWORD PTR _L_num$[ebp]
  00116	d1 e0		 shl	 eax, 1
  00118	89 45 e0	 mov	 DWORD PTR _L_num$[ebp], eax

; 2050 : 
; 2051 :                 if (L_num >= L_denom)

  0011b	8b 45 e0	 mov	 eax, DWORD PTR _L_num$[ebp]
  0011e	3b 45 d4	 cmp	 eax, DWORD PTR _L_denom$[ebp]
  00121	7c 26		 jl	 SHORT $LN1@div_s

; 2052 :                 {
; 2053 :                     L_num = L_sub (L_num, L_denom);

  00123	8b 45 d4	 mov	 eax, DWORD PTR _L_denom$[ebp]
  00126	50		 push	 eax
  00127	8b 4d e0	 mov	 ecx, DWORD PTR _L_num$[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _L_sub
  00130	83 c4 08	 add	 esp, 8
  00133	89 45 e0	 mov	 DWORD PTR _L_num$[ebp], eax

; 2054 : #if (WMOPS)
; 2055 :                     multiCounter[currCounter].L_sub--;
; 2056 : #endif
; 2057 :                     var_out = add (var_out, 1);

  00136	6a 01		 push	 1
  00138	0f b7 45 f8	 movzx	 eax, WORD PTR _var_out$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _add
  00142	83 c4 08	 add	 esp, 8
  00145	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN1@div_s:

; 2058 : #if (WMOPS)
; 2059 :                     multiCounter[currCounter].add--;
; 2060 : #endif
; 2061 :                 }
; 2062 :             }

  00149	eb a8		 jmp	 SHORT $LN3@div_s
$LN7@div_s:

; 2063 :         }
; 2064 :     }
; 2065 : 
; 2066 : #if (WMOPS)
; 2067 :     multiCounter[currCounter].div_s++;
; 2068 : #endif
; 2069 :     return (var_out);

  0014b	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]
$LN13@div_s:

; 2070 : }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00158	3b ec		 cmp	 ebp, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
_div_s	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _norm_s
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_norm_s	PROC						; COMDAT

; 1939 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1940 :     Word16 var_out;
; 1941 : 
; 1942 :     if (var1 == 0)

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	75 08		 jne	 SHORT $LN8@norm_s

; 1943 :     {
; 1944 :         var_out = 0;

  00026	33 c0		 xor	 eax, eax
  00028	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1945 :     }
; 1946 :     else

  0002c	eb 52		 jmp	 SHORT $LN7@norm_s
$LN8@norm_s:

; 1947 :     {
; 1948 :         if (var1 == (Word16) 0xffff)

  0002e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00032	83 f8 ff	 cmp	 eax, -1
  00035	75 0b		 jne	 SHORT $LN6@norm_s

; 1949 :         {
; 1950 :             var_out = 15;

  00037	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0003c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1951 :         }
; 1952 :         else

  00040	eb 3e		 jmp	 SHORT $LN7@norm_s
$LN6@norm_s:

; 1953 :         {
; 1954 :             if (var1 < 0)

  00042	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00046	85 c0		 test	 eax, eax
  00048	7d 0a		 jge	 SHORT $LN4@norm_s

; 1955 :             {
; 1956 :                 var1 = ~var1;

  0004a	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  0004e	f7 d0		 not	 eax
  00050	66 89 45 08	 mov	 WORD PTR _var1$[ebp], ax
$LN4@norm_s:

; 1957 :             }
; 1958 :             for (var_out = 0; var1 < 0x4000; var_out++)

  00054	33 c0		 xor	 eax, eax
  00056	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
  0005a	eb 0c		 jmp	 SHORT $LN3@norm_s
$LN2@norm_s:
  0005c	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]
  00060	66 83 c0 01	 add	 ax, 1
  00064	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN3@norm_s:
  00068	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  0006c	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00071	7d 0d		 jge	 SHORT $LN7@norm_s

; 1959 :             {
; 1960 :                 var1 <<= 1;

  00073	66 8b 45 08	 mov	 ax, WORD PTR _var1$[ebp]
  00077	66 d1 e0	 shl	 ax, 1
  0007a	66 89 45 08	 mov	 WORD PTR _var1$[ebp], ax

; 1961 :             }

  0007e	eb dc		 jmp	 SHORT $LN2@norm_s
$LN7@norm_s:

; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 : #if (WMOPS)
; 1966 :     multiCounter[currCounter].norm_s++;
; 1967 : #endif
; 1968 :     return (var_out);

  00080	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 1969 : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_norm_s	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_sat
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_sat	PROC						; COMDAT

; 1879 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1880 :     Word32 L_var_out;
; 1881 : 
; 1882 :     L_var_out = L_var1;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1883 : 
; 1884 :     if (Overflow)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Overflow, 0
  0002b	74 2d		 je	 SHORT $LN3@L_sat

; 1885 :     {
; 1886 : 
; 1887 :         if (Carry)

  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Carry, 0
  00034	74 09		 je	 SHORT $LN2@L_sat

; 1888 :         {
; 1889 :             L_var_out = MIN_32;

  00036	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _L_var_out$[ebp], -2147483648 ; 80000000H

; 1890 :         }
; 1891 :         else

  0003d	eb 07		 jmp	 SHORT $LN1@L_sat
$LN2@L_sat:

; 1892 :         {
; 1893 :             L_var_out = MAX_32;

  0003f	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _L_var_out$[ebp], 2147483647 ; 7fffffffH
$LN1@L_sat:

; 1894 :         }
; 1895 : 
; 1896 :         Carry = 0;

  00046	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Carry, 0

; 1897 :         Overflow = 0;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0
$LN3@L_sat:

; 1898 :     }
; 1899 : #if (WMOPS)
; 1900 :     multiCounter[currCounter].L_sat++;
; 1901 : #endif
; 1902 :     return (L_var_out);

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1903 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_L_sat	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_abs
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_abs	PROC						; COMDAT

; 1822 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1823 :     Word32 L_var_out;
; 1824 : 
; 1825 :     if (L_var1 == MIN_32)

  0001e	81 7d 08 00 00
	00 80		 cmp	 DWORD PTR _L_var1$[ebp], -2147483648 ; 80000000H
  00025	75 09		 jne	 SHORT $LN4@L_abs

; 1826 :     {
; 1827 :         L_var_out = MAX_32;

  00027	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _L_var_out$[ebp], 2147483647 ; 7fffffffH

; 1828 :     }
; 1829 :     else

  0002e	eb 16		 jmp	 SHORT $LN3@L_abs
$LN4@L_abs:

; 1830 :     {
; 1831 :         if (L_var1 < 0)

  00030	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00034	7d 0a		 jge	 SHORT $LN2@L_abs

; 1832 :         {
; 1833 :             L_var_out = -L_var1;

  00036	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00039	f7 d8		 neg	 eax
  0003b	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1834 :         }
; 1835 :         else

  0003e	eb 06		 jmp	 SHORT $LN3@L_abs
$LN2@L_abs:

; 1836 :         {
; 1837 :             L_var_out = L_var1;

  00040	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00043	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax
$LN3@L_abs:

; 1838 :         }
; 1839 :     }
; 1840 : 
; 1841 : #if (WMOPS)
; 1842 :     multiCounter[currCounter].L_abs++;
; 1843 : #endif
; 1844 :     return (L_var_out);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1845 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_L_abs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shr_r
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_var2$ = 12						; size = 2
_L_shr_r PROC						; COMDAT

; 1765 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1766 :     Word32 L_var_out;
; 1767 : 
; 1768 :     if (var2 > 31)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	7e 09		 jle	 SHORT $LN4@L_shr_r

; 1769 :     {
; 1770 :         L_var_out = 0;

  00027	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _L_var_out$[ebp], 0

; 1771 :     }
; 1772 :     else

  0002e	eb 38		 jmp	 SHORT $LN3@L_shr_r
$LN4@L_shr_r:

; 1773 :     {
; 1774 :         L_var_out = L_shr (L_var1, var2);

  00030	0f b7 45 0c	 movzx	 eax, WORD PTR _var2$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _L_var1$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _L_shr
  0003e	83 c4 08	 add	 esp, 8
  00041	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1775 : #if (WMOPS)
; 1776 :         multiCounter[currCounter].L_shr--;
; 1777 : #endif
; 1778 :         if (var2 > 0)

  00044	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00048	85 c0		 test	 eax, eax
  0004a	7e 1c		 jle	 SHORT $LN3@L_shr_r

; 1779 :         {
; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  0004c	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00050	83 e9 01	 sub	 ecx, 1
  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	d3 e0		 shl	 eax, cl
  0005a	23 45 08	 and	 eax, DWORD PTR _L_var1$[ebp]
  0005d	74 09		 je	 SHORT $LN3@L_shr_r

; 1781 :             {
; 1782 :                 L_var_out++;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax
$LN3@L_shr_r:

; 1783 :             }
; 1784 :         }
; 1785 :     }
; 1786 : #if (WMOPS)
; 1787 :     multiCounter[currCounter].L_shr_r++;
; 1788 : #endif
; 1789 :     return (L_var_out);

  00068	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1790 : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_L_shr_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_deposit_l
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_var1$ = 8						; size = 2
_L_deposit_l PROC					; COMDAT

; 1712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1716 : #if (WMOPS)
; 1717 :     multiCounter[currCounter].L_deposit_l++;
; 1718 : #endif
; 1719 :     return (L_var_out);

  00025	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1720 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_L_deposit_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_deposit_h
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_var1$ = 8						; size = 2
_L_deposit_h PROC					; COMDAT

; 1672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	c1 e0 10	 shl	 eax, 16			; 00000010H
  00025	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);

  00028	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1680 : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_L_deposit_h ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _msu_r
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_msu_r	PROC						; COMDAT

; 1623 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _L_var3$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _L_msu
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	89 45 08	 mov	 DWORD PTR _L_var3$[ebp], eax

; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);

  00037	68 00 80 00 00	 push	 32768			; 00008000H
  0003c	8b 45 08	 mov	 eax, DWORD PTR _L_var3$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _L_add
  00045	83 c4 08	 add	 esp, 8
  00048	89 45 08	 mov	 DWORD PTR _L_var3$[ebp], eax

; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _L_var3$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _extract_h
  00054	83 c4 04	 add	 esp, 4
  00057	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);

  0005b	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 1640 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_msu_r	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _mac_r
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_mac_r	PROC						; COMDAT

; 1564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _L_var3$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _L_mac
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	89 45 08	 mov	 DWORD PTR _L_var3$[ebp], eax

; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);

  00037	68 00 80 00 00	 push	 32768			; 00008000H
  0003c	8b 45 08	 mov	 eax, DWORD PTR _L_var3$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _L_add
  00045	83 c4 08	 add	 esp, 8
  00048	89 45 08	 mov	 DWORD PTR _L_var3$[ebp], eax

; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _L_var3$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _extract_h
  00054	83 c4 04	 add	 esp, 4
  00057	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);

  0005b	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 1581 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_mac_r	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shr_r
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_shr_r	PROC						; COMDAT

; 1496 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00022	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00025	7e 08		 jle	 SHORT $LN4@shr_r

; 1500 :     {
; 1501 :         var_out = 0;

  00027	33 c0		 xor	 eax, eax
  00029	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1502 :     }
; 1503 :     else

  0002d	eb 40		 jmp	 SHORT $LN3@shr_r
$LN4@shr_r:

; 1504 :     {
; 1505 :         var_out = shr (var1, var2);

  0002f	0f b7 45 0c	 movzx	 eax, WORD PTR _var2$[ebp]
  00033	50		 push	 eax
  00034	0f b7 4d 08	 movzx	 ecx, WORD PTR _var1$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _shr
  0003e	83 c4 08	 add	 esp, 8
  00041	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)

  00045	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00049	85 c0		 test	 eax, eax
  0004b	7e 22		 jle	 SHORT $LN3@shr_r

; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)

  0004d	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00051	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00055	83 e9 01	 sub	 ecx, 1
  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	d3 e2		 shl	 edx, cl
  0005f	23 c2		 and	 eax, edx
  00061	74 0c		 je	 SHORT $LN3@shr_r

; 1513 :             {
; 1514 :                 var_out++;

  00063	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]
  00067	66 83 c0 01	 add	 ax, 1
  0006b	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN3@shr_r:

; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);

  0006f	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 1522 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_shr_r	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shr
_TEXT	SEGMENT
tv77 = -208						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_var2$ = 12						; size = 2
_L_shr	PROC						; COMDAT

; 1417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7d 2a		 jge	 SHORT $LN7@L_shr

; 1421 :     {
; 1422 :         if (var2 < -32)

  00026	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0002a	83 f8 e0	 cmp	 eax, -32		; ffffffe0H
  0002d	7d 09		 jge	 SHORT $LN6@L_shr

; 1423 :             var2 = -32;

  0002f	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  00034	66 89 45 0c	 mov	 WORD PTR _var2$[ebp], ax
$LN6@L_shr:

; 1424 :         L_var_out = L_shl (L_var1, -var2);

  00038	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0003c	f7 d8		 neg	 eax
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _L_var1$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _L_shl
  00048	83 c4 08	 add	 esp, 8
  0004b	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  0004e	eb 54		 jmp	 SHORT $LN5@L_shr
$LN7@L_shr:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  00050	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00054	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00057	7c 27		 jl	 SHORT $LN4@L_shr

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  00059	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  0005d	7d 0c		 jge	 SHORT $LN10@L_shr
  0005f	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv77[ebp], -1
  00069	eb 0a		 jmp	 SHORT $LN11@L_shr
$LN10@L_shr:
  0006b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN11@L_shr:
  00075	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  0007b	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1434 :         }
; 1435 :         else

  0007e	eb 24		 jmp	 SHORT $LN5@L_shr
$LN4@L_shr:

; 1436 :         {
; 1437 :             if (L_var1 < 0)

  00080	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00084	7d 12		 jge	 SHORT $LN2@L_shr

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00086	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00089	f7 d0		 not	 eax
  0008b	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  0008f	d3 f8		 sar	 eax, cl
  00091	f7 d0		 not	 eax
  00093	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1440 :             }
; 1441 :             else

  00096	eb 0c		 jmp	 SHORT $LN5@L_shr
$LN2@L_shr:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00098	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  0009c	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0009f	d3 f8		 sar	 eax, cl
  000a1	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax
$LN5@L_shr:

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1451 : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b0	3b ec		 cmp	 ebp, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_L_shr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shl
_TEXT	SEGMENT
$T1 = -209						; size = 1
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_var2$ = 12						; size = 2
_L_shl	PROC						; COMDAT

; 1341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0

; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)

  00025	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	7f 31		 jg	 SHORT $LN9@L_shl

; 1345 :     {
; 1346 :         if (var2 < -32)

  0002d	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00031	83 f8 e0	 cmp	 eax, -32		; ffffffe0H
  00034	7d 09		 jge	 SHORT $LN8@L_shl

; 1347 :             var2 = -32;

  00036	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  0003b	66 89 45 0c	 mov	 WORD PTR _var2$[ebp], ax
$LN8@L_shl:

; 1348 :         L_var_out = L_shr (L_var1, -var2);

  0003f	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00043	f7 d8		 neg	 eax
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _L_var1$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _L_shr
  0004f	83 c4 08	 add	 esp, 8
  00052	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00059	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  0005c	eb 75		 jmp	 SHORT $LN7@L_shl
$LN9@L_shl:

; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)

  0005e	eb 0c		 jmp	 SHORT $LN6@L_shl
$LN5@L_shl:
  00060	66 8b 45 0c	 mov	 ax, WORD PTR _var2$[ebp]
  00064	66 83 e8 01	 sub	 ax, 1
  00068	66 89 45 0c	 mov	 WORD PTR _var2$[ebp], ax
$LN6@L_shl:
  0006c	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00070	85 c0		 test	 eax, eax
  00072	7e 5f		 jle	 SHORT $LN7@L_shl

; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00074	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR _L_var1$[ebp], 1073741823 ; 3fffffffH
  0007b	7e 1c		 jle	 SHORT $LN3@L_shl

; 1358 :             {
; 1359 :                 Overflow = 1;

  0007d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1360 :                 L_var_out = MAX_32;

  00087	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  0008e	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _L_var_out$[ebp], 2147483647 ; 7fffffffH

; 1361 :                 break;

  00095	eb 3c		 jmp	 SHORT $LN7@L_shl

; 1362 :             }
; 1363 :             else

  00097	eb 23		 jmp	 SHORT $LN2@L_shl
$LN3@L_shl:

; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00099	81 7d 08 00 00
	00 c0		 cmp	 DWORD PTR _L_var1$[ebp], -1073741824 ; c0000000H
  000a0	7d 1a		 jge	 SHORT $LN2@L_shl

; 1366 :                 {
; 1367 :                     Overflow = 1;

  000a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1368 :                     L_var_out = MIN_32;

  000ac	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  000b3	c7 45 f8 00 00
	00 80		 mov	 DWORD PTR _L_var_out$[ebp], -2147483648 ; 80000000H

; 1369 :                     break;

  000ba	eb 17		 jmp	 SHORT $LN7@L_shl
$LN2@L_shl:

; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  000bf	d1 e0		 shl	 eax, 1
  000c1	89 45 08	 mov	 DWORD PTR _L_var1$[ebp], eax

; 1373 :             L_var_out = L_var1;

  000c4	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  000cb	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  000ce	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1374 :         }

  000d1	eb 8d		 jmp	 SHORT $LN5@L_shl
$LN7@L_shl:

; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);

  000d3	80 bd 2f ff ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  000da	75 0d		 jne	 SHORT $LN12@L_shl
  000dc	68 00 00 00 00	 push	 OFFSET $LN13@L_shl
  000e1	e8 00 00 00 00	 call	 __RTC_UninitUse
  000e6	83 c4 04	 add	 esp, 4
$LN12@L_shl:
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1380 : }

  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000f5	3b ec		 cmp	 ebp, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
$LN14@L_shl:
$LN13@L_shl:
  00100	4c		 DB	 76			; 0000004cH
  00101	5f		 DB	 95			; 0000005fH
  00102	76		 DB	 118			; 00000076H
  00103	61		 DB	 97			; 00000061H
  00104	72		 DB	 114			; 00000072H
  00105	5f		 DB	 95			; 0000005fH
  00106	6f		 DB	 111			; 0000006fH
  00107	75		 DB	 117			; 00000075H
  00108	74		 DB	 116			; 00000074H
  00109	00		 DB	 0
_L_shl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _mult_r
_TEXT	SEGMENT
_L_product_arr$ = -20					; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_mult_r	PROC						; COMDAT

; 1286 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00026	0f af c1	 imul	 eax, ecx
  00029	89 45 ec	 mov	 DWORD PTR _L_product_arr$[ebp], eax

; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */

  0002c	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  0002f	05 00 40 00 00	 add	 eax, 16384		; 00004000H
  00034	89 45 ec	 mov	 DWORD PTR _L_product_arr$[ebp], eax

; 1292 :     L_product_arr &= (Word32) 0xffff8000L;

  00037	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  0003a	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  0003f	89 45 ec	 mov	 DWORD PTR _L_product_arr$[ebp], eax

; 1293 :     L_product_arr >>= 15;       /* shift */

  00042	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  00045	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00048	89 45 ec	 mov	 DWORD PTR _L_product_arr$[ebp], eax

; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  0004e	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00053	74 0b		 je	 SHORT $LN1@mult_r

; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;

  00055	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  00058	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
  0005d	89 45 ec	 mov	 DWORD PTR _L_product_arr$[ebp], eax
$LN1@mult_r:

; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);

  00060	8b 45 ec	 mov	 eax, DWORD PTR _L_product_arr$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _saturate
  00069	83 c4 04	 add	 esp, 4
  0006c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);

  00070	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 1304 : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_mult_r	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_negate
_TEXT	SEGMENT
tv66 = -208						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_negate PROC						; COMDAT

; 1241 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;

  0001e	81 7d 08 00 00
	00 80		 cmp	 DWORD PTR _L_var1$[ebp], -2147483648 ; 80000000H
  00025	75 0c		 jne	 SHORT $LN3@L_negate
  00027	c7 85 30 ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv66[ebp], 2147483647 ; 7fffffffH
  00031	eb 0b		 jmp	 SHORT $LN4@L_negate
$LN3@L_negate:
  00033	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00036	f7 d8		 neg	 eax
  00038	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
$LN4@L_negate:
  0003e	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00044	89 4d f8	 mov	 DWORD PTR _L_var_out$[ebp], ecx

; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1249 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_L_negate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_sub_c
_TEXT	SEGMENT
_carry_int$ = -32					; size = 4
_L_test$ = -20						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_var2$ = 12						; size = 4
_L_sub_c PROC						; COMDAT

; 1150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;

  0001e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 0

; 1154 : 
; 1155 :     if (Carry)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Carry, 0
  0002c	74 52		 je	 SHORT $LN12@L_sub_c

; 1156 :     {
; 1157 :         Carry = 0;

  0002e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Carry, 0

; 1158 :         if (L_var2 != MIN_32)

  00038	81 7d 0c 00 00
	00 80		 cmp	 DWORD PTR _L_var2$[ebp], -2147483648 ; 80000000H
  0003f	74 17		 je	 SHORT $LN11@L_sub_c

; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);

  00041	8b 45 0c	 mov	 eax, DWORD PTR _L_var2$[ebp]
  00044	f7 d8		 neg	 eax
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _L_var1$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _L_add_c
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else

  00056	eb 23		 jmp	 SHORT $LN10@L_sub_c
$LN11@L_sub_c:

; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;

  00058	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0005b	2b 45 0c	 sub	 eax, DWORD PTR _L_var2$[ebp]
  0005e	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1168 :             if (L_var1 > 0L)

  00061	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00065	7e 14		 jle	 SHORT $LN10@L_sub_c

; 1169 :             {
; 1170 :                 Overflow = 1;

  00067	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1171 :                 Carry = 0;

  00071	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Carry, 0
$LN10@L_sub_c:

; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else

  0007b	e9 9f 00 00 00	 jmp	 $LN8@L_sub_c
$LN12@L_sub_c:

; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;

  00080	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00083	2b 45 0c	 sub	 eax, DWORD PTR _L_var2$[ebp]
  00086	83 e8 01	 sub	 eax, 1
  00089	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1178 :         L_test = L_var1 - L_var2;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0008f	2b 45 0c	 sub	 eax, DWORD PTR _L_var2$[ebp]
  00092	89 45 ec	 mov	 DWORD PTR _L_test$[ebp], eax

; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))

  00095	79 1f		 jns	 SHORT $LN7@L_sub_c
  00097	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  0009b	7e 19		 jle	 SHORT $LN7@L_sub_c
  0009d	83 7d 0c 00	 cmp	 DWORD PTR _L_var2$[ebp], 0
  000a1	7d 13		 jge	 SHORT $LN7@L_sub_c

; 1181 :         {
; 1182 :             Overflow = 1;

  000a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1183 :             carry_int = 0;

  000ad	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 0
  000b4	eb 44		 jmp	 SHORT $LN6@L_sub_c
$LN7@L_sub_c:

; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))

  000b6	83 7d ec 00	 cmp	 DWORD PTR _L_test$[ebp], 0
  000ba	7e 1f		 jle	 SHORT $LN5@L_sub_c
  000bc	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  000c0	7d 19		 jge	 SHORT $LN5@L_sub_c
  000c2	83 7d 0c 00	 cmp	 DWORD PTR _L_var2$[ebp], 0
  000c6	7e 13		 jle	 SHORT $LN5@L_sub_c

; 1186 :         {
; 1187 :             Overflow = 1;

  000c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1188 :             carry_int = 1;

  000d2	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 1
  000d9	eb 1f		 jmp	 SHORT $LN6@L_sub_c
$LN5@L_sub_c:

; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))

  000db	83 7d ec 00	 cmp	 DWORD PTR _L_test$[ebp], 0
  000df	7e 19		 jle	 SHORT $LN6@L_sub_c
  000e1	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  000e4	33 45 0c	 xor	 eax, DWORD PTR _L_var2$[ebp]
  000e7	7e 11		 jle	 SHORT $LN6@L_sub_c

; 1191 :         {
; 1192 :             Overflow = 0;

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0

; 1193 :             carry_int = 1;

  000f3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 1
$LN6@L_sub_c:

; 1194 :         }
; 1195 :         if (L_test == MIN_32)

  000fa	81 7d ec 00 00
	00 80		 cmp	 DWORD PTR _L_test$[ebp], -2147483648 ; 80000000H
  00101	75 14		 jne	 SHORT $LN2@L_sub_c

; 1196 :         {
; 1197 :             Overflow = 1;

  00103	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1198 :             Carry = carry_int;

  0010d	8b 45 e0	 mov	 eax, DWORD PTR _carry_int$[ebp]
  00110	a3 00 00 00 00	 mov	 DWORD PTR _Carry, eax

; 1199 :         }
; 1200 :         else

  00115	eb 08		 jmp	 SHORT $LN8@L_sub_c
$LN2@L_sub_c:

; 1201 :         {
; 1202 :             Carry = carry_int;

  00117	8b 45 e0	 mov	 eax, DWORD PTR _carry_int$[ebp]
  0011a	a3 00 00 00 00	 mov	 DWORD PTR _Carry, eax
$LN8@L_sub_c:

; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);

  0011f	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1210 : }

  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0012b	3b ec		 cmp	 ebp, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
_L_sub_c ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_add_c
_TEXT	SEGMENT
_carry_int$ = -32					; size = 4
_L_test$ = -20						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_var2$ = 12						; size = 4
_L_add_c PROC						; COMDAT

; 1037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;

  0001e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 0

; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;

  00025	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00028	03 45 0c	 add	 eax, DWORD PTR _L_var2$[ebp]
  0002b	03 05 00 00 00
	00		 add	 eax, DWORD PTR _Carry
  00031	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;

  00034	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00037	03 45 0c	 add	 eax, DWORD PTR _L_var2$[ebp]
  0003a	89 45 ec	 mov	 DWORD PTR _L_test$[ebp], eax

; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))

  0003d	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00041	7e 1f		 jle	 SHORT $LN14@L_add_c
  00043	83 7d 0c 00	 cmp	 DWORD PTR _L_var2$[ebp], 0
  00047	7e 19		 jle	 SHORT $LN14@L_add_c
  00049	83 7d ec 00	 cmp	 DWORD PTR _L_test$[ebp], 0
  0004d	7d 13		 jge	 SHORT $LN14@L_add_c

; 1047 :     {
; 1048 :         Overflow = 1;

  0004f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1049 :         carry_int = 0;

  00059	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 0

; 1050 :     }
; 1051 :     else

  00060	eb 6a		 jmp	 SHORT $LN13@L_add_c
$LN14@L_add_c:

; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))

  00062	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00066	7d 32		 jge	 SHORT $LN12@L_add_c
  00068	83 7d 0c 00	 cmp	 DWORD PTR _L_var2$[ebp], 0
  0006c	7d 2c		 jge	 SHORT $LN12@L_add_c

; 1054 :         {
; 1055 :             if (L_test >= 0)

  0006e	83 7d ec 00	 cmp	 DWORD PTR _L_test$[ebp], 0
  00072	7c 13		 jl	 SHORT $LN11@L_add_c

; 1056 : 	    {
; 1057 :                 Overflow = 1;

  00074	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1058 :                 carry_int = 1;

  0007e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 1

; 1059 : 	    }
; 1060 :             else

  00085	eb 11		 jmp	 SHORT $LN10@L_add_c
$LN11@L_add_c:

; 1061 : 	    {
; 1062 :                 Overflow = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0

; 1063 :                 carry_int = 1;

  00091	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 1
$LN10@L_add_c:

; 1064 : 	    }
; 1065 :         }
; 1066 :         else

  00098	eb 32		 jmp	 SHORT $LN13@L_add_c
$LN12@L_add_c:

; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))

  0009a	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0009d	33 45 0c	 xor	 eax, DWORD PTR _L_var2$[ebp]
  000a0	7d 19		 jge	 SHORT $LN8@L_add_c
  000a2	83 7d ec 00	 cmp	 DWORD PTR _L_test$[ebp], 0
  000a6	7c 13		 jl	 SHORT $LN8@L_add_c

; 1069 :             {
; 1070 :                 Overflow = 0;

  000a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0

; 1071 :                 carry_int = 1;

  000b2	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 1

; 1072 :             }
; 1073 :             else

  000b9	eb 11		 jmp	 SHORT $LN13@L_add_c
$LN8@L_add_c:

; 1074 :             {
; 1075 :                 Overflow = 0;

  000bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0

; 1076 :                 carry_int = 0;

  000c5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _carry_int$[ebp], 0
$LN13@L_add_c:

; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)

  000cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Carry, 0
  000d3	74 39		 je	 SHORT $LN6@L_add_c

; 1082 :     {
; 1083 :         if (L_test == MAX_32)

  000d5	81 7d ec ff ff
	ff 7f		 cmp	 DWORD PTR _L_test$[ebp], 2147483647 ; 7fffffffH
  000dc	75 14		 jne	 SHORT $LN5@L_add_c

; 1084 :         {
; 1085 :             Overflow = 1;

  000de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1086 :             Carry = carry_int;

  000e8	8b 45 e0	 mov	 eax, DWORD PTR _carry_int$[ebp]
  000eb	a3 00 00 00 00	 mov	 DWORD PTR _Carry, eax

; 1087 :         }
; 1088 :         else

  000f0	eb 1a		 jmp	 SHORT $LN4@L_add_c
$LN5@L_add_c:

; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)

  000f2	83 7d ec ff	 cmp	 DWORD PTR _L_test$[ebp], -1
  000f6	75 0c		 jne	 SHORT $LN3@L_add_c

; 1091 :             {
; 1092 :                 Carry = 1;

  000f8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Carry, 1

; 1093 :             }
; 1094 :             else

  00102	eb 08		 jmp	 SHORT $LN4@L_add_c
$LN3@L_add_c:

; 1095 :             {
; 1096 :                 Carry = carry_int;

  00104	8b 45 e0	 mov	 eax, DWORD PTR _carry_int$[ebp]
  00107	a3 00 00 00 00	 mov	 DWORD PTR _Carry, eax
$LN4@L_add_c:

; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else

  0010c	eb 08		 jmp	 SHORT $LN1@L_add_c
$LN6@L_add_c:

; 1101 :     {
; 1102 :         Carry = carry_int;

  0010e	8b 45 e0	 mov	 eax, DWORD PTR _carry_int$[ebp]
  00111	a3 00 00 00 00	 mov	 DWORD PTR _Carry, eax
$LN1@L_add_c:

; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);

  00116	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 1109 : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
_L_add_c ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_sub
_TEXT	SEGMENT
tv72 = -208						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_var2$ = 12						; size = 4
_L_sub	PROC						; COMDAT

; 980  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00021	2b 45 0c	 sub	 eax, DWORD PTR _L_var2$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0002a	33 45 0c	 xor	 eax, DWORD PTR _L_var2$[ebp]
  0002d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00032	74 3c		 je	 SHORT $LN2@L_sub

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00034	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00037	33 45 08	 xor	 eax, DWORD PTR _L_var1$[ebp]
  0003a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0003f	74 2f		 je	 SHORT $LN2@L_sub

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00041	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00045	7d 0c		 jge	 SHORT $LN5@L_sub
  00047	c7 85 30 ff ff
	ff 00 00 00 80	 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00051	eb 0a		 jmp	 SHORT $LN6@L_sub
$LN5@L_sub:
  00053	c7 85 30 ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN6@L_sub:
  0005d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00063	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 990  :             Overflow = 1;

  00066	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2@L_sub:

; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);

  00070	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 997  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_L_sub	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_add
_TEXT	SEGMENT
tv72 = -208						; size = 4
_L_var_out$ = -8					; size = 4
_L_var1$ = 8						; size = 4
_L_var2$ = 12						; size = 4
_L_add	PROC						; COMDAT

; 928  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00021	03 45 0c	 add	 eax, DWORD PTR _L_var2$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00027	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  0002a	33 45 0c	 xor	 eax, DWORD PTR _L_var2$[ebp]
  0002d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00032	75 3c		 jne	 SHORT $LN2@L_add

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00034	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00037	33 45 08	 xor	 eax, DWORD PTR _L_var1$[ebp]
  0003a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0003f	74 2f		 je	 SHORT $LN2@L_add

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00041	83 7d 08 00	 cmp	 DWORD PTR _L_var1$[ebp], 0
  00045	7d 0c		 jge	 SHORT $LN5@L_add
  00047	c7 85 30 ff ff
	ff 00 00 00 80	 mov	 DWORD PTR tv72[ebp], -2147483648 ; 80000000H
  00051	eb 0a		 jmp	 SHORT $LN6@L_add
$LN5@L_add:
  00053	c7 85 30 ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv72[ebp], 2147483647 ; 7fffffffH
$LN6@L_add:
  0005d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00063	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 938  :             Overflow = 1;

  00066	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2@L_add:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);

  00070	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 945  : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_L_add	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_msuNs
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_L_msuNs PROC						; COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _L_mult
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _L_var3$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _L_sub_c
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 893  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_L_msuNs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_macNs
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_L_macNs PROC						; COMDAT

; 821  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _L_mult
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _L_var3$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _L_add_c
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 834  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_L_macNs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_msu
_TEXT	SEGMENT
_L_product$ = -20					; size = 4
_L_var_out$ = -8					; size = 4
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_L_msu	PROC						; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _L_mult
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 ec	 mov	 DWORD PTR _L_product$[ebp], eax

; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);

  00033	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _L_var3$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _L_sub
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 775  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_L_msu	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_mac
_TEXT	SEGMENT
_L_product$ = -20					; size = 4
_L_var_out$ = -8					; size = 4
_L_var3$ = 8						; size = 4
_var1$ = 12						; size = 2
_var2$ = 16						; size = 2
_L_mac	PROC						; COMDAT

; 707  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _var2$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _var1$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _L_mult
  0002d	83 c4 08	 add	 esp, 8
  00030	89 45 ec	 mov	 DWORD PTR _L_product$[ebp], eax

; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);

  00033	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _L_var3$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _L_add
  00040	83 c4 08	 add	 esp, 8
  00043	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 721  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_L_mac	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _round
_TEXT	SEGMENT
_L_rounded$ = -20					; size = 4
_var_out$ = -8						; size = 2
_L_var1$ = 8						; size = 4
_round	PROC						; COMDAT

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);

  0001e	68 00 80 00 00	 push	 32768			; 00008000H
  00023	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _L_add
  0002c	83 c4 08	 add	 esp, 8
  0002f	89 45 ec	 mov	 DWORD PTR _L_rounded$[ebp], eax

; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);

  00032	8b 45 ec	 mov	 eax, DWORD PTR _L_rounded$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _extract_h
  0003b	83 c4 04	 add	 esp, 4
  0003e	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);

  00042	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 667  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_round	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _extract_l
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var1$ = 8						; size = 4
_extract_l PROC						; COMDAT

; 611  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;

  0001e	66 8b 45 08	 mov	 ax, WORD PTR _L_var1$[ebp]
  00022	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);

  00026	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 619  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_extract_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _extract_h
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_L_var1$ = 8						; size = 4
_extract_h PROC						; COMDAT

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _L_var1$[ebp]
  00021	c1 f8 10	 sar	 eax, 16			; 00000010H
  00024	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);

  00028	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 580  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_extract_h ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _negate
_TEXT	SEGMENT
tv68 = -208						; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_negate	PROC						; COMDAT

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00027	75 0c		 jne	 SHORT $LN3@negate
  00029	c7 85 30 ff ff
	ff ff 7f 00 00	 mov	 DWORD PTR tv68[ebp], 32767 ; 00007fffH
  00033	eb 0c		 jmp	 SHORT $LN4@negate
$LN3@negate:
  00035	0f bf 4d 08	 movsx	 ecx, WORD PTR _var1$[ebp]
  00039	f7 d9		 neg	 ecx
  0003b	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
$LN4@negate:
  00041	66 8b 95 30 ff
	ff ff		 mov	 dx, WORD PTR tv68[ebp]
  00048	66 89 55 f8	 mov	 WORD PTR _var_out$[ebp], dx

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);

  0004c	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 541  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_negate	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_mult
_TEXT	SEGMENT
_L_var_out$ = -8					; size = 4
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_L_mult	PROC						; COMDAT

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00026	0f af c1	 imul	 eax, ecx
  00029	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0002c	81 7d f8 00 00
	00 40		 cmp	 DWORD PTR _L_var_out$[ebp], 1073741824 ; 40000000H
  00033	74 0a		 je	 SHORT $LN2@L_mult

; 488  :     {
; 489  :         L_var_out *= 2;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]
  00038	d1 e0		 shl	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _L_var_out$[ebp], eax

; 490  :     }
; 491  :     else

  0003d	eb 11		 jmp	 SHORT $LN1@L_mult
$LN2@L_mult:

; 492  :     {
; 493  :         Overflow = 1;

  0003f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00049	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _L_var_out$[ebp], 2147483647 ; 7fffffffH
$LN1@L_mult:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);

  00050	8b 45 f8	 mov	 eax, DWORD PTR _L_var_out$[ebp]

; 501  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_L_mult	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _mult
_TEXT	SEGMENT
_L_product$ = -20					; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_mult	PROC						; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00026	0f af c1	 imul	 eax, ecx
  00029	89 45 ec	 mov	 DWORD PTR _L_product$[ebp], eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0002c	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  0002f	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  00034	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00037	89 45 ec	 mov	 DWORD PTR _L_product$[ebp], eax

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  0003d	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00042	74 0b		 je	 SHORT $LN1@mult

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00044	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  00047	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
  0004c	89 45 ec	 mov	 DWORD PTR _L_product$[ebp], eax
$LN1@mult:

; 438  : 
; 439  :     var_out = saturate (L_product);

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _L_product$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _saturate
  00058	83 c4 04	 add	 esp, 4
  0005b	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);

  0005f	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 444  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_mult	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shr
_TEXT	SEGMENT
tv78 = -208						; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_shr	PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7d 2c		 jge	 SHORT $LN7@shr

; 359  :     {
; 360  :         if (var2 < -16)

  00026	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0002a	83 f8 f0	 cmp	 eax, -16		; fffffff0H
  0002d	7d 09		 jge	 SHORT $LN6@shr

; 361  :             var2 = -16;

  0002f	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00034	66 89 45 0c	 mov	 WORD PTR _var2$[ebp], ax
$LN6@shr:

; 362  :         var_out = shl (var1, -var2);

  00038	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0003c	f7 d8		 neg	 eax
  0003e	50		 push	 eax
  0003f	0f b7 4d 08	 movzx	 ecx, WORD PTR _var1$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _shl
  00049	83 c4 08	 add	 esp, 8
  0004c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else

  00050	eb 5e		 jmp	 SHORT $LN5@shr
$LN7@shr:

; 368  :     {
; 369  :         if (var2 >= 15)

  00052	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00056	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00059	7c 2b		 jl	 SHORT $LN4@shr

; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;

  0005b	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	7d 0c		 jge	 SHORT $LN10@shr
  00063	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv78[ebp], -1
  0006d	eb 0a		 jmp	 SHORT $LN11@shr
$LN10@shr:
  0006f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN11@shr:
  00079	66 8b 8d 30 ff
	ff ff		 mov	 cx, WORD PTR tv78[ebp]
  00080	66 89 4d f8	 mov	 WORD PTR _var_out$[ebp], cx

; 372  :         }
; 373  :         else

  00084	eb 2a		 jmp	 SHORT $LN5@shr
$LN4@shr:

; 374  :         {
; 375  :             if (var1 < 0)

  00086	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  0008a	85 c0		 test	 eax, eax
  0008c	7d 14		 jge	 SHORT $LN2@shr

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0008e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00092	f7 d0		 not	 eax
  00094	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00098	d3 f8		 sar	 eax, cl
  0009a	f7 d0		 not	 eax
  0009c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 378  :             }
; 379  :             else

  000a0	eb 0e		 jmp	 SHORT $LN5@shr
$LN2@shr:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000a2	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  000a6	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  000aa	d3 f8		 sar	 eax, cl
  000ac	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN5@shr:

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);

  000b0	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 390  : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
_shr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shl
_TEXT	SEGMENT
tv86 = -220						; size = 4
_result$ = -20						; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_shl	PROC						; COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7d 2c		 jge	 SHORT $LN7@shl

; 288  :     {
; 289  :         if (var2 < -16)

  00026	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0002a	83 f8 f0	 cmp	 eax, -16		; fffffff0H
  0002d	7d 09		 jge	 SHORT $LN6@shl

; 290  :             var2 = -16;

  0002f	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00034	66 89 45 0c	 mov	 WORD PTR _var2$[ebp], ax
$LN6@shl:

; 291  :         var_out = shr (var1, -var2);

  00038	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0003c	f7 d8		 neg	 eax
  0003e	50		 push	 eax
  0003f	0f b7 4d 08	 movzx	 ecx, WORD PTR _var1$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _shr
  00049	83 c4 08	 add	 esp, 8
  0004c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  00050	eb 74		 jmp	 SHORT $LN5@shl
$LN7@shl:

; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00052	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00056	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	d3 e2		 shl	 edx, cl
  00061	0f af c2	 imul	 eax, edx
  00064	89 45 ec	 mov	 DWORD PTR _result$[ebp], eax

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00067	0f bf 45 0c	 movsx	 eax, WORD PTR _var2$[ebp]
  0006b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0006e	7e 08		 jle	 SHORT $LN2@shl
  00070	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00074	85 c0		 test	 eax, eax
  00076	75 09		 jne	 SHORT $LN3@shl
$LN2@shl:
  00078	0f bf 45 ec	 movsx	 eax, WORD PTR _result$[ebp]
  0007c	39 45 ec	 cmp	 DWORD PTR _result$[ebp], eax
  0007f	74 35		 je	 SHORT $LN4@shl
$LN3@shl:

; 301  :         {
; 302  :             Overflow = 1;

  00081	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0008b	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  0008f	85 c0		 test	 eax, eax
  00091	7e 0c		 jle	 SHORT $LN10@shl
  00093	c7 85 24 ff ff
	ff ff 7f 00 00	 mov	 DWORD PTR tv86[ebp], 32767 ; 00007fffH
  0009d	eb 0a		 jmp	 SHORT $LN11@shl
$LN10@shl:
  0009f	c7 85 24 ff ff
	ff 00 80 ff ff	 mov	 DWORD PTR tv86[ebp], -32768 ; ffff8000H
$LN11@shl:
  000a9	66 8b 8d 24 ff
	ff ff		 mov	 cx, WORD PTR tv86[ebp]
  000b0	66 89 4d f8	 mov	 WORD PTR _var_out$[ebp], cx

; 304  :         }
; 305  :         else

  000b4	eb 10		 jmp	 SHORT $LN5@shl
$LN4@shl:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _extract_l
  000bf	83 c4 04	 add	 esp, 4
  000c2	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN5@shl:

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);

  000c6	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 317  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_shl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _abs_s
_TEXT	SEGMENT
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_abs_s	PROC						; COMDAT

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00027	75 0b		 jne	 SHORT $LN4@abs_s

; 227  :     {
; 228  :         var_out = MAX_16;

  00029	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0002e	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 229  :     }
; 230  :     else

  00032	eb 1c		 jmp	 SHORT $LN3@abs_s
$LN4@abs_s:

; 231  :     {
; 232  :         if (var1 < 0)

  00034	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00038	85 c0		 test	 eax, eax
  0003a	7d 0c		 jge	 SHORT $LN2@abs_s

; 233  :         {
; 234  :             var_out = -var1;

  0003c	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00040	f7 d8		 neg	 eax
  00042	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 235  :         }
; 236  :         else

  00046	eb 08		 jmp	 SHORT $LN3@abs_s
$LN2@abs_s:

; 237  :         {
; 238  :             var_out = var1;

  00048	66 8b 45 08	 mov	 ax, WORD PTR _var1$[ebp]
  0004c	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax
$LN3@abs_s:

; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);

  00050	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 245  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_abs_s	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _sub
_TEXT	SEGMENT
_L_diff$ = -20						; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_sub	PROC						; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00026	2b c1		 sub	 eax, ecx
  00028	89 45 ec	 mov	 DWORD PTR _L_diff$[ebp], eax

; 187  :     var_out = saturate (L_diff);

  0002b	8b 45 ec	 mov	 eax, DWORD PTR _L_diff$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _saturate
  00034	83 c4 04	 add	 esp, 4
  00037	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);

  0003b	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 192  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_sub	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _add
_TEXT	SEGMENT
_L_sum$ = -20						; size = 4
_var_out$ = -8						; size = 2
_var1$ = 8						; size = 2
_var2$ = 12						; size = 2
_add	PROC						; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _var1$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _var2$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	89 45 ec	 mov	 DWORD PTR _L_sum$[ebp], eax

; 140  :     var_out = saturate (L_sum);

  0002b	8b 45 ec	 mov	 eax, DWORD PTR _L_sum$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _saturate
  00034	83 c4 04	 add	 esp, 4
  00037	66 89 45 f8	 mov	 WORD PTR _var_out$[ebp], ax

; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);

  0003b	66 8b 45 f8	 mov	 ax, WORD PTR _var_out$[ebp]

; 145  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_add	ENDP
_TEXT	ENDS
END
