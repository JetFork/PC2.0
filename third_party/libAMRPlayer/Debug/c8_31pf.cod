; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c8_31pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c8_31pf_id
CONST	SEGMENT
_c8_31pf_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_code_8i40_31bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	_cor_h_x2:PROC
EXTRN	_cor_h:PROC
EXTRN	_set_sign12k2:PROC
EXTRN	_search_10and8i40:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c8_31pf.c
;	COMDAT _compress_code
_TEXT	SEGMENT
_ic$ = -44						; size = 2
_ib$ = -32						; size = 2
_ia$ = -20						; size = 2
_i$ = -8						; size = 2
_sign_indx$ = 8						; size = 4
_pos_indx$ = 12						; size = 4
_indx$ = 16						; size = 4
_compress_code PROC					; COMDAT

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 240  :    Word16 i, ia, ib, ic;
; 241  : 
; 242  :    for (i = 0; i < NB_TRACK_MR102; i++)

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00024	eb 0c		 jmp	 SHORT $LN5@compress_c
$LN4@compress_c:
  00026	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002a	66 83 c0 01	 add	 ax, 1
  0002e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN5@compress_c:
  00032	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00036	83 f8 04	 cmp	 eax, 4
  00039	7d 1d		 jge	 SHORT $LN3@compress_c

; 243  :    {
; 244  :       indx[i] = sign_indx[i];                            move16 (); 

  0003b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0003f	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00043	8b 55 10	 mov	 edx, DWORD PTR _indx$[ebp]
  00046	8b 75 08	 mov	 esi, DWORD PTR _sign_indx$[ebp]
  00049	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  0004d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00051	e8 00 00 00 00	 call	 _move16

; 245  :    }

  00056	eb ce		 jmp	 SHORT $LN4@compress_c
$LN3@compress_c:

; 246  :     
; 247  :     /* First index 
; 248  :       indx[NB_TRACK] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4; */
; 249  :    move16 (); 

  00058	e8 00 00 00 00	 call	 _move16

; 250  :    indx[NB_TRACK_MR102] = compress10(pos_indx[0],pos_indx[4],pos_indx[1]);

  0005d	b8 02 00 00 00	 mov	 eax, 2
  00062	c1 e0 00	 shl	 eax, 0
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00068	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0006c	52		 push	 edx
  0006d	b8 02 00 00 00	 mov	 eax, 2
  00072	c1 e0 02	 shl	 eax, 2
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00078	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0007c	52		 push	 edx
  0007d	b8 02 00 00 00	 mov	 eax, 2
  00082	6b c8 00	 imul	 ecx, eax, 0
  00085	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00088	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _compress10
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	b9 02 00 00 00	 mov	 ecx, 2
  0009a	c1 e1 02	 shl	 ecx, 2
  0009d	8b 55 10	 mov	 edx, DWORD PTR _indx$[ebp]
  000a0	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 251  : 
; 252  :     /* Second index       
; 253  :       indx[NB_TRACK+1] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4; */
; 254  :     
; 255  :    move16 (); 

  000a4	e8 00 00 00 00	 call	 _move16

; 256  :    indx[NB_TRACK_MR102+1]= compress10(pos_indx[2],pos_indx[6],pos_indx[5]);

  000a9	b8 02 00 00 00	 mov	 eax, 2
  000ae	6b c8 05	 imul	 ecx, eax, 5
  000b1	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  000b4	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  000b8	50		 push	 eax
  000b9	b9 02 00 00 00	 mov	 ecx, 2
  000be	6b d1 06	 imul	 edx, ecx, 6
  000c1	8b 45 0c	 mov	 eax, DWORD PTR _pos_indx$[ebp]
  000c4	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  000c8	51		 push	 ecx
  000c9	ba 02 00 00 00	 mov	 edx, 2
  000ce	d1 e2		 shl	 edx, 1
  000d0	8b 45 0c	 mov	 eax, DWORD PTR _pos_indx$[ebp]
  000d3	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _compress10
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	ba 02 00 00 00	 mov	 edx, 2
  000e5	6b ca 05	 imul	 ecx, edx, 5
  000e8	8b 55 10	 mov	 edx, DWORD PTR _indx$[ebp]
  000eb	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 257  :     
; 258  :     /*
; 259  :       Third index      
; 260  :       if ((ib/2)%2 == 1)
; 261  :         indx[NB_TRACK+2] = ((((4-ia/2) + (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
; 262  :       else   
; 263  :         indx[NB_TRACK+2] = ((((ia/2) +   (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
; 264  :         */
; 265  :     
; 266  :     ib = shr(pos_indx[7], 1) & 1;                        logic16 ();

  000ef	6a 01		 push	 1
  000f1	b8 02 00 00 00	 mov	 eax, 2
  000f6	6b c8 07	 imul	 ecx, eax, 7
  000f9	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  000fc	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _shr
  00106	83 c4 08	 add	 esp, 8
  00109	0f bf c8	 movsx	 ecx, ax
  0010c	83 e1 01	 and	 ecx, 1
  0010f	66 89 4d e0	 mov	 WORD PTR _ib$[ebp], cx
  00113	e8 00 00 00 00	 call	 _logic16

; 267  :     test ();

  00118	e8 00 00 00 00	 call	 _test

; 268  :     if (sub(ib, 1) == 0)

  0011d	6a 01		 push	 1
  0011f	0f b7 45 e0	 movzx	 eax, WORD PTR _ib$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _sub
  00129	83 c4 08	 add	 esp, 8
  0012c	0f bf c8	 movsx	 ecx, ax
  0012f	85 c9		 test	 ecx, ecx
  00131	75 2e		 jne	 SHORT $LN2@compress_c

; 269  :        ia = sub(4, shr(pos_indx[3], 1));

  00133	6a 01		 push	 1
  00135	b8 02 00 00 00	 mov	 eax, 2
  0013a	6b c8 03	 imul	 ecx, eax, 3
  0013d	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00140	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _shr
  0014a	83 c4 08	 add	 esp, 8
  0014d	0f b7 c8	 movzx	 ecx, ax
  00150	51		 push	 ecx
  00151	6a 04		 push	 4
  00153	e8 00 00 00 00	 call	 _sub
  00158	83 c4 08	 add	 esp, 8
  0015b	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax

; 270  :     else

  0015f	eb 1e		 jmp	 SHORT $LN1@compress_c
$LN2@compress_c:

; 271  :        ia = shr(pos_indx[3], 1);

  00161	6a 01		 push	 1
  00163	b8 02 00 00 00	 mov	 eax, 2
  00168	6b c8 03	 imul	 ecx, eax, 3
  0016b	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  0016e	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _shr
  00178	83 c4 08	 add	 esp, 8
  0017b	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax
$LN1@compress_c:

; 272  : 
; 273  :     ib = extract_l(L_shr(L_mult(shr(pos_indx[7], 1), 5), 1));       

  0017f	6a 01		 push	 1
  00181	6a 05		 push	 5
  00183	6a 01		 push	 1
  00185	b8 02 00 00 00	 mov	 eax, 2
  0018a	6b c8 07	 imul	 ecx, eax, 7
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00190	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _shr
  0019a	83 c4 08	 add	 esp, 8
  0019d	0f b7 c8	 movzx	 ecx, ax
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 _L_mult
  001a6	83 c4 08	 add	 esp, 8
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _L_shr
  001af	83 c4 08	 add	 esp, 8
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 _extract_l
  001b8	83 c4 04	 add	 esp, 4
  001bb	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax

; 274  :     ib = add(shl(add(ia, ib), 5), 12);

  001bf	6a 0c		 push	 12			; 0000000cH
  001c1	6a 05		 push	 5
  001c3	0f b7 45 e0	 movzx	 eax, WORD PTR _ib$[ebp]
  001c7	50		 push	 eax
  001c8	0f b7 4d ec	 movzx	 ecx, WORD PTR _ia$[ebp]
  001cc	51		 push	 ecx
  001cd	e8 00 00 00 00	 call	 _add
  001d2	83 c4 08	 add	 esp, 8
  001d5	0f b7 d0	 movzx	 edx, ax
  001d8	52		 push	 edx
  001d9	e8 00 00 00 00	 call	 _shl
  001de	83 c4 08	 add	 esp, 8
  001e1	0f b7 c0	 movzx	 eax, ax
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 _add
  001ea	83 c4 08	 add	 esp, 8
  001ed	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax

; 275  :     ic = shl(mult(ib, 1311), 2);

  001f1	6a 02		 push	 2
  001f3	68 1f 05 00 00	 push	 1311			; 0000051fH
  001f8	0f b7 45 e0	 movzx	 eax, WORD PTR _ib$[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 _mult
  00202	83 c4 08	 add	 esp, 8
  00205	0f b7 c8	 movzx	 ecx, ax
  00208	51		 push	 ecx
  00209	e8 00 00 00 00	 call	 _shl
  0020e	83 c4 08	 add	 esp, 8
  00211	66 89 45 d4	 mov	 WORD PTR _ic$[ebp], ax

; 276  :     ia = pos_indx[3] & 1;                             logic16 ();

  00215	b8 02 00 00 00	 mov	 eax, 2
  0021a	6b c8 03	 imul	 ecx, eax, 3
  0021d	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00220	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00224	83 e0 01	 and	 eax, 1
  00227	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax
  0022b	e8 00 00 00 00	 call	 _logic16

; 277  :     ib = shl((pos_indx[7] & 1), 1);                   logic16 ();

  00230	6a 01		 push	 1
  00232	b8 02 00 00 00	 mov	 eax, 2
  00237	6b c8 07	 imul	 ecx, eax, 7
  0023a	8b 55 0c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  0023d	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00241	83 e0 01	 and	 eax, 1
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _shl
  0024a	83 c4 08	 add	 esp, 8
  0024d	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax
  00251	e8 00 00 00 00	 call	 _logic16

; 278  :     indx[NB_TRACK_MR102+2] = add(ia, add(ib, ic));

  00256	0f b7 45 d4	 movzx	 eax, WORD PTR _ic$[ebp]
  0025a	50		 push	 eax
  0025b	0f b7 4d e0	 movzx	 ecx, WORD PTR _ib$[ebp]
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 _add
  00265	83 c4 08	 add	 esp, 8
  00268	0f b7 d0	 movzx	 edx, ax
  0026b	52		 push	 edx
  0026c	0f b7 45 ec	 movzx	 eax, WORD PTR _ia$[ebp]
  00270	50		 push	 eax
  00271	e8 00 00 00 00	 call	 _add
  00276	83 c4 08	 add	 esp, 8
  00279	b9 02 00 00 00	 mov	 ecx, 2
  0027e	6b d1 06	 imul	 edx, ecx, 6
  00281	8b 4d 10	 mov	 ecx, DWORD PTR _indx$[ebp]
  00284	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 279  : }

  00288	5f		 pop	 edi
  00289	5e		 pop	 esi
  0028a	5b		 pop	 ebx
  0028b	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00291	3b ec		 cmp	 ebp, esp
  00293	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00298	8b e5		 mov	 esp, ebp
  0029a	5d		 pop	 ebp
  0029b	c3		 ret	 0
_compress_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c8_31pf.c
;	COMDAT _compress10
_TEXT	SEGMENT
_ic$ = -44						; size = 2
_ib$ = -32						; size = 2
_ia$ = -20						; size = 2
_indx$ = -8						; size = 2
_pos_indxA$ = 8						; size = 2
_pos_indxB$ = 12					; size = 2
_pos_indxC$ = 16					; size = 2
_compress10 PROC					; COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 205  :    Word16 indx, ia,ib,ic;
; 206  : 
; 207  :    ia = shr(pos_indxA, 1);

  0001e	6a 01		 push	 1
  00020	0f b7 45 08	 movzx	 eax, WORD PTR _pos_indxA$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _shr
  0002a	83 c4 08	 add	 esp, 8
  0002d	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax

; 208  :    ib = extract_l(L_shr(L_mult(shr(pos_indxB, 1), 5), 1));

  00031	6a 01		 push	 1
  00033	6a 05		 push	 5
  00035	6a 01		 push	 1
  00037	0f b7 45 0c	 movzx	 eax, WORD PTR _pos_indxB$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _shr
  00041	83 c4 08	 add	 esp, 8
  00044	0f b7 c8	 movzx	 ecx, ax
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _L_mult
  0004d	83 c4 08	 add	 esp, 8
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _L_shr
  00056	83 c4 08	 add	 esp, 8
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _extract_l
  0005f	83 c4 04	 add	 esp, 4
  00062	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax

; 209  :    ic = extract_l(L_shr(L_mult(shr(pos_indxC, 1), 25), 1));            

  00066	6a 01		 push	 1
  00068	6a 19		 push	 25			; 00000019H
  0006a	6a 01		 push	 1
  0006c	0f b7 45 10	 movzx	 eax, WORD PTR _pos_indxC$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _shr
  00076	83 c4 08	 add	 esp, 8
  00079	0f b7 c8	 movzx	 ecx, ax
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _L_mult
  00082	83 c4 08	 add	 esp, 8
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _L_shr
  0008b	83 c4 08	 add	 esp, 8
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _extract_l
  00094	83 c4 04	 add	 esp, 4
  00097	66 89 45 d4	 mov	 WORD PTR _ic$[ebp], ax

; 210  :    indx = shl(add(ia, add(ib, ic)), 3);

  0009b	6a 03		 push	 3
  0009d	0f b7 45 d4	 movzx	 eax, WORD PTR _ic$[ebp]
  000a1	50		 push	 eax
  000a2	0f b7 4d e0	 movzx	 ecx, WORD PTR _ib$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 _add
  000ac	83 c4 08	 add	 esp, 8
  000af	0f b7 d0	 movzx	 edx, ax
  000b2	52		 push	 edx
  000b3	0f b7 45 ec	 movzx	 eax, WORD PTR _ia$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _add
  000bd	83 c4 08	 add	 esp, 8
  000c0	0f b7 c8	 movzx	 ecx, ax
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _shl
  000c9	83 c4 08	 add	 esp, 8
  000cc	66 89 45 f8	 mov	 WORD PTR _indx$[ebp], ax

; 211  :    ia = pos_indxA & 1;                                logic16 ();

  000d0	0f bf 45 08	 movsx	 eax, WORD PTR _pos_indxA$[ebp]
  000d4	83 e0 01	 and	 eax, 1
  000d7	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax
  000db	e8 00 00 00 00	 call	 _logic16

; 212  :    ib = shl((pos_indxB & 1), 1);                      logic16 ();

  000e0	6a 01		 push	 1
  000e2	0f bf 45 0c	 movsx	 eax, WORD PTR _pos_indxB$[ebp]
  000e6	83 e0 01	 and	 eax, 1
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _shl
  000ef	83 c4 08	 add	 esp, 8
  000f2	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax
  000f6	e8 00 00 00 00	 call	 _logic16

; 213  :    ic = shl((pos_indxC & 1), 2);                      logic16 ();

  000fb	6a 02		 push	 2
  000fd	0f bf 45 10	 movsx	 eax, WORD PTR _pos_indxC$[ebp]
  00101	83 e0 01	 and	 eax, 1
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _shl
  0010a	83 c4 08	 add	 esp, 8
  0010d	66 89 45 d4	 mov	 WORD PTR _ic$[ebp], ax
  00111	e8 00 00 00 00	 call	 _logic16

; 214  :    indx = add(indx , add(ia, add(ib, ic)));  

  00116	0f b7 45 d4	 movzx	 eax, WORD PTR _ic$[ebp]
  0011a	50		 push	 eax
  0011b	0f b7 4d e0	 movzx	 ecx, WORD PTR _ib$[ebp]
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 _add
  00125	83 c4 08	 add	 esp, 8
  00128	0f b7 d0	 movzx	 edx, ax
  0012b	52		 push	 edx
  0012c	0f b7 45 ec	 movzx	 eax, WORD PTR _ia$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _add
  00136	83 c4 08	 add	 esp, 8
  00139	0f b7 c8	 movzx	 ecx, ax
  0013c	51		 push	 ecx
  0013d	0f b7 55 f8	 movzx	 edx, WORD PTR _indx$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 _add
  00147	83 c4 08	 add	 esp, 8
  0014a	66 89 45 f8	 mov	 WORD PTR _indx$[ebp], ax

; 215  :    
; 216  :    return indx;

  0014e	66 8b 45 f8	 mov	 ax, WORD PTR _indx$[ebp]

; 217  : 
; 218  : }

  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0015b	3b ec		 cmp	 ebp, esp
  0015d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
_compress10 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c8_31pf.c
;	COMDAT _build_code
_TEXT	SEGMENT
tv325 = -402						; size = 2
tv317 = -402						; size = 2
tv309 = -402						; size = 2
tv301 = -402						; size = 2
tv293 = -402						; size = 2
tv285 = -402						; size = 2
tv277 = -402						; size = 2
tv269 = -402						; size = 2
_s$ = -204						; size = 4
_p7$ = -192						; size = 4
_p6$ = -180						; size = 4
_p5$ = -168						; size = 4
_p4$ = -156						; size = 4
_p3$ = -144						; size = 4
_p2$ = -132						; size = 4
_p1$ = -120						; size = 4
_p0$ = -108						; size = 4
__sign$ = -96						; size = 16
_pos_index$ = -72					; size = 2
_sign_index$ = -60					; size = 2
_track$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_codvec$ = 8						; size = 4
_sign$ = 12						; size = 4
_cod$ = 16						; size = 4
_h$ = 20						; size = 4
_y$ = 24						; size = 4
_sign_indx$ = 28					; size = 4
_pos_indx$ = 32						; size = 4
_build_code PROC					; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 79   :     Word16 i, j, k, track, sign_index, pos_index, _sign[NB_PULSE];
; 80   :     Word16 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7;
; 81   :     Word32 s;
; 82   : 
; 83   :     for (i = 0; i < L_CODE; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN22@build_code
$LN21@build_code:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN22@build_code:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 28	 cmp	 eax, 40			; 00000028H
  00043	7d 14		 jge	 SHORT $LN20@build_code

; 84   :     {
; 85   :         cod[i] = 0;                              move16 (); 

  00045	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00049	33 c9		 xor	 ecx, ecx
  0004b	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  0004e	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00052	e8 00 00 00 00	 call	 _move16

; 86   :     }

  00057	eb d7		 jmp	 SHORT $LN21@build_code
$LN20@build_code:

; 87   :     for (i = 0; i < NB_TRACK_MR102; i++)

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN19@build_code
$LN18@build_code:
  00061	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN19@build_code:
  0006d	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00071	83 f8 04	 cmp	 eax, 4
  00074	7d 28		 jge	 SHORT $LN17@build_code

; 88   :     {
; 89   :         pos_indx[i] = -1;                            move16 (); 

  00076	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	83 c9 ff	 or	 ecx, -1
  0007d	8b 55 20	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00080	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00084	e8 00 00 00 00	 call	 _move16

; 90   :         sign_indx[i] = -1;                            move16 (); 

  00089	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0008d	83 c9 ff	 or	 ecx, -1
  00090	8b 55 1c	 mov	 edx, DWORD PTR _sign_indx$[ebp]
  00093	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00097	e8 00 00 00 00	 call	 _move16

; 91   :     }

  0009c	eb c3		 jmp	 SHORT $LN18@build_code
$LN17@build_code:

; 92   :     
; 93   :     for (k = 0; k < NB_PULSE; k++)

  0009e	33 c0		 xor	 eax, eax
  000a0	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  000a4	eb 0c		 jmp	 SHORT $LN16@build_code
$LN15@build_code:
  000a6	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  000aa	66 83 c0 01	 add	 ax, 1
  000ae	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
$LN16@build_code:
  000b2	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  000b6	83 f8 08	 cmp	 eax, 8
  000b9	0f 8d 64 02 00
	00		 jge	 $LN14@build_code

; 94   :     {
; 95   :        /* read pulse position */            
; 96   :        i = codvec[k];                           move16 ();

  000bf	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  000c6	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000ca	66 89 55 f4	 mov	 WORD PTR _i$[ebp], dx
  000ce	e8 00 00 00 00	 call	 _move16

; 97   :        /* read sign           */        
; 98   :        j = sign[i];                             move16 (); 

  000d3	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000d7	8b 4d 0c	 mov	 ecx, DWORD PTR _sign$[ebp]
  000da	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000de	66 89 55 e8	 mov	 WORD PTR _j$[ebp], dx
  000e2	e8 00 00 00 00	 call	 _move16

; 99   :        
; 100  :        pos_index = shr(i, 2);                      /* index = pos/4 */

  000e7	6a 02		 push	 2
  000e9	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _shr
  000f3	83 c4 08	 add	 esp, 8
  000f6	66 89 45 b8	 mov	 WORD PTR _pos_index$[ebp], ax

; 101  :        track = i & 3;             logic16 ();      /* track = pos%4 */

  000fa	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000fe	83 e0 03	 and	 eax, 3
  00101	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax
  00105	e8 00 00 00 00	 call	 _logic16

; 102  :        
; 103  :        test (); 

  0010a	e8 00 00 00 00	 call	 _test

; 104  :        if (j > 0)

  0010f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00113	85 c0		 test	 eax, eax
  00115	7e 49		 jle	 SHORT $LN13@build_code

; 105  :        {
; 106  :           cod[i] = add (cod[i], POS_CODE);         move16 ();

  00117	68 ff 1f 00 00	 push	 8191			; 00001fffH
  0011c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00120	8b 4d 10	 mov	 ecx, DWORD PTR _cod$[ebp]
  00123	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00127	52		 push	 edx
  00128	e8 00 00 00 00	 call	 _add
  0012d	83 c4 08	 add	 esp, 8
  00130	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00134	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00137	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0013b	e8 00 00 00 00	 call	 _move16

; 107  :           _sign[k] = POS_SIGN;                     move16 (); 

  00140	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00144	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00149	66 89 4c 45 a0	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  0014e	e8 00 00 00 00	 call	 _move16

; 108  :           sign_index = 0;  /* bit=0 -> positive pulse */  move16 (); 

  00153	33 c0		 xor	 eax, eax
  00155	66 89 45 c4	 mov	 WORD PTR _sign_index$[ebp], ax
  00159	e8 00 00 00 00	 call	 _move16

; 109  :        }
; 110  :        else

  0015e	eb 4a		 jmp	 SHORT $LN12@build_code
$LN13@build_code:

; 111  :        {
; 112  :           cod[i] = sub (cod[i], NEG_CODE);         move16 ();

  00160	68 ff 1f 00 00	 push	 8191			; 00001fffH
  00165	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00169	8b 4d 10	 mov	 ecx, DWORD PTR _cod$[ebp]
  0016c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00170	52		 push	 edx
  00171	e8 00 00 00 00	 call	 _sub
  00176	83 c4 08	 add	 esp, 8
  00179	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0017d	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00180	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00184	e8 00 00 00 00	 call	 _move16

; 113  :           _sign[k] = NEG_SIGN;                     move16 (); 

  00189	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  0018d	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00192	66 89 4c 45 a0	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  00197	e8 00 00 00 00	 call	 _move16

; 114  :           sign_index = 1;     move16 (); /* bit=1 => negative pulse */ 

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	66 89 45 c4	 mov	 WORD PTR _sign_index$[ebp], ax
  001a5	e8 00 00 00 00	 call	 _move16
$LN12@build_code:

; 115  :           /* index = add (index, 8); 1 = negative  old code */
; 116  :        }
; 117  :        
; 118  :        test (); move16 ();

  001aa	e8 00 00 00 00	 call	 _test
  001af	e8 00 00 00 00	 call	 _move16

; 119  :        if (pos_indx[track] < 0)

  001b4	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  001b8	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  001bb	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  001bf	85 d2		 test	 edx, edx
  001c1	7d 2d		 jge	 SHORT $LN11@build_code

; 120  :        {   /* first set first NB_TRACK pulses  */
; 121  :           pos_indx[track] = pos_index;                 move16 (); 

  001c3	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  001c7	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  001ca	66 8b 55 b8	 mov	 dx, WORD PTR _pos_index$[ebp]
  001ce	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  001d2	e8 00 00 00 00	 call	 _move16

; 122  :           sign_indx[track] = sign_index;              move16 (); 

  001d7	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  001db	8b 4d 1c	 mov	 ecx, DWORD PTR _sign_indx$[ebp]
  001de	66 8b 55 c4	 mov	 dx, WORD PTR _sign_index$[ebp]
  001e2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  001e6	e8 00 00 00 00	 call	 _move16

; 123  :        }
; 124  :        else

  001eb	e9 2e 01 00 00	 jmp	 $LN10@build_code
$LN11@build_code:

; 125  :        {   /* 2nd row of pulses , test if positions needs to be switched */
; 126  :           test (); logic16 (); logic16 (); 

  001f0	e8 00 00 00 00	 call	 _test
  001f5	e8 00 00 00 00	 call	 _logic16
  001fa	e8 00 00 00 00	 call	 _logic16

; 127  :           if (((sign_index ^ sign_indx[track]) & 1) == 0)

  001ff	0f bf 45 c4	 movsx	 eax, WORD PTR _sign_index$[ebp]
  00203	0f bf 4d d0	 movsx	 ecx, WORD PTR _track$[ebp]
  00207	8b 55 1c	 mov	 edx, DWORD PTR _sign_indx$[ebp]
  0020a	0f bf 0c 4a	 movsx	 ecx, WORD PTR [edx+ecx*2]
  0020e	33 c1		 xor	 eax, ecx
  00210	83 e0 01	 and	 eax, 1
  00213	0f 85 85 00 00
	00		 jne	 $LN9@build_code

; 128  :           {
; 129  :              /* sign of 1st pulse == sign of 2nd pulse */
; 130  :              
; 131  :              test (); 

  00219	e8 00 00 00 00	 call	 _test

; 132  :              if (sub (pos_indx[track], pos_index) <= 0)

  0021e	0f b7 45 b8	 movzx	 eax, WORD PTR _pos_index$[ebp]
  00222	50		 push	 eax
  00223	0f bf 4d d0	 movsx	 ecx, WORD PTR _track$[ebp]
  00227	8b 55 20	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  0022a	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _sub
  00234	83 c4 08	 add	 esp, 8
  00237	0f bf c8	 movsx	 ecx, ax
  0023a	85 c9		 test	 ecx, ecx
  0023c	7f 17		 jg	 SHORT $LN8@build_code

; 133  :              {   /* no swap */
; 134  :                 pos_indx[track + NB_TRACK_MR102] = pos_index;     move16 (); 

  0023e	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  00242	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00245	66 8b 55 b8	 mov	 dx, WORD PTR _pos_index$[ebp]
  00249	66 89 54 41 08	 mov	 WORD PTR [ecx+eax*2+8], dx
  0024e	e8 00 00 00 00	 call	 _move16

; 135  :              }
; 136  :              else

  00253	eb 44		 jmp	 SHORT $LN7@build_code
$LN8@build_code:

; 137  :              {   /* swap*/
; 138  :                 pos_indx[track + NB_TRACK_MR102] = pos_indx[track];

  00255	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  00259	0f bf 4d d0	 movsx	 ecx, WORD PTR _track$[ebp]
  0025d	8b 55 20	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00260	8b 75 20	 mov	 esi, DWORD PTR _pos_indx$[ebp]
  00263	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00267	66 89 44 4a 08	 mov	 WORD PTR [edx+ecx*2+8], ax

; 139  :                 move16 (); 

  0026c	e8 00 00 00 00	 call	 _move16

; 140  :                 
; 141  :                 pos_indx[track] = pos_index;         move16 ();

  00271	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  00275	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00278	66 8b 55 b8	 mov	 dx, WORD PTR _pos_index$[ebp]
  0027c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00280	e8 00 00 00 00	 call	 _move16

; 142  :                 sign_indx[track] = sign_index;       move16 ();

  00285	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  00289	8b 4d 1c	 mov	 ecx, DWORD PTR _sign_indx$[ebp]
  0028c	66 8b 55 c4	 mov	 dx, WORD PTR _sign_index$[ebp]
  00290	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00294	e8 00 00 00 00	 call	 _move16
$LN7@build_code:

; 143  :              }
; 144  :           }
; 145  :           else

  00299	e9 80 00 00 00	 jmp	 $LN10@build_code
$LN9@build_code:

; 146  :           {
; 147  :              /* sign of 1st pulse != sign of 2nd pulse */
; 148  :              
; 149  :              test (); 

  0029e	e8 00 00 00 00	 call	 _test

; 150  :              if (sub (pos_indx[track], pos_index) <= 0)

  002a3	0f b7 45 b8	 movzx	 eax, WORD PTR _pos_index$[ebp]
  002a7	50		 push	 eax
  002a8	0f bf 4d d0	 movsx	 ecx, WORD PTR _track$[ebp]
  002ac	8b 55 20	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  002af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 _sub
  002b9	83 c4 08	 add	 esp, 8
  002bc	0f bf c8	 movsx	 ecx, ax
  002bf	85 c9		 test	 ecx, ecx
  002c1	7f 46		 jg	 SHORT $LN5@build_code

; 151  :              {  /*swap*/
; 152  :                 pos_indx[track + NB_TRACK_MR102] = pos_indx[track];

  002c3	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  002c7	0f bf 4d d0	 movsx	 ecx, WORD PTR _track$[ebp]
  002cb	8b 55 20	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  002ce	8b 75 20	 mov	 esi, DWORD PTR _pos_indx$[ebp]
  002d1	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  002d5	66 89 44 4a 08	 mov	 WORD PTR [edx+ecx*2+8], ax

; 153  :                 move16 (); 

  002da	e8 00 00 00 00	 call	 _move16

; 154  :                 
; 155  :                 pos_indx[track] = pos_index;         move16 (); 

  002df	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  002e3	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  002e6	66 8b 55 b8	 mov	 dx, WORD PTR _pos_index$[ebp]
  002ea	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  002ee	e8 00 00 00 00	 call	 _move16

; 156  :                 sign_indx[track] = sign_index;       move16 (); 

  002f3	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  002f7	8b 4d 1c	 mov	 ecx, DWORD PTR _sign_indx$[ebp]
  002fa	66 8b 55 c4	 mov	 dx, WORD PTR _sign_index$[ebp]
  002fe	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00302	e8 00 00 00 00	 call	 _move16

; 157  :              }
; 158  :              else

  00307	eb 15		 jmp	 SHORT $LN10@build_code
$LN5@build_code:

; 159  :              {   /*no swap */
; 160  :                 pos_indx[track + NB_TRACK_MR102] = pos_index;     move16 (); 

  00309	0f bf 45 d0	 movsx	 eax, WORD PTR _track$[ebp]
  0030d	8b 4d 20	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00310	66 8b 55 b8	 mov	 dx, WORD PTR _pos_index$[ebp]
  00314	66 89 54 41 08	 mov	 WORD PTR [ecx+eax*2+8], dx
  00319	e8 00 00 00 00	 call	 _move16
$LN10@build_code:

; 161  :              }
; 162  :           }
; 163  :        }
; 164  :     }

  0031e	e9 83 fd ff ff	 jmp	 $LN15@build_code
$LN14@build_code:

; 165  :     
; 166  :     p0 = h - codvec[0];                          move16 (); 

  00323	b8 02 00 00 00	 mov	 eax, 2
  00328	6b c8 00	 imul	 ecx, eax, 0
  0032b	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  0032e	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00332	d1 e0		 shl	 eax, 1
  00334	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00337	2b c8		 sub	 ecx, eax
  00339	89 4d 94	 mov	 DWORD PTR _p0$[ebp], ecx
  0033c	e8 00 00 00 00	 call	 _move16

; 167  :     p1 = h - codvec[1];                          move16 (); 

  00341	b8 02 00 00 00	 mov	 eax, 2
  00346	c1 e0 00	 shl	 eax, 0
  00349	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0034c	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00350	d1 e2		 shl	 edx, 1
  00352	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00355	2b c2		 sub	 eax, edx
  00357	89 45 88	 mov	 DWORD PTR _p1$[ebp], eax
  0035a	e8 00 00 00 00	 call	 _move16

; 168  :     p2 = h - codvec[2];                          move16 (); 

  0035f	b8 02 00 00 00	 mov	 eax, 2
  00364	d1 e0		 shl	 eax, 1
  00366	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00369	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0036d	d1 e2		 shl	 edx, 1
  0036f	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00372	2b c2		 sub	 eax, edx
  00374	89 85 7c ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], eax
  0037a	e8 00 00 00 00	 call	 _move16

; 169  :     p3 = h - codvec[3];                          move16 (); 

  0037f	b8 02 00 00 00	 mov	 eax, 2
  00384	6b c8 03	 imul	 ecx, eax, 3
  00387	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  0038a	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  0038e	d1 e0		 shl	 eax, 1
  00390	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00393	2b c8		 sub	 ecx, eax
  00395	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _p3$[ebp], ecx
  0039b	e8 00 00 00 00	 call	 _move16

; 170  :     p4 = h - codvec[4];                          move16 (); 

  003a0	b8 02 00 00 00	 mov	 eax, 2
  003a5	c1 e0 02	 shl	 eax, 2
  003a8	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  003ab	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  003af	d1 e2		 shl	 edx, 1
  003b1	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  003b4	2b c2		 sub	 eax, edx
  003b6	89 85 64 ff ff
	ff		 mov	 DWORD PTR _p4$[ebp], eax
  003bc	e8 00 00 00 00	 call	 _move16

; 171  :     p5 = h - codvec[5];                          move16 (); 

  003c1	b8 02 00 00 00	 mov	 eax, 2
  003c6	6b c8 05	 imul	 ecx, eax, 5
  003c9	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  003cc	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  003d0	d1 e0		 shl	 eax, 1
  003d2	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  003d5	2b c8		 sub	 ecx, eax
  003d7	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _p5$[ebp], ecx
  003dd	e8 00 00 00 00	 call	 _move16

; 172  :     p6 = h - codvec[6];                          move16 (); 

  003e2	b8 02 00 00 00	 mov	 eax, 2
  003e7	6b c8 06	 imul	 ecx, eax, 6
  003ea	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  003ed	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  003f1	d1 e0		 shl	 eax, 1
  003f3	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  003f6	2b c8		 sub	 ecx, eax
  003f8	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _p6$[ebp], ecx
  003fe	e8 00 00 00 00	 call	 _move16

; 173  :     p7 = h - codvec[7];                          move16 (); 

  00403	b8 02 00 00 00	 mov	 eax, 2
  00408	6b c8 07	 imul	 ecx, eax, 7
  0040b	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  0040e	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00412	d1 e0		 shl	 eax, 1
  00414	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00417	2b c8		 sub	 ecx, eax
  00419	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _p7$[ebp], ecx
  0041f	e8 00 00 00 00	 call	 _move16

; 174  :     
; 175  :     for (i = 0; i < L_CODE; i++)

  00424	33 c0		 xor	 eax, eax
  00426	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0042a	eb 0c		 jmp	 SHORT $LN3@build_code
$LN2@build_code:
  0042c	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00430	66 83 c0 01	 add	 ax, 1
  00434	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@build_code:
  00438	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0043c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0043f	0f 8d 70 02 00
	00		 jge	 $LN23@build_code

; 176  :     {
; 177  :        s = 0;                                   move32 (); 

  00445	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  0044f	e8 00 00 00 00	 call	 _move32

; 178  :        s = L_mac (s, *p0++, _sign[0]);

  00454	8b 45 94	 mov	 eax, DWORD PTR _p0$[ebp]
  00457	66 8b 08	 mov	 cx, WORD PTR [eax]
  0045a	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv269[ebp], cx
  00461	8b 55 94	 mov	 edx, DWORD PTR _p0$[ebp]
  00464	83 c2 02	 add	 edx, 2
  00467	89 55 94	 mov	 DWORD PTR _p0$[ebp], edx
  0046a	b8 02 00 00 00	 mov	 eax, 2
  0046f	6b c8 00	 imul	 ecx, eax, 0
  00472	0f b7 54 0d a0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  00477	52		 push	 edx
  00478	0f b7 85 6e fe
	ff ff		 movzx	 eax, WORD PTR tv269[ebp]
  0047f	50		 push	 eax
  00480	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00486	51		 push	 ecx
  00487	e8 00 00 00 00	 call	 _L_mac
  0048c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0048f	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 179  :        s = L_mac (s, *p1++, _sign[1]);

  00495	8b 45 88	 mov	 eax, DWORD PTR _p1$[ebp]
  00498	66 8b 08	 mov	 cx, WORD PTR [eax]
  0049b	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv277[ebp], cx
  004a2	8b 55 88	 mov	 edx, DWORD PTR _p1$[ebp]
  004a5	83 c2 02	 add	 edx, 2
  004a8	89 55 88	 mov	 DWORD PTR _p1$[ebp], edx
  004ab	b8 02 00 00 00	 mov	 eax, 2
  004b0	c1 e0 00	 shl	 eax, 0
  004b3	0f b7 4c 05 a0	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  004b8	51		 push	 ecx
  004b9	0f b7 95 6e fe
	ff ff		 movzx	 edx, WORD PTR tv277[ebp]
  004c0	52		 push	 edx
  004c1	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  004c7	50		 push	 eax
  004c8	e8 00 00 00 00	 call	 _L_mac
  004cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d0	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 180  :        s = L_mac (s, *p2++, _sign[2]);

  004d6	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _p2$[ebp]
  004dc	66 8b 08	 mov	 cx, WORD PTR [eax]
  004df	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv285[ebp], cx
  004e6	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _p2$[ebp]
  004ec	83 c2 02	 add	 edx, 2
  004ef	89 95 7c ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], edx
  004f5	b8 02 00 00 00	 mov	 eax, 2
  004fa	d1 e0		 shl	 eax, 1
  004fc	0f b7 4c 05 a0	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00501	51		 push	 ecx
  00502	0f b7 95 6e fe
	ff ff		 movzx	 edx, WORD PTR tv285[ebp]
  00509	52		 push	 edx
  0050a	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 _L_mac
  00516	83 c4 0c	 add	 esp, 12			; 0000000cH
  00519	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 181  :        s = L_mac (s, *p3++, _sign[3]);

  0051f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _p3$[ebp]
  00525	66 8b 08	 mov	 cx, WORD PTR [eax]
  00528	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv293[ebp], cx
  0052f	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _p3$[ebp]
  00535	83 c2 02	 add	 edx, 2
  00538	89 95 70 ff ff
	ff		 mov	 DWORD PTR _p3$[ebp], edx
  0053e	b8 02 00 00 00	 mov	 eax, 2
  00543	6b c8 03	 imul	 ecx, eax, 3
  00546	0f b7 54 0d a0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  0054b	52		 push	 edx
  0054c	0f b7 85 6e fe
	ff ff		 movzx	 eax, WORD PTR tv293[ebp]
  00553	50		 push	 eax
  00554	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0055a	51		 push	 ecx
  0055b	e8 00 00 00 00	 call	 _L_mac
  00560	83 c4 0c	 add	 esp, 12			; 0000000cH
  00563	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 182  :        s = L_mac (s, *p4++, _sign[4]);

  00569	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _p4$[ebp]
  0056f	66 8b 08	 mov	 cx, WORD PTR [eax]
  00572	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv301[ebp], cx
  00579	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _p4$[ebp]
  0057f	83 c2 02	 add	 edx, 2
  00582	89 95 64 ff ff
	ff		 mov	 DWORD PTR _p4$[ebp], edx
  00588	b8 02 00 00 00	 mov	 eax, 2
  0058d	c1 e0 02	 shl	 eax, 2
  00590	0f b7 4c 05 a0	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00595	51		 push	 ecx
  00596	0f b7 95 6e fe
	ff ff		 movzx	 edx, WORD PTR tv301[ebp]
  0059d	52		 push	 edx
  0059e	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  005a4	50		 push	 eax
  005a5	e8 00 00 00 00	 call	 _L_mac
  005aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ad	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 183  :        s = L_mac (s, *p5++, _sign[5]);

  005b3	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _p5$[ebp]
  005b9	66 8b 08	 mov	 cx, WORD PTR [eax]
  005bc	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv309[ebp], cx
  005c3	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _p5$[ebp]
  005c9	83 c2 02	 add	 edx, 2
  005cc	89 95 58 ff ff
	ff		 mov	 DWORD PTR _p5$[ebp], edx
  005d2	b8 02 00 00 00	 mov	 eax, 2
  005d7	6b c8 05	 imul	 ecx, eax, 5
  005da	0f b7 54 0d a0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  005df	52		 push	 edx
  005e0	0f b7 85 6e fe
	ff ff		 movzx	 eax, WORD PTR tv309[ebp]
  005e7	50		 push	 eax
  005e8	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  005ee	51		 push	 ecx
  005ef	e8 00 00 00 00	 call	 _L_mac
  005f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  005f7	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 184  :        s = L_mac (s, *p6++, _sign[6]);

  005fd	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _p6$[ebp]
  00603	66 8b 08	 mov	 cx, WORD PTR [eax]
  00606	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv317[ebp], cx
  0060d	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _p6$[ebp]
  00613	83 c2 02	 add	 edx, 2
  00616	89 95 4c ff ff
	ff		 mov	 DWORD PTR _p6$[ebp], edx
  0061c	b8 02 00 00 00	 mov	 eax, 2
  00621	6b c8 06	 imul	 ecx, eax, 6
  00624	0f b7 54 0d a0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  00629	52		 push	 edx
  0062a	0f b7 85 6e fe
	ff ff		 movzx	 eax, WORD PTR tv317[ebp]
  00631	50		 push	 eax
  00632	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00638	51		 push	 ecx
  00639	e8 00 00 00 00	 call	 _L_mac
  0063e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00641	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 185  :        s = L_mac (s, *p7++, _sign[7]);

  00647	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _p7$[ebp]
  0064d	66 8b 08	 mov	 cx, WORD PTR [eax]
  00650	66 89 8d 6e fe
	ff ff		 mov	 WORD PTR tv325[ebp], cx
  00657	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _p7$[ebp]
  0065d	83 c2 02	 add	 edx, 2
  00660	89 95 40 ff ff
	ff		 mov	 DWORD PTR _p7$[ebp], edx
  00666	b8 02 00 00 00	 mov	 eax, 2
  0066b	6b c8 07	 imul	 ecx, eax, 7
  0066e	0f b7 54 0d a0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  00673	52		 push	 edx
  00674	0f b7 85 6e fe
	ff ff		 movzx	 eax, WORD PTR tv325[ebp]
  0067b	50		 push	 eax
  0067c	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00682	51		 push	 ecx
  00683	e8 00 00 00 00	 call	 _L_mac
  00688	83 c4 0c	 add	 esp, 12			; 0000000cH
  0068b	89 85 34 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 186  :        y[i] = round (s);                        move16 (); 

  00691	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00697	50		 push	 eax
  00698	e8 00 00 00 00	 call	 _round
  0069d	83 c4 04	 add	 esp, 4
  006a0	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  006a4	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  006a7	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  006ab	e8 00 00 00 00	 call	 _move16

; 187  :     }

  006b0	e9 77 fd ff ff	 jmp	 $LN2@build_code
$LN23@build_code:

; 188  : }

  006b5	52		 push	 edx
  006b6	8b cd		 mov	 ecx, ebp
  006b8	50		 push	 eax
  006b9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@build_code
  006bf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006c4	58		 pop	 eax
  006c5	5a		 pop	 edx
  006c6	5f		 pop	 edi
  006c7	5e		 pop	 esi
  006c8	5b		 pop	 ebx
  006c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006cc	33 cd		 xor	 ecx, ebp
  006ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d3	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  006d9	3b ec		 cmp	 ebp, esp
  006db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006e0	8b e5		 mov	 esp, ebp
  006e2	5d		 pop	 ebp
  006e3	c3		 ret	 0
$LN27@build_code:
  006e4	01 00 00 00	 DD	 1
  006e8	00 00 00 00	 DD	 $LN26@build_code
$LN26@build_code:
  006ec	a0 ff ff ff	 DD	 -96			; ffffffa0H
  006f0	10 00 00 00	 DD	 16			; 00000010H
  006f4	00 00 00 00	 DD	 $LN25@build_code
$LN25@build_code:
  006f8	5f		 DB	 95			; 0000005fH
  006f9	73		 DB	 115			; 00000073H
  006fa	69		 DB	 105			; 00000069H
  006fb	67		 DB	 103			; 00000067H
  006fc	6e		 DB	 110			; 0000006eH
  006fd	00		 DB	 0
_build_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c8_31pf.c
;	COMDAT _code_8i40_31bits
_TEXT	SEGMENT
_linear_codewords$ = -3488				; size = 16
_linear_signs$ = -3464					; size = 8
_rr$ = -3448						; size = 3200
_sign$ = -240						; size = 80
_dn$ = -152						; size = 80
_codvec$ = -64						; size = 16
_pos_max$ = -40						; size = 8
_ipos$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_cn$ = 12						; size = 4
_h$ = 16						; size = 4
_cod$ = 20						; size = 4
_y$ = 24						; size = 4
_indx$ = 28						; size = 4
_code_8i40_31bits PROC					; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 0e 00
	00		 sub	 esp, 3684		; 00000e64H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 9c f1 ff
	ff		 lea	 edi, DWORD PTR [ebp-3684]
  00012	b9 99 03 00 00	 mov	 ecx, 921		; 00000399H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 325  :    Word16 ipos[NB_PULSE], pos_max[NB_TRACK_MR102], codvec[NB_PULSE];
; 326  :    Word16 dn[L_CODE], sign[L_CODE];
; 327  :    Word16 rr[L_CODE][L_CODE];
; 328  :    Word16 linear_signs[NB_TRACK_MR102];
; 329  :    Word16 linear_codewords[NB_PULSE];
; 330  : 
; 331  :    cor_h_x2 (h, x, dn, 2, NB_TRACK_MR102, STEP_MR102);

  00028	6a 04		 push	 4
  0002a	6a 04		 push	 4
  0002c	6a 02		 push	 2
  0002e	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _dn$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _cor_h_x2
  00042	83 c4 18	 add	 esp, 24			; 00000018H

; 332  :    /* 2 = use GSMEFR scaling */
; 333  : 
; 334  :    set_sign12k2 (dn, cn, sign, pos_max, NB_TRACK_MR102, ipos, STEP_MR102);

  00045	6a 04		 push	 4
  00047	8d 45 e8	 lea	 eax, DWORD PTR _ipos$[ebp]
  0004a	50		 push	 eax
  0004b	6a 04		 push	 4
  0004d	8d 4d d8	 lea	 ecx, DWORD PTR _pos_max$[ebp]
  00050	51		 push	 ecx
  00051	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _sign$[ebp]
  00057	52		 push	 edx
  00058	8b 45 0c	 mov	 eax, DWORD PTR _cn$[ebp]
  0005b	50		 push	 eax
  0005c	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _dn$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _set_sign12k2
  00068	83 c4 1c	 add	 esp, 28			; 0000001cH

; 335  :    /* same setsign alg as GSM-EFR new constants though*/
; 336  :    
; 337  :    cor_h (h, sign, rr);

  0006b	8d 85 88 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00071	50		 push	 eax
  00072	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _sign$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  0007c	52		 push	 edx
  0007d	e8 00 00 00 00	 call	 _cor_h
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 338  :    search_10and8i40 (NB_PULSE, STEP_MR102, NB_TRACK_MR102,
; 339  :                      dn, rr, ipos, pos_max, codvec);

  00085	8d 45 c0	 lea	 eax, DWORD PTR _codvec$[ebp]
  00088	50		 push	 eax
  00089	8d 4d d8	 lea	 ecx, DWORD PTR _pos_max$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 55 e8	 lea	 edx, DWORD PTR _ipos$[ebp]
  00090	52		 push	 edx
  00091	8d 85 88 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00097	50		 push	 eax
  00098	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _dn$[ebp]
  0009e	51		 push	 ecx
  0009f	6a 04		 push	 4
  000a1	6a 04		 push	 4
  000a3	6a 08		 push	 8
  000a5	e8 00 00 00 00	 call	 _search_10and8i40
  000aa	83 c4 20	 add	 esp, 32			; 00000020H

; 340  :    
; 341  :    build_code (codvec, sign, cod, h, y, linear_signs, linear_codewords);

  000ad	8d 85 60 f2 ff
	ff		 lea	 eax, DWORD PTR _linear_codewords$[ebp]
  000b3	50		 push	 eax
  000b4	8d 8d 78 f2 ff
	ff		 lea	 ecx, DWORD PTR _linear_signs$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  000be	52		 push	 edx
  000bf	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  000c2	50		 push	 eax
  000c3	8b 4d 14	 mov	 ecx, DWORD PTR _cod$[ebp]
  000c6	51		 push	 ecx
  000c7	8d 95 10 ff ff
	ff		 lea	 edx, DWORD PTR _sign$[ebp]
  000cd	52		 push	 edx
  000ce	8d 45 c0	 lea	 eax, DWORD PTR _codvec$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _build_code
  000d7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 342  :    compress_code (linear_signs, linear_codewords, indx);

  000da	8b 45 1c	 mov	 eax, DWORD PTR _indx$[ebp]
  000dd	50		 push	 eax
  000de	8d 8d 60 f2 ff
	ff		 lea	 ecx, DWORD PTR _linear_codewords$[ebp]
  000e4	51		 push	 ecx
  000e5	8d 95 78 f2 ff
	ff		 lea	 edx, DWORD PTR _linear_signs$[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 _compress_code
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 343  :    
; 344  :    return;
; 345  : }

  000f4	52		 push	 edx
  000f5	8b cd		 mov	 ecx, ebp
  000f7	50		 push	 eax
  000f8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@code_8i40_
  000fe	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00103	58		 pop	 eax
  00104	5a		 pop	 edx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	81 c4 64 0e 00
	00		 add	 esp, 3684		; 00000e64H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
  00123	90		 npad	 1
$LN12@code_8i40_:
  00124	08 00 00 00	 DD	 8
  00128	00 00 00 00	 DD	 $LN11@code_8i40_
$LN11@code_8i40_:
  0012c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00130	10 00 00 00	 DD	 16			; 00000010H
  00134	00 00 00 00	 DD	 $LN3@code_8i40_
  00138	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0013c	08 00 00 00	 DD	 8
  00140	00 00 00 00	 DD	 $LN4@code_8i40_
  00144	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00148	10 00 00 00	 DD	 16			; 00000010H
  0014c	00 00 00 00	 DD	 $LN5@code_8i40_
  00150	68 ff ff ff	 DD	 -152			; ffffff68H
  00154	50 00 00 00	 DD	 80			; 00000050H
  00158	00 00 00 00	 DD	 $LN6@code_8i40_
  0015c	10 ff ff ff	 DD	 -240			; ffffff10H
  00160	50 00 00 00	 DD	 80			; 00000050H
  00164	00 00 00 00	 DD	 $LN7@code_8i40_
  00168	88 f2 ff ff	 DD	 -3448			; fffff288H
  0016c	80 0c 00 00	 DD	 3200			; 00000c80H
  00170	00 00 00 00	 DD	 $LN8@code_8i40_
  00174	78 f2 ff ff	 DD	 -3464			; fffff278H
  00178	08 00 00 00	 DD	 8
  0017c	00 00 00 00	 DD	 $LN9@code_8i40_
  00180	60 f2 ff ff	 DD	 -3488			; fffff260H
  00184	10 00 00 00	 DD	 16			; 00000010H
  00188	00 00 00 00	 DD	 $LN10@code_8i40_
$LN10@code_8i40_:
  0018c	6c		 DB	 108			; 0000006cH
  0018d	69		 DB	 105			; 00000069H
  0018e	6e		 DB	 110			; 0000006eH
  0018f	65		 DB	 101			; 00000065H
  00190	61		 DB	 97			; 00000061H
  00191	72		 DB	 114			; 00000072H
  00192	5f		 DB	 95			; 0000005fH
  00193	63		 DB	 99			; 00000063H
  00194	6f		 DB	 111			; 0000006fH
  00195	64		 DB	 100			; 00000064H
  00196	65		 DB	 101			; 00000065H
  00197	77		 DB	 119			; 00000077H
  00198	6f		 DB	 111			; 0000006fH
  00199	72		 DB	 114			; 00000072H
  0019a	64		 DB	 100			; 00000064H
  0019b	73		 DB	 115			; 00000073H
  0019c	00		 DB	 0
$LN9@code_8i40_:
  0019d	6c		 DB	 108			; 0000006cH
  0019e	69		 DB	 105			; 00000069H
  0019f	6e		 DB	 110			; 0000006eH
  001a0	65		 DB	 101			; 00000065H
  001a1	61		 DB	 97			; 00000061H
  001a2	72		 DB	 114			; 00000072H
  001a3	5f		 DB	 95			; 0000005fH
  001a4	73		 DB	 115			; 00000073H
  001a5	69		 DB	 105			; 00000069H
  001a6	67		 DB	 103			; 00000067H
  001a7	6e		 DB	 110			; 0000006eH
  001a8	73		 DB	 115			; 00000073H
  001a9	00		 DB	 0
$LN8@code_8i40_:
  001aa	72		 DB	 114			; 00000072H
  001ab	72		 DB	 114			; 00000072H
  001ac	00		 DB	 0
$LN7@code_8i40_:
  001ad	73		 DB	 115			; 00000073H
  001ae	69		 DB	 105			; 00000069H
  001af	67		 DB	 103			; 00000067H
  001b0	6e		 DB	 110			; 0000006eH
  001b1	00		 DB	 0
$LN6@code_8i40_:
  001b2	64		 DB	 100			; 00000064H
  001b3	6e		 DB	 110			; 0000006eH
  001b4	00		 DB	 0
$LN5@code_8i40_:
  001b5	63		 DB	 99			; 00000063H
  001b6	6f		 DB	 111			; 0000006fH
  001b7	64		 DB	 100			; 00000064H
  001b8	76		 DB	 118			; 00000076H
  001b9	65		 DB	 101			; 00000065H
  001ba	63		 DB	 99			; 00000063H
  001bb	00		 DB	 0
$LN4@code_8i40_:
  001bc	70		 DB	 112			; 00000070H
  001bd	6f		 DB	 111			; 0000006fH
  001be	73		 DB	 115			; 00000073H
  001bf	5f		 DB	 95			; 0000005fH
  001c0	6d		 DB	 109			; 0000006dH
  001c1	61		 DB	 97			; 00000061H
  001c2	78		 DB	 120			; 00000078H
  001c3	00		 DB	 0
$LN3@code_8i40_:
  001c4	69		 DB	 105			; 00000069H
  001c5	70		 DB	 112			; 00000070H
  001c6	6f		 DB	 111			; 0000006fH
  001c7	73		 DB	 115			; 00000073H
  001c8	00		 DB	 0
_code_8i40_31bits ENDP
_TEXT	ENDS
END
