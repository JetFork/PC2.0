; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c2_9pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c2_9pf_id
_DATA	SEGMENT
?trackTable@?1??build_code@@9@9 DW 00H			; `build_code'::`2'::trackTable
	DW	01H
	DW	00H
	DW	01H
	DW	0ffffH
	DW	00H
	DW	0ffffH
	DW	01H
	DW	00H
	DW	01H
	DW	00H
	DW	01H
	DW	00H
	DW	0ffffH
	DW	01H
	DW	00H
	DW	01H
	DW	0ffffH
	DW	00H
	DW	01H
_DATA	ENDS
CONST	SEGMENT
_c2_9pf_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_startPos DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	04H
CONST	ENDS
PUBLIC	_code_2i40_9bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_cor_h_x:PROC
EXTRN	_cor_h:PROC
EXTRN	_set_sign:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_9pf.c
;	COMDAT _build_code
_TEXT	SEGMENT
tv201 = -350						; size = 2
tv193 = -350						; size = 2
_s$ = -152						; size = 4
_pt$ = -140						; size = 4
_p1$ = -128						; size = 4
_p0$ = -116						; size = 4
_rsign$ = -104						; size = 2
_indx$ = -92						; size = 2
__sign$ = -80						; size = 4
_index$ = -68						; size = 2
_first$ = -56						; size = 2
_track$ = -44						; size = 2
_k$ = -32						; size = 2
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_subNr$ = 8						; size = 2
_codvec$ = 12						; size = 4
_dn_sign$ = 16						; size = 4
_cod$ = 20						; size = 4
_h$ = 24						; size = 4
_y$ = 28						; size = 4
_sign$ = 32						; size = 4
_build_code PROC					; COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00012	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 295  :     Word16 i, j, k, track, first, index, _sign[NB_PULSE], indx, rsign;
; 296  :     Word16 *p0, *p1, *pt;
; 297  :     Word32 s;
; 298  :     static Word16 trackTable[4*5] = {
; 299  :        0, 1, 0, 1, -1, /* subframe 1; track to code; -1 do not code this position */
; 300  :        0, -1, 1, 0, 1, /* subframe 2 */
; 301  :        0, 1, 0, -1, 1, /* subframe 3 */
; 302  :        0, 1, -1, 0, 1};/* subframe 4 */
; 303  : 
; 304  :     pt = &trackTable[add(subNr, shl(subNr, 2))];

  0001e	6a 02		 push	 2
  00020	0f b7 45 08	 movzx	 eax, WORD PTR _subNr$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _shl
  0002a	83 c4 08	 add	 esp, 8
  0002d	0f b7 c8	 movzx	 ecx, ax
  00030	51		 push	 ecx
  00031	0f b7 55 08	 movzx	 edx, WORD PTR _subNr$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _add
  0003b	83 c4 08	 add	 esp, 8
  0003e	98		 cwde
  0003f	8d 0c 45 00 00
	00 00		 lea	 ecx, DWORD PTR ?trackTable@?1??build_code@@9@9[eax*2]
  00046	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _pt$[ebp], ecx

; 305  : 	
; 306  :     for (i = 0; i < L_CODE; i++) {

  0004c	33 c0		 xor	 eax, eax
  0004e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00052	eb 0c		 jmp	 SHORT $LN17@build_code
$LN16@build_code:
  00054	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00058	66 83 c0 01	 add	 ax, 1
  0005c	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN17@build_code:
  00060	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00064	83 f8 28	 cmp	 eax, 40			; 00000028H
  00067	7d 14		 jge	 SHORT $LN15@build_code

; 307  :         cod[i] = 0;                                 move16 ();

  00069	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0006d	33 c9		 xor	 ecx, ecx
  0006f	8b 55 14	 mov	 edx, DWORD PTR _cod$[ebp]
  00072	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00076	e8 00 00 00 00	 call	 _move16

; 308  :     }

  0007b	eb d7		 jmp	 SHORT $LN16@build_code
$LN15@build_code:

; 309  :     
; 310  :     indx = 0; move16 ();

  0007d	33 c0		 xor	 eax, eax
  0007f	66 89 45 a4	 mov	 WORD PTR _indx$[ebp], ax
  00083	e8 00 00 00 00	 call	 _move16

; 311  :     rsign = 0; move16 ();

  00088	33 c0		 xor	 eax, eax
  0008a	66 89 45 98	 mov	 WORD PTR _rsign$[ebp], ax
  0008e	e8 00 00 00 00	 call	 _move16

; 312  :     for (k = 0; k < NB_PULSE; k++) {

  00093	33 c0		 xor	 eax, eax
  00095	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
  00099	eb 0c		 jmp	 SHORT $LN14@build_code
$LN13@build_code:
  0009b	66 8b 45 e0	 mov	 ax, WORD PTR _k$[ebp]
  0009f	66 83 c0 01	 add	 ax, 1
  000a3	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
$LN14@build_code:
  000a7	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  000ab	83 f8 02	 cmp	 eax, 2
  000ae	0f 8d c3 01 00
	00		 jge	 $LN12@build_code

; 313  :        i = codvec[k];    /* read pulse position */  move16 ();

  000b4	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _codvec$[ebp]
  000bb	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000bf	66 89 55 f8	 mov	 WORD PTR _i$[ebp], dx
  000c3	e8 00 00 00 00	 call	 _move16

; 314  :        j = dn_sign[i];   /* read sign           */  move16 ();

  000c8	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR _dn_sign$[ebp]
  000cf	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000d3	66 89 55 ec	 mov	 WORD PTR _j$[ebp], dx
  000d7	e8 00 00 00 00	 call	 _move16

; 315  : 
; 316  :        index = mult(i, 6554);    /* index = pos/5 */

  000dc	68 9a 19 00 00	 push	 6554			; 0000199aH
  000e1	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _mult
  000eb	83 c4 08	 add	 esp, 8
  000ee	66 89 45 bc	 mov	 WORD PTR _index$[ebp], ax

; 317  :                                  /* track = pos%5 */
; 318  :        track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));

  000f2	6a 01		 push	 1
  000f4	6a 05		 push	 5
  000f6	0f b7 45 bc	 movzx	 eax, WORD PTR _index$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _L_mult
  00100	83 c4 08	 add	 esp, 8
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _L_shr
  00109	83 c4 08	 add	 esp, 8
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _extract_l
  00112	83 c4 04	 add	 esp, 4
  00115	0f b7 c8	 movzx	 ecx, ax
  00118	51		 push	 ecx
  00119	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 _sub
  00123	83 c4 08	 add	 esp, 8
  00126	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax

; 319  :        
; 320  :        first = pt[track];                           move16 ();

  0012a	0f bf 45 d4	 movsx	 eax, WORD PTR _track$[ebp]
  0012e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _pt$[ebp]
  00134	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00138	66 89 55 c8	 mov	 WORD PTR _first$[ebp], dx
  0013c	e8 00 00 00 00	 call	 _move16

; 321  : 
; 322  :        test ();

  00141	e8 00 00 00 00	 call	 _test

; 323  :        if (first == 0) {

  00146	0f bf 45 c8	 movsx	 eax, WORD PTR _first$[ebp]
  0014a	85 c0		 test	 eax, eax
  0014c	75 3d		 jne	 SHORT $LN11@build_code

; 324  :           test ();

  0014e	e8 00 00 00 00	 call	 _test

; 325  :           if (k == 0) {

  00153	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  00157	85 c0		 test	 eax, eax
  00159	75 0d		 jne	 SHORT $LN10@build_code

; 326  :              track = 0;                             move16 ();

  0015b	33 c0		 xor	 eax, eax
  0015d	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  00161	e8 00 00 00 00	 call	 _move16

; 327  :           } else {

  00166	eb 21		 jmp	 SHORT $LN9@build_code
$LN10@build_code:

; 328  :              track = 1;                             move16 ();           

  00168	b8 01 00 00 00	 mov	 eax, 1
  0016d	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  00171	e8 00 00 00 00	 call	 _move16

; 329  :              index = shl(index, 3);

  00176	6a 03		 push	 3
  00178	0f b7 45 bc	 movzx	 eax, WORD PTR _index$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _shl
  00182	83 c4 08	 add	 esp, 8
  00185	66 89 45 bc	 mov	 WORD PTR _index$[ebp], ax
$LN9@build_code:

; 330  :           }             
; 331  :        } else {

  00189	eb 4e		 jmp	 SHORT $LN8@build_code
$LN11@build_code:

; 332  :           test ();

  0018b	e8 00 00 00 00	 call	 _test

; 333  :           if (k == 0) {

  00190	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  00194	85 c0		 test	 eax, eax
  00196	75 20		 jne	 SHORT $LN7@build_code

; 334  :              track = 0;                             move16 ();            

  00198	33 c0		 xor	 eax, eax
  0019a	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  0019e	e8 00 00 00 00	 call	 _move16

; 335  :              index = add(index, 64);  /* table bit is MSB */

  001a3	6a 40		 push	 64			; 00000040H
  001a5	0f b7 45 bc	 movzx	 eax, WORD PTR _index$[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _add
  001af	83 c4 08	 add	 esp, 8
  001b2	66 89 45 bc	 mov	 WORD PTR _index$[ebp], ax

; 336  :           } else {

  001b6	eb 21		 jmp	 SHORT $LN8@build_code
$LN7@build_code:

; 337  :              track = 1;                             move16 ();           

  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  001c1	e8 00 00 00 00	 call	 _move16

; 338  :              index = shl(index, 3);

  001c6	6a 03		 push	 3
  001c8	0f b7 45 bc	 movzx	 eax, WORD PTR _index$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 _shl
  001d2	83 c4 08	 add	 esp, 8
  001d5	66 89 45 bc	 mov	 WORD PTR _index$[ebp], ax
$LN8@build_code:

; 339  :           }             
; 340  :        }
; 341  : 
; 342  :        test ();

  001d9	e8 00 00 00 00	 call	 _test

; 343  :        if (j > 0) {

  001de	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  001e2	85 c0		 test	 eax, eax
  001e4	7e 4e		 jle	 SHORT $LN5@build_code

; 344  :           cod[i] = 8191;                            move16 ();

  001e6	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001ea	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  001ef	8b 55 14	 mov	 edx, DWORD PTR _cod$[ebp]
  001f2	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001f6	e8 00 00 00 00	 call	 _move16

; 345  :           _sign[k] = 32767;                         move16 ();

  001fb	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  001ff	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00204	66 89 4c 45 b0	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  00209	e8 00 00 00 00	 call	 _move16

; 346  :           rsign = add(rsign, shl(1, track));

  0020e	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  00212	50		 push	 eax
  00213	6a 01		 push	 1
  00215	e8 00 00 00 00	 call	 _shl
  0021a	83 c4 08	 add	 esp, 8
  0021d	0f b7 c8	 movzx	 ecx, ax
  00220	51		 push	 ecx
  00221	0f b7 55 98	 movzx	 edx, WORD PTR _rsign$[ebp]
  00225	52		 push	 edx
  00226	e8 00 00 00 00	 call	 _add
  0022b	83 c4 08	 add	 esp, 8
  0022e	66 89 45 98	 mov	 WORD PTR _rsign$[ebp], ax

; 347  :        } else {

  00232	eb 28		 jmp	 SHORT $LN4@build_code
$LN5@build_code:

; 348  :           cod[i] = -8192;                           move16 ();

  00234	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00238	b9 00 e0 ff ff	 mov	 ecx, -8192		; ffffe000H
  0023d	8b 55 14	 mov	 edx, DWORD PTR _cod$[ebp]
  00240	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00244	e8 00 00 00 00	 call	 _move16

; 349  :           _sign[k] = (Word16) - 32768L;             move16 ();

  00249	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  0024d	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00252	66 89 4c 45 b0	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  00257	e8 00 00 00 00	 call	 _move16
$LN4@build_code:

; 350  :         }
; 351  :        
; 352  :        indx = add(indx, index);

  0025c	0f b7 45 bc	 movzx	 eax, WORD PTR _index$[ebp]
  00260	50		 push	 eax
  00261	0f b7 4d a4	 movzx	 ecx, WORD PTR _indx$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _add
  0026b	83 c4 08	 add	 esp, 8
  0026e	66 89 45 a4	 mov	 WORD PTR _indx$[ebp], ax

; 353  :     }

  00272	e9 24 fe ff ff	 jmp	 $LN13@build_code
$LN12@build_code:

; 354  :     *sign = rsign;                                  move16 ();

  00277	8b 45 20	 mov	 eax, DWORD PTR _sign$[ebp]
  0027a	66 8b 4d 98	 mov	 cx, WORD PTR _rsign$[ebp]
  0027e	66 89 08	 mov	 WORD PTR [eax], cx
  00281	e8 00 00 00 00	 call	 _move16

; 355  :                                   
; 356  :     p0 = h - codvec[0];                             move16 ();

  00286	b8 02 00 00 00	 mov	 eax, 2
  0028b	6b c8 00	 imul	 ecx, eax, 0
  0028e	8b 55 0c	 mov	 edx, DWORD PTR _codvec$[ebp]
  00291	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00295	d1 e0		 shl	 eax, 1
  00297	8b 4d 18	 mov	 ecx, DWORD PTR _h$[ebp]
  0029a	2b c8		 sub	 ecx, eax
  0029c	89 4d 8c	 mov	 DWORD PTR _p0$[ebp], ecx
  0029f	e8 00 00 00 00	 call	 _move16

; 357  :     p1 = h - codvec[1];                             move16 ();

  002a4	b8 02 00 00 00	 mov	 eax, 2
  002a9	c1 e0 00	 shl	 eax, 0
  002ac	8b 4d 0c	 mov	 ecx, DWORD PTR _codvec$[ebp]
  002af	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  002b3	d1 e2		 shl	 edx, 1
  002b5	8b 45 18	 mov	 eax, DWORD PTR _h$[ebp]
  002b8	2b c2		 sub	 eax, edx
  002ba	89 45 80	 mov	 DWORD PTR _p1$[ebp], eax
  002bd	e8 00 00 00 00	 call	 _move16

; 358  :     
; 359  :     for (i = 0; i < L_CODE; i++) {

  002c2	33 c0		 xor	 eax, eax
  002c4	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  002c8	eb 0c		 jmp	 SHORT $LN3@build_code
$LN2@build_code:
  002ca	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  002ce	66 83 c0 01	 add	 ax, 1
  002d2	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@build_code:
  002d6	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  002da	83 f8 28	 cmp	 eax, 40			; 00000028H
  002dd	0f 8d b5 00 00
	00		 jge	 $LN1@build_code

; 360  :        s = 0;                                       move32 ();

  002e3	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  002ed	e8 00 00 00 00	 call	 _move32

; 361  :        s = L_mac(s, *p0++, _sign[0]);

  002f2	8b 45 8c	 mov	 eax, DWORD PTR _p0$[ebp]
  002f5	66 8b 08	 mov	 cx, WORD PTR [eax]
  002f8	66 89 8d a2 fe
	ff ff		 mov	 WORD PTR tv193[ebp], cx
  002ff	8b 55 8c	 mov	 edx, DWORD PTR _p0$[ebp]
  00302	83 c2 02	 add	 edx, 2
  00305	89 55 8c	 mov	 DWORD PTR _p0$[ebp], edx
  00308	b8 02 00 00 00	 mov	 eax, 2
  0030d	6b c8 00	 imul	 ecx, eax, 0
  00310	0f b7 54 0d b0	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  00315	52		 push	 edx
  00316	0f b7 85 a2 fe
	ff ff		 movzx	 eax, WORD PTR tv193[ebp]
  0031d	50		 push	 eax
  0031e	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00324	51		 push	 ecx
  00325	e8 00 00 00 00	 call	 _L_mac
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032d	89 85 68 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 362  :        s = L_mac(s, *p1++, _sign[1]);

  00333	8b 45 80	 mov	 eax, DWORD PTR _p1$[ebp]
  00336	66 8b 08	 mov	 cx, WORD PTR [eax]
  00339	66 89 8d a2 fe
	ff ff		 mov	 WORD PTR tv201[ebp], cx
  00340	8b 55 80	 mov	 edx, DWORD PTR _p1$[ebp]
  00343	83 c2 02	 add	 edx, 2
  00346	89 55 80	 mov	 DWORD PTR _p1$[ebp], edx
  00349	b8 02 00 00 00	 mov	 eax, 2
  0034e	c1 e0 00	 shl	 eax, 0
  00351	0f b7 4c 05 b0	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00356	51		 push	 ecx
  00357	0f b7 95 a2 fe
	ff ff		 movzx	 edx, WORD PTR tv201[ebp]
  0035e	52		 push	 edx
  0035f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 _L_mac
  0036b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036e	89 85 68 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 363  :        y[i] = round(s);                             move16 ();

  00374	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 _round
  00380	83 c4 04	 add	 esp, 4
  00383	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00387	8b 55 1c	 mov	 edx, DWORD PTR _y$[ebp]
  0038a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0038e	e8 00 00 00 00	 call	 _move16

; 364  :     }

  00393	e9 32 ff ff ff	 jmp	 $LN2@build_code
$LN1@build_code:

; 365  :     
; 366  :     return indx;

  00398	66 8b 45 a4	 mov	 ax, WORD PTR _indx$[ebp]

; 367  : }

  0039c	52		 push	 edx
  0039d	8b cd		 mov	 ecx, ebp
  0039f	50		 push	 eax
  003a0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@build_code
  003a6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003ab	58		 pop	 eax
  003ac	5a		 pop	 edx
  003ad	5f		 pop	 edi
  003ae	5e		 pop	 esi
  003af	5b		 pop	 ebx
  003b0	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  003b6	3b ec		 cmp	 ebp, esp
  003b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003bd	8b e5		 mov	 esp, ebp
  003bf	5d		 pop	 ebp
  003c0	c3		 ret	 0
  003c1	8d 49 00	 npad	 3
$LN22@build_code:
  003c4	01 00 00 00	 DD	 1
  003c8	00 00 00 00	 DD	 $LN21@build_code
$LN21@build_code:
  003cc	b0 ff ff ff	 DD	 -80			; ffffffb0H
  003d0	04 00 00 00	 DD	 4
  003d4	00 00 00 00	 DD	 $LN20@build_code
$LN20@build_code:
  003d8	5f		 DB	 95			; 0000005fH
  003d9	73		 DB	 115			; 00000073H
  003da	69		 DB	 105			; 00000069H
  003db	67		 DB	 103			; 00000067H
  003dc	6e		 DB	 110			; 0000006eH
  003dd	00		 DB	 0
_build_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_9pf.c
;	COMDAT _search_2i40
_TEXT	SEGMENT
_i$ = -200						; size = 2
_alp1$ = -188						; size = 4
_alp0$ = -176						; size = 4
_s$ = -164						; size = 4
_alp_16$ = -152						; size = 2
_alp$ = -140						; size = 2
_alpk$ = -128						; size = 2
_sq1$ = -116						; size = 2
_sq$ = -104						; size = 2
_ps1$ = -92						; size = 2
_ps0$ = -80						; size = 2
_psk$ = -68						; size = 2
_ipos$ = -56						; size = 4
_track1$ = -44						; size = 2
_ix$ = -32						; size = 2
_i1$ = -20						; size = 2
_i0$ = -8						; size = 2
_subNr$ = 8						; size = 2
_dn$ = 12						; size = 4
_rr$ = 16						; size = 4
_codvec$ = 20						; size = 4
_search_2i40 PROC					; COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 74 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-396]
  00012	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 185  :     Word16 i0, i1;
; 186  :     Word16 ix = 0; /* initialization only needed to keep gcc silent */

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 e0	 mov	 WORD PTR _ix$[ebp], ax

; 187  :     Word16  track1, ipos[NB_PULSE];
; 188  :     Word16 psk, ps0, ps1, sq, sq1;
; 189  :     Word16 alpk, alp, alp_16;
; 190  :     Word32 s, alp0, alp1;
; 191  :     Word16 i;    
; 192  : 
; 193  :     psk = -1;                     move16 ();

  00024	83 c8 ff	 or	 eax, -1
  00027	66 89 45 bc	 mov	 WORD PTR _psk$[ebp], ax
  0002b	e8 00 00 00 00	 call	 _move16

; 194  :     alpk = 1;                     move16 ();

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	66 89 45 80	 mov	 WORD PTR _alpk$[ebp], ax
  00039	e8 00 00 00 00	 call	 _move16

; 195  :     for (i = 0; i < NB_PULSE; i++)

  0003e	33 c0		 xor	 eax, eax
  00040	66 89 85 38 ff
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00047	eb 12		 jmp	 SHORT $LN14@search_2i4
$LN13@search_2i4:
  00049	66 8b 85 38 ff
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00050	66 83 c0 01	 add	 ax, 1
  00054	66 89 85 38 ff
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN14@search_2i4:
  0005b	0f bf 85 38 ff
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00062	83 f8 02	 cmp	 eax, 2
  00065	7d 1c		 jge	 SHORT $LN12@search_2i4

; 196  :     {
; 197  :        codvec[i] = i;             move16 ();

  00067	0f bf 85 38 ff
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0006e	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00071	66 8b 95 38 ff
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  00078	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0007c	e8 00 00 00 00	 call	 _move16

; 198  :     }

  00081	eb c6		 jmp	 SHORT $LN13@search_2i4
$LN12@search_2i4:

; 199  :  
; 200  :     for (track1 = 0; track1 < 2; track1++) {		

  00083	33 c0		 xor	 eax, eax
  00085	66 89 45 d4	 mov	 WORD PTR _track1$[ebp], ax
  00089	eb 0c		 jmp	 SHORT $LN11@search_2i4
$LN10@search_2i4:
  0008b	66 8b 45 d4	 mov	 ax, WORD PTR _track1$[ebp]
  0008f	66 83 c0 01	 add	 ax, 1
  00093	66 89 45 d4	 mov	 WORD PTR _track1$[ebp], ax
$LN11@search_2i4:
  00097	0f bf 45 d4	 movsx	 eax, WORD PTR _track1$[ebp]
  0009b	83 f8 02	 cmp	 eax, 2
  0009e	0f 8d cf 02 00
	00		 jge	 $LN15@search_2i4

; 201  :        /* fix starting position */
; 202  :        
; 203  :        ipos[0] = startPos[subNr*2+8*track1];     move16 ();

  000a4	0f bf 45 08	 movsx	 eax, WORD PTR _subNr$[ebp]
  000a8	0f bf 4d d4	 movsx	 ecx, WORD PTR _track1$[ebp]
  000ac	c1 e1 03	 shl	 ecx, 3
  000af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000b2	b8 02 00 00 00	 mov	 eax, 2
  000b7	6b c8 00	 imul	 ecx, eax, 0
  000ba	66 8b 14 55 00
	00 00 00	 mov	 dx, WORD PTR _startPos[edx*2]
  000c2	66 89 54 0d c8	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  000c7	e8 00 00 00 00	 call	 _move16

; 204  :        ipos[1] = startPos[subNr*2+1+8*track1];   move16 ();          

  000cc	0f bf 45 08	 movsx	 eax, WORD PTR _subNr$[ebp]
  000d0	0f bf 4d d4	 movsx	 ecx, WORD PTR _track1$[ebp]
  000d4	c1 e1 03	 shl	 ecx, 3
  000d7	8d 54 41 01	 lea	 edx, DWORD PTR [ecx+eax*2+1]
  000db	b8 02 00 00 00	 mov	 eax, 2
  000e0	c1 e0 00	 shl	 eax, 0
  000e3	66 8b 0c 55 00
	00 00 00	 mov	 cx, WORD PTR _startPos[edx*2]
  000eb	66 89 4c 05 c8	 mov	 WORD PTR _ipos$[ebp+eax], cx
  000f0	e8 00 00 00 00	 call	 _move16

; 205  :        
; 206  : 
; 207  :           /*----------------------------------------------------------------*
; 208  :            * i0 loop: try 8 positions.                                      *
; 209  :            *----------------------------------------------------------------*/
; 210  :           
; 211  : 			                  move16 (); /* account for ptr. init. (rr[io]) */

  000f5	e8 00 00 00 00	 call	 _move16

; 212  :           for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {

  000fa	b8 02 00 00 00	 mov	 eax, 2
  000ff	6b c8 00	 imul	 ecx, eax, 0
  00102	66 8b 54 0d c8	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  00107	66 89 55 f8	 mov	 WORD PTR _i0$[ebp], dx
  0010b	eb 0b		 jmp	 SHORT $LN8@search_2i4
$LN7@search_2i4:
  0010d	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00111	83 c0 05	 add	 eax, 5
  00114	66 89 45 f8	 mov	 WORD PTR _i0$[ebp], ax
$LN8@search_2i4:
  00118	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  0011c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0011f	0f 8d 49 02 00
	00		 jge	 $LN6@search_2i4

; 213  :              
; 214  :              ps0 = dn[i0];                    move16 ();

  00125	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00129	8b 4d 0c	 mov	 ecx, DWORD PTR _dn$[ebp]
  0012c	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00130	66 89 55 b0	 mov	 WORD PTR _ps0$[ebp], dx
  00134	e8 00 00 00 00	 call	 _move16

; 215  :              alp0 = L_mult(rr[i0][i0], _1_4);

  00139	68 00 20 00 00	 push	 8192			; 00002000H
  0013e	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00142	6b c8 50	 imul	 ecx, eax, 80
  00145	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00148	0f bf 55 f8	 movsx	 edx, WORD PTR _i0$[ebp]
  0014c	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _L_mult
  00156	83 c4 08	 add	 esp, 8
  00159	89 85 50 ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 216  :              
; 217  :           /*----------------------------------------------------------------*
; 218  :            * i1 loop: 8 positions.                                          *
; 219  :            *----------------------------------------------------------------*/
; 220  :              
; 221  :              sq = -1;                         move16 ();

  0015f	83 c8 ff	 or	 eax, -1
  00162	66 89 45 98	 mov	 WORD PTR _sq$[ebp], ax
  00166	e8 00 00 00 00	 call	 _move16

; 222  :              alp = 1;                         move16 ();

  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	66 89 85 74 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  00177	e8 00 00 00 00	 call	 _move16

; 223  :              ix = ipos[1];                    move16 ();

  0017c	b8 02 00 00 00	 mov	 eax, 2
  00181	c1 e0 00	 shl	 eax, 0
  00184	66 8b 4c 05 c8	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00189	66 89 4d e0	 mov	 WORD PTR _ix$[ebp], cx
  0018d	e8 00 00 00 00	 call	 _move16

; 224  :              
; 225  :         /*-------------------------------------------------------------------*
; 226  :         *  These index have low complexity address computation because      *
; 227  :         *  they are, in fact, pointers with fixed increment.  For example,  *
; 228  :         *  "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"      *
; 229  :         *  and incremented by "STEP".                                       *
; 230  :         *-------------------------------------------------------------------*/
; 231  :              
; 232  :              move16 (); /* account for ptr. init. (rr[i1]) */

  00192	e8 00 00 00 00	 call	 _move16

; 233  :              move16 (); /* account for ptr. init. (dn[i1]) */

  00197	e8 00 00 00 00	 call	 _move16

; 234  :              move16 (); /* account for ptr. init. (rr[io]) */

  0019c	e8 00 00 00 00	 call	 _move16

; 235  :              for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {

  001a1	b8 02 00 00 00	 mov	 eax, 2
  001a6	c1 e0 00	 shl	 eax, 0
  001a9	66 8b 4c 05 c8	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  001ae	66 89 4d ec	 mov	 WORD PTR _i1$[ebp], cx
  001b2	eb 0b		 jmp	 SHORT $LN5@search_2i4
$LN4@search_2i4:
  001b4	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001b8	83 c0 05	 add	 eax, 5
  001bb	66 89 45 ec	 mov	 WORD PTR _i1$[ebp], ax
$LN5@search_2i4:
  001bf	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001c3	83 f8 28	 cmp	 eax, 40			; 00000028H
  001c6	0f 8d 14 01 00
	00		 jge	 $LN3@search_2i4

; 236  :                 ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */

  001cc	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001d0	8b 4d 0c	 mov	 ecx, DWORD PTR _dn$[ebp]
  001d3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001d7	52		 push	 edx
  001d8	0f b7 45 b0	 movzx	 eax, WORD PTR _ps0$[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _add
  001e2	83 c4 08	 add	 esp, 8
  001e5	66 89 45 a4	 mov	 WORD PTR _ps1$[ebp], ax

; 237  :                 
; 238  :                 /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
; 239  :                    
; 240  :                 alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */

  001e9	68 00 20 00 00	 push	 8192			; 00002000H
  001ee	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001f2	6b c8 50	 imul	 ecx, eax, 80
  001f5	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  001f8	0f bf 55 ec	 movsx	 edx, WORD PTR _i1$[ebp]
  001fc	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00200	50		 push	 eax
  00201	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 _L_mac
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00210	89 85 44 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 241  :                 alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */

  00216	68 00 40 00 00	 push	 16384			; 00004000H
  0021b	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  0021f	6b c8 50	 imul	 ecx, eax, 80
  00222	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00225	0f bf 55 ec	 movsx	 edx, WORD PTR _i1$[ebp]
  00229	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0022d	50		 push	 eax
  0022e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  00234	51		 push	 ecx
  00235	e8 00 00 00 00	 call	 _L_mac
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023d	89 85 44 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 242  :                 
; 243  :                 sq1 = mult(ps1, ps1);

  00243	0f b7 45 a4	 movzx	 eax, WORD PTR _ps1$[ebp]
  00247	50		 push	 eax
  00248	0f b7 4d a4	 movzx	 ecx, WORD PTR _ps1$[ebp]
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 _mult
  00252	83 c4 08	 add	 esp, 8
  00255	66 89 45 8c	 mov	 WORD PTR _sq1$[ebp], ax

; 244  :                 
; 245  :                 alp_16 = round(alp1);

  00259	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _round
  00265	83 c4 04	 add	 esp, 4
  00268	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 246  :                 
; 247  :                 s = L_msu(L_mult(alp, sq1), sq, alp_16);

  0026f	0f b7 85 68 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  00276	50		 push	 eax
  00277	0f b7 4d 98	 movzx	 ecx, WORD PTR _sq$[ebp]
  0027b	51		 push	 ecx
  0027c	0f b7 55 8c	 movzx	 edx, WORD PTR _sq1$[ebp]
  00280	52		 push	 edx
  00281	0f b7 85 74 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  00288	50		 push	 eax
  00289	e8 00 00 00 00	 call	 _L_mult
  0028e	83 c4 08	 add	 esp, 8
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 _L_msu
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029a	89 85 5c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 248  : 
; 249  :                 test ();

  002a0	e8 00 00 00 00	 call	 _test

; 250  :                 if (s > 0) {

  002a5	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  002ac	7e 2d		 jle	 SHORT $LN2@search_2i4

; 251  :                    sq = sq1;                  move16 ();

  002ae	66 8b 45 8c	 mov	 ax, WORD PTR _sq1$[ebp]
  002b2	66 89 45 98	 mov	 WORD PTR _sq$[ebp], ax
  002b6	e8 00 00 00 00	 call	 _move16

; 252  :                    alp = alp_16;              move16 ();

  002bb	66 8b 85 68 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  002c2	66 89 85 74 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  002c9	e8 00 00 00 00	 call	 _move16

; 253  :                    ix = i1;                   move16 ();

  002ce	66 8b 45 ec	 mov	 ax, WORD PTR _i1$[ebp]
  002d2	66 89 45 e0	 mov	 WORD PTR _ix$[ebp], ax
  002d6	e8 00 00 00 00	 call	 _move16
$LN2@search_2i4:

; 254  :                 }
; 255  :              }

  002db	e9 d4 fe ff ff	 jmp	 $LN4@search_2i4
$LN3@search_2i4:

; 256  :              
; 257  :           /*----------------------------------------------------------------*
; 258  :            * memorise codevector if this one is better than the last one.   *
; 259  :            *----------------------------------------------------------------*/
; 260  :              
; 261  :              s = L_msu(L_mult(alpk, sq), psk, alp);

  002e0	0f b7 85 74 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  002e7	50		 push	 eax
  002e8	0f b7 4d bc	 movzx	 ecx, WORD PTR _psk$[ebp]
  002ec	51		 push	 ecx
  002ed	0f b7 55 98	 movzx	 edx, WORD PTR _sq$[ebp]
  002f1	52		 push	 edx
  002f2	0f b7 45 80	 movzx	 eax, WORD PTR _alpk$[ebp]
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 _L_mult
  002fc	83 c4 08	 add	 esp, 8
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 _L_msu
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH
  00308	89 85 5c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 262  :              
; 263  :              test ();

  0030e	e8 00 00 00 00	 call	 _test

; 264  :              if (s > 0) {

  00313	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  0031a	7e 4d		 jle	 SHORT $LN1@search_2i4

; 265  :                 psk = sq;                     move16 ();

  0031c	66 8b 45 98	 mov	 ax, WORD PTR _sq$[ebp]
  00320	66 89 45 bc	 mov	 WORD PTR _psk$[ebp], ax
  00324	e8 00 00 00 00	 call	 _move16

; 266  :                 alpk = alp;                   move16 ();

  00329	66 8b 85 74 ff
	ff ff		 mov	 ax, WORD PTR _alp$[ebp]
  00330	66 89 45 80	 mov	 WORD PTR _alpk$[ebp], ax
  00334	e8 00 00 00 00	 call	 _move16

; 267  :                 codvec[0] = i0;               move16 ();

  00339	b8 02 00 00 00	 mov	 eax, 2
  0033e	6b c8 00	 imul	 ecx, eax, 0
  00341	8b 55 14	 mov	 edx, DWORD PTR _codvec$[ebp]
  00344	66 8b 45 f8	 mov	 ax, WORD PTR _i0$[ebp]
  00348	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  0034c	e8 00 00 00 00	 call	 _move16

; 268  :                 codvec[1] = ix;               move16 ();

  00351	b8 02 00 00 00	 mov	 eax, 2
  00356	c1 e0 00	 shl	 eax, 0
  00359	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0035c	66 8b 55 e0	 mov	 dx, WORD PTR _ix$[ebp]
  00360	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00364	e8 00 00 00 00	 call	 _move16
$LN1@search_2i4:

; 269  :              }
; 270  :           }

  00369	e9 9f fd ff ff	 jmp	 $LN7@search_2i4
$LN6@search_2i4:

; 271  :     }

  0036e	e9 18 fd ff ff	 jmp	 $LN10@search_2i4
$LN15@search_2i4:

; 272  :     
; 273  :     return;
; 274  : }

  00373	52		 push	 edx
  00374	8b cd		 mov	 ecx, ebp
  00376	50		 push	 eax
  00377	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@search_2i4
  0037d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00382	58		 pop	 eax
  00383	5a		 pop	 edx
  00384	5f		 pop	 edi
  00385	5e		 pop	 esi
  00386	5b		 pop	 ebx
  00387	81 c4 8c 01 00
	00		 add	 esp, 396		; 0000018cH
  0038d	3b ec		 cmp	 ebp, esp
  0038f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
$LN19@search_2i4:
  00398	01 00 00 00	 DD	 1
  0039c	00 00 00 00	 DD	 $LN18@search_2i4
$LN18@search_2i4:
  003a0	c8 ff ff ff	 DD	 -56			; ffffffc8H
  003a4	04 00 00 00	 DD	 4
  003a8	00 00 00 00	 DD	 $LN17@search_2i4
$LN17@search_2i4:
  003ac	69		 DB	 105			; 00000069H
  003ad	70		 DB	 112			; 00000070H
  003ae	6f		 DB	 111			; 0000006fH
  003af	73		 DB	 115			; 00000073H
  003b0	00		 DB	 0
_search_2i40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_9pf.c
;	COMDAT _code_2i40_9bits
_TEXT	SEGMENT
_sharp$ = -3520						; size = 2
_index$ = -3508						; size = 2
_i$ = -3496						; size = 2
_rr$ = -3484						; size = 3200
_dn_sign$ = -276					; size = 80
_dn2$ = -188						; size = 80
_dn$ = -100						; size = 80
_codvec$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_subNr$ = 8						; size = 2
_x$ = 12						; size = 4
_h$ = 16						; size = 4
_T0$ = 20						; size = 2
_pitch_sharp$ = 24					; size = 2
_code$ = 28						; size = 4
_y$ = 32						; size = 4
_sign$ = 36						; size = 4
_code_2i40_9bits PROC					; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 0e 00
	00		 sub	 esp, 3716		; 00000e84H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c f1 ff
	ff		 lea	 edi, DWORD PTR [ebp-3716]
  00012	b9 a1 03 00 00	 mov	 ecx, 929		; 000003a1H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 126  :     Word16 codvec[NB_PULSE];
; 127  :     Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
; 128  :     Word16 rr[L_CODE][L_CODE];
; 129  :     Word16 i, index, sharp;
; 130  :     
; 131  :     sharp = shl(pitch_sharp, 1);

  00028	6a 01		 push	 1
  0002a	0f b7 45 18	 movzx	 eax, WORD PTR _pitch_sharp$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _shl
  00034	83 c4 08	 add	 esp, 8
  00037	66 89 85 40 f2
	ff ff		 mov	 WORD PTR _sharp$[ebp], ax

; 132  :     test ();

  0003e	e8 00 00 00 00	 call	 _test

; 133  :     if (sub(T0, L_CODE) < 0)

  00043	6a 28		 push	 40			; 00000028H
  00045	0f b7 45 14	 movzx	 eax, WORD PTR _T0$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _sub
  0004f	83 c4 08	 add	 esp, 8
  00052	0f bf c8	 movsx	 ecx, ax
  00055	85 c9		 test	 ecx, ecx
  00057	0f 8d 80 00 00
	00		 jge	 $LN8@code_2i40_

; 134  :        for (i = T0; i < L_CODE; i++) {

  0005d	66 8b 45 14	 mov	 ax, WORD PTR _T0$[ebp]
  00061	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00068	eb 12		 jmp	 SHORT $LN7@code_2i40_
$LN6@code_2i40_:
  0006a	66 8b 85 58 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@code_2i40_:
  0007c	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00083	83 f8 28	 cmp	 eax, 40			; 00000028H
  00086	7d 55		 jge	 SHORT $LN8@code_2i40_

; 135  :           h[i] = add(h[i], mult(h[i - T0], sharp));         move16 ();

  00088	0f b7 85 40 f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  0008f	50		 push	 eax
  00090	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00097	0f bf 55 14	 movsx	 edx, WORD PTR _T0$[ebp]
  0009b	2b ca		 sub	 ecx, edx
  0009d	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  000a0	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _mult
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b7 d0	 movzx	 edx, ax
  000b0	52		 push	 edx
  000b1	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  000b8	8b 4d 10	 mov	 ecx, DWORD PTR _h$[ebp]
  000bb	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _add
  000c5	83 c4 08	 add	 esp, 8
  000c8	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  000cf	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  000d2	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  000d6	e8 00 00 00 00	 call	 _move16

; 136  :        }

  000db	eb 8d		 jmp	 SHORT $LN6@code_2i40_
$LN8@code_2i40_:

; 137  :     cor_h_x(h, x, dn, 1);

  000dd	6a 01		 push	 1
  000df	8d 45 9c	 lea	 eax, DWORD PTR _dn$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _cor_h_x
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 138  :     set_sign(dn, dn_sign, dn2, 8); /* dn2[] not used in this codebook search */

  000f3	6a 08		 push	 8
  000f5	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _dn2$[ebp]
  000fb	50		 push	 eax
  000fc	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00102	51		 push	 ecx
  00103	8d 55 9c	 lea	 edx, DWORD PTR _dn$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _set_sign
  0010c	83 c4 10	 add	 esp, 16			; 00000010H

; 139  :     cor_h(h, dn_sign, rr);

  0010f	8d 85 64 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00115	50		 push	 eax
  00116	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _cor_h
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  :     search_2i40(subNr, dn, rr, codvec);

  00129	8d 45 f4	 lea	 eax, DWORD PTR _codvec$[ebp]
  0012c	50		 push	 eax
  0012d	8d 8d 64 f2 ff
	ff		 lea	 ecx, DWORD PTR _rr$[ebp]
  00133	51		 push	 ecx
  00134	8d 55 9c	 lea	 edx, DWORD PTR _dn$[ebp]
  00137	52		 push	 edx
  00138	0f b7 45 08	 movzx	 eax, WORD PTR _subNr$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _search_2i40
  00142	83 c4 10	 add	 esp, 16			; 00000010H

; 141  :                                     move16 (); /* function result */

  00145	e8 00 00 00 00	 call	 _move16

; 142  :     index = build_code(subNr, codvec, dn_sign, code, h, y, sign);

  0014a	8b 45 24	 mov	 eax, DWORD PTR _sign$[ebp]
  0014d	50		 push	 eax
  0014e	8b 4d 20	 mov	 ecx, DWORD PTR _y$[ebp]
  00151	51		 push	 ecx
  00152	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  00155	52		 push	 edx
  00156	8b 45 1c	 mov	 eax, DWORD PTR _code$[ebp]
  00159	50		 push	 eax
  0015a	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00160	51		 push	 ecx
  00161	8d 55 f4	 lea	 edx, DWORD PTR _codvec$[ebp]
  00164	52		 push	 edx
  00165	0f b7 45 08	 movzx	 eax, WORD PTR _subNr$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _build_code
  0016f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00172	66 89 85 4c f2
	ff ff		 mov	 WORD PTR _index$[ebp], ax

; 143  :     
; 144  :   /*-----------------------------------------------------------------*
; 145  :    * Compute innovation vector gain.                                 *
; 146  :    * Include fixed-gain pitch contribution into code[].              *
; 147  :    *-----------------------------------------------------------------*/
; 148  :     
; 149  :     test ();

  00179	e8 00 00 00 00	 call	 _test

; 150  :     if (sub(T0, L_CODE) < 0)

  0017e	6a 28		 push	 40			; 00000028H
  00180	0f b7 45 14	 movzx	 eax, WORD PTR _T0$[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _sub
  0018a	83 c4 08	 add	 esp, 8
  0018d	0f bf c8	 movsx	 ecx, ax
  00190	85 c9		 test	 ecx, ecx
  00192	0f 8d 80 00 00
	00		 jge	 $LN4@code_2i40_

; 151  :        for (i = T0; i < L_CODE; i++) {

  00198	66 8b 45 14	 mov	 ax, WORD PTR _T0$[ebp]
  0019c	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  001a3	eb 12		 jmp	 SHORT $LN3@code_2i40_
$LN2@code_2i40_:
  001a5	66 8b 85 58 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  001ac	66 83 c0 01	 add	 ax, 1
  001b0	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN3@code_2i40_:
  001b7	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001be	83 f8 28	 cmp	 eax, 40			; 00000028H
  001c1	7d 55		 jge	 SHORT $LN4@code_2i40_

; 152  :           code[i] = add(code[i], mult(code[i - T0], sharp));  move16 ();

  001c3	0f b7 85 40 f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  001ca	50		 push	 eax
  001cb	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  001d2	0f bf 55 14	 movsx	 edx, WORD PTR _T0$[ebp]
  001d6	2b ca		 sub	 ecx, edx
  001d8	8b 45 1c	 mov	 eax, DWORD PTR _code$[ebp]
  001db	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  001df	51		 push	 ecx
  001e0	e8 00 00 00 00	 call	 _mult
  001e5	83 c4 08	 add	 esp, 8
  001e8	0f b7 d0	 movzx	 edx, ax
  001eb	52		 push	 edx
  001ec	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001f3	8b 4d 1c	 mov	 ecx, DWORD PTR _code$[ebp]
  001f6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001fa	52		 push	 edx
  001fb	e8 00 00 00 00	 call	 _add
  00200	83 c4 08	 add	 esp, 8
  00203	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  0020a	8b 55 1c	 mov	 edx, DWORD PTR _code$[ebp]
  0020d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00211	e8 00 00 00 00	 call	 _move16

; 153  :        }

  00216	eb 8d		 jmp	 SHORT $LN2@code_2i40_
$LN4@code_2i40_:

; 154  :     return index;

  00218	66 8b 85 4c f2
	ff ff		 mov	 ax, WORD PTR _index$[ebp]

; 155  : }

  0021f	52		 push	 edx
  00220	8b cd		 mov	 ecx, ebp
  00222	50		 push	 eax
  00223	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@code_2i40_
  00229	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022e	58		 pop	 eax
  0022f	5a		 pop	 edx
  00230	5f		 pop	 edi
  00231	5e		 pop	 esi
  00232	5b		 pop	 ebx
  00233	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00236	33 cd		 xor	 ecx, ebp
  00238	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023d	81 c4 84 0e 00
	00		 add	 esp, 3716		; 00000e84H
  00243	3b ec		 cmp	 ebp, esp
  00245	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
  0024e	8b ff		 npad	 2
$LN17@code_2i40_:
  00250	05 00 00 00	 DD	 5
  00254	00 00 00 00	 DD	 $LN16@code_2i40_
$LN16@code_2i40_:
  00258	f4 ff ff ff	 DD	 -12			; fffffff4H
  0025c	04 00 00 00	 DD	 4
  00260	00 00 00 00	 DD	 $LN11@code_2i40_
  00264	9c ff ff ff	 DD	 -100			; ffffff9cH
  00268	50 00 00 00	 DD	 80			; 00000050H
  0026c	00 00 00 00	 DD	 $LN12@code_2i40_
  00270	44 ff ff ff	 DD	 -188			; ffffff44H
  00274	50 00 00 00	 DD	 80			; 00000050H
  00278	00 00 00 00	 DD	 $LN13@code_2i40_
  0027c	ec fe ff ff	 DD	 -276			; fffffeecH
  00280	50 00 00 00	 DD	 80			; 00000050H
  00284	00 00 00 00	 DD	 $LN14@code_2i40_
  00288	64 f2 ff ff	 DD	 -3484			; fffff264H
  0028c	80 0c 00 00	 DD	 3200			; 00000c80H
  00290	00 00 00 00	 DD	 $LN15@code_2i40_
$LN15@code_2i40_:
  00294	72		 DB	 114			; 00000072H
  00295	72		 DB	 114			; 00000072H
  00296	00		 DB	 0
$LN14@code_2i40_:
  00297	64		 DB	 100			; 00000064H
  00298	6e		 DB	 110			; 0000006eH
  00299	5f		 DB	 95			; 0000005fH
  0029a	73		 DB	 115			; 00000073H
  0029b	69		 DB	 105			; 00000069H
  0029c	67		 DB	 103			; 00000067H
  0029d	6e		 DB	 110			; 0000006eH
  0029e	00		 DB	 0
$LN13@code_2i40_:
  0029f	64		 DB	 100			; 00000064H
  002a0	6e		 DB	 110			; 0000006eH
  002a1	32		 DB	 50			; 00000032H
  002a2	00		 DB	 0
$LN12@code_2i40_:
  002a3	64		 DB	 100			; 00000064H
  002a4	6e		 DB	 110			; 0000006eH
  002a5	00		 DB	 0
$LN11@code_2i40_:
  002a6	63		 DB	 99			; 00000063H
  002a7	6f		 DB	 111			; 0000006fH
  002a8	64		 DB	 100			; 00000064H
  002a9	76		 DB	 118			; 00000076H
  002aa	65		 DB	 101			; 00000065H
  002ab	63		 DB	 99			; 00000063H
  002ac	00		 DB	 0
_code_2i40_9bits ENDP
_TEXT	ENDS
END
