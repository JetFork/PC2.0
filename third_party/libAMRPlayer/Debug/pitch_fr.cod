; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\pitch_fr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pitch_fr_id
CONST	SEGMENT
_pitch_fr_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_mode_dep_parm DW 054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	05H
	DW	0aH
	DW	05H
	DW	09H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	05H
	DW	0aH
	DW	05H
	DW	09H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	09H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	09H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	09H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	03H
	DW	06H
	DW	0aH
	DW	013H
	DW	014H
	DW	054H
	DW	01H
	DW	0fffeH
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	09H
	DW	014H
	DW	05eH
	DW	00H
	DW	0fffdH
	DW	03H
	DW	03H
	DW	06H
	DW	05H
	DW	09H
	DW	012H
	ORG $+18
CONST	ENDS
PUBLIC	_Pitch_fr_init
PUBLIC	_Pitch_fr_reset
PUBLIC	_Pitch_fr_exit
PUBLIC	_Pitch_fr
PUBLIC	??_C@_0CC@HOAPGGEM@Pitch_fr_init?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CP@FLPNEKMA@Pitch_fr_init?3?5can?5not?5malloc?5st@ ; `string'
PUBLIC	??_C@_0CD@OBLKDDLG@Pitch_fr_reset?3?5invalid?5paramete@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_Extract:PROC
EXTRN	_Mpy_32:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Enc_lag3:PROC
EXTRN	_Enc_lag6:PROC
EXTRN	_Interpol_3or6:PROC
EXTRN	_Inv_sqrt:PROC
EXTRN	_Convolve:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CD@OBLKDDLG@Pitch_fr_reset?3?5invalid?5paramete@
CONST	SEGMENT
??_C@_0CD@OBLKDDLG@Pitch_fr_reset?3?5invalid?5paramete@ DB 'Pitch_fr_rese'
	DB	't: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FLPNEKMA@Pitch_fr_init?3?5can?5not?5malloc?5st@
CONST	SEGMENT
??_C@_0CP@FLPNEKMA@Pitch_fr_init?3?5can?5not?5malloc?5st@ DB 'Pitch_fr_in'
	DB	'it: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HOAPGGEM@Pitch_fr_init?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@HOAPGGEM@Pitch_fr_init?3?5invalid?5parameter@ DB 'Pitch_fr_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _getRange
_TEXT	SEGMENT
_T0$ = 8						; size = 2
_delta_low$ = 12					; size = 2
_delta_range$ = 16					; size = 2
_pitmin$ = 20						; size = 2
_pitmax$ = 24						; size = 2
_t0_min$ = 28						; size = 4
_t0_max$ = 32						; size = 4
_getRange PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 269  :     *t0_min = sub(T0, delta_low);

  0001e	0f b7 45 0c	 movzx	 eax, WORD PTR _delta_low$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 08	 movzx	 ecx, WORD PTR _T0$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _sub
  0002d	83 c4 08	 add	 esp, 8
  00030	8b 55 1c	 mov	 edx, DWORD PTR _t0_min$[ebp]
  00033	66 89 02	 mov	 WORD PTR [edx], ax

; 270  :     test ();

  00036	e8 00 00 00 00	 call	 _test

; 271  :     if (sub(*t0_min, pitmin) < 0) {

  0003b	0f b7 45 14	 movzx	 eax, WORD PTR _pitmin$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 1c	 mov	 ecx, DWORD PTR _t0_min$[ebp]
  00043	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _sub
  0004c	83 c4 08	 add	 esp, 8
  0004f	98		 cwde
  00050	85 c0		 test	 eax, eax
  00052	7d 0f		 jge	 SHORT $LN2@getRange

; 272  :         *t0_min = pitmin;                                  move16();

  00054	8b 45 1c	 mov	 eax, DWORD PTR _t0_min$[ebp]
  00057	66 8b 4d 14	 mov	 cx, WORD PTR _pitmin$[ebp]
  0005b	66 89 08	 mov	 WORD PTR [eax], cx
  0005e	e8 00 00 00 00	 call	 _move16
$LN2@getRange:

; 273  :     }
; 274  :     *t0_max = add(*t0_min, delta_range);

  00063	0f b7 45 10	 movzx	 eax, WORD PTR _delta_range$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 1c	 mov	 ecx, DWORD PTR _t0_min$[ebp]
  0006b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _add
  00074	83 c4 08	 add	 esp, 8
  00077	8b 4d 20	 mov	 ecx, DWORD PTR _t0_max$[ebp]
  0007a	66 89 01	 mov	 WORD PTR [ecx], ax

; 275  :     test ();

  0007d	e8 00 00 00 00	 call	 _test

; 276  :     if (sub(*t0_max, pitmax) > 0) {

  00082	0f b7 45 18	 movzx	 eax, WORD PTR _pitmax$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 20	 mov	 ecx, DWORD PTR _t0_max$[ebp]
  0008a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _sub
  00093	83 c4 08	 add	 esp, 8
  00096	98		 cwde
  00097	85 c0		 test	 eax, eax
  00099	7e 29		 jle	 SHORT $LN3@getRange

; 277  :         *t0_max = pitmax;                                  move16();

  0009b	8b 45 20	 mov	 eax, DWORD PTR _t0_max$[ebp]
  0009e	66 8b 4d 18	 mov	 cx, WORD PTR _pitmax$[ebp]
  000a2	66 89 08	 mov	 WORD PTR [eax], cx
  000a5	e8 00 00 00 00	 call	 _move16

; 278  :         *t0_min = sub(*t0_max, delta_range);

  000aa	0f b7 45 10	 movzx	 eax, WORD PTR _delta_range$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d 20	 mov	 ecx, DWORD PTR _t0_max$[ebp]
  000b2	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _sub
  000bb	83 c4 08	 add	 esp, 8
  000be	8b 4d 1c	 mov	 ecx, DWORD PTR _t0_min$[ebp]
  000c1	66 89 01	 mov	 WORD PTR [ecx], ax
$LN3@getRange:

; 279  :     }
; 280  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000cd	3b ec		 cmp	 ebp, esp
  000cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
_getRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _searchFrac
_TEXT	SEGMENT
_corr_int$ = -32					; size = 2
_max$ = -20						; size = 2
_i$ = -8						; size = 2
_lag$ = 8						; size = 4
_frac$ = 12						; size = 4
_last_frac$ = 16					; size = 2
_corr$ = 20						; size = 4
_flag3$ = 24						; size = 2
_searchFrac PROC					; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 203  :     Word16 i;
; 204  :     Word16 max;
; 205  :     Word16 corr_int;
; 206  : 
; 207  :     /* Test the fractions around T0 and choose the one which maximizes   */
; 208  :     /* the interpolated normalized correlation.                          */
; 209  : 
; 210  :     max = Interpol_3or6 (&corr[*lag], *frac, flag3); move16 (); /* function result */

  0001e	0f b7 45 18	 movzx	 eax, WORD PTR _flag3$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _frac$[ebp]
  00026	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _lag$[ebp]
  0002d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00030	8b 55 14	 mov	 edx, DWORD PTR _corr$[ebp]
  00033	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _Interpol_3or6
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	66 89 45 ec	 mov	 WORD PTR _max$[ebp], ax
  00043	e8 00 00 00 00	 call	 _move16

; 211  : 
; 212  :     for (i = add (*frac, 1); i <= last_frac; i++) {

  00048	6a 01		 push	 1
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _frac$[ebp]
  0004d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _add
  00056	83 c4 08	 add	 esp, 8
  00059	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0005d	eb 0c		 jmp	 SHORT $LN9@searchFrac
$LN8@searchFrac:
  0005f	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00063	66 83 c0 01	 add	 ax, 1
  00067	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN9@searchFrac:
  0006b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0006f	0f bf 4d 10	 movsx	 ecx, WORD PTR _last_frac$[ebp]
  00073	3b c1		 cmp	 eax, ecx
  00075	7f 64		 jg	 SHORT $LN7@searchFrac

; 213  :         corr_int = Interpol_3or6 (&corr[*lag], i, flag3);

  00077	0f b7 45 18	 movzx	 eax, WORD PTR _flag3$[ebp]
  0007b	50		 push	 eax
  0007c	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _lag$[ebp]
  00084	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00087	8b 4d 14	 mov	 ecx, DWORD PTR _corr$[ebp]
  0008a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _Interpol_3or6
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	66 89 45 e0	 mov	 WORD PTR _corr_int$[ebp], ax

; 214  :         move16 ();

  0009a	e8 00 00 00 00	 call	 _move16

; 215  :         test ();

  0009f	e8 00 00 00 00	 call	 _test

; 216  :         if (sub (corr_int, max) > 0) {

  000a4	0f b7 45 ec	 movzx	 eax, WORD PTR _max$[ebp]
  000a8	50		 push	 eax
  000a9	0f b7 4d e0	 movzx	 ecx, WORD PTR _corr_int$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _sub
  000b3	83 c4 08	 add	 esp, 8
  000b6	0f bf d0	 movsx	 edx, ax
  000b9	85 d2		 test	 edx, edx
  000bb	7e 1c		 jle	 SHORT $LN6@searchFrac

; 217  :             max = corr_int;                       move16 ();

  000bd	66 8b 45 e0	 mov	 ax, WORD PTR _corr_int$[ebp]
  000c1	66 89 45 ec	 mov	 WORD PTR _max$[ebp], ax
  000c5	e8 00 00 00 00	 call	 _move16

; 218  :             *frac = i;                            move16 ();

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _frac$[ebp]
  000cd	66 8b 4d f8	 mov	 cx, WORD PTR _i$[ebp]
  000d1	66 89 08	 mov	 WORD PTR [eax], cx
  000d4	e8 00 00 00 00	 call	 _move16
$LN6@searchFrac:

; 219  :         }
; 220  :     }

  000d9	eb 84		 jmp	 SHORT $LN8@searchFrac
$LN7@searchFrac:

; 221  : 
; 222  :     test();

  000db	e8 00 00 00 00	 call	 _test

; 223  :     if (flag3 == 0) {

  000e0	0f bf 45 18	 movsx	 eax, WORD PTR _flag3$[ebp]
  000e4	85 c0		 test	 eax, eax
  000e6	75 49		 jne	 SHORT $LN5@searchFrac

; 224  :         /* Limit the fraction value in the interval [-2,-1,0,1,2,3] */
; 225  : 
; 226  :         test ();

  000e8	e8 00 00 00 00	 call	 _test

; 227  :         if (sub (*frac, -3) == 0) {

  000ed	6a fd		 push	 -3			; fffffffdH
  000ef	8b 45 0c	 mov	 eax, DWORD PTR _frac$[ebp]
  000f2	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000f5	51		 push	 ecx
  000f6	e8 00 00 00 00	 call	 _sub
  000fb	83 c4 08	 add	 esp, 8
  000fe	0f bf d0	 movsx	 edx, ax
  00101	85 d2		 test	 edx, edx
  00103	75 27		 jne	 SHORT $LN4@searchFrac

; 228  :             *frac = 3;                            move16 ();

  00105	b8 03 00 00 00	 mov	 eax, 3
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _frac$[ebp]
  0010d	66 89 01	 mov	 WORD PTR [ecx], ax
  00110	e8 00 00 00 00	 call	 _move16

; 229  :             *lag = sub (*lag, 1);

  00115	6a 01		 push	 1
  00117	8b 45 08	 mov	 eax, DWORD PTR _lag$[ebp]
  0011a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 _sub
  00123	83 c4 08	 add	 esp, 8
  00126	8b 55 08	 mov	 edx, DWORD PTR _lag$[ebp]
  00129	66 89 02	 mov	 WORD PTR [edx], ax
$LN4@searchFrac:

; 230  :         }
; 231  :     }
; 232  :     else {

  0012c	e9 86 00 00 00	 jmp	 $LN10@searchFrac
$LN5@searchFrac:

; 233  :         /* limit the fraction value between -1 and 1 */
; 234  : 
; 235  :         test ();

  00131	e8 00 00 00 00	 call	 _test

; 236  :         if (sub (*frac, -2) == 0) {

  00136	6a fe		 push	 -2			; fffffffeH
  00138	8b 45 0c	 mov	 eax, DWORD PTR _frac$[ebp]
  0013b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 _sub
  00144	83 c4 08	 add	 esp, 8
  00147	0f bf d0	 movsx	 edx, ax
  0014a	85 d2		 test	 edx, edx
  0014c	75 27		 jne	 SHORT $LN2@searchFrac

; 237  :             *frac = 1;                            move16 ();

  0014e	b8 01 00 00 00	 mov	 eax, 1
  00153	8b 4d 0c	 mov	 ecx, DWORD PTR _frac$[ebp]
  00156	66 89 01	 mov	 WORD PTR [ecx], ax
  00159	e8 00 00 00 00	 call	 _move16

; 238  :             *lag = sub (*lag, 1);

  0015e	6a 01		 push	 1
  00160	8b 45 08	 mov	 eax, DWORD PTR _lag$[ebp]
  00163	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00166	51		 push	 ecx
  00167	e8 00 00 00 00	 call	 _sub
  0016c	83 c4 08	 add	 esp, 8
  0016f	8b 55 08	 mov	 edx, DWORD PTR _lag$[ebp]
  00172	66 89 02	 mov	 WORD PTR [edx], ax
$LN2@searchFrac:

; 239  :         }
; 240  :         test ();

  00175	e8 00 00 00 00	 call	 _test

; 241  :         if (sub (*frac, 2) == 0) {

  0017a	6a 02		 push	 2
  0017c	8b 45 0c	 mov	 eax, DWORD PTR _frac$[ebp]
  0017f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _sub
  00188	83 c4 08	 add	 esp, 8
  0018b	0f bf d0	 movsx	 edx, ax
  0018e	85 d2		 test	 edx, edx
  00190	75 25		 jne	 SHORT $LN10@searchFrac

; 242  :             *frac = -1;                           move16 ();

  00192	83 c8 ff	 or	 eax, -1
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR _frac$[ebp]
  00198	66 89 01	 mov	 WORD PTR [ecx], ax
  0019b	e8 00 00 00 00	 call	 _move16

; 243  :             *lag = add (*lag, 1);

  001a0	6a 01		 push	 1
  001a2	8b 45 08	 mov	 eax, DWORD PTR _lag$[ebp]
  001a5	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 _add
  001ae	83 c4 08	 add	 esp, 8
  001b1	8b 55 08	 mov	 edx, DWORD PTR _lag$[ebp]
  001b4	66 89 02	 mov	 WORD PTR [edx], ax
$LN10@searchFrac:

; 244  :         }
; 245  :     }
; 246  : }

  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx
  001ba	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001c0	3b ec		 cmp	 ebp, esp
  001c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
_searchFrac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _Norm_Corr
_TEXT	SEGMENT
_scaled_excf$ = -308					; size = 80
_s_excf$ = -220						; size = 4
_h_fac$ = -208						; size = 2
_scaling$ = -196					; size = 2
_excf$ = -184						; size = 80
_s$ = -96						; size = 4
_norm_l$ = -84						; size = 2
_norm_h$ = -72						; size = 2
_corr_l$ = -60						; size = 2
_corr_h$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_exc$ = 8						; size = 4
_xn$ = 12						; size = 4
_h$ = 16						; size = 4
_L_subfr$ = 20						; size = 2
_t_min$ = 24						; size = 2
_t_max$ = 28						; size = 2
_corr_norm$ = 32					; size = 4
_Norm_Corr PROC						; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 01 00
	00		 sub	 esp, 504		; 000001f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-504]
  00012	b9 7e 00 00 00	 mov	 ecx, 126		; 0000007eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 96   :     Word16 i, j, k;
; 97   :     Word16 corr_h, corr_l, norm_h, norm_l;
; 98   :     Word32 s;
; 99   : 
; 100  :     /* Usally dynamic allocation of (L_subfr) */
; 101  :     Word16 excf[L_SUBFR];
; 102  :     Word16 scaling, h_fac, *s_excf, scaled_excf[L_SUBFR];
; 103  : 
; 104  :     k = -t_min;                                move16 ();

  00028	0f bf 45 18	 movsx	 eax, WORD PTR _t_min$[ebp]
  0002c	f7 d8		 neg	 eax
  0002e	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  00032	e8 00 00 00 00	 call	 _move16

; 105  : 
; 106  :     /* compute the filtered excitation for the first delay t_min */
; 107  : 
; 108  :     Convolve (&exc[k], h, excf, L_subfr);

  00037	0f b7 45 14	 movzx	 eax, WORD PTR _L_subfr$[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _excf$[ebp]
  00042	51		 push	 ecx
  00043	8b 55 10	 mov	 edx, DWORD PTR _h$[ebp]
  00046	52		 push	 edx
  00047	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _exc$[ebp]
  0004e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _Convolve
  00057	83 c4 10	 add	 esp, 16			; 00000010H

; 109  : 
; 110  :     /* scale "excf[]" to avoid overflow */
; 111  : 
; 112  :     for (j = 0; j < L_subfr; j++) {

  0005a	33 c0		 xor	 eax, eax
  0005c	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00060	eb 0c		 jmp	 SHORT $LN21@Norm_Corr
$LN20@Norm_Corr:
  00062	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00066	66 83 c0 01	 add	 ax, 1
  0006a	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN21@Norm_Corr:
  0006e	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00072	0f bf 4d 14	 movsx	 ecx, WORD PTR _L_subfr$[ebp]
  00076	3b c1		 cmp	 eax, ecx
  00078	7d 2a		 jge	 SHORT $LN19@Norm_Corr

; 113  :         scaled_excf[j] = shr (excf[j], 2);     move16 ();

  0007a	6a 02		 push	 2
  0007c	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00080	0f b7 8c 45 48
	ff ff ff	 movzx	 ecx, WORD PTR _excf$[ebp+eax*2]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 _shr
  0008e	83 c4 08	 add	 esp, 8
  00091	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  00095	66 89 84 55 cc
	fe ff ff	 mov	 WORD PTR _scaled_excf$[ebp+edx*2], ax
  0009d	e8 00 00 00 00	 call	 _move16

; 114  :     }

  000a2	eb be		 jmp	 SHORT $LN20@Norm_Corr
$LN19@Norm_Corr:

; 115  : 
; 116  :     /* Compute 1/sqrt(energy of excf[]) */
; 117  : 
; 118  :     s = 0;                                     move32 ();

  000a4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  000ab	e8 00 00 00 00	 call	 _move32

; 119  :     for (j = 0; j < L_subfr; j++) {

  000b0	33 c0		 xor	 eax, eax
  000b2	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  000b6	eb 0c		 jmp	 SHORT $LN18@Norm_Corr
$LN17@Norm_Corr:
  000b8	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  000bc	66 83 c0 01	 add	 ax, 1
  000c0	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN18@Norm_Corr:
  000c4	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000c8	0f bf 4d 14	 movsx	 ecx, WORD PTR _L_subfr$[ebp]
  000cc	3b c1		 cmp	 eax, ecx
  000ce	7d 2b		 jge	 SHORT $LN16@Norm_Corr

; 120  :         s = L_mac (s, excf[j], excf[j]);

  000d0	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000d4	0f b7 8c 45 48
	ff ff ff	 movzx	 ecx, WORD PTR _excf$[ebp+eax*2]
  000dc	51		 push	 ecx
  000dd	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  000e1	0f b7 84 55 48
	ff ff ff	 movzx	 eax, WORD PTR _excf$[ebp+edx*2]
  000e9	50		 push	 eax
  000ea	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _L_mac
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 121  :     }

  000f9	eb bd		 jmp	 SHORT $LN17@Norm_Corr
$LN16@Norm_Corr:

; 122  :     test ();

  000fb	e8 00 00 00 00	 call	 _test

; 123  :     if (L_sub (s, 67108864L) <= 0) {            /* if (s <= 2^26) */

  00100	68 00 00 00 04	 push	 67108864		; 04000000H
  00105	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _L_sub
  0010e	83 c4 08	 add	 esp, 8
  00111	85 c0		 test	 eax, eax
  00113	7f 32		 jg	 SHORT $LN15@Norm_Corr

; 124  :         s_excf = excf;                         move16 ();

  00115	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _excf$[ebp]
  0011b	89 85 24 ff ff
	ff		 mov	 DWORD PTR _s_excf$[ebp], eax
  00121	e8 00 00 00 00	 call	 _move16

; 125  :         h_fac = 15 - 12;                       move16 ();

  00126	b8 03 00 00 00	 mov	 eax, 3
  0012b	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _h_fac$[ebp], ax
  00132	e8 00 00 00 00	 call	 _move16

; 126  :         scaling = 0;                           move16 ();

  00137	33 c0		 xor	 eax, eax
  00139	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _scaling$[ebp], ax
  00140	e8 00 00 00 00	 call	 _move16

; 127  :     }
; 128  :     else {

  00145	eb 33		 jmp	 SHORT $LN14@Norm_Corr
$LN15@Norm_Corr:

; 129  :         /* "excf[]" is divided by 2 */
; 130  :         s_excf = scaled_excf;                  move16 ();

  00147	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _scaled_excf$[ebp]
  0014d	89 85 24 ff ff
	ff		 mov	 DWORD PTR _s_excf$[ebp], eax
  00153	e8 00 00 00 00	 call	 _move16

; 131  :         h_fac = 15 - 12 - 2;                   move16 ();

  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _h_fac$[ebp], ax
  00164	e8 00 00 00 00	 call	 _move16

; 132  :         scaling = 2;                           move16 ();

  00169	b8 02 00 00 00	 mov	 eax, 2
  0016e	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _scaling$[ebp], ax
  00175	e8 00 00 00 00	 call	 _move16
$LN14@Norm_Corr:

; 133  :     }
; 134  : 
; 135  :     /* loop for every possible period */
; 136  : 
; 137  :     for (i = t_min; i <= t_max; i++) {

  0017a	66 8b 45 18	 mov	 ax, WORD PTR _t_min$[ebp]
  0017e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00182	eb 0c		 jmp	 SHORT $LN13@Norm_Corr
$LN12@Norm_Corr:
  00184	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00188	66 83 c0 01	 add	 ax, 1
  0018c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN13@Norm_Corr:
  00190	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00194	0f bf 4d 1c	 movsx	 ecx, WORD PTR _t_max$[ebp]
  00198	3b c1		 cmp	 eax, ecx
  0019a	0f 8f 31 02 00
	00		 jg	 $LN22@Norm_Corr

; 138  :         /* Compute 1/sqrt(energy of excf[]) */
; 139  :         
; 140  :         s = 0;                                 move32 ();

  001a0	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  001a7	e8 00 00 00 00	 call	 _move32

; 141  :         for (j = 0; j < L_subfr; j++) {

  001ac	33 c0		 xor	 eax, eax
  001ae	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  001b2	eb 0c		 jmp	 SHORT $LN10@Norm_Corr
$LN9@Norm_Corr:
  001b4	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  001b8	66 83 c0 01	 add	 ax, 1
  001bc	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN10@Norm_Corr:
  001c0	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  001c4	0f bf 4d 14	 movsx	 ecx, WORD PTR _L_subfr$[ebp]
  001c8	3b c1		 cmp	 eax, ecx
  001ca	7d 2f		 jge	 SHORT $LN8@Norm_Corr

; 142  :             s = L_mac (s, s_excf[j], s_excf[j]);

  001cc	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  001d0	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  001d6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001da	52		 push	 edx
  001db	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  001df	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  001e5	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001e9	52		 push	 edx
  001ea	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _L_mac
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f6	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 143  :         }

  001f9	eb b9		 jmp	 SHORT $LN9@Norm_Corr
$LN8@Norm_Corr:

; 144  :         
; 145  :         s = Inv_sqrt (s);

  001fb	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _Inv_sqrt
  00204	83 c4 04	 add	 esp, 4
  00207	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 146  :         L_Extract (s, &norm_h, &norm_l);

  0020a	8d 45 ac	 lea	 eax, DWORD PTR _norm_l$[ebp]
  0020d	50		 push	 eax
  0020e	8d 4d b8	 lea	 ecx, DWORD PTR _norm_h$[ebp]
  00211	51		 push	 ecx
  00212	8b 55 a0	 mov	 edx, DWORD PTR _s$[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 _L_Extract
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  :         
; 148  :         /* Compute correlation between xn[] and excf[] */
; 149  :         
; 150  :         s = 0;                                  move32 ();

  0021e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  00225	e8 00 00 00 00	 call	 _move32

; 151  :         for (j = 0; j < L_subfr; j++) {

  0022a	33 c0		 xor	 eax, eax
  0022c	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00230	eb 0c		 jmp	 SHORT $LN7@Norm_Corr
$LN6@Norm_Corr:
  00232	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00236	66 83 c0 01	 add	 ax, 1
  0023a	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN7@Norm_Corr:
  0023e	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00242	0f bf 4d 14	 movsx	 ecx, WORD PTR _L_subfr$[ebp]
  00246	3b c1		 cmp	 eax, ecx
  00248	7d 2c		 jge	 SHORT $LN5@Norm_Corr

; 152  :             s = L_mac (s, xn[j], s_excf[j]);

  0024a	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0024e	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  00254	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00258	52		 push	 edx
  00259	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0025d	8b 4d 0c	 mov	 ecx, DWORD PTR _xn$[ebp]
  00260	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00264	52		 push	 edx
  00265	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00268	50		 push	 eax
  00269	e8 00 00 00 00	 call	 _L_mac
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00271	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 153  :         }

  00274	eb bc		 jmp	 SHORT $LN6@Norm_Corr
$LN5@Norm_Corr:

; 154  :         L_Extract (s, &corr_h, &corr_l);

  00276	8d 45 c4	 lea	 eax, DWORD PTR _corr_l$[ebp]
  00279	50		 push	 eax
  0027a	8d 4d d0	 lea	 ecx, DWORD PTR _corr_h$[ebp]
  0027d	51		 push	 ecx
  0027e	8b 55 a0	 mov	 edx, DWORD PTR _s$[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 _L_Extract
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 
; 156  :         /* Normalize correlation = correlation * (1/sqrt(energy)) */
; 157  :         
; 158  :         s = Mpy_32 (corr_h, corr_l, norm_h, norm_l);

  0028a	0f b7 45 ac	 movzx	 eax, WORD PTR _norm_l$[ebp]
  0028e	50		 push	 eax
  0028f	0f b7 4d b8	 movzx	 ecx, WORD PTR _norm_h$[ebp]
  00293	51		 push	 ecx
  00294	0f b7 55 c4	 movzx	 edx, WORD PTR _corr_l$[ebp]
  00298	52		 push	 edx
  00299	0f b7 45 d0	 movzx	 eax, WORD PTR _corr_h$[ebp]
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 _Mpy_32
  002a3	83 c4 10	 add	 esp, 16			; 00000010H
  002a6	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 159  :         
; 160  :         corr_norm[i] = extract_h (L_shl (s, 16));

  002a9	6a 10		 push	 16			; 00000010H
  002ab	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 _L_shl
  002b4	83 c4 08	 add	 esp, 8
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 _extract_h
  002bd	83 c4 04	 add	 esp, 4
  002c0	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  002c4	8b 55 20	 mov	 edx, DWORD PTR _corr_norm$[ebp]
  002c7	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 161  :         move16 ();

  002cb	e8 00 00 00 00	 call	 _move16

; 162  : 
; 163  :             /* modify the filtered excitation excf[] for the next iteration */
; 164  :         
; 165  :         test ();

  002d0	e8 00 00 00 00	 call	 _test

; 166  :         if (sub (i, t_max) != 0) {

  002d5	0f b7 45 1c	 movzx	 eax, WORD PTR _t_max$[ebp]
  002d9	50		 push	 eax
  002da	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  002de	51		 push	 ecx
  002df	e8 00 00 00 00	 call	 _sub
  002e4	83 c4 08	 add	 esp, 8
  002e7	0f bf d0	 movsx	 edx, ax
  002ea	85 d2		 test	 edx, edx
  002ec	0f 84 da 00 00
	00		 je	 $LN4@Norm_Corr

; 167  :             k--;

  002f2	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  002f6	66 83 e8 01	 sub	 ax, 1
  002fa	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax

; 168  :             for (j = L_subfr - 1; j > 0; j--) {

  002fe	0f bf 45 14	 movsx	 eax, WORD PTR _L_subfr$[ebp]
  00302	83 e8 01	 sub	 eax, 1
  00305	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00309	eb 0c		 jmp	 SHORT $LN3@Norm_Corr
$LN2@Norm_Corr:
  0030b	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  0030f	66 83 e8 01	 sub	 ax, 1
  00313	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN3@Norm_Corr:
  00317	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0031b	85 c0		 test	 eax, eax
  0031d	7e 7a		 jle	 SHORT $LN1@Norm_Corr

; 169  :                 s = L_mult (exc[k], h[j]);

  0031f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00323	8b 4d 10	 mov	 ecx, DWORD PTR _h$[ebp]
  00326	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0032a	52		 push	 edx
  0032b	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  0032f	8b 4d 08	 mov	 ecx, DWORD PTR _exc$[ebp]
  00332	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00336	52		 push	 edx
  00337	e8 00 00 00 00	 call	 _L_mult
  0033c	83 c4 08	 add	 esp, 8
  0033f	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 170  :                 s = L_shl (s, h_fac);

  00342	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _h_fac$[ebp]
  00349	50		 push	 eax
  0034a	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  0034d	51		 push	 ecx
  0034e	e8 00 00 00 00	 call	 _L_shl
  00353	83 c4 08	 add	 esp, 8
  00356	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 171  :                 s_excf[j] = add (extract_h (s), s_excf[j - 1]); move16 ();

  00359	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0035d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  00363	0f b7 54 41 fe	 movzx	 edx, WORD PTR [ecx+eax*2-2]
  00368	52		 push	 edx
  00369	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0036c	50		 push	 eax
  0036d	e8 00 00 00 00	 call	 _extract_h
  00372	83 c4 04	 add	 esp, 4
  00375	0f b7 c8	 movzx	 ecx, ax
  00378	51		 push	 ecx
  00379	e8 00 00 00 00	 call	 _add
  0037e	83 c4 08	 add	 esp, 8
  00381	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  00385	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  0038b	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  0038f	e8 00 00 00 00	 call	 _move16

; 172  :             }

  00394	e9 72 ff ff ff	 jmp	 $LN2@Norm_Corr
$LN1@Norm_Corr:

; 173  :             s_excf[0] = shr (exc[k], scaling);  move16 ();

  00399	0f b7 85 3c ff
	ff ff		 movzx	 eax, WORD PTR _scaling$[ebp]
  003a0	50		 push	 eax
  003a1	0f bf 4d dc	 movsx	 ecx, WORD PTR _k$[ebp]
  003a5	8b 55 08	 mov	 edx, DWORD PTR _exc$[ebp]
  003a8	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 _shr
  003b2	83 c4 08	 add	 esp, 8
  003b5	b9 02 00 00 00	 mov	 ecx, 2
  003ba	6b d1 00	 imul	 edx, ecx, 0
  003bd	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _s_excf$[ebp]
  003c3	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  003c7	e8 00 00 00 00	 call	 _move16
$LN4@Norm_Corr:

; 174  :         }
; 175  :     }

  003cc	e9 b3 fd ff ff	 jmp	 $LN12@Norm_Corr
$LN22@Norm_Corr:

; 176  :     return;
; 177  : }

  003d1	52		 push	 edx
  003d2	8b cd		 mov	 ecx, ebp
  003d4	50		 push	 eax
  003d5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN31@Norm_Corr
  003db	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003e0	58		 pop	 eax
  003e1	5a		 pop	 edx
  003e2	5f		 pop	 edi
  003e3	5e		 pop	 esi
  003e4	5b		 pop	 ebx
  003e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e8	33 cd		 xor	 ecx, ebp
  003ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ef	81 c4 f8 01 00
	00		 add	 esp, 504		; 000001f8H
  003f5	3b ec		 cmp	 ebp, esp
  003f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003fc	8b e5		 mov	 esp, ebp
  003fe	5d		 pop	 ebp
  003ff	c3		 ret	 0
$LN31@Norm_Corr:
  00400	06 00 00 00	 DD	 6
  00404	00 00 00 00	 DD	 $LN30@Norm_Corr
$LN30@Norm_Corr:
  00408	d0 ff ff ff	 DD	 -48			; ffffffd0H
  0040c	02 00 00 00	 DD	 2
  00410	00 00 00 00	 DD	 $LN24@Norm_Corr
  00414	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00418	02 00 00 00	 DD	 2
  0041c	00 00 00 00	 DD	 $LN25@Norm_Corr
  00420	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00424	02 00 00 00	 DD	 2
  00428	00 00 00 00	 DD	 $LN26@Norm_Corr
  0042c	ac ff ff ff	 DD	 -84			; ffffffacH
  00430	02 00 00 00	 DD	 2
  00434	00 00 00 00	 DD	 $LN27@Norm_Corr
  00438	48 ff ff ff	 DD	 -184			; ffffff48H
  0043c	50 00 00 00	 DD	 80			; 00000050H
  00440	00 00 00 00	 DD	 $LN28@Norm_Corr
  00444	cc fe ff ff	 DD	 -308			; fffffeccH
  00448	50 00 00 00	 DD	 80			; 00000050H
  0044c	00 00 00 00	 DD	 $LN29@Norm_Corr
$LN29@Norm_Corr:
  00450	73		 DB	 115			; 00000073H
  00451	63		 DB	 99			; 00000063H
  00452	61		 DB	 97			; 00000061H
  00453	6c		 DB	 108			; 0000006cH
  00454	65		 DB	 101			; 00000065H
  00455	64		 DB	 100			; 00000064H
  00456	5f		 DB	 95			; 0000005fH
  00457	65		 DB	 101			; 00000065H
  00458	78		 DB	 120			; 00000078H
  00459	63		 DB	 99			; 00000063H
  0045a	66		 DB	 102			; 00000066H
  0045b	00		 DB	 0
$LN28@Norm_Corr:
  0045c	65		 DB	 101			; 00000065H
  0045d	78		 DB	 120			; 00000078H
  0045e	63		 DB	 99			; 00000063H
  0045f	66		 DB	 102			; 00000066H
  00460	00		 DB	 0
$LN27@Norm_Corr:
  00461	6e		 DB	 110			; 0000006eH
  00462	6f		 DB	 111			; 0000006fH
  00463	72		 DB	 114			; 00000072H
  00464	6d		 DB	 109			; 0000006dH
  00465	5f		 DB	 95			; 0000005fH
  00466	6c		 DB	 108			; 0000006cH
  00467	00		 DB	 0
$LN26@Norm_Corr:
  00468	6e		 DB	 110			; 0000006eH
  00469	6f		 DB	 111			; 0000006fH
  0046a	72		 DB	 114			; 00000072H
  0046b	6d		 DB	 109			; 0000006dH
  0046c	5f		 DB	 95			; 0000005fH
  0046d	68		 DB	 104			; 00000068H
  0046e	00		 DB	 0
$LN25@Norm_Corr:
  0046f	63		 DB	 99			; 00000063H
  00470	6f		 DB	 111			; 0000006fH
  00471	72		 DB	 114			; 00000072H
  00472	72		 DB	 114			; 00000072H
  00473	5f		 DB	 95			; 0000005fH
  00474	6c		 DB	 108			; 0000006cH
  00475	00		 DB	 0
$LN24@Norm_Corr:
  00476	63		 DB	 99			; 00000063H
  00477	6f		 DB	 111			; 0000006fH
  00478	72		 DB	 114			; 00000072H
  00479	72		 DB	 114			; 00000072H
  0047a	5f		 DB	 95			; 0000005fH
  0047b	68		 DB	 104			; 00000068H
  0047c	00		 DB	 0
_Norm_Corr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _Pitch_fr
_TEXT	SEGMENT
_delta_search$ = -340					; size = 2
_frame_offset$ = -328					; size = 2
_pit_min$ = -316					; size = 2
_delta_frc_range$ = -304				; size = 2
_delta_frc_low$ = -292					; size = 2
_delta_int_range$ = -280				; size = 2
_delta_int_low$ = -268					; size = 2
_last_frac$ = -256					; size = 2
_flag4$ = -244						; size = 2
_flag3$ = -232						; size = 2
_max_frac_lag$ = -220					; size = 2
_corr_v$ = -208						; size = 80
_corr$ = -120						; size = 4
_tmp_lag$ = -108					; size = 2
_frac$ = -96						; size = 2
_lag$ = -84						; size = 2
_max$ = -72						; size = 2
_t0_max$ = -60						; size = 2
_t0_min$ = -48						; size = 2
_t_max$ = -36						; size = 2
_t_min$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_T_op$ = 16						; size = 4
_exc$ = 20						; size = 4
_xn$ = 24						; size = 4
_h$ = 28						; size = 4
_L_subfr$ = 32						; size = 2
_i_subfr$ = 36						; size = 2
_pit_frac$ = 40						; size = 4
_resu3$ = 44						; size = 4
_ana_index$ = 48					; size = 4
_Pitch_fr PROC						; COMDAT

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-536]
  00012	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 387  :     Word16 i;
; 388  :     Word16 t_min, t_max;
; 389  :     Word16 t0_min, t0_max;
; 390  :     Word16 max, lag, frac;
; 391  :     Word16 tmp_lag;
; 392  :     Word16 *corr;
; 393  :     Word16 corr_v[40];    /* Total length = t0_max-t0_min+1+2*L_INTER_SRCH */
; 394  : 
; 395  :     Word16 max_frac_lag;
; 396  :     Word16 flag3, flag4;
; 397  :     Word16 last_frac;
; 398  :     Word16 delta_int_low, delta_int_range;
; 399  :     Word16 delta_frc_low, delta_frc_range;
; 400  :     Word16 pit_min;
; 401  :     Word16 frame_offset;
; 402  :     Word16 delta_search;
; 403  : 
; 404  :     /*-----------------------------------------------------------------------*
; 405  :      *                      set mode specific variables                      *
; 406  :      *-----------------------------------------------------------------------*/
; 407  : 
; 408  :     max_frac_lag    = mode_dep_parm[mode].max_frac_lag;           move16 ();

  00028	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  0002c	66 8b 88 00 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax]
  00033	66 89 8d 24 ff
	ff ff		 mov	 WORD PTR _max_frac_lag$[ebp], cx
  0003a	e8 00 00 00 00	 call	 _move16

; 409  :     flag3           = mode_dep_parm[mode].flag3;                  move16 ();

  0003f	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  00043	66 8b 88 02 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+2]
  0004a	66 89 8d 18 ff
	ff ff		 mov	 WORD PTR _flag3$[ebp], cx
  00051	e8 00 00 00 00	 call	 _move16

; 410  :     frac            = mode_dep_parm[mode].first_frac;             move16 ();

  00056	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  0005a	66 8b 88 04 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+4]
  00061	66 89 4d a0	 mov	 WORD PTR _frac$[ebp], cx
  00065	e8 00 00 00 00	 call	 _move16

; 411  :     last_frac       = mode_dep_parm[mode].last_frac;              move16 ();

  0006a	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  0006e	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+6]
  00075	66 89 8d 00 ff
	ff ff		 mov	 WORD PTR _last_frac$[ebp], cx
  0007c	e8 00 00 00 00	 call	 _move16

; 412  :     delta_int_low   = mode_dep_parm[mode].delta_int_low;          move16 ();

  00081	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  00085	66 8b 88 08 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+8]
  0008c	66 89 8d f4 fe
	ff ff		 mov	 WORD PTR _delta_int_low$[ebp], cx
  00093	e8 00 00 00 00	 call	 _move16

; 413  :     delta_int_range = mode_dep_parm[mode].delta_int_range;        move16 ();

  00098	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  0009c	66 8b 88 0a 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+10]
  000a3	66 89 8d e8 fe
	ff ff		 mov	 WORD PTR _delta_int_range$[ebp], cx
  000aa	e8 00 00 00 00	 call	 _move16

; 414  :     
; 415  :     delta_frc_low   = mode_dep_parm[mode].delta_frc_low;          move16 ();

  000af	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  000b3	66 8b 88 0c 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+12]
  000ba	66 89 8d dc fe
	ff ff		 mov	 WORD PTR _delta_frc_low$[ebp], cx
  000c1	e8 00 00 00 00	 call	 _move16

; 416  :     delta_frc_range = mode_dep_parm[mode].delta_frc_range;        move16 ();

  000c6	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  000ca	66 8b 88 0e 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+14]
  000d1	66 89 8d d0 fe
	ff ff		 mov	 WORD PTR _delta_frc_range$[ebp], cx
  000d8	e8 00 00 00 00	 call	 _move16

; 417  :     pit_min         = mode_dep_parm[mode].pit_min;                move16 ();

  000dd	6b 45 0c 12	 imul	 eax, DWORD PTR _mode$[ebp], 18
  000e1	66 8b 88 10 00
	00 00		 mov	 cx, WORD PTR _mode_dep_parm[eax+16]
  000e8	66 89 8d c4 fe
	ff ff		 mov	 WORD PTR _pit_min$[ebp], cx
  000ef	e8 00 00 00 00	 call	 _move16

; 418  :     
; 419  :     /*-----------------------------------------------------------------------*
; 420  :      *                 decide upon full or differential search               *
; 421  :      *-----------------------------------------------------------------------*/
; 422  :     
; 423  :     delta_search = 1;                                             move16 ();

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _delta_search$[ebp], ax
  00100	e8 00 00 00 00	 call	 _move16

; 424  :     
; 425  :     test (); test ();

  00105	e8 00 00 00 00	 call	 _test
  0010a	e8 00 00 00 00	 call	 _test

; 426  :     if ((i_subfr == 0) || (sub(i_subfr,L_FRAME_BY2) == 0)) {

  0010f	0f bf 45 24	 movsx	 eax, WORD PTR _i_subfr$[ebp]
  00113	85 c0		 test	 eax, eax
  00115	74 1a		 je	 SHORT $LN29@Pitch_fr
  00117	6a 50		 push	 80			; 00000050H
  00119	0f b7 45 24	 movzx	 eax, WORD PTR _i_subfr$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _sub
  00123	83 c4 08	 add	 esp, 8
  00126	0f bf c8	 movsx	 ecx, ax
  00129	85 c9		 test	 ecx, ecx
  0012b	0f 85 ff 00 00
	00		 jne	 $LN30@Pitch_fr
$LN29@Pitch_fr:

; 427  :       
; 428  :         /* Subframe 1 and 3 */
; 429  :       
; 430  :         test (); test (); test ();

  00131	e8 00 00 00 00	 call	 _test
  00136	e8 00 00 00 00	 call	 _test
  0013b	e8 00 00 00 00	 call	 _test

; 431  :         if (((sub(mode, MR475) != 0) && (sub(mode, MR515) != 0)) ||
; 432  :             (sub(i_subfr,L_FRAME_BY2) != 0)) {

  00140	6a 00		 push	 0
  00142	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _sub
  0014c	83 c4 08	 add	 esp, 8
  0014f	0f bf c8	 movsx	 ecx, ax
  00152	85 c9		 test	 ecx, ecx
  00154	74 16		 je	 SHORT $LN26@Pitch_fr
  00156	6a 01		 push	 1
  00158	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _sub
  00162	83 c4 08	 add	 esp, 8
  00165	0f bf c8	 movsx	 ecx, ax
  00168	85 c9		 test	 ecx, ecx
  0016a	75 16		 jne	 SHORT $LN27@Pitch_fr
$LN26@Pitch_fr:
  0016c	6a 50		 push	 80			; 00000050H
  0016e	0f b7 45 24	 movzx	 eax, WORD PTR _i_subfr$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _sub
  00178	83 c4 08	 add	 esp, 8
  0017b	0f bf c8	 movsx	 ecx, ax
  0017e	85 c9		 test	 ecx, ecx
  00180	74 78		 je	 SHORT $LN28@Pitch_fr
$LN27@Pitch_fr:

; 433  :         
; 434  :             /* set t0_min, t0_max for full search */
; 435  :             /* this is *not* done for mode MR475, MR515 in subframe 3 */
; 436  :         
; 437  :             delta_search = 0; /* no differential search */         move16 ();

  00182	33 c0		 xor	 eax, eax
  00184	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _delta_search$[ebp], ax
  0018b	e8 00 00 00 00	 call	 _move16

; 438  :             
; 439  :             /* calculate index into T_op which contains the open-loop */
; 440  :             /* pitch estimations for the 2 big subframes */
; 441  :             
; 442  :             frame_offset = 1;                                      move16 ();

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	66 89 85 b8 fe
	ff ff		 mov	 WORD PTR _frame_offset$[ebp], ax
  0019c	e8 00 00 00 00	 call	 _move16

; 443  :             test ();

  001a1	e8 00 00 00 00	 call	 _test

; 444  :             if (i_subfr == 0)

  001a6	0f bf 45 24	 movsx	 eax, WORD PTR _i_subfr$[ebp]
  001aa	85 c0		 test	 eax, eax
  001ac	75 09		 jne	 SHORT $LN25@Pitch_fr

; 445  :                 frame_offset = 0;                                  move16 ();

  001ae	33 c0		 xor	 eax, eax
  001b0	66 89 85 b8 fe
	ff ff		 mov	 WORD PTR _frame_offset$[ebp], ax
$LN25@Pitch_fr:
  001b7	e8 00 00 00 00	 call	 _move16

; 446  :             
; 447  :             /* get T_op from the corresponding half frame and */
; 448  :             /* set t0_min, t0_max */
; 449  :             
; 450  :             getRange (T_op[frame_offset], delta_int_low, delta_int_range,
; 451  :                       pit_min, PIT_MAX, &t0_min, &t0_max);

  001bc	8d 45 c4	 lea	 eax, DWORD PTR _t0_max$[ebp]
  001bf	50		 push	 eax
  001c0	8d 4d d0	 lea	 ecx, DWORD PTR _t0_min$[ebp]
  001c3	51		 push	 ecx
  001c4	68 8f 00 00 00	 push	 143			; 0000008fH
  001c9	0f b7 95 c4 fe
	ff ff		 movzx	 edx, WORD PTR _pit_min$[ebp]
  001d0	52		 push	 edx
  001d1	0f b7 85 e8 fe
	ff ff		 movzx	 eax, WORD PTR _delta_int_range$[ebp]
  001d8	50		 push	 eax
  001d9	0f b7 8d f4 fe
	ff ff		 movzx	 ecx, WORD PTR _delta_int_low$[ebp]
  001e0	51		 push	 ecx
  001e1	0f bf 95 b8 fe
	ff ff		 movsx	 edx, WORD PTR _frame_offset$[ebp]
  001e8	8b 45 10	 mov	 eax, DWORD PTR _T_op$[ebp]
  001eb	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  001ef	51		 push	 ecx
  001f0	e8 00 00 00 00	 call	 _getRange
  001f5	83 c4 1c	 add	 esp, 28			; 0000001cH

; 452  :         }
; 453  :         else {

  001f8	eb 34		 jmp	 SHORT $LN24@Pitch_fr
$LN28@Pitch_fr:

; 454  :             
; 455  :             /* mode MR475, MR515 and 3. Subframe: delta search as well */
; 456  :             getRange (st->T0_prev_subframe, delta_frc_low, delta_frc_range,
; 457  :                       pit_min, PIT_MAX, &t0_min, &t0_max);

  001fa	8d 45 c4	 lea	 eax, DWORD PTR _t0_max$[ebp]
  001fd	50		 push	 eax
  001fe	8d 4d d0	 lea	 ecx, DWORD PTR _t0_min$[ebp]
  00201	51		 push	 ecx
  00202	68 8f 00 00 00	 push	 143			; 0000008fH
  00207	0f b7 95 c4 fe
	ff ff		 movzx	 edx, WORD PTR _pit_min$[ebp]
  0020e	52		 push	 edx
  0020f	0f b7 85 d0 fe
	ff ff		 movzx	 eax, WORD PTR _delta_frc_range$[ebp]
  00216	50		 push	 eax
  00217	0f b7 8d dc fe
	ff ff		 movzx	 ecx, WORD PTR _delta_frc_low$[ebp]
  0021e	51		 push	 ecx
  0021f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00222	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 _getRange
  0022b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN24@Pitch_fr:

; 458  :         }
; 459  :     }
; 460  :     else {

  0022e	eb 34		 jmp	 SHORT $LN23@Pitch_fr
$LN30@Pitch_fr:

; 461  :         
; 462  :         /* for Subframe 2 and 4 */
; 463  :         /* get range around T0 of previous subframe for delta search */
; 464  :         
; 465  :         getRange (st->T0_prev_subframe, delta_frc_low, delta_frc_range,
; 466  :                   pit_min, PIT_MAX, &t0_min, &t0_max);

  00230	8d 45 c4	 lea	 eax, DWORD PTR _t0_max$[ebp]
  00233	50		 push	 eax
  00234	8d 4d d0	 lea	 ecx, DWORD PTR _t0_min$[ebp]
  00237	51		 push	 ecx
  00238	68 8f 00 00 00	 push	 143			; 0000008fH
  0023d	0f b7 95 c4 fe
	ff ff		 movzx	 edx, WORD PTR _pit_min$[ebp]
  00244	52		 push	 edx
  00245	0f b7 85 d0 fe
	ff ff		 movzx	 eax, WORD PTR _delta_frc_range$[ebp]
  0024c	50		 push	 eax
  0024d	0f b7 8d dc fe
	ff ff		 movzx	 ecx, WORD PTR _delta_frc_low$[ebp]
  00254	51		 push	 ecx
  00255	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00258	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 _getRange
  00261	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN23@Pitch_fr:

; 467  :     }
; 468  : 
; 469  :     /*-----------------------------------------------------------------------*
; 470  :      *           Find interval to compute normalized correlation             *
; 471  :      *-----------------------------------------------------------------------*/
; 472  : 
; 473  :     t_min = sub (t0_min, L_INTER_SRCH);

  00264	6a 04		 push	 4
  00266	0f b7 45 d0	 movzx	 eax, WORD PTR _t0_min$[ebp]
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _sub
  00270	83 c4 08	 add	 esp, 8
  00273	66 89 45 e8	 mov	 WORD PTR _t_min$[ebp], ax

; 474  :     t_max = add (t0_max, L_INTER_SRCH);

  00277	6a 04		 push	 4
  00279	0f b7 45 c4	 movzx	 eax, WORD PTR _t0_max$[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 _add
  00283	83 c4 08	 add	 esp, 8
  00286	66 89 45 dc	 mov	 WORD PTR _t_max$[ebp], ax

; 475  : 
; 476  :     corr = &corr_v[-t_min];                                        move16 ();

  0028a	0f bf 45 e8	 movsx	 eax, WORD PTR _t_min$[ebp]
  0028e	f7 d8		 neg	 eax
  00290	8d 8c 45 30 ff
	ff ff		 lea	 ecx, DWORD PTR _corr_v$[ebp+eax*2]
  00297	89 4d 88	 mov	 DWORD PTR _corr$[ebp], ecx
  0029a	e8 00 00 00 00	 call	 _move16

; 477  : 
; 478  :     /*-----------------------------------------------------------------------*
; 479  :      * Compute normalized correlation between target and filtered excitation *
; 480  :      *-----------------------------------------------------------------------*/
; 481  : 
; 482  :     Norm_Corr (exc, xn, h, L_subfr, t_min, t_max, corr);

  0029f	8b 45 88	 mov	 eax, DWORD PTR _corr$[ebp]
  002a2	50		 push	 eax
  002a3	0f b7 4d dc	 movzx	 ecx, WORD PTR _t_max$[ebp]
  002a7	51		 push	 ecx
  002a8	0f b7 55 e8	 movzx	 edx, WORD PTR _t_min$[ebp]
  002ac	52		 push	 edx
  002ad	0f b7 45 20	 movzx	 eax, WORD PTR _L_subfr$[ebp]
  002b1	50		 push	 eax
  002b2	8b 4d 1c	 mov	 ecx, DWORD PTR _h$[ebp]
  002b5	51		 push	 ecx
  002b6	8b 55 18	 mov	 edx, DWORD PTR _xn$[ebp]
  002b9	52		 push	 edx
  002ba	8b 45 14	 mov	 eax, DWORD PTR _exc$[ebp]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 _Norm_Corr
  002c3	83 c4 1c	 add	 esp, 28			; 0000001cH

; 483  : 
; 484  :     /*-----------------------------------------------------------------------*
; 485  :      *                           Find integer pitch                          *
; 486  :      *-----------------------------------------------------------------------*/
; 487  : 
; 488  :     max = corr[t0_min];                                            move16 ();

  002c6	0f bf 45 d0	 movsx	 eax, WORD PTR _t0_min$[ebp]
  002ca	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  002cd	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  002d1	66 89 55 b8	 mov	 WORD PTR _max$[ebp], dx
  002d5	e8 00 00 00 00	 call	 _move16

; 489  :     lag = t0_min;                                                  move16 ();

  002da	66 8b 45 d0	 mov	 ax, WORD PTR _t0_min$[ebp]
  002de	66 89 45 ac	 mov	 WORD PTR _lag$[ebp], ax
  002e2	e8 00 00 00 00	 call	 _move16

; 490  : 
; 491  :     for (i = t0_min + 1; i <= t0_max; i++) {

  002e7	0f bf 45 d0	 movsx	 eax, WORD PTR _t0_min$[ebp]
  002eb	83 c0 01	 add	 eax, 1
  002ee	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  002f2	eb 0c		 jmp	 SHORT $LN22@Pitch_fr
$LN21@Pitch_fr:
  002f4	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  002f8	66 83 c0 01	 add	 ax, 1
  002fc	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN22@Pitch_fr:
  00300	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00304	0f bf 4d c4	 movsx	 ecx, WORD PTR _t0_max$[ebp]
  00308	3b c1		 cmp	 eax, ecx
  0030a	7f 48		 jg	 SHORT $LN20@Pitch_fr

; 492  :         test ();

  0030c	e8 00 00 00 00	 call	 _test

; 493  :         if (sub (corr[i], max) >= 0) {

  00311	0f b7 45 b8	 movzx	 eax, WORD PTR _max$[ebp]
  00315	50		 push	 eax
  00316	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0031a	8b 55 88	 mov	 edx, DWORD PTR _corr$[ebp]
  0031d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _sub
  00327	83 c4 08	 add	 esp, 8
  0032a	0f bf c8	 movsx	 ecx, ax
  0032d	85 c9		 test	 ecx, ecx
  0032f	7c 21		 jl	 SHORT $LN19@Pitch_fr

; 494  :             max = corr[i];                                         move16 ();

  00331	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00335	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  00338	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0033c	66 89 55 b8	 mov	 WORD PTR _max$[ebp], dx
  00340	e8 00 00 00 00	 call	 _move16

; 495  :             lag = i;                                               move16 ();

  00345	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00349	66 89 45 ac	 mov	 WORD PTR _lag$[ebp], ax
  0034d	e8 00 00 00 00	 call	 _move16
$LN19@Pitch_fr:

; 496  :         }
; 497  :     }

  00352	eb a0		 jmp	 SHORT $LN21@Pitch_fr
$LN20@Pitch_fr:

; 498  : 
; 499  :     /*-----------------------------------------------------------------------*
; 500  :      *                        Find fractional pitch                          *
; 501  :      *-----------------------------------------------------------------------*/
; 502  :     test (); test ();

  00354	e8 00 00 00 00	 call	 _test
  00359	e8 00 00 00 00	 call	 _test

; 503  :     if ((delta_search == 0) && (sub (lag, max_frac_lag) > 0)) {

  0035e	0f bf 85 ac fe
	ff ff		 movsx	 eax, WORD PTR _delta_search$[ebp]
  00365	85 c0		 test	 eax, eax
  00367	75 2c		 jne	 SHORT $LN18@Pitch_fr
  00369	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _max_frac_lag$[ebp]
  00370	50		 push	 eax
  00371	0f b7 4d ac	 movzx	 ecx, WORD PTR _lag$[ebp]
  00375	51		 push	 ecx
  00376	e8 00 00 00 00	 call	 _sub
  0037b	83 c4 08	 add	 esp, 8
  0037e	0f bf d0	 movsx	 edx, ax
  00381	85 d2		 test	 edx, edx
  00383	7e 10		 jle	 SHORT $LN18@Pitch_fr

; 504  : 
; 505  :         /* full search and integer pitch greater than max_frac_lag */
; 506  :         /* fractional search is not needed, set fractional to zero */
; 507  : 
; 508  :         frac = 0;                                                  move16 ();

  00385	33 c0		 xor	 eax, eax
  00387	66 89 45 a0	 mov	 WORD PTR _frac$[ebp], ax
  0038b	e8 00 00 00 00	 call	 _move16

; 509  :     }
; 510  :     else {

  00390	e9 77 02 00 00	 jmp	 $LN17@Pitch_fr
$LN18@Pitch_fr:

; 511  : 
; 512  :         /* if differential search AND mode MR475 OR MR515 OR MR59 OR MR67   */
; 513  :         /* then search fractional with 4 bits resolution           */
; 514  :        
; 515  :        test (); test (); test (); test (); test (); 

  00395	e8 00 00 00 00	 call	 _test
  0039a	e8 00 00 00 00	 call	 _test
  0039f	e8 00 00 00 00	 call	 _test
  003a4	e8 00 00 00 00	 call	 _test
  003a9	e8 00 00 00 00	 call	 _test

; 516  :        if ((delta_search != 0) &&
; 517  :            ((sub (mode, MR475) == 0) ||
; 518  :             (sub (mode, MR515) == 0) ||
; 519  :             (sub (mode, MR59) == 0) ||
; 520  :             (sub (mode, MR67) == 0))) {

  003ae	0f bf 85 ac fe
	ff ff		 movsx	 eax, WORD PTR _delta_search$[ebp]
  003b5	85 c0		 test	 eax, eax
  003b7	0f 84 2b 02 00
	00		 je	 $LN16@Pitch_fr
  003bd	6a 00		 push	 0
  003bf	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  003c3	50		 push	 eax
  003c4	e8 00 00 00 00	 call	 _sub
  003c9	83 c4 08	 add	 esp, 8
  003cc	0f bf c8	 movsx	 ecx, ax
  003cf	85 c9		 test	 ecx, ecx
  003d1	74 46		 je	 SHORT $LN15@Pitch_fr
  003d3	6a 01		 push	 1
  003d5	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 _sub
  003df	83 c4 08	 add	 esp, 8
  003e2	0f bf c8	 movsx	 ecx, ax
  003e5	85 c9		 test	 ecx, ecx
  003e7	74 30		 je	 SHORT $LN15@Pitch_fr
  003e9	6a 02		 push	 2
  003eb	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  003ef	50		 push	 eax
  003f0	e8 00 00 00 00	 call	 _sub
  003f5	83 c4 08	 add	 esp, 8
  003f8	0f bf c8	 movsx	 ecx, ax
  003fb	85 c9		 test	 ecx, ecx
  003fd	74 1a		 je	 SHORT $LN15@Pitch_fr
  003ff	6a 03		 push	 3
  00401	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 _sub
  0040b	83 c4 08	 add	 esp, 8
  0040e	0f bf c8	 movsx	 ecx, ax
  00411	85 c9		 test	 ecx, ecx
  00413	0f 85 cf 01 00
	00		 jne	 $LN16@Pitch_fr
$LN15@Pitch_fr:

; 521  : 
; 522  :           /* modify frac or last_frac according to position of last */
; 523  :           /* integer pitch: either search around integer pitch, */
; 524  :           /* or only on left or right side */
; 525  :           
; 526  :           tmp_lag = st->T0_prev_subframe;                          move16 ();

  00419	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0041c	66 8b 08	 mov	 cx, WORD PTR [eax]
  0041f	66 89 4d 94	 mov	 WORD PTR _tmp_lag$[ebp], cx
  00423	e8 00 00 00 00	 call	 _move16

; 527  :           test ();

  00428	e8 00 00 00 00	 call	 _test

; 528  :           if ( sub( sub(tmp_lag, t0_min), 5) > 0)

  0042d	6a 05		 push	 5
  0042f	0f b7 45 d0	 movzx	 eax, WORD PTR _t0_min$[ebp]
  00433	50		 push	 eax
  00434	0f b7 4d 94	 movzx	 ecx, WORD PTR _tmp_lag$[ebp]
  00438	51		 push	 ecx
  00439	e8 00 00 00 00	 call	 _sub
  0043e	83 c4 08	 add	 esp, 8
  00441	0f b7 d0	 movzx	 edx, ax
  00444	52		 push	 edx
  00445	e8 00 00 00 00	 call	 _sub
  0044a	83 c4 08	 add	 esp, 8
  0044d	98		 cwde
  0044e	85 c0		 test	 eax, eax
  00450	7e 13		 jle	 SHORT $LN14@Pitch_fr

; 529  :              tmp_lag = add (t0_min, 5);

  00452	6a 05		 push	 5
  00454	0f b7 45 d0	 movzx	 eax, WORD PTR _t0_min$[ebp]
  00458	50		 push	 eax
  00459	e8 00 00 00 00	 call	 _add
  0045e	83 c4 08	 add	 esp, 8
  00461	66 89 45 94	 mov	 WORD PTR _tmp_lag$[ebp], ax
$LN14@Pitch_fr:

; 530  :           test ();

  00465	e8 00 00 00 00	 call	 _test

; 531  :           if ( sub( sub(t0_max, tmp_lag), 4) > 0)

  0046a	6a 04		 push	 4
  0046c	0f b7 45 94	 movzx	 eax, WORD PTR _tmp_lag$[ebp]
  00470	50		 push	 eax
  00471	0f b7 4d c4	 movzx	 ecx, WORD PTR _t0_max$[ebp]
  00475	51		 push	 ecx
  00476	e8 00 00 00 00	 call	 _sub
  0047b	83 c4 08	 add	 esp, 8
  0047e	0f b7 d0	 movzx	 edx, ax
  00481	52		 push	 edx
  00482	e8 00 00 00 00	 call	 _sub
  00487	83 c4 08	 add	 esp, 8
  0048a	98		 cwde
  0048b	85 c0		 test	 eax, eax
  0048d	7e 13		 jle	 SHORT $LN13@Pitch_fr

; 532  :                tmp_lag = sub (t0_max, 4);

  0048f	6a 04		 push	 4
  00491	0f b7 45 c4	 movzx	 eax, WORD PTR _t0_max$[ebp]
  00495	50		 push	 eax
  00496	e8 00 00 00 00	 call	 _sub
  0049b	83 c4 08	 add	 esp, 8
  0049e	66 89 45 94	 mov	 WORD PTR _tmp_lag$[ebp], ax
$LN13@Pitch_fr:

; 533  :           
; 534  :           test (); test ();

  004a2	e8 00 00 00 00	 call	 _test
  004a7	e8 00 00 00 00	 call	 _test

; 535  :           if ((sub (lag, tmp_lag) == 0) ||
; 536  :               (sub (lag, sub(tmp_lag, 1)) == 0)) {

  004ac	0f b7 45 94	 movzx	 eax, WORD PTR _tmp_lag$[ebp]
  004b0	50		 push	 eax
  004b1	0f b7 4d ac	 movzx	 ecx, WORD PTR _lag$[ebp]
  004b5	51		 push	 ecx
  004b6	e8 00 00 00 00	 call	 _sub
  004bb	83 c4 08	 add	 esp, 8
  004be	0f bf d0	 movsx	 edx, ax
  004c1	85 d2		 test	 edx, edx
  004c3	74 25		 je	 SHORT $LN11@Pitch_fr
  004c5	6a 01		 push	 1
  004c7	0f b7 45 94	 movzx	 eax, WORD PTR _tmp_lag$[ebp]
  004cb	50		 push	 eax
  004cc	e8 00 00 00 00	 call	 _sub
  004d1	83 c4 08	 add	 esp, 8
  004d4	0f b7 c8	 movzx	 ecx, ax
  004d7	51		 push	 ecx
  004d8	0f b7 55 ac	 movzx	 edx, WORD PTR _lag$[ebp]
  004dc	52		 push	 edx
  004dd	e8 00 00 00 00	 call	 _sub
  004e2	83 c4 08	 add	 esp, 8
  004e5	98		 cwde
  004e6	85 c0		 test	 eax, eax
  004e8	75 29		 jne	 SHORT $LN12@Pitch_fr
$LN11@Pitch_fr:

; 537  :              
; 538  :              /* normal search in fractions around T0 */
; 539  :              
; 540  :              searchFrac (&lag, &frac, last_frac, corr, flag3);

  004ea	0f b7 85 18 ff
	ff ff		 movzx	 eax, WORD PTR _flag3$[ebp]
  004f1	50		 push	 eax
  004f2	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  004f5	51		 push	 ecx
  004f6	0f b7 95 00 ff
	ff ff		 movzx	 edx, WORD PTR _last_frac$[ebp]
  004fd	52		 push	 edx
  004fe	8d 45 a0	 lea	 eax, DWORD PTR _frac$[ebp]
  00501	50		 push	 eax
  00502	8d 4d ac	 lea	 ecx, DWORD PTR _lag$[ebp]
  00505	51		 push	 ecx
  00506	e8 00 00 00 00	 call	 _searchFrac
  0050b	83 c4 14	 add	 esp, 20			; 00000014H
  0050e	e9 d3 00 00 00	 jmp	 $LN10@Pitch_fr
$LN12@Pitch_fr:

; 541  :              
; 542  :           }
; 543  :           else if (sub (lag, sub (tmp_lag, 2)) == 0) {

  00513	6a 02		 push	 2
  00515	0f b7 45 94	 movzx	 eax, WORD PTR _tmp_lag$[ebp]
  00519	50		 push	 eax
  0051a	e8 00 00 00 00	 call	 _sub
  0051f	83 c4 08	 add	 esp, 8
  00522	0f b7 c8	 movzx	 ecx, ax
  00525	51		 push	 ecx
  00526	0f b7 55 ac	 movzx	 edx, WORD PTR _lag$[ebp]
  0052a	52		 push	 edx
  0052b	e8 00 00 00 00	 call	 _sub
  00530	83 c4 08	 add	 esp, 8
  00533	98		 cwde
  00534	85 c0		 test	 eax, eax
  00536	75 36		 jne	 SHORT $LN9@Pitch_fr

; 544  :              test ();

  00538	e8 00 00 00 00	 call	 _test

; 545  :              /* limit search around T0 to the right side */
; 546  :              frac = 0;                                            move16 ();

  0053d	33 c0		 xor	 eax, eax
  0053f	66 89 45 a0	 mov	 WORD PTR _frac$[ebp], ax
  00543	e8 00 00 00 00	 call	 _move16

; 547  :              searchFrac (&lag, &frac, last_frac, corr, flag3);

  00548	0f b7 85 18 ff
	ff ff		 movzx	 eax, WORD PTR _flag3$[ebp]
  0054f	50		 push	 eax
  00550	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  00553	51		 push	 ecx
  00554	0f b7 95 00 ff
	ff ff		 movzx	 edx, WORD PTR _last_frac$[ebp]
  0055b	52		 push	 edx
  0055c	8d 45 a0	 lea	 eax, DWORD PTR _frac$[ebp]
  0055f	50		 push	 eax
  00560	8d 4d ac	 lea	 ecx, DWORD PTR _lag$[ebp]
  00563	51		 push	 ecx
  00564	e8 00 00 00 00	 call	 _searchFrac
  00569	83 c4 14	 add	 esp, 20			; 00000014H
  0056c	eb 78		 jmp	 SHORT $LN10@Pitch_fr
$LN9@Pitch_fr:

; 548  :           }
; 549  :           else if (sub (lag, add(tmp_lag, 1)) == 0) {

  0056e	6a 01		 push	 1
  00570	0f b7 45 94	 movzx	 eax, WORD PTR _tmp_lag$[ebp]
  00574	50		 push	 eax
  00575	e8 00 00 00 00	 call	 _add
  0057a	83 c4 08	 add	 esp, 8
  0057d	0f b7 c8	 movzx	 ecx, ax
  00580	51		 push	 ecx
  00581	0f b7 55 ac	 movzx	 edx, WORD PTR _lag$[ebp]
  00585	52		 push	 edx
  00586	e8 00 00 00 00	 call	 _sub
  0058b	83 c4 08	 add	 esp, 8
  0058e	98		 cwde
  0058f	85 c0		 test	 eax, eax
  00591	75 3e		 jne	 SHORT $LN7@Pitch_fr

; 550  :              test (); test ();

  00593	e8 00 00 00 00	 call	 _test
  00598	e8 00 00 00 00	 call	 _test

; 551  :              /* limit search around T0 to the left side */
; 552  :              last_frac = 0;                                       move16 ();

  0059d	33 c0		 xor	 eax, eax
  0059f	66 89 85 00 ff
	ff ff		 mov	 WORD PTR _last_frac$[ebp], ax
  005a6	e8 00 00 00 00	 call	 _move16

; 553  :              searchFrac (&lag, &frac, last_frac, corr, flag3);

  005ab	0f b7 85 18 ff
	ff ff		 movzx	 eax, WORD PTR _flag3$[ebp]
  005b2	50		 push	 eax
  005b3	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  005b6	51		 push	 ecx
  005b7	0f b7 95 00 ff
	ff ff		 movzx	 edx, WORD PTR _last_frac$[ebp]
  005be	52		 push	 edx
  005bf	8d 45 a0	 lea	 eax, DWORD PTR _frac$[ebp]
  005c2	50		 push	 eax
  005c3	8d 4d ac	 lea	 ecx, DWORD PTR _lag$[ebp]
  005c6	51		 push	 ecx
  005c7	e8 00 00 00 00	 call	 _searchFrac
  005cc	83 c4 14	 add	 esp, 20			; 00000014H

; 554  :           }
; 555  :           else {

  005cf	eb 15		 jmp	 SHORT $LN10@Pitch_fr
$LN7@Pitch_fr:

; 556  :              test (); test ();

  005d1	e8 00 00 00 00	 call	 _test
  005d6	e8 00 00 00 00	 call	 _test

; 557  :              /* no fractional search */
; 558  :              frac = 0;                                            move16 ();

  005db	33 c0		 xor	 eax, eax
  005dd	66 89 45 a0	 mov	 WORD PTR _frac$[ebp], ax
  005e1	e8 00 00 00 00	 call	 _move16
$LN10@Pitch_fr:

; 559  :             }
; 560  :        }
; 561  :        else

  005e6	eb 24		 jmp	 SHORT $LN17@Pitch_fr
$LN16@Pitch_fr:

; 562  :           /* test the fractions around T0 */
; 563  :           searchFrac (&lag, &frac, last_frac, corr, flag3);

  005e8	0f b7 85 18 ff
	ff ff		 movzx	 eax, WORD PTR _flag3$[ebp]
  005ef	50		 push	 eax
  005f0	8b 4d 88	 mov	 ecx, DWORD PTR _corr$[ebp]
  005f3	51		 push	 ecx
  005f4	0f b7 95 00 ff
	ff ff		 movzx	 edx, WORD PTR _last_frac$[ebp]
  005fb	52		 push	 edx
  005fc	8d 45 a0	 lea	 eax, DWORD PTR _frac$[ebp]
  005ff	50		 push	 eax
  00600	8d 4d ac	 lea	 ecx, DWORD PTR _lag$[ebp]
  00603	51		 push	 ecx
  00604	e8 00 00 00 00	 call	 _searchFrac
  00609	83 c4 14	 add	 esp, 20			; 00000014H
$LN17@Pitch_fr:

; 564  :     }
; 565  :     
; 566  :     /*-----------------------------------------------------------------------*
; 567  :      *                           encode pitch                                *
; 568  :      *-----------------------------------------------------------------------*/
; 569  :     
; 570  :     test ();

  0060c	e8 00 00 00 00	 call	 _test

; 571  :     if (flag3 != 0) {       

  00611	0f bf 85 18 ff
	ff ff		 movsx	 eax, WORD PTR _flag3$[ebp]
  00618	85 c0		 test	 eax, eax
  0061a	0f 84 cb 00 00
	00		 je	 $LN4@Pitch_fr

; 572  :        /* flag4 indicates encoding with 4 bit resolution;         */
; 573  :        /* this is needed for mode MR475, MR515 and MR59           */
; 574  :        
; 575  :        flag4 = 0;                                                 move16 ();

  00620	33 c0		 xor	 eax, eax
  00622	66 89 85 0c ff
	ff ff		 mov	 WORD PTR _flag4$[ebp], ax
  00629	e8 00 00 00 00	 call	 _move16

; 576  :        test (); test (); test (); test (); 

  0062e	e8 00 00 00 00	 call	 _test
  00633	e8 00 00 00 00	 call	 _test
  00638	e8 00 00 00 00	 call	 _test
  0063d	e8 00 00 00 00	 call	 _test

; 577  :        if ( (sub (mode, MR475) == 0) ||
; 578  :             (sub (mode, MR515) == 0) ||
; 579  :             (sub (mode, MR59) == 0) ||
; 580  :             (sub (mode, MR67) == 0) ) {

  00642	6a 00		 push	 0
  00644	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00648	50		 push	 eax
  00649	e8 00 00 00 00	 call	 _sub
  0064e	83 c4 08	 add	 esp, 8
  00651	0f bf c8	 movsx	 ecx, ax
  00654	85 c9		 test	 ecx, ecx
  00656	74 42		 je	 SHORT $LN2@Pitch_fr
  00658	6a 01		 push	 1
  0065a	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 _sub
  00664	83 c4 08	 add	 esp, 8
  00667	0f bf c8	 movsx	 ecx, ax
  0066a	85 c9		 test	 ecx, ecx
  0066c	74 2c		 je	 SHORT $LN2@Pitch_fr
  0066e	6a 02		 push	 2
  00670	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 _sub
  0067a	83 c4 08	 add	 esp, 8
  0067d	0f bf c8	 movsx	 ecx, ax
  00680	85 c9		 test	 ecx, ecx
  00682	74 16		 je	 SHORT $LN2@Pitch_fr
  00684	6a 03		 push	 3
  00686	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0068a	50		 push	 eax
  0068b	e8 00 00 00 00	 call	 _sub
  00690	83 c4 08	 add	 esp, 8
  00693	0f bf c8	 movsx	 ecx, ax
  00696	85 c9		 test	 ecx, ecx
  00698	75 11		 jne	 SHORT $LN3@Pitch_fr
$LN2@Pitch_fr:

; 581  :           flag4 = 1;                                              move16 ();

  0069a	b8 01 00 00 00	 mov	 eax, 1
  0069f	66 89 85 0c ff
	ff ff		 mov	 WORD PTR _flag4$[ebp], ax
  006a6	e8 00 00 00 00	 call	 _move16
$LN3@Pitch_fr:

; 582  :        }
; 583  :        
; 584  :        /* encode with 1/3 subsample resolution */
; 585  :        
; 586  :        *ana_index = Enc_lag3(lag, frac, st->T0_prev_subframe,
; 587  :                              t0_min, t0_max, delta_search, flag4); move16 (); /* function result */

  006ab	0f b7 85 0c ff
	ff ff		 movzx	 eax, WORD PTR _flag4$[ebp]
  006b2	50		 push	 eax
  006b3	0f b7 8d ac fe
	ff ff		 movzx	 ecx, WORD PTR _delta_search$[ebp]
  006ba	51		 push	 ecx
  006bb	0f b7 55 c4	 movzx	 edx, WORD PTR _t0_max$[ebp]
  006bf	52		 push	 edx
  006c0	0f b7 45 d0	 movzx	 eax, WORD PTR _t0_min$[ebp]
  006c4	50		 push	 eax
  006c5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  006c8	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  006cb	52		 push	 edx
  006cc	0f b7 45 a0	 movzx	 eax, WORD PTR _frac$[ebp]
  006d0	50		 push	 eax
  006d1	0f b7 4d ac	 movzx	 ecx, WORD PTR _lag$[ebp]
  006d5	51		 push	 ecx
  006d6	e8 00 00 00 00	 call	 _Enc_lag3
  006db	83 c4 1c	 add	 esp, 28			; 0000001cH
  006de	8b 55 30	 mov	 edx, DWORD PTR _ana_index$[ebp]
  006e1	66 89 02	 mov	 WORD PTR [edx], ax
  006e4	e8 00 00 00 00	 call	 _move16

; 588  : 
; 589  :     }  
; 590  :     else

  006e9	eb 2a		 jmp	 SHORT $LN1@Pitch_fr
$LN4@Pitch_fr:

; 591  :     {
; 592  :        /* encode with 1/6 subsample resolution */
; 593  :        
; 594  :        *ana_index = Enc_lag6(lag, frac, t0_min, delta_search); move16 (); /* function result */

  006eb	0f b7 85 ac fe
	ff ff		 movzx	 eax, WORD PTR _delta_search$[ebp]
  006f2	50		 push	 eax
  006f3	0f b7 4d d0	 movzx	 ecx, WORD PTR _t0_min$[ebp]
  006f7	51		 push	 ecx
  006f8	0f b7 55 a0	 movzx	 edx, WORD PTR _frac$[ebp]
  006fc	52		 push	 edx
  006fd	0f b7 45 ac	 movzx	 eax, WORD PTR _lag$[ebp]
  00701	50		 push	 eax
  00702	e8 00 00 00 00	 call	 _Enc_lag6
  00707	83 c4 10	 add	 esp, 16			; 00000010H
  0070a	8b 4d 30	 mov	 ecx, DWORD PTR _ana_index$[ebp]
  0070d	66 89 01	 mov	 WORD PTR [ecx], ax
  00710	e8 00 00 00 00	 call	 _move16
$LN1@Pitch_fr:

; 595  :     }
; 596  :     
; 597  :     /*-----------------------------------------------------------------------*
; 598  :      *                          update state variables                       *
; 599  :      *-----------------------------------------------------------------------*/
; 600  :     
; 601  :     st->T0_prev_subframe = lag;                                    move16 ();

  00715	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00718	66 8b 4d ac	 mov	 cx, WORD PTR _lag$[ebp]
  0071c	66 89 08	 mov	 WORD PTR [eax], cx
  0071f	e8 00 00 00 00	 call	 _move16

; 602  :     
; 603  :     /*-----------------------------------------------------------------------*
; 604  :      *                      update output variables                          *
; 605  :      *-----------------------------------------------------------------------*/
; 606  :     
; 607  :     *resu3    = flag3;                                             move16 ();

  00724	8b 45 2c	 mov	 eax, DWORD PTR _resu3$[ebp]
  00727	66 8b 8d 18 ff
	ff ff		 mov	 cx, WORD PTR _flag3$[ebp]
  0072e	66 89 08	 mov	 WORD PTR [eax], cx
  00731	e8 00 00 00 00	 call	 _move16

; 608  : 
; 609  :     *pit_frac = frac;                                              move16 ();

  00736	8b 45 28	 mov	 eax, DWORD PTR _pit_frac$[ebp]
  00739	66 8b 4d a0	 mov	 cx, WORD PTR _frac$[ebp]
  0073d	66 89 08	 mov	 WORD PTR [eax], cx
  00740	e8 00 00 00 00	 call	 _move16

; 610  : 
; 611  :     return (lag);

  00745	66 8b 45 ac	 mov	 ax, WORD PTR _lag$[ebp]

; 612  : }

  00749	52		 push	 edx
  0074a	8b cd		 mov	 ecx, ebp
  0074c	50		 push	 eax
  0074d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN39@Pitch_fr
  00753	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00758	58		 pop	 eax
  00759	5a		 pop	 edx
  0075a	5f		 pop	 edi
  0075b	5e		 pop	 esi
  0075c	5b		 pop	 ebx
  0075d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00760	33 cd		 xor	 ecx, ebp
  00762	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00767	81 c4 18 02 00
	00		 add	 esp, 536		; 00000218H
  0076d	3b ec		 cmp	 ebp, esp
  0076f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00774	8b e5		 mov	 esp, ebp
  00776	5d		 pop	 ebp
  00777	c3		 ret	 0
$LN39@Pitch_fr:
  00778	05 00 00 00	 DD	 5
  0077c	00 00 00 00	 DD	 $LN38@Pitch_fr
$LN38@Pitch_fr:
  00780	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00784	02 00 00 00	 DD	 2
  00788	00 00 00 00	 DD	 $LN33@Pitch_fr
  0078c	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00790	02 00 00 00	 DD	 2
  00794	00 00 00 00	 DD	 $LN34@Pitch_fr
  00798	ac ff ff ff	 DD	 -84			; ffffffacH
  0079c	02 00 00 00	 DD	 2
  007a0	00 00 00 00	 DD	 $LN35@Pitch_fr
  007a4	a0 ff ff ff	 DD	 -96			; ffffffa0H
  007a8	02 00 00 00	 DD	 2
  007ac	00 00 00 00	 DD	 $LN36@Pitch_fr
  007b0	30 ff ff ff	 DD	 -208			; ffffff30H
  007b4	50 00 00 00	 DD	 80			; 00000050H
  007b8	00 00 00 00	 DD	 $LN37@Pitch_fr
$LN37@Pitch_fr:
  007bc	63		 DB	 99			; 00000063H
  007bd	6f		 DB	 111			; 0000006fH
  007be	72		 DB	 114			; 00000072H
  007bf	72		 DB	 114			; 00000072H
  007c0	5f		 DB	 95			; 0000005fH
  007c1	76		 DB	 118			; 00000076H
  007c2	00		 DB	 0
$LN36@Pitch_fr:
  007c3	66		 DB	 102			; 00000066H
  007c4	72		 DB	 114			; 00000072H
  007c5	61		 DB	 97			; 00000061H
  007c6	63		 DB	 99			; 00000063H
  007c7	00		 DB	 0
$LN35@Pitch_fr:
  007c8	6c		 DB	 108			; 0000006cH
  007c9	61		 DB	 97			; 00000061H
  007ca	67		 DB	 103			; 00000067H
  007cb	00		 DB	 0
$LN34@Pitch_fr:
  007cc	74		 DB	 116			; 00000074H
  007cd	30		 DB	 48			; 00000030H
  007ce	5f		 DB	 95			; 0000005fH
  007cf	6d		 DB	 109			; 0000006dH
  007d0	61		 DB	 97			; 00000061H
  007d1	78		 DB	 120			; 00000078H
  007d2	00		 DB	 0
$LN33@Pitch_fr:
  007d3	74		 DB	 116			; 00000074H
  007d4	30		 DB	 48			; 00000030H
  007d5	5f		 DB	 95			; 0000005fH
  007d6	6d		 DB	 109			; 0000006dH
  007d7	69		 DB	 105			; 00000069H
  007d8	6e		 DB	 110			; 0000006eH
  007d9	00		 DB	 0
_Pitch_fr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _Pitch_fr_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Pitch_fr_exit PROC					; COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 346  :     if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Pitch_fr_e
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@Pitch_fr_e
$LN1@Pitch_fr_e:

; 347  :         return;

  0002c	eb 21		 jmp	 SHORT $LN3@Pitch_fr_e
$LN2@Pitch_fr_e:

; 348  : 
; 349  :     /* deallocate memory */
; 350  :     free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 351  :     *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Pitch_fr_e:

; 352  : 
; 353  :     return;
; 354  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Pitch_fr_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _Pitch_fr_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Pitch_fr_reset PROC					; COMDAT

; 325  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 326  : 
; 327  :     if (state == (Pitch_frState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@Pitch_fr_r

; 328  :         fprintf(stderr, "Pitch_fr_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@OBLKDDLG@Pitch_fr_reset?3?5invalid?5paramete@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 329  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 0a		 jmp	 SHORT $LN2@Pitch_fr_r
$LN1@Pitch_fr_r:

; 330  :     }
; 331  : 
; 332  :     state->T0_prev_subframe = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 333  : 
; 334  :     return 0;

  00061	33 c0		 xor	 eax, eax
$LN2@Pitch_fr_r:

; 335  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_Pitch_fr_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pitch_fr.c
;	COMDAT _Pitch_fr_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Pitch_fr_init PROC					; COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 297  :     Pitch_frState* s;
; 298  : 
; 299  :     if (state == (Pitch_frState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@Pitch_fr_i

; 300  :         fprintf(stderr, "Pitch_fr_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HOAPGGEM@Pitch_fr_init?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 301  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@Pitch_fr_i
$LN2@Pitch_fr_i:

; 302  :     }
; 303  :     *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 304  : 
; 305  :     /* allocate memory */
; 306  :     if ((s= (Pitch_frState *) malloc(sizeof(Pitch_frState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 02		 push	 2
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@Pitch_fr_i

; 307  :         fprintf(stderr, "Pitch_fr_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FLPNEKMA@Pitch_fr_init?3?5can?5not?5malloc?5st@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 308  :         return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@Pitch_fr_i
$LN1@Pitch_fr_i:

; 309  :     }
; 310  : 
; 311  :     Pitch_fr_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _Pitch_fr_reset
  000bd	83 c4 04	 add	 esp, 4

; 312  :     *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 
; 314  :     return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@Pitch_fr_i:

; 315  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_Pitch_fr_init ENDP
_TEXT	ENDS
END
