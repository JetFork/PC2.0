; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ph_disp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ph_disp_id
CONST	SEGMENT
_ph_disp_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_ph_imp_low_MR795 DW 06899H
	DW	0321H
	DW	09c9H
	DW	0fd55H
	DW	0fa9aH
	DW	0246H
	DW	025cH
	DW	0fb06H
	DW	0db7H
	DW	0e8faH
	DW	011b6H
	DW	0fe0dH
	DW	0f86cH
	DW	0bc3H
	DW	0ec3eH
	DW	015eeH
	DW	0f83aH
	DW	0fbdbH
	DW	0fa4dH
	DW	0115aH
	DW	0fd44H
	DW	0eb29H
	DW	01201H
	DW	01c4H
	DW	0fdb3H
	DW	0f2e8H
	DW	0b89H
	DW	04f3H
	DW	0fb44H
	DW	0f5e2H
	DW	06c3H
	DW	0e56H
	DW	0ee85H
	DW	0fc31H
	DW	01127H
	DW	0f617H
	DW	03b5H
	DW	0faadH
	DW	0fc2dH
	DW	01666H
_ph_imp_mid_MR795 DW 07642H
	DW	0ef7H
	DW	0f03cH
	DW	0b9cH
	DW	0fbe8H
	DW	0fc16H
	DW	09adH
	DW	0f41dH
	DW	0affH
	DW	0f749H
	DW	06d9H
	DW	0f9b5H
	DW	06b2H
	DW	0f911H
	DW	0607H
	DW	0fc10H
	DW	01adH
	DW	0ff57H
	DW	01d8H
	DW	0fb10H
	DW	0880H
	DW	0f56eH
	DW	09dbH
	DW	0f9abH
	DW	0158H
	DW	033aH
	DW	0fa07H
	DW	06bcH
	DW	0f987H
	DW	06a5H
	DW	0f7f1H
	DW	0a54H
	DW	0f40cH
	DW	0b51H
	DW	0f846H
	DW	022dH
	DW	030cH
	DW	0faa7H
	DW	034aH
	DW	028fH
_ph_imp_low DW	03962H
	DW	02cfeH
	DW	04f4H
	DW	0f537H
	DW	0e9d9H
	DW	01d5aH
	DW	0ffddH
	DW	0f509H
	DW	0f420H
	DW	012d7H
	DW	0b88H
	DW	0df18H
	DW	0ec9H
	DW	05afH
	DW	0883H
	DW	0de43H
	DW	01f73H
	DW	0f7c9H
	DW	0fa52H
	DW	0309H
	DW	0454H
	DW	0f6afH
	DW	08ceH
	DW	0fe95H
	DW	0fd5eH
	DW	0f7c9H
	DW	0179eH
	DW	0e9cfH
	DW	0430H
	DW	0c33H
	DW	0ec3eH
	DW	014c0H
	DW	0f6e7H
	DW	0f170H
	DW	01b0cH
	DW	0f0cfH
	DW	02a3H
	DW	0f911H
	DW	01dH
	DW	027a1H
_ph_imp_mid DW	07642H
	DW	0ef7H
	DW	0f03cH
	DW	0b9cH
	DW	0fbe8H
	DW	0fc16H
	DW	09adH
	DW	0f41dH
	DW	0affH
	DW	0f749H
	DW	06d9H
	DW	0f9b5H
	DW	06b2H
	DW	0f911H
	DW	0607H
	DW	0fc10H
	DW	01adH
	DW	0ff57H
	DW	01d8H
	DW	0fb10H
	DW	0880H
	DW	0f56eH
	DW	09dbH
	DW	0f9abH
	DW	0158H
	DW	033aH
	DW	0fa07H
	DW	06bcH
	DW	0f987H
	DW	06a5H
	DW	0f7f1H
	DW	0a54H
	DW	0f40cH
	DW	0b51H
	DW	0f846H
	DW	022dH
	DW	030cH
	DW	0faa7H
	DW	034aH
	DW	028fH
CONST	ENDS
PUBLIC	_ph_disp_init
PUBLIC	_ph_disp_reset
PUBLIC	_ph_disp_exit
PUBLIC	_ph_disp_lock
PUBLIC	_ph_disp_release
PUBLIC	_ph_disp
PUBLIC	??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@ ; `string'
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_shl:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@ DB 'ph_disp_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@ DB 'ph_disp_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@ DB 'ph_disp_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp
_TEXT	SEGMENT
tv297 = -494						; size = 2
tv273 = -494						; size = 2
_ph_imp$ = -296						; size = 4
_ppos$ = -284						; size = 2
_nPulse$ = -272						; size = 2
_nze$ = -260						; size = 2
_j$ = -248						; size = 2
_ps_poss$ = -236					; size = 80
_inno_sav$ = -148					; size = 80
_impNr$ = -60						; size = 2
_L_temp$ = -48						; size = 4
_tmp1$ = -36						; size = 2
_i1$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_mode$ = 12						; size = 4
_x$ = 16						; size = 4
_cbGain$ = 20						; size = 2
_ltpGain$ = 24						; size = 2
_inno$ = 28						; size = 4
_pitch_fac$ = 32					; size = 2
_tmp_shift$ = 36					; size = 2
_ph_disp PROC						; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 01 00
	00		 sub	 esp, 496		; 000001f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-496]
  00012	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 170  :    Word16 i, i1;
; 171  :    Word16 tmp1;
; 172  :    Word32 L_temp;
; 173  :    Word16 impNr;           /* indicator for amount of disp./filter used */
; 174  : 
; 175  :    Word16 inno_sav[L_SUBFR];
; 176  :    Word16 ps_poss[L_SUBFR];
; 177  :    Word16 j, nze, nPulse, ppos;
; 178  :    const Word16 *ph_imp;   /* Pointer to phase dispersion filter */
; 179  : 
; 180  :    /* Update LTP gain memory */
; 181  :    for (i = PHDGAINMEMSIZE-1; i > 0; i--)

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00031	eb 0c		 jmp	 SHORT $LN43@ph_disp
$LN42@ph_disp:
  00033	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00037	66 83 e8 01	 sub	 ax, 1
  0003b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN43@ph_disp:
  0003f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00043	85 c0		 test	 eax, eax
  00045	7e 1e		 jle	 SHORT $LN41@ph_disp

; 182  :    {
; 183  :        state->gainMem[i] = state->gainMem[i-1];                    move16 ();

  00047	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0004b	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0004f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00052	8b 75 08	 mov	 esi, DWORD PTR _state$[ebp]
  00055	66 8b 44 46 fe	 mov	 ax, WORD PTR [esi+eax*2-2]
  0005a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0005e	e8 00 00 00 00	 call	 _move16

; 184  :    }

  00063	eb ce		 jmp	 SHORT $LN42@ph_disp
$LN41@ph_disp:

; 185  :    state->gainMem[0] = ltpGain;                                    move16 ();

  00065	b8 02 00 00 00	 mov	 eax, 2
  0006a	6b c8 00	 imul	 ecx, eax, 0
  0006d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00070	66 8b 45 18	 mov	 ax, WORD PTR _ltpGain$[ebp]
  00074	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00078	e8 00 00 00 00	 call	 _move16

; 186  :    
; 187  :    /* basic adaption of phase dispersion */
; 188  :    test ();

  0007d	e8 00 00 00 00	 call	 _test

; 189  :    if (sub(ltpGain, PHDTHR2LTP) < 0) {    /* if (ltpGain < 0.9) */

  00082	68 9a 39 00 00	 push	 14746			; 0000399aH
  00087	0f b7 45 18	 movzx	 eax, WORD PTR _ltpGain$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _sub
  00091	83 c4 08	 add	 esp, 8
  00094	0f bf c8	 movsx	 ecx, ax
  00097	85 c9		 test	 ecx, ecx
  00099	7d 3b		 jge	 SHORT $LN40@ph_disp

; 190  :        test ();

  0009b	e8 00 00 00 00	 call	 _test

; 191  :        if (sub(ltpGain, PHDTHR1LTP) > 0)

  000a0	68 66 26 00 00	 push	 9830			; 00002666H
  000a5	0f b7 45 18	 movzx	 eax, WORD PTR _ltpGain$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _sub
  000af	83 c4 08	 add	 esp, 8
  000b2	0f bf c8	 movsx	 ecx, ax
  000b5	85 c9		 test	 ecx, ecx
  000b7	7e 10		 jle	 SHORT $LN39@ph_disp

; 192  :        {  /* if (ltpGain > 0.6 */
; 193  :           impNr = 1; /* medium dispersion */                      move16 ();

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  000c2	e8 00 00 00 00	 call	 _move16

; 194  :        }
; 195  :        else

  000c7	eb 0b		 jmp	 SHORT $LN38@ph_disp
$LN39@ph_disp:

; 196  :        {
; 197  :           impNr = 0; /* maximum dispersion */                     move16 ();

  000c9	33 c0		 xor	 eax, eax
  000cb	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  000cf	e8 00 00 00 00	 call	 _move16
$LN38@ph_disp:

; 198  :        }
; 199  :    }
; 200  :    else

  000d4	eb 0e		 jmp	 SHORT $LN37@ph_disp
$LN40@ph_disp:

; 201  :    {
; 202  :       impNr = 2; /* no dispersion */                              move16 ();

  000d6	b8 02 00 00 00	 mov	 eax, 2
  000db	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  000df	e8 00 00 00 00	 call	 _move16
$LN37@ph_disp:

; 203  :    }
; 204  :    
; 205  :    /* onset indicator */
; 206  :    /* onset = (cbGain  > onFact * cbGainMem[0]) */
; 207  :                                                                    move32 ();

  000e4	e8 00 00 00 00	 call	 _move32

; 208  :    tmp1 = round(L_shl(L_mult(state->prevCbGain, ONFACTPLUS1), 2));

  000e9	6a 02		 push	 2
  000eb	68 00 40 00 00	 push	 16384			; 00004000H
  000f0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000f3	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _L_mult
  000fd	83 c4 08	 add	 esp, 8
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _L_shl
  00106	83 c4 08	 add	 esp, 8
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _round
  0010f	83 c4 04	 add	 esp, 4
  00112	66 89 45 dc	 mov	 WORD PTR _tmp1$[ebp], ax

; 209  :    test ();

  00116	e8 00 00 00 00	 call	 _test

; 210  :    if (sub(cbGain, tmp1) > 0)

  0011b	0f b7 45 dc	 movzx	 eax, WORD PTR _tmp1$[ebp]
  0011f	50		 push	 eax
  00120	0f b7 4d 14	 movzx	 ecx, WORD PTR _cbGain$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 _sub
  0012a	83 c4 08	 add	 esp, 8
  0012d	0f bf d0	 movsx	 edx, ax
  00130	85 d2		 test	 edx, edx
  00132	7e 13		 jle	 SHORT $LN36@ph_disp

; 211  :    {
; 212  :        state->onset = ONLENGTH;                                    move16 ();

  00134	b8 02 00 00 00	 mov	 eax, 2
  00139	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0013c	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
  00140	e8 00 00 00 00	 call	 _move16

; 213  :    }
; 214  :    else

  00145	eb 2e		 jmp	 SHORT $LN35@ph_disp
$LN36@ph_disp:

; 215  :    {
; 216  :        test (); 

  00147	e8 00 00 00 00	 call	 _test

; 217  :        if (state->onset > 0)

  0014c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0014f	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00153	85 c9		 test	 ecx, ecx
  00155	7e 1e		 jle	 SHORT $LN35@ph_disp

; 218  :        {
; 219  :            state->onset = sub (state->onset, 1);                   move16 ();

  00157	6a 01		 push	 1
  00159	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0015c	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _sub
  00166	83 c4 08	 add	 esp, 8
  00169	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0016c	66 89 42 10	 mov	 WORD PTR [edx+16], ax
  00170	e8 00 00 00 00	 call	 _move16
$LN35@ph_disp:

; 220  :        }
; 221  :    }
; 222  :    
; 223  :    /* if not onset, check ltpGain buffer and use max phase dispersion if
; 224  :       half or more of the ltpGain-parameters say so */
; 225  :    test ();

  00175	e8 00 00 00 00	 call	 _test

; 226  :    if (state->onset == 0)

  0017a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0017d	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00181	85 c9		 test	 ecx, ecx
  00183	0f 85 86 00 00
	00		 jne	 $LN33@ph_disp

; 227  :    {
; 228  :        /* Check LTP gain memory and set filter accordingly */
; 229  :        i1 = 0;                                                     move16 ();

  00189	33 c0		 xor	 eax, eax
  0018b	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
  0018f	e8 00 00 00 00	 call	 _move16

; 230  :        for (i = 0; i < PHDGAINMEMSIZE; i++)

  00194	33 c0		 xor	 eax, eax
  00196	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0019a	eb 0c		 jmp	 SHORT $LN32@ph_disp
$LN31@ph_disp:
  0019c	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  001a0	66 83 c0 01	 add	 ax, 1
  001a4	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN32@ph_disp:
  001a8	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001ac	83 f8 05	 cmp	 eax, 5
  001af	7d 38		 jge	 SHORT $LN30@ph_disp

; 231  :        {
; 232  :            test ();

  001b1	e8 00 00 00 00	 call	 _test

; 233  :            if (sub(state->gainMem[i], PHDTHR1LTP) < 0)

  001b6	68 66 26 00 00	 push	 9830			; 00002666H
  001bb	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001bf	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001c2	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 _sub
  001cc	83 c4 08	 add	 esp, 8
  001cf	98		 cwde
  001d0	85 c0		 test	 eax, eax
  001d2	7d 13		 jge	 SHORT $LN29@ph_disp

; 234  :            {
; 235  :                i1 = add (i1, 1);

  001d4	6a 01		 push	 1
  001d6	0f b7 45 e8	 movzx	 eax, WORD PTR _i1$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _add
  001e0	83 c4 08	 add	 esp, 8
  001e3	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
$LN29@ph_disp:

; 236  :            }
; 237  :        }

  001e7	eb b3		 jmp	 SHORT $LN31@ph_disp
$LN30@ph_disp:

; 238  :        test ();

  001e9	e8 00 00 00 00	 call	 _test

; 239  :        if (sub(i1, 2) > 0)

  001ee	6a 02		 push	 2
  001f0	0f b7 45 e8	 movzx	 eax, WORD PTR _i1$[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _sub
  001fa	83 c4 08	 add	 esp, 8
  001fd	0f bf c8	 movsx	 ecx, ax
  00200	85 c9		 test	 ecx, ecx
  00202	7e 0b		 jle	 SHORT $LN33@ph_disp

; 240  :        {
; 241  :            impNr = 0;                                              move16 ();

  00204	33 c0		 xor	 eax, eax
  00206	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  0020a	e8 00 00 00 00	 call	 _move16
$LN33@ph_disp:

; 242  :        }
; 243  :        
; 244  :    }
; 245  :    /* Restrict decrease in phase dispersion to one step if not onset */
; 246  :    test (); test ();

  0020f	e8 00 00 00 00	 call	 _test
  00214	e8 00 00 00 00	 call	 _test

; 247  :    if ((sub(impNr, add(state->prevState, 1)) > 0) && (state->onset == 0))

  00219	6a 01		 push	 1
  0021b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0021e	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 _add
  00228	83 c4 08	 add	 esp, 8
  0022b	0f b7 d0	 movzx	 edx, ax
  0022e	52		 push	 edx
  0022f	0f b7 45 c4	 movzx	 eax, WORD PTR _impNr$[ebp]
  00233	50		 push	 eax
  00234	e8 00 00 00 00	 call	 _sub
  00239	83 c4 08	 add	 esp, 8
  0023c	0f bf c8	 movsx	 ecx, ax
  0023f	85 c9		 test	 ecx, ecx
  00241	7e 1e		 jle	 SHORT $LN27@ph_disp
  00243	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00246	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  0024a	85 c9		 test	 ecx, ecx
  0024c	75 13		 jne	 SHORT $LN27@ph_disp

; 248  :    {
; 249  :        impNr = sub (impNr, 1);

  0024e	6a 01		 push	 1
  00250	0f b7 45 c4	 movzx	 eax, WORD PTR _impNr$[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 _sub
  0025a	83 c4 08	 add	 esp, 8
  0025d	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
$LN27@ph_disp:

; 250  :    }
; 251  :    /* if onset, use one step less phase dispersion */
; 252  :    test (); test ();

  00261	e8 00 00 00 00	 call	 _test
  00266	e8 00 00 00 00	 call	 _test

; 253  :    if((sub(impNr, 2) < 0) && (state->onset > 0))

  0026b	6a 02		 push	 2
  0026d	0f b7 45 c4	 movzx	 eax, WORD PTR _impNr$[ebp]
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 _sub
  00277	83 c4 08	 add	 esp, 8
  0027a	0f bf c8	 movsx	 ecx, ax
  0027d	85 c9		 test	 ecx, ecx
  0027f	7d 1e		 jge	 SHORT $LN26@ph_disp
  00281	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00284	0f bf 48 10	 movsx	 ecx, WORD PTR [eax+16]
  00288	85 c9		 test	 ecx, ecx
  0028a	7e 13		 jle	 SHORT $LN26@ph_disp

; 254  :    {
; 255  :        impNr = add (impNr, 1);

  0028c	6a 01		 push	 1
  0028e	0f b7 45 c4	 movzx	 eax, WORD PTR _impNr$[ebp]
  00292	50		 push	 eax
  00293	e8 00 00 00 00	 call	 _add
  00298	83 c4 08	 add	 esp, 8
  0029b	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
$LN26@ph_disp:

; 256  :    }
; 257  :    
; 258  :    /* disable for very low levels */
; 259  :    test ();

  0029f	e8 00 00 00 00	 call	 _test

; 260  :    if(sub(cbGain, 10) < 0)

  002a4	6a 0a		 push	 10			; 0000000aH
  002a6	0f b7 45 14	 movzx	 eax, WORD PTR _cbGain$[ebp]
  002aa	50		 push	 eax
  002ab	e8 00 00 00 00	 call	 _sub
  002b0	83 c4 08	 add	 esp, 8
  002b3	0f bf c8	 movsx	 ecx, ax
  002b6	85 c9		 test	 ecx, ecx
  002b8	7d 0e		 jge	 SHORT $LN25@ph_disp

; 261  :    {
; 262  :        impNr = 2;                                                  move16 ();

  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  002c3	e8 00 00 00 00	 call	 _move16
$LN25@ph_disp:

; 263  :    }
; 264  :    
; 265  :    test ();

  002c8	e8 00 00 00 00	 call	 _test

; 266  :    if(sub(state->lockFull, 1) == 0)

  002cd	6a 01		 push	 1
  002cf	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  002d2	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  002d6	51		 push	 ecx
  002d7	e8 00 00 00 00	 call	 _sub
  002dc	83 c4 08	 add	 esp, 8
  002df	0f bf d0	 movsx	 edx, ax
  002e2	85 d2		 test	 edx, edx
  002e4	75 0b		 jne	 SHORT $LN24@ph_disp

; 267  :    {
; 268  :        impNr = 0;                                                  move16 ();

  002e6	33 c0		 xor	 eax, eax
  002e8	66 89 45 c4	 mov	 WORD PTR _impNr$[ebp], ax
  002ec	e8 00 00 00 00	 call	 _move16
$LN24@ph_disp:

; 269  :    }
; 270  : 
; 271  :    /* update static memory */
; 272  :    state->prevState = impNr;                                       move16 ();

  002f1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  002f4	66 8b 4d c4	 mov	 cx, WORD PTR _impNr$[ebp]
  002f8	66 89 48 0a	 mov	 WORD PTR [eax+10], cx
  002fc	e8 00 00 00 00	 call	 _move16

; 273  :    state->prevCbGain = cbGain;                                     move16 ();

  00301	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00304	66 8b 4d 14	 mov	 cx, WORD PTR _cbGain$[ebp]
  00308	66 89 48 0c	 mov	 WORD PTR [eax+12], cx
  0030c	e8 00 00 00 00	 call	 _move16

; 274  :   
; 275  :    /* do phase dispersion for all modes but 12.2 and 7.4;
; 276  :       don't modify the innovation if impNr >=2 (= no phase disp) */
; 277  :    test (); test (); test(); test();

  00311	e8 00 00 00 00	 call	 _test
  00316	e8 00 00 00 00	 call	 _test
  0031b	e8 00 00 00 00	 call	 _test
  00320	e8 00 00 00 00	 call	 _test

; 278  :    if (sub(mode, MR122) != 0 && 
; 279  :        sub(mode, MR102) != 0 &&
; 280  :        sub(mode, MR74) != 0 &&
; 281  :        sub(impNr, 2) < 0)

  00325	6a 07		 push	 7
  00327	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 _sub
  00331	83 c4 08	 add	 esp, 8
  00334	0f bf c8	 movsx	 ecx, ax
  00337	85 c9		 test	 ecx, ecx
  00339	0f 84 0b 03 00
	00		 je	 $LN23@ph_disp
  0033f	6a 06		 push	 6
  00341	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 _sub
  0034b	83 c4 08	 add	 esp, 8
  0034e	0f bf c8	 movsx	 ecx, ax
  00351	85 c9		 test	 ecx, ecx
  00353	0f 84 f1 02 00
	00		 je	 $LN23@ph_disp
  00359	6a 04		 push	 4
  0035b	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0035f	50		 push	 eax
  00360	e8 00 00 00 00	 call	 _sub
  00365	83 c4 08	 add	 esp, 8
  00368	0f bf c8	 movsx	 ecx, ax
  0036b	85 c9		 test	 ecx, ecx
  0036d	0f 84 d7 02 00
	00		 je	 $LN23@ph_disp
  00373	6a 02		 push	 2
  00375	0f b7 45 c4	 movzx	 eax, WORD PTR _impNr$[ebp]
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _sub
  0037f	83 c4 08	 add	 esp, 8
  00382	0f bf c8	 movsx	 ecx, ax
  00385	85 c9		 test	 ecx, ecx
  00387	0f 8d bd 02 00
	00		 jge	 $LN23@ph_disp

; 282  :    {
; 283  :        /* track pulse positions, save innovation,
; 284  :           and initialize new innovation          */
; 285  :        nze = 0;                                                    move16 ();

  0038d	33 c0		 xor	 eax, eax
  0038f	66 89 85 fc fe
	ff ff		 mov	 WORD PTR _nze$[ebp], ax
  00396	e8 00 00 00 00	 call	 _move16

; 286  :        for (i = 0; i < L_SUBFR; i++)

  0039b	33 c0		 xor	 eax, eax
  0039d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  003a1	eb 0c		 jmp	 SHORT $LN22@ph_disp
$LN21@ph_disp:
  003a3	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  003a7	66 83 c0 01	 add	 ax, 1
  003ab	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN22@ph_disp:
  003af	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  003b3	83 f8 28	 cmp	 eax, 40			; 00000028H
  003b6	7d 7d		 jge	 SHORT $LN20@ph_disp

; 287  :        {
; 288  :            move16 (); test();

  003b8	e8 00 00 00 00	 call	 _move16
  003bd	e8 00 00 00 00	 call	 _test

; 289  :            if (inno[i] != 0)

  003c2	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  003c6	8b 4d 1c	 mov	 ecx, DWORD PTR _inno$[ebp]
  003c9	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  003cd	85 d2		 test	 edx, edx
  003cf	74 31		 je	 SHORT $LN19@ph_disp

; 290  :            {
; 291  :                ps_poss[nze] = i;                                   move16 ();

  003d1	0f bf 85 fc fe
	ff ff		 movsx	 eax, WORD PTR _nze$[ebp]
  003d8	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  003dc	66 89 8c 45 14
	ff ff ff	 mov	 WORD PTR _ps_poss$[ebp+eax*2], cx
  003e4	e8 00 00 00 00	 call	 _move16

; 292  :                nze = add (nze, 1);

  003e9	6a 01		 push	 1
  003eb	0f b7 85 fc fe
	ff ff		 movzx	 eax, WORD PTR _nze$[ebp]
  003f2	50		 push	 eax
  003f3	e8 00 00 00 00	 call	 _add
  003f8	83 c4 08	 add	 esp, 8
  003fb	66 89 85 fc fe
	ff ff		 mov	 WORD PTR _nze$[ebp], ax
$LN19@ph_disp:

; 293  :            }
; 294  :            inno_sav[i] = inno[i];                                  move16 ();

  00402	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00406	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0040a	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  0040d	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  00411	66 89 84 4d 6c
	ff ff ff	 mov	 WORD PTR _inno_sav$[ebp+ecx*2], ax
  00419	e8 00 00 00 00	 call	 _move16

; 295  :            inno[i] = 0;                                            move16 ();

  0041e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00422	33 c9		 xor	 ecx, ecx
  00424	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  00427	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0042b	e8 00 00 00 00	 call	 _move16

; 296  :        }

  00430	e9 6e ff ff ff	 jmp	 $LN21@ph_disp
$LN20@ph_disp:

; 297  :        /* Choose filter corresponding to codec mode and dispersion criterium */
; 298  :        test ();

  00435	e8 00 00 00 00	 call	 _test

; 299  :        if (sub (mode, MR795) == 0)

  0043a	6a 05		 push	 5
  0043c	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00440	50		 push	 eax
  00441	e8 00 00 00 00	 call	 _sub
  00446	83 c4 08	 add	 esp, 8
  00449	0f bf c8	 movsx	 ecx, ax
  0044c	85 c9		 test	 ecx, ecx
  0044e	75 2f		 jne	 SHORT $LN18@ph_disp

; 300  :        {
; 301  :            test ();

  00450	e8 00 00 00 00	 call	 _test

; 302  :            if (impNr == 0)

  00455	0f bf 45 c4	 movsx	 eax, WORD PTR _impNr$[ebp]
  00459	85 c0		 test	 eax, eax
  0045b	75 11		 jne	 SHORT $LN17@ph_disp

; 303  :            {
; 304  :                ph_imp = ph_imp_low_MR795;                            move16 ();

  0045d	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ph_imp$[ebp], OFFSET _ph_imp_low_MR795
  00467	e8 00 00 00 00	 call	 _move16

; 305  :            }
; 306  :            else

  0046c	eb 0f		 jmp	 SHORT $LN16@ph_disp
$LN17@ph_disp:

; 307  :            {
; 308  :                ph_imp = ph_imp_mid_MR795;                            move16 ();

  0046e	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ph_imp$[ebp], OFFSET _ph_imp_mid_MR795
  00478	e8 00 00 00 00	 call	 _move16
$LN16@ph_disp:

; 309  :            }
; 310  :        }
; 311  :        else

  0047d	eb 2d		 jmp	 SHORT $LN15@ph_disp
$LN18@ph_disp:

; 312  :        {
; 313  :            test ();

  0047f	e8 00 00 00 00	 call	 _test

; 314  :            if (impNr == 0)

  00484	0f bf 45 c4	 movsx	 eax, WORD PTR _impNr$[ebp]
  00488	85 c0		 test	 eax, eax
  0048a	75 11		 jne	 SHORT $LN14@ph_disp

; 315  :            {
; 316  :                ph_imp = ph_imp_low;                                  move16 ();

  0048c	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ph_imp$[ebp], OFFSET _ph_imp_low
  00496	e8 00 00 00 00	 call	 _move16

; 317  :            }
; 318  :            else

  0049b	eb 0f		 jmp	 SHORT $LN15@ph_disp
$LN14@ph_disp:

; 319  :            {
; 320  :                ph_imp = ph_imp_mid;                                  move16 ();

  0049d	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ph_imp$[ebp], OFFSET _ph_imp_mid
  004a7	e8 00 00 00 00	 call	 _move16
$LN15@ph_disp:

; 321  :            }
; 322  :        }
; 323  :        
; 324  :        /* Do phase dispersion of innovation */
; 325  :        for (nPulse = 0; nPulse < nze; nPulse++)

  004ac	33 c0		 xor	 eax, eax
  004ae	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _nPulse$[ebp], ax
  004b5	eb 12		 jmp	 SHORT $LN12@ph_disp
$LN11@ph_disp:
  004b7	66 8b 85 f0 fe
	ff ff		 mov	 ax, WORD PTR _nPulse$[ebp]
  004be	66 83 c0 01	 add	 ax, 1
  004c2	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _nPulse$[ebp], ax
$LN12@ph_disp:
  004c9	0f bf 85 f0 fe
	ff ff		 movsx	 eax, WORD PTR _nPulse$[ebp]
  004d0	0f bf 8d fc fe
	ff ff		 movsx	 ecx, WORD PTR _nze$[ebp]
  004d7	3b c1		 cmp	 eax, ecx
  004d9	0f 8d 6b 01 00
	00		 jge	 $LN23@ph_disp

; 326  :        {
; 327  :            ppos = ps_poss[nPulse];                                   move16 ();

  004df	0f bf 85 f0 fe
	ff ff		 movsx	 eax, WORD PTR _nPulse$[ebp]
  004e6	66 8b 8c 45 14
	ff ff ff	 mov	 cx, WORD PTR _ps_poss$[ebp+eax*2]
  004ee	66 89 8d e4 fe
	ff ff		 mov	 WORD PTR _ppos$[ebp], cx
  004f5	e8 00 00 00 00	 call	 _move16

; 328  :            
; 329  :            /* circular convolution with impulse response */
; 330  :            j = 0;                                                    move16 ();

  004fa	33 c0		 xor	 eax, eax
  004fc	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00503	e8 00 00 00 00	 call	 _move16

; 331  :            for (i = ppos; i < L_SUBFR; i++)

  00508	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR _ppos$[ebp]
  0050f	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00513	eb 0c		 jmp	 SHORT $LN9@ph_disp
$LN8@ph_disp:
  00515	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00519	66 83 c0 01	 add	 ax, 1
  0051d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN9@ph_disp:
  00521	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00525	83 f8 28	 cmp	 eax, 40			; 00000028H
  00528	7d 7c		 jge	 SHORT $LN7@ph_disp

; 332  :            {
; 333  :                /* inno[i1] += inno_sav[ppos] * ph_imp[i1-ppos] */
; 334  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  0052a	0f bf 85 08 ff
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  00531	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _ph_imp$[ebp]
  00537	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0053b	66 89 95 12 fe
	ff ff		 mov	 WORD PTR tv273[ebp], dx
  00542	66 8b 85 08 ff
	ff ff		 mov	 ax, WORD PTR _j$[ebp]
  00549	66 83 c0 01	 add	 ax, 1
  0054d	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00554	0f b7 8d 12 fe
	ff ff		 movzx	 ecx, WORD PTR tv273[ebp]
  0055b	51		 push	 ecx
  0055c	0f bf 95 e4 fe
	ff ff		 movsx	 edx, WORD PTR _ppos$[ebp]
  00563	0f b7 84 55 6c
	ff ff ff	 movzx	 eax, WORD PTR _inno_sav$[ebp+edx*2]
  0056b	50		 push	 eax
  0056c	e8 00 00 00 00	 call	 _mult
  00571	83 c4 08	 add	 esp, 8
  00574	66 89 45 dc	 mov	 WORD PTR _tmp1$[ebp], ax

; 335  :                inno[i] = add(inno[i], tmp1);                         move16 ();

  00578	0f b7 45 dc	 movzx	 eax, WORD PTR _tmp1$[ebp]
  0057c	50		 push	 eax
  0057d	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00581	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  00584	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00588	50		 push	 eax
  00589	e8 00 00 00 00	 call	 _add
  0058e	83 c4 08	 add	 esp, 8
  00591	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00595	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  00598	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0059c	e8 00 00 00 00	 call	 _move16

; 336  :            }    

  005a1	e9 6f ff ff ff	 jmp	 $LN8@ph_disp
$LN7@ph_disp:

; 337  :            
; 338  :            for (i = 0; i < ppos; i++)

  005a6	33 c0		 xor	 eax, eax
  005a8	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  005ac	eb 0c		 jmp	 SHORT $LN6@ph_disp
$LN5@ph_disp:
  005ae	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  005b2	66 83 c0 01	 add	 ax, 1
  005b6	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN6@ph_disp:
  005ba	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  005be	0f bf 8d e4 fe
	ff ff		 movsx	 ecx, WORD PTR _ppos$[ebp]
  005c5	3b c1		 cmp	 eax, ecx
  005c7	7d 7c		 jge	 SHORT $LN4@ph_disp

; 339  :            {
; 340  :                /* inno[i] += inno_sav[ppos] * ph_imp[L_SUBFR-ppos+i] */
; 341  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  005c9	0f bf 85 08 ff
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  005d0	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _ph_imp$[ebp]
  005d6	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  005da	66 89 95 12 fe
	ff ff		 mov	 WORD PTR tv297[ebp], dx
  005e1	66 8b 85 08 ff
	ff ff		 mov	 ax, WORD PTR _j$[ebp]
  005e8	66 83 c0 01	 add	 ax, 1
  005ec	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  005f3	0f b7 8d 12 fe
	ff ff		 movzx	 ecx, WORD PTR tv297[ebp]
  005fa	51		 push	 ecx
  005fb	0f bf 95 e4 fe
	ff ff		 movsx	 edx, WORD PTR _ppos$[ebp]
  00602	0f b7 84 55 6c
	ff ff ff	 movzx	 eax, WORD PTR _inno_sav$[ebp+edx*2]
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 _mult
  00610	83 c4 08	 add	 esp, 8
  00613	66 89 45 dc	 mov	 WORD PTR _tmp1$[ebp], ax

; 342  :                inno[i] = add(inno[i], tmp1);                         move16 ();

  00617	0f b7 45 dc	 movzx	 eax, WORD PTR _tmp1$[ebp]
  0061b	50		 push	 eax
  0061c	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00620	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  00623	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00627	50		 push	 eax
  00628	e8 00 00 00 00	 call	 _add
  0062d	83 c4 08	 add	 esp, 8
  00630	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00634	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  00637	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0063b	e8 00 00 00 00	 call	 _move16

; 343  :            }

  00640	e9 69 ff ff ff	 jmp	 $LN5@ph_disp
$LN4@ph_disp:

; 344  :        }

  00645	e9 6d fe ff ff	 jmp	 $LN11@ph_disp
$LN23@ph_disp:

; 345  :    }
; 346  :        
; 347  :    /* compute total excitation for synthesis part of decoder
; 348  :       (using modified innovation if phase dispersion is active) */
; 349  :    for (i = 0; i < L_SUBFR; i++)

  0064a	33 c0		 xor	 eax, eax
  0064c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00650	eb 0c		 jmp	 SHORT $LN3@ph_disp
$LN2@ph_disp:
  00652	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00656	66 83 c0 01	 add	 ax, 1
  0065a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@ph_disp:
  0065e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00662	83 f8 28	 cmp	 eax, 40			; 00000028H
  00665	7d 71		 jge	 SHORT $LN44@ph_disp

; 350  :    {
; 351  :        /* x[i] = gain_pit*x[i] + cbGain*code[i]; */
; 352  :        L_temp = L_mult (        x[i],    pitch_fac);

  00667	0f b7 45 20	 movzx	 eax, WORD PTR _pitch_fac$[ebp]
  0066b	50		 push	 eax
  0066c	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00670	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  00673	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00677	50		 push	 eax
  00678	e8 00 00 00 00	 call	 _L_mult
  0067d	83 c4 08	 add	 esp, 8
  00680	89 45 d0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 353  :                                                 /* 12.2: Q0 * Q13 */
; 354  :                                                 /*  7.4: Q0 * Q14 */
; 355  :        L_temp = L_mac  (L_temp, inno[i], cbGain);

  00683	0f b7 45 14	 movzx	 eax, WORD PTR _cbGain$[ebp]
  00687	50		 push	 eax
  00688	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0068c	8b 55 1c	 mov	 edx, DWORD PTR _inno$[ebp]
  0068f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00693	50		 push	 eax
  00694	8b 4d d0	 mov	 ecx, DWORD PTR _L_temp$[ebp]
  00697	51		 push	 ecx
  00698	e8 00 00 00 00	 call	 _L_mac
  0069d	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a0	89 45 d0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 356  :                                                 /* 12.2: Q12 * Q1 */
; 357  :                                                 /*  7.4: Q13 * Q1 */
; 358  :        L_temp = L_shl (L_temp, tmp_shift);                 /* Q16 */           

  006a3	0f b7 45 24	 movzx	 eax, WORD PTR _tmp_shift$[ebp]
  006a7	50		 push	 eax
  006a8	8b 4d d0	 mov	 ecx, DWORD PTR _L_temp$[ebp]
  006ab	51		 push	 ecx
  006ac	e8 00 00 00 00	 call	 _L_shl
  006b1	83 c4 08	 add	 esp, 8
  006b4	89 45 d0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 359  :        x[i] = round (L_temp);                                        move16 (); 

  006b7	8b 45 d0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  006ba	50		 push	 eax
  006bb	e8 00 00 00 00	 call	 _round
  006c0	83 c4 04	 add	 esp, 4
  006c3	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  006c7	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  006ca	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  006ce	e8 00 00 00 00	 call	 _move16

; 360  :    }

  006d3	e9 7a ff ff ff	 jmp	 $LN2@ph_disp
$LN44@ph_disp:

; 361  : 
; 362  :    return;
; 363  : }

  006d8	52		 push	 edx
  006d9	8b cd		 mov	 ecx, ebp
  006db	50		 push	 eax
  006dc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN49@ph_disp
  006e2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006e7	58		 pop	 eax
  006e8	5a		 pop	 edx
  006e9	5f		 pop	 edi
  006ea	5e		 pop	 esi
  006eb	5b		 pop	 ebx
  006ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ef	33 cd		 xor	 ecx, ebp
  006f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006f6	81 c4 f0 01 00
	00		 add	 esp, 496		; 000001f0H
  006fc	3b ec		 cmp	 ebp, esp
  006fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00703	8b e5		 mov	 esp, ebp
  00705	5d		 pop	 ebp
  00706	c3		 ret	 0
  00707	90		 npad	 1
$LN49@ph_disp:
  00708	02 00 00 00	 DD	 2
  0070c	00 00 00 00	 DD	 $LN48@ph_disp
$LN48@ph_disp:
  00710	6c ff ff ff	 DD	 -148			; ffffff6cH
  00714	50 00 00 00	 DD	 80			; 00000050H
  00718	00 00 00 00	 DD	 $LN46@ph_disp
  0071c	14 ff ff ff	 DD	 -236			; ffffff14H
  00720	50 00 00 00	 DD	 80			; 00000050H
  00724	00 00 00 00	 DD	 $LN47@ph_disp
$LN47@ph_disp:
  00728	70		 DB	 112			; 00000070H
  00729	73		 DB	 115			; 00000073H
  0072a	5f		 DB	 95			; 0000005fH
  0072b	70		 DB	 112			; 00000070H
  0072c	6f		 DB	 111			; 0000006fH
  0072d	73		 DB	 115			; 00000073H
  0072e	73		 DB	 115			; 00000073H
  0072f	00		 DB	 0
$LN46@ph_disp:
  00730	69		 DB	 105			; 00000069H
  00731	6e		 DB	 110			; 0000006eH
  00732	6e		 DB	 110			; 0000006eH
  00733	6f		 DB	 111			; 0000006fH
  00734	5f		 DB	 95			; 0000005fH
  00735	73		 DB	 115			; 00000073H
  00736	61		 DB	 97			; 00000061H
  00737	76		 DB	 118			; 00000076H
  00738	00		 DB	 0
_ph_disp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_release
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ph_disp_release PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 141  :   state->lockFull = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00023	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 142  :   return;
; 143  : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_ph_disp_release ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_lock
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ph_disp_lock PROC					; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 129  :   state->lockFull = 1;

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 130  :   return;
; 131  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_ph_disp_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ph_disp_exit PROC					; COMDAT

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 112  :   if ((state == NULL) || (*state == NULL))

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@ph_disp_ex
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@ph_disp_ex
$LN1@ph_disp_ex:

; 113  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@ph_disp_ex
$LN2@ph_disp_ex:

; 114  :   
; 115  :   /* deallocate memory */
; 116  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 117  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@ph_disp_ex:

; 118  :   
; 119  :   return;
; 120  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_ph_disp_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_ph_disp_reset PROC					; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 86   :   Word16 i;
; 87   : 
; 88   :    if (state == (ph_dispState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@ph_disp_re

; 89   :       fprintf(stderr, "ph_disp_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 52		 jmp	 SHORT $LN5@ph_disp_re
$LN4@ph_disp_re:

; 91   :    }
; 92   :    for (i=0; i<PHDGAINMEMSIZE; i++)

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN3@ph_disp_re
$LN2@ph_disp_re:
  00061	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@ph_disp_re:
  0006d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00071	83 f8 05	 cmp	 eax, 5
  00074	7d 0f		 jge	 SHORT $LN1@ph_disp_re

; 93   :    {
; 94   :        state->gainMem[i] = 0;

  00076	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	33 c9		 xor	 ecx, ecx
  0007c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0007f	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 95   :    }

  00083	eb dc		 jmp	 SHORT $LN2@ph_disp_re
$LN1@ph_disp_re:

; 96   :    state->prevState = 0;

  00085	33 c0		 xor	 eax, eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 97   :    state->prevCbGain = 0;

  0008e	33 c0		 xor	 eax, eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00093	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 98   :    state->lockFull = 0;

  00097	33 c0		 xor	 eax, eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0009c	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 99   :    state->onset = 0;          /* assume no onset in start */ 

  000a0	33 c0		 xor	 eax, eax
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a5	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 100  : 
; 101  :    return 0;

  000a9	33 c0		 xor	 eax, eax
$LN5@ph_disp_re:

; 102  : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_ph_disp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_ph_disp_init PROC					; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 58   :   ph_dispState *s;
; 59   : 
; 60   :   if (state == (ph_dispState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@ph_disp_in

; 61   :       fprintf(stderr, "ph_disp_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@ph_disp_in
$LN2@ph_disp_in:

; 63   :   }
; 64   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 65   : 
; 66   :   /* allocate memory */
; 67   :   if ((s= (ph_dispState *) malloc(sizeof(ph_dispState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 12		 push	 18			; 00000012H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@ph_disp_in

; 68   :       fprintf(stderr, "ph_disp_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@ph_disp_in
$LN1@ph_disp_in:

; 70   :   }
; 71   :   ph_disp_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _ph_disp_reset
  000bd	83 c4 04	 add	 esp, 4

; 72   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 73   : 
; 74   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@ph_disp_in:

; 75   :   
; 76   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_ph_disp_init ENDP
_TEXT	ENDS
END
