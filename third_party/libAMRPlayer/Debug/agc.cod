; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\agc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_agc_id
CONST	SEGMENT
_agc_id	DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_agc_init
PUBLIC	_agc_reset
PUBLIC	_agc_exit
PUBLIC	_agc
PUBLIC	_agc2
PUBLIC	??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@ ; `string'
PUBLIC	??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_deposit_l:PROC
EXTRN	_div_s:PROC
EXTRN	_norm_l:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Inv_sqrt:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_Overflow:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@ DB 'agc_reset: '
	DB	'invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@
CONST	SEGMENT
??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@ DB 'agc_init: c'
	DB	'an not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@ DB 'agc_init: in'
	DB	'valid parameter', 0aH, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _energy_new
_TEXT	SEGMENT
_ov_save$ = -32						; size = 4
_i$ = -20						; size = 2
_s$ = -8						; size = 4
_in$ = 8						; size = 4
_l_trm$ = 12						; size = 2
_energy_new PROC					; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 73   :     Word32 s;
; 74   :     Word16 i;
; 75   :     Flag ov_save;
; 76   : 
; 77   :     ov_save = Overflow; move16 (); /* save overflow flag in case energy_old */

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR _Overflow
  00023	89 45 e0	 mov	 DWORD PTR _ov_save$[ebp], eax
  00026	e8 00 00 00 00	 call	 _move16

; 78   :                                    /* must be called                        */
; 79   :     s = L_mult(in[0], in[0]);

  0002b	b8 02 00 00 00	 mov	 eax, 2
  00030	6b c8 00	 imul	 ecx, eax, 0
  00033	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00036	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0003a	50		 push	 eax
  0003b	b9 02 00 00 00	 mov	 ecx, 2
  00040	6b d1 00	 imul	 edx, ecx, 0
  00043	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00046	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _L_mult
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 80   :     for (i = 1; i < l_trm; i++)

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN5@energy_new
$LN4@energy_new:
  00061	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN5@energy_new:
  0006d	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00071	0f bf 4d 0c	 movsx	 ecx, WORD PTR _l_trm$[ebp]
  00075	3b c1		 cmp	 eax, ecx
  00077	7d 29		 jge	 SHORT $LN3@energy_new

; 81   :     {
; 82   :         s = L_mac(s, in[i], in[i]);

  00079	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00080	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00084	52		 push	 edx
  00085	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  0008c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00090	52		 push	 edx
  00091	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _L_mac
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 83   :     }

  000a0	eb bf		 jmp	 SHORT $LN4@energy_new
$LN3@energy_new:

; 84   :     
; 85   :     /* check for overflow */
; 86   :     test (); 

  000a2	e8 00 00 00 00	 call	 _test

; 87   :     if (L_sub (s, MAX_32) == 0L)

  000a7	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _L_sub
  000b5	83 c4 08	 add	 esp, 8
  000b8	85 c0		 test	 eax, eax
  000ba	75 28		 jne	 SHORT $LN2@energy_new

; 88   :     {
; 89   :         Overflow = ov_save; move16 (); /* restore overflow flag */

  000bc	8b 45 e0	 mov	 eax, DWORD PTR _ov_save$[ebp]
  000bf	a3 00 00 00 00	 mov	 DWORD PTR _Overflow, eax
  000c4	e8 00 00 00 00	 call	 _move16

; 90   :         s = energy_old (in, l_trm); move32 (); /* function result */

  000c9	0f b7 45 0c	 movzx	 eax, WORD PTR _l_trm$[ebp]
  000cd	50		 push	 eax
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 _energy_old
  000d7	83 c4 08	 add	 esp, 8
  000da	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  000dd	e8 00 00 00 00	 call	 _move32

; 91   :     }
; 92   :     else

  000e2	eb 11		 jmp	 SHORT $LN1@energy_new
$LN2@energy_new:

; 93   :     {
; 94   :        s = L_shr(s, 4);

  000e4	6a 04		 push	 4
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _L_shr
  000ef	83 c4 08	 add	 esp, 8
  000f2	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
$LN1@energy_new:

; 95   :     }
; 96   : 
; 97   :     return s;

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]

; 98   : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00101	3b ec		 cmp	 ebp, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_energy_new ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _energy_old
_TEXT	SEGMENT
_temp$ = -32						; size = 2
_i$ = -20						; size = 2
_s$ = -8						; size = 4
_in$ = 8						; size = 4
_l_trm$ = 12						; size = 2
_energy_old PROC					; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 53   :     Word32 s;
; 54   :     Word16 i, temp;
; 55   : 
; 56   :     temp = shr (in[0], 2);

  0001e	6a 02		 push	 2
  00020	b8 02 00 00 00	 mov	 eax, 2
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  0002b	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _shr
  00035	83 c4 08	 add	 esp, 8
  00038	66 89 45 e0	 mov	 WORD PTR _temp$[ebp], ax

; 57   :     s = L_mult (temp, temp);

  0003c	0f b7 45 e0	 movzx	 eax, WORD PTR _temp$[ebp]
  00040	50		 push	 eax
  00041	0f b7 4d e0	 movzx	 ecx, WORD PTR _temp$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _L_mult
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 58   :     
; 59   :     for (i = 1; i < l_trm; i++)

  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  0005a	eb 0c		 jmp	 SHORT $LN3@energy_old
$LN2@energy_old:
  0005c	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  00060	66 83 c0 01	 add	 ax, 1
  00064	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN3@energy_old:
  00068	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  0006c	0f bf 4d 0c	 movsx	 ecx, WORD PTR _l_trm$[ebp]
  00070	3b c1		 cmp	 eax, ecx
  00072	7d 35		 jge	 SHORT $LN1@energy_old

; 60   :     {
; 61   :         temp = shr (in[i], 2);

  00074	6a 02		 push	 2
  00076	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  0007d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _shr
  00087	83 c4 08	 add	 esp, 8
  0008a	66 89 45 e0	 mov	 WORD PTR _temp$[ebp], ax

; 62   :         s = L_mac (s, temp, temp);

  0008e	0f b7 45 e0	 movzx	 eax, WORD PTR _temp$[ebp]
  00092	50		 push	 eax
  00093	0f b7 4d e0	 movzx	 ecx, WORD PTR _temp$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 _L_mac
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 63   :     }

  000a7	eb b3		 jmp	 SHORT $LN2@energy_old
$LN1@energy_old:

; 64   : 
; 65   :     return s;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]

; 66   : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_energy_old ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc2
_TEXT	SEGMENT
_s$ = -68						; size = 4
_g0$ = -56						; size = 2
_gain_out$ = -44					; size = 2
_gain_in$ = -32						; size = 2
_exp$ = -20						; size = 2
_i$ = -8						; size = 2
_sig_in$ = 8						; size = 4
_sig_out$ = 12						; size = 4
_l_trm$ = 16						; size = 2
_agc2	PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 269  :     Word16 i, exp;
; 270  :     Word16 gain_in, gain_out, g0;
; 271  :     Word32 s;
; 272  :     
; 273  :     /* calculate gain_out with exponent */
; 274  :     s = energy_new(sig_out, l_trm);   move32 (); /* function result */

  0001e	0f b7 45 10	 movzx	 eax, WORD PTR _l_trm$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _sig_out$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _energy_new
  0002c	83 c4 08	 add	 esp, 8
  0002f	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax
  00032	e8 00 00 00 00	 call	 _move32

; 275  :         
; 276  :     test (); 

  00037	e8 00 00 00 00	 call	 _test

; 277  :     if (s == 0)

  0003c	83 7d bc 00	 cmp	 DWORD PTR _s$[ebp], 0
  00040	75 05		 jne	 SHORT $LN6@agc2

; 278  :     {
; 279  :         return;

  00042	e9 88 01 00 00	 jmp	 $LN7@agc2
$LN6@agc2:

; 280  :     }
; 281  :     exp = sub (norm_l (s), 1);

  00047	6a 01		 push	 1
  00049	8b 45 bc	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _norm_l
  00052	83 c4 04	 add	 esp, 4
  00055	0f b7 c8	 movzx	 ecx, ax
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _sub
  0005e	83 c4 08	 add	 esp, 8
  00061	66 89 45 ec	 mov	 WORD PTR _exp$[ebp], ax

; 282  :     gain_out = round (L_shl (s, exp));

  00065	0f b7 45 ec	 movzx	 eax, WORD PTR _exp$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d bc	 mov	 ecx, DWORD PTR _s$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _L_shl
  00073	83 c4 08	 add	 esp, 8
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _round
  0007c	83 c4 04	 add	 esp, 4
  0007f	66 89 45 d4	 mov	 WORD PTR _gain_out$[ebp], ax

; 283  : 
; 284  :     /* calculate gain_in with exponent */
; 285  :     s = energy_new(sig_in, l_trm);   move32 (); /* function result */

  00083	0f b7 45 10	 movzx	 eax, WORD PTR _l_trm$[ebp]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _sig_in$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _energy_new
  00091	83 c4 08	 add	 esp, 8
  00094	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax
  00097	e8 00 00 00 00	 call	 _move32

; 286  :     
; 287  :     test (); 

  0009c	e8 00 00 00 00	 call	 _test

; 288  :     if (s == 0)

  000a1	83 7d bc 00	 cmp	 DWORD PTR _s$[ebp], 0
  000a5	75 10		 jne	 SHORT $LN5@agc2

; 289  :     {
; 290  :         g0 = 0;                 move16 (); 

  000a7	33 c0		 xor	 eax, eax
  000a9	66 89 45 c8	 mov	 WORD PTR _g0$[ebp], ax
  000ad	e8 00 00 00 00	 call	 _move16

; 291  :     }
; 292  :     else

  000b2	e9 b9 00 00 00	 jmp	 $LN4@agc2
$LN5@agc2:

; 293  :     {
; 294  :         i = norm_l (s);

  000b7	8b 45 bc	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _norm_l
  000c0	83 c4 04	 add	 esp, 4
  000c3	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 295  :         gain_in = round (L_shl (s, i));

  000c7	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d bc	 mov	 ecx, DWORD PTR _s$[ebp]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _L_shl
  000d5	83 c4 08	 add	 esp, 8
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _round
  000de	83 c4 04	 add	 esp, 4
  000e1	66 89 45 e0	 mov	 WORD PTR _gain_in$[ebp], ax

; 296  :         exp = sub (exp, i);

  000e5	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000e9	50		 push	 eax
  000ea	0f b7 4d ec	 movzx	 ecx, WORD PTR _exp$[ebp]
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 _sub
  000f4	83 c4 08	 add	 esp, 8
  000f7	66 89 45 ec	 mov	 WORD PTR _exp$[ebp], ax

; 297  : 
; 298  :         /*---------------------------------------------------*
; 299  :          *  g0 = sqrt(gain_in/gain_out);                     *
; 300  :          *---------------------------------------------------*/
; 301  : 
; 302  :         s = L_deposit_l (div_s (gain_out, gain_in));

  000fb	0f b7 45 e0	 movzx	 eax, WORD PTR _gain_in$[ebp]
  000ff	50		 push	 eax
  00100	0f b7 4d d4	 movzx	 ecx, WORD PTR _gain_out$[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 _div_s
  0010a	83 c4 08	 add	 esp, 8
  0010d	0f b7 d0	 movzx	 edx, ax
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 _L_deposit_l
  00116	83 c4 04	 add	 esp, 4
  00119	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax

; 303  :         s = L_shl (s, 7);       /* s = gain_out / gain_in */

  0011c	6a 07		 push	 7
  0011e	8b 45 bc	 mov	 eax, DWORD PTR _s$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _L_shl
  00127	83 c4 08	 add	 esp, 8
  0012a	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax

; 304  :         s = L_shr (s, exp);     /* add exponent */

  0012d	0f b7 45 ec	 movzx	 eax, WORD PTR _exp$[ebp]
  00131	50		 push	 eax
  00132	8b 4d bc	 mov	 ecx, DWORD PTR _s$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 _L_shr
  0013b	83 c4 08	 add	 esp, 8
  0013e	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax

; 305  : 
; 306  :         s = Inv_sqrt (s); move32 (); /* function result */

  00141	8b 45 bc	 mov	 eax, DWORD PTR _s$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _Inv_sqrt
  0014a	83 c4 04	 add	 esp, 4
  0014d	89 45 bc	 mov	 DWORD PTR _s$[ebp], eax
  00150	e8 00 00 00 00	 call	 _move32

; 307  :         g0 = round (L_shl (s, 9));

  00155	6a 09		 push	 9
  00157	8b 45 bc	 mov	 eax, DWORD PTR _s$[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _L_shl
  00160	83 c4 08	 add	 esp, 8
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 _round
  00169	83 c4 04	 add	 esp, 4
  0016c	66 89 45 c8	 mov	 WORD PTR _g0$[ebp], ax
$LN4@agc2:

; 308  :     }
; 309  : 
; 310  :     /* sig_out(n) = gain(n) sig_out(n) */
; 311  : 
; 312  :     for (i = 0; i < l_trm; i++)

  00170	33 c0		 xor	 eax, eax
  00172	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00176	eb 0c		 jmp	 SHORT $LN3@agc2
$LN2@agc2:
  00178	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0017c	66 83 c0 01	 add	 ax, 1
  00180	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@agc2:
  00184	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00188	0f bf 4d 10	 movsx	 ecx, WORD PTR _l_trm$[ebp]
  0018c	3b c1		 cmp	 eax, ecx
  0018e	7d 3f		 jge	 SHORT $LN7@agc2

; 313  :     {
; 314  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], g0), 3));

  00190	6a 03		 push	 3
  00192	0f b7 45 c8	 movzx	 eax, WORD PTR _g0$[ebp]
  00196	50		 push	 eax
  00197	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0019b	8b 55 0c	 mov	 edx, DWORD PTR _sig_out$[ebp]
  0019e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _L_mult
  001a8	83 c4 08	 add	 esp, 8
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 _L_shl
  001b1	83 c4 08	 add	 esp, 8
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _extract_h
  001ba	83 c4 04	 add	 esp, 4
  001bd	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  001c1	8b 55 0c	 mov	 edx, DWORD PTR _sig_out$[ebp]
  001c4	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 315  :                                 move16 (); 

  001c8	e8 00 00 00 00	 call	 _move16

; 316  :     }

  001cd	eb a9		 jmp	 SHORT $LN2@agc2
$LN7@agc2:

; 317  : 
; 318  :     return;
; 319  : }

  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	5b		 pop	 ebx
  001d2	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  001d8	3b ec		 cmp	 ebp, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
_agc2	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc
_TEXT	SEGMENT
_s$ = -80						; size = 4
_gain$ = -68						; size = 2
_g0$ = -56						; size = 2
_gain_out$ = -44					; size = 2
_gain_in$ = -32						; size = 2
_exp$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_sig_in$ = 12						; size = 4
_sig_out$ = 16						; size = 4
_agc_fac$ = 20						; size = 2
_l_trm$ = 24						; size = 2
_agc	PROC						; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 191  :     Word16 i, exp;
; 192  :     Word16 gain_in, gain_out, g0, gain;
; 193  :     Word32 s;
; 194  :             
; 195  :     /* calculate gain_out with exponent */
; 196  :     s = energy_new(sig_out, l_trm); move32 (); /* function result */

  0001e	0f b7 45 18	 movzx	 eax, WORD PTR _l_trm$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 10	 mov	 ecx, DWORD PTR _sig_out$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _energy_new
  0002c	83 c4 08	 add	 esp, 8
  0002f	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax
  00032	e8 00 00 00 00	 call	 _move32

; 197  :         
; 198  :     test (); 

  00037	e8 00 00 00 00	 call	 _test

; 199  :     if (s == 0)

  0003c	83 7d b0 00	 cmp	 DWORD PTR _s$[ebp], 0
  00040	75 14		 jne	 SHORT $LN6@agc

; 200  :     {
; 201  :         st->past_gain = 0;          move16 (); 

  00042	33 c0		 xor	 eax, eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00047	66 89 01	 mov	 WORD PTR [ecx], ax
  0004a	e8 00 00 00 00	 call	 _move16

; 202  :         return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 fe 01 00 00	 jmp	 $LN7@agc
$LN6@agc:

; 203  :     }
; 204  :     exp = sub (norm_l (s), 1);

  00056	6a 01		 push	 1
  00058	8b 45 b0	 mov	 eax, DWORD PTR _s$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _norm_l
  00061	83 c4 04	 add	 esp, 4
  00064	0f b7 c8	 movzx	 ecx, ax
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _sub
  0006d	83 c4 08	 add	 esp, 8
  00070	66 89 45 ec	 mov	 WORD PTR _exp$[ebp], ax

; 205  :     gain_out = round (L_shl (s, exp));

  00074	0f b7 45 ec	 movzx	 eax, WORD PTR _exp$[ebp]
  00078	50		 push	 eax
  00079	8b 4d b0	 mov	 ecx, DWORD PTR _s$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 _L_shl
  00082	83 c4 08	 add	 esp, 8
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _round
  0008b	83 c4 04	 add	 esp, 4
  0008e	66 89 45 d4	 mov	 WORD PTR _gain_out$[ebp], ax

; 206  : 
; 207  :     /* calculate gain_in with exponent */
; 208  :     s = energy_new(sig_in, l_trm);   move32 (); /* function result */

  00092	0f b7 45 18	 movzx	 eax, WORD PTR _l_trm$[ebp]
  00096	50		 push	 eax
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _sig_in$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _energy_new
  000a0	83 c4 08	 add	 esp, 8
  000a3	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax
  000a6	e8 00 00 00 00	 call	 _move32

; 209  :     
; 210  :     test (); 

  000ab	e8 00 00 00 00	 call	 _test

; 211  :     if (s == 0)

  000b0	83 7d b0 00	 cmp	 DWORD PTR _s$[ebp], 0
  000b4	75 10		 jne	 SHORT $LN5@agc

; 212  :     {
; 213  :         g0 = 0;                 move16 (); 

  000b6	33 c0		 xor	 eax, eax
  000b8	66 89 45 c8	 mov	 WORD PTR _g0$[ebp], ax
  000bc	e8 00 00 00 00	 call	 _move16

; 214  :     }
; 215  :     else

  000c1	e9 e0 00 00 00	 jmp	 $LN4@agc
$LN5@agc:

; 216  :     {
; 217  :         i = norm_l (s);

  000c6	8b 45 b0	 mov	 eax, DWORD PTR _s$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _norm_l
  000cf	83 c4 04	 add	 esp, 4
  000d2	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 218  :         gain_in = round (L_shl (s, i));

  000d6	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000da	50		 push	 eax
  000db	8b 4d b0	 mov	 ecx, DWORD PTR _s$[ebp]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 _L_shl
  000e4	83 c4 08	 add	 esp, 8
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _round
  000ed	83 c4 04	 add	 esp, 4
  000f0	66 89 45 e0	 mov	 WORD PTR _gain_in$[ebp], ax

; 219  :         exp = sub (exp, i);

  000f4	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000f8	50		 push	 eax
  000f9	0f b7 4d ec	 movzx	 ecx, WORD PTR _exp$[ebp]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _sub
  00103	83 c4 08	 add	 esp, 8
  00106	66 89 45 ec	 mov	 WORD PTR _exp$[ebp], ax

; 220  : 
; 221  :         /*---------------------------------------------------*
; 222  :          *  g0 = (1-agc_fac) * sqrt(gain_in/gain_out);       *
; 223  :          *---------------------------------------------------*/
; 224  : 
; 225  :         s = L_deposit_l (div_s (gain_out, gain_in));

  0010a	0f b7 45 e0	 movzx	 eax, WORD PTR _gain_in$[ebp]
  0010e	50		 push	 eax
  0010f	0f b7 4d d4	 movzx	 ecx, WORD PTR _gain_out$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 _div_s
  00119	83 c4 08	 add	 esp, 8
  0011c	0f b7 d0	 movzx	 edx, ax
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _L_deposit_l
  00125	83 c4 04	 add	 esp, 4
  00128	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax

; 226  :         s = L_shl (s, 7);       /* s = gain_out / gain_in */

  0012b	6a 07		 push	 7
  0012d	8b 45 b0	 mov	 eax, DWORD PTR _s$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _L_shl
  00136	83 c4 08	 add	 esp, 8
  00139	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax

; 227  :         s = L_shr (s, exp);     /* add exponent */

  0013c	0f b7 45 ec	 movzx	 eax, WORD PTR _exp$[ebp]
  00140	50		 push	 eax
  00141	8b 4d b0	 mov	 ecx, DWORD PTR _s$[ebp]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 _L_shr
  0014a	83 c4 08	 add	 esp, 8
  0014d	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax

; 228  : 
; 229  :         s = Inv_sqrt (s); move32 (); /* function result */

  00150	8b 45 b0	 mov	 eax, DWORD PTR _s$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _Inv_sqrt
  00159	83 c4 04	 add	 esp, 4
  0015c	89 45 b0	 mov	 DWORD PTR _s$[ebp], eax
  0015f	e8 00 00 00 00	 call	 _move32

; 230  :         i = round (L_shl (s, 9));

  00164	6a 09		 push	 9
  00166	8b 45 b0	 mov	 eax, DWORD PTR _s$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _L_shl
  0016f	83 c4 08	 add	 esp, 8
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _round
  00178	83 c4 04	 add	 esp, 4
  0017b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 231  : 
; 232  :         /* g0 = i * (1-agc_fac) */
; 233  :         g0 = mult (i, sub (32767, agc_fac));

  0017f	0f b7 45 14	 movzx	 eax, WORD PTR _agc_fac$[ebp]
  00183	50		 push	 eax
  00184	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00189	e8 00 00 00 00	 call	 _sub
  0018e	83 c4 08	 add	 esp, 8
  00191	0f b7 c8	 movzx	 ecx, ax
  00194	51		 push	 ecx
  00195	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  00199	52		 push	 edx
  0019a	e8 00 00 00 00	 call	 _mult
  0019f	83 c4 08	 add	 esp, 8
  001a2	66 89 45 c8	 mov	 WORD PTR _g0$[ebp], ax
$LN4@agc:

; 234  :     }
; 235  : 
; 236  :     /* compute gain[n] = agc_fac * gain[n-1]
; 237  :                         + (1-agc_fac) * sqrt(gain_in/gain_out) */
; 238  :     /* sig_out[n] = gain[n] * sig_out[n]                        */
; 239  : 
; 240  :     gain = st->past_gain;           move16 (); 

  001a6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001a9	66 8b 08	 mov	 cx, WORD PTR [eax]
  001ac	66 89 4d bc	 mov	 WORD PTR _gain$[ebp], cx
  001b0	e8 00 00 00 00	 call	 _move16

; 241  : 
; 242  :     for (i = 0; i < l_trm; i++)

  001b5	33 c0		 xor	 eax, eax
  001b7	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  001bb	eb 0c		 jmp	 SHORT $LN3@agc
$LN2@agc:
  001bd	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  001c1	66 83 c0 01	 add	 ax, 1
  001c5	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@agc:
  001c9	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001cd	0f bf 4d 18	 movsx	 ecx, WORD PTR _l_trm$[ebp]
  001d1	3b c1		 cmp	 eax, ecx
  001d3	7d 6e		 jge	 SHORT $LN1@agc

; 243  :     {
; 244  :         gain = mult (gain, agc_fac);

  001d5	0f b7 45 14	 movzx	 eax, WORD PTR _agc_fac$[ebp]
  001d9	50		 push	 eax
  001da	0f b7 4d bc	 movzx	 ecx, WORD PTR _gain$[ebp]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 _mult
  001e4	83 c4 08	 add	 esp, 8
  001e7	66 89 45 bc	 mov	 WORD PTR _gain$[ebp], ax

; 245  :         gain = add (gain, g0);

  001eb	0f b7 45 c8	 movzx	 eax, WORD PTR _g0$[ebp]
  001ef	50		 push	 eax
  001f0	0f b7 4d bc	 movzx	 ecx, WORD PTR _gain$[ebp]
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _add
  001fa	83 c4 08	 add	 esp, 8
  001fd	66 89 45 bc	 mov	 WORD PTR _gain$[ebp], ax

; 246  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], gain), 3));

  00201	6a 03		 push	 3
  00203	0f b7 45 bc	 movzx	 eax, WORD PTR _gain$[ebp]
  00207	50		 push	 eax
  00208	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0020c	8b 55 10	 mov	 edx, DWORD PTR _sig_out$[ebp]
  0020f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _L_mult
  00219	83 c4 08	 add	 esp, 8
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 _L_shl
  00222	83 c4 08	 add	 esp, 8
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 _extract_h
  0022b	83 c4 04	 add	 esp, 4
  0022e	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00232	8b 55 10	 mov	 edx, DWORD PTR _sig_out$[ebp]
  00235	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 247  :                                 move16 (); 

  00239	e8 00 00 00 00	 call	 _move16

; 248  :     }

  0023e	e9 7a ff ff ff	 jmp	 $LN2@agc
$LN1@agc:

; 249  : 
; 250  :     st->past_gain = gain;           move16 (); 

  00243	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00246	66 8b 4d bc	 mov	 cx, WORD PTR _gain$[ebp]
  0024a	66 89 08	 mov	 WORD PTR [eax], cx
  0024d	e8 00 00 00 00	 call	 _move16

; 251  : 
; 252  :     return 0;

  00252	33 c0		 xor	 eax, eax
$LN7@agc:

; 253  : }

  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	5b		 pop	 ebx
  00257	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0025d	3b ec		 cmp	 ebp, esp
  0025f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
_agc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_agc_exit PROC						; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 165  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@agc_exit
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@agc_exit
$LN1@agc_exit:

; 166  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@agc_exit
$LN2@agc_exit:

; 167  :  
; 168  :   /* deallocate memory */
; 169  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 170  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@agc_exit:

; 171  :   
; 172  :   return;
; 173  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_agc_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_agc_reset PROC						; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 145  :   if (state == (agcState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@agc_reset

; 146  :       fprintf(stderr, "agc_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 147  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 0d		 jmp	 SHORT $LN2@agc_reset
$LN1@agc_reset:

; 148  :   }
; 149  :   
; 150  :   state->past_gain = 4096;   /* initial value of past_gain = 1.0  */

  00059	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00061	66 89 01	 mov	 WORD PTR [ecx], ax

; 151  :   
; 152  :   return 0;

  00064	33 c0		 xor	 eax, eax
$LN2@agc_reset:

; 153  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_agc_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_agc_init PROC						; COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 115  :   agcState* s;
; 116  :  
; 117  :   if (state == (agcState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@agc_init

; 118  :       fprintf(stderr, "agc_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 119  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@agc_init
$LN2@agc_init:

; 120  :   }
; 121  :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 122  :  
; 123  :   /* allocate memory */
; 124  :   if ((s= (agcState *) malloc(sizeof(agcState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 02		 push	 2
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@agc_init

; 125  :       fprintf(stderr, "agc_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 126  :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@agc_init
$LN1@agc_init:

; 127  :   }
; 128  :   
; 129  :   agc_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _agc_reset
  000bd	83 c4 04	 add	 esp, 4

; 130  :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 131  :   
; 132  :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@agc_init:

; 133  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_agc_init ENDP
_TEXT	ENDS
END
