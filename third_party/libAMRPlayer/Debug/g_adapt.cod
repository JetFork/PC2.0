; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\g_adapt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_adapt_id
CONST	SEGMENT
_g_adapt_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_gain_adapt_init
PUBLIC	_gain_adapt_reset
PUBLIC	_gain_adapt_exit
PUBLIC	_gain_adapt
PUBLIC	??_C@_0CE@KLNEPGIP@gain_adapt_init?3?5invalid?5paramet@ ; `string'
PUBLIC	??_C@_0CP@ODPCGCFH@gain_adapt_init?3?5can?8t?5malloc?5st@ ; `string'
PUBLIC	??_C@_0CF@ODACHLCM@gain_adapt_reset?3?5invalid?5parame@ ; `string'
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_shr_r:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_gmed_n:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CF@ODACHLCM@gain_adapt_reset?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@ODACHLCM@gain_adapt_reset?3?5invalid?5parame@ DB 'gain_adapt_re'
	DB	'set: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODPCGCFH@gain_adapt_init?3?5can?8t?5malloc?5st@
CONST	SEGMENT
??_C@_0CP@ODPCGCFH@gain_adapt_init?3?5can?8t?5malloc?5st@ DB 'gain_adapt_'
	DB	'init: can''t malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KLNEPGIP@gain_adapt_init?3?5invalid?5paramet@
CONST	SEGMENT
??_C@_0CE@KLNEPGIP@gain_adapt_init?3?5invalid?5paramet@ DB 'gain_adapt_in'
	DB	'it: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\g_adapt.c
;	COMDAT _gain_adapt
_TEXT	SEGMENT
_i$ = -56						; size = 2
_tmp$ = -44						; size = 2
_filt$ = -32						; size = 2
_result$ = -20						; size = 2
_adapt$ = -8						; size = 2
_st$ = 8						; size = 4
_ltpg$ = 12						; size = 2
_gain_cod$ = 16						; size = 2
_alpha$ = 20						; size = 4
_gain_adapt PROC					; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 142  :     Word16 adapt;      /* adaptdation status; 0, 1, or 2       */
; 143  :     Word16 result;     /* alpha factor, Q13                    */
; 144  :     Word16 filt;       /* median-filtered LTP coding gain, Q13 */
; 145  :     Word16 tmp, i;
; 146  :     
; 147  :     /* basic adaptation */
; 148  :     test ();

  0001e	e8 00 00 00 00	 call	 _test

; 149  :     if (sub (ltpg, LTP_GAIN_THR1) <= 0)

  00023	68 a1 0a 00 00	 push	 2721			; 00000aa1H
  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _ltpg$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _sub
  00032	83 c4 08	 add	 esp, 8
  00035	0f bf c8	 movsx	 ecx, ax
  00038	85 c9		 test	 ecx, ecx
  0003a	7f 0d		 jg	 SHORT $LN18@gain_adapt

; 150  :     {
; 151  :         adapt = 0;                            move16 ();

  0003c	33 c0		 xor	 eax, eax
  0003e	66 89 45 f8	 mov	 WORD PTR _adapt$[ebp], ax
  00042	e8 00 00 00 00	 call	 _move16

; 152  :     }
; 153  :     else

  00047	eb 3c		 jmp	 SHORT $LN17@gain_adapt
$LN18@gain_adapt:

; 154  :     {
; 155  :         test ();

  00049	e8 00 00 00 00	 call	 _test

; 156  :         if (sub (ltpg, LTP_GAIN_THR2) <= 0)

  0004e	68 43 15 00 00	 push	 5443			; 00001543H
  00053	0f b7 45 0c	 movzx	 eax, WORD PTR _ltpg$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _sub
  0005d	83 c4 08	 add	 esp, 8
  00060	0f bf c8	 movsx	 ecx, ax
  00063	85 c9		 test	 ecx, ecx
  00065	7f 10		 jg	 SHORT $LN16@gain_adapt

; 157  :         {
; 158  :             adapt = 1;                        move16 ();

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	66 89 45 f8	 mov	 WORD PTR _adapt$[ebp], ax
  00070	e8 00 00 00 00	 call	 _move16

; 159  :         }
; 160  :         else

  00075	eb 0e		 jmp	 SHORT $LN17@gain_adapt
$LN16@gain_adapt:

; 161  :         {
; 162  :             adapt = 2;                        move16 ();

  00077	b8 02 00 00 00	 mov	 eax, 2
  0007c	66 89 45 f8	 mov	 WORD PTR _adapt$[ebp], ax
  00080	e8 00 00 00 00	 call	 _move16
$LN17@gain_adapt:

; 163  :         }
; 164  :     }
; 165  : 
; 166  :     /*
; 167  :      * // onset indicator
; 168  :      * if ((cbGain > onFact * cbGainMem[0]) && (cbGain > 100.0))
; 169  :      *     onset = 8;
; 170  :      * else
; 171  :      *     if (onset)
; 172  :      *         onset--;
; 173  :      */
; 174  :     /* tmp = cbGain / onFact; onFact = 2.0; 200 Q1 = 100.0 */
; 175  :     tmp = shr_r (gain_cod, 1);

  00085	6a 01		 push	 1
  00087	0f b7 45 10	 movzx	 eax, WORD PTR _gain_cod$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _shr_r
  00091	83 c4 08	 add	 esp, 8
  00094	66 89 45 d4	 mov	 WORD PTR _tmp$[ebp], ax

; 176  :     test (); test ();

  00098	e8 00 00 00 00	 call	 _test
  0009d	e8 00 00 00 00	 call	 _test

; 177  :     if ((sub (tmp, st->prev_gc) > 0) && sub(gain_cod, 200) > 0)

  000a2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000a5	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  000a9	51		 push	 ecx
  000aa	0f b7 55 d4	 movzx	 edx, WORD PTR _tmp$[ebp]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 _sub
  000b4	83 c4 08	 add	 esp, 8
  000b7	98		 cwde
  000b8	85 c0		 test	 eax, eax
  000ba	7e 2b		 jle	 SHORT $LN14@gain_adapt
  000bc	68 c8 00 00 00	 push	 200			; 000000c8H
  000c1	0f b7 45 10	 movzx	 eax, WORD PTR _gain_cod$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _sub
  000cb	83 c4 08	 add	 esp, 8
  000ce	0f bf c8	 movsx	 ecx, ax
  000d1	85 c9		 test	 ecx, ecx
  000d3	7e 12		 jle	 SHORT $LN14@gain_adapt

; 178  :     {
; 179  :         st->onset = 8;                            move16 ();

  000d5	b8 08 00 00 00	 mov	 eax, 8
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000dd	66 89 01	 mov	 WORD PTR [ecx], ax
  000e0	e8 00 00 00 00	 call	 _move16

; 180  :     }
; 181  :     else

  000e5	eb 2b		 jmp	 SHORT $LN13@gain_adapt
$LN14@gain_adapt:

; 182  :     {
; 183  :         test ();

  000e7	e8 00 00 00 00	 call	 _test

; 184  :         if (st->onset != 0)

  000ec	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ef	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  000f2	85 c9		 test	 ecx, ecx
  000f4	74 1c		 je	 SHORT $LN13@gain_adapt

; 185  :         {
; 186  :             st->onset = sub (st->onset, 1);       move16 ();

  000f6	6a 01		 push	 1
  000f8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000fb	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 _sub
  00104	83 c4 08	 add	 esp, 8
  00107	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0010a	66 89 02	 mov	 WORD PTR [edx], ax
  0010d	e8 00 00 00 00	 call	 _move16
$LN13@gain_adapt:

; 187  :         }
; 188  :     }
; 189  : 
; 190  :     /*
; 191  :      *  // if onset, increase adaptor state
; 192  :      *  if (onset && (gainAdapt < 2)) gainAdapt++;
; 193  :      */
; 194  :     test(); test ();

  00112	e8 00 00 00 00	 call	 _test
  00117	e8 00 00 00 00	 call	 _test

; 195  :     if ((st->onset != 0) && (sub (adapt, 2) < 0))

  0011c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0011f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00122	85 c9		 test	 ecx, ecx
  00124	74 29		 je	 SHORT $LN11@gain_adapt
  00126	6a 02		 push	 2
  00128	0f b7 45 f8	 movzx	 eax, WORD PTR _adapt$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _sub
  00132	83 c4 08	 add	 esp, 8
  00135	0f bf c8	 movsx	 ecx, ax
  00138	85 c9		 test	 ecx, ecx
  0013a	7d 13		 jge	 SHORT $LN11@gain_adapt

; 196  :     {
; 197  :         adapt = add (adapt, 1);

  0013c	6a 01		 push	 1
  0013e	0f b7 45 f8	 movzx	 eax, WORD PTR _adapt$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _add
  00148	83 c4 08	 add	 esp, 8
  0014b	66 89 45 f8	 mov	 WORD PTR _adapt$[ebp], ax
$LN11@gain_adapt:

; 198  :     }
; 199  : 
; 200  :     st->ltpg_mem[0] = ltpg;                       move16 ();

  0014f	b8 02 00 00 00	 mov	 eax, 2
  00154	6b c8 00	 imul	 ecx, eax, 0
  00157	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0015a	66 8b 45 0c	 mov	 ax, WORD PTR _ltpg$[ebp]
  0015e	66 89 44 0a 06	 mov	 WORD PTR [edx+ecx+6], ax
  00163	e8 00 00 00 00	 call	 _move16

; 201  :     filt = gmed_n (st->ltpg_mem, 5);   move16 (); /* function result */

  00168	6a 05		 push	 5
  0016a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0016d	83 c0 06	 add	 eax, 6
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 _gmed_n
  00176	83 c4 08	 add	 esp, 8
  00179	66 89 45 e0	 mov	 WORD PTR _filt$[ebp], ax
  0017d	e8 00 00 00 00	 call	 _move16

; 202  : 
; 203  :     test ();

  00182	e8 00 00 00 00	 call	 _test

; 204  :     if (adapt == 0)

  00187	0f bf 45 f8	 movsx	 eax, WORD PTR _adapt$[ebp]
  0018b	85 c0		 test	 eax, eax
  0018d	0f 85 84 00 00
	00		 jne	 $LN10@gain_adapt

; 205  :     {
; 206  :         test ();

  00193	e8 00 00 00 00	 call	 _test

; 207  :         if (sub (filt, 5443) > 0) /* 5443 Q13 = 0.66443... */

  00198	68 43 15 00 00	 push	 5443			; 00001543H
  0019d	0f b7 45 e0	 movzx	 eax, WORD PTR _filt$[ebp]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _sub
  001a7	83 c4 08	 add	 esp, 8
  001aa	0f bf c8	 movsx	 ecx, ax
  001ad	85 c9		 test	 ecx, ecx
  001af	7e 0d		 jle	 SHORT $LN9@gain_adapt

; 208  :         {
; 209  :             result = 0; move16 ();

  001b1	33 c0		 xor	 eax, eax
  001b3	66 89 45 ec	 mov	 WORD PTR _result$[ebp], ax
  001b7	e8 00 00 00 00	 call	 _move16

; 210  :         }
; 211  :         else

  001bc	eb 57		 jmp	 SHORT $LN8@gain_adapt
$LN9@gain_adapt:

; 212  :         {
; 213  :             test ();

  001be	e8 00 00 00 00	 call	 _test

; 214  :             if (filt < 0)

  001c3	0f bf 45 e0	 movsx	 eax, WORD PTR _filt$[ebp]
  001c7	85 c0		 test	 eax, eax
  001c9	7d 10		 jge	 SHORT $LN7@gain_adapt

; 215  :             {
; 216  :                 result = 16384; move16 ();  /* 16384 Q15 = 0.5 */

  001cb	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  001d0	66 89 45 ec	 mov	 WORD PTR _result$[ebp], ax
  001d4	e8 00 00 00 00	 call	 _move16

; 217  :             }
; 218  :             else

  001d9	eb 3a		 jmp	 SHORT $LN8@gain_adapt
$LN7@gain_adapt:

; 219  :             {   /* result       =   0.5 - 0.75257499*filt     */
; 220  :                 /* result (Q15) = 16384 - 24660 * (filt << 2) */
; 221  :                 filt = shl (filt, 2); /* Q15 */

  001db	6a 02		 push	 2
  001dd	0f b7 45 e0	 movzx	 eax, WORD PTR _filt$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _shl
  001e7	83 c4 08	 add	 esp, 8
  001ea	66 89 45 e0	 mov	 WORD PTR _filt$[ebp], ax

; 222  :                 result = sub (16384, mult (24660, filt));

  001ee	0f b7 45 e0	 movzx	 eax, WORD PTR _filt$[ebp]
  001f2	50		 push	 eax
  001f3	68 54 60 00 00	 push	 24660			; 00006054H
  001f8	e8 00 00 00 00	 call	 _mult
  001fd	83 c4 08	 add	 esp, 8
  00200	0f b7 c8	 movzx	 ecx, ax
  00203	51		 push	 ecx
  00204	68 00 40 00 00	 push	 16384			; 00004000H
  00209	e8 00 00 00 00	 call	 _sub
  0020e	83 c4 08	 add	 esp, 8
  00211	66 89 45 ec	 mov	 WORD PTR _result$[ebp], ax
$LN8@gain_adapt:

; 223  :             }
; 224  :         }
; 225  :     }
; 226  :     else

  00215	eb 0b		 jmp	 SHORT $LN5@gain_adapt
$LN10@gain_adapt:

; 227  :     {
; 228  :         result = 0; move16 ();

  00217	33 c0		 xor	 eax, eax
  00219	66 89 45 ec	 mov	 WORD PTR _result$[ebp], ax
  0021d	e8 00 00 00 00	 call	 _move16
$LN5@gain_adapt:

; 229  :     }
; 230  :     /*
; 231  :      *  if (prevAlpha == 0.0) result = 0.5 * (result + prevAlpha);
; 232  :      */
; 233  :     test ();

  00222	e8 00 00 00 00	 call	 _test

; 234  :     if (st->prev_alpha == 0)

  00227	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0022a	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0022e	85 c9		 test	 ecx, ecx
  00230	75 13		 jne	 SHORT $LN4@gain_adapt

; 235  :     {
; 236  :         result = shr (result, 1);

  00232	6a 01		 push	 1
  00234	0f b7 45 ec	 movzx	 eax, WORD PTR _result$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 _shr
  0023e	83 c4 08	 add	 esp, 8
  00241	66 89 45 ec	 mov	 WORD PTR _result$[ebp], ax
$LN4@gain_adapt:

; 237  :     }
; 238  : 
; 239  :     /* store the result */
; 240  :     *alpha = result;                           move16 ();

  00245	8b 45 14	 mov	 eax, DWORD PTR _alpha$[ebp]
  00248	66 8b 4d ec	 mov	 cx, WORD PTR _result$[ebp]
  0024c	66 89 08	 mov	 WORD PTR [eax], cx
  0024f	e8 00 00 00 00	 call	 _move16

; 241  :     
; 242  :     /* update adapter state memory */
; 243  :     st->prev_alpha = result;                   move16 ();

  00254	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00257	66 8b 4d ec	 mov	 cx, WORD PTR _result$[ebp]
  0025b	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  0025f	e8 00 00 00 00	 call	 _move16

; 244  :     st->prev_gc = gain_cod;                    move16 ();

  00264	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00267	66 8b 4d 10	 mov	 cx, WORD PTR _gain_cod$[ebp]
  0026b	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  0026f	e8 00 00 00 00	 call	 _move16

; 245  : 
; 246  :     for (i = LTPG_MEM_SIZE-1; i > 0; i--)

  00274	b8 04 00 00 00	 mov	 eax, 4
  00279	66 89 45 c8	 mov	 WORD PTR _i$[ebp], ax
  0027d	eb 0c		 jmp	 SHORT $LN3@gain_adapt
$LN2@gain_adapt:
  0027f	66 8b 45 c8	 mov	 ax, WORD PTR _i$[ebp]
  00283	66 83 e8 01	 sub	 ax, 1
  00287	66 89 45 c8	 mov	 WORD PTR _i$[ebp], ax
$LN3@gain_adapt:
  0028b	0f bf 45 c8	 movsx	 eax, WORD PTR _i$[ebp]
  0028f	85 c0		 test	 eax, eax
  00291	7e 1f		 jle	 SHORT $LN19@gain_adapt

; 247  :     {
; 248  :         st->ltpg_mem[i] = st->ltpg_mem[i-1];   move16 ();

  00293	0f bf 45 c8	 movsx	 eax, WORD PTR _i$[ebp]
  00297	0f bf 4d c8	 movsx	 ecx, WORD PTR _i$[ebp]
  0029b	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0029e	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  002a1	66 8b 44 46 04	 mov	 ax, WORD PTR [esi+eax*2+4]
  002a6	66 89 44 4a 06	 mov	 WORD PTR [edx+ecx*2+6], ax
  002ab	e8 00 00 00 00	 call	 _move16

; 249  :     }

  002b0	eb cd		 jmp	 SHORT $LN2@gain_adapt
$LN19@gain_adapt:

; 250  :     /* mem[0] is just present for convenience in calling the gmed_n[5]
; 251  :      * function above. The memory depth is really LTPG_MEM_SIZE-1.
; 252  :      */
; 253  : }

  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi
  002b4	5b		 pop	 ebx
  002b5	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  002bb	3b ec		 cmp	 ebp, esp
  002bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c3		 ret	 0
_gain_adapt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\g_adapt.c
;	COMDAT _gain_adapt_exit
_TEXT	SEGMENT
_st$ = 8						; size = 4
_gain_adapt_exit PROC					; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 116  :     if (st == NULL || *st == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@gain_adapt
  00024	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@gain_adapt
$LN1@gain_adapt:

; 117  :         return;

  0002c	eb 21		 jmp	 SHORT $LN3@gain_adapt
$LN2@gain_adapt:

; 118  : 
; 119  :     /* deallocate memory */
; 120  :     free(*st);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 121  :     *st = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@gain_adapt:

; 122  : 
; 123  :     return;
; 124  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_gain_adapt_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\g_adapt.c
;	COMDAT _gain_adapt_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_gain_adapt_reset PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 88   :     Word16 i;
; 89   : 
; 90   :     if (st == (GainAdaptState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@gain_adapt

; 91   :         fprintf(stderr, "gain_adapt_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@ODACHLCM@gain_adapt_reset?3?5invalid?5parame@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 92   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 49		 jmp	 SHORT $LN5@gain_adapt
$LN4@gain_adapt:

; 93   :     }
; 94   : 
; 95   :     st->onset = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 96   :     st->prev_alpha = 0;

  00061	33 c0		 xor	 eax, eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00066	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 97   :     st->prev_gc = 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0006f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 98   : 
; 99   :     for (i = 0; i < LTPG_MEM_SIZE; i++)

  00073	33 c0		 xor	 eax, eax
  00075	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00079	eb 0c		 jmp	 SHORT $LN3@gain_adapt
$LN2@gain_adapt:
  0007b	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0007f	66 83 c0 01	 add	 ax, 1
  00083	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@gain_adapt:
  00087	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0008b	83 f8 05	 cmp	 eax, 5
  0008e	7d 10		 jge	 SHORT $LN1@gain_adapt

; 100  :     {
; 101  :         st->ltpg_mem[i] = 0;

  00090	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00094	33 c9		 xor	 ecx, ecx
  00096	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00099	66 89 4c 42 06	 mov	 WORD PTR [edx+eax*2+6], cx

; 102  :     }

  0009e	eb db		 jmp	 SHORT $LN2@gain_adapt
$LN1@gain_adapt:

; 103  : 
; 104  :     return 0;

  000a0	33 c0		 xor	 eax, eax
$LN5@gain_adapt:

; 105  : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_gain_adapt_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\g_adapt.c
;	COMDAT _gain_adapt_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_st$ = 8						; size = 4
_gain_adapt_init PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   :     GainAdaptState* s;
; 61   : 
; 62   :     if (st == (GainAdaptState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@gain_adapt

; 63   :         fprintf(stderr, "gain_adapt_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KLNEPGIP@gain_adapt_init?3?5invalid?5paramet@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 64   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@gain_adapt
$LN2@gain_adapt:

; 65   :     }
; 66   :     *st = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 67   : 
; 68   :     /* allocate memory */
; 69   :     if ((s= (GainAdaptState *) malloc(sizeof(GainAdaptState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 10		 push	 16			; 00000010H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@gain_adapt

; 70   :         fprintf(stderr, "gain_adapt_init: can't malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@ODPCGCFH@gain_adapt_init?3?5can?8t?5malloc?5st@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 71   :         return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@gain_adapt
$LN1@gain_adapt:

; 72   :     }
; 73   :     gain_adapt_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _gain_adapt_reset
  000bd	83 c4 04	 add	 esp, 4

; 74   :     *st = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 75   : 
; 76   :     return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@gain_adapt:

; 77   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_gain_adapt_init ENDP
_TEXT	ENDS
END
