; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\dtx_enc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_dtx_enc_id
CONST	SEGMENT
_dtx_enc_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_lsp_init_data DW 07530H
	DW	06590H
	DW	05208H
	DW	03a98H
	DW	01f40H
	DW	00H
	DW	0e0c0H
	DW	0c568H
	DW	0adf8H
	DW	09a70H
CONST	ENDS
PUBLIC	_dtx_enc_init
PUBLIC	_dtx_enc_reset
PUBLIC	_dtx_enc_exit
PUBLIC	_dtx_enc
PUBLIC	_dtx_buffer
PUBLIC	_tx_dtx_handler
PUBLIC	??_C@_0CB@NMGCLMKP@dtx_enc_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@MIMIAFBJ@dtx_enc_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@NIBLONKO@dtx_enc_reset?3?5invalid?5parameter@ ; `string'
EXTRN	_Q_plsf_3:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_deposit_l:PROC
EXTRN	_Copy:PROC
EXTRN	_Set_zero:PROC
EXTRN	_Log2:PROC
EXTRN	_Lsf_lsp:PROC
EXTRN	_Lsp_lsf:PROC
EXTRN	_Reorder_lsf:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CC@NIBLONKO@dtx_enc_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@NIBLONKO@dtx_enc_reset?3?5invalid?5parameter@ DB 'dtx_enc_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MIMIAFBJ@dtx_enc_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@MIMIAFBJ@dtx_enc_init?3?5can?5not?5malloc?5sta@ DB 'dtx_enc_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NMGCLMKP@dtx_enc_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@NMGCLMKP@dtx_enc_init?3?5invalid?5parameter?6@ DB 'dtx_enc_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _tx_dtx_handler
_TEXT	SEGMENT
_compute_new_sid_possible$ = -8				; size = 2
_st$ = 8						; size = 4
_vad_flag$ = 12						; size = 2
_usedMode$ = 16						; size = 4
_tx_dtx_handler PROC					; COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 329  :    Word16 compute_new_sid_possible;
; 330  :    
; 331  :    /* this state machine is in synch with the GSMEFR txDtx machine      */ 
; 332  :    st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1);  

  0001e	6a 01		 push	 1
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	0f b7 88 be 00
	00 00		 movzx	 ecx, WORD PTR [eax+190]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _add
  00030	83 c4 08	 add	 esp, 8
  00033	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00036	66 89 82 be 00
	00 00		 mov	 WORD PTR [edx+190], ax

; 333  :    
; 334  :    compute_new_sid_possible = 0;                       move16(); 

  0003d	33 c0		 xor	 eax, eax
  0003f	66 89 45 f8	 mov	 WORD PTR _compute_new_sid_possible$[ebp], ax
  00043	e8 00 00 00 00	 call	 _move16

; 335  : 
; 336  :    test();

  00048	e8 00 00 00 00	 call	 _test

; 337  :    if (vad_flag != 0)

  0004d	0f bf 45 0c	 movsx	 eax, WORD PTR _vad_flag$[ebp]
  00051	85 c0		 test	 eax, eax
  00053	74 19		 je	 SHORT $LN5@tx_dtx_han

; 338  :    {
; 339  :       st->dtxHangoverCount = DTX_HANG_CONST;           move16();

  00055	b8 07 00 00 00	 mov	 eax, 7
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0005d	66 89 81 bc 00
	00 00		 mov	 WORD PTR [ecx+188], ax
  00064	e8 00 00 00 00	 call	 _move16

; 340  :    }
; 341  :    else 

  00069	e9 a7 00 00 00	 jmp	 $LN4@tx_dtx_han
$LN5@tx_dtx_han:

; 342  :    {  /* non-speech */
; 343  :       test();

  0006e	e8 00 00 00 00	 call	 _test

; 344  :       if (st->dtxHangoverCount == 0)

  00073	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00076	0f bf 88 bc 00
	00 00		 movsx	 ecx, WORD PTR [eax+188]
  0007d	85 c9		 test	 ecx, ecx
  0007f	75 2f		 jne	 SHORT $LN3@tx_dtx_han

; 345  :       {  /* out of decoder analysis hangover  */
; 346  :          st->decAnaElapsedCount = 0;                   move16();        

  00081	33 c0		 xor	 eax, eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00086	66 89 81 be 00
	00 00		 mov	 WORD PTR [ecx+190], ax
  0008d	e8 00 00 00 00	 call	 _move16

; 347  :          *usedMode = MRDTX;                            move16(); 

  00092	8b 45 10	 mov	 eax, DWORD PTR _usedMode$[ebp]
  00095	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
  0009b	e8 00 00 00 00	 call	 _move16

; 348  :          compute_new_sid_possible = 1;                 move16(); 

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	66 89 45 f8	 mov	 WORD PTR _compute_new_sid_possible$[ebp], ax
  000a9	e8 00 00 00 00	 call	 _move16

; 349  :       }
; 350  :       else

  000ae	eb 65		 jmp	 SHORT $LN4@tx_dtx_han
$LN3@tx_dtx_han:

; 351  :       { /* in possible analysis hangover */
; 352  :          st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);

  000b0	6a 01		 push	 1
  000b2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000b5	0f b7 88 bc 00
	00 00		 movzx	 ecx, WORD PTR [eax+188]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 _sub
  000c2	83 c4 08	 add	 esp, 8
  000c5	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000c8	66 89 82 bc 00
	00 00		 mov	 WORD PTR [edx+188], ax

; 353  :          
; 354  :          /* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
; 355  :          test ();

  000cf	e8 00 00 00 00	 call	 _test

; 356  :          if (sub(add(st->decAnaElapsedCount, st->dtxHangoverCount),
; 357  :                  DTX_ELAPSED_FRAMES_THRESH) < 0)

  000d4	6a 1e		 push	 30			; 0000001eH
  000d6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d9	0f b7 88 bc 00
	00 00		 movzx	 ecx, WORD PTR [eax+188]
  000e0	51		 push	 ecx
  000e1	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000e4	0f b7 82 be 00
	00 00		 movzx	 eax, WORD PTR [edx+190]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _add
  000f1	83 c4 08	 add	 esp, 8
  000f4	0f b7 c8	 movzx	 ecx, ax
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _sub
  000fd	83 c4 08	 add	 esp, 8
  00100	0f bf d0	 movsx	 edx, ax
  00103	85 d2		 test	 edx, edx
  00105	7d 0e		 jge	 SHORT $LN4@tx_dtx_han

; 358  :          {
; 359  :             *usedMode = MRDTX;                         move16(); 

  00107	8b 45 10	 mov	 eax, DWORD PTR _usedMode$[ebp]
  0010a	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
  00110	e8 00 00 00 00	 call	 _move16
$LN4@tx_dtx_han:

; 360  :             /* if short time since decoder update, do not add extra HO */            
; 361  :          }
; 362  :          /*
; 363  :           else 
; 364  :             override VAD and stay in 
; 365  :             speech mode *usedMode 
; 366  :             and add extra hangover
; 367  :          */
; 368  :       }
; 369  :    }
; 370  :    
; 371  :    return compute_new_sid_possible;

  00115	66 8b 45 f8	 mov	 ax, WORD PTR _compute_new_sid_possible$[ebp]

; 372  : }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00122	3b ec		 cmp	 ebp, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
_tx_dtx_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _dtx_buffer
_TEXT	SEGMENT
_log_en$ = -56						; size = 2
_log_en_m$ = -44					; size = 2
_log_en_e$ = -32					; size = 2
_L_frame_en$ = -20					; size = 4
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_lsp_new$ = 12						; size = 4
_speech$ = 16						; size = 4
_dtx_buffer PROC					; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 277  :    Word16 i;
; 278  :    Word32 L_frame_en;
; 279  :    Word16 log_en_e;
; 280  :    Word16 log_en_m;
; 281  :    Word16 log_en;
; 282  :    
; 283  :    /* update pointer to circular buffer      */
; 284  :    st->hist_ptr = add(st->hist_ptr, 1);

  0001e	6a 01		 push	 1
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	0f b7 88 b0 00
	00 00		 movzx	 ecx, WORD PTR [eax+176]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _add
  00030	83 c4 08	 add	 esp, 8
  00033	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00036	66 89 82 b0 00
	00 00		 mov	 WORD PTR [edx+176], ax

; 285  :    test ();

  0003d	e8 00 00 00 00	 call	 _test

; 286  :    if (sub(st->hist_ptr, DTX_HIST_SIZE) == 0)

  00042	6a 08		 push	 8
  00044	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00047	0f b7 88 b0 00
	00 00		 movzx	 ecx, WORD PTR [eax+176]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _sub
  00054	83 c4 08	 add	 esp, 8
  00057	0f bf d0	 movsx	 edx, ax
  0005a	85 d2		 test	 edx, edx
  0005c	75 11		 jne	 SHORT $LN4@dtx_buffer

; 287  :    {
; 288  :       st->hist_ptr = 0;                                     move16 ();

  0005e	33 c0		 xor	 eax, eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00063	66 89 81 b0 00
	00 00		 mov	 WORD PTR [ecx+176], ax
  0006a	e8 00 00 00 00	 call	 _move16
$LN4@dtx_buffer:

; 289  :    }
; 290  :    
; 291  :    /* copy lsp vector into buffer */
; 292  :    Copy(lsp_new, &st->lsp_hist[st->hist_ptr * M], M);

  0006f	6a 0a		 push	 10			; 0000000aH
  00071	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00074	0f bf 88 b0 00
	00 00		 movsx	 ecx, WORD PTR [eax+176]
  0007b	6b d1 0a	 imul	 edx, ecx, 10
  0007e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00081	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00084	51		 push	 ecx
  00085	8b 55 0c	 mov	 edx, DWORD PTR _lsp_new$[ebp]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 _Copy
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 293  :    
; 294  :    /* compute log energy based on frame energy */
; 295  :    L_frame_en = 0;     /* Q0 */                             move32 ();

  00091	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _L_frame_en$[ebp], 0
  00098	e8 00 00 00 00	 call	 _move32

; 296  :    for (i=0; i < L_FRAME; i++)

  0009d	33 c0		 xor	 eax, eax
  0009f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000a3	eb 0c		 jmp	 SHORT $LN3@dtx_buffer
$LN2@dtx_buffer:
  000a5	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000a9	66 83 c0 01	 add	 ax, 1
  000ad	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@dtx_buffer:
  000b1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000b5	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  000ba	7d 29		 jge	 SHORT $LN1@dtx_buffer

; 297  :    {
; 298  :       L_frame_en = L_mac(L_frame_en, speech[i], speech[i]); 

  000bc	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000c0	8b 4d 10	 mov	 ecx, DWORD PTR _speech$[ebp]
  000c3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000c7	52		 push	 edx
  000c8	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000cc	8b 4d 10	 mov	 ecx, DWORD PTR _speech$[ebp]
  000cf	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000d3	52		 push	 edx
  000d4	8b 45 ec	 mov	 eax, DWORD PTR _L_frame_en$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _L_mac
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	89 45 ec	 mov	 DWORD PTR _L_frame_en$[ebp], eax

; 299  :    }

  000e3	eb c0		 jmp	 SHORT $LN2@dtx_buffer
$LN1@dtx_buffer:

; 300  :    Log2(L_frame_en, &log_en_e, &log_en_m);

  000e5	8d 45 d4	 lea	 eax, DWORD PTR _log_en_m$[ebp]
  000e8	50		 push	 eax
  000e9	8d 4d e0	 lea	 ecx, DWORD PTR _log_en_e$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 ec	 mov	 edx, DWORD PTR _L_frame_en$[ebp]
  000f0	52		 push	 edx
  000f1	e8 00 00 00 00	 call	 _Log2
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 301  :    
; 302  :    /* convert exponent and mantissa to Word16 Q10 */
; 303  :    log_en = shl(log_en_e, 10);  /* Q10 */

  000f9	6a 0a		 push	 10			; 0000000aH
  000fb	0f b7 45 e0	 movzx	 eax, WORD PTR _log_en_e$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _shl
  00105	83 c4 08	 add	 esp, 8
  00108	66 89 45 c8	 mov	 WORD PTR _log_en$[ebp], ax

; 304  :    log_en = add(log_en, shr(log_en_m, 15-10));

  0010c	6a 05		 push	 5
  0010e	0f b7 45 d4	 movzx	 eax, WORD PTR _log_en_m$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _shr
  00118	83 c4 08	 add	 esp, 8
  0011b	0f b7 c8	 movzx	 ecx, ax
  0011e	51		 push	 ecx
  0011f	0f b7 55 c8	 movzx	 edx, WORD PTR _log_en$[ebp]
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 _add
  00129	83 c4 08	 add	 esp, 8
  0012c	66 89 45 c8	 mov	 WORD PTR _log_en$[ebp], ax

; 305  :    
; 306  :    /* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
; 307  :    log_en = sub(log_en, 8521);

  00130	68 49 21 00 00	 push	 8521			; 00002149H
  00135	0f b7 45 c8	 movzx	 eax, WORD PTR _log_en$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _sub
  0013f	83 c4 08	 add	 esp, 8
  00142	66 89 45 c8	 mov	 WORD PTR _log_en$[ebp], ax

; 308  :    
; 309  :    /* insert into log energy buffer with division by 2 */
; 310  :    log_en = shr(log_en, 1);

  00146	6a 01		 push	 1
  00148	0f b7 45 c8	 movzx	 eax, WORD PTR _log_en$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _shr
  00152	83 c4 08	 add	 esp, 8
  00155	66 89 45 c8	 mov	 WORD PTR _log_en$[ebp], ax

; 311  :    st->log_en_hist[st->hist_ptr] = log_en; /* Q10 */        move16 ();

  00159	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0015c	0f bf 88 b0 00
	00 00		 movsx	 ecx, WORD PTR [eax+176]
  00163	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00166	66 8b 45 c8	 mov	 ax, WORD PTR _log_en$[ebp]
  0016a	66 89 84 4a a0
	00 00 00	 mov	 WORD PTR [edx+ecx*2+160], ax
  00172	e8 00 00 00 00	 call	 _move16

; 312  : 
; 313  :    return 0;

  00177	33 c0		 xor	 eax, eax

; 314  : }

  00179	52		 push	 edx
  0017a	8b cd		 mov	 ecx, ebp
  0017c	50		 push	 eax
  0017d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@dtx_buffer
  00183	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00188	58		 pop	 eax
  00189	5a		 pop	 edx
  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00193	3b ec		 cmp	 ebp, esp
  00195	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
  0019e	8b ff		 npad	 2
$LN10@dtx_buffer:
  001a0	02 00 00 00	 DD	 2
  001a4	00 00 00 00	 DD	 $LN9@dtx_buffer
$LN9@dtx_buffer:
  001a8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  001ac	02 00 00 00	 DD	 2
  001b0	00 00 00 00	 DD	 $LN7@dtx_buffer
  001b4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  001b8	02 00 00 00	 DD	 2
  001bc	00 00 00 00	 DD	 $LN8@dtx_buffer
$LN8@dtx_buffer:
  001c0	6c		 DB	 108			; 0000006cH
  001c1	6f		 DB	 111			; 0000006fH
  001c2	67		 DB	 103			; 00000067H
  001c3	5f		 DB	 95			; 0000005fH
  001c4	65		 DB	 101			; 00000065H
  001c5	6e		 DB	 110			; 0000006eH
  001c6	5f		 DB	 95			; 0000005fH
  001c7	6d		 DB	 109			; 0000006dH
  001c8	00		 DB	 0
$LN7@dtx_buffer:
  001c9	6c		 DB	 108			; 0000006cH
  001ca	6f		 DB	 111			; 0000006fH
  001cb	67		 DB	 103			; 00000067H
  001cc	5f		 DB	 95			; 0000005fH
  001cd	65		 DB	 101			; 00000065H
  001ce	6e		 DB	 110			; 0000006eH
  001cf	5f		 DB	 95			; 0000005fH
  001d0	65		 DB	 101			; 00000065H
  001d1	00		 DB	 0
_dtx_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _dtx_enc
_TEXT	SEGMENT
_L_lsp$ = -168						; size = 40
_lsp_q$ = -120						; size = 20
_lsp$ = -92						; size = 20
_lsf$ = -64						; size = 20
_log_en$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_computeSidFlag$ = 12					; size = 2
_qSt$ = 16						; size = 4
_predState$ = 20					; size = 4
_anap$ = 24						; size = 4
_dtx_enc PROC						; COMDAT

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00012	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 156  :    Word16 i,j;
; 157  :    Word16 log_en;
; 158  :    Word16 lsf[M];
; 159  :    Word16 lsp[M];
; 160  :    Word16 lsp_q[M];
; 161  :    Word32 L_lsp[M];
; 162  : 
; 163  :    /* VOX mode computation of SID parameters */
; 164  :    test (); test ();

  00028	e8 00 00 00 00	 call	 _test
  0002d	e8 00 00 00 00	 call	 _test

; 165  :    if ((computeSidFlag != 0))

  00032	0f bf 45 0c	 movsx	 eax, WORD PTR _computeSidFlag$[ebp]
  00036	85 c0		 test	 eax, eax
  00038	0f 84 c0 03 00
	00		 je	 $LN17@dtx_enc

; 166  :    {
; 167  :       /* compute new SID frame if safe i.e don't
; 168  :        * compute immediately after a talk spurt  */
; 169  :       log_en = 0;                                           move16 ();

  0003e	33 c0		 xor	 eax, eax
  00040	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax
  00044	e8 00 00 00 00	 call	 _move16

; 170  :       for (i = 0; i < M; i++)

  00049	33 c0		 xor	 eax, eax
  0004b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0004f	eb 0c		 jmp	 SHORT $LN16@dtx_enc
$LN15@dtx_enc:
  00051	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00055	66 83 c0 01	 add	 ax, 1
  00059	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN16@dtx_enc:
  0005d	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00061	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00064	7d 16		 jge	 SHORT $LN14@dtx_enc

; 171  :       {
; 172  :          L_lsp[i] = 0;                                      move16 ();

  00066	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0006a	c7 84 85 58 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _L_lsp$[ebp+eax*4], 0
  00075	e8 00 00 00 00	 call	 _move16

; 173  :       }

  0007a	eb d5		 jmp	 SHORT $LN15@dtx_enc
$LN14@dtx_enc:

; 174  :       
; 175  :       /* average energy and lsp */
; 176  :       for (i = 0; i < DTX_HIST_SIZE; i++)

  0007c	33 c0		 xor	 eax, eax
  0007e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00082	eb 0c		 jmp	 SHORT $LN13@dtx_enc
$LN12@dtx_enc:
  00084	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00088	66 83 c0 01	 add	 ax, 1
  0008c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN13@dtx_enc:
  00090	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00094	83 f8 08	 cmp	 eax, 8
  00097	0f 8d 90 00 00
	00		 jge	 $LN11@dtx_enc

; 177  :       {
; 178  :          log_en = add(log_en,
; 179  :                       shr(st->log_en_hist[i],2));

  0009d	6a 02		 push	 2
  0009f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a6	0f b7 94 41 a0
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+160]
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 _shr
  000b4	83 c4 08	 add	 esp, 8
  000b7	0f b7 c0	 movzx	 eax, ax
  000ba	50		 push	 eax
  000bb	0f b7 4d dc	 movzx	 ecx, WORD PTR _log_en$[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _add
  000c5	83 c4 08	 add	 esp, 8
  000c8	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 180  : 
; 181  :          for (j = 0; j < M; j++)

  000cc	33 c0		 xor	 eax, eax
  000ce	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  000d2	eb 0c		 jmp	 SHORT $LN10@dtx_enc
$LN9@dtx_enc:
  000d4	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  000d8	66 83 c0 01	 add	 ax, 1
  000dc	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN10@dtx_enc:
  000e0	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000e4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000e7	7d 3f		 jge	 SHORT $LN8@dtx_enc

; 182  :          {
; 183  :             L_lsp[j] = L_add(L_lsp[j],
; 184  :                              L_deposit_l(st->lsp_hist[i * M + j]));

  000e9	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000ed	6b c8 0a	 imul	 ecx, eax, 10
  000f0	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  000f4	03 ca		 add	 ecx, edx
  000f6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000f9	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _L_deposit_l
  00103	83 c4 04	 add	 esp, 4
  00106	50		 push	 eax
  00107	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  0010b	8b 84 95 58 ff
	ff ff		 mov	 eax, DWORD PTR _L_lsp$[ebp+edx*4]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _L_add
  00118	83 c4 08	 add	 esp, 8
  0011b	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  0011f	89 84 8d 58 ff
	ff ff		 mov	 DWORD PTR _L_lsp$[ebp+ecx*4], eax

; 185  :          }

  00126	eb ac		 jmp	 SHORT $LN9@dtx_enc
$LN8@dtx_enc:

; 186  :       }

  00128	e9 57 ff ff ff	 jmp	 $LN12@dtx_enc
$LN11@dtx_enc:

; 187  : 
; 188  :       log_en = shr(log_en, 1);

  0012d	6a 01		 push	 1
  0012f	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _shr
  00139	83 c4 08	 add	 esp, 8
  0013c	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 189  :       for (j = 0; j < M; j++)

  00140	33 c0		 xor	 eax, eax
  00142	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00146	eb 0c		 jmp	 SHORT $LN7@dtx_enc
$LN6@dtx_enc:
  00148	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  0014c	66 83 c0 01	 add	 ax, 1
  00150	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN7@dtx_enc:
  00154	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00158	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0015b	7d 2a		 jge	 SHORT $LN5@dtx_enc

; 190  :       {
; 191  :          lsp[j] = extract_l(L_shr(L_lsp[j], 3));   /* divide by 8 */

  0015d	6a 03		 push	 3
  0015f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00163	8b 8c 85 58 ff
	ff ff		 mov	 ecx, DWORD PTR _L_lsp$[ebp+eax*4]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _L_shr
  00170	83 c4 08	 add	 esp, 8
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _extract_l
  00179	83 c4 04	 add	 esp, 4
  0017c	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  00180	66 89 44 55 a4	 mov	 WORD PTR _lsp$[ebp+edx*2], ax

; 192  :       }

  00185	eb c1		 jmp	 SHORT $LN6@dtx_enc
$LN5@dtx_enc:

; 193  : 
; 194  :       /*  quantize logarithmic energy to 6 bits */
; 195  :       st->log_en_index = add(log_en, 2560);          /* +2.5 in Q10      */

  00187	68 00 0a 00 00	 push	 2560			; 00000a00H
  0018c	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _add
  00196	83 c4 08	 add	 esp, 8
  00199	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0019c	66 89 81 b2 00
	00 00		 mov	 WORD PTR [ecx+178], ax

; 196  :       st->log_en_index = add(st->log_en_index, 128); /* add 0.5/4 in Q10 */

  001a3	68 80 00 00 00	 push	 128			; 00000080H
  001a8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ab	0f b7 88 b2 00
	00 00		 movzx	 ecx, WORD PTR [eax+178]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 _add
  001b8	83 c4 08	 add	 esp, 8
  001bb	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001be	66 89 82 b2 00
	00 00		 mov	 WORD PTR [edx+178], ax

; 197  :       st->log_en_index = shr(st->log_en_index, 8);

  001c5	6a 08		 push	 8
  001c7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ca	0f b7 88 b2 00
	00 00		 movzx	 ecx, WORD PTR [eax+178]
  001d1	51		 push	 ecx
  001d2	e8 00 00 00 00	 call	 _shr
  001d7	83 c4 08	 add	 esp, 8
  001da	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001dd	66 89 82 b2 00
	00 00		 mov	 WORD PTR [edx+178], ax

; 198  : 
; 199  :       test ();

  001e4	e8 00 00 00 00	 call	 _test

; 200  :       if (sub(st->log_en_index, 63) > 0)

  001e9	6a 3f		 push	 63			; 0000003fH
  001eb	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ee	0f b7 88 b2 00
	00 00		 movzx	 ecx, WORD PTR [eax+178]
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 _sub
  001fb	83 c4 08	 add	 esp, 8
  001fe	0f bf d0	 movsx	 edx, ax
  00201	85 d2		 test	 edx, edx
  00203	7e 14		 jle	 SHORT $LN4@dtx_enc

; 201  :       {
; 202  :          st->log_en_index = 63;                             move16 ();

  00205	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0020a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0020d	66 89 81 b2 00
	00 00		 mov	 WORD PTR [ecx+178], ax
  00214	e8 00 00 00 00	 call	 _move16
$LN4@dtx_enc:

; 203  :       }
; 204  :       test ();

  00219	e8 00 00 00 00	 call	 _test

; 205  :       if (st->log_en_index < 0)

  0021e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00221	0f bf 88 b2 00
	00 00		 movsx	 ecx, WORD PTR [eax+178]
  00228	85 c9		 test	 ecx, ecx
  0022a	7d 11		 jge	 SHORT $LN3@dtx_enc

; 206  :       {
; 207  :          st->log_en_index = 0;                              move16 ();

  0022c	33 c0		 xor	 eax, eax
  0022e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00231	66 89 81 b2 00
	00 00		 mov	 WORD PTR [ecx+178], ax
  00238	e8 00 00 00 00	 call	 _move16
$LN3@dtx_enc:

; 208  :       }
; 209  :          
; 210  :       /* update gain predictor memory */
; 211  :       log_en = shl(st->log_en_index, -2+10); /* Q11 and divide by 4 */

  0023d	6a 08		 push	 8
  0023f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00242	0f b7 88 b2 00
	00 00		 movzx	 ecx, WORD PTR [eax+178]
  00249	51		 push	 ecx
  0024a	e8 00 00 00 00	 call	 _shl
  0024f	83 c4 08	 add	 esp, 8
  00252	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 212  :       log_en = sub(log_en, 2560);            /* add 2.5 in Q11      */

  00256	68 00 0a 00 00	 push	 2560			; 00000a00H
  0025b	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _sub
  00265	83 c4 08	 add	 esp, 8
  00268	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 213  :       
; 214  :       log_en = sub(log_en, 9000);

  0026c	68 28 23 00 00	 push	 9000			; 00002328H
  00271	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 _sub
  0027b	83 c4 08	 add	 esp, 8
  0027e	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 215  :       test ();

  00282	e8 00 00 00 00	 call	 _test

; 216  :       if (log_en > 0)

  00287	0f bf 45 dc	 movsx	 eax, WORD PTR _log_en$[ebp]
  0028b	85 c0		 test	 eax, eax
  0028d	7e 0b		 jle	 SHORT $LN2@dtx_enc

; 217  :       {
; 218  :          log_en = 0;                                        move16 ();

  0028f	33 c0		 xor	 eax, eax
  00291	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax
  00295	e8 00 00 00 00	 call	 _move16
$LN2@dtx_enc:

; 219  :       }
; 220  :       test ();

  0029a	e8 00 00 00 00	 call	 _test

; 221  :       if (sub(log_en, -14436) < 0)

  0029f	68 9c c7 ff ff	 push	 -14436			; ffffc79cH
  002a4	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _sub
  002ae	83 c4 08	 add	 esp, 8
  002b1	0f bf c8	 movsx	 ecx, ax
  002b4	85 c9		 test	 ecx, ecx
  002b6	7d 0e		 jge	 SHORT $LN1@dtx_enc

; 222  :       {
; 223  :          log_en = -14436;                                   move16 ();

  002b8	b8 9c c7 ff ff	 mov	 eax, -14436		; ffffc79cH
  002bd	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax
  002c1	e8 00 00 00 00	 call	 _move16
$LN1@dtx_enc:

; 224  :       }
; 225  :       
; 226  :       /* past_qua_en for other modes than MR122 */      
; 227  :       predState->past_qua_en[0] = log_en;                   move16 ();

  002c6	b8 02 00 00 00	 mov	 eax, 2
  002cb	6b c8 00	 imul	 ecx, eax, 0
  002ce	8b 55 14	 mov	 edx, DWORD PTR _predState$[ebp]
  002d1	66 8b 45 dc	 mov	 ax, WORD PTR _log_en$[ebp]
  002d5	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  002d9	e8 00 00 00 00	 call	 _move16

; 228  :       predState->past_qua_en[1] = log_en;                   move16 ();

  002de	b8 02 00 00 00	 mov	 eax, 2
  002e3	c1 e0 00	 shl	 eax, 0
  002e6	8b 4d 14	 mov	 ecx, DWORD PTR _predState$[ebp]
  002e9	66 8b 55 dc	 mov	 dx, WORD PTR _log_en$[ebp]
  002ed	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  002f1	e8 00 00 00 00	 call	 _move16

; 229  :       predState->past_qua_en[2] = log_en;                   move16 ();

  002f6	b8 02 00 00 00	 mov	 eax, 2
  002fb	d1 e0		 shl	 eax, 1
  002fd	8b 4d 14	 mov	 ecx, DWORD PTR _predState$[ebp]
  00300	66 8b 55 dc	 mov	 dx, WORD PTR _log_en$[ebp]
  00304	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00308	e8 00 00 00 00	 call	 _move16

; 230  :       predState->past_qua_en[3] = log_en;                   move16 ();

  0030d	b8 02 00 00 00	 mov	 eax, 2
  00312	6b c8 03	 imul	 ecx, eax, 3
  00315	8b 55 14	 mov	 edx, DWORD PTR _predState$[ebp]
  00318	66 8b 45 dc	 mov	 ax, WORD PTR _log_en$[ebp]
  0031c	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00320	e8 00 00 00 00	 call	 _move16

; 231  : 
; 232  :       /* scale down by factor 20*log10(2) in Q15 */
; 233  :       log_en = mult(5443, log_en);

  00325	0f b7 45 dc	 movzx	 eax, WORD PTR _log_en$[ebp]
  00329	50		 push	 eax
  0032a	68 43 15 00 00	 push	 5443			; 00001543H
  0032f	e8 00 00 00 00	 call	 _mult
  00334	83 c4 08	 add	 esp, 8
  00337	66 89 45 dc	 mov	 WORD PTR _log_en$[ebp], ax

; 234  :       
; 235  :       /* past_qua_en for mode MR122 */      
; 236  :       predState->past_qua_en_MR122[0] = log_en;             move16 ();

  0033b	b8 02 00 00 00	 mov	 eax, 2
  00340	6b c8 00	 imul	 ecx, eax, 0
  00343	8b 55 14	 mov	 edx, DWORD PTR _predState$[ebp]
  00346	66 8b 45 dc	 mov	 ax, WORD PTR _log_en$[ebp]
  0034a	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax
  0034f	e8 00 00 00 00	 call	 _move16

; 237  :       predState->past_qua_en_MR122[1] = log_en;             move16 ();

  00354	b8 02 00 00 00	 mov	 eax, 2
  00359	c1 e0 00	 shl	 eax, 0
  0035c	8b 4d 14	 mov	 ecx, DWORD PTR _predState$[ebp]
  0035f	66 8b 55 dc	 mov	 dx, WORD PTR _log_en$[ebp]
  00363	66 89 54 01 08	 mov	 WORD PTR [ecx+eax+8], dx
  00368	e8 00 00 00 00	 call	 _move16

; 238  :       predState->past_qua_en_MR122[2] = log_en;             move16 ();

  0036d	b8 02 00 00 00	 mov	 eax, 2
  00372	d1 e0		 shl	 eax, 1
  00374	8b 4d 14	 mov	 ecx, DWORD PTR _predState$[ebp]
  00377	66 8b 55 dc	 mov	 dx, WORD PTR _log_en$[ebp]
  0037b	66 89 54 01 08	 mov	 WORD PTR [ecx+eax+8], dx
  00380	e8 00 00 00 00	 call	 _move16

; 239  :       predState->past_qua_en_MR122[3] = log_en;             move16 ();

  00385	b8 02 00 00 00	 mov	 eax, 2
  0038a	6b c8 03	 imul	 ecx, eax, 3
  0038d	8b 55 14	 mov	 edx, DWORD PTR _predState$[ebp]
  00390	66 8b 45 dc	 mov	 ax, WORD PTR _log_en$[ebp]
  00394	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax
  00399	e8 00 00 00 00	 call	 _move16

; 240  :  
; 241  :       /* make sure that LSP's are ordered */
; 242  :       Lsp_lsf(lsp, lsf, M);

  0039e	6a 0a		 push	 10			; 0000000aH
  003a0	8d 45 c0	 lea	 eax, DWORD PTR _lsf$[ebp]
  003a3	50		 push	 eax
  003a4	8d 4d a4	 lea	 ecx, DWORD PTR _lsp$[ebp]
  003a7	51		 push	 ecx
  003a8	e8 00 00 00 00	 call	 _Lsp_lsf
  003ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 243  :       Reorder_lsf(lsf, LSF_GAP, M);

  003b0	6a 0a		 push	 10			; 0000000aH
  003b2	68 cd 00 00 00	 push	 205			; 000000cdH
  003b7	8d 45 c0	 lea	 eax, DWORD PTR _lsf$[ebp]
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 _Reorder_lsf
  003c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 244  :       Lsf_lsp(lsf, lsp, M);

  003c3	6a 0a		 push	 10			; 0000000aH
  003c5	8d 45 a4	 lea	 eax, DWORD PTR _lsp$[ebp]
  003c8	50		 push	 eax
  003c9	8d 4d c0	 lea	 ecx, DWORD PTR _lsf$[ebp]
  003cc	51		 push	 ecx
  003cd	e8 00 00 00 00	 call	 _Lsf_lsp
  003d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  :       
; 246  :       /* Quantize lsp and put on parameter list */
; 247  :       Q_plsf_3(qSt, MRDTX, lsp, lsp_q, st->lsp_index, 
; 248  :                &st->init_lsf_vq_index);

  003d5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  003d8	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
  003dd	50		 push	 eax
  003de	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  003e1	81 c1 b6 00 00
	00		 add	 ecx, 182		; 000000b6H
  003e7	51		 push	 ecx
  003e8	8d 55 88	 lea	 edx, DWORD PTR _lsp_q$[ebp]
  003eb	52		 push	 edx
  003ec	8d 45 a4	 lea	 eax, DWORD PTR _lsp$[ebp]
  003ef	50		 push	 eax
  003f0	6a 08		 push	 8
  003f2	8b 4d 10	 mov	 ecx, DWORD PTR _qSt$[ebp]
  003f5	51		 push	 ecx
  003f6	e8 00 00 00 00	 call	 _Q_plsf_3
  003fb	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@dtx_enc:

; 249  :    }
; 250  :    
; 251  :    *(*anap)++ = st->init_lsf_vq_index; /* 3 bits */         move16 ();

  003fe	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  00401	8b 08		 mov	 ecx, DWORD PTR [eax]
  00403	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00406	66 8b 82 b4 00
	00 00		 mov	 ax, WORD PTR [edx+180]
  0040d	66 89 01	 mov	 WORD PTR [ecx], ax
  00410	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  00413	8b 11		 mov	 edx, DWORD PTR [ecx]
  00415	83 c2 02	 add	 edx, 2
  00418	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  0041b	89 10		 mov	 DWORD PTR [eax], edx
  0041d	e8 00 00 00 00	 call	 _move16

; 252  :    
; 253  :    *(*anap)++ = st->lsp_index[0];      /* 8 bits */         move16 ();

  00422	b8 02 00 00 00	 mov	 eax, 2
  00427	6b c8 00	 imul	 ecx, eax, 0
  0042a	8b 55 18	 mov	 edx, DWORD PTR _anap$[ebp]
  0042d	8b 02		 mov	 eax, DWORD PTR [edx]
  0042f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00432	66 8b 8c 0a b6
	00 00 00	 mov	 cx, WORD PTR [edx+ecx+182]
  0043a	66 89 08	 mov	 WORD PTR [eax], cx
  0043d	8b 55 18	 mov	 edx, DWORD PTR _anap$[ebp]
  00440	8b 02		 mov	 eax, DWORD PTR [edx]
  00442	83 c0 02	 add	 eax, 2
  00445	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  00448	89 01		 mov	 DWORD PTR [ecx], eax
  0044a	e8 00 00 00 00	 call	 _move16

; 254  :    *(*anap)++ = st->lsp_index[1];      /* 9 bits */         move16 ();

  0044f	b8 02 00 00 00	 mov	 eax, 2
  00454	c1 e0 00	 shl	 eax, 0
  00457	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  0045a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0045c	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0045f	66 8b 84 01 b6
	00 00 00	 mov	 ax, WORD PTR [ecx+eax+182]
  00467	66 89 02	 mov	 WORD PTR [edx], ax
  0046a	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  0046d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0046f	83 c2 02	 add	 edx, 2
  00472	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  00475	89 10		 mov	 DWORD PTR [eax], edx
  00477	e8 00 00 00 00	 call	 _move16

; 255  :    *(*anap)++ = st->lsp_index[2];      /* 9 bits */         move16 ();

  0047c	b8 02 00 00 00	 mov	 eax, 2
  00481	d1 e0		 shl	 eax, 1
  00483	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  00486	8b 11		 mov	 edx, DWORD PTR [ecx]
  00488	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0048b	66 8b 84 01 b6
	00 00 00	 mov	 ax, WORD PTR [ecx+eax+182]
  00493	66 89 02	 mov	 WORD PTR [edx], ax
  00496	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  00499	8b 11		 mov	 edx, DWORD PTR [ecx]
  0049b	83 c2 02	 add	 edx, 2
  0049e	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  004a1	89 10		 mov	 DWORD PTR [eax], edx
  004a3	e8 00 00 00 00	 call	 _move16

; 256  :    
; 257  :    
; 258  :    *(*anap)++ = st->log_en_index;      /* 6 bits    */      move16 ();

  004a8	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  004ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ad	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  004b0	66 8b 82 b2 00
	00 00		 mov	 ax, WORD PTR [edx+178]
  004b7	66 89 01	 mov	 WORD PTR [ecx], ax
  004ba	8b 4d 18	 mov	 ecx, DWORD PTR _anap$[ebp]
  004bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  004bf	83 c2 02	 add	 edx, 2
  004c2	8b 45 18	 mov	 eax, DWORD PTR _anap$[ebp]
  004c5	89 10		 mov	 DWORD PTR [eax], edx
  004c7	e8 00 00 00 00	 call	 _move16

; 259  :                                        /* = 35 bits */
; 260  :    
; 261  :    return 0;

  004cc	33 c0		 xor	 eax, eax

; 262  : }

  004ce	52		 push	 edx
  004cf	8b cd		 mov	 ecx, ebp
  004d1	50		 push	 eax
  004d2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@dtx_enc
  004d8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004dd	58		 pop	 eax
  004de	5a		 pop	 edx
  004df	5f		 pop	 edi
  004e0	5e		 pop	 esi
  004e1	5b		 pop	 ebx
  004e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e5	33 cd		 xor	 ecx, ebp
  004e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ec	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  004f2	3b ec		 cmp	 ebp, esp
  004f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004f9	8b e5		 mov	 esp, ebp
  004fb	5d		 pop	 ebp
  004fc	c3		 ret	 0
  004fd	8d 49 00	 npad	 3
$LN25@dtx_enc:
  00500	04 00 00 00	 DD	 4
  00504	00 00 00 00	 DD	 $LN24@dtx_enc
$LN24@dtx_enc:
  00508	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0050c	14 00 00 00	 DD	 20			; 00000014H
  00510	00 00 00 00	 DD	 $LN20@dtx_enc
  00514	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00518	14 00 00 00	 DD	 20			; 00000014H
  0051c	00 00 00 00	 DD	 $LN21@dtx_enc
  00520	88 ff ff ff	 DD	 -120			; ffffff88H
  00524	14 00 00 00	 DD	 20			; 00000014H
  00528	00 00 00 00	 DD	 $LN22@dtx_enc
  0052c	58 ff ff ff	 DD	 -168			; ffffff58H
  00530	28 00 00 00	 DD	 40			; 00000028H
  00534	00 00 00 00	 DD	 $LN23@dtx_enc
$LN23@dtx_enc:
  00538	4c		 DB	 76			; 0000004cH
  00539	5f		 DB	 95			; 0000005fH
  0053a	6c		 DB	 108			; 0000006cH
  0053b	73		 DB	 115			; 00000073H
  0053c	70		 DB	 112			; 00000070H
  0053d	00		 DB	 0
$LN22@dtx_enc:
  0053e	6c		 DB	 108			; 0000006cH
  0053f	73		 DB	 115			; 00000073H
  00540	70		 DB	 112			; 00000070H
  00541	5f		 DB	 95			; 0000005fH
  00542	71		 DB	 113			; 00000071H
  00543	00		 DB	 0
$LN21@dtx_enc:
  00544	6c		 DB	 108			; 0000006cH
  00545	73		 DB	 115			; 00000073H
  00546	70		 DB	 112			; 00000070H
  00547	00		 DB	 0
$LN20@dtx_enc:
  00548	6c		 DB	 108			; 0000006cH
  00549	73		 DB	 115			; 00000073H
  0054a	66		 DB	 102			; 00000066H
  0054b	00		 DB	 0
_dtx_enc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _dtx_enc_exit
_TEXT	SEGMENT
_st$ = 8						; size = 4
_dtx_enc_exit PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 132  :    if (st == NULL || *st == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@dtx_enc_ex
  00024	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@dtx_enc_ex
$LN1@dtx_enc_ex:

; 133  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@dtx_enc_ex
$LN2@dtx_enc_ex:

; 134  :    
; 135  :    /* deallocate memory */
; 136  :    free(*st);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 137  :    *st = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@dtx_enc_ex:

; 138  :    
; 139  :    return;
; 140  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_dtx_enc_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _dtx_enc_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_dtx_enc_reset PROC					; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 94   :   Word16 i;
; 95   : 
; 96   :   if (st == (dtx_encState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 38		 jne	 SHORT $LN4@dtx_enc_re

; 97   :     fprintf(stderr, "dtx_enc_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NIBLONKO@dtx_enc_reset?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 98   :     return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 d4 00 00 00	 jmp	 $LN5@dtx_enc_re
$LN4@dtx_enc_re:

; 99   :   }
; 100  : 
; 101  :   st->hist_ptr = 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00061	66 89 81 b0 00
	00 00		 mov	 WORD PTR [ecx+176], ax

; 102  :   st->log_en_index = 0;

  00068	33 c0		 xor	 eax, eax
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0006d	66 89 81 b2 00
	00 00		 mov	 WORD PTR [ecx+178], ax

; 103  :   st->init_lsf_vq_index = 0;

  00074	33 c0		 xor	 eax, eax
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00079	66 89 81 b4 00
	00 00		 mov	 WORD PTR [ecx+180], ax

; 104  :   st->lsp_index[0] = 0;

  00080	b8 02 00 00 00	 mov	 eax, 2
  00085	6b c8 00	 imul	 ecx, eax, 0
  00088	33 d2		 xor	 edx, edx
  0008a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0008d	66 89 94 08 b6
	00 00 00	 mov	 WORD PTR [eax+ecx+182], dx

; 105  :   st->lsp_index[1] = 0;

  00095	b8 02 00 00 00	 mov	 eax, 2
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	33 c9		 xor	 ecx, ecx
  0009f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000a2	66 89 8c 02 b6
	00 00 00	 mov	 WORD PTR [edx+eax+182], cx

; 106  :   st->lsp_index[2] = 0;

  000aa	b8 02 00 00 00	 mov	 eax, 2
  000af	d1 e0		 shl	 eax, 1
  000b1	33 c9		 xor	 ecx, ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000b6	66 89 8c 02 b6
	00 00 00	 mov	 WORD PTR [edx+eax+182], cx

; 107  :  
; 108  :   /* Init lsp_hist[] */
; 109  :   for(i = 0; i < DTX_HIST_SIZE; i++)

  000be	33 c0		 xor	 eax, eax
  000c0	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000c4	eb 0c		 jmp	 SHORT $LN3@dtx_enc_re
$LN2@dtx_enc_re:
  000c6	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000ca	66 83 c0 01	 add	 ax, 1
  000ce	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@dtx_enc_re:
  000d2	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000d6	83 f8 08	 cmp	 eax, 8
  000d9	7d 1f		 jge	 SHORT $LN1@dtx_enc_re

; 110  :   {
; 111  :     Copy(lsp_init_data, &st->lsp_hist[i * M], M);

  000db	6a 0a		 push	 10			; 0000000aH
  000dd	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000e1	6b c8 0a	 imul	 ecx, eax, 10
  000e4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000e7	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000ea	50		 push	 eax
  000eb	68 00 00 00 00	 push	 OFFSET _lsp_init_data
  000f0	e8 00 00 00 00	 call	 _Copy
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  :   }

  000f8	eb cc		 jmp	 SHORT $LN2@dtx_enc_re
$LN1@dtx_enc_re:

; 113  : 
; 114  :   /* Reset energy history */
; 115  :   Set_zero(st->log_en_hist, M);

  000fa	6a 0a		 push	 10			; 0000000aH
  000fc	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ff	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _Set_zero
  0010a	83 c4 08	 add	 esp, 8

; 116  : 
; 117  :   st->dtxHangoverCount = DTX_HANG_CONST;

  0010d	b8 07 00 00 00	 mov	 eax, 7
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00115	66 89 81 bc 00
	00 00		 mov	 WORD PTR [ecx+188], ax

; 118  :   st->decAnaElapsedCount = 32767; 

  0011c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00124	66 89 81 be 00
	00 00		 mov	 WORD PTR [ecx+190], ax

; 119  : 
; 120  :   return 1;

  0012b	b8 01 00 00 00	 mov	 eax, 1
$LN5@dtx_enc_re:

; 121  : }

  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00139	3b ec		 cmp	 ebp, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
_dtx_enc_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_enc.c
;	COMDAT _dtx_enc_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_st$ = 8						; size = 4
_dtx_enc_init PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   :   dtx_encState* s;
; 65   :  
; 66   :   if (st == (dtx_encState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@dtx_enc_in

; 67   :     fprintf(stderr, "dtx_enc_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NMGCLMKP@dtx_enc_init?3?5invalid?5parameter?6@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :     return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 74		 jmp	 SHORT $LN3@dtx_enc_in
$LN2@dtx_enc_in:

; 69   :   }
; 70   :   
; 71   :   *st = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 72   :  
; 73   :   /* allocate memory */
; 74   :   if ((s= (dtx_encState *) malloc(sizeof(dtx_encState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	68 c0 00 00 00	 push	 192			; 000000c0H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 35		 jne	 SHORT $LN1@dtx_enc_in

; 75   :     fprintf(stderr, "dtx_enc_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MIMIAFBJ@dtx_enc_init?3?5can?5not?5malloc?5sta@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   :     return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 16		 jmp	 SHORT $LN3@dtx_enc_in
$LN1@dtx_enc_in:

; 77   :   }
; 78   :   
; 79   :   dtx_enc_reset(s);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _dtx_enc_reset
  000c0	83 c4 04	 add	 esp, 4

; 80   :   *st = s;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c9	89 08		 mov	 DWORD PTR [eax], ecx

; 81   :   
; 82   :   return 0;

  000cb	33 c0		 xor	 eax, eax
$LN3@dtx_enc_in:

; 83   : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
_dtx_enc_init ENDP
_TEXT	ENDS
END
