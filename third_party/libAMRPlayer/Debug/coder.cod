; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\coder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_coder_id
CONST	SEGMENT
_coder_id DB	'@(#)$Id $', 00H
CONST	ENDS
PUBLIC	_read_mode
PUBLIC	_coder_main
PUBLIC	??_C@_04BBIHCBDO@?$CF9s?6?$AA@			; `string'
PUBLIC	??_C@_0CG@OIMIKGJJ@?6error?5reading?5mode?5control?5file@ ; `string'
PUBLIC	??_C@_0DE@FBIIBAM@?6invalid?5amr_mode?5found?5in?5mode?5@ ; `string'
PUBLIC	??_C@_07FCHKDECE@Encoder?$AA@			; `string'
PUBLIC	??_C@_0CE@IJOLNHCI@Code?5compiled?5with?5VAD?5option?3?5?$CF@ ; `string'
PUBLIC	??_C@_04NGLAHB@?9dtx?$AA@			; `string'
PUBLIC	??_C@_0L@OMBHHAMA@?9modefile?$DN?$AA@		; `string'
PUBLIC	??_C@_0PM@GFONJINO@?5Usage?3?6?6?5?5?5?$CFs?5?$FL?9dtx?$FN?5amr_mode?5?5@ ; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02BMJICGCB@rt?$AA@			; `string'
PUBLIC	??_C@_0CI@CGHOPIKO@Error?5opening?5mode?5control?5file?5@ ; `string'
PUBLIC	??_C@_0BN@BJFEJIKL@?5Mode?5control?5file?3?5?5?5?5?5?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@FCPNNMIH@Invalid?5amr_mode?5specified?3?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0CB@EDBECNLE@Error?5opening?5input?5file?5?5?$CFs?5?$CB?$CB?6@ ; `string'
PUBLIC	??_C@_0BN@INFCDJHG@?5Input?5speech?5file?3?5?5?5?5?5?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CL@PFECDEDN@Error?5opening?5output?5bitstream?5f@ ; `string'
PUBLIC	??_C@_0BN@IKIHJAKD@?5Output?5bitstream?5file?3?5?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_07KLAMFGHC@encoder?$AA@			; `string'
PUBLIC	??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@		; `string'
PUBLIC	??_C@_0CC@DOGOGDHP@?6end?5of?5mode?5control?5file?5reache@ ; `string'
PUBLIC	??_C@_0CF@FPNDKFCB@?$ANframe?$DN?$CF?98d?5mode?$DN?$CF?95s?5used_mode?$DN@ ; `string'
PUBLIC	??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fscanf_s:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__exit:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	_proc_head:PROC
EXTRN	_str2mode:PROC
EXTRN	_mode2str:PROC
EXTRN	_Speech_Encode_Frame_init:PROC
EXTRN	_Speech_Encode_Frame_reset:PROC
EXTRN	_Speech_Encode_Frame_exit:PROC
EXTRN	_Speech_Encode_Frame:PROC
EXTRN	_PackBits:PROC
EXTRN	_sid_sync_init:PROC
EXTRN	_sid_sync_reset:PROC
EXTRN	_sid_sync_exit:PROC
EXTRN	_sid_sync:PROC
EXTRN	_get_vadname:PROC
EXTRN	_encoder_homing_frame_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@
CONST	SEGMENT
??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@ DB 0aH, '%d '
	DB	'frame(s) processed', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@ DB 0aH, 'e'
	DB	'rror writing output file: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FPNDKFCB@?$ANframe?$DN?$CF?98d?5mode?$DN?$CF?95s?5used_mode?$DN@
CONST	SEGMENT
??_C@_0CF@FPNDKFCB@?$ANframe?$DN?$CF?98d?5mode?$DN?$CF?95s?5used_mode?$DN@ DB 0dH
	DB	'frame=%-8d mode=%-5s used_mode=%-5s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DOGOGDHP@?6end?5of?5mode?5control?5file?5reache@
CONST	SEGMENT
??_C@_0CC@DOGOGDHP@?6end?5of?5mode?5control?5file?5reache@ DB 0aH, 'end o'
	DB	'f mode control file reached', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
CONST	SEGMENT
??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@ DB '#!AMR', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLAMFGHC@encoder?$AA@
CONST	SEGMENT
??_C@_07KLAMFGHC@encoder?$AA@ DB 'encoder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IKIHJAKD@?5Output?5bitstream?5file?3?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@IKIHJAKD@?5Output?5bitstream?5file?3?5?5?$CFs?6?$AA@ DB ' Outpu'
	DB	't bitstream file:  %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFECDEDN@Error?5opening?5output?5bitstream?5f@
CONST	SEGMENT
??_C@_0CL@PFECDEDN@Error?5opening?5output?5bitstream?5f@ DB 'Error openin'
	DB	'g output bitstream file %s !!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFCDJHG@?5Input?5speech?5file?3?5?5?5?5?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@INFCDJHG@?5Input?5speech?5file?3?5?5?5?5?5?5?$CFs?6?$AA@ DB ' I'
	DB	'nput speech file:      %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EDBECNLE@Error?5opening?5input?5file?5?5?$CFs?5?$CB?$CB?6@
CONST	SEGMENT
??_C@_0CB@EDBECNLE@Error?5opening?5input?5file?5?5?$CFs?5?$CB?$CB?6@ DB 'E'
	DB	'rror opening input file  %s !!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FCPNNMIH@Invalid?5amr_mode?5specified?3?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0CC@FCPNNMIH@Invalid?5amr_mode?5specified?3?5?8?$CFs?8@ DB 'Invalid'
	DB	' amr_mode specified: ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BJFEJIKL@?5Mode?5control?5file?3?5?5?5?5?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@BJFEJIKL@?5Mode?5control?5file?3?5?5?5?5?5?5?$CFs?6?$AA@ DB ' M'
	DB	'ode control file:      %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CGHOPIKO@Error?5opening?5mode?5control?5file?5@
CONST	SEGMENT
??_C@_0CI@CGHOPIKO@Error?5opening?5mode?5control?5file?5@ DB 'Error openi'
	DB	'ng mode control file  %s !!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt?$AA@
CONST	SEGMENT
??_C@_02BMJICGCB@rt?$AA@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0PM@GFONJINO@?5Usage?3?6?6?5?5?5?$CFs?5?$FL?9dtx?$FN?5amr_mode?5?5@
CONST	SEGMENT
??_C@_0PM@GFONJINO@?5Usage?3?6?6?5?5?5?$CFs?5?$FL?9dtx?$FN?5amr_mode?5?5@ DB ' '
	DB	'Usage:', 0aH, 0aH, '   %s [-dtx] amr_mode            speech_f'
	DB	'ile  bitstream_file', 0aH, 0aH, ' or ', 0aH, 0aH, '   %s [-dt'
	DB	'x] -modefile=mode_file speech_file  bitstream_file', 0aH, 0aH
	DB	' -dtx                enables DTX mode', 0aH, ' -modefile=mode'
	DB	'_file reads AMR modes from text file (one line per frame)', 0aH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMBHHAMA@?9modefile?$DN?$AA@
CONST	SEGMENT
??_C@_0L@OMBHHAMA@?9modefile?$DN?$AA@ DB '-modefile=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NGLAHB@?9dtx?$AA@
CONST	SEGMENT
??_C@_04NGLAHB@?9dtx?$AA@ DB '-dtx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IJOLNHCI@Code?5compiled?5with?5VAD?5option?3?5?$CF@
CONST	SEGMENT
??_C@_0CE@IJOLNHCI@Code?5compiled?5with?5VAD?5option?3?5?$CF@ DB 'Code co'
	DB	'mpiled with VAD option: %s', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCHKDECE@Encoder?$AA@
CONST	SEGMENT
??_C@_07FCHKDECE@Encoder?$AA@ DB 'Encoder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FBIIBAM@?6invalid?5amr_mode?5found?5in?5mode?5@
CONST	SEGMENT
??_C@_0DE@FBIIBAM@?6invalid?5amr_mode?5found?5in?5mode?5@ DB 0aH, 'invali'
	DB	'd amr_mode found in mode control file: ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OIMIKGJJ@?6error?5reading?5mode?5control?5file@
CONST	SEGMENT
??_C@_0CG@OIMIKGJJ@?6error?5reading?5mode?5control?5file@ DB 0aH, 'error '
	DB	'reading mode control file: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BBIHCBDO@?$CF9s?6?$AA@
CONST	SEGMENT
??_C@_04BBIHCBDO@?$CF9s?6?$AA@ DB '%9s', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\coder.c
;	COMDAT _coder_main
_TEXT	SEGMENT
$T1 = -1332						; size = 4
_res$2 = -1128						; size = 4
_sid_state$ = -1116					; size = 4
_speech_encoder_state$ = -1104				; size = 4
_useModeFile$ = -1092					; size = 4
_tx_type$ = -1080					; size = 4
_used_mode$ = -1068					; size = 4
_mode$ = -1056						; size = 4
_i$ = -1044						; size = 4
_reset_flag$ = -1032					; size = 2
_dtx$ = -1020						; size = 2
_frame$ = -1008						; size = 4
_packed_size$ = -996					; size = 2
_packed_bits$ = -984					; size = 32
_serial$ = -944						; size = 500
_new_speech$ = -436					; size = 320
_file_modes$ = -108					; size = 4
_file_serial$ = -96					; size = 4
_file_speech$ = -84					; size = 4
_serialFileName$ = -72					; size = 4
_modefileName$ = -60					; size = 4
_fileName$ = -48					; size = 4
_usedModeStr$ = -36					; size = 4
_modeStr$ = -24						; size = 4
_progname$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_coder_main PROC					; COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 05 00
	00		 sub	 esp, 1336		; 00000538H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fa ff
	ff		 lea	 edi, DWORD PTR [ebp-1336]
  00012	b9 4e 01 00 00	 mov	 ecx, 334		; 0000014eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 105  :   char *progname = argv[0];

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00033	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00036	89 45 f4	 mov	 DWORD PTR _progname$[ebp], eax

; 106  :   char *modeStr = NULL;

  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _modeStr$[ebp], 0

; 107  :   char *usedModeStr = NULL;

  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _usedModeStr$[ebp], 0

; 108  :   char *fileName = NULL;

  00047	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fileName$[ebp], 0

; 109  :   char *modefileName = NULL;

  0004e	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _modefileName$[ebp], 0

; 110  :   char *serialFileName = NULL;

  00055	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _serialFileName$[ebp], 0

; 111  :   
; 112  :   FILE *file_speech = NULL;           /* File of speech data               */

  0005c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _file_speech$[ebp], 0

; 113  :   FILE *file_serial = NULL;           /* File of coded bits                */

  00063	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _file_serial$[ebp], 0

; 114  :   FILE *file_modes = NULL;            /* File with mode information        */

  0006a	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _file_modes$[ebp], 0

; 115  :   
; 116  :   Word16 new_speech[L_FRAME];         /* Pointer to new speech data        */
; 117  :   Word16 serial[SERIAL_FRAMESIZE];    /* Output bitstream buffer           */
; 118  : 
; 119  : #ifdef MMS_IO
; 120  :   UWord8 packed_bits[MAX_PACKED_SIZE];
; 121  :   Word16 packed_size;
; 122  : #endif
; 123  : 
; 124  :   Word32 frame;
; 125  :   Word16 dtx = 0;                     /* enable encoder DTX                */

  00071	33 c0		 xor	 eax, eax
  00073	66 89 85 04 fc
	ff ff		 mov	 WORD PTR _dtx$[ebp], ax

; 126  :   
; 127  :   /* changed eedodr */
; 128  :   Word16 reset_flag;
; 129  : 
; 130  :   int i;
; 131  :   enum Mode mode;
; 132  :   enum Mode used_mode;
; 133  :   enum TXFrameType tx_type;
; 134  : 
; 135  :   int useModeFile = 0;

  0007a	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _useModeFile$[ebp], 0

; 136  :   
; 137  :   Speech_Encode_FrameState *speech_encoder_state = NULL;

  00084	c7 85 b0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _speech_encoder_state$[ebp], 0

; 138  :   sid_syncState *sid_state = NULL;

  0008e	c7 85 a4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _sid_state$[ebp], 0

; 139  : 
; 140  :   proc_head ("Encoder");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07FCHKDECE@Encoder?$AA@
  0009d	e8 00 00 00 00	 call	 _proc_head
  000a2	83 c4 04	 add	 esp, 4

; 141  :   fprintf(stderr, "Code compiled with VAD option: %s\n\n", get_vadname());

  000a5	e8 00 00 00 00	 call	 _get_vadname
  000aa	8b f4		 mov	 esi, esp
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IJOLNHCI@Code?5compiled?5with?5VAD?5option?3?5?$CF@
  000b2	8b fc		 mov	 edi, esp
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  000ba	3b fc		 cmp	 edi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c6	d1 e1		 shl	 ecx, 1
  000c8	03 c1		 add	 eax, ecx
  000ca	50		 push	 eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	3b f4		 cmp	 esi, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN38@coder_main:

; 142  : 
; 143  :   /*----------------------------------------------------------------------*
; 144  :    * Process command line options                                         *
; 145  :    *----------------------------------------------------------------------*/
; 146  :   while (argc > 1) {

  000db	83 7d 08 01	 cmp	 DWORD PTR _argc$[ebp], 1
  000df	0f 8e 93 00 00
	00		 jle	 $LN37@coder_main

; 147  :       if (strcmp(argv[1], "-dtx") == 0) {

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_04NGLAHB@?9dtx?$AA@
  000ea	b8 04 00 00 00	 mov	 eax, 4
  000ef	c1 e0 00	 shl	 eax, 0
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  000f5	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _strcmp
  000fe	83 c4 08	 add	 esp, 8
  00101	85 c0		 test	 eax, eax
  00103	75 0e		 jne	 SHORT $LN36@coder_main

; 148  :           dtx = 1;

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	66 89 85 04 fc
	ff ff		 mov	 WORD PTR _dtx$[ebp], ax
  00111	eb 4e		 jmp	 SHORT $LN35@coder_main
$LN36@coder_main:

; 149  :       } else if (strncmp(argv[1], "-modefile=", 10) == 0) {

  00113	8b f4		 mov	 esi, esp
  00115	6a 0a		 push	 10			; 0000000aH
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OMBHHAMA@?9modefile?$DN?$AA@
  0011c	b8 04 00 00 00	 mov	 eax, 4
  00121	c1 e0 00	 shl	 eax, 0
  00124	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00127	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0012a	52		 push	 edx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncmp
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
  00134	3b f4		 cmp	 esi, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	85 c0		 test	 eax, eax
  0013d	75 20		 jne	 SHORT $LN34@coder_main

; 150  :           useModeFile = 1;

  0013f	c7 85 bc fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _useModeFile$[ebp], 1

; 151  :           modefileName = argv[1]+10;

  00149	b8 04 00 00 00	 mov	 eax, 4
  0014e	c1 e0 00	 shl	 eax, 0
  00151	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00154	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00157	83 c2 0a	 add	 edx, 10			; 0000000aH
  0015a	89 55 c4	 mov	 DWORD PTR _modefileName$[ebp], edx

; 152  :       } else

  0015d	eb 02		 jmp	 SHORT $LN35@coder_main
$LN34@coder_main:

; 153  :           break;

  0015f	eb 17		 jmp	 SHORT $LN37@coder_main
$LN35@coder_main:

; 154  :       argc--;

  00161	8b 45 08	 mov	 eax, DWORD PTR _argc$[ebp]
  00164	83 e8 01	 sub	 eax, 1
  00167	89 45 08	 mov	 DWORD PTR _argc$[ebp], eax

; 155  :       argv++;

  0016a	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0016d	83 c0 04	 add	 eax, 4
  00170	89 45 0c	 mov	 DWORD PTR _argv$[ebp], eax

; 156  :   }

  00173	e9 63 ff ff ff	 jmp	 $LN38@coder_main
$LN37@coder_main:

; 157  :   
; 158  :   /*----------------------------------------------------------------------*
; 159  :    * Check number of arguments                                            *
; 160  :    *----------------------------------------------------------------------*/
; 161  :   if (   (argc != 4 && !useModeFile)
; 162  :       || (argc != 3 &&  useModeFile))

  00178	83 7d 08 04	 cmp	 DWORD PTR _argc$[ebp], 4
  0017c	74 09		 je	 SHORT $LN30@coder_main
  0017e	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _useModeFile$[ebp], 0
  00185	74 0f		 je	 SHORT $LN31@coder_main
$LN30@coder_main:
  00187	83 7d 08 03	 cmp	 DWORD PTR _argc$[ebp], 3
  0018b	74 52		 je	 SHORT $LN32@coder_main
  0018d	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _useModeFile$[ebp], 0
  00194	74 49		 je	 SHORT $LN32@coder_main
$LN31@coder_main:

; 163  :   {
; 164  :     fprintf (stderr,
; 165  :       " Usage:\n\n"
; 166  :       "   %s [-dtx] amr_mode            speech_file  bitstream_file\n\n"
; 167  :       " or \n\n"
; 168  :       "   %s [-dtx] -modefile=mode_file speech_file  bitstream_file\n\n"
; 169  :       " -dtx                enables DTX mode\n"
; 170  :       " -modefile=mode_file reads AMR modes from text file (one line per frame)\n\n",
; 171  :              progname, progname);

  00196	8b f4		 mov	 esi, esp
  00198	8b 45 f4	 mov	 eax, DWORD PTR _progname$[ebp]
  0019b	50		 push	 eax
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR _progname$[ebp]
  0019f	51		 push	 ecx
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0PM@GFONJINO@?5Usage?3?6?6?5?5?5?$CFs?5?$FL?9dtx?$FN?5amr_mode?5?5@
  001a5	8b fc		 mov	 edi, esp
  001a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  001ad	3b fc		 cmp	 edi, esp
  001af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b4	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001b9	d1 e2		 shl	 edx, 1
  001bb	03 c2		 add	 eax, edx
  001bd	50		 push	 eax
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  001c4	83 c4 10	 add	 esp, 16			; 00000010H
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  :       exit (1);

  001ce	8b f4		 mov	 esi, esp
  001d0	6a 01		 push	 1
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  001d8	3b f4		 cmp	 esi, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN32@coder_main:

; 173  :   }
; 174  : 
; 175  :   /*----------------------------------------------------------------------*
; 176  :    * Open mode file or convert mode string                                *
; 177  :    *----------------------------------------------------------------------*/
; 178  :   if (useModeFile) {

  001df	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _useModeFile$[ebp], 0
  001e6	0f 84 fb 00 00
	00		 je	 $LN29@coder_main

; 179  :       fileName = argv[1];

  001ec	b8 04 00 00 00	 mov	 eax, 4
  001f1	c1 e0 00	 shl	 eax, 0
  001f4	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  001f7	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001fa	89 55 d0	 mov	 DWORD PTR _fileName$[ebp], edx

; 180  :       serialFileName = argv[2];

  001fd	b8 04 00 00 00	 mov	 eax, 4
  00202	d1 e0		 shl	 eax, 1
  00204	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00207	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0020a	89 55 b8	 mov	 DWORD PTR _serialFileName$[ebp], edx

; 181  :       
; 182  :       /* Open mode control file */
; 183  :       if (strcmp(modefileName, "-") == 0) {

  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  00212	8b 45 c4	 mov	 eax, DWORD PTR _modefileName$[ebp]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 _strcmp
  0021b	83 c4 08	 add	 esp, 8
  0021e	85 c0		 test	 eax, eax
  00220	75 1e		 jne	 SHORT $LN28@coder_main

; 184  :           file_modes = stdin;

  00222	8b f4		 mov	 esi, esp
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0022a	3b f4		 cmp	 esi, esp
  0022c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00231	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00236	6b d1 00	 imul	 edx, ecx, 0
  00239	03 c2		 add	 eax, edx
  0023b	89 45 94	 mov	 DWORD PTR _file_modes$[ebp], eax
  0023e	eb 6e		 jmp	 SHORT $LN27@coder_main
$LN28@coder_main:

; 185  :       }
; 186  :       else if (fopen_s (&file_modes, modefileName, "rt") || file_modes == NULL)

  00240	8b f4		 mov	 esi, esp
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_02BMJICGCB@rt?$AA@
  00247	8b 45 c4	 mov	 eax, DWORD PTR _modefileName$[ebp]
  0024a	50		 push	 eax
  0024b	8d 4d 94	 lea	 ecx, DWORD PTR _file_modes$[ebp]
  0024e	51		 push	 ecx
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH
  00258	3b f4		 cmp	 esi, esp
  0025a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025f	85 c0		 test	 eax, eax
  00261	75 06		 jne	 SHORT $LN25@coder_main
  00263	83 7d 94 00	 cmp	 DWORD PTR _file_modes$[ebp], 0
  00267	75 45		 jne	 SHORT $LN27@coder_main
$LN25@coder_main:

; 187  :       {
; 188  :           fprintf (stderr, "Error opening mode control file  %s !!\n",
; 189  :                    modefileName);

  00269	8b f4		 mov	 esi, esp
  0026b	8b 45 c4	 mov	 eax, DWORD PTR _modefileName$[ebp]
  0026e	50		 push	 eax
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CGHOPIKO@Error?5opening?5mode?5control?5file?5@
  00274	8b fc		 mov	 edi, esp
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0027c	3b fc		 cmp	 edi, esp
  0027e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00283	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00288	d1 e1		 shl	 ecx, 1
  0028a	03 c1		 add	 eax, ecx
  0028c	50		 push	 eax
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00293	83 c4 0c	 add	 esp, 12			; 0000000cH
  00296	3b f4		 cmp	 esi, esp
  00298	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 190  :           exit (1);

  0029d	8b f4		 mov	 esi, esp
  0029f	6a 01		 push	 1
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  002a7	3b f4		 cmp	 esi, esp
  002a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN27@coder_main:

; 191  :       }
; 192  :       fprintf (stderr, " Mode control file:      %s\n", modefileName);

  002ae	8b f4		 mov	 esi, esp
  002b0	8b 45 c4	 mov	 eax, DWORD PTR _modefileName$[ebp]
  002b3	50		 push	 eax
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BJFEJIKL@?5Mode?5control?5file?3?5?5?5?5?5?5?$CFs?6?$AA@
  002b9	8b fc		 mov	 edi, esp
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  002c1	3b fc		 cmp	 edi, esp
  002c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002cd	d1 e1		 shl	 ecx, 1
  002cf	03 c1		 add	 eax, ecx
  002d1	50		 push	 eax
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  002d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002db	3b f4		 cmp	 esi, esp
  002dd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 193  : 
; 194  :   } else {

  002e2	e9 97 00 00 00	 jmp	 $LN24@coder_main
$LN29@coder_main:

; 195  :       
; 196  :       modeStr = argv[1];

  002e7	b8 04 00 00 00	 mov	 eax, 4
  002ec	c1 e0 00	 shl	 eax, 0
  002ef	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  002f2	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  002f5	89 55 e8	 mov	 DWORD PTR _modeStr$[ebp], edx

; 197  :       fileName = argv[2];

  002f8	b8 04 00 00 00	 mov	 eax, 4
  002fd	d1 e0		 shl	 eax, 1
  002ff	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00302	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00305	89 55 d0	 mov	 DWORD PTR _fileName$[ebp], edx

; 198  :       serialFileName = argv[3];

  00308	b8 04 00 00 00	 mov	 eax, 4
  0030d	6b c8 03	 imul	 ecx, eax, 3
  00310	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00313	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00316	89 45 b8	 mov	 DWORD PTR _serialFileName$[ebp], eax

; 199  :       
; 200  :       /* check and convert mode string */
; 201  :       if (str2mode(modeStr, &mode) != 0 && mode != MRDTX) {

  00319	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _mode$[ebp]
  0031f	50		 push	 eax
  00320	8b 4d e8	 mov	 ecx, DWORD PTR _modeStr$[ebp]
  00323	51		 push	 ecx
  00324	e8 00 00 00 00	 call	 _str2mode
  00329	83 c4 08	 add	 esp, 8
  0032c	85 c0		 test	 eax, eax
  0032e	74 4e		 je	 SHORT $LN24@coder_main
  00330	83 bd e0 fb ff
	ff 08		 cmp	 DWORD PTR _mode$[ebp], 8
  00337	74 45		 je	 SHORT $LN24@coder_main

; 202  :           fprintf(stderr, "Invalid amr_mode specified: '%s'\n",
; 203  :                   modeStr);

  00339	8b f4		 mov	 esi, esp
  0033b	8b 45 e8	 mov	 eax, DWORD PTR _modeStr$[ebp]
  0033e	50		 push	 eax
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FCPNNMIH@Invalid?5amr_mode?5specified?3?5?8?$CFs?8@
  00344	8b fc		 mov	 edi, esp
  00346	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0034c	3b fc		 cmp	 edi, esp
  0034e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00353	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00358	d1 e1		 shl	 ecx, 1
  0035a	03 c1		 add	 eax, ecx
  0035c	50		 push	 eax
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00363	83 c4 0c	 add	 esp, 12			; 0000000cH
  00366	3b f4		 cmp	 esi, esp
  00368	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 204  :           exit(1);

  0036d	8b f4		 mov	 esi, esp
  0036f	6a 01		 push	 1
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00377	3b f4		 cmp	 esi, esp
  00379	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN24@coder_main:

; 205  :       }
; 206  :   }
; 207  :   
; 208  : 
; 209  :   /*----------------------------------------------------------------------*
; 210  :    * Open speech file and result file (output serial bit stream)          *
; 211  :    *----------------------------------------------------------------------*/
; 212  :   if (strcmp(fileName, "-") == 0) {

  0037e	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  00383	8b 45 d0	 mov	 eax, DWORD PTR _fileName$[ebp]
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 _strcmp
  0038c	83 c4 08	 add	 esp, 8
  0038f	85 c0		 test	 eax, eax
  00391	75 1e		 jne	 SHORT $LN22@coder_main

; 213  :      file_speech = stdin;

  00393	8b f4		 mov	 esi, esp
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0039b	3b f4		 cmp	 esi, esp
  0039d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003a7	6b d1 00	 imul	 edx, ecx, 0
  003aa	03 c2		 add	 eax, edx
  003ac	89 45 ac	 mov	 DWORD PTR _file_speech$[ebp], eax
  003af	eb 6e		 jmp	 SHORT $LN21@coder_main
$LN22@coder_main:

; 214  :   }
; 215  :   else if (fopen_s(&file_speech, fileName, "rb") || file_speech == NULL)

  003b1	8b f4		 mov	 esi, esp
  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  003b8	8b 45 d0	 mov	 eax, DWORD PTR _fileName$[ebp]
  003bb	50		 push	 eax
  003bc	8d 4d ac	 lea	 ecx, DWORD PTR _file_speech$[ebp]
  003bf	51		 push	 ecx
  003c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  003c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c9	3b f4		 cmp	 esi, esp
  003cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d0	85 c0		 test	 eax, eax
  003d2	75 06		 jne	 SHORT $LN19@coder_main
  003d4	83 7d ac 00	 cmp	 DWORD PTR _file_speech$[ebp], 0
  003d8	75 45		 jne	 SHORT $LN21@coder_main
$LN19@coder_main:

; 216  :   {
; 217  :       fprintf (stderr, "Error opening input file  %s !!\n", fileName);

  003da	8b f4		 mov	 esi, esp
  003dc	8b 45 d0	 mov	 eax, DWORD PTR _fileName$[ebp]
  003df	50		 push	 eax
  003e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EDBECNLE@Error?5opening?5input?5file?5?5?$CFs?5?$CB?$CB?6@
  003e5	8b fc		 mov	 edi, esp
  003e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  003ed	3b fc		 cmp	 edi, esp
  003ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003f9	d1 e1		 shl	 ecx, 1
  003fb	03 c1		 add	 eax, ecx
  003fd	50		 push	 eax
  003fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00404	83 c4 0c	 add	 esp, 12			; 0000000cH
  00407	3b f4		 cmp	 esi, esp
  00409	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 218  :       exit (1);

  0040e	8b f4		 mov	 esi, esp
  00410	6a 01		 push	 1
  00412	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00418	3b f4		 cmp	 esi, esp
  0041a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@coder_main:

; 219  :   }
; 220  :   fprintf (stderr, " Input speech file:      %s\n", fileName);

  0041f	8b f4		 mov	 esi, esp
  00421	8b 45 d0	 mov	 eax, DWORD PTR _fileName$[ebp]
  00424	50		 push	 eax
  00425	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@INFCDJHG@?5Input?5speech?5file?3?5?5?5?5?5?5?$CFs?6?$AA@
  0042a	8b fc		 mov	 edi, esp
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00432	3b fc		 cmp	 edi, esp
  00434	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00439	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0043e	d1 e1		 shl	 ecx, 1
  00440	03 c1		 add	 eax, ecx
  00442	50		 push	 eax
  00443	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00449	83 c4 0c	 add	 esp, 12			; 0000000cH
  0044c	3b f4		 cmp	 esi, esp
  0044e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 221  : 
; 222  :   if (strcmp(serialFileName, "-") == 0) {

  00453	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  00458	8b 45 b8	 mov	 eax, DWORD PTR _serialFileName$[ebp]
  0045b	50		 push	 eax
  0045c	e8 00 00 00 00	 call	 _strcmp
  00461	83 c4 08	 add	 esp, 8
  00464	85 c0		 test	 eax, eax
  00466	75 1e		 jne	 SHORT $LN18@coder_main

; 223  :      file_serial = stdout;

  00468	8b f4		 mov	 esi, esp
  0046a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00470	3b f4		 cmp	 esi, esp
  00472	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00477	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0047c	c1 e1 00	 shl	 ecx, 0
  0047f	03 c1		 add	 eax, ecx
  00481	89 45 a0	 mov	 DWORD PTR _file_serial$[ebp], eax
  00484	eb 6e		 jmp	 SHORT $LN17@coder_main
$LN18@coder_main:

; 224  :   }
; 225  :   else if (fopen_s(&file_serial, serialFileName, "wb") || file_serial == NULL)

  00486	8b f4		 mov	 esi, esp
  00488	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb?$AA@
  0048d	8b 45 b8	 mov	 eax, DWORD PTR _serialFileName$[ebp]
  00490	50		 push	 eax
  00491	8d 4d a0	 lea	 ecx, DWORD PTR _file_serial$[ebp]
  00494	51		 push	 ecx
  00495	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen_s
  0049b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049e	3b f4		 cmp	 esi, esp
  004a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a5	85 c0		 test	 eax, eax
  004a7	75 06		 jne	 SHORT $LN15@coder_main
  004a9	83 7d a0 00	 cmp	 DWORD PTR _file_serial$[ebp], 0
  004ad	75 45		 jne	 SHORT $LN17@coder_main
$LN15@coder_main:

; 226  :   {
; 227  :       fprintf (stderr,"Error opening output bitstream file %s !!\n",serialFileName);

  004af	8b f4		 mov	 esi, esp
  004b1	8b 45 b8	 mov	 eax, DWORD PTR _serialFileName$[ebp]
  004b4	50		 push	 eax
  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PFECDEDN@Error?5opening?5output?5bitstream?5f@
  004ba	8b fc		 mov	 edi, esp
  004bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  004c2	3b fc		 cmp	 edi, esp
  004c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  004ce	d1 e1		 shl	 ecx, 1
  004d0	03 c1		 add	 eax, ecx
  004d2	50		 push	 eax
  004d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  004d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004dc	3b f4		 cmp	 esi, esp
  004de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 228  :       exit (1);

  004e3	8b f4		 mov	 esi, esp
  004e5	6a 01		 push	 1
  004e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  004ed	3b f4		 cmp	 esi, esp
  004ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@coder_main:

; 229  :   }
; 230  :   fprintf (stderr, " Output bitstream file:  %s\n", serialFileName);

  004f4	8b f4		 mov	 esi, esp
  004f6	8b 45 b8	 mov	 eax, DWORD PTR _serialFileName$[ebp]
  004f9	50		 push	 eax
  004fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IKIHJAKD@?5Output?5bitstream?5file?3?5?5?$CFs?6?$AA@
  004ff	8b fc		 mov	 edi, esp
  00501	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00507	3b fc		 cmp	 edi, esp
  00509	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00513	d1 e1		 shl	 ecx, 1
  00515	03 c1		 add	 eax, ecx
  00517	50		 push	 eax
  00518	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0051e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00521	3b f4		 cmp	 esi, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 231  : 
; 232  : 
; 233  :   /*-----------------------------------------------------------------------*
; 234  :    * Initialisation of the coder.                                          *
; 235  :    *-----------------------------------------------------------------------*/
; 236  :   if (   Speech_Encode_Frame_init(&speech_encoder_state, dtx, "encoder")
; 237  :       || sid_sync_init (&sid_state))

  00528	68 00 00 00 00	 push	 OFFSET ??_C@_07KLAMFGHC@encoder?$AA@
  0052d	0f bf 85 04 fc
	ff ff		 movsx	 eax, WORD PTR _dtx$[ebp]
  00534	50		 push	 eax
  00535	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _speech_encoder_state$[ebp]
  0053b	51		 push	 ecx
  0053c	e8 00 00 00 00	 call	 _Speech_Encode_Frame_init
  00541	83 c4 0c	 add	 esp, 12			; 0000000cH
  00544	85 c0		 test	 eax, eax
  00546	75 13		 jne	 SHORT $LN13@coder_main
  00548	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR _sid_state$[ebp]
  0054e	50		 push	 eax
  0054f	e8 00 00 00 00	 call	 _sid_sync_init
  00554	83 c4 04	 add	 esp, 4
  00557	85 c0		 test	 eax, eax
  00559	74 11		 je	 SHORT $LN14@coder_main
$LN13@coder_main:

; 238  :       exit(-1);

  0055b	8b f4		 mov	 esi, esp
  0055d	6a ff		 push	 -1
  0055f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00565	3b f4		 cmp	 esi, esp
  00567	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@coder_main:

; 239  : 
; 240  : #ifdef MMS_IO
; 241  :   /* write magic number to indicate single channel AMR file storage format */
; 242  :   fwrite(AMR_MAGIC_NUMBER, sizeof(UWord8), strlen(AMR_MAGIC_NUMBER), file_serial);

  0056c	8b f4		 mov	 esi, esp
  0056e	8b 45 a0	 mov	 eax, DWORD PTR _file_serial$[ebp]
  00571	50		 push	 eax
  00572	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  00577	e8 00 00 00 00	 call	 _strlen
  0057c	83 c4 04	 add	 esp, 4
  0057f	50		 push	 eax
  00580	6a 01		 push	 1
  00582	68 00 00 00 00	 push	 OFFSET ??_C@_06MJAMDGFO@?$CD?$CBAMR?6?$AA@
  00587	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  0058d	83 c4 10	 add	 esp, 16			; 00000010H
  00590	3b f4		 cmp	 esi, esp
  00592	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 243  : #endif
; 244  : 
; 245  :   /*-----------------------------------------------------------------------*
; 246  :    * Process speech frame by frame                                         *
; 247  :    *-----------------------------------------------------------------------*/
; 248  :   frame = 0;

  00597	c7 85 10 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _frame$[ebp], 0
$LN12@coder_main:

; 249  :   while (fread (new_speech, sizeof (Word16), L_FRAME, file_speech) == L_FRAME)

  005a1	8b f4		 mov	 esi, esp
  005a3	8b 45 ac	 mov	 eax, DWORD PTR _file_speech$[ebp]
  005a6	50		 push	 eax
  005a7	68 a0 00 00 00	 push	 160			; 000000a0H
  005ac	6a 02		 push	 2
  005ae	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR _new_speech$[ebp]
  005b4	51		 push	 ecx
  005b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  005bb	83 c4 10	 add	 esp, 16			; 00000010H
  005be	3b f4		 cmp	 esi, esp
  005c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005c5	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  005ca	0f 85 da 02 00
	00		 jne	 $LN11@coder_main

; 250  :   {
; 251  :      /* read new mode string from file if required */
; 252  :      if (useModeFile) {

  005d0	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR _useModeFile$[ebp], 0
  005d7	74 73		 je	 SHORT $LN10@coder_main

; 253  :          int res;
; 254  :          if ((res = read_mode(file_modes, &mode)) == EOF) {

  005d9	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _mode$[ebp]
  005df	50		 push	 eax
  005e0	8b 4d 94	 mov	 ecx, DWORD PTR _file_modes$[ebp]
  005e3	51		 push	 ecx
  005e4	e8 00 00 00 00	 call	 _read_mode
  005e9	83 c4 08	 add	 esp, 8
  005ec	89 85 98 fb ff
	ff		 mov	 DWORD PTR _res$2[ebp], eax
  005f2	83 bd 98 fb ff
	ff ff		 cmp	 DWORD PTR _res$2[ebp], -1
  005f9	75 37		 jne	 SHORT $LN9@coder_main

; 255  :              fprintf(stderr, "\nend of mode control file reached");

  005fb	8b f4		 mov	 esi, esp
  005fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DOGOGDHP@?6end?5of?5mode?5control?5file?5reache@
  00602	8b fc		 mov	 edi, esp
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0060a	3b fc		 cmp	 edi, esp
  0060c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00611	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00616	d1 e1		 shl	 ecx, 1
  00618	03 c1		 add	 eax, ecx
  0061a	50		 push	 eax
  0061b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00621	83 c4 08	 add	 esp, 8
  00624	3b f4		 cmp	 esi, esp
  00626	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 256  :              break;

  0062b	e9 7a 02 00 00	 jmp	 $LN11@coder_main
  00630	eb 1a		 jmp	 SHORT $LN10@coder_main
$LN9@coder_main:

; 257  :          } else if (res == 1)

  00632	83 bd 98 fb ff
	ff 01		 cmp	 DWORD PTR _res$2[ebp], 1
  00639	75 11		 jne	 SHORT $LN10@coder_main

; 258  :              exit(-1);

  0063b	8b f4		 mov	 esi, esp
  0063d	6a ff		 push	 -1
  0063f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00645	3b f4		 cmp	 esi, esp
  00647	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@coder_main:

; 259  :      }
; 260  :       
; 261  :      frame++;

  0064c	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  00652	83 c0 01	 add	 eax, 1
  00655	89 85 10 fc ff
	ff		 mov	 DWORD PTR _frame$[ebp], eax

; 262  :      
; 263  :      /* zero flags and parameter bits */
; 264  :      for (i = 0; i < SERIAL_FRAMESIZE; i++)

  0065b	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00665	eb 0f		 jmp	 SHORT $LN6@coder_main
$LN5@coder_main:
  00667	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0066d	83 c0 01	 add	 eax, 1
  00670	89 85 ec fb ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN6@coder_main:
  00676	81 bd ec fb ff
	ff fa 00 00 00	 cmp	 DWORD PTR _i$[ebp], 250	; 000000faH
  00680	7d 33		 jge	 SHORT $LN4@coder_main

; 265  :          serial[i] = 0;

  00682	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00688	d1 e0		 shl	 eax, 1
  0068a	89 85 cc fa ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00690	81 bd cc fa ff
	ff f4 01 00 00	 cmp	 DWORD PTR $T1[ebp], 500	; 000001f4H
  0069a	73 02		 jae	 SHORT $LN41@coder_main
  0069c	eb 05		 jmp	 SHORT $LN42@coder_main
$LN41@coder_main:
  0069e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN42@coder_main:
  006a3	33 c9		 xor	 ecx, ecx
  006a5	8b 95 cc fa ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  006ab	66 89 8c 15 50
	fc ff ff	 mov	 WORD PTR _serial$[ebp+edx], cx
  006b3	eb b2		 jmp	 SHORT $LN5@coder_main
$LN4@coder_main:

; 266  : 
; 267  :      /* check for homing frame */
; 268  :      reset_flag = encoder_homing_frame_test(new_speech);

  006b5	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _new_speech$[ebp]
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 _encoder_homing_frame_test
  006c1	83 c4 04	 add	 esp, 4
  006c4	66 89 85 f8 fb
	ff ff		 mov	 WORD PTR _reset_flag$[ebp], ax

; 269  :      
; 270  :      /* encode speech */
; 271  :      Speech_Encode_Frame(speech_encoder_state, mode,
; 272  :                          new_speech, &serial[1], &used_mode); 

  006cb	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _used_mode$[ebp]
  006d1	50		 push	 eax
  006d2	b9 02 00 00 00	 mov	 ecx, 2
  006d7	c1 e1 00	 shl	 ecx, 0
  006da	8d 94 0d 50 fc
	ff ff		 lea	 edx, DWORD PTR _serial$[ebp+ecx]
  006e1	52		 push	 edx
  006e2	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _new_speech$[ebp]
  006e8	50		 push	 eax
  006e9	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _mode$[ebp]
  006ef	51		 push	 ecx
  006f0	8b 95 b0 fb ff
	ff		 mov	 edx, DWORD PTR _speech_encoder_state$[ebp]
  006f6	52		 push	 edx
  006f7	e8 00 00 00 00	 call	 _Speech_Encode_Frame
  006fc	83 c4 14	 add	 esp, 20			; 00000014H

; 273  : 
; 274  :      /* print frame number and mode information */
; 275  :      mode2str(mode, &modeStr);

  006ff	8d 45 e8	 lea	 eax, DWORD PTR _modeStr$[ebp]
  00702	50		 push	 eax
  00703	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _mode$[ebp]
  00709	51		 push	 ecx
  0070a	e8 00 00 00 00	 call	 _mode2str
  0070f	83 c4 08	 add	 esp, 8

; 276  :      mode2str(used_mode, &usedModeStr);

  00712	8d 45 dc	 lea	 eax, DWORD PTR _usedModeStr$[ebp]
  00715	50		 push	 eax
  00716	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _used_mode$[ebp]
  0071c	51		 push	 ecx
  0071d	e8 00 00 00 00	 call	 _mode2str
  00722	83 c4 08	 add	 esp, 8

; 277  :      if ( (frame%50) == 0) {

  00725	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  0072b	99		 cdq
  0072c	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00731	f7 f9		 idiv	 ecx
  00733	85 d2		 test	 edx, edx
  00735	75 3f		 jne	 SHORT $LN3@coder_main

; 278  :         fprintf (stderr, "\rframe=%-8d mode=%-5s used_mode=%-5s",
; 279  :                  frame, modeStr, usedModeStr);

  00737	8b f4		 mov	 esi, esp
  00739	8b 45 dc	 mov	 eax, DWORD PTR _usedModeStr$[ebp]
  0073c	50		 push	 eax
  0073d	8b 4d e8	 mov	 ecx, DWORD PTR _modeStr$[ebp]
  00740	51		 push	 ecx
  00741	8b 95 10 fc ff
	ff		 mov	 edx, DWORD PTR _frame$[ebp]
  00747	52		 push	 edx
  00748	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@FPNDKFCB@?$ANframe?$DN?$CF?98d?5mode?$DN?$CF?95s?5used_mode?$DN@
  0074d	8b fc		 mov	 edi, esp
  0074f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00755	3b fc		 cmp	 edi, esp
  00757	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0075c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00761	d1 e1		 shl	 ecx, 1
  00763	03 c1		 add	 eax, ecx
  00765	50		 push	 eax
  00766	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0076c	83 c4 14	 add	 esp, 20			; 00000014H
  0076f	3b f4		 cmp	 esi, esp
  00771	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@coder_main:

; 280  :      }
; 281  : 
; 282  :      /* include frame type and mode information in serial bitstream */
; 283  :      sid_sync (sid_state, used_mode, &tx_type);

  00776	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _tx_type$[ebp]
  0077c	50		 push	 eax
  0077d	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _used_mode$[ebp]
  00783	51		 push	 ecx
  00784	8b 95 a4 fb ff
	ff		 mov	 edx, DWORD PTR _sid_state$[ebp]
  0078a	52		 push	 edx
  0078b	e8 00 00 00 00	 call	 _sid_sync
  00790	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 
; 285  : #ifndef MMS_IO
; 286  :      serial[0] = tx_type;
; 287  :      if (tx_type != TX_NO_DATA) {
; 288  :        serial[1+MAX_SERIAL_SIZE] = mode;
; 289  :      }
; 290  :      else {
; 291  :        serial[1+MAX_SERIAL_SIZE] = -1;
; 292  :      }
; 293  : 
; 294  :      /* write bitstream to output file */
; 295  :      if (fwrite (serial, sizeof (Word16), SERIAL_FRAMESIZE, file_serial)
; 296  :          != SERIAL_FRAMESIZE) {
; 297  :          fprintf(stderr, "\nerror writing output file: %s\n",
; 298  :                  strerror(errno));
; 299  :          exit(-1);
; 300  :      }
; 301  : #else
; 302  : 
; 303  :      packed_size = PackBits(used_mode, mode, tx_type, &serial[1], packed_bits);

  00793	8d 85 28 fc ff
	ff		 lea	 eax, DWORD PTR _packed_bits$[ebp]
  00799	50		 push	 eax
  0079a	b9 02 00 00 00	 mov	 ecx, 2
  0079f	c1 e1 00	 shl	 ecx, 0
  007a2	8d 94 0d 50 fc
	ff ff		 lea	 edx, DWORD PTR _serial$[ebp+ecx]
  007a9	52		 push	 edx
  007aa	8b 85 c8 fb ff
	ff		 mov	 eax, DWORD PTR _tx_type$[ebp]
  007b0	50		 push	 eax
  007b1	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _mode$[ebp]
  007b7	51		 push	 ecx
  007b8	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _used_mode$[ebp]
  007be	52		 push	 edx
  007bf	e8 00 00 00 00	 call	 _PackBits
  007c4	83 c4 14	 add	 esp, 20			; 00000014H
  007c7	66 89 85 1c fc
	ff ff		 mov	 WORD PTR _packed_size$[ebp], ax

; 304  : 
; 305  :      /* write file storage format bitstream to output file */
; 306  :      if (fwrite (packed_bits, sizeof (UWord8), packed_size, file_serial)
; 307  :          != packed_size) {

  007ce	8b f4		 mov	 esi, esp
  007d0	8b 45 a0	 mov	 eax, DWORD PTR _file_serial$[ebp]
  007d3	50		 push	 eax
  007d4	0f bf 8d 1c fc
	ff ff		 movsx	 ecx, WORD PTR _packed_size$[ebp]
  007db	51		 push	 ecx
  007dc	6a 01		 push	 1
  007de	8d 95 28 fc ff
	ff		 lea	 edx, DWORD PTR _packed_bits$[ebp]
  007e4	52		 push	 edx
  007e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  007eb	83 c4 10	 add	 esp, 16			; 00000010H
  007ee	3b f4		 cmp	 esi, esp
  007f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007f5	0f bf 8d 1c fc
	ff ff		 movsx	 ecx, WORD PTR _packed_size$[ebp]
  007fc	3b c1		 cmp	 eax, ecx
  007fe	74 66		 je	 SHORT $LN2@coder_main

; 308  :          fprintf(stderr, "\nerror writing output file: %s\n",
; 309  :                  strerror(errno));

  00800	8b f4		 mov	 esi, esp
  00802	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00808	3b f4		 cmp	 esi, esp
  0080a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0080f	8b f4		 mov	 esi, esp
  00811	8b 00		 mov	 eax, DWORD PTR [eax]
  00813	50		 push	 eax
  00814	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  0081a	83 c4 04	 add	 esp, 4
  0081d	3b f4		 cmp	 esi, esp
  0081f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00824	8b f4		 mov	 esi, esp
  00826	50		 push	 eax
  00827	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FHPBCEHP@?6error?5writing?5output?5file?3?5?$CFs?6?$AA@
  0082c	8b fc		 mov	 edi, esp
  0082e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00834	3b fc		 cmp	 edi, esp
  00836	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0083b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00840	d1 e1		 shl	 ecx, 1
  00842	03 c1		 add	 eax, ecx
  00844	50		 push	 eax
  00845	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0084b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0084e	3b f4		 cmp	 esi, esp
  00850	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 310  :          exit(-1);

  00855	8b f4		 mov	 esi, esp
  00857	6a ff		 push	 -1
  00859	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0085f	3b f4		 cmp	 esi, esp
  00861	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@coder_main:

; 311  :      }
; 312  : #endif
; 313  : 
; 314  :      fflush(file_serial);

  00866	8b f4		 mov	 esi, esp
  00868	8b 45 a0	 mov	 eax, DWORD PTR _file_serial$[ebp]
  0086b	50		 push	 eax
  0086c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00872	83 c4 04	 add	 esp, 4
  00875	3b f4		 cmp	 esi, esp
  00877	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 315  : 
; 316  :      /* perform homing if homing frame was detected at encoder input */
; 317  :      if (reset_flag != 0)

  0087c	0f bf 85 f8 fb
	ff ff		 movsx	 eax, WORD PTR _reset_flag$[ebp]
  00883	85 c0		 test	 eax, eax
  00885	74 1e		 je	 SHORT $LN1@coder_main

; 318  :      {
; 319  :          Speech_Encode_Frame_reset(speech_encoder_state);

  00887	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR _speech_encoder_state$[ebp]
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 _Speech_Encode_Frame_reset
  00893	83 c4 04	 add	 esp, 4

; 320  :          sid_sync_reset(sid_state);

  00896	8b 85 a4 fb ff
	ff		 mov	 eax, DWORD PTR _sid_state$[ebp]
  0089c	50		 push	 eax
  0089d	e8 00 00 00 00	 call	 _sid_sync_reset
  008a2	83 c4 04	 add	 esp, 4
$LN1@coder_main:

; 321  :      }
; 322  :   }

  008a5	e9 f7 fc ff ff	 jmp	 $LN12@coder_main
$LN11@coder_main:

; 323  :   fprintf (stderr, "\n%d frame(s) processed\n", frame);

  008aa	8b f4		 mov	 esi, esp
  008ac	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _frame$[ebp]
  008b2	50		 push	 eax
  008b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LFMGIPDC@?6?$CFd?5frame?$CIs?$CJ?5processed?6?$AA@
  008b8	8b fc		 mov	 edi, esp
  008ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  008c0	3b fc		 cmp	 edi, esp
  008c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008c7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  008cc	d1 e1		 shl	 ecx, 1
  008ce	03 c1		 add	 eax, ecx
  008d0	50		 push	 eax
  008d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  008d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  008da	3b f4		 cmp	 esi, esp
  008dc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 324  :   
; 325  :   /*-----------------------------------------------------------------------*
; 326  :    * Close down speech coder                                               *
; 327  :    *-----------------------------------------------------------------------*/
; 328  :   Speech_Encode_Frame_exit(&speech_encoder_state);

  008e1	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR _speech_encoder_state$[ebp]
  008e7	50		 push	 eax
  008e8	e8 00 00 00 00	 call	 _Speech_Encode_Frame_exit
  008ed	83 c4 04	 add	 esp, 4

; 329  :   sid_sync_exit (&sid_state);

  008f0	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR _sid_state$[ebp]
  008f6	50		 push	 eax
  008f7	e8 00 00 00 00	 call	 _sid_sync_exit
  008fc	83 c4 04	 add	 esp, 4

; 330  :   
; 331  :   return (0);

  008ff	33 c0		 xor	 eax, eax
$LN40@coder_main:

; 332  : }

  00901	52		 push	 edx
  00902	8b cd		 mov	 ecx, ebp
  00904	50		 push	 eax
  00905	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN57@coder_main
  0090b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00910	58		 pop	 eax
  00911	5a		 pop	 edx
  00912	5f		 pop	 edi
  00913	5e		 pop	 esi
  00914	5b		 pop	 ebx
  00915	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00918	33 cd		 xor	 ecx, ebp
  0091a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0091f	81 c4 38 05 00
	00		 add	 esp, 1336		; 00000538H
  00925	3b ec		 cmp	 ebp, esp
  00927	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0092c	8b e5		 mov	 esp, ebp
  0092e	5d		 pop	 ebp
  0092f	c3		 ret	 0
$LN57@coder_main:
  00930	0d 00 00 00	 DD	 13			; 0000000dH
  00934	00 00 00 00	 DD	 $LN56@coder_main
$LN56@coder_main:
  00938	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0093c	04 00 00 00	 DD	 4
  00940	00 00 00 00	 DD	 $LN43@coder_main
  00944	dc ff ff ff	 DD	 -36			; ffffffdcH
  00948	04 00 00 00	 DD	 4
  0094c	00 00 00 00	 DD	 $LN44@coder_main
  00950	ac ff ff ff	 DD	 -84			; ffffffacH
  00954	04 00 00 00	 DD	 4
  00958	00 00 00 00	 DD	 $LN45@coder_main
  0095c	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00960	04 00 00 00	 DD	 4
  00964	00 00 00 00	 DD	 $LN46@coder_main
  00968	94 ff ff ff	 DD	 -108			; ffffff94H
  0096c	04 00 00 00	 DD	 4
  00970	00 00 00 00	 DD	 $LN47@coder_main
  00974	4c fe ff ff	 DD	 -436			; fffffe4cH
  00978	40 01 00 00	 DD	 320			; 00000140H
  0097c	00 00 00 00	 DD	 $LN48@coder_main
  00980	50 fc ff ff	 DD	 -944			; fffffc50H
  00984	f4 01 00 00	 DD	 500			; 000001f4H
  00988	00 00 00 00	 DD	 $LN49@coder_main
  0098c	28 fc ff ff	 DD	 -984			; fffffc28H
  00990	20 00 00 00	 DD	 32			; 00000020H
  00994	00 00 00 00	 DD	 $LN50@coder_main
  00998	e0 fb ff ff	 DD	 -1056			; fffffbe0H
  0099c	04 00 00 00	 DD	 4
  009a0	00 00 00 00	 DD	 $LN51@coder_main
  009a4	d4 fb ff ff	 DD	 -1068			; fffffbd4H
  009a8	04 00 00 00	 DD	 4
  009ac	00 00 00 00	 DD	 $LN52@coder_main
  009b0	c8 fb ff ff	 DD	 -1080			; fffffbc8H
  009b4	04 00 00 00	 DD	 4
  009b8	00 00 00 00	 DD	 $LN53@coder_main
  009bc	b0 fb ff ff	 DD	 -1104			; fffffbb0H
  009c0	04 00 00 00	 DD	 4
  009c4	00 00 00 00	 DD	 $LN54@coder_main
  009c8	a4 fb ff ff	 DD	 -1116			; fffffba4H
  009cc	04 00 00 00	 DD	 4
  009d0	00 00 00 00	 DD	 $LN55@coder_main
$LN55@coder_main:
  009d4	73		 DB	 115			; 00000073H
  009d5	69		 DB	 105			; 00000069H
  009d6	64		 DB	 100			; 00000064H
  009d7	5f		 DB	 95			; 0000005fH
  009d8	73		 DB	 115			; 00000073H
  009d9	74		 DB	 116			; 00000074H
  009da	61		 DB	 97			; 00000061H
  009db	74		 DB	 116			; 00000074H
  009dc	65		 DB	 101			; 00000065H
  009dd	00		 DB	 0
$LN54@coder_main:
  009de	73		 DB	 115			; 00000073H
  009df	70		 DB	 112			; 00000070H
  009e0	65		 DB	 101			; 00000065H
  009e1	65		 DB	 101			; 00000065H
  009e2	63		 DB	 99			; 00000063H
  009e3	68		 DB	 104			; 00000068H
  009e4	5f		 DB	 95			; 0000005fH
  009e5	65		 DB	 101			; 00000065H
  009e6	6e		 DB	 110			; 0000006eH
  009e7	63		 DB	 99			; 00000063H
  009e8	6f		 DB	 111			; 0000006fH
  009e9	64		 DB	 100			; 00000064H
  009ea	65		 DB	 101			; 00000065H
  009eb	72		 DB	 114			; 00000072H
  009ec	5f		 DB	 95			; 0000005fH
  009ed	73		 DB	 115			; 00000073H
  009ee	74		 DB	 116			; 00000074H
  009ef	61		 DB	 97			; 00000061H
  009f0	74		 DB	 116			; 00000074H
  009f1	65		 DB	 101			; 00000065H
  009f2	00		 DB	 0
$LN53@coder_main:
  009f3	74		 DB	 116			; 00000074H
  009f4	78		 DB	 120			; 00000078H
  009f5	5f		 DB	 95			; 0000005fH
  009f6	74		 DB	 116			; 00000074H
  009f7	79		 DB	 121			; 00000079H
  009f8	70		 DB	 112			; 00000070H
  009f9	65		 DB	 101			; 00000065H
  009fa	00		 DB	 0
$LN52@coder_main:
  009fb	75		 DB	 117			; 00000075H
  009fc	73		 DB	 115			; 00000073H
  009fd	65		 DB	 101			; 00000065H
  009fe	64		 DB	 100			; 00000064H
  009ff	5f		 DB	 95			; 0000005fH
  00a00	6d		 DB	 109			; 0000006dH
  00a01	6f		 DB	 111			; 0000006fH
  00a02	64		 DB	 100			; 00000064H
  00a03	65		 DB	 101			; 00000065H
  00a04	00		 DB	 0
$LN51@coder_main:
  00a05	6d		 DB	 109			; 0000006dH
  00a06	6f		 DB	 111			; 0000006fH
  00a07	64		 DB	 100			; 00000064H
  00a08	65		 DB	 101			; 00000065H
  00a09	00		 DB	 0
$LN50@coder_main:
  00a0a	70		 DB	 112			; 00000070H
  00a0b	61		 DB	 97			; 00000061H
  00a0c	63		 DB	 99			; 00000063H
  00a0d	6b		 DB	 107			; 0000006bH
  00a0e	65		 DB	 101			; 00000065H
  00a0f	64		 DB	 100			; 00000064H
  00a10	5f		 DB	 95			; 0000005fH
  00a11	62		 DB	 98			; 00000062H
  00a12	69		 DB	 105			; 00000069H
  00a13	74		 DB	 116			; 00000074H
  00a14	73		 DB	 115			; 00000073H
  00a15	00		 DB	 0
$LN49@coder_main:
  00a16	73		 DB	 115			; 00000073H
  00a17	65		 DB	 101			; 00000065H
  00a18	72		 DB	 114			; 00000072H
  00a19	69		 DB	 105			; 00000069H
  00a1a	61		 DB	 97			; 00000061H
  00a1b	6c		 DB	 108			; 0000006cH
  00a1c	00		 DB	 0
$LN48@coder_main:
  00a1d	6e		 DB	 110			; 0000006eH
  00a1e	65		 DB	 101			; 00000065H
  00a1f	77		 DB	 119			; 00000077H
  00a20	5f		 DB	 95			; 0000005fH
  00a21	73		 DB	 115			; 00000073H
  00a22	70		 DB	 112			; 00000070H
  00a23	65		 DB	 101			; 00000065H
  00a24	65		 DB	 101			; 00000065H
  00a25	63		 DB	 99			; 00000063H
  00a26	68		 DB	 104			; 00000068H
  00a27	00		 DB	 0
$LN47@coder_main:
  00a28	66		 DB	 102			; 00000066H
  00a29	69		 DB	 105			; 00000069H
  00a2a	6c		 DB	 108			; 0000006cH
  00a2b	65		 DB	 101			; 00000065H
  00a2c	5f		 DB	 95			; 0000005fH
  00a2d	6d		 DB	 109			; 0000006dH
  00a2e	6f		 DB	 111			; 0000006fH
  00a2f	64		 DB	 100			; 00000064H
  00a30	65		 DB	 101			; 00000065H
  00a31	73		 DB	 115			; 00000073H
  00a32	00		 DB	 0
$LN46@coder_main:
  00a33	66		 DB	 102			; 00000066H
  00a34	69		 DB	 105			; 00000069H
  00a35	6c		 DB	 108			; 0000006cH
  00a36	65		 DB	 101			; 00000065H
  00a37	5f		 DB	 95			; 0000005fH
  00a38	73		 DB	 115			; 00000073H
  00a39	65		 DB	 101			; 00000065H
  00a3a	72		 DB	 114			; 00000072H
  00a3b	69		 DB	 105			; 00000069H
  00a3c	61		 DB	 97			; 00000061H
  00a3d	6c		 DB	 108			; 0000006cH
  00a3e	00		 DB	 0
$LN45@coder_main:
  00a3f	66		 DB	 102			; 00000066H
  00a40	69		 DB	 105			; 00000069H
  00a41	6c		 DB	 108			; 0000006cH
  00a42	65		 DB	 101			; 00000065H
  00a43	5f		 DB	 95			; 0000005fH
  00a44	73		 DB	 115			; 00000073H
  00a45	70		 DB	 112			; 00000070H
  00a46	65		 DB	 101			; 00000065H
  00a47	65		 DB	 101			; 00000065H
  00a48	63		 DB	 99			; 00000063H
  00a49	68		 DB	 104			; 00000068H
  00a4a	00		 DB	 0
$LN44@coder_main:
  00a4b	75		 DB	 117			; 00000075H
  00a4c	73		 DB	 115			; 00000073H
  00a4d	65		 DB	 101			; 00000065H
  00a4e	64		 DB	 100			; 00000064H
  00a4f	4d		 DB	 77			; 0000004dH
  00a50	6f		 DB	 111			; 0000006fH
  00a51	64		 DB	 100			; 00000064H
  00a52	65		 DB	 101			; 00000065H
  00a53	53		 DB	 83			; 00000053H
  00a54	74		 DB	 116			; 00000074H
  00a55	72		 DB	 114			; 00000072H
  00a56	00		 DB	 0
$LN43@coder_main:
  00a57	6d		 DB	 109			; 0000006dH
  00a58	6f		 DB	 111			; 0000006fH
  00a59	64		 DB	 100			; 00000064H
  00a5a	65		 DB	 101			; 00000065H
  00a5b	53		 DB	 83			; 00000053H
  00a5c	74		 DB	 116			; 00000074H
  00a5d	72		 DB	 114			; 00000072H
  00a5e	00		 DB	 0
_coder_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\coder.c
;	COMDAT _read_mode
_TEXT	SEGMENT
_buf$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_file_modes$ = 8					; size = 4
_mode$ = 12						; size = 4
_read_mode PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 77   :     char buf[10];
; 78   :     
; 79   :     if (fscanf_s(file_modes, "%9s\n", buf) != 1) {

  00028	8b f4		 mov	 esi, esp
  0002a	8d 45 ec	 lea	 eax, DWORD PTR _buf$[ebp]
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_04BBIHCBDO@?$CF9s?6?$AA@
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _file_modes$[ebp]
  00036	51		 push	 ecx
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fscanf_s
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	83 f8 01	 cmp	 eax, 1
  0004a	74 7e		 je	 SHORT $LN4@read_mode

; 80   :         if (feof(file_modes))

  0004c	8b f4		 mov	 esi, esp
  0004e	8b 45 08	 mov	 eax, DWORD PTR _file_modes$[ebp]
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__feof
  00058	83 c4 04	 add	 esp, 4
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	85 c0		 test	 eax, eax
  00064	74 08		 je	 SHORT $LN3@read_mode

; 81   :             return EOF;

  00066	83 c8 ff	 or	 eax, -1
  00069	e9 b5 00 00 00	 jmp	 $LN5@read_mode
$LN3@read_mode:

; 82   : 
; 83   :         fprintf(stderr, "\nerror reading mode control file: %s\n",
; 84   :                 strerror(errno));

  0006e	8b f4		 mov	 esi, esp
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b f4		 mov	 esi, esp
  0007f	8b 00		 mov	 eax, DWORD PTR [eax]
  00081	50		 push	 eax
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00088	83 c4 04	 add	 esp, 4
  0008b	3b f4		 cmp	 esi, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b f4		 mov	 esi, esp
  00094	50		 push	 eax
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OIMIKGJJ@?6error?5reading?5mode?5control?5file@
  0009a	8b fc		 mov	 edi, esp
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  000a2	3b fc		 cmp	 edi, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000ae	d1 e1		 shl	 ecx, 1
  000b0	03 c1		 add	 eax, ecx
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 85   :         return 1;

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	eb 59		 jmp	 SHORT $LN5@read_mode
$LN4@read_mode:

; 86   :     }
; 87   : 
; 88   :     if (str2mode(buf, mode) != 0 || *mode == MRDTX) {

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  000cd	50		 push	 eax
  000ce	8d 4d ec	 lea	 ecx, DWORD PTR _buf$[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 _str2mode
  000d7	83 c4 08	 add	 esp, 8
  000da	85 c0		 test	 eax, eax
  000dc	75 08		 jne	 SHORT $LN1@read_mode
  000de	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  000e1	83 38 08	 cmp	 DWORD PTR [eax], 8
  000e4	75 3b		 jne	 SHORT $LN2@read_mode
$LN1@read_mode:

; 89   :         fprintf(stderr, "\ninvalid amr_mode found in mode control file: '%s'\n",
; 90   :                 buf);

  000e6	8b f4		 mov	 esi, esp
  000e8	8d 45 ec	 lea	 eax, DWORD PTR _buf$[ebp]
  000eb	50		 push	 eax
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FBIIBAM@?6invalid?5amr_mode?5found?5in?5mode?5@
  000f1	8b fc		 mov	 edi, esp
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  000f9	3b fc		 cmp	 edi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00105	d1 e1		 shl	 ecx, 1
  00107	03 c1		 add	 eax, ecx
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
  00113	3b f4		 cmp	 esi, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 91   :         return 1;

  0011a	b8 01 00 00 00	 mov	 eax, 1
  0011f	eb 02		 jmp	 SHORT $LN5@read_mode
$LN2@read_mode:

; 92   :     }
; 93   : 
; 94   :     return 0;

  00121	33 c0		 xor	 eax, eax
$LN5@read_mode:

; 95   : }

  00123	52		 push	 edx
  00124	8b cd		 mov	 ecx, ebp
  00126	50		 push	 eax
  00127	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@read_mode
  0012d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00132	58		 pop	 eax
  00133	5a		 pop	 edx
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx
  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00147	3b ec		 cmp	 ebp, esp
  00149	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
  00152	8b ff		 npad	 2
$LN9@read_mode:
  00154	01 00 00 00	 DD	 1
  00158	00 00 00 00	 DD	 $LN8@read_mode
$LN8@read_mode:
  0015c	ec ff ff ff	 DD	 -20			; ffffffecH
  00160	0a 00 00 00	 DD	 10			; 0000000aH
  00164	00 00 00 00	 DD	 $LN7@read_mode
$LN7@read_mode:
  00168	62		 DB	 98			; 00000062H
  00169	75		 DB	 117			; 00000075H
  0016a	66		 DB	 102			; 00000066H
  0016b	00		 DB	 0
_read_mode ENDP
_TEXT	ENDS
END
