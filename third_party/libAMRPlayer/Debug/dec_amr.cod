; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\dec_amr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_dec_amr_id
_DATA	SEGMENT
_bitno	DD	FLAT:_bitno_MR475
	DD	FLAT:_bitno_MR515
	DD	FLAT:_bitno_MR59
	DD	FLAT:_bitno_MR67
	DD	FLAT:_bitno_MR74
	DD	FLAT:_bitno_MR795
	DD	FLAT:_bitno_MR102
	DD	FLAT:_bitno_MR122
	DD	FLAT:_bitno_MRDTX
_toc_byte DB	04H
	DB	0cH
	DB	014H
	DB	01cH
	DB	024H
	DB	02cH
	DB	034H
	DB	03cH
	DB	044H
	DB	04cH
	DB	054H
	DB	05cH
	DB	064H
	DB	06cH
	DB	074H
	DB	07cH
_unpacked_size DW 05fH
	DW	067H
	DW	076H
	DW	086H
	DW	094H
	DW	09fH
	DW	0ccH
	DW	0f4H
	DW	023H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
_packed_size DW	0dH
	DW	0eH
	DW	010H
	DW	012H
	DW	014H
	DW	015H
	DW	01bH
	DW	020H
	DW	06H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
_unused_size DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+4
_sort_475 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	030H
	DW	031H
	DW	03dH
	DW	03eH
	DW	052H
	DW	053H
	DW	02fH
	DW	02eH
	DW	02dH
	DW	02cH
	DW	051H
	DW	050H
	DW	04fH
	DW	04eH
	DW	011H
	DW	012H
	DW	014H
	DW	016H
	DW	04dH
	DW	04cH
	DW	04bH
	DW	04aH
	DW	01dH
	DW	01eH
	DW	02bH
	DW	02aH
	DW	029H
	DW	028H
	DW	026H
	DW	027H
	DW	010H
	DW	013H
	DW	015H
	DW	032H
	DW	033H
	DW	03bH
	DW	03cH
	DW	03fH
	DW	040H
	DW	048H
	DW	049H
	DW	054H
	DW	055H
	DW	05dH
	DW	05eH
	DW	020H
	DW	021H
	DW	023H
	DW	024H
	DW	035H
	DW	036H
	DW	038H
	DW	039H
	DW	042H
	DW	043H
	DW	045H
	DW	046H
	DW	057H
	DW	058H
	DW	05aH
	DW	05bH
	DW	022H
	DW	037H
	DW	044H
	DW	059H
	DW	025H
	DW	03aH
	DW	047H
	DW	05cH
	DW	01fH
	DW	034H
	DW	041H
	DW	056H
	ORG $+2
_sort_515 DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	00H
	DW	0fH
	DW	0eH
	DW	0dH
	DW	0cH
	DW	0bH
	DW	0aH
	DW	09H
	DW	08H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	02eH
	DW	041H
	DW	054H
	DW	02dH
	DW	02cH
	DW	02bH
	DW	040H
	DW	03fH
	DW	03eH
	DW	053H
	DW	052H
	DW	051H
	DW	066H
	DW	065H
	DW	064H
	DW	02aH
	DW	03dH
	DW	050H
	DW	063H
	DW	01cH
	DW	02fH
	DW	042H
	DW	055H
	DW	012H
	DW	029H
	DW	03cH
	DW	04fH
	DW	062H
	DW	01dH
	DW	030H
	DW	043H
	DW	011H
	DW	014H
	DW	016H
	DW	028H
	DW	03bH
	DW	04eH
	DW	061H
	DW	015H
	DW	01eH
	DW	031H
	DW	044H
	DW	056H
	DW	013H
	DW	010H
	DW	057H
	DW	027H
	DW	026H
	DW	03aH
	DW	039H
	DW	04dH
	DW	023H
	DW	036H
	DW	049H
	DW	05cH
	DW	04cH
	DW	060H
	DW	05fH
	DW	024H
	DW	037H
	DW	04aH
	DW	05dH
	DW	020H
	DW	033H
	DW	021H
	DW	034H
	DW	046H
	DW	047H
	DW	059H
	DW	05aH
	DW	01fH
	DW	032H
	DW	045H
	DW	058H
	DW	025H
	DW	038H
	DW	04bH
	DW	05eH
	DW	022H
	DW	035H
	DW	048H
	DW	05bH
	ORG $+2
_sort_59 DW	00H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	06H
	DW	07H
	DW	02H
	DW	0dH
	DW	0fH
	DW	08H
	DW	09H
	DW	0bH
	DW	0cH
	DW	0eH
	DW	0aH
	DW	010H
	DW	01cH
	DW	04aH
	DW	01dH
	DW	04bH
	DW	01bH
	DW	049H
	DW	01aH
	DW	048H
	DW	01eH
	DW	04cH
	DW	033H
	DW	061H
	DW	032H
	DW	047H
	DW	060H
	DW	075H
	DW	01fH
	DW	04dH
	DW	034H
	DW	062H
	DW	031H
	DW	046H
	DW	05fH
	DW	074H
	DW	035H
	DW	063H
	DW	020H
	DW	04eH
	DW	021H
	DW	04fH
	DW	030H
	DW	045H
	DW	05eH
	DW	073H
	DW	02fH
	DW	044H
	DW	05dH
	DW	072H
	DW	02eH
	DW	043H
	DW	05cH
	DW	071H
	DW	013H
	DW	015H
	DW	017H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	06fH
	DW	02bH
	DW	059H
	DW	06eH
	DW	040H
	DW	041H
	DW	02cH
	DW	05aH
	DW	019H
	DW	02dH
	DW	042H
	DW	05bH
	DW	070H
	DW	036H
	DW	064H
	DW	028H
	DW	03dH
	DW	056H
	DW	06bH
	DW	027H
	DW	03cH
	DW	055H
	DW	06aH
	DW	024H
	DW	039H
	DW	052H
	DW	067H
	DW	023H
	DW	038H
	DW	051H
	DW	066H
	DW	022H
	DW	037H
	DW	050H
	DW	065H
	DW	02aH
	DW	03fH
	DW	058H
	DW	06dH
	DW	029H
	DW	03eH
	DW	057H
	DW	06cH
	DW	026H
	DW	03bH
	DW	054H
	DW	069H
	DW	025H
	DW	03aH
	DW	053H
	DW	068H
	ORG $+4
_sort_67 DW	00H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	06H
	DW	0dH
	DW	07H
	DW	02H
	DW	08H
	DW	09H
	DW	0bH
	DW	0fH
	DW	0cH
	DW	0eH
	DW	0aH
	DW	01cH
	DW	052H
	DW	01dH
	DW	053H
	DW	01bH
	DW	051H
	DW	01aH
	DW	050H
	DW	01eH
	DW	054H
	DW	010H
	DW	037H
	DW	06dH
	DW	038H
	DW	06eH
	DW	01fH
	DW	055H
	DW	039H
	DW	06fH
	DW	030H
	DW	049H
	DW	066H
	DW	07fH
	DW	020H
	DW	056H
	DW	033H
	DW	04cH
	DW	069H
	DW	082H
	DW	034H
	DW	04dH
	DW	06aH
	DW	083H
	DW	03aH
	DW	070H
	DW	021H
	DW	057H
	DW	013H
	DW	017H
	DW	035H
	DW	04eH
	DW	06bH
	DW	084H
	DW	015H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	019H
	DW	032H
	DW	04bH
	DW	068H
	DW	081H
	DW	02fH
	DW	048H
	DW	065H
	DW	07eH
	DW	036H
	DW	04fH
	DW	06cH
	DW	085H
	DW	02eH
	DW	047H
	DW	064H
	DW	07dH
	DW	080H
	DW	067H
	DW	04aH
	DW	031H
	DW	02dH
	DW	046H
	DW	063H
	DW	07cH
	DW	02aH
	DW	043H
	DW	060H
	DW	079H
	DW	027H
	DW	040H
	DW	05dH
	DW	076H
	DW	026H
	DW	03fH
	DW	05cH
	DW	075H
	DW	023H
	DW	03cH
	DW	059H
	DW	072H
	DW	022H
	DW	03bH
	DW	058H
	DW	071H
	DW	02cH
	DW	045H
	DW	062H
	DW	07bH
	DW	02bH
	DW	044H
	DW	061H
	DW	07aH
	DW	029H
	DW	042H
	DW	05fH
	DW	078H
	DW	028H
	DW	041H
	DW	05eH
	DW	077H
	DW	025H
	DW	03eH
	DW	05bH
	DW	074H
	DW	024H
	DW	03dH
	DW	05aH
	DW	073H
	ORG $+4
_sort_74 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	01aH
	DW	057H
	DW	01bH
	DW	058H
	DW	01cH
	DW	059H
	DW	01dH
	DW	05aH
	DW	01eH
	DW	05bH
	DW	033H
	DW	050H
	DW	070H
	DW	08dH
	DW	034H
	DW	051H
	DW	071H
	DW	08eH
	DW	036H
	DW	053H
	DW	073H
	DW	090H
	DW	037H
	DW	054H
	DW	074H
	DW	091H
	DW	03aH
	DW	077H
	DW	03bH
	DW	078H
	DW	015H
	DW	016H
	DW	017H
	DW	011H
	DW	012H
	DW	013H
	DW	01fH
	DW	03cH
	DW	05cH
	DW	079H
	DW	038H
	DW	055H
	DW	075H
	DW	092H
	DW	014H
	DW	018H
	DW	019H
	DW	032H
	DW	04fH
	DW	06fH
	DW	08cH
	DW	039H
	DW	056H
	DW	076H
	DW	093H
	DW	031H
	DW	04eH
	DW	06eH
	DW	08bH
	DW	030H
	DW	04dH
	DW	035H
	DW	052H
	DW	072H
	DW	08fH
	DW	06dH
	DW	08aH
	DW	02fH
	DW	04cH
	DW	06cH
	DW	089H
	DW	020H
	DW	021H
	DW	03dH
	DW	03eH
	DW	05dH
	DW	05eH
	DW	07aH
	DW	07bH
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	046H
	DW	047H
	DW	048H
	DW	049H
	DW	04aH
	DW	04bH
	DW	066H
	DW	067H
	DW	068H
	DW	069H
	DW	06aH
	DW	06bH
	DW	083H
	DW	084H
	DW	085H
	DW	086H
	DW	087H
	DW	088H
	DW	022H
	DW	03fH
	DW	05fH
	DW	07cH
	DW	023H
	DW	040H
	DW	060H
	DW	07dH
	DW	024H
	DW	041H
	DW	061H
	DW	07eH
	DW	025H
	DW	042H
	DW	062H
	DW	07fH
	DW	026H
	DW	043H
	DW	063H
	DW	080H
	DW	027H
	DW	044H
	DW	064H
	DW	081H
	DW	028H
	DW	045H
	DW	065H
	DW	082H
_sort_795 DW	08H
	DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	0eH
	DW	010H
	DW	09H
	DW	0aH
	DW	0cH
	DW	0dH
	DW	0fH
	DW	0bH
	DW	011H
	DW	014H
	DW	016H
	DW	018H
	DW	017H
	DW	013H
	DW	012H
	DW	015H
	DW	038H
	DW	058H
	DW	07aH
	DW	09aH
	DW	039H
	DW	059H
	DW	07bH
	DW	09bH
	DW	03aH
	DW	05aH
	DW	07cH
	DW	09cH
	DW	034H
	DW	054H
	DW	076H
	DW	096H
	DW	035H
	DW	055H
	DW	077H
	DW	097H
	DW	01bH
	DW	05dH
	DW	01cH
	DW	05eH
	DW	01dH
	DW	05fH
	DW	01eH
	DW	060H
	DW	01fH
	DW	061H
	DW	03dH
	DW	07fH
	DW	03eH
	DW	080H
	DW	03fH
	DW	081H
	DW	03bH
	DW	05bH
	DW	07dH
	DW	09dH
	DW	020H
	DW	062H
	DW	040H
	DW	082H
	DW	01H
	DW	00H
	DW	019H
	DW	01aH
	DW	021H
	DW	063H
	DW	022H
	DW	064H
	DW	041H
	DW	083H
	DW	042H
	DW	084H
	DW	036H
	DW	056H
	DW	078H
	DW	098H
	DW	03cH
	DW	05cH
	DW	07eH
	DW	09eH
	DW	037H
	DW	057H
	DW	079H
	DW	099H
	DW	075H
	DW	074H
	DW	073H
	DW	02eH
	DW	04eH
	DW	070H
	DW	090H
	DW	02bH
	DW	04bH
	DW	06dH
	DW	08dH
	DW	028H
	DW	048H
	DW	06aH
	DW	08aH
	DW	024H
	DW	044H
	DW	066H
	DW	086H
	DW	072H
	DW	095H
	DW	094H
	DW	093H
	DW	092H
	DW	053H
	DW	052H
	DW	051H
	DW	050H
	DW	033H
	DW	032H
	DW	031H
	DW	030H
	DW	02fH
	DW	02dH
	DW	02cH
	DW	02aH
	DW	027H
	DW	023H
	DW	04fH
	DW	04dH
	DW	04cH
	DW	04aH
	DW	047H
	DW	043H
	DW	071H
	DW	06fH
	DW	06eH
	DW	06cH
	DW	069H
	DW	065H
	DW	091H
	DW	08fH
	DW	08eH
	DW	08cH
	DW	089H
	DW	085H
	DW	029H
	DW	049H
	DW	06bH
	DW	08bH
	DW	025H
	DW	045H
	DW	067H
	DW	087H
	DW	026H
	DW	046H
	DW	068H
	DW	088H
	ORG $+2
_sort_102 DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	00H
	DW	010H
	DW	0fH
	DW	0eH
	DW	0dH
	DW	0cH
	DW	0bH
	DW	0aH
	DW	09H
	DW	08H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	073H
	DW	074H
	DW	075H
	DW	076H
	DW	077H
	DW	078H
	DW	048H
	DW	049H
	DW	0a1H
	DW	0a2H
	DW	041H
	DW	044H
	DW	045H
	DW	06cH
	DW	06fH
	DW	070H
	DW	09aH
	DW	09dH
	DW	09eH
	DW	0c5H
	DW	0c8H
	DW	0c9H
	DW	020H
	DW	021H
	DW	079H
	DW	07aH
	DW	04aH
	DW	04bH
	DW	0a3H
	DW	0a4H
	DW	042H
	DW	06dH
	DW	09bH
	DW	0c6H
	DW	013H
	DW	017H
	DW	015H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	019H
	DW	025H
	DW	024H
	DW	023H
	DW	022H
	DW	050H
	DW	04fH
	DW	04eH
	DW	04dH
	DW	07eH
	DW	07dH
	DW	07cH
	DW	07bH
	DW	0a9H
	DW	0a8H
	DW	0a7H
	DW	0a6H
	DW	046H
	DW	043H
	DW	047H
	DW	071H
	DW	06eH
	DW	072H
	DW	09fH
	DW	09cH
	DW	0a0H
	DW	0caH
	DW	0c7H
	DW	0cbH
	DW	04cH
	DW	0a5H
	DW	051H
	DW	052H
	DW	05cH
	DW	05bH
	DW	05dH
	DW	053H
	DW	05fH
	DW	055H
	DW	054H
	DW	05eH
	DW	065H
	DW	066H
	DW	060H
	DW	068H
	DW	056H
	DW	067H
	DW	057H
	DW	061H
	DW	07fH
	DW	080H
	DW	08aH
	DW	089H
	DW	08bH
	DW	081H
	DW	08dH
	DW	083H
	DW	082H
	DW	08cH
	DW	093H
	DW	094H
	DW	08eH
	DW	096H
	DW	084H
	DW	095H
	DW	085H
	DW	08fH
	DW	0aaH
	DW	0abH
	DW	0b5H
	DW	0b4H
	DW	0b6H
	DW	0acH
	DW	0b8H
	DW	0aeH
	DW	0adH
	DW	0b7H
	DW	0beH
	DW	0bfH
	DW	0b9H
	DW	0c1H
	DW	0afH
	DW	0c0H
	DW	0b0H
	DW	0baH
	DW	026H
	DW	027H
	DW	031H
	DW	030H
	DW	032H
	DW	028H
	DW	034H
	DW	02aH
	DW	029H
	DW	033H
	DW	03aH
	DW	03bH
	DW	035H
	DW	03dH
	DW	02bH
	DW	03cH
	DW	02cH
	DW	036H
	DW	0c2H
	DW	0b3H
	DW	0bdH
	DW	0c4H
	DW	0b1H
	DW	0c3H
	DW	0b2H
	DW	0bbH
	DW	0bcH
	DW	097H
	DW	088H
	DW	092H
	DW	099H
	DW	086H
	DW	098H
	DW	087H
	DW	090H
	DW	091H
	DW	069H
	DW	05aH
	DW	064H
	DW	06bH
	DW	058H
	DW	06aH
	DW	059H
	DW	062H
	DW	063H
	DW	03eH
	DW	02fH
	DW	039H
	DW	040H
	DW	02dH
	DW	03fH
	DW	02eH
	DW	037H
	DW	038H
_sort_122 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	017H
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	026H
	DW	08dH
	DW	027H
	DW	08eH
	DW	028H
	DW	08fH
	DW	029H
	DW	090H
	DW	02aH
	DW	091H
	DW	02bH
	DW	092H
	DW	02cH
	DW	093H
	DW	02dH
	DW	094H
	DW	02eH
	DW	095H
	DW	02fH
	DW	061H
	DW	096H
	DW	0c8H
	DW	030H
	DW	062H
	DW	097H
	DW	0c9H
	DW	031H
	DW	063H
	DW	098H
	DW	0caH
	DW	056H
	DW	088H
	DW	0bdH
	DW	0efH
	DW	057H
	DW	089H
	DW	0beH
	DW	0f0H
	DW	058H
	DW	08aH
	DW	0bfH
	DW	0f1H
	DW	05bH
	DW	0c2H
	DW	05cH
	DW	0c3H
	DW	05dH
	DW	0c4H
	DW	05eH
	DW	0c5H
	DW	05fH
	DW	0c6H
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	032H
	DW	064H
	DW	099H
	DW	0cbH
	DW	059H
	DW	08bH
	DW	0c0H
	DW	0f2H
	DW	033H
	DW	065H
	DW	09aH
	DW	0ccH
	DW	037H
	DW	069H
	DW	09eH
	DW	0d0H
	DW	05aH
	DW	08cH
	DW	0c1H
	DW	0f3H
	DW	03bH
	DW	06dH
	DW	0a2H
	DW	0d4H
	DW	03fH
	DW	071H
	DW	0a6H
	DW	0d8H
	DW	043H
	DW	075H
	DW	0aaH
	DW	0dcH
	DW	024H
	DW	025H
	DW	036H
	DW	035H
	DW	034H
	DW	03aH
	DW	039H
	DW	038H
	DW	03eH
	DW	03dH
	DW	03cH
	DW	042H
	DW	041H
	DW	040H
	DW	046H
	DW	045H
	DW	044H
	DW	068H
	DW	067H
	DW	066H
	DW	06cH
	DW	06bH
	DW	06aH
	DW	070H
	DW	06fH
	DW	06eH
	DW	074H
	DW	073H
	DW	072H
	DW	078H
	DW	077H
	DW	076H
	DW	09dH
	DW	09cH
	DW	09bH
	DW	0a1H
	DW	0a0H
	DW	09fH
	DW	0a5H
	DW	0a4H
	DW	0a3H
	DW	0a9H
	DW	0a8H
	DW	0a7H
	DW	0adH
	DW	0acH
	DW	0abH
	DW	0cfH
	DW	0ceH
	DW	0cdH
	DW	0d3H
	DW	0d2H
	DW	0d1H
	DW	0d7H
	DW	0d6H
	DW	0d5H
	DW	0dbH
	DW	0daH
	DW	0d9H
	DW	0dfH
	DW	0deH
	DW	0ddH
	DW	049H
	DW	048H
	DW	047H
	DW	04cH
	DW	04bH
	DW	04aH
	DW	04fH
	DW	04eH
	DW	04dH
	DW	052H
	DW	051H
	DW	050H
	DW	055H
	DW	054H
	DW	053H
	DW	07bH
	DW	07aH
	DW	079H
	DW	07eH
	DW	07dH
	DW	07cH
	DW	081H
	DW	080H
	DW	07fH
	DW	084H
	DW	083H
	DW	082H
	DW	087H
	DW	086H
	DW	085H
	DW	0b0H
	DW	0afH
	DW	0aeH
	DW	0b3H
	DW	0b2H
	DW	0b1H
	DW	0b6H
	DW	0b5H
	DW	0b4H
	DW	0b9H
	DW	0b8H
	DW	0b7H
	DW	0bcH
	DW	0bbH
	DW	0baH
	DW	0e2H
	DW	0e1H
	DW	0e0H
	DW	0e5H
	DW	0e4H
	DW	0e3H
	DW	0e8H
	DW	0e7H
	DW	0e6H
	DW	0ebH
	DW	0eaH
	DW	0e9H
	DW	0eeH
	DW	0edH
	DW	0ecH
	DW	060H
	DW	0c7H
_sort_SID DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	ORG $+2
_sort_ptr DD	FLAT:_sort_475
	DD	FLAT:_sort_515
	DD	FLAT:_sort_59
	DD	FLAT:_sort_67
	DD	FLAT:_sort_74
	DD	FLAT:_sort_795
	DD	FLAT:_sort_102
	DD	FLAT:_sort_122
	DD	FLAT:_sort_SID
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
_lsp_init_data DW 07530H
	DW	06590H
	DW	05208H
	DW	03a98H
	DW	01f40H
	DW	00H
	DW	0e0c0H
	DW	0c568H
	DW	0adf8H
	DW	09a70H
_bitno_id DB	'@(#)$Id $', 00H
	ORG $+2
_prmno	DW	011H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	017H
	DW	027H
	DW	039H
	DW	05H
	ORG $+2
_prmnofsf DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	07H
	DW	08H
	DW	0cH
	DW	012H
_bitno_MR475 DW	08H
	DW	08H
	DW	07H
	DW	08H
	DW	07H
	DW	02H
	DW	08H
	DW	04H
	DW	07H
	DW	02H
	DW	04H
	DW	07H
	DW	02H
	DW	08H
	DW	04H
	DW	07H
	DW	02H
	ORG $+2
_bitno_MR515 DW	08H
	DW	08H
	DW	07H
	DW	08H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	ORG $+2
_bitno_MR59 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	09H
	DW	02H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	06H
	DW	08H
	DW	09H
	DW	02H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	06H
	ORG $+2
_bitno_MR67 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	0bH
	DW	03H
	DW	07H
	DW	04H
	DW	0bH
	DW	03H
	DW	07H
	DW	08H
	DW	0bH
	DW	03H
	DW	07H
	DW	04H
	DW	0bH
	DW	03H
	DW	07H
	ORG $+2
_bitno_MR74 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	0dH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	04H
	DW	07H
	DW	08H
	DW	0dH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	04H
	DW	07H
	ORG $+2
_bitno_MR795 DW	09H
	DW	09H
	DW	09H
	DW	08H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	06H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	08H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	06H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	ORG $+2
_bitno_MR102 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	ORG $+2
_bitno_MR122 DW	07H
	DW	08H
	DW	09H
	DW	08H
	DW	06H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	ORG $+2
_bitno_MRDTX DW	03H
	DW	08H
	DW	09H
	DW	09H
	DW	06H
	ORG $+2
_dec_amr_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_Decoder_amr_init
PUBLIC	_Decoder_amr_reset
PUBLIC	_Decoder_amr_exit
PUBLIC	_Decoder_amr
PUBLIC	??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@ ; `string'
PUBLIC	??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@ ; `string'
PUBLIC	??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@ ; `string'
EXTRN	_gc_pred_init:PROC
EXTRN	_gc_pred_reset:PROC
EXTRN	_gc_pred_exit:PROC
EXTRN	_D_plsf_init:PROC
EXTRN	_D_plsf_reset:PROC
EXTRN	_D_plsf_exit:PROC
EXTRN	_D_plsf_5:PROC
EXTRN	_D_plsf_3:PROC
EXTRN	_Cb_gain_average_init:PROC
EXTRN	_Cb_gain_average_reset:PROC
EXTRN	_Cb_gain_average_exit:PROC
EXTRN	_Cb_gain_average:PROC
EXTRN	_dtx_dec_init:PROC
EXTRN	_dtx_dec_reset:PROC
EXTRN	_dtx_dec_exit:PROC
EXTRN	_dtx_dec:PROC
EXTRN	_dtx_dec_activity_update:PROC
EXTRN	_rx_dtx_handler:PROC
EXTRN	_ec_gain_code_init:PROC
EXTRN	_ec_gain_code_reset:PROC
EXTRN	_ec_gain_code_exit:PROC
EXTRN	_ec_gain_code:PROC
EXTRN	_ec_gain_code_update:PROC
EXTRN	_ec_gain_pitch_init:PROC
EXTRN	_ec_gain_pitch_reset:PROC
EXTRN	_ec_gain_pitch_exit:PROC
EXTRN	_ec_gain_pitch:PROC
EXTRN	_ec_gain_pitch_update:PROC
EXTRN	_ph_disp_init:PROC
EXTRN	_ph_disp_reset:PROC
EXTRN	_ph_disp_exit:PROC
EXTRN	_ph_disp_lock:PROC
EXTRN	_ph_disp_release:PROC
EXTRN	_ph_disp:PROC
EXTRN	_Bgn_scd_init:PROC
EXTRN	_Bgn_scd_reset:PROC
EXTRN	_Bgn_scd_exit:PROC
EXTRN	_Bgn_scd:PROC
EXTRN	_lsp_avg_init:PROC
EXTRN	_lsp_avg_reset:PROC
EXTRN	_lsp_avg_exit:PROC
EXTRN	_lsp_avg:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_fwc:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Copy:PROC
EXTRN	_Set_zero:PROC
EXTRN	_Syn_filt:PROC
EXTRN	_agc2:PROC
EXTRN	_Int_lpc_1and3:PROC
EXTRN	_Int_lpc_1to3:PROC
EXTRN	_Dec_gain:PROC
EXTRN	_Dec_lag3:PROC
EXTRN	_Dec_lag6:PROC
EXTRN	_decode_2i40_9bits:PROC
EXTRN	_decode_2i40_11bits:PROC
EXTRN	_decode_3i40_14bits:PROC
EXTRN	_decode_4i40_17bits:PROC
EXTRN	_dec_8i40_31bits:PROC
EXTRN	_dec_10i40_35bits:PROC
EXTRN	_Pred_lt_3or6:PROC
EXTRN	_d_gain_pitch:PROC
EXTRN	_d_gain_code:PROC
EXTRN	_Int_lsf:PROC
EXTRN	_Lsf_lsp:PROC
EXTRN	_Ex_ctrl:PROC
EXTRN	_sqrt_l_exp:PROC
EXTRN	_build_CN_param:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_Overflow:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@ DB 'Decoder_amr_r'
	DB	'eset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@ DB 'Decoder_amr_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@ DB 'Decoder_amr_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr
_TEXT	SEGMENT
tv616 = -912						; size = 4
_newDTXState$ = -712					; size = 4
_pdfi$ = -700						; size = 2
_bfi$ = -688						; size = 2
_evenSubfr$ = -676					; size = 2
_subfrNr$ = -664					; size = 2
_excEnergy$ = -652					; size = 2
_carefulFlag$ = -640					; size = 2
_flag4$ = -628						; size = 2
_L_temp$ = -616						; size = 4
_temp$ = -604						; size = 2
_tmp_shift$ = -592					; size = 2
_delta_frc_range$ = -580				; size = 2
_delta_frc_low$ = -568					; size = 2
_t0_max$ = -556						; size = 2
_t0_min$ = -544						; size = 2
_pitch_fac$ = -532					; size = 2
_pit_flag$ = -520					; size = 2
_pit_sharp$ = -508					; size = 2
_gain_code_mix$ = -496					; size = 2
_gain_code$ = -484					; size = 2
_gain_pit$ = -472					; size = 2
_index_mr475$ = -460					; size = 2
_index$ = -448						; size = 2
_T0_frac$ = -436					; size = 2
_T0$ = -424						; size = 2
_i_subfr$ = -412					; size = 2
_i$ = -400						; size = 2
_exc_enhanced$ = -388					; size = 80
_excp$ = -300						; size = 80
_code$ = -212						; size = 80
_lsf_i$ = -124						; size = 20
_prev_lsf$ = -96					; size = 20
_lsp_mid$ = -68						; size = 20
_lsp_new$ = -40						; size = 20
_Az$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_parm$ = 16						; size = 4
_frame_type$ = 20					; size = 4
_synth$ = 24						; size = 4
_A_t$ = 28						; size = 4
_Decoder_amr PROC					; COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 03 00
	00		 sub	 esp, 912		; 00000390H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 70 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-912]
  00012	b9 e4 00 00 00	 mov	 ecx, 228		; 000000e4H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 265  :     /* LPC coefficients */
; 266  :    
; 267  :     Word16 *Az;                /* Pointer on A_t */
; 268  :     
; 269  :     /* LSPs */
; 270  : 
; 271  :     Word16 lsp_new[M];
; 272  :     Word16 lsp_mid[M];
; 273  : 
; 274  :     /* LSFs */
; 275  :     
; 276  :     Word16 prev_lsf[M];
; 277  :     Word16 lsf_i[M];    
; 278  : 
; 279  :     /* Algebraic codevector */
; 280  : 
; 281  :     Word16 code[L_SUBFR];
; 282  : 
; 283  :     /* excitation */
; 284  : 
; 285  :     Word16 excp[L_SUBFR];
; 286  :     Word16 exc_enhanced[L_SUBFR];
; 287  : 
; 288  :     /* Scalars */
; 289  : 
; 290  :     Word16 i, i_subfr;
; 291  :     Word16 T0, T0_frac, index, index_mr475 = 0;

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 85 34 fe
	ff ff		 mov	 WORD PTR _index_mr475$[ebp], ax

; 292  :     Word16 gain_pit, gain_code, gain_code_mix, pit_sharp, pit_flag, pitch_fac;
; 293  :     Word16 t0_min, t0_max;
; 294  :     Word16 delta_frc_low, delta_frc_range;
; 295  :     Word16 tmp_shift;
; 296  :     Word16 temp;
; 297  :     Word32 L_temp;
; 298  :     Word16 flag4;
; 299  :     Word16 carefulFlag;
; 300  :     Word16 excEnergy;
; 301  :     Word16 subfrNr; 
; 302  :     Word16 evenSubfr = 0;

  00031	33 c0		 xor	 eax, eax
  00033	66 89 85 5c fd
	ff ff		 mov	 WORD PTR _evenSubfr$[ebp], ax

; 303  : 
; 304  :     Word16 bfi = 0;   /* bad frame indication flag                          */

  0003a	33 c0		 xor	 eax, eax
  0003c	66 89 85 50 fd
	ff ff		 mov	 WORD PTR _bfi$[ebp], ax

; 305  :     Word16 pdfi = 0;  /* potential degraded bad frame flag                  */

  00043	33 c0		 xor	 eax, eax
  00045	66 89 85 44 fd
	ff ff		 mov	 WORD PTR _pdfi$[ebp], ax

; 306  : 
; 307  :     enum DTXStateType newDTXState;  /* SPEECH , DTX, DTX_MUTE */
; 308  : 
; 309  :     /* find the new  DTX state  SPEECH OR DTX */
; 310  :     newDTXState = rx_dtx_handler(st->dtxDecoderState, frame_type);

  0004c	8b 45 14	 mov	 eax, DWORD PTR _frame_type$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00053	8b 91 08 02 00
	00		 mov	 edx, DWORD PTR [ecx+520]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _rx_dtx_handler
  0005f	83 c4 08	 add	 esp, 8
  00062	89 85 38 fd ff
	ff		 mov	 DWORD PTR _newDTXState$[ebp], eax

; 311  :     move16 ();   /* function result */

  00068	e8 00 00 00 00	 call	 _move16

; 312  :     
; 313  :     /* DTX actions */
; 314  :     test();

  0006d	e8 00 00 00 00	 call	 _test

; 315  :     if (sub(newDTXState, SPEECH) != 0 )

  00072	6a 00		 push	 0
  00074	0f b7 85 38 fd
	ff ff		 movzx	 eax, WORD PTR _newDTXState$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _sub
  00081	83 c4 08	 add	 esp, 8
  00084	0f bf c8	 movsx	 ecx, ax
  00087	85 c9		 test	 ecx, ecx
  00089	0f 84 a3 00 00
	00		 je	 $LN129@Decoder_am

; 316  :     {
; 317  :        Decoder_amr_reset (st, MRDTX);

  0008f	6a 08		 push	 8
  00091	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _Decoder_amr_reset
  0009a	83 c4 08	 add	 esp, 8

; 318  : 
; 319  :        dtx_dec(st->dtxDecoderState, 
; 320  :                st->mem_syn, 
; 321  :                st->lsfState, 
; 322  :                st->pred_state,
; 323  :                st->Cb_gain_averState,
; 324  :                newDTXState,
; 325  :                mode, 
; 326  :                parm, synth, A_t);

  0009d	8b 45 1c	 mov	 eax, DWORD PTR _A_t$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 18	 mov	 ecx, DWORD PTR _synth$[ebp]
  000a4	51		 push	 ecx
  000a5	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  000ac	50		 push	 eax
  000ad	8b 8d 38 fd ff
	ff		 mov	 ecx, DWORD PTR _newDTXState$[ebp]
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000b7	8b 82 ec 01 00
	00		 mov	 eax, DWORD PTR [edx+492]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000c1	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  000c7	52		 push	 edx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000cb	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR [eax+500]
  000d1	51		 push	 ecx
  000d2	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000d5	81 c2 9c 01 00
	00		 add	 edx, 412		; 0000019cH
  000db	52		 push	 edx
  000dc	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000df	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  000e5	51		 push	 ecx
  000e6	e8 00 00 00 00	 call	 _dtx_dec
  000eb	83 c4 28	 add	 esp, 40			; 00000028H

; 327  :        /* update average lsp */
; 328  :        
; 329  :        Lsf_lsp(st->lsfState->past_lsf_q, st->lsp_old, M);

  000ee	6a 0a		 push	 10			; 0000000aH
  000f0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000f3	05 88 01 00 00	 add	 eax, 392		; 00000188H
  000f8	50		 push	 eax
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000fc	8b 91 f4 01 00
	00		 mov	 edx, DWORD PTR [ecx+500]
  00102	83 c2 14	 add	 edx, 20			; 00000014H
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 _Lsf_lsp
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  :        lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);

  0010e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00111	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR [eax+500]
  00117	83 c1 14	 add	 ecx, 20			; 00000014H
  0011a	51		 push	 ecx
  0011b	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0011e	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _lsp_avg
  0012a	83 c4 08	 add	 esp, 8

; 331  :        goto the_end;

  0012d	e9 89 20 00 00	 jmp	 $the_end$148
$LN129@Decoder_am:

; 332  :     }
; 333  : 
; 334  :     /* SPEECH action state machine  */
; 335  :     test (); test (); test (); 

  00132	e8 00 00 00 00	 call	 _test
  00137	e8 00 00 00 00	 call	 _test
  0013c	e8 00 00 00 00	 call	 _test

; 336  :     if ((sub(frame_type, RX_SPEECH_BAD) == 0) || 
; 337  :         (sub(frame_type, RX_NO_DATA) == 0) ||
; 338  :         (sub(frame_type, RX_ONSET) == 0)) 

  00141	6a 03		 push	 3
  00143	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _sub
  0014d	83 c4 08	 add	 esp, 8
  00150	0f bf c8	 movsx	 ecx, ax
  00153	85 c9		 test	 ecx, ecx
  00155	74 2c		 je	 SHORT $LN127@Decoder_am
  00157	6a 07		 push	 7
  00159	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 _sub
  00163	83 c4 08	 add	 esp, 8
  00166	0f bf c8	 movsx	 ecx, ax
  00169	85 c9		 test	 ecx, ecx
  0016b	74 16		 je	 SHORT $LN127@Decoder_am
  0016d	6a 02		 push	 2
  0016f	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _sub
  00179	83 c4 08	 add	 esp, 8
  0017c	0f bf c8	 movsx	 ecx, ax
  0017f	85 c9		 test	 ecx, ecx
  00181	75 76		 jne	 SHORT $LN128@Decoder_am
$LN127@Decoder_am:

; 339  :     {
; 340  :        bfi = 1;                                          move16 ();

  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	66 89 85 50 fd
	ff ff		 mov	 WORD PTR _bfi$[ebp], ax
  0018f	e8 00 00 00 00	 call	 _move16

; 341  :        test(); test();

  00194	e8 00 00 00 00	 call	 _test
  00199	e8 00 00 00 00	 call	 _test

; 342  :        if ((sub(frame_type, RX_NO_DATA) == 0) ||
; 343  :            (sub(frame_type, RX_ONSET) == 0))

  0019e	6a 07		 push	 7
  001a0	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  001a4	50		 push	 eax
  001a5	e8 00 00 00 00	 call	 _sub
  001aa	83 c4 08	 add	 esp, 8
  001ad	0f bf c8	 movsx	 ecx, ax
  001b0	85 c9		 test	 ecx, ecx
  001b2	74 16		 je	 SHORT $LN125@Decoder_am
  001b4	6a 02		 push	 2
  001b6	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 _sub
  001c0	83 c4 08	 add	 esp, 8
  001c3	0f bf c8	 movsx	 ecx, ax
  001c6	85 c9		 test	 ecx, ecx
  001c8	75 2d		 jne	 SHORT $LN126@Decoder_am
$LN125@Decoder_am:

; 344  :        {
; 345  : 	  build_CN_param(&st->nodataSeed,
; 346  : 			 prmno[mode],
; 347  : 			 bitno[mode],
; 348  : 			 parm);

  001ca	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  001cd	50		 push	 eax
  001ce	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  001d1	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _bitno[ecx*4]
  001d8	52		 push	 edx
  001d9	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  001dc	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _prmno[eax*2]
  001e4	51		 push	 ecx
  001e5	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001e8	81 c2 e8 01 00
	00		 add	 edx, 488		; 000001e8H
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 _build_CN_param
  001f4	83 c4 10	 add	 esp, 16			; 00000010H
$LN126@Decoder_am:

; 349  :        }       

  001f7	eb 27		 jmp	 SHORT $LN124@Decoder_am
$LN128@Decoder_am:

; 350  :     }
; 351  :     else if (sub(frame_type, RX_SPEECH_DEGRADED) == 0)

  001f9	6a 01		 push	 1
  001fb	0f b7 45 14	 movzx	 eax, WORD PTR _frame_type$[ebp]
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 _sub
  00205	83 c4 08	 add	 esp, 8
  00208	0f bf c8	 movsx	 ecx, ax
  0020b	85 c9		 test	 ecx, ecx
  0020d	75 11		 jne	 SHORT $LN124@Decoder_am

; 352  :     {
; 353  :        pdfi = 1;                                         move16 ();

  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	66 89 85 44 fd
	ff ff		 mov	 WORD PTR _pdfi$[ebp], ax
  0021b	e8 00 00 00 00	 call	 _move16
$LN124@Decoder_am:

; 354  :     }
; 355  :    
; 356  :     
; 357  :     test();

  00220	e8 00 00 00 00	 call	 _test

; 358  :     if (bfi != 0)

  00225	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  0022c	85 c0		 test	 eax, eax
  0022e	74 21		 je	 SHORT $LN122@Decoder_am

; 359  :     {
; 360  :         st->state = add (st->state, 1);

  00230	6a 01		 push	 1
  00232	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00235	0f b7 88 b8 01
	00 00		 movzx	 ecx, WORD PTR [eax+440]
  0023c	51		 push	 ecx
  0023d	e8 00 00 00 00	 call	 _add
  00242	83 c4 08	 add	 esp, 8
  00245	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00248	66 89 82 b8 01
	00 00		 mov	 WORD PTR [edx+440], ax
  0024f	eb 43		 jmp	 SHORT $LN121@Decoder_am
$LN122@Decoder_am:

; 361  :     }
; 362  :     else if (sub (st->state, 6) == 0)

  00251	6a 06		 push	 6
  00253	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00256	0f b7 88 b8 01
	00 00		 movzx	 ecx, WORD PTR [eax+440]
  0025d	51		 push	 ecx
  0025e	e8 00 00 00 00	 call	 _sub
  00263	83 c4 08	 add	 esp, 8
  00266	0f bf d0	 movsx	 edx, ax
  00269	85 d2		 test	 edx, edx
  0026b	75 16		 jne	 SHORT $LN120@Decoder_am

; 363  : 
; 364  :     {
; 365  :         st->state = 5;                                   move16 ();

  0026d	b8 05 00 00 00	 mov	 eax, 5
  00272	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00275	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax
  0027c	e8 00 00 00 00	 call	 _move16

; 366  :     }
; 367  :     else

  00281	eb 11		 jmp	 SHORT $LN121@Decoder_am
$LN120@Decoder_am:

; 368  :     {
; 369  :         st->state = 0;                                   move16 ();

  00283	33 c0		 xor	 eax, eax
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00288	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax
  0028f	e8 00 00 00 00	 call	 _move16
$LN121@Decoder_am:

; 370  :     }
; 371  :     
; 372  :     test (); 

  00294	e8 00 00 00 00	 call	 _test

; 373  :     if (sub (st->state, 6) > 0)

  00299	6a 06		 push	 6
  0029b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0029e	0f b7 88 b8 01
	00 00		 movzx	 ecx, WORD PTR [eax+440]
  002a5	51		 push	 ecx
  002a6	e8 00 00 00 00	 call	 _sub
  002ab	83 c4 08	 add	 esp, 8
  002ae	0f bf d0	 movsx	 edx, ax
  002b1	85 d2		 test	 edx, edx
  002b3	7e 14		 jle	 SHORT $LN118@Decoder_am

; 374  :     {
; 375  :         st->state = 6;                                   move16 ();

  002b5	b8 06 00 00 00	 mov	 eax, 6
  002ba	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002bd	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax
  002c4	e8 00 00 00 00	 call	 _move16
$LN118@Decoder_am:

; 376  :     }
; 377  : 
; 378  :     /* If this frame is the first speech frame after CNI period,     */
; 379  :     /* set the BFH state machine to an appropriate state depending   */
; 380  :     /* on whether there was DTX muting before start of speech or not */
; 381  :     /* If there was DTX muting, the first speech frame is muted.     */
; 382  :     /* If there was no DTX muting, the first speech frame is not     */
; 383  :     /* muted. The BFH state machine starts from state 5, however, to */
; 384  :     /* keep the audible noise resulting from a SID frame which is    */
; 385  :     /* erroneously interpreted as a good speech frame as small as    */
; 386  :     /* possible (the decoder output in this case is quickly muted)   */
; 387  : 
; 388  :     test(); 

  002c9	e8 00 00 00 00	 call	 _test

; 389  :     if (sub(st->dtxDecoderState->dtxGlobalState, DTX) == 0)

  002ce	6a 01		 push	 1
  002d0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002d3	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  002d9	0f b7 91 98 01
	00 00		 movzx	 edx, WORD PTR [ecx+408]
  002e0	52		 push	 edx
  002e1	e8 00 00 00 00	 call	 _sub
  002e6	83 c4 08	 add	 esp, 8
  002e9	98		 cwde
  002ea	85 c0		 test	 eax, eax
  002ec	75 27		 jne	 SHORT $LN117@Decoder_am

; 390  :     {
; 391  :        st->state = 5;                                    move16 ();

  002ee	b8 05 00 00 00	 mov	 eax, 5
  002f3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002f6	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax
  002fd	e8 00 00 00 00	 call	 _move16

; 392  :        st->prev_bf = 0;                                  move16 ();

  00302	33 c0		 xor	 eax, eax
  00304	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00307	66 89 81 b4 01
	00 00		 mov	 WORD PTR [ecx+436], ax
  0030e	e8 00 00 00 00	 call	 _move16
  00313	eb 4d		 jmp	 SHORT $LN116@Decoder_am
$LN117@Decoder_am:

; 393  :     }
; 394  :     else if (test (), sub(st->dtxDecoderState->dtxGlobalState, DTX_MUTE) == 0)

  00315	e8 00 00 00 00	 call	 _test
  0031a	6a 02		 push	 2
  0031c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0031f	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  00325	0f b7 91 98 01
	00 00		 movzx	 edx, WORD PTR [ecx+408]
  0032c	52		 push	 edx
  0032d	e8 00 00 00 00	 call	 _sub
  00332	83 c4 08	 add	 esp, 8
  00335	98		 cwde
  00336	85 c0		 test	 eax, eax
  00338	75 28		 jne	 SHORT $LN116@Decoder_am

; 395  :     {
; 396  :        st->state = 5;                                    move16 ();

  0033a	b8 05 00 00 00	 mov	 eax, 5
  0033f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00342	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax
  00349	e8 00 00 00 00	 call	 _move16

; 397  :        st->prev_bf = 1;                                  move16 ();

  0034e	b8 01 00 00 00	 mov	 eax, 1
  00353	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00356	66 89 81 b4 01
	00 00		 mov	 WORD PTR [ecx+436], ax
  0035d	e8 00 00 00 00	 call	 _move16
$LN116@Decoder_am:

; 398  :     }
; 399  :     
; 400  :     /* save old LSFs for CB gain smoothing */
; 401  :     Copy (st->lsfState->past_lsf_q, prev_lsf, M);

  00362	6a 0a		 push	 10			; 0000000aH
  00364	8d 45 a0	 lea	 eax, DWORD PTR _prev_lsf$[ebp]
  00367	50		 push	 eax
  00368	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0036b	8b 91 f4 01 00
	00		 mov	 edx, DWORD PTR [ecx+500]
  00371	83 c2 14	 add	 edx, 20			; 00000014H
  00374	52		 push	 edx
  00375	e8 00 00 00 00	 call	 _Copy
  0037a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 402  :     
; 403  :     /* decode LSF parameters and generate interpolated lpc coefficients
; 404  :        for the 4 subframes */
; 405  :     test ();

  0037d	e8 00 00 00 00	 call	 _test

; 406  :     if (sub (mode, MR122) != 0)

  00382	6a 07		 push	 7
  00384	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 _sub
  0038e	83 c4 08	 add	 esp, 8
  00391	0f bf c8	 movsx	 ecx, ax
  00394	85 c9		 test	 ecx, ecx
  00396	74 55		 je	 SHORT $LN114@Decoder_am

; 407  :     {
; 408  :        D_plsf_3(st->lsfState, mode, bfi, parm, lsp_new);

  00398	8d 45 d8	 lea	 eax, DWORD PTR _lsp_new$[ebp]
  0039b	50		 push	 eax
  0039c	8b 4d 10	 mov	 ecx, DWORD PTR _parm$[ebp]
  0039f	51		 push	 ecx
  003a0	0f b7 95 50 fd
	ff ff		 movzx	 edx, WORD PTR _bfi$[ebp]
  003a7	52		 push	 edx
  003a8	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  003ab	50		 push	 eax
  003ac	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  003af	8b 91 f4 01 00
	00		 mov	 edx, DWORD PTR [ecx+500]
  003b5	52		 push	 edx
  003b6	e8 00 00 00 00	 call	 _D_plsf_3
  003bb	83 c4 14	 add	 esp, 20			; 00000014H

; 409  : 
; 410  :        fwc ();                     /* function worst case */

  003be	e8 00 00 00 00	 call	 _fwc

; 411  : 
; 412  :        /* Advance synthesis parameters pointer */
; 413  :        parm += 3;                  move16 ();

  003c3	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  003c6	83 c0 06	 add	 eax, 6
  003c9	89 45 10	 mov	 DWORD PTR _parm$[ebp], eax
  003cc	e8 00 00 00 00	 call	 _move16

; 414  :        
; 415  :        Int_lpc_1to3(st->lsp_old, lsp_new, A_t);

  003d1	8b 45 1c	 mov	 eax, DWORD PTR _A_t$[ebp]
  003d4	50		 push	 eax
  003d5	8d 4d d8	 lea	 ecx, DWORD PTR _lsp_new$[ebp]
  003d8	51		 push	 ecx
  003d9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  003dc	81 c2 88 01 00
	00		 add	 edx, 392		; 00000188H
  003e2	52		 push	 edx
  003e3	e8 00 00 00 00	 call	 _Int_lpc_1to3
  003e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  :     }
; 417  :     else

  003eb	eb 56		 jmp	 SHORT $LN113@Decoder_am
$LN114@Decoder_am:

; 418  :     {
; 419  :        D_plsf_5 (st->lsfState, bfi, parm, lsp_mid, lsp_new);

  003ed	8d 45 d8	 lea	 eax, DWORD PTR _lsp_new$[ebp]
  003f0	50		 push	 eax
  003f1	8d 4d bc	 lea	 ecx, DWORD PTR _lsp_mid$[ebp]
  003f4	51		 push	 ecx
  003f5	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  003f8	52		 push	 edx
  003f9	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  00400	50		 push	 eax
  00401	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00404	8b 91 f4 01 00
	00		 mov	 edx, DWORD PTR [ecx+500]
  0040a	52		 push	 edx
  0040b	e8 00 00 00 00	 call	 _D_plsf_5
  00410	83 c4 14	 add	 esp, 20			; 00000014H

; 420  : 
; 421  :        fwc ();                     /* function worst case */

  00413	e8 00 00 00 00	 call	 _fwc

; 422  : 
; 423  :        /* Advance synthesis parameters pointer */
; 424  :        parm += 5;                  move16 ();

  00418	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  0041b	83 c0 0a	 add	 eax, 10			; 0000000aH
  0041e	89 45 10	 mov	 DWORD PTR _parm$[ebp], eax
  00421	e8 00 00 00 00	 call	 _move16

; 425  :        
; 426  :        Int_lpc_1and3 (st->lsp_old, lsp_mid, lsp_new, A_t);

  00426	8b 45 1c	 mov	 eax, DWORD PTR _A_t$[ebp]
  00429	50		 push	 eax
  0042a	8d 4d d8	 lea	 ecx, DWORD PTR _lsp_new$[ebp]
  0042d	51		 push	 ecx
  0042e	8d 55 bc	 lea	 edx, DWORD PTR _lsp_mid$[ebp]
  00431	52		 push	 edx
  00432	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00435	05 88 01 00 00	 add	 eax, 392		; 00000188H
  0043a	50		 push	 eax
  0043b	e8 00 00 00 00	 call	 _Int_lpc_1and3
  00440	83 c4 10	 add	 esp, 16			; 00000010H
$LN113@Decoder_am:

; 427  :     }
; 428  :        
; 429  :     /* update the LSPs for the next frame */
; 430  :     for (i = 0; i < M; i++)

  00443	33 c0		 xor	 eax, eax
  00445	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0044c	eb 12		 jmp	 SHORT $LN112@Decoder_am
$LN111@Decoder_am:
  0044e	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00455	66 83 c0 01	 add	 ax, 1
  00459	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN112@Decoder_am:
  00460	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00467	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0046a	7d 25		 jge	 SHORT $LN110@Decoder_am

; 431  :     {
; 432  :        st->lsp_old[i] = lsp_new[i];        move16 (); 

  0046c	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00473	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  0047a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0047d	66 8b 44 45 d8	 mov	 ax, WORD PTR _lsp_new$[ebp+eax*2]
  00482	66 89 84 4a 88
	01 00 00	 mov	 WORD PTR [edx+ecx*2+392], ax
  0048a	e8 00 00 00 00	 call	 _move16

; 433  :     }

  0048f	eb bd		 jmp	 SHORT $LN111@Decoder_am
$LN110@Decoder_am:

; 434  : 
; 435  :     fwc ();                     /* function worst case */

  00491	e8 00 00 00 00	 call	 _fwc

; 436  : 
; 437  :    /*------------------------------------------------------------------------*
; 438  :     *          Loop for every subframe in the analysis frame                 *
; 439  :     *------------------------------------------------------------------------*
; 440  :     * The subframe size is L_SUBFR and the loop is repeated L_FRAME/L_SUBFR  *
; 441  :     *  times                                                                 *
; 442  :     *     - decode the pitch delay                                           *
; 443  :     *     - decode algebraic code                                            *
; 444  :     *     - decode pitch and codebook gains                                  *
; 445  :     *     - find the excitation and compute synthesis speech                 *
; 446  :     *------------------------------------------------------------------------*/
; 447  :     
; 448  :     /* pointer to interpolated LPC parameters */
; 449  :     Az = A_t;                                                       move16 (); 

  00496	8b 45 1c	 mov	 eax, DWORD PTR _A_t$[ebp]
  00499	89 45 f4	 mov	 DWORD PTR _Az$[ebp], eax
  0049c	e8 00 00 00 00	 call	 _move16

; 450  :     
; 451  :     evenSubfr = 0;                                                  move16();

  004a1	33 c0		 xor	 eax, eax
  004a3	66 89 85 5c fd
	ff ff		 mov	 WORD PTR _evenSubfr$[ebp], ax
  004aa	e8 00 00 00 00	 call	 _move16

; 452  :     subfrNr = -1;                                                   move16();

  004af	83 c8 ff	 or	 eax, -1
  004b2	66 89 85 68 fd
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax
  004b9	e8 00 00 00 00	 call	 _move16

; 453  :     for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)

  004be	33 c0		 xor	 eax, eax
  004c0	66 89 85 64 fe
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], ax
  004c7	eb 11		 jmp	 SHORT $LN109@Decoder_am
$LN108@Decoder_am:
  004c9	0f bf 85 64 fe
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  004d0	83 c0 28	 add	 eax, 40			; 00000028H
  004d3	66 89 85 64 fe
	ff ff		 mov	 WORD PTR _i_subfr$[ebp], ax
$LN109@Decoder_am:
  004da	0f bf 85 64 fe
	ff ff		 movsx	 eax, WORD PTR _i_subfr$[ebp]
  004e1	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  004e6	0f 8d 0e 1c 00
	00		 jge	 $LN107@Decoder_am

; 454  :     {
; 455  :        subfrNr = add(subfrNr, 1);

  004ec	6a 01		 push	 1
  004ee	0f b7 85 68 fd
	ff ff		 movzx	 eax, WORD PTR _subfrNr$[ebp]
  004f5	50		 push	 eax
  004f6	e8 00 00 00 00	 call	 _add
  004fb	83 c4 08	 add	 esp, 8
  004fe	66 89 85 68 fd
	ff ff		 mov	 WORD PTR _subfrNr$[ebp], ax

; 456  :        evenSubfr = sub(1, evenSubfr);

  00505	0f b7 85 5c fd
	ff ff		 movzx	 eax, WORD PTR _evenSubfr$[ebp]
  0050c	50		 push	 eax
  0050d	6a 01		 push	 1
  0050f	e8 00 00 00 00	 call	 _sub
  00514	83 c4 08	 add	 esp, 8
  00517	66 89 85 5c fd
	ff ff		 mov	 WORD PTR _evenSubfr$[ebp], ax

; 457  : 
; 458  :        /* flag for first and 3th subframe */
; 459  :        pit_flag = i_subfr;             move16 ();

  0051e	66 8b 85 64 fe
	ff ff		 mov	 ax, WORD PTR _i_subfr$[ebp]
  00525	66 89 85 f8 fd
	ff ff		 mov	 WORD PTR _pit_flag$[ebp], ax
  0052c	e8 00 00 00 00	 call	 _move16

; 460  : 
; 461  :        test();

  00531	e8 00 00 00 00	 call	 _test

; 462  :        if (sub (i_subfr, L_FRAME_BY2) == 0)

  00536	6a 50		 push	 80			; 00000050H
  00538	0f b7 85 64 fe
	ff ff		 movzx	 eax, WORD PTR _i_subfr$[ebp]
  0053f	50		 push	 eax
  00540	e8 00 00 00 00	 call	 _sub
  00545	83 c4 08	 add	 esp, 8
  00548	0f bf c8	 movsx	 ecx, ax
  0054b	85 c9		 test	 ecx, ecx
  0054d	75 44		 jne	 SHORT $LN106@Decoder_am

; 463  :        {
; 464  :           test(); test();

  0054f	e8 00 00 00 00	 call	 _test
  00554	e8 00 00 00 00	 call	 _test

; 465  :           if (sub(mode, MR475) != 0 && sub(mode, MR515) != 0) 

  00559	6a 00		 push	 0
  0055b	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0055f	50		 push	 eax
  00560	e8 00 00 00 00	 call	 _sub
  00565	83 c4 08	 add	 esp, 8
  00568	0f bf c8	 movsx	 ecx, ax
  0056b	85 c9		 test	 ecx, ecx
  0056d	74 24		 je	 SHORT $LN106@Decoder_am
  0056f	6a 01		 push	 1
  00571	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00575	50		 push	 eax
  00576	e8 00 00 00 00	 call	 _sub
  0057b	83 c4 08	 add	 esp, 8
  0057e	0f bf c8	 movsx	 ecx, ax
  00581	85 c9		 test	 ecx, ecx
  00583	74 0e		 je	 SHORT $LN106@Decoder_am

; 466  :           {
; 467  :              pit_flag = 0;             move16 ();

  00585	33 c0		 xor	 eax, eax
  00587	66 89 85 f8 fd
	ff ff		 mov	 WORD PTR _pit_flag$[ebp], ax
  0058e	e8 00 00 00 00	 call	 _move16
$LN106@Decoder_am:

; 468  :           }
; 469  :        }
; 470  :        
; 471  :        /* pitch index */
; 472  :        index = *parm++;                move16 ();

  00593	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00596	66 8b 08	 mov	 cx, WORD PTR [eax]
  00599	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  005a0	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  005a3	83 c2 02	 add	 edx, 2
  005a6	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  005a9	e8 00 00 00 00	 call	 _move16

; 473  : 
; 474  :        /*-------------------------------------------------------*
; 475  :         * - decode pitch lag and find adaptive codebook vector. *
; 476  :         *-------------------------------------------------------*/
; 477  :        
; 478  :        test ();

  005ae	e8 00 00 00 00	 call	 _test

; 479  :        if (sub(mode, MR122) != 0)

  005b3	6a 07		 push	 7
  005b5	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  005b9	50		 push	 eax
  005ba	e8 00 00 00 00	 call	 _sub
  005bf	83 c4 08	 add	 esp, 8
  005c2	0f bf c8	 movsx	 ecx, ax
  005c5	85 c9		 test	 ecx, ecx
  005c7	0f 84 50 03 00
	00		 je	 $LN104@Decoder_am

; 480  :        {
; 481  :           /* flag4 indicates encoding with 4 bit resolution;     */
; 482  :           /* this is needed for mode MR475, MR515, MR59 and MR67 */
; 483  :           
; 484  :           flag4 = 0;                                 move16 ();

  005cd	33 c0		 xor	 eax, eax
  005cf	66 89 85 8c fd
	ff ff		 mov	 WORD PTR _flag4$[ebp], ax
  005d6	e8 00 00 00 00	 call	 _move16

; 485  :           test (); test (); test (); test ();        

  005db	e8 00 00 00 00	 call	 _test
  005e0	e8 00 00 00 00	 call	 _test
  005e5	e8 00 00 00 00	 call	 _test
  005ea	e8 00 00 00 00	 call	 _test

; 486  :           if ((sub (mode, MR475) == 0) ||
; 487  :               (sub (mode, MR515) == 0) ||
; 488  :               (sub (mode, MR59) == 0) ||
; 489  :               (sub (mode, MR67) == 0) ) {

  005ef	6a 00		 push	 0
  005f1	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  005f5	50		 push	 eax
  005f6	e8 00 00 00 00	 call	 _sub
  005fb	83 c4 08	 add	 esp, 8
  005fe	0f bf c8	 movsx	 ecx, ax
  00601	85 c9		 test	 ecx, ecx
  00603	74 42		 je	 SHORT $LN102@Decoder_am
  00605	6a 01		 push	 1
  00607	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0060b	50		 push	 eax
  0060c	e8 00 00 00 00	 call	 _sub
  00611	83 c4 08	 add	 esp, 8
  00614	0f bf c8	 movsx	 ecx, ax
  00617	85 c9		 test	 ecx, ecx
  00619	74 2c		 je	 SHORT $LN102@Decoder_am
  0061b	6a 02		 push	 2
  0061d	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 _sub
  00627	83 c4 08	 add	 esp, 8
  0062a	0f bf c8	 movsx	 ecx, ax
  0062d	85 c9		 test	 ecx, ecx
  0062f	74 16		 je	 SHORT $LN102@Decoder_am
  00631	6a 03		 push	 3
  00633	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00637	50		 push	 eax
  00638	e8 00 00 00 00	 call	 _sub
  0063d	83 c4 08	 add	 esp, 8
  00640	0f bf c8	 movsx	 ecx, ax
  00643	85 c9		 test	 ecx, ecx
  00645	75 11		 jne	 SHORT $LN103@Decoder_am
$LN102@Decoder_am:

; 490  :              flag4 = 1;                              move16 ();

  00647	b8 01 00 00 00	 mov	 eax, 1
  0064c	66 89 85 8c fd
	ff ff		 mov	 WORD PTR _flag4$[ebp], ax
  00653	e8 00 00 00 00	 call	 _move16
$LN103@Decoder_am:

; 491  :           }
; 492  :           
; 493  :           /*-------------------------------------------------------*
; 494  :            * - get ranges for the t0_min and t0_max                *
; 495  :            * - only needed in delta decoding                       *
; 496  :            *-------------------------------------------------------*/
; 497  : 
; 498  :           delta_frc_low = 5;                      move16();

  00658	b8 05 00 00 00	 mov	 eax, 5
  0065d	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _delta_frc_low$[ebp], ax
  00664	e8 00 00 00 00	 call	 _move16

; 499  :           delta_frc_range = 9;                    move16();

  00669	b8 09 00 00 00	 mov	 eax, 9
  0066e	66 89 85 bc fd
	ff ff		 mov	 WORD PTR _delta_frc_range$[ebp], ax
  00675	e8 00 00 00 00	 call	 _move16

; 500  : 
; 501  :           test ();

  0067a	e8 00 00 00 00	 call	 _test

; 502  :           if ( sub(mode, MR795) == 0 )

  0067f	6a 05		 push	 5
  00681	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00685	50		 push	 eax
  00686	e8 00 00 00 00	 call	 _sub
  0068b	83 c4 08	 add	 esp, 8
  0068e	0f bf c8	 movsx	 ecx, ax
  00691	85 c9		 test	 ecx, ecx
  00693	75 22		 jne	 SHORT $LN101@Decoder_am

; 503  :           {
; 504  :              delta_frc_low = 10;                  move16();

  00695	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0069a	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _delta_frc_low$[ebp], ax
  006a1	e8 00 00 00 00	 call	 _move16

; 505  :              delta_frc_range = 19;                move16();

  006a6	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  006ab	66 89 85 bc fd
	ff ff		 mov	 WORD PTR _delta_frc_range$[ebp], ax
  006b2	e8 00 00 00 00	 call	 _move16
$LN101@Decoder_am:

; 506  :           }
; 507  :              
; 508  :           t0_min = sub(st->old_T0, delta_frc_low);

  006b7	0f b7 85 c8 fd
	ff ff		 movzx	 eax, WORD PTR _delta_frc_low$[ebp]
  006be	50		 push	 eax
  006bf	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  006c2	0f b7 91 b2 01
	00 00		 movzx	 edx, WORD PTR [ecx+434]
  006c9	52		 push	 edx
  006ca	e8 00 00 00 00	 call	 _sub
  006cf	83 c4 08	 add	 esp, 8
  006d2	66 89 85 e0 fd
	ff ff		 mov	 WORD PTR _t0_min$[ebp], ax

; 509  :           test ();

  006d9	e8 00 00 00 00	 call	 _test

; 510  :           if (sub(t0_min, PIT_MIN) < 0)

  006de	6a 14		 push	 20			; 00000014H
  006e0	0f b7 85 e0 fd
	ff ff		 movzx	 eax, WORD PTR _t0_min$[ebp]
  006e7	50		 push	 eax
  006e8	e8 00 00 00 00	 call	 _sub
  006ed	83 c4 08	 add	 esp, 8
  006f0	0f bf c8	 movsx	 ecx, ax
  006f3	85 c9		 test	 ecx, ecx
  006f5	7d 11		 jge	 SHORT $LN100@Decoder_am

; 511  :           {
; 512  :              t0_min = PIT_MIN;                    move16();

  006f7	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  006fc	66 89 85 e0 fd
	ff ff		 mov	 WORD PTR _t0_min$[ebp], ax
  00703	e8 00 00 00 00	 call	 _move16
$LN100@Decoder_am:

; 513  :           }
; 514  :           t0_max = add(t0_min, delta_frc_range);

  00708	0f b7 85 bc fd
	ff ff		 movzx	 eax, WORD PTR _delta_frc_range$[ebp]
  0070f	50		 push	 eax
  00710	0f b7 8d e0 fd
	ff ff		 movzx	 ecx, WORD PTR _t0_min$[ebp]
  00717	51		 push	 ecx
  00718	e8 00 00 00 00	 call	 _add
  0071d	83 c4 08	 add	 esp, 8
  00720	66 89 85 d4 fd
	ff ff		 mov	 WORD PTR _t0_max$[ebp], ax

; 515  :           test ();

  00727	e8 00 00 00 00	 call	 _test

; 516  :           if (sub(t0_max, PIT_MAX) > 0)

  0072c	68 8f 00 00 00	 push	 143			; 0000008fH
  00731	0f b7 85 d4 fd
	ff ff		 movzx	 eax, WORD PTR _t0_max$[ebp]
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _sub
  0073e	83 c4 08	 add	 esp, 8
  00741	0f bf c8	 movsx	 ecx, ax
  00744	85 c9		 test	 ecx, ecx
  00746	7e 30		 jle	 SHORT $LN99@Decoder_am

; 517  :           {
; 518  :              t0_max = PIT_MAX;                    move16();

  00748	b8 8f 00 00 00	 mov	 eax, 143		; 0000008fH
  0074d	66 89 85 d4 fd
	ff ff		 mov	 WORD PTR _t0_max$[ebp], ax
  00754	e8 00 00 00 00	 call	 _move16

; 519  :              t0_min = sub(t0_max, delta_frc_range);

  00759	0f b7 85 bc fd
	ff ff		 movzx	 eax, WORD PTR _delta_frc_range$[ebp]
  00760	50		 push	 eax
  00761	0f b7 8d d4 fd
	ff ff		 movzx	 ecx, WORD PTR _t0_max$[ebp]
  00768	51		 push	 ecx
  00769	e8 00 00 00 00	 call	 _sub
  0076e	83 c4 08	 add	 esp, 8
  00771	66 89 85 e0 fd
	ff ff		 mov	 WORD PTR _t0_min$[ebp], ax
$LN99@Decoder_am:

; 520  :           }
; 521  :              
; 522  :           Dec_lag3 (index, t0_min, t0_max, pit_flag, st->old_T0,
; 523  :                     &T0, &T0_frac, flag4);

  00778	0f b7 85 8c fd
	ff ff		 movzx	 eax, WORD PTR _flag4$[ebp]
  0077f	50		 push	 eax
  00780	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR _T0_frac$[ebp]
  00786	51		 push	 ecx
  00787	8d 95 58 fe ff
	ff		 lea	 edx, DWORD PTR _T0$[ebp]
  0078d	52		 push	 edx
  0078e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00791	0f b7 88 b2 01
	00 00		 movzx	 ecx, WORD PTR [eax+434]
  00798	51		 push	 ecx
  00799	0f b7 95 f8 fd
	ff ff		 movzx	 edx, WORD PTR _pit_flag$[ebp]
  007a0	52		 push	 edx
  007a1	0f b7 85 d4 fd
	ff ff		 movzx	 eax, WORD PTR _t0_max$[ebp]
  007a8	50		 push	 eax
  007a9	0f b7 8d e0 fd
	ff ff		 movzx	 ecx, WORD PTR _t0_min$[ebp]
  007b0	51		 push	 ecx
  007b1	0f b7 95 40 fe
	ff ff		 movzx	 edx, WORD PTR _index$[ebp]
  007b8	52		 push	 edx
  007b9	e8 00 00 00 00	 call	 _Dec_lag3
  007be	83 c4 20	 add	 esp, 32			; 00000020H

; 524  : 
; 525  :           st->T0_lagBuff = T0;                        move16 ();

  007c1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  007c4	66 8b 8d 58 fe
	ff ff		 mov	 cx, WORD PTR _T0$[ebp]
  007cb	66 89 88 cc 01
	00 00		 mov	 WORD PTR [eax+460], cx
  007d2	e8 00 00 00 00	 call	 _move16

; 526  : 
; 527  :           test ();

  007d7	e8 00 00 00 00	 call	 _test

; 528  :           if (bfi != 0)

  007dc	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  007e3	85 c0		 test	 eax, eax
  007e5	0f 84 02 01 00
	00		 je	 $LN98@Decoder_am

; 529  :           {
; 530  :              test ();

  007eb	e8 00 00 00 00	 call	 _test

; 531  :              if (sub (st->old_T0, PIT_MAX) < 0)     

  007f0	68 8f 00 00 00	 push	 143			; 0000008fH
  007f5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  007f8	0f b7 88 b2 01
	00 00		 movzx	 ecx, WORD PTR [eax+434]
  007ff	51		 push	 ecx
  00800	e8 00 00 00 00	 call	 _sub
  00805	83 c4 08	 add	 esp, 8
  00808	0f bf d0	 movsx	 edx, ax
  0080b	85 d2		 test	 edx, edx
  0080d	7d 1f		 jge	 SHORT $LN97@Decoder_am

; 532  :              {                                      /* Graceful pitch */
; 533  :                 st->old_T0 = add(st->old_T0, 1);    /* degradation    */

  0080f	6a 01		 push	 1
  00811	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00814	0f b7 88 b2 01
	00 00		 movzx	 ecx, WORD PTR [eax+434]
  0081b	51		 push	 ecx
  0081c	e8 00 00 00 00	 call	 _add
  00821	83 c4 08	 add	 esp, 8
  00824	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00827	66 89 82 b2 01
	00 00		 mov	 WORD PTR [edx+434], ax
$LN97@Decoder_am:

; 534  :              }
; 535  :              T0 = st->old_T0;                     move16 (); 

  0082e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00831	66 8b 88 b2 01
	00 00		 mov	 cx, WORD PTR [eax+434]
  00838	66 89 8d 58 fe
	ff ff		 mov	 WORD PTR _T0$[ebp], cx
  0083f	e8 00 00 00 00	 call	 _move16

; 536  :              T0_frac = 0;                         move16 (); 

  00844	33 c0		 xor	 eax, eax
  00846	66 89 85 4c fe
	ff ff		 mov	 WORD PTR _T0_frac$[ebp], ax
  0084d	e8 00 00 00 00	 call	 _move16

; 537  : 
; 538  :              test (); test (); test (); test (); test ();

  00852	e8 00 00 00 00	 call	 _test
  00857	e8 00 00 00 00	 call	 _test
  0085c	e8 00 00 00 00	 call	 _test
  00861	e8 00 00 00 00	 call	 _test
  00866	e8 00 00 00 00	 call	 _test

; 539  :              if ( st->inBackgroundNoise != 0 && 
; 540  :                   sub(st->voicedHangover, 4) > 0 &&
; 541  :                   ((sub(mode, MR475) == 0 ) ||
; 542  :                    (sub(mode, MR515) == 0 ) ||
; 543  :                    (sub(mode, MR59) == 0) )
; 544  :                   )

  0086b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0086e	0f bf 88 ce 01
	00 00		 movsx	 ecx, WORD PTR [eax+462]
  00875	85 c9		 test	 ecx, ecx
  00877	74 74		 je	 SHORT $LN98@Decoder_am
  00879	6a 04		 push	 4
  0087b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0087e	0f b7 88 d0 01
	00 00		 movzx	 ecx, WORD PTR [eax+464]
  00885	51		 push	 ecx
  00886	e8 00 00 00 00	 call	 _sub
  0088b	83 c4 08	 add	 esp, 8
  0088e	0f bf d0	 movsx	 edx, ax
  00891	85 d2		 test	 edx, edx
  00893	7e 58		 jle	 SHORT $LN98@Decoder_am
  00895	6a 00		 push	 0
  00897	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0089b	50		 push	 eax
  0089c	e8 00 00 00 00	 call	 _sub
  008a1	83 c4 08	 add	 esp, 8
  008a4	0f bf c8	 movsx	 ecx, ax
  008a7	85 c9		 test	 ecx, ecx
  008a9	74 2c		 je	 SHORT $LN95@Decoder_am
  008ab	6a 01		 push	 1
  008ad	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  008b1	50		 push	 eax
  008b2	e8 00 00 00 00	 call	 _sub
  008b7	83 c4 08	 add	 esp, 8
  008ba	0f bf c8	 movsx	 ecx, ax
  008bd	85 c9		 test	 ecx, ecx
  008bf	74 16		 je	 SHORT $LN95@Decoder_am
  008c1	6a 02		 push	 2
  008c3	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  008c7	50		 push	 eax
  008c8	e8 00 00 00 00	 call	 _sub
  008cd	83 c4 08	 add	 esp, 8
  008d0	0f bf c8	 movsx	 ecx, ax
  008d3	85 c9		 test	 ecx, ecx
  008d5	75 16		 jne	 SHORT $LN98@Decoder_am
$LN95@Decoder_am:

; 545  :              {
; 546  :                 T0 = st->T0_lagBuff;                  move16 ();

  008d7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  008da	66 8b 88 cc 01
	00 00		 mov	 cx, WORD PTR [eax+460]
  008e1	66 89 8d 58 fe
	ff ff		 mov	 WORD PTR _T0$[ebp], cx
  008e8	e8 00 00 00 00	 call	 _move16
$LN98@Decoder_am:

; 547  :              }
; 548  :           }
; 549  : 
; 550  :           fwc ();             /* function worst case */

  008ed	e8 00 00 00 00	 call	 _fwc

; 551  : 
; 552  :           Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 1);

  008f2	6a 01		 push	 1
  008f4	6a 28		 push	 40			; 00000028H
  008f6	0f b7 85 4c fe
	ff ff		 movzx	 eax, WORD PTR _T0_frac$[ebp]
  008fd	50		 push	 eax
  008fe	0f b7 8d 58 fe
	ff ff		 movzx	 ecx, WORD PTR _T0$[ebp]
  00905	51		 push	 ecx
  00906	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00909	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  0090f	50		 push	 eax
  00910	e8 00 00 00 00	 call	 _Pred_lt_3or6
  00915	83 c4 14	 add	 esp, 20			; 00000014H

; 553  :        }
; 554  :        else

  00918	e9 d2 00 00 00	 jmp	 $LN94@Decoder_am
$LN104@Decoder_am:

; 555  :        {
; 556  :           Dec_lag6 (index, PIT_MIN_MR122,
; 557  :                     PIT_MAX, pit_flag, &T0, &T0_frac);

  0091d	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _T0_frac$[ebp]
  00923	50		 push	 eax
  00924	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _T0$[ebp]
  0092a	51		 push	 ecx
  0092b	0f b7 95 f8 fd
	ff ff		 movzx	 edx, WORD PTR _pit_flag$[ebp]
  00932	52		 push	 edx
  00933	68 8f 00 00 00	 push	 143			; 0000008fH
  00938	6a 12		 push	 18			; 00000012H
  0093a	0f b7 85 40 fe
	ff ff		 movzx	 eax, WORD PTR _index$[ebp]
  00941	50		 push	 eax
  00942	e8 00 00 00 00	 call	 _Dec_lag6
  00947	83 c4 18	 add	 esp, 24			; 00000018H

; 558  : 
; 559  :           test (); test (); test ();

  0094a	e8 00 00 00 00	 call	 _test
  0094f	e8 00 00 00 00	 call	 _test
  00954	e8 00 00 00 00	 call	 _test

; 560  :           if ( bfi == 0 && (pit_flag == 0 || sub (index, 61) < 0))

  00959	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  00960	85 c0		 test	 eax, eax
  00962	75 26		 jne	 SHORT $LN93@Decoder_am
  00964	0f bf 85 f8 fd
	ff ff		 movsx	 eax, WORD PTR _pit_flag$[ebp]
  0096b	85 c0		 test	 eax, eax
  0096d	74 19		 je	 SHORT $LN92@Decoder_am
  0096f	6a 3d		 push	 61			; 0000003dH
  00971	0f b7 85 40 fe
	ff ff		 movzx	 eax, WORD PTR _index$[ebp]
  00978	50		 push	 eax
  00979	e8 00 00 00 00	 call	 _sub
  0097e	83 c4 08	 add	 esp, 8
  00981	0f bf c8	 movsx	 ecx, ax
  00984	85 c9		 test	 ecx, ecx
  00986	7d 02		 jge	 SHORT $LN93@Decoder_am
$LN92@Decoder_am:

; 561  :           {
; 562  :           }                
; 563  :           else

  00988	eb 3a		 jmp	 SHORT $LN91@Decoder_am
$LN93@Decoder_am:

; 564  :           {
; 565  :              st->T0_lagBuff = T0;                 move16 ();

  0098a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0098d	66 8b 8d 58 fe
	ff ff		 mov	 cx, WORD PTR _T0$[ebp]
  00994	66 89 88 cc 01
	00 00		 mov	 WORD PTR [eax+460], cx
  0099b	e8 00 00 00 00	 call	 _move16

; 566  :              T0 = st->old_T0;                     move16 (); 

  009a0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  009a3	66 8b 88 b2 01
	00 00		 mov	 cx, WORD PTR [eax+434]
  009aa	66 89 8d 58 fe
	ff ff		 mov	 WORD PTR _T0$[ebp], cx
  009b1	e8 00 00 00 00	 call	 _move16

; 567  :              T0_frac = 0;                         move16 (); 

  009b6	33 c0		 xor	 eax, eax
  009b8	66 89 85 4c fe
	ff ff		 mov	 WORD PTR _T0_frac$[ebp], ax
  009bf	e8 00 00 00 00	 call	 _move16
$LN91@Decoder_am:

; 568  :           }
; 569  : 
; 570  :           fwc ();             /* function worst case */

  009c4	e8 00 00 00 00	 call	 _fwc

; 571  : 
; 572  :           Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 0);

  009c9	6a 00		 push	 0
  009cb	6a 28		 push	 40			; 00000028H
  009cd	0f b7 85 4c fe
	ff ff		 movzx	 eax, WORD PTR _T0_frac$[ebp]
  009d4	50		 push	 eax
  009d5	0f b7 8d 58 fe
	ff ff		 movzx	 ecx, WORD PTR _T0$[ebp]
  009dc	51		 push	 ecx
  009dd	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  009e0	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  009e6	50		 push	 eax
  009e7	e8 00 00 00 00	 call	 _Pred_lt_3or6
  009ec	83 c4 14	 add	 esp, 20			; 00000014H
$LN94@Decoder_am:

; 573  :        }
; 574  :        
; 575  :        fwc ();             /* function worst case */

  009ef	e8 00 00 00 00	 call	 _fwc

; 576  :        
; 577  :        /*-------------------------------------------------------*
; 578  :         * - (MR122 only: Decode pitch gain.)                    *
; 579  :         * - Decode innovative codebook.                         *
; 580  :         * - set pitch sharpening factor                         *
; 581  :         *-------------------------------------------------------*/
; 582  : 
; 583  :         test (); test (); 

  009f4	e8 00 00 00 00	 call	 _test
  009f9	e8 00 00 00 00	 call	 _test

; 584  :         if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)

  009fe	6a 00		 push	 0
  00a00	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00a04	50		 push	 eax
  00a05	e8 00 00 00 00	 call	 _sub
  00a0a	83 c4 08	 add	 esp, 8
  00a0d	0f bf c8	 movsx	 ecx, ax
  00a10	85 c9		 test	 ecx, ecx
  00a12	74 1a		 je	 SHORT $LN89@Decoder_am
  00a14	6a 01		 push	 1
  00a16	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00a1a	50		 push	 eax
  00a1b	e8 00 00 00 00	 call	 _sub
  00a20	83 c4 08	 add	 esp, 8
  00a23	0f bf c8	 movsx	 ecx, ax
  00a26	85 c9		 test	 ecx, ecx
  00a28	0f 85 88 00 00
	00		 jne	 $LN90@Decoder_am
$LN89@Decoder_am:

; 585  :         {   /* MR475, MR515 */
; 586  :            index = *parm++;        /* index of position */ move16 ();

  00a2e	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00a31	66 8b 08	 mov	 cx, WORD PTR [eax]
  00a34	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  00a3b	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00a3e	83 c2 02	 add	 edx, 2
  00a41	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00a44	e8 00 00 00 00	 call	 _move16

; 587  :            i = *parm++;            /* signs             */ move16 ();

  00a49	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00a4c	66 8b 08	 mov	 cx, WORD PTR [eax]
  00a4f	66 89 8d 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], cx
  00a56	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00a59	83 c2 02	 add	 edx, 2
  00a5c	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00a5f	e8 00 00 00 00	 call	 _move16

; 588  :            
; 589  :            fwc ();                 /* function worst case */

  00a64	e8 00 00 00 00	 call	 _fwc

; 590  : 
; 591  :            decode_2i40_9bits (subfrNr, i, index, code);

  00a69	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00a6f	50		 push	 eax
  00a70	0f b7 8d 40 fe
	ff ff		 movzx	 ecx, WORD PTR _index$[ebp]
  00a77	51		 push	 ecx
  00a78	0f b7 95 70 fe
	ff ff		 movzx	 edx, WORD PTR _i$[ebp]
  00a7f	52		 push	 edx
  00a80	0f b7 85 68 fd
	ff ff		 movzx	 eax, WORD PTR _subfrNr$[ebp]
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 _decode_2i40_9bits
  00a8d	83 c4 10	 add	 esp, 16			; 00000010H

; 592  :            
; 593  :            fwc ();                 /* function worst case */

  00a90	e8 00 00 00 00	 call	 _fwc

; 594  : 
; 595  :            pit_sharp = shl (st->sharp, 1);

  00a95	6a 01		 push	 1
  00a97	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00a9a	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  00aa1	51		 push	 ecx
  00aa2	e8 00 00 00 00	 call	 _shl
  00aa7	83 c4 08	 add	 esp, 8
  00aaa	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  00ab1	e9 4d 03 00 00	 jmp	 $LN88@Decoder_am
$LN90@Decoder_am:

; 596  :         }
; 597  :         else if (sub (mode, MR59) == 0)

  00ab6	6a 02		 push	 2
  00ab8	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00abc	50		 push	 eax
  00abd	e8 00 00 00 00	 call	 _sub
  00ac2	83 c4 08	 add	 esp, 8
  00ac5	0f bf c8	 movsx	 ecx, ax
  00ac8	85 c9		 test	 ecx, ecx
  00aca	0f 85 85 00 00
	00		 jne	 $LN87@Decoder_am

; 598  :         {   /* MR59 */
; 599  :            test (); 

  00ad0	e8 00 00 00 00	 call	 _test

; 600  :            index = *parm++;        /* index of position */ move16 ();

  00ad5	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00ad8	66 8b 08	 mov	 cx, WORD PTR [eax]
  00adb	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  00ae2	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00ae5	83 c2 02	 add	 edx, 2
  00ae8	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00aeb	e8 00 00 00 00	 call	 _move16

; 601  :            i = *parm++;            /* signs             */ move16 ();

  00af0	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00af3	66 8b 08	 mov	 cx, WORD PTR [eax]
  00af6	66 89 8d 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], cx
  00afd	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00b00	83 c2 02	 add	 edx, 2
  00b03	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00b06	e8 00 00 00 00	 call	 _move16

; 602  :            
; 603  :            fwc ();                 /* function worst case */

  00b0b	e8 00 00 00 00	 call	 _fwc

; 604  : 
; 605  :            decode_2i40_11bits (i, index, code);

  00b10	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00b16	50		 push	 eax
  00b17	0f b7 8d 40 fe
	ff ff		 movzx	 ecx, WORD PTR _index$[ebp]
  00b1e	51		 push	 ecx
  00b1f	0f b7 95 70 fe
	ff ff		 movzx	 edx, WORD PTR _i$[ebp]
  00b26	52		 push	 edx
  00b27	e8 00 00 00 00	 call	 _decode_2i40_11bits
  00b2c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 606  :            
; 607  :            fwc ();                 /* function worst case */

  00b2f	e8 00 00 00 00	 call	 _fwc

; 608  : 
; 609  :            pit_sharp = shl (st->sharp, 1);

  00b34	6a 01		 push	 1
  00b36	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00b39	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  00b40	51		 push	 ecx
  00b41	e8 00 00 00 00	 call	 _shl
  00b46	83 c4 08	 add	 esp, 8
  00b49	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  00b50	e9 ae 02 00 00	 jmp	 $LN88@Decoder_am
$LN87@Decoder_am:

; 610  :         }
; 611  :         else if (sub (mode, MR67) == 0)

  00b55	6a 03		 push	 3
  00b57	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00b5b	50		 push	 eax
  00b5c	e8 00 00 00 00	 call	 _sub
  00b61	83 c4 08	 add	 esp, 8
  00b64	0f bf c8	 movsx	 ecx, ax
  00b67	85 c9		 test	 ecx, ecx
  00b69	0f 85 8a 00 00
	00		 jne	 $LN85@Decoder_am

; 612  :         {   /* MR67 */
; 613  :            test (); test ();

  00b6f	e8 00 00 00 00	 call	 _test
  00b74	e8 00 00 00 00	 call	 _test

; 614  :            index = *parm++;        /* index of position */ move16 ();

  00b79	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00b7c	66 8b 08	 mov	 cx, WORD PTR [eax]
  00b7f	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  00b86	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00b89	83 c2 02	 add	 edx, 2
  00b8c	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00b8f	e8 00 00 00 00	 call	 _move16

; 615  :            i = *parm++;            /* signs             */ move16 ();

  00b94	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00b97	66 8b 08	 mov	 cx, WORD PTR [eax]
  00b9a	66 89 8d 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], cx
  00ba1	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00ba4	83 c2 02	 add	 edx, 2
  00ba7	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00baa	e8 00 00 00 00	 call	 _move16

; 616  :            
; 617  :            fwc ();                 /* function worst case */

  00baf	e8 00 00 00 00	 call	 _fwc

; 618  : 
; 619  :            decode_3i40_14bits (i, index, code);

  00bb4	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00bba	50		 push	 eax
  00bbb	0f b7 8d 40 fe
	ff ff		 movzx	 ecx, WORD PTR _index$[ebp]
  00bc2	51		 push	 ecx
  00bc3	0f b7 95 70 fe
	ff ff		 movzx	 edx, WORD PTR _i$[ebp]
  00bca	52		 push	 edx
  00bcb	e8 00 00 00 00	 call	 _decode_3i40_14bits
  00bd0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 620  :             
; 621  :            fwc ();                 /* function worst case */

  00bd3	e8 00 00 00 00	 call	 _fwc

; 622  : 
; 623  :            pit_sharp = shl (st->sharp, 1);

  00bd8	6a 01		 push	 1
  00bda	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00bdd	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  00be4	51		 push	 ecx
  00be5	e8 00 00 00 00	 call	 _shl
  00bea	83 c4 08	 add	 esp, 8
  00bed	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  00bf4	e9 0a 02 00 00	 jmp	 $LN88@Decoder_am
$LN85@Decoder_am:

; 624  :         }
; 625  :         else if (sub (mode, MR795) <= 0)

  00bf9	6a 05		 push	 5
  00bfb	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00bff	50		 push	 eax
  00c00	e8 00 00 00 00	 call	 _sub
  00c05	83 c4 08	 add	 esp, 8
  00c08	0f bf c8	 movsx	 ecx, ax
  00c0b	85 c9		 test	 ecx, ecx
  00c0d	0f 8f 8f 00 00
	00		 jg	 $LN83@Decoder_am

; 626  :         {   /* MR74, MR795 */
; 627  :            test (); test (); test ();

  00c13	e8 00 00 00 00	 call	 _test
  00c18	e8 00 00 00 00	 call	 _test
  00c1d	e8 00 00 00 00	 call	 _test

; 628  :            index = *parm++;        /* index of position */ move16 ();

  00c22	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00c25	66 8b 08	 mov	 cx, WORD PTR [eax]
  00c28	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  00c2f	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00c32	83 c2 02	 add	 edx, 2
  00c35	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00c38	e8 00 00 00 00	 call	 _move16

; 629  :            i = *parm++;            /* signs             */ move16 ();

  00c3d	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00c40	66 8b 08	 mov	 cx, WORD PTR [eax]
  00c43	66 89 8d 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], cx
  00c4a	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00c4d	83 c2 02	 add	 edx, 2
  00c50	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00c53	e8 00 00 00 00	 call	 _move16

; 630  :            
; 631  :            fwc ();                 /* function worst case */

  00c58	e8 00 00 00 00	 call	 _fwc

; 632  : 
; 633  :            decode_4i40_17bits (i, index, code);

  00c5d	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00c63	50		 push	 eax
  00c64	0f b7 8d 40 fe
	ff ff		 movzx	 ecx, WORD PTR _index$[ebp]
  00c6b	51		 push	 ecx
  00c6c	0f b7 95 70 fe
	ff ff		 movzx	 edx, WORD PTR _i$[ebp]
  00c73	52		 push	 edx
  00c74	e8 00 00 00 00	 call	 _decode_4i40_17bits
  00c79	83 c4 0c	 add	 esp, 12			; 0000000cH

; 634  :            
; 635  :            fwc ();                 /* function worst case */

  00c7c	e8 00 00 00 00	 call	 _fwc

; 636  : 
; 637  :            pit_sharp = shl (st->sharp, 1);

  00c81	6a 01		 push	 1
  00c83	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00c86	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  00c8d	51		 push	 ecx
  00c8e	e8 00 00 00 00	 call	 _shl
  00c93	83 c4 08	 add	 esp, 8
  00c96	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  00c9d	e9 61 01 00 00	 jmp	 $LN88@Decoder_am
$LN83@Decoder_am:

; 638  :         }
; 639  :         else if (sub (mode, MR102) == 0)

  00ca2	6a 06		 push	 6
  00ca4	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00ca8	50		 push	 eax
  00ca9	e8 00 00 00 00	 call	 _sub
  00cae	83 c4 08	 add	 esp, 8
  00cb1	0f bf c8	 movsx	 ecx, ax
  00cb4	85 c9		 test	 ecx, ecx
  00cb6	75 5b		 jne	 SHORT $LN81@Decoder_am

; 640  :         {  /* MR102 */
; 641  :            test (); test (); test ();

  00cb8	e8 00 00 00 00	 call	 _test
  00cbd	e8 00 00 00 00	 call	 _test
  00cc2	e8 00 00 00 00	 call	 _test

; 642  : 
; 643  :            fwc ();                 /* function worst case */

  00cc7	e8 00 00 00 00	 call	 _fwc

; 644  : 
; 645  :            dec_8i40_31bits (parm, code);

  00ccc	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00cd2	50		 push	 eax
  00cd3	8b 4d 10	 mov	 ecx, DWORD PTR _parm$[ebp]
  00cd6	51		 push	 ecx
  00cd7	e8 00 00 00 00	 call	 _dec_8i40_31bits
  00cdc	83 c4 08	 add	 esp, 8

; 646  :            parm += 7;                                       move16 (); 

  00cdf	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00ce2	83 c0 0e	 add	 eax, 14			; 0000000eH
  00ce5	89 45 10	 mov	 DWORD PTR _parm$[ebp], eax
  00ce8	e8 00 00 00 00	 call	 _move16

; 647  : 
; 648  :            fwc ();                 /* function worst case */

  00ced	e8 00 00 00 00	 call	 _fwc

; 649  : 
; 650  :            pit_sharp = shl (st->sharp, 1);

  00cf2	6a 01		 push	 1
  00cf4	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00cf7	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  00cfe	51		 push	 ecx
  00cff	e8 00 00 00 00	 call	 _shl
  00d04	83 c4 08	 add	 esp, 8
  00d07	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax

; 651  :         }
; 652  :         else

  00d0e	e9 f0 00 00 00	 jmp	 $LN88@Decoder_am
$LN81@Decoder_am:

; 653  :         {  /* MR122 */
; 654  :            test (); test (); test ();

  00d13	e8 00 00 00 00	 call	 _test
  00d18	e8 00 00 00 00	 call	 _test
  00d1d	e8 00 00 00 00	 call	 _test

; 655  :            index = *parm++;                                move16 ();

  00d22	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00d25	66 8b 08	 mov	 cx, WORD PTR [eax]
  00d28	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  00d2f	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00d32	83 c2 02	 add	 edx, 2
  00d35	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00d38	e8 00 00 00 00	 call	 _move16

; 656  :            test();

  00d3d	e8 00 00 00 00	 call	 _test

; 657  :            if (bfi != 0)

  00d42	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  00d49	85 c0		 test	 eax, eax
  00d4b	74 26		 je	 SHORT $LN79@Decoder_am

; 658  :            {
; 659  :               ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  00d4d	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00d53	50		 push	 eax
  00d54	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d57	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  00d5e	52		 push	 edx
  00d5f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00d62	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  00d68	51		 push	 ecx
  00d69	e8 00 00 00 00	 call	 _ec_gain_pitch
  00d6e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  :            }
; 661  :            else

  00d71	eb 20		 jmp	 SHORT $LN78@Decoder_am
$LN79@Decoder_am:

; 662  :            {
; 663  :               gain_pit = d_gain_pitch (mode, index);        move16 ();

  00d73	0f b7 85 40 fe
	ff ff		 movzx	 eax, WORD PTR _index$[ebp]
  00d7a	50		 push	 eax
  00d7b	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  00d7e	51		 push	 ecx
  00d7f	e8 00 00 00 00	 call	 _d_gain_pitch
  00d84	83 c4 08	 add	 esp, 8
  00d87	66 89 85 28 fe
	ff ff		 mov	 WORD PTR _gain_pit$[ebp], ax
  00d8e	e8 00 00 00 00	 call	 _move16
$LN78@Decoder_am:

; 664  :            }
; 665  :            ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 666  :                                  &gain_pit);

  00d93	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00d99	50		 push	 eax
  00d9a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00d9d	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  00da4	52		 push	 edx
  00da5	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  00dac	50		 push	 eax
  00dad	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00db0	8b 91 f8 01 00
	00		 mov	 edx, DWORD PTR [ecx+504]
  00db6	52		 push	 edx
  00db7	e8 00 00 00 00	 call	 _ec_gain_pitch_update
  00dbc	83 c4 10	 add	 esp, 16			; 00000010H

; 667  :            
; 668  : 
; 669  :            fwc ();                 /* function worst case */

  00dbf	e8 00 00 00 00	 call	 _fwc

; 670  : 
; 671  : 
; 672  :            dec_10i40_35bits (parm, code);

  00dc4	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00dca	50		 push	 eax
  00dcb	8b 4d 10	 mov	 ecx, DWORD PTR _parm$[ebp]
  00dce	51		 push	 ecx
  00dcf	e8 00 00 00 00	 call	 _dec_10i40_35bits
  00dd4	83 c4 08	 add	 esp, 8

; 673  :            parm += 10;                                     move16 (); 

  00dd7	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00dda	83 c0 14	 add	 eax, 20			; 00000014H
  00ddd	89 45 10	 mov	 DWORD PTR _parm$[ebp], eax
  00de0	e8 00 00 00 00	 call	 _move16

; 674  : 
; 675  :            fwc ();                 /* function worst case */

  00de5	e8 00 00 00 00	 call	 _fwc

; 676  : 
; 677  :            /* pit_sharp = gain_pit;                   */
; 678  :            /* if (pit_sharp > 1.0) pit_sharp = 1.0;   */
; 679  :            
; 680  :            pit_sharp = shl (gain_pit, 1);

  00dea	6a 01		 push	 1
  00dec	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  00df3	50		 push	 eax
  00df4	e8 00 00 00 00	 call	 _shl
  00df9	83 c4 08	 add	 esp, 8
  00dfc	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
$LN88@Decoder_am:

; 681  :         }
; 682  :         
; 683  :         /*-------------------------------------------------------*
; 684  :          * - Add the pitch contribution to code[].               *
; 685  :          *-------------------------------------------------------*/
; 686  :         for (i = T0; i < L_SUBFR; i++)

  00e03	66 8b 85 58 fe
	ff ff		 mov	 ax, WORD PTR _T0$[ebp]
  00e0a	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00e11	eb 12		 jmp	 SHORT $LN77@Decoder_am
$LN76@Decoder_am:
  00e13	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00e1a	66 83 c0 01	 add	 ax, 1
  00e1e	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN77@Decoder_am:
  00e25	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00e2c	83 f8 28	 cmp	 eax, 40			; 00000028H
  00e2f	7d 69		 jge	 SHORT $LN75@Decoder_am

; 687  :         {
; 688  :            temp = mult (code[i - T0], pit_sharp);

  00e31	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  00e38	50		 push	 eax
  00e39	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00e40	0f bf 95 58 fe
	ff ff		 movsx	 edx, WORD PTR _T0$[ebp]
  00e47	2b ca		 sub	 ecx, edx
  00e49	0f b7 84 4d 2c
	ff ff ff	 movzx	 eax, WORD PTR _code$[ebp+ecx*2]
  00e51	50		 push	 eax
  00e52	e8 00 00 00 00	 call	 _mult
  00e57	83 c4 08	 add	 esp, 8
  00e5a	66 89 85 a4 fd
	ff ff		 mov	 WORD PTR _temp$[ebp], ax

; 689  :            code[i] = add (code[i], temp);

  00e61	0f b7 85 a4 fd
	ff ff		 movzx	 eax, WORD PTR _temp$[ebp]
  00e68	50		 push	 eax
  00e69	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00e70	0f b7 94 4d 2c
	ff ff ff	 movzx	 edx, WORD PTR _code$[ebp+ecx*2]
  00e78	52		 push	 edx
  00e79	e8 00 00 00 00	 call	 _add
  00e7e	83 c4 08	 add	 esp, 8
  00e81	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00e88	66 89 84 4d 2c
	ff ff ff	 mov	 WORD PTR _code$[ebp+ecx*2], ax

; 690  :            move16 (); 

  00e90	e8 00 00 00 00	 call	 _move16

; 691  :         }

  00e95	e9 79 ff ff ff	 jmp	 $LN76@Decoder_am
$LN75@Decoder_am:

; 692  :         
; 693  :         fwc ();                 /* function worst case */

  00e9a	e8 00 00 00 00	 call	 _fwc

; 694  :         
; 695  :         /*------------------------------------------------------------*
; 696  :          * - Decode codebook gain (MR122) or both pitch               *
; 697  :          *   gain and codebook gain (all others)                      *
; 698  :          * - Update pitch sharpening "sharp" with quantized gain_pit  *
; 699  :          *------------------------------------------------------------*/
; 700  : 
; 701  :         if (test(), sub (mode, MR475) == 0)

  00e9f	e8 00 00 00 00	 call	 _test
  00ea4	6a 00		 push	 0
  00ea6	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00eaa	50		 push	 eax
  00eab	e8 00 00 00 00	 call	 _sub
  00eb0	83 c4 08	 add	 esp, 8
  00eb3	0f bf c8	 movsx	 ecx, ax
  00eb6	85 c9		 test	 ecx, ecx
  00eb8	0f 85 71 01 00
	00		 jne	 $LN74@Decoder_am

; 702  :         {
; 703  :            /* read and decode pitch and code gain */
; 704  :            test();      

  00ebe	e8 00 00 00 00	 call	 _test

; 705  :            if (evenSubfr != 0) 

  00ec3	0f bf 85 5c fd
	ff ff		 movsx	 eax, WORD PTR _evenSubfr$[ebp]
  00eca	85 c0		 test	 eax, eax
  00ecc	74 1b		 je	 SHORT $LN73@Decoder_am

; 706  :            {
; 707  :               index_mr475 = *parm++;        move16 (); /* index of gain(s) */

  00ece	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  00ed1	66 8b 08	 mov	 cx, WORD PTR [eax]
  00ed4	66 89 8d 34 fe
	ff ff		 mov	 WORD PTR _index_mr475$[ebp], cx
  00edb	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  00ede	83 c2 02	 add	 edx, 2
  00ee1	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  00ee4	e8 00 00 00 00	 call	 _move16
$LN73@Decoder_am:

; 708  :            }
; 709  : 
; 710  :            test();

  00ee9	e8 00 00 00 00	 call	 _test

; 711  :            if (bfi == 0)

  00eee	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  00ef5	85 c0		 test	 eax, eax
  00ef7	75 3d		 jne	 SHORT $LN72@Decoder_am

; 712  :            {
; 713  :               Dec_gain(st->pred_state, mode, index_mr475, code,
; 714  :                        evenSubfr, &gain_pit, &gain_code); 

  00ef9	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  00eff	50		 push	 eax
  00f00	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _gain_pit$[ebp]
  00f06	51		 push	 ecx
  00f07	0f b7 95 5c fd
	ff ff		 movzx	 edx, WORD PTR _evenSubfr$[ebp]
  00f0e	52		 push	 edx
  00f0f	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  00f15	50		 push	 eax
  00f16	0f b7 8d 34 fe
	ff ff		 movzx	 ecx, WORD PTR _index_mr475$[ebp]
  00f1d	51		 push	 ecx
  00f1e	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00f21	52		 push	 edx
  00f22	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00f25	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  00f2b	51		 push	 ecx
  00f2c	e8 00 00 00 00	 call	 _Dec_gain
  00f31	83 c4 1c	 add	 esp, 28			; 0000001cH

; 715  :            }
; 716  :            else

  00f34	eb 52		 jmp	 SHORT $LN71@Decoder_am
$LN72@Decoder_am:

; 717  :            {
; 718  :               ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  00f36	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00f3c	50		 push	 eax
  00f3d	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00f40	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  00f47	52		 push	 edx
  00f48	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00f4b	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  00f51	51		 push	 ecx
  00f52	e8 00 00 00 00	 call	 _ec_gain_pitch
  00f57	83 c4 0c	 add	 esp, 12			; 0000000cH

; 719  :               ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 720  :                             &gain_code);

  00f5a	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  00f60	50		 push	 eax
  00f61	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00f64	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  00f6b	52		 push	 edx
  00f6c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00f6f	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  00f75	51		 push	 ecx
  00f76	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00f79	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  00f7f	50		 push	 eax
  00f80	e8 00 00 00 00	 call	 _ec_gain_code
  00f85	83 c4 10	 add	 esp, 16			; 00000010H
$LN71@Decoder_am:

; 721  :            }
; 722  :            ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 723  :                                  &gain_pit);

  00f88	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00f8e	50		 push	 eax
  00f8f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00f92	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  00f99	52		 push	 edx
  00f9a	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  00fa1	50		 push	 eax
  00fa2	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00fa5	8b 91 f8 01 00
	00		 mov	 edx, DWORD PTR [ecx+504]
  00fab	52		 push	 edx
  00fac	e8 00 00 00 00	 call	 _ec_gain_pitch_update
  00fb1	83 c4 10	 add	 esp, 16			; 00000010H

; 724  :            ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 725  :                                 &gain_code);

  00fb4	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  00fba	50		 push	 eax
  00fbb	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00fbe	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  00fc5	52		 push	 edx
  00fc6	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  00fcd	50		 push	 eax
  00fce	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00fd1	8b 91 fc 01 00
	00		 mov	 edx, DWORD PTR [ecx+508]
  00fd7	52		 push	 edx
  00fd8	e8 00 00 00 00	 call	 _ec_gain_code_update
  00fdd	83 c4 10	 add	 esp, 16			; 00000010H

; 726  :            
; 727  :            fwc ();                 /* function worst case */

  00fe0	e8 00 00 00 00	 call	 _fwc

; 728  : 
; 729  :            pit_sharp = gain_pit;                                move16 ();

  00fe5	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _gain_pit$[ebp]
  00fec	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  00ff3	e8 00 00 00 00	 call	 _move16

; 730  :            test ();

  00ff8	e8 00 00 00 00	 call	 _test

; 731  :            if (sub (pit_sharp, SHARPMAX) > 0) 

  00ffd	68 d9 32 00 00	 push	 13017			; 000032d9H
  01002	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  01009	50		 push	 eax
  0100a	e8 00 00 00 00	 call	 _sub
  0100f	83 c4 08	 add	 esp, 8
  01012	0f bf c8	 movsx	 ecx, ax
  01015	85 c9		 test	 ecx, ecx
  01017	7e 11		 jle	 SHORT $LN70@Decoder_am

; 732  :            {
; 733  :                pit_sharp = SHARPMAX;                            move16 ();

  01019	b8 d9 32 00 00	 mov	 eax, 13017		; 000032d9H
  0101e	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  01025	e8 00 00 00 00	 call	 _move16
$LN70@Decoder_am:

; 734  :            }
; 735  : 
; 736  :         }
; 737  :         else if (test(), test(), (sub (mode, MR74) <= 0) || 

  0102a	e9 7d 04 00 00	 jmp	 $LN69@Decoder_am
$LN74@Decoder_am:

; 738  :                  (sub (mode, MR102) == 0))

  0102f	e8 00 00 00 00	 call	 _test
  01034	e8 00 00 00 00	 call	 _test
  01039	6a 04		 push	 4
  0103b	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0103f	50		 push	 eax
  01040	e8 00 00 00 00	 call	 _sub
  01045	83 c4 08	 add	 esp, 8
  01048	0f bf c8	 movsx	 ecx, ax
  0104b	85 c9		 test	 ecx, ecx
  0104d	7e 20		 jle	 SHORT $LN132@Decoder_am
  0104f	6a 06		 push	 6
  01051	0f b7 55 0c	 movzx	 edx, WORD PTR _mode$[ebp]
  01055	52		 push	 edx
  01056	e8 00 00 00 00	 call	 _sub
  0105b	83 c4 08	 add	 esp, 8
  0105e	98		 cwde
  0105f	85 c0		 test	 eax, eax
  01061	74 0c		 je	 SHORT $LN132@Decoder_am
  01063	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv616[ebp], 0
  0106d	eb 0a		 jmp	 SHORT $LN133@Decoder_am
$LN132@Decoder_am:
  0106f	c7 85 70 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv616[ebp], 1
$LN133@Decoder_am:
  01079	83 bd 70 fc ff
	ff 00		 cmp	 DWORD PTR tv616[ebp], 0
  01080	0f 84 b8 01 00
	00		 je	 $LN68@Decoder_am

; 739  :         {
; 740  :             /* read and decode pitch and code gain */
; 741  :             index = *parm++;                move16 (); /* index of gain(s) */

  01086	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  01089	66 8b 08	 mov	 cx, WORD PTR [eax]
  0108c	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  01093	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  01096	83 c2 02	 add	 edx, 2
  01099	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  0109c	e8 00 00 00 00	 call	 _move16

; 742  :            
; 743  :             test();

  010a1	e8 00 00 00 00	 call	 _test

; 744  :             if (bfi == 0)

  010a6	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  010ad	85 c0		 test	 eax, eax
  010af	75 3d		 jne	 SHORT $LN67@Decoder_am

; 745  :             {
; 746  :                Dec_gain(st->pred_state, mode, index, code,
; 747  :                         evenSubfr, &gain_pit, &gain_code);

  010b1	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  010b7	50		 push	 eax
  010b8	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _gain_pit$[ebp]
  010be	51		 push	 ecx
  010bf	0f b7 95 5c fd
	ff ff		 movzx	 edx, WORD PTR _evenSubfr$[ebp]
  010c6	52		 push	 edx
  010c7	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _code$[ebp]
  010cd	50		 push	 eax
  010ce	0f b7 8d 40 fe
	ff ff		 movzx	 ecx, WORD PTR _index$[ebp]
  010d5	51		 push	 ecx
  010d6	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  010d9	52		 push	 edx
  010da	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  010dd	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  010e3	51		 push	 ecx
  010e4	e8 00 00 00 00	 call	 _Dec_gain
  010e9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 748  :             }
; 749  :             else

  010ec	eb 52		 jmp	 SHORT $LN66@Decoder_am
$LN67@Decoder_am:

; 750  :             {
; 751  :                ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  010ee	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  010f4	50		 push	 eax
  010f5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  010f8	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  010ff	52		 push	 edx
  01100	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01103	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  01109	51		 push	 ecx
  0110a	e8 00 00 00 00	 call	 _ec_gain_pitch
  0110f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  :                ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 753  :                              &gain_code);

  01112	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01118	50		 push	 eax
  01119	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0111c	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  01123	52		 push	 edx
  01124	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01127	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  0112d	51		 push	 ecx
  0112e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01131	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  01137	50		 push	 eax
  01138	e8 00 00 00 00	 call	 _ec_gain_code
  0113d	83 c4 10	 add	 esp, 16			; 00000010H
$LN66@Decoder_am:

; 754  :             }
; 755  :             ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 756  :                                   &gain_pit);

  01140	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  01146	50		 push	 eax
  01147	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0114a	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  01151	52		 push	 edx
  01152	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  01159	50		 push	 eax
  0115a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0115d	8b 91 f8 01 00
	00		 mov	 edx, DWORD PTR [ecx+504]
  01163	52		 push	 edx
  01164	e8 00 00 00 00	 call	 _ec_gain_pitch_update
  01169	83 c4 10	 add	 esp, 16			; 00000010H

; 757  :             ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 758  :                                  &gain_code);

  0116c	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01172	50		 push	 eax
  01173	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01176	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  0117d	52		 push	 edx
  0117e	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  01185	50		 push	 eax
  01186	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01189	8b 91 fc 01 00
	00		 mov	 edx, DWORD PTR [ecx+508]
  0118f	52		 push	 edx
  01190	e8 00 00 00 00	 call	 _ec_gain_code_update
  01195	83 c4 10	 add	 esp, 16			; 00000010H

; 759  : 
; 760  :             fwc ();                 /* function worst case */

  01198	e8 00 00 00 00	 call	 _fwc

; 761  :             
; 762  :             pit_sharp = gain_pit;                               move16 ();

  0119d	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _gain_pit$[ebp]
  011a4	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  011ab	e8 00 00 00 00	 call	 _move16

; 763  :             test ();

  011b0	e8 00 00 00 00	 call	 _test

; 764  :             if (sub (pit_sharp, SHARPMAX) > 0) 

  011b5	68 d9 32 00 00	 push	 13017			; 000032d9H
  011ba	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  011c1	50		 push	 eax
  011c2	e8 00 00 00 00	 call	 _sub
  011c7	83 c4 08	 add	 esp, 8
  011ca	0f bf c8	 movsx	 ecx, ax
  011cd	85 c9		 test	 ecx, ecx
  011cf	7e 11		 jle	 SHORT $LN65@Decoder_am

; 765  :             {
; 766  :                pit_sharp = SHARPMAX;                           move16 ();

  011d1	b8 d9 32 00 00	 mov	 eax, 13017		; 000032d9H
  011d6	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  011dd	e8 00 00 00 00	 call	 _move16
$LN65@Decoder_am:

; 767  :             }
; 768  : 
; 769  :             if (sub (mode, MR102) == 0)

  011e2	6a 06		 push	 6
  011e4	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  011e8	50		 push	 eax
  011e9	e8 00 00 00 00	 call	 _sub
  011ee	83 c4 08	 add	 esp, 8
  011f1	0f bf c8	 movsx	 ecx, ax
  011f4	85 c9		 test	 ecx, ecx
  011f6	75 41		 jne	 SHORT $LN64@Decoder_am

; 770  :             {
; 771  :                if (sub (st->old_T0, add(L_SUBFR, 5)) > 0)

  011f8	6a 05		 push	 5
  011fa	6a 28		 push	 40			; 00000028H
  011fc	e8 00 00 00 00	 call	 _add
  01201	83 c4 08	 add	 esp, 8
  01204	0f b7 c0	 movzx	 eax, ax
  01207	50		 push	 eax
  01208	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0120b	0f b7 91 b2 01
	00 00		 movzx	 edx, WORD PTR [ecx+434]
  01212	52		 push	 edx
  01213	e8 00 00 00 00	 call	 _sub
  01218	83 c4 08	 add	 esp, 8
  0121b	98		 cwde
  0121c	85 c0		 test	 eax, eax
  0121e	7e 19		 jle	 SHORT $LN64@Decoder_am

; 772  :                {
; 773  :                   pit_sharp = shr(pit_sharp, 2);

  01220	6a 02		 push	 2
  01222	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  01229	50		 push	 eax
  0122a	e8 00 00 00 00	 call	 _shr
  0122f	83 c4 08	 add	 esp, 8
  01232	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
$LN64@Decoder_am:

; 774  :                }
; 775  :             }
; 776  :         }
; 777  :         else

  01239	e9 6e 02 00 00	 jmp	 $LN69@Decoder_am
$LN68@Decoder_am:

; 778  :         {
; 779  :            /* read and decode pitch gain */
; 780  :            index = *parm++;                move16 (); /* index of gain(s) */

  0123e	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  01241	66 8b 08	 mov	 cx, WORD PTR [eax]
  01244	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  0124b	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  0124e	83 c2 02	 add	 edx, 2
  01251	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  01254	e8 00 00 00 00	 call	 _move16

; 781  :            
; 782  :            test (); 

  01259	e8 00 00 00 00	 call	 _test

; 783  :            if (sub (mode, MR795) == 0)

  0125e	6a 05		 push	 5
  01260	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01264	50		 push	 eax
  01265	e8 00 00 00 00	 call	 _sub
  0126a	83 c4 08	 add	 esp, 8
  0126d	0f bf c8	 movsx	 ecx, ax
  01270	85 c9		 test	 ecx, ecx
  01272	0f 85 84 01 00
	00		 jne	 $LN61@Decoder_am

; 784  :            {
; 785  :               /* decode pitch gain */
; 786  :               test();

  01278	e8 00 00 00 00	 call	 _test

; 787  :               if (bfi != 0)

  0127d	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01284	85 c0		 test	 eax, eax
  01286	74 26		 je	 SHORT $LN60@Decoder_am

; 788  :               {
; 789  :                  ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  01288	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  0128e	50		 push	 eax
  0128f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01292	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  01299	52		 push	 edx
  0129a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0129d	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  012a3	51		 push	 ecx
  012a4	e8 00 00 00 00	 call	 _ec_gain_pitch
  012a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 790  :               }
; 791  :               else

  012ac	eb 20		 jmp	 SHORT $LN59@Decoder_am
$LN60@Decoder_am:

; 792  :               {
; 793  :                  gain_pit = d_gain_pitch (mode, index);       move16 ();

  012ae	0f b7 85 40 fe
	ff ff		 movzx	 eax, WORD PTR _index$[ebp]
  012b5	50		 push	 eax
  012b6	8b 4d 0c	 mov	 ecx, DWORD PTR _mode$[ebp]
  012b9	51		 push	 ecx
  012ba	e8 00 00 00 00	 call	 _d_gain_pitch
  012bf	83 c4 08	 add	 esp, 8
  012c2	66 89 85 28 fe
	ff ff		 mov	 WORD PTR _gain_pit$[ebp], ax
  012c9	e8 00 00 00 00	 call	 _move16
$LN59@Decoder_am:

; 794  :               }
; 795  :               ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 796  :                                     &gain_pit);

  012ce	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  012d4	50		 push	 eax
  012d5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  012d8	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  012df	52		 push	 edx
  012e0	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  012e7	50		 push	 eax
  012e8	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  012eb	8b 91 f8 01 00
	00		 mov	 edx, DWORD PTR [ecx+504]
  012f1	52		 push	 edx
  012f2	e8 00 00 00 00	 call	 _ec_gain_pitch_update
  012f7	83 c4 10	 add	 esp, 16			; 00000010H

; 797  :               
; 798  :               /* read and decode code gain */
; 799  :               index = *parm++;                                move16 ();

  012fa	8b 45 10	 mov	 eax, DWORD PTR _parm$[ebp]
  012fd	66 8b 08	 mov	 cx, WORD PTR [eax]
  01300	66 89 8d 40 fe
	ff ff		 mov	 WORD PTR _index$[ebp], cx
  01307	8b 55 10	 mov	 edx, DWORD PTR _parm$[ebp]
  0130a	83 c2 02	 add	 edx, 2
  0130d	89 55 10	 mov	 DWORD PTR _parm$[ebp], edx
  01310	e8 00 00 00 00	 call	 _move16

; 800  :               test();

  01315	e8 00 00 00 00	 call	 _test

; 801  :               if (bfi == 0)

  0131a	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01321	85 c0		 test	 eax, eax
  01323	75 2e		 jne	 SHORT $LN58@Decoder_am

; 802  :               {
; 803  :                  d_gain_code (st->pred_state, mode, index, code, &gain_code);

  01325	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  0132b	50		 push	 eax
  0132c	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _code$[ebp]
  01332	51		 push	 ecx
  01333	0f b7 95 40 fe
	ff ff		 movzx	 edx, WORD PTR _index$[ebp]
  0133a	52		 push	 edx
  0133b	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0133e	50		 push	 eax
  0133f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01342	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  01348	52		 push	 edx
  01349	e8 00 00 00 00	 call	 _d_gain_code
  0134e	83 c4 14	 add	 esp, 20			; 00000014H

; 804  :               }
; 805  :               else

  01351	eb 2e		 jmp	 SHORT $LN57@Decoder_am
$LN58@Decoder_am:

; 806  :               {
; 807  :                  ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 808  :                                &gain_code);

  01353	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01359	50		 push	 eax
  0135a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0135d	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  01364	52		 push	 edx
  01365	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01368	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  0136e	51		 push	 ecx
  0136f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01372	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  01378	50		 push	 eax
  01379	e8 00 00 00 00	 call	 _ec_gain_code
  0137e	83 c4 10	 add	 esp, 16			; 00000010H
$LN57@Decoder_am:

; 809  :               }
; 810  :               ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 811  :                                    &gain_code);

  01381	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01387	50		 push	 eax
  01388	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0138b	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  01392	52		 push	 edx
  01393	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  0139a	50		 push	 eax
  0139b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0139e	8b 91 fc 01 00
	00		 mov	 edx, DWORD PTR [ecx+508]
  013a4	52		 push	 edx
  013a5	e8 00 00 00 00	 call	 _ec_gain_code_update
  013aa	83 c4 10	 add	 esp, 16			; 00000010H

; 812  :               
; 813  :               fwc ();                 /* function worst case */

  013ad	e8 00 00 00 00	 call	 _fwc

; 814  :               
; 815  :               pit_sharp = gain_pit;                               move16 ();

  013b2	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _gain_pit$[ebp]
  013b9	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  013c0	e8 00 00 00 00	 call	 _move16

; 816  :               test ();

  013c5	e8 00 00 00 00	 call	 _test

; 817  :               if (sub (pit_sharp, SHARPMAX) > 0)

  013ca	68 d9 32 00 00	 push	 13017			; 000032d9H
  013cf	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  013d6	50		 push	 eax
  013d7	e8 00 00 00 00	 call	 _sub
  013dc	83 c4 08	 add	 esp, 8
  013df	0f bf c8	 movsx	 ecx, ax
  013e2	85 c9		 test	 ecx, ecx
  013e4	7e 11		 jle	 SHORT $LN56@Decoder_am

; 818  :               {
; 819  :                  pit_sharp = SHARPMAX;                           move16 ();

  013e6	b8 d9 32 00 00	 mov	 eax, 13017		; 000032d9H
  013eb	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  013f2	e8 00 00 00 00	 call	 _move16
$LN56@Decoder_am:

; 820  :               }
; 821  :            }
; 822  :            else 

  013f7	e9 b0 00 00 00	 jmp	 $LN69@Decoder_am
$LN61@Decoder_am:

; 823  :            { /* MR122 */
; 824  :               test();

  013fc	e8 00 00 00 00	 call	 _test

; 825  :               if (bfi == 0)

  01401	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01408	85 c0		 test	 eax, eax
  0140a	75 2e		 jne	 SHORT $LN54@Decoder_am

; 826  :               {
; 827  :                  d_gain_code (st->pred_state, mode, index, code, &gain_code);

  0140c	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01412	50		 push	 eax
  01413	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _code$[ebp]
  01419	51		 push	 ecx
  0141a	0f b7 95 40 fe
	ff ff		 movzx	 edx, WORD PTR _index$[ebp]
  01421	52		 push	 edx
  01422	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  01425	50		 push	 eax
  01426	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01429	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  0142f	52		 push	 edx
  01430	e8 00 00 00 00	 call	 _d_gain_code
  01435	83 c4 14	 add	 esp, 20			; 00000014H

; 828  :               }
; 829  :               else

  01438	eb 2e		 jmp	 SHORT $LN53@Decoder_am
$LN54@Decoder_am:

; 830  :               {
; 831  :                  ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 832  :                                &gain_code);

  0143a	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01440	50		 push	 eax
  01441	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01444	0f b7 91 b8 01
	00 00		 movzx	 edx, WORD PTR [ecx+440]
  0144b	52		 push	 edx
  0144c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0144f	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  01455	51		 push	 ecx
  01456	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01459	8b 82 fc 01 00
	00		 mov	 eax, DWORD PTR [edx+508]
  0145f	50		 push	 eax
  01460	e8 00 00 00 00	 call	 _ec_gain_code
  01465	83 c4 10	 add	 esp, 16			; 00000010H
$LN53@Decoder_am:

; 833  :               }
; 834  :               ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 835  :                                    &gain_code);

  01468	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  0146e	50		 push	 eax
  0146f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01472	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  01479	52		 push	 edx
  0147a	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  01481	50		 push	 eax
  01482	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01485	8b 91 fc 01 00
	00		 mov	 edx, DWORD PTR [ecx+508]
  0148b	52		 push	 edx
  0148c	e8 00 00 00 00	 call	 _ec_gain_code_update
  01491	83 c4 10	 add	 esp, 16			; 00000010H

; 836  :                             
; 837  :               fwc ();                 /* function worst case */

  01494	e8 00 00 00 00	 call	 _fwc

; 838  :                 
; 839  :               pit_sharp = gain_pit;                                move16 ();

  01499	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _gain_pit$[ebp]
  014a0	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax
  014a7	e8 00 00 00 00	 call	 _move16
$LN69@Decoder_am:

; 840  :            }
; 841  :         }
; 842  :         
; 843  :         /* store pitch sharpening for next subframe          */
; 844  :         /* (for modes which use the previous pitch gain for 
; 845  :            pitch sharpening in the search phase)             */
; 846  :         /* do not update sharpening in even subframes for MR475 */
; 847  :         test(); test();

  014ac	e8 00 00 00 00	 call	 _test
  014b1	e8 00 00 00 00	 call	 _test

; 848  :         if (sub(mode, MR475) != 0 || evenSubfr == 0)

  014b6	6a 00		 push	 0
  014b8	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  014bc	50		 push	 eax
  014bd	e8 00 00 00 00	 call	 _sub
  014c2	83 c4 08	 add	 esp, 8
  014c5	0f bf c8	 movsx	 ecx, ax
  014c8	85 c9		 test	 ecx, ecx
  014ca	75 0b		 jne	 SHORT $LN51@Decoder_am
  014cc	0f bf 85 5c fd
	ff ff		 movsx	 eax, WORD PTR _evenSubfr$[ebp]
  014d3	85 c0		 test	 eax, eax
  014d5	75 4e		 jne	 SHORT $LN52@Decoder_am
$LN51@Decoder_am:

; 849  :         {
; 850  :             st->sharp = gain_pit;                                   move16 (); 

  014d7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  014da	66 8b 8d 28 fe
	ff ff		 mov	 cx, WORD PTR _gain_pit$[ebp]
  014e1	66 89 88 b0 01
	00 00		 mov	 WORD PTR [eax+432], cx
  014e8	e8 00 00 00 00	 call	 _move16

; 851  :             test ();

  014ed	e8 00 00 00 00	 call	 _test

; 852  :             if (sub (st->sharp, SHARPMAX) > 0)

  014f2	68 d9 32 00 00	 push	 13017			; 000032d9H
  014f7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  014fa	0f b7 88 b0 01
	00 00		 movzx	 ecx, WORD PTR [eax+432]
  01501	51		 push	 ecx
  01502	e8 00 00 00 00	 call	 _sub
  01507	83 c4 08	 add	 esp, 8
  0150a	0f bf d0	 movsx	 edx, ax
  0150d	85 d2		 test	 edx, edx
  0150f	7e 14		 jle	 SHORT $LN52@Decoder_am

; 853  :             {
; 854  :                 st->sharp = SHARPMAX;                                move16 ();

  01511	b8 d9 32 00 00	 mov	 eax, 13017		; 000032d9H
  01516	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01519	66 89 81 b0 01
	00 00		 mov	 WORD PTR [ecx+432], ax
  01520	e8 00 00 00 00	 call	 _move16
$LN52@Decoder_am:

; 855  :             }
; 856  :         }
; 857  : 
; 858  :         pit_sharp = shl (pit_sharp, 1);

  01525	6a 01		 push	 1
  01527	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  0152e	50		 push	 eax
  0152f	e8 00 00 00 00	 call	 _shl
  01534	83 c4 08	 add	 esp, 8
  01537	66 89 85 04 fe
	ff ff		 mov	 WORD PTR _pit_sharp$[ebp], ax

; 859  :         test ();

  0153e	e8 00 00 00 00	 call	 _test

; 860  :         if (sub (pit_sharp, 16384) > 0)

  01543	68 00 40 00 00	 push	 16384			; 00004000H
  01548	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  0154f	50		 push	 eax
  01550	e8 00 00 00 00	 call	 _sub
  01555	83 c4 08	 add	 esp, 8
  01558	0f bf c8	 movsx	 ecx, ax
  0155b	85 c9		 test	 ecx, ecx
  0155d	0f 8e d1 00 00
	00		 jle	 $LN49@Decoder_am

; 861  :         {
; 862  :            for (i = 0; i < L_SUBFR; i++)

  01563	33 c0		 xor	 eax, eax
  01565	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0156c	eb 12		 jmp	 SHORT $LN48@Decoder_am
$LN47@Decoder_am:
  0156e	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01575	66 83 c0 01	 add	 ax, 1
  01579	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN48@Decoder_am:
  01580	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01587	83 f8 28	 cmp	 eax, 40			; 00000028H
  0158a	0f 8d a4 00 00
	00		 jge	 $LN49@Decoder_am

; 863  :             {
; 864  :                temp = mult (st->exc[i], pit_sharp);

  01590	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  01597	50		 push	 eax
  01598	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  0159f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  015a2	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  015a8	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  015ac	51		 push	 ecx
  015ad	e8 00 00 00 00	 call	 _mult
  015b2	83 c4 08	 add	 esp, 8
  015b5	66 89 85 a4 fd
	ff ff		 mov	 WORD PTR _temp$[ebp], ax

; 865  :                L_temp = L_mult (temp, gain_pit);

  015bc	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  015c3	50		 push	 eax
  015c4	0f b7 8d a4 fd
	ff ff		 movzx	 ecx, WORD PTR _temp$[ebp]
  015cb	51		 push	 ecx
  015cc	e8 00 00 00 00	 call	 _L_mult
  015d1	83 c4 08	 add	 esp, 8
  015d4	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 866  :                test ();

  015da	e8 00 00 00 00	 call	 _test

; 867  :                if (sub(mode, MR122)==0)

  015df	6a 07		 push	 7
  015e1	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  015e5	50		 push	 eax
  015e6	e8 00 00 00 00	 call	 _sub
  015eb	83 c4 08	 add	 esp, 8
  015ee	0f bf c8	 movsx	 ecx, ax
  015f1	85 c9		 test	 ecx, ecx
  015f3	75 17		 jne	 SHORT $LN45@Decoder_am

; 868  :                {
; 869  :                   L_temp = L_shr (L_temp, 1);

  015f5	6a 01		 push	 1
  015f7	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  015fd	50		 push	 eax
  015fe	e8 00 00 00 00	 call	 _L_shr
  01603	83 c4 08	 add	 esp, 8
  01606	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax
$LN45@Decoder_am:

; 870  :                }
; 871  :                excp[i] = round (L_temp);                        move16 (); 

  0160c	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  01612	50		 push	 eax
  01613	e8 00 00 00 00	 call	 _round
  01618	83 c4 04	 add	 esp, 4
  0161b	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01622	66 89 84 4d d4
	fe ff ff	 mov	 WORD PTR _excp$[ebp+ecx*2], ax
  0162a	e8 00 00 00 00	 call	 _move16

; 872  :             }

  0162f	e9 3a ff ff ff	 jmp	 $LN47@Decoder_am
$LN49@Decoder_am:

; 873  :         }
; 874  :         
; 875  :         /*-------------------------------------------------------*
; 876  :          * - Store list of LTP gains needed in the source        *
; 877  :          *   characteristic detector (SCD)                       *
; 878  :          *-------------------------------------------------------*/
; 879  :         test ();

  01634	e8 00 00 00 00	 call	 _test

; 880  :         if ( bfi == 0 )

  01639	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01640	85 c0		 test	 eax, eax
  01642	75 73		 jne	 SHORT $LN44@Decoder_am

; 881  :         {
; 882  :            for (i = 0; i < 8; i++)

  01644	33 c0		 xor	 eax, eax
  01646	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0164d	eb 12		 jmp	 SHORT $LN43@Decoder_am
$LN42@Decoder_am:
  0164f	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01656	66 83 c0 01	 add	 ax, 1
  0165a	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN43@Decoder_am:
  01661	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01668	83 f8 08	 cmp	 eax, 8
  0166b	7d 2b		 jge	 SHORT $LN41@Decoder_am

; 883  :            {
; 884  :               st->ltpGainHistory[i] = st->ltpGainHistory[i+1];     move16 ();

  0166d	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01674	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  0167b	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0167e	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  01681	66 8b 84 46 d4
	01 00 00	 mov	 ax, WORD PTR [esi+eax*2+468]
  01689	66 89 84 4a d2
	01 00 00	 mov	 WORD PTR [edx+ecx*2+466], ax
  01691	e8 00 00 00 00	 call	 _move16

; 885  :            }

  01696	eb b7		 jmp	 SHORT $LN42@Decoder_am
$LN41@Decoder_am:

; 886  :            st->ltpGainHistory[8] = gain_pit;                       move16 ();

  01698	b8 02 00 00 00	 mov	 eax, 2
  0169d	c1 e0 03	 shl	 eax, 3
  016a0	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  016a3	66 8b 95 28 fe
	ff ff		 mov	 dx, WORD PTR _gain_pit$[ebp]
  016aa	66 89 94 01 d2
	01 00 00	 mov	 WORD PTR [ecx+eax+466], dx
  016b2	e8 00 00 00 00	 call	 _move16
$LN44@Decoder_am:

; 887  :         }
; 888  : 
; 889  :         /*-------------------------------------------------------*
; 890  :          * - Limit gain_pit if in background noise and BFI       *
; 891  :          *   for MR475, MR515, MR59                              *
; 892  :          *-------------------------------------------------------*/
; 893  : 
; 894  :         test (); test (); test (); test (); test (); test ();

  016b7	e8 00 00 00 00	 call	 _test
  016bc	e8 00 00 00 00	 call	 _test
  016c1	e8 00 00 00 00	 call	 _test
  016c6	e8 00 00 00 00	 call	 _test
  016cb	e8 00 00 00 00	 call	 _test
  016d0	e8 00 00 00 00	 call	 _test

; 895  :         if ( (st->prev_bf != 0 || bfi != 0) && st->inBackgroundNoise != 0 &&
; 896  :              ((sub(mode, MR475) == 0) ||
; 897  :               (sub(mode, MR515) == 0) ||
; 898  :               (sub(mode, MR59) == 0))
; 899  :              )

  016d5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  016d8	0f bf 88 b4 01
	00 00		 movsx	 ecx, WORD PTR [eax+436]
  016df	85 c9		 test	 ecx, ecx
  016e1	75 0f		 jne	 SHORT $LN39@Decoder_am
  016e3	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  016ea	85 c0		 test	 eax, eax
  016ec	0f 84 e6 00 00
	00		 je	 $LN40@Decoder_am
$LN39@Decoder_am:
  016f2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  016f5	0f bf 88 ce 01
	00 00		 movsx	 ecx, WORD PTR [eax+462]
  016fc	85 c9		 test	 ecx, ecx
  016fe	0f 84 d4 00 00
	00		 je	 $LN40@Decoder_am
  01704	6a 00		 push	 0
  01706	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0170a	50		 push	 eax
  0170b	e8 00 00 00 00	 call	 _sub
  01710	83 c4 08	 add	 esp, 8
  01713	0f bf c8	 movsx	 ecx, ax
  01716	85 c9		 test	 ecx, ecx
  01718	74 30		 je	 SHORT $LN38@Decoder_am
  0171a	6a 01		 push	 1
  0171c	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01720	50		 push	 eax
  01721	e8 00 00 00 00	 call	 _sub
  01726	83 c4 08	 add	 esp, 8
  01729	0f bf c8	 movsx	 ecx, ax
  0172c	85 c9		 test	 ecx, ecx
  0172e	74 1a		 je	 SHORT $LN38@Decoder_am
  01730	6a 02		 push	 2
  01732	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01736	50		 push	 eax
  01737	e8 00 00 00 00	 call	 _sub
  0173c	83 c4 08	 add	 esp, 8
  0173f	0f bf c8	 movsx	 ecx, ax
  01742	85 c9		 test	 ecx, ecx
  01744	0f 85 8e 00 00
	00		 jne	 $LN40@Decoder_am
$LN38@Decoder_am:

; 900  :         {
; 901  :            test ();

  0174a	e8 00 00 00 00	 call	 _test

; 902  :            if ( sub (gain_pit, 12288) > 0)    /* if (gain_pit > 0.75) in Q14*/

  0174f	68 00 30 00 00	 push	 12288			; 00003000H
  01754	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  0175b	50		 push	 eax
  0175c	e8 00 00 00 00	 call	 _sub
  01761	83 c4 08	 add	 esp, 8
  01764	0f bf c8	 movsx	 ecx, ax
  01767	85 c9		 test	 ecx, ecx
  01769	7e 3b		 jle	 SHORT $LN37@Decoder_am

; 903  :               gain_pit = add( shr( sub(gain_pit, 12288), 1 ), 12288 );

  0176b	68 00 30 00 00	 push	 12288			; 00003000H
  01770	6a 01		 push	 1
  01772	68 00 30 00 00	 push	 12288			; 00003000H
  01777	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  0177e	50		 push	 eax
  0177f	e8 00 00 00 00	 call	 _sub
  01784	83 c4 08	 add	 esp, 8
  01787	0f b7 c8	 movzx	 ecx, ax
  0178a	51		 push	 ecx
  0178b	e8 00 00 00 00	 call	 _shr
  01790	83 c4 08	 add	 esp, 8
  01793	0f b7 d0	 movzx	 edx, ax
  01796	52		 push	 edx
  01797	e8 00 00 00 00	 call	 _add
  0179c	83 c4 08	 add	 esp, 8
  0179f	66 89 85 28 fe
	ff ff		 mov	 WORD PTR _gain_pit$[ebp], ax
$LN37@Decoder_am:

; 904  :               /* gain_pit = (gain_pit-0.75)/2.0 + 0.75; */
; 905  : 
; 906  :            test ();

  017a6	e8 00 00 00 00	 call	 _test

; 907  :            if ( sub (gain_pit, 14745) > 0)    /* if (gain_pit > 0.90) in Q14*/

  017ab	68 99 39 00 00	 push	 14745			; 00003999H
  017b0	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  017b7	50		 push	 eax
  017b8	e8 00 00 00 00	 call	 _sub
  017bd	83 c4 08	 add	 esp, 8
  017c0	0f bf c8	 movsx	 ecx, ax
  017c3	85 c9		 test	 ecx, ecx
  017c5	7e 11		 jle	 SHORT $LN40@Decoder_am

; 908  :            {
; 909  :               gain_pit = 14745;                                 move16 ();

  017c7	b8 99 39 00 00	 mov	 eax, 14745		; 00003999H
  017cc	66 89 85 28 fe
	ff ff		 mov	 WORD PTR _gain_pit$[ebp], ax
  017d3	e8 00 00 00 00	 call	 _move16
$LN40@Decoder_am:

; 910  :            }
; 911  :         }
; 912  : 
; 913  :         /*-------------------------------------------------------*
; 914  :          *  Calculate CB mixed gain                              *
; 915  :          *-------------------------------------------------------*/
; 916  :         Int_lsf(prev_lsf, st->lsfState->past_lsf_q, i_subfr, lsf_i); 

  017d8	8d 45 84	 lea	 eax, DWORD PTR _lsf_i$[ebp]
  017db	50		 push	 eax
  017dc	0f b7 8d 64 fe
	ff ff		 movzx	 ecx, WORD PTR _i_subfr$[ebp]
  017e3	51		 push	 ecx
  017e4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  017e7	8b 82 f4 01 00
	00		 mov	 eax, DWORD PTR [edx+500]
  017ed	83 c0 14	 add	 eax, 20			; 00000014H
  017f0	50		 push	 eax
  017f1	8d 4d a0	 lea	 ecx, DWORD PTR _prev_lsf$[ebp]
  017f4	51		 push	 ecx
  017f5	e8 00 00 00 00	 call	 _Int_lsf
  017fa	83 c4 10	 add	 esp, 16			; 00000010H

; 917  :         gain_code_mix = Cb_gain_average(
; 918  :             st->Cb_gain_averState, mode, gain_code, 
; 919  :             lsf_i, st->lsp_avg_st->lsp_meanSave, bfi, 
; 920  :             st->prev_bf, pdfi, st->prev_pdf,  
; 921  :             st->inBackgroundNoise, st->voicedHangover);         move16 ();

  017fd	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01800	0f b7 88 d0 01
	00 00		 movzx	 ecx, WORD PTR [eax+464]
  01807	51		 push	 ecx
  01808	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0180b	0f b7 82 ce 01
	00 00		 movzx	 eax, WORD PTR [edx+462]
  01812	50		 push	 eax
  01813	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01816	0f b7 91 b6 01
	00 00		 movzx	 edx, WORD PTR [ecx+438]
  0181d	52		 push	 edx
  0181e	0f b7 85 44 fd
	ff ff		 movzx	 eax, WORD PTR _pdfi$[ebp]
  01825	50		 push	 eax
  01826	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01829	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  01830	52		 push	 edx
  01831	0f b7 85 50 fd
	ff ff		 movzx	 eax, WORD PTR _bfi$[ebp]
  01838	50		 push	 eax
  01839	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0183c	8b 91 f0 01 00
	00		 mov	 edx, DWORD PTR [ecx+496]
  01842	52		 push	 edx
  01843	8d 45 84	 lea	 eax, DWORD PTR _lsf_i$[ebp]
  01846	50		 push	 eax
  01847	0f b7 8d 1c fe
	ff ff		 movzx	 ecx, WORD PTR _gain_code$[ebp]
  0184e	51		 push	 ecx
  0184f	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  01852	52		 push	 edx
  01853	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01856	8b 88 ec 01 00
	00		 mov	 ecx, DWORD PTR [eax+492]
  0185c	51		 push	 ecx
  0185d	e8 00 00 00 00	 call	 _Cb_gain_average
  01862	83 c4 2c	 add	 esp, 44			; 0000002cH
  01865	66 89 85 10 fe
	ff ff		 mov	 WORD PTR _gain_code_mix$[ebp], ax
  0186c	e8 00 00 00 00	 call	 _move16

; 922  :         
; 923  :         /* make sure that MR74, MR795, MR122 have original code_gain*/
; 924  :         test();

  01871	e8 00 00 00 00	 call	 _test

; 925  :         if ((sub(mode, MR67) > 0) && (sub(mode, MR102) != 0) ) 

  01876	6a 03		 push	 3
  01878	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0187c	50		 push	 eax
  0187d	e8 00 00 00 00	 call	 _sub
  01882	83 c4 08	 add	 esp, 8
  01885	0f bf c8	 movsx	 ecx, ax
  01888	85 c9		 test	 ecx, ecx
  0188a	7e 29		 jle	 SHORT $LN35@Decoder_am
  0188c	6a 06		 push	 6
  0188e	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01892	50		 push	 eax
  01893	e8 00 00 00 00	 call	 _sub
  01898	83 c4 08	 add	 esp, 8
  0189b	0f bf c8	 movsx	 ecx, ax
  0189e	85 c9		 test	 ecx, ecx
  018a0	74 13		 je	 SHORT $LN35@Decoder_am

; 926  :            /* MR74, MR795, MR122 */
; 927  :         {
; 928  :            gain_code_mix = gain_code;                 move16 ();

  018a2	66 8b 85 1c fe
	ff ff		 mov	 ax, WORD PTR _gain_code$[ebp]
  018a9	66 89 85 10 fe
	ff ff		 mov	 WORD PTR _gain_code_mix$[ebp], ax
  018b0	e8 00 00 00 00	 call	 _move16
$LN35@Decoder_am:

; 929  :         }
; 930  :         
; 931  :         /*-------------------------------------------------------*
; 932  :          * - Find the total excitation.                          *
; 933  :          * - Find synthesis speech corresponding to st->exc[].   *
; 934  :          *-------------------------------------------------------*/
; 935  :         test ();

  018b5	e8 00 00 00 00	 call	 _test

; 936  :         if (sub(mode, MR102) <= 0) /* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/

  018ba	6a 06		 push	 6
  018bc	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  018c0	50		 push	 eax
  018c1	e8 00 00 00 00	 call	 _sub
  018c6	83 c4 08	 add	 esp, 8
  018c9	0f bf c8	 movsx	 ecx, ax
  018cc	85 c9		 test	 ecx, ecx
  018ce	7f 26		 jg	 SHORT $LN34@Decoder_am

; 937  :         {
; 938  :            pitch_fac = gain_pit;                                move16 ();

  018d0	66 8b 85 28 fe
	ff ff		 mov	 ax, WORD PTR _gain_pit$[ebp]
  018d7	66 89 85 ec fd
	ff ff		 mov	 WORD PTR _pitch_fac$[ebp], ax
  018de	e8 00 00 00 00	 call	 _move16

; 939  :            tmp_shift = 1;                                       move16 ();

  018e3	b8 01 00 00 00	 mov	 eax, 1
  018e8	66 89 85 b0 fd
	ff ff		 mov	 WORD PTR _tmp_shift$[ebp], ax
  018ef	e8 00 00 00 00	 call	 _move16

; 940  :         }
; 941  :         else       /* MR122 */

  018f4	eb 2f		 jmp	 SHORT $LN33@Decoder_am
$LN34@Decoder_am:

; 942  :         {
; 943  :            pitch_fac = shr (gain_pit, 1);                       move16 ();

  018f6	6a 01		 push	 1
  018f8	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  018ff	50		 push	 eax
  01900	e8 00 00 00 00	 call	 _shr
  01905	83 c4 08	 add	 esp, 8
  01908	66 89 85 ec fd
	ff ff		 mov	 WORD PTR _pitch_fac$[ebp], ax
  0190f	e8 00 00 00 00	 call	 _move16

; 944  :            tmp_shift = 2;                                       move16 ();

  01914	b8 02 00 00 00	 mov	 eax, 2
  01919	66 89 85 b0 fd
	ff ff		 mov	 WORD PTR _tmp_shift$[ebp], ax
  01920	e8 00 00 00 00	 call	 _move16
$LN33@Decoder_am:

; 945  :         }
; 946  : 
; 947  :         /* copy unscaled LTP excitation to exc_enhanced (used in phase
; 948  :          * dispersion below) and compute total excitation for LTP feedback
; 949  :          */
; 950  :         for (i = 0; i < L_SUBFR; i++)

  01925	33 c0		 xor	 eax, eax
  01927	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0192e	eb 12		 jmp	 SHORT $LN32@Decoder_am
$LN31@Decoder_am:
  01930	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01937	66 83 c0 01	 add	 ax, 1
  0193b	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN32@Decoder_am:
  01942	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01949	83 f8 28	 cmp	 eax, 40			; 00000028H
  0194c	0f 8d ca 00 00
	00		 jge	 $LN30@Decoder_am

; 951  :         {
; 952  :            exc_enhanced[i] = st->exc[i];                        move16 ();

  01952	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01959	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0195c	8b 91 84 01 00
	00		 mov	 edx, DWORD PTR [ecx+388]
  01962	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01969	66 8b 14 42	 mov	 dx, WORD PTR [edx+eax*2]
  0196d	66 89 94 4d 7c
	fe ff ff	 mov	 WORD PTR _exc_enhanced$[ebp+ecx*2], dx
  01975	e8 00 00 00 00	 call	 _move16

; 953  : 
; 954  :            /* st->exc[i] = gain_pit*st->exc[i] + gain_code*code[i]; */
; 955  :            L_temp = L_mult (st->exc[i], pitch_fac);

  0197a	0f b7 85 ec fd
	ff ff		 movzx	 eax, WORD PTR _pitch_fac$[ebp]
  01981	50		 push	 eax
  01982	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01989	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0198c	8b 82 84 01 00
	00		 mov	 eax, DWORD PTR [edx+388]
  01992	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  01996	51		 push	 ecx
  01997	e8 00 00 00 00	 call	 _L_mult
  0199c	83 c4 08	 add	 esp, 8
  0199f	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 956  :                                                       /* 12.2: Q0 * Q13 */
; 957  :                                                       /*  7.4: Q0 * Q14 */
; 958  :            L_temp = L_mac (L_temp, code[i], gain_code);

  019a5	0f b7 85 1c fe
	ff ff		 movzx	 eax, WORD PTR _gain_code$[ebp]
  019ac	50		 push	 eax
  019ad	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  019b4	0f b7 94 4d 2c
	ff ff ff	 movzx	 edx, WORD PTR _code$[ebp+ecx*2]
  019bc	52		 push	 edx
  019bd	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  019c3	50		 push	 eax
  019c4	e8 00 00 00 00	 call	 _L_mac
  019c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  019cc	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 959  :                                                       /* 12.2: Q12 * Q1 */
; 960  :                                                       /*  7.4: Q13 * Q1 */
; 961  :            L_temp = L_shl (L_temp, tmp_shift);                   /* Q16 */

  019d2	0f b7 85 b0 fd
	ff ff		 movzx	 eax, WORD PTR _tmp_shift$[ebp]
  019d9	50		 push	 eax
  019da	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _L_temp$[ebp]
  019e0	51		 push	 ecx
  019e1	e8 00 00 00 00	 call	 _L_shl
  019e6	83 c4 08	 add	 esp, 8
  019e9	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 962  :            st->exc[i] = round (L_temp);                         move16 (); 

  019ef	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  019f5	50		 push	 eax
  019f6	e8 00 00 00 00	 call	 _round
  019fb	83 c4 04	 add	 esp, 4
  019fe	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01a05	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01a08	8b 92 84 01 00
	00		 mov	 edx, DWORD PTR [edx+388]
  01a0e	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  01a12	e8 00 00 00 00	 call	 _move16

; 963  :         }

  01a17	e9 14 ff ff ff	 jmp	 $LN31@Decoder_am
$LN30@Decoder_am:

; 964  :         
; 965  :         /*-------------------------------------------------------*
; 966  :          * - Adaptive phase dispersion                           *
; 967  :          *-------------------------------------------------------*/
; 968  :         ph_disp_release(st->ph_disp_st); /* free phase dispersion adaption */

  01a1c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01a1f	8b 88 04 02 00
	00		 mov	 ecx, DWORD PTR [eax+516]
  01a25	51		 push	 ecx
  01a26	e8 00 00 00 00	 call	 _ph_disp_release
  01a2b	83 c4 04	 add	 esp, 4

; 969  : 
; 970  :         test (); test (); test (); test (); test (); test ();

  01a2e	e8 00 00 00 00	 call	 _test
  01a33	e8 00 00 00 00	 call	 _test
  01a38	e8 00 00 00 00	 call	 _test
  01a3d	e8 00 00 00 00	 call	 _test
  01a42	e8 00 00 00 00	 call	 _test
  01a47	e8 00 00 00 00	 call	 _test

; 971  :         if ( ((sub(mode, MR475) == 0) ||
; 972  :               (sub(mode, MR515) == 0) ||
; 973  :               (sub(mode, MR59) == 0))   &&
; 974  :              sub(st->voicedHangover, 3) > 0 &&
; 975  :              st->inBackgroundNoise != 0 &&
; 976  :              bfi != 0 )

  01a4c	6a 00		 push	 0
  01a4e	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01a52	50		 push	 eax
  01a53	e8 00 00 00 00	 call	 _sub
  01a58	83 c4 08	 add	 esp, 8
  01a5b	0f bf c8	 movsx	 ecx, ax
  01a5e	85 c9		 test	 ecx, ecx
  01a60	74 2c		 je	 SHORT $LN28@Decoder_am
  01a62	6a 01		 push	 1
  01a64	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01a68	50		 push	 eax
  01a69	e8 00 00 00 00	 call	 _sub
  01a6e	83 c4 08	 add	 esp, 8
  01a71	0f bf c8	 movsx	 ecx, ax
  01a74	85 c9		 test	 ecx, ecx
  01a76	74 16		 je	 SHORT $LN28@Decoder_am
  01a78	6a 02		 push	 2
  01a7a	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01a7e	50		 push	 eax
  01a7f	e8 00 00 00 00	 call	 _sub
  01a84	83 c4 08	 add	 esp, 8
  01a87	0f bf c8	 movsx	 ecx, ax
  01a8a	85 c9		 test	 ecx, ecx
  01a8c	75 47		 jne	 SHORT $LN29@Decoder_am
$LN28@Decoder_am:
  01a8e	6a 03		 push	 3
  01a90	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01a93	0f b7 88 d0 01
	00 00		 movzx	 ecx, WORD PTR [eax+464]
  01a9a	51		 push	 ecx
  01a9b	e8 00 00 00 00	 call	 _sub
  01aa0	83 c4 08	 add	 esp, 8
  01aa3	0f bf d0	 movsx	 edx, ax
  01aa6	85 d2		 test	 edx, edx
  01aa8	7e 2b		 jle	 SHORT $LN29@Decoder_am
  01aaa	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01aad	0f bf 88 ce 01
	00 00		 movsx	 ecx, WORD PTR [eax+462]
  01ab4	85 c9		 test	 ecx, ecx
  01ab6	74 1d		 je	 SHORT $LN29@Decoder_am
  01ab8	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01abf	85 c0		 test	 eax, eax
  01ac1	74 12		 je	 SHORT $LN29@Decoder_am

; 977  :         {
; 978  :            ph_disp_lock(st->ph_disp_st); /* Always Use full Phase Disp. */

  01ac3	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01ac6	8b 88 04 02 00
	00		 mov	 ecx, DWORD PTR [eax+516]
  01acc	51		 push	 ecx
  01acd	e8 00 00 00 00	 call	 _ph_disp_lock
  01ad2	83 c4 04	 add	 esp, 4
$LN29@Decoder_am:

; 979  :         }                                /* if error in bg noise       */
; 980  : 
; 981  :         /* apply phase dispersion to innovation (if enabled) and
; 982  :            compute total excitation for synthesis part           */
; 983  :         ph_disp(st->ph_disp_st, mode,
; 984  :                 exc_enhanced, gain_code_mix, gain_pit, code,
; 985  :                 pitch_fac, tmp_shift);       

  01ad5	0f b7 85 b0 fd
	ff ff		 movzx	 eax, WORD PTR _tmp_shift$[ebp]
  01adc	50		 push	 eax
  01add	0f b7 8d ec fd
	ff ff		 movzx	 ecx, WORD PTR _pitch_fac$[ebp]
  01ae4	51		 push	 ecx
  01ae5	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR _code$[ebp]
  01aeb	52		 push	 edx
  01aec	0f b7 85 28 fe
	ff ff		 movzx	 eax, WORD PTR _gain_pit$[ebp]
  01af3	50		 push	 eax
  01af4	0f b7 8d 10 fe
	ff ff		 movzx	 ecx, WORD PTR _gain_code_mix$[ebp]
  01afb	51		 push	 ecx
  01afc	8d 95 7c fe ff
	ff		 lea	 edx, DWORD PTR _exc_enhanced$[ebp]
  01b02	52		 push	 edx
  01b03	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  01b06	50		 push	 eax
  01b07	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01b0a	8b 91 04 02 00
	00		 mov	 edx, DWORD PTR [ecx+516]
  01b10	52		 push	 edx
  01b11	e8 00 00 00 00	 call	 _ph_disp
  01b16	83 c4 20	 add	 esp, 32			; 00000020H

; 986  :         
; 987  :         /*-------------------------------------------------------*
; 988  :          * - The Excitation control module are active during BFI.*
; 989  :          * - Conceal drops in signal energy if in bg noise.      *
; 990  :          *-------------------------------------------------------*/
; 991  : 
; 992  :         L_temp = 0;                                   move32 ();

  01b19	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _L_temp$[ebp], 0
  01b23	e8 00 00 00 00	 call	 _move32

; 993  :         for (i = 0; i < L_SUBFR; i++)

  01b28	33 c0		 xor	 eax, eax
  01b2a	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  01b31	eb 12		 jmp	 SHORT $LN27@Decoder_am
$LN26@Decoder_am:
  01b33	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01b3a	66 83 c0 01	 add	 ax, 1
  01b3e	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN27@Decoder_am:
  01b45	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01b4c	83 f8 28	 cmp	 eax, 40			; 00000028H
  01b4f	7d 37		 jge	 SHORT $LN25@Decoder_am

; 994  :         {
; 995  :             L_temp = L_mac (L_temp, exc_enhanced[i], exc_enhanced[i] );

  01b51	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01b58	0f b7 8c 45 7c
	fe ff ff	 movzx	 ecx, WORD PTR _exc_enhanced$[ebp+eax*2]
  01b60	51		 push	 ecx
  01b61	0f bf 95 70 fe
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  01b68	0f b7 84 55 7c
	fe ff ff	 movzx	 eax, WORD PTR _exc_enhanced$[ebp+edx*2]
  01b70	50		 push	 eax
  01b71	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _L_temp$[ebp]
  01b77	51		 push	 ecx
  01b78	e8 00 00 00 00	 call	 _L_mac
  01b7d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b80	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 996  :         }

  01b86	eb ab		 jmp	 SHORT $LN26@Decoder_am
$LN25@Decoder_am:

; 997  : 
; 998  :         L_temp = L_shr (L_temp, 1);     /* excEnergy = sqrt(L_temp) in Q0 */

  01b88	6a 01		 push	 1
  01b8a	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  01b90	50		 push	 eax
  01b91	e8 00 00 00 00	 call	 _L_shr
  01b96	83 c4 08	 add	 esp, 8
  01b99	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 999  :         L_temp = sqrt_l_exp(L_temp, &temp); move32 (); /* function result */

  01b9f	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  01ba5	50		 push	 eax
  01ba6	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _L_temp$[ebp]
  01bac	51		 push	 ecx
  01bad	e8 00 00 00 00	 call	 _sqrt_l_exp
  01bb2	83 c4 08	 add	 esp, 8
  01bb5	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax
  01bbb	e8 00 00 00 00	 call	 _move32

; 1000 :         L_temp = L_shr(L_temp, add( shr(temp, 1), 15));

  01bc0	6a 0f		 push	 15			; 0000000fH
  01bc2	6a 01		 push	 1
  01bc4	0f b7 85 a4 fd
	ff ff		 movzx	 eax, WORD PTR _temp$[ebp]
  01bcb	50		 push	 eax
  01bcc	e8 00 00 00 00	 call	 _shr
  01bd1	83 c4 08	 add	 esp, 8
  01bd4	0f b7 c8	 movzx	 ecx, ax
  01bd7	51		 push	 ecx
  01bd8	e8 00 00 00 00	 call	 _add
  01bdd	83 c4 08	 add	 esp, 8
  01be0	0f b7 d0	 movzx	 edx, ax
  01be3	52		 push	 edx
  01be4	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  01bea	50		 push	 eax
  01beb	e8 00 00 00 00	 call	 _L_shr
  01bf0	83 c4 08	 add	 esp, 8
  01bf3	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 1001 :         L_temp = L_shr(L_temp, 2);       /* To cope with 16-bit and  */

  01bf9	6a 02		 push	 2
  01bfb	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  01c01	50		 push	 eax
  01c02	e8 00 00 00 00	 call	 _L_shr
  01c07	83 c4 08	 add	 esp, 8
  01c0a	89 85 98 fd ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 1002 :         excEnergy = extract_l(L_temp);   /* scaling in ex_ctrl()     */

  01c10	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  01c16	50		 push	 eax
  01c17	e8 00 00 00 00	 call	 _extract_l
  01c1c	83 c4 04	 add	 esp, 4
  01c1f	66 89 85 74 fd
	ff ff		 mov	 WORD PTR _excEnergy$[ebp], ax

; 1003 : 
; 1004 :         test (); test (); test (); test (); test (); 

  01c26	e8 00 00 00 00	 call	 _test
  01c2b	e8 00 00 00 00	 call	 _test
  01c30	e8 00 00 00 00	 call	 _test
  01c35	e8 00 00 00 00	 call	 _test
  01c3a	e8 00 00 00 00	 call	 _test

; 1005 :         test (); test (); test (); test (); test ();

  01c3f	e8 00 00 00 00	 call	 _test
  01c44	e8 00 00 00 00	 call	 _test
  01c49	e8 00 00 00 00	 call	 _test
  01c4e	e8 00 00 00 00	 call	 _test
  01c53	e8 00 00 00 00	 call	 _test

; 1006 :         if ( ((sub (mode, MR475) == 0) ||
; 1007 :               (sub (mode, MR515) == 0) ||
; 1008 :               (sub (mode, MR59) == 0))  &&
; 1009 :              sub(st->voicedHangover, 5) > 0 &&
; 1010 :              st->inBackgroundNoise != 0 &&
; 1011 :              sub(st->state, 4) < 0 &&
; 1012 :              ( (pdfi != 0 && st->prev_pdf != 0) ||
; 1013 :                 bfi != 0 ||
; 1014 :                 st->prev_bf != 0) )

  01c58	6a 00		 push	 0
  01c5a	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01c5e	50		 push	 eax
  01c5f	e8 00 00 00 00	 call	 _sub
  01c64	83 c4 08	 add	 esp, 8
  01c67	0f bf c8	 movsx	 ecx, ax
  01c6a	85 c9		 test	 ecx, ecx
  01c6c	74 30		 je	 SHORT $LN23@Decoder_am
  01c6e	6a 01		 push	 1
  01c70	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01c74	50		 push	 eax
  01c75	e8 00 00 00 00	 call	 _sub
  01c7a	83 c4 08	 add	 esp, 8
  01c7d	0f bf c8	 movsx	 ecx, ax
  01c80	85 c9		 test	 ecx, ecx
  01c82	74 1a		 je	 SHORT $LN23@Decoder_am
  01c84	6a 02		 push	 2
  01c86	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  01c8a	50		 push	 eax
  01c8b	e8 00 00 00 00	 call	 _sub
  01c90	83 c4 08	 add	 esp, 8
  01c93	0f bf c8	 movsx	 ecx, ax
  01c96	85 c9		 test	 ecx, ecx
  01c98	0f 85 02 01 00
	00		 jne	 $LN24@Decoder_am
$LN23@Decoder_am:
  01c9e	6a 05		 push	 5
  01ca0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01ca3	0f b7 88 d0 01
	00 00		 movzx	 ecx, WORD PTR [eax+464]
  01caa	51		 push	 ecx
  01cab	e8 00 00 00 00	 call	 _sub
  01cb0	83 c4 08	 add	 esp, 8
  01cb3	0f bf d0	 movsx	 edx, ax
  01cb6	85 d2		 test	 edx, edx
  01cb8	0f 8e e2 00 00
	00		 jle	 $LN24@Decoder_am
  01cbe	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01cc1	0f bf 88 ce 01
	00 00		 movsx	 ecx, WORD PTR [eax+462]
  01cc8	85 c9		 test	 ecx, ecx
  01cca	0f 84 d0 00 00
	00		 je	 $LN24@Decoder_am
  01cd0	6a 04		 push	 4
  01cd2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01cd5	0f b7 88 b8 01
	00 00		 movzx	 ecx, WORD PTR [eax+440]
  01cdc	51		 push	 ecx
  01cdd	e8 00 00 00 00	 call	 _sub
  01ce2	83 c4 08	 add	 esp, 8
  01ce5	0f bf d0	 movsx	 edx, ax
  01ce8	85 d2		 test	 edx, edx
  01cea	0f 8d b0 00 00
	00		 jge	 $LN24@Decoder_am
  01cf0	0f bf 85 44 fd
	ff ff		 movsx	 eax, WORD PTR _pdfi$[ebp]
  01cf7	85 c0		 test	 eax, eax
  01cf9	74 0e		 je	 SHORT $LN21@Decoder_am
  01cfb	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01cfe	0f bf 88 b6 01
	00 00		 movsx	 ecx, WORD PTR [eax+438]
  01d05	85 c9		 test	 ecx, ecx
  01d07	75 19		 jne	 SHORT $LN22@Decoder_am
$LN21@Decoder_am:
  01d09	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01d10	85 c0		 test	 eax, eax
  01d12	75 0e		 jne	 SHORT $LN22@Decoder_am
  01d14	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01d17	0f bf 88 b4 01
	00 00		 movsx	 ecx, WORD PTR [eax+436]
  01d1e	85 c9		 test	 ecx, ecx
  01d20	74 7e		 je	 SHORT $LN24@Decoder_am
$LN22@Decoder_am:

; 1015 :         {
; 1016 :            carefulFlag = 0;                          move32 ();

  01d22	33 c0		 xor	 eax, eax
  01d24	66 89 85 80 fd
	ff ff		 mov	 WORD PTR _carefulFlag$[ebp], ax
  01d2b	e8 00 00 00 00	 call	 _move32

; 1017 :            test (); test ();           

  01d30	e8 00 00 00 00	 call	 _test
  01d35	e8 00 00 00 00	 call	 _test

; 1018 :            if ( pdfi != 0 && bfi == 0 )       

  01d3a	0f bf 85 44 fd
	ff ff		 movsx	 eax, WORD PTR _pdfi$[ebp]
  01d41	85 c0		 test	 eax, eax
  01d43	74 1c		 je	 SHORT $LN20@Decoder_am
  01d45	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01d4c	85 c0		 test	 eax, eax
  01d4e	75 11		 jne	 SHORT $LN20@Decoder_am

; 1019 :            {
; 1020 :               carefulFlag = 1;                       move16 ();

  01d50	b8 01 00 00 00	 mov	 eax, 1
  01d55	66 89 85 80 fd
	ff ff		 mov	 WORD PTR _carefulFlag$[ebp], ax
  01d5c	e8 00 00 00 00	 call	 _move16
$LN20@Decoder_am:

; 1021 :            }
; 1022 : 
; 1023 :            Ex_ctrl(exc_enhanced,     
; 1024 :                    excEnergy,
; 1025 :                    st->excEnergyHist,
; 1026 :                    st->voicedHangover,
; 1027 :                    st->prev_bf,
; 1028 :                    carefulFlag);

  01d61	0f b7 85 80 fd
	ff ff		 movzx	 eax, WORD PTR _carefulFlag$[ebp]
  01d68	50		 push	 eax
  01d69	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01d6c	0f b7 91 b4 01
	00 00		 movzx	 edx, WORD PTR [ecx+436]
  01d73	52		 push	 edx
  01d74	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01d77	0f b7 88 d0 01
	00 00		 movzx	 ecx, WORD PTR [eax+464]
  01d7e	51		 push	 ecx
  01d7f	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01d82	81 c2 ba 01 00
	00		 add	 edx, 442		; 000001baH
  01d88	52		 push	 edx
  01d89	0f b7 85 74 fd
	ff ff		 movzx	 eax, WORD PTR _excEnergy$[ebp]
  01d90	50		 push	 eax
  01d91	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  01d97	51		 push	 ecx
  01d98	e8 00 00 00 00	 call	 _Ex_ctrl
  01d9d	83 c4 18	 add	 esp, 24			; 00000018H
$LN24@Decoder_am:

; 1029 :         }
; 1030 : 
; 1031 :         test (); test (); test (); test ();

  01da0	e8 00 00 00 00	 call	 _test
  01da5	e8 00 00 00 00	 call	 _test
  01daa	e8 00 00 00 00	 call	 _test
  01daf	e8 00 00 00 00	 call	 _test

; 1032 :         if ( st->inBackgroundNoise != 0 &&
; 1033 :              ( bfi != 0 || st->prev_bf != 0 ) &&
; 1034 :              sub(st->state, 4) < 0 )

  01db4	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01db7	0f bf 88 ce 01
	00 00		 movsx	 ecx, WORD PTR [eax+462]
  01dbe	85 c9		 test	 ecx, ecx
  01dc0	74 37		 je	 SHORT $LN19@Decoder_am
  01dc2	0f bf 85 50 fd
	ff ff		 movsx	 eax, WORD PTR _bfi$[ebp]
  01dc9	85 c0		 test	 eax, eax
  01dcb	75 0e		 jne	 SHORT $LN18@Decoder_am
  01dcd	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01dd0	0f bf 88 b4 01
	00 00		 movsx	 ecx, WORD PTR [eax+436]
  01dd7	85 c9		 test	 ecx, ecx
  01dd9	74 1e		 je	 SHORT $LN19@Decoder_am
$LN18@Decoder_am:
  01ddb	6a 04		 push	 4
  01ddd	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01de0	0f b7 88 b8 01
	00 00		 movzx	 ecx, WORD PTR [eax+440]
  01de7	51		 push	 ecx
  01de8	e8 00 00 00 00	 call	 _sub
  01ded	83 c4 08	 add	 esp, 8
  01df0	0f bf d0	 movsx	 edx, ax
  01df3	85 d2		 test	 edx, edx
  01df5	7d 02		 jge	 SHORT $LN19@Decoder_am

; 1035 :         { 
; 1036 :            ; /* do nothing! */
; 1037 :         }
; 1038 :         else

  01df7	eb 73		 jmp	 SHORT $LN17@Decoder_am
$LN19@Decoder_am:

; 1039 :         {
; 1040 :            /* Update energy history for all modes */
; 1041 :            for (i = 0; i < 8; i++)

  01df9	33 c0		 xor	 eax, eax
  01dfb	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  01e02	eb 12		 jmp	 SHORT $LN16@Decoder_am
$LN15@Decoder_am:
  01e04	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01e0b	66 83 c0 01	 add	 ax, 1
  01e0f	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN16@Decoder_am:
  01e16	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01e1d	83 f8 08	 cmp	 eax, 8
  01e20	7d 2b		 jge	 SHORT $LN14@Decoder_am

; 1042 :            {
; 1043 :               st->excEnergyHist[i] = st->excEnergyHist[i+1]; move16 ();

  01e22	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01e29	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01e30	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01e33	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  01e36	66 8b 84 46 bc
	01 00 00	 mov	 ax, WORD PTR [esi+eax*2+444]
  01e3e	66 89 84 4a ba
	01 00 00	 mov	 WORD PTR [edx+ecx*2+442], ax
  01e46	e8 00 00 00 00	 call	 _move16

; 1044 :            }

  01e4b	eb b7		 jmp	 SHORT $LN15@Decoder_am
$LN14@Decoder_am:

; 1045 :            st->excEnergyHist[8] = excEnergy;   move16 ();

  01e4d	b8 02 00 00 00	 mov	 eax, 2
  01e52	c1 e0 03	 shl	 eax, 3
  01e55	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01e58	66 8b 95 74 fd
	ff ff		 mov	 dx, WORD PTR _excEnergy$[ebp]
  01e5f	66 89 94 01 ba
	01 00 00	 mov	 WORD PTR [ecx+eax+442], dx
  01e67	e8 00 00 00 00	 call	 _move16
$LN17@Decoder_am:

; 1046 :         }
; 1047 :         /*-------------------------------------------------------*
; 1048 :          * Excitation control module end.                        *
; 1049 :          *-------------------------------------------------------*/
; 1050 :         
; 1051 :         fwc ();                 /* function worst case */

  01e6c	e8 00 00 00 00	 call	 _fwc

; 1052 : 
; 1053 :         test (); 

  01e71	e8 00 00 00 00	 call	 _test

; 1054 :         if (sub (pit_sharp, 16384) > 0)

  01e76	68 00 40 00 00	 push	 16384			; 00004000H
  01e7b	0f b7 85 04 fe
	ff ff		 movzx	 eax, WORD PTR _pit_sharp$[ebp]
  01e82	50		 push	 eax
  01e83	e8 00 00 00 00	 call	 _sub
  01e88	83 c4 08	 add	 esp, 8
  01e8b	0f bf c8	 movsx	 ecx, ax
  01e8e	85 c9		 test	 ecx, ecx
  01e90	0f 8e be 00 00
	00		 jle	 $LN13@Decoder_am

; 1055 :         {
; 1056 :            for (i = 0; i < L_SUBFR; i++)

  01e96	33 c0		 xor	 eax, eax
  01e98	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  01e9f	eb 12		 jmp	 SHORT $LN12@Decoder_am
$LN11@Decoder_am:
  01ea1	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01ea8	66 83 c0 01	 add	 ax, 1
  01eac	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN12@Decoder_am:
  01eb3	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01eba	83 f8 28	 cmp	 eax, 40			; 00000028H
  01ebd	7d 3e		 jge	 SHORT $LN10@Decoder_am

; 1057 :            {
; 1058 :               excp[i] = add (excp[i], exc_enhanced[i]);              

  01ebf	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01ec6	0f b7 8c 45 7c
	fe ff ff	 movzx	 ecx, WORD PTR _exc_enhanced$[ebp+eax*2]
  01ece	51		 push	 ecx
  01ecf	0f bf 95 70 fe
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  01ed6	0f b7 84 55 d4
	fe ff ff	 movzx	 eax, WORD PTR _excp$[ebp+edx*2]
  01ede	50		 push	 eax
  01edf	e8 00 00 00 00	 call	 _add
  01ee4	83 c4 08	 add	 esp, 8
  01ee7	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01eee	66 89 84 4d d4
	fe ff ff	 mov	 WORD PTR _excp$[ebp+ecx*2], ax

; 1059 :               move16 (); 

  01ef6	e8 00 00 00 00	 call	 _move16

; 1060 :            }

  01efb	eb a4		 jmp	 SHORT $LN11@Decoder_am
$LN10@Decoder_am:

; 1061 :            agc2 (exc_enhanced, excp, L_SUBFR);

  01efd	6a 28		 push	 40			; 00000028H
  01eff	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _excp$[ebp]
  01f05	50		 push	 eax
  01f06	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  01f0c	51		 push	 ecx
  01f0d	e8 00 00 00 00	 call	 _agc2
  01f12	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 :            Overflow = 0;                 move16 ();

  01f15	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0
  01f1f	e8 00 00 00 00	 call	 _move16

; 1063 :            Syn_filt (Az, excp, &synth[i_subfr], L_SUBFR,
; 1064 :                      st->mem_syn, 0);

  01f24	6a 00		 push	 0
  01f26	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01f29	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  01f2e	50		 push	 eax
  01f2f	6a 28		 push	 40			; 00000028H
  01f31	0f bf 8d 64 fe
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  01f38	8b 55 18	 mov	 edx, DWORD PTR _synth$[ebp]
  01f3b	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  01f3e	50		 push	 eax
  01f3f	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _excp$[ebp]
  01f45	51		 push	 ecx
  01f46	8b 55 f4	 mov	 edx, DWORD PTR _Az$[ebp]
  01f49	52		 push	 edx
  01f4a	e8 00 00 00 00	 call	 _Syn_filt
  01f4f	83 c4 18	 add	 esp, 24			; 00000018H

; 1065 :         }
; 1066 :         else

  01f52	eb 3d		 jmp	 SHORT $LN9@Decoder_am
$LN13@Decoder_am:

; 1067 :         {
; 1068 :            Overflow = 0;                 move16 ();

  01f54	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0
  01f5e	e8 00 00 00 00	 call	 _move16

; 1069 :            Syn_filt (Az, exc_enhanced, &synth[i_subfr], L_SUBFR,
; 1070 :                      st->mem_syn, 0);

  01f63	6a 00		 push	 0
  01f65	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  01f68	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  01f6d	50		 push	 eax
  01f6e	6a 28		 push	 40			; 00000028H
  01f70	0f bf 8d 64 fe
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  01f77	8b 55 18	 mov	 edx, DWORD PTR _synth$[ebp]
  01f7a	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  01f7d	50		 push	 eax
  01f7e	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  01f84	51		 push	 ecx
  01f85	8b 55 f4	 mov	 edx, DWORD PTR _Az$[ebp]
  01f88	52		 push	 edx
  01f89	e8 00 00 00 00	 call	 _Syn_filt
  01f8e	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@Decoder_am:

; 1071 :         }
; 1072 : 
; 1073 :         test ();

  01f91	e8 00 00 00 00	 call	 _test

; 1074 :         if (Overflow != 0)    /* Test for overflow */

  01f96	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Overflow, 0
  01f9d	0f 84 e2 00 00
	00		 je	 $LN8@Decoder_am

; 1075 :         {
; 1076 :            for (i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++)

  01fa3	33 c0		 xor	 eax, eax
  01fa5	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  01fac	eb 12		 jmp	 SHORT $LN7@Decoder_am
$LN6@Decoder_am:
  01fae	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01fb5	66 83 c0 01	 add	 ax, 1
  01fb9	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@Decoder_am:
  01fc0	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01fc7	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  01fcc	7d 2e		 jge	 SHORT $LN5@Decoder_am

; 1077 :            {
; 1078 :               st->old_exc[i] = shr(st->old_exc[i], 2);       move16 ();

  01fce	6a 02		 push	 2
  01fd0	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01fd7	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  01fda	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  01fde	52		 push	 edx
  01fdf	e8 00 00 00 00	 call	 _shr
  01fe4	83 c4 08	 add	 esp, 8
  01fe7	0f bf 8d 70 fe
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01fee	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  01ff1	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  01ff5	e8 00 00 00 00	 call	 _move16

; 1079 :            }

  01ffa	eb b2		 jmp	 SHORT $LN6@Decoder_am
$LN5@Decoder_am:

; 1080 :            for (i = 0; i < L_SUBFR; i++)

  01ffc	33 c0		 xor	 eax, eax
  01ffe	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  02005	eb 12		 jmp	 SHORT $LN4@Decoder_am
$LN3@Decoder_am:
  02007	66 8b 85 70 fe
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  0200e	66 83 c0 01	 add	 ax, 1
  02012	66 89 85 70 fe
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN4@Decoder_am:
  02019	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  02020	83 f8 28	 cmp	 eax, 40			; 00000028H
  02023	7d 30		 jge	 SHORT $LN2@Decoder_am

; 1081 :            {
; 1082 :               exc_enhanced[i] = shr(exc_enhanced[i], 2);     move16 ();

  02025	6a 02		 push	 2
  02027	0f bf 85 70 fe
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0202e	0f b7 8c 45 7c
	fe ff ff	 movzx	 ecx, WORD PTR _exc_enhanced$[ebp+eax*2]
  02036	51		 push	 ecx
  02037	e8 00 00 00 00	 call	 _shr
  0203c	83 c4 08	 add	 esp, 8
  0203f	0f bf 95 70 fe
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  02046	66 89 84 55 7c
	fe ff ff	 mov	 WORD PTR _exc_enhanced$[ebp+edx*2], ax
  0204e	e8 00 00 00 00	 call	 _move16

; 1083 :            }

  02053	eb b2		 jmp	 SHORT $LN3@Decoder_am
$LN2@Decoder_am:

; 1084 :            Syn_filt(Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1);

  02055	6a 01		 push	 1
  02057	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0205a	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  0205f	50		 push	 eax
  02060	6a 28		 push	 40			; 00000028H
  02062	0f bf 8d 64 fe
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  02069	8b 55 18	 mov	 edx, DWORD PTR _synth$[ebp]
  0206c	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0206f	50		 push	 eax
  02070	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  02076	51		 push	 ecx
  02077	8b 55 f4	 mov	 edx, DWORD PTR _Az$[ebp]
  0207a	52		 push	 edx
  0207b	e8 00 00 00 00	 call	 _Syn_filt
  02080	83 c4 18	 add	 esp, 24			; 00000018H

; 1085 :         }
; 1086 :         else

  02083	eb 22		 jmp	 SHORT $LN1@Decoder_am
$LN8@Decoder_am:

; 1087 :         {
; 1088 :            Copy(&synth[i_subfr+L_SUBFR-M], st->mem_syn, M);

  02085	6a 0a		 push	 10			; 0000000aH
  02087	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0208a	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  0208f	50		 push	 eax
  02090	0f bf 8d 64 fe
	ff ff		 movsx	 ecx, WORD PTR _i_subfr$[ebp]
  02097	8b 55 18	 mov	 edx, DWORD PTR _synth$[ebp]
  0209a	8d 44 4a 3c	 lea	 eax, DWORD PTR [edx+ecx*2+60]
  0209e	50		 push	 eax
  0209f	e8 00 00 00 00	 call	 _Copy
  020a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Decoder_am:

; 1089 :         }
; 1090 :         
; 1091 :         /*--------------------------------------------------*
; 1092 :          * Update signal for next frame.                    *
; 1093 :          * -> shift to the left by L_SUBFR  st->exc[]       *
; 1094 :          *--------------------------------------------------*/
; 1095 :         
; 1096 :         Copy (&st->old_exc[L_SUBFR], &st->old_exc[0], PIT_MAX + L_INTERPOL);

  020a7	68 9a 00 00 00	 push	 154			; 0000009aH
  020ac	b8 02 00 00 00	 mov	 eax, 2
  020b1	6b c8 00	 imul	 ecx, eax, 0
  020b4	03 4d 08	 add	 ecx, DWORD PTR _st$[ebp]
  020b7	51		 push	 ecx
  020b8	ba 02 00 00 00	 mov	 edx, 2
  020bd	6b c2 28	 imul	 eax, edx, 40
  020c0	03 45 08	 add	 eax, DWORD PTR _st$[ebp]
  020c3	50		 push	 eax
  020c4	e8 00 00 00 00	 call	 _Copy
  020c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1097 : 
; 1098 :         fwc ();                 /* function worst case */

  020cc	e8 00 00 00 00	 call	 _fwc

; 1099 : 
; 1100 :         /* interpolated LPC parameters for next subframe */
; 1101 :         Az += MP1;                      move16 ();

  020d1	8b 45 f4	 mov	 eax, DWORD PTR _Az$[ebp]
  020d4	83 c0 16	 add	 eax, 22			; 00000016H
  020d7	89 45 f4	 mov	 DWORD PTR _Az$[ebp], eax
  020da	e8 00 00 00 00	 call	 _move16

; 1102 :         
; 1103 :         /* store T0 for next subframe */ 
; 1104 :         st->old_T0 = T0;                move16 ();

  020df	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  020e2	66 8b 8d 58 fe
	ff ff		 mov	 cx, WORD PTR _T0$[ebp]
  020e9	66 89 88 b2 01
	00 00		 mov	 WORD PTR [eax+434], cx
  020f0	e8 00 00 00 00	 call	 _move16

; 1105 :     }

  020f5	e9 cf e3 ff ff	 jmp	 $LN108@Decoder_am
$LN107@Decoder_am:

; 1106 :     
; 1107 :     /*-------------------------------------------------------*
; 1108 :      * Call the Source Characteristic Detector which updates *
; 1109 :      * st->inBackgroundNoise and st->voicedHangover.         *
; 1110 :      *-------------------------------------------------------*/
; 1111 : 
; 1112 :                             move16 (); /* function result */

  020fa	e8 00 00 00 00	 call	 _move16

; 1113 :     st->inBackgroundNoise = Bgn_scd(st->background_state,
; 1114 :                                     &(st->ltpGainHistory[0]),
; 1115 :                                     &(synth[0]),
; 1116 :                                     &(st->voicedHangover) );

  020ff	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  02102	05 d0 01 00 00	 add	 eax, 464		; 000001d0H
  02107	50		 push	 eax
  02108	b9 02 00 00 00	 mov	 ecx, 2
  0210d	6b d1 00	 imul	 edx, ecx, 0
  02110	03 55 18	 add	 edx, DWORD PTR _synth$[ebp]
  02113	52		 push	 edx
  02114	b8 02 00 00 00	 mov	 eax, 2
  02119	6b c8 00	 imul	 ecx, eax, 0
  0211c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0211f	8d 84 0a d2 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+466]
  02126	50		 push	 eax
  02127	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0212a	8b 91 e4 01 00
	00		 mov	 edx, DWORD PTR [ecx+484]
  02130	52		 push	 edx
  02131	e8 00 00 00 00	 call	 _Bgn_scd
  02136	83 c4 10	 add	 esp, 16			; 00000010H
  02139	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0213c	66 89 81 ce 01
	00 00		 mov	 WORD PTR [ecx+462], ax

; 1117 : 
; 1118 :     dtx_dec_activity_update(st->dtxDecoderState, 
; 1119 :                             st->lsfState->past_lsf_q, 
; 1120 :                             synth);

  02143	8b 45 18	 mov	 eax, DWORD PTR _synth$[ebp]
  02146	50		 push	 eax
  02147	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0214a	8b 91 f4 01 00
	00		 mov	 edx, DWORD PTR [ecx+500]
  02150	83 c2 14	 add	 edx, 20			; 00000014H
  02153	52		 push	 edx
  02154	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  02157	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  0215d	51		 push	 ecx
  0215e	e8 00 00 00 00	 call	 _dtx_dec_activity_update
  02163	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1121 :     
; 1122 :     fwc ();                     /* function worst case */

  02166	e8 00 00 00 00	 call	 _fwc

; 1123 : 
; 1124 :     /* store bfi for next subframe */
; 1125 :     st->prev_bf = bfi;                  move16 (); 

  0216b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0216e	66 8b 8d 50 fd
	ff ff		 mov	 cx, WORD PTR _bfi$[ebp]
  02175	66 89 88 b4 01
	00 00		 mov	 WORD PTR [eax+436], cx
  0217c	e8 00 00 00 00	 call	 _move16

; 1126 :     st->prev_pdf = pdfi;                move16 (); 

  02181	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  02184	66 8b 8d 44 fd
	ff ff		 mov	 cx, WORD PTR _pdfi$[ebp]
  0218b	66 89 88 b6 01
	00 00		 mov	 WORD PTR [eax+438], cx
  02192	e8 00 00 00 00	 call	 _move16

; 1127 :     
; 1128 :     /*--------------------------------------------------*
; 1129 :      * Calculate the LSF averages on the eight          *
; 1130 :      * previous frames                                  *
; 1131 :      *--------------------------------------------------*/
; 1132 :     
; 1133 :     lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);

  02197	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0219a	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR [eax+500]
  021a0	83 c1 14	 add	 ecx, 20			; 00000014H
  021a3	51		 push	 ecx
  021a4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  021a7	8b 82 f0 01 00
	00		 mov	 eax, DWORD PTR [edx+496]
  021ad	50		 push	 eax
  021ae	e8 00 00 00 00	 call	 _lsp_avg
  021b3	83 c4 08	 add	 esp, 8

; 1134 :     fwc ();                 /* function worst case */

  021b6	e8 00 00 00 00	 call	 _fwc
$the_end$148:

; 1135 : 
; 1136 : the_end:
; 1137 :     st->dtxDecoderState->dtxGlobalState = newDTXState;  move16();

  021bb	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  021be	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  021c4	8b 95 38 fd ff
	ff		 mov	 edx, DWORD PTR _newDTXState$[ebp]
  021ca	89 91 98 01 00
	00		 mov	 DWORD PTR [ecx+408], edx
  021d0	e8 00 00 00 00	 call	 _move16

; 1138 :     
; 1139 :     return 0;

  021d5	33 c0		 xor	 eax, eax

; 1140 : }

  021d7	52		 push	 edx
  021d8	8b cd		 mov	 ecx, ebp
  021da	50		 push	 eax
  021db	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN147@Decoder_am
  021e1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  021e6	58		 pop	 eax
  021e7	5a		 pop	 edx
  021e8	5f		 pop	 edi
  021e9	5e		 pop	 esi
  021ea	5b		 pop	 ebx
  021eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  021ee	33 cd		 xor	 ecx, ebp
  021f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  021f5	81 c4 90 03 00
	00		 add	 esp, 912		; 00000390H
  021fb	3b ec		 cmp	 ebp, esp
  021fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02202	8b e5		 mov	 esp, ebp
  02204	5d		 pop	 ebp
  02205	c3		 ret	 0
  02206	8b ff		 npad	 2
$LN147@Decoder_am:
  02208	0c 00 00 00	 DD	 12			; 0000000cH
  0220c	00 00 00 00	 DD	 $LN146@Decoder_am
$LN146@Decoder_am:
  02210	d8 ff ff ff	 DD	 -40			; ffffffd8H
  02214	14 00 00 00	 DD	 20			; 00000014H
  02218	00 00 00 00	 DD	 $LN134@Decoder_am
  0221c	bc ff ff ff	 DD	 -68			; ffffffbcH
  02220	14 00 00 00	 DD	 20			; 00000014H
  02224	00 00 00 00	 DD	 $LN135@Decoder_am
  02228	a0 ff ff ff	 DD	 -96			; ffffffa0H
  0222c	14 00 00 00	 DD	 20			; 00000014H
  02230	00 00 00 00	 DD	 $LN136@Decoder_am
  02234	84 ff ff ff	 DD	 -124			; ffffff84H
  02238	14 00 00 00	 DD	 20			; 00000014H
  0223c	00 00 00 00	 DD	 $LN137@Decoder_am
  02240	2c ff ff ff	 DD	 -212			; ffffff2cH
  02244	50 00 00 00	 DD	 80			; 00000050H
  02248	00 00 00 00	 DD	 $LN138@Decoder_am
  0224c	d4 fe ff ff	 DD	 -300			; fffffed4H
  02250	50 00 00 00	 DD	 80			; 00000050H
  02254	00 00 00 00	 DD	 $LN139@Decoder_am
  02258	7c fe ff ff	 DD	 -388			; fffffe7cH
  0225c	50 00 00 00	 DD	 80			; 00000050H
  02260	00 00 00 00	 DD	 $LN140@Decoder_am
  02264	58 fe ff ff	 DD	 -424			; fffffe58H
  02268	02 00 00 00	 DD	 2
  0226c	00 00 00 00	 DD	 $LN141@Decoder_am
  02270	4c fe ff ff	 DD	 -436			; fffffe4cH
  02274	02 00 00 00	 DD	 2
  02278	00 00 00 00	 DD	 $LN142@Decoder_am
  0227c	28 fe ff ff	 DD	 -472			; fffffe28H
  02280	02 00 00 00	 DD	 2
  02284	00 00 00 00	 DD	 $LN143@Decoder_am
  02288	1c fe ff ff	 DD	 -484			; fffffe1cH
  0228c	02 00 00 00	 DD	 2
  02290	00 00 00 00	 DD	 $LN144@Decoder_am
  02294	a4 fd ff ff	 DD	 -604			; fffffda4H
  02298	02 00 00 00	 DD	 2
  0229c	00 00 00 00	 DD	 $LN145@Decoder_am
$LN145@Decoder_am:
  022a0	74		 DB	 116			; 00000074H
  022a1	65		 DB	 101			; 00000065H
  022a2	6d		 DB	 109			; 0000006dH
  022a3	70		 DB	 112			; 00000070H
  022a4	00		 DB	 0
$LN144@Decoder_am:
  022a5	67		 DB	 103			; 00000067H
  022a6	61		 DB	 97			; 00000061H
  022a7	69		 DB	 105			; 00000069H
  022a8	6e		 DB	 110			; 0000006eH
  022a9	5f		 DB	 95			; 0000005fH
  022aa	63		 DB	 99			; 00000063H
  022ab	6f		 DB	 111			; 0000006fH
  022ac	64		 DB	 100			; 00000064H
  022ad	65		 DB	 101			; 00000065H
  022ae	00		 DB	 0
$LN143@Decoder_am:
  022af	67		 DB	 103			; 00000067H
  022b0	61		 DB	 97			; 00000061H
  022b1	69		 DB	 105			; 00000069H
  022b2	6e		 DB	 110			; 0000006eH
  022b3	5f		 DB	 95			; 0000005fH
  022b4	70		 DB	 112			; 00000070H
  022b5	69		 DB	 105			; 00000069H
  022b6	74		 DB	 116			; 00000074H
  022b7	00		 DB	 0
$LN142@Decoder_am:
  022b8	54		 DB	 84			; 00000054H
  022b9	30		 DB	 48			; 00000030H
  022ba	5f		 DB	 95			; 0000005fH
  022bb	66		 DB	 102			; 00000066H
  022bc	72		 DB	 114			; 00000072H
  022bd	61		 DB	 97			; 00000061H
  022be	63		 DB	 99			; 00000063H
  022bf	00		 DB	 0
$LN141@Decoder_am:
  022c0	54		 DB	 84			; 00000054H
  022c1	30		 DB	 48			; 00000030H
  022c2	00		 DB	 0
$LN140@Decoder_am:
  022c3	65		 DB	 101			; 00000065H
  022c4	78		 DB	 120			; 00000078H
  022c5	63		 DB	 99			; 00000063H
  022c6	5f		 DB	 95			; 0000005fH
  022c7	65		 DB	 101			; 00000065H
  022c8	6e		 DB	 110			; 0000006eH
  022c9	68		 DB	 104			; 00000068H
  022ca	61		 DB	 97			; 00000061H
  022cb	6e		 DB	 110			; 0000006eH
  022cc	63		 DB	 99			; 00000063H
  022cd	65		 DB	 101			; 00000065H
  022ce	64		 DB	 100			; 00000064H
  022cf	00		 DB	 0
$LN139@Decoder_am:
  022d0	65		 DB	 101			; 00000065H
  022d1	78		 DB	 120			; 00000078H
  022d2	63		 DB	 99			; 00000063H
  022d3	70		 DB	 112			; 00000070H
  022d4	00		 DB	 0
$LN138@Decoder_am:
  022d5	63		 DB	 99			; 00000063H
  022d6	6f		 DB	 111			; 0000006fH
  022d7	64		 DB	 100			; 00000064H
  022d8	65		 DB	 101			; 00000065H
  022d9	00		 DB	 0
$LN137@Decoder_am:
  022da	6c		 DB	 108			; 0000006cH
  022db	73		 DB	 115			; 00000073H
  022dc	66		 DB	 102			; 00000066H
  022dd	5f		 DB	 95			; 0000005fH
  022de	69		 DB	 105			; 00000069H
  022df	00		 DB	 0
$LN136@Decoder_am:
  022e0	70		 DB	 112			; 00000070H
  022e1	72		 DB	 114			; 00000072H
  022e2	65		 DB	 101			; 00000065H
  022e3	76		 DB	 118			; 00000076H
  022e4	5f		 DB	 95			; 0000005fH
  022e5	6c		 DB	 108			; 0000006cH
  022e6	73		 DB	 115			; 00000073H
  022e7	66		 DB	 102			; 00000066H
  022e8	00		 DB	 0
$LN135@Decoder_am:
  022e9	6c		 DB	 108			; 0000006cH
  022ea	73		 DB	 115			; 00000073H
  022eb	70		 DB	 112			; 00000070H
  022ec	5f		 DB	 95			; 0000005fH
  022ed	6d		 DB	 109			; 0000006dH
  022ee	69		 DB	 105			; 00000069H
  022ef	64		 DB	 100			; 00000064H
  022f0	00		 DB	 0
$LN134@Decoder_am:
  022f1	6c		 DB	 108			; 0000006cH
  022f2	73		 DB	 115			; 00000073H
  022f3	70		 DB	 112			; 00000070H
  022f4	5f		 DB	 95			; 0000005fH
  022f5	6e		 DB	 110			; 0000006eH
  022f6	65		 DB	 101			; 00000065H
  022f7	77		 DB	 119			; 00000077H
  022f8	00		 DB	 0
_Decoder_amr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Decoder_amr_exit PROC					; COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 226  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Decoder_am
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 05		 jne	 SHORT $LN2@Decoder_am
$LN1@Decoder_am:

; 227  :       return;

  0002c	e9 d5 00 00 00	 jmp	 $LN3@Decoder_am
$LN2@Decoder_am:

; 228  :  
; 229  :   D_plsf_exit(&(*state)->lsfState);

  00031	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	81 c1 f4 01 00
	00		 add	 ecx, 500		; 000001f4H
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _D_plsf_exit
  00042	83 c4 04	 add	 esp, 4

; 230  :   ec_gain_pitch_exit(&(*state)->ec_gain_p_st);

  00045	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _ec_gain_pitch_exit
  00056	83 c4 04	 add	 esp, 4

; 231  :   ec_gain_code_exit(&(*state)->ec_gain_c_st);

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	81 c1 fc 01 00
	00		 add	 ecx, 508		; 000001fcH
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _ec_gain_code_exit
  0006a	83 c4 04	 add	 esp, 4

; 232  :   gc_pred_exit(&(*state)->pred_state);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _gc_pred_exit
  0007e	83 c4 04	 add	 esp, 4

; 233  :   Bgn_scd_exit(&(*state)->background_state);

  00081	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	81 c1 e4 01 00
	00		 add	 ecx, 484		; 000001e4H
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _Bgn_scd_exit
  00092	83 c4 04	 add	 esp, 4

; 234  :   ph_disp_exit(&(*state)->ph_disp_st);

  00095	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	81 c1 04 02 00
	00		 add	 ecx, 516		; 00000204H
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _ph_disp_exit
  000a6	83 c4 04	 add	 esp, 4

; 235  :   Cb_gain_average_exit(&(*state)->Cb_gain_averState);

  000a9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	81 c1 ec 01 00
	00		 add	 ecx, 492		; 000001ecH
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _Cb_gain_average_exit
  000ba	83 c4 04	 add	 esp, 4

; 236  :   lsp_avg_exit(&(*state)->lsp_avg_st);

  000bd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	81 c1 f0 01 00
	00		 add	 ecx, 496		; 000001f0H
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 _lsp_avg_exit
  000ce	83 c4 04	 add	 esp, 4

; 237  :   dtx_dec_exit(&(*state)->dtxDecoderState);

  000d1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	81 c1 08 02 00
	00		 add	 ecx, 520		; 00000208H
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _dtx_dec_exit
  000e2	83 c4 04	 add	 esp, 4

; 238  :   
; 239  :   /* deallocate memory */
; 240  :   free(*state);

  000e5	8b f4		 mov	 esi, esp
  000e7	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ec	51		 push	 ecx
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f3	83 c4 04	 add	 esp, 4
  000f6	3b f4		 cmp	 esi, esp
  000f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 241  :   *state = NULL;

  000fd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00100	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Decoder_am:

; 242  :   
; 243  :   return;
; 244  : }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0010f	3b ec		 cmp	 ebp, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
_Decoder_amr_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_mode$ = 12						; size = 4
_Decoder_amr_reset PROC					; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 155  :   Word16 i;
; 156  : 
; 157  :   if (state == (Decoder_amrState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN13@Decoder_am

; 158  :       fprintf(stderr, "Decoder_amr_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 159  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 f4 01 00 00	 jmp	 $LN14@Decoder_am
$LN13@Decoder_am:

; 160  :   }
; 161  :   
; 162  :   /* Initialize static pointer */
; 163  :   state->exc = state->old_exc + PIT_MAX + L_INTERPOL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	05 34 01 00 00	 add	 eax, 308		; 00000134H
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	89 81 84 01 00
	00		 mov	 DWORD PTR [ecx+388], eax

; 164  : 
; 165  :   /* Static vectors to zero */
; 166  :   Set_zero (state->old_exc, PIT_MAX + L_INTERPOL);

  0006d	68 9a 00 00 00	 push	 154			; 0000009aH
  00072	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _Set_zero
  0007b	83 c4 08	 add	 esp, 8

; 167  : 
; 168  :   if (mode != MRDTX)

  0007e	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  00082	74 13		 je	 SHORT $LN12@Decoder_am

; 169  :      Set_zero (state->mem_syn, M);

  00084	6a 0a		 push	 10			; 0000000aH
  00086	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00089	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _Set_zero
  00094	83 c4 08	 add	 esp, 8
$LN12@Decoder_am:

; 170  : 
; 171  :   /* initialize pitch sharpening */
; 172  :   state->sharp = SHARPMIN;

  00097	33 c0		 xor	 eax, eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0009c	66 89 81 b0 01
	00 00		 mov	 WORD PTR [ecx+432], ax

; 173  :   state->old_T0 = 40;

  000a3	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ab	66 89 81 b2 01
	00 00		 mov	 WORD PTR [ecx+434], ax

; 174  :      
; 175  :   /* Initialize state->lsp_old [] */ 
; 176  : 
; 177  :   if (mode != MRDTX) {

  000b2	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  000b6	74 22		 je	 SHORT $LN11@Decoder_am

; 178  :       Copy(lsp_init_data, &state->lsp_old[0], M);

  000b8	6a 0a		 push	 10			; 0000000aH
  000ba	b8 02 00 00 00	 mov	 eax, 2
  000bf	6b c8 00	 imul	 ecx, eax, 0
  000c2	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c5	8d 84 0a 88 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+392]
  000cc	50		 push	 eax
  000cd	68 00 00 00 00	 push	 OFFSET _lsp_init_data
  000d2	e8 00 00 00 00	 call	 _Copy
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@Decoder_am:

; 179  :   }
; 180  : 
; 181  :   /* Initialize memories of bad frame handling */
; 182  :   state->prev_bf = 0;

  000da	33 c0		 xor	 eax, eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000df	66 89 81 b4 01
	00 00		 mov	 WORD PTR [ecx+436], ax

; 183  :   state->prev_pdf = 0;

  000e6	33 c0		 xor	 eax, eax
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000eb	66 89 81 b6 01
	00 00		 mov	 WORD PTR [ecx+438], ax

; 184  :   state->state = 0;

  000f2	33 c0		 xor	 eax, eax
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000f7	66 89 81 b8 01
	00 00		 mov	 WORD PTR [ecx+440], ax

; 185  :   
; 186  :   state->T0_lagBuff = 40;

  000fe	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00106	66 89 81 cc 01
	00 00		 mov	 WORD PTR [ecx+460], ax

; 187  :   state->inBackgroundNoise = 0;

  0010d	33 c0		 xor	 eax, eax
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00112	66 89 81 ce 01
	00 00		 mov	 WORD PTR [ecx+462], ax

; 188  :   state->voicedHangover = 0;

  00119	33 c0		 xor	 eax, eax
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0011e	66 89 81 d0 01
	00 00		 mov	 WORD PTR [ecx+464], ax

; 189  :   if (mode != MRDTX) {

  00125	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  00129	74 30		 je	 SHORT $LN10@Decoder_am

; 190  :       for (i=0;i<9;i++)

  0012b	33 c0		 xor	 eax, eax
  0012d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00131	eb 0c		 jmp	 SHORT $LN9@Decoder_am
$LN8@Decoder_am:
  00133	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00137	66 83 c0 01	 add	 ax, 1
  0013b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN9@Decoder_am:
  0013f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00143	83 f8 09	 cmp	 eax, 9
  00146	7d 13		 jge	 SHORT $LN10@Decoder_am

; 191  :           state->excEnergyHist[i] = 0;

  00148	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0014c	33 c9		 xor	 ecx, ecx
  0014e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00151	66 89 8c 42 ba
	01 00 00	 mov	 WORD PTR [edx+eax*2+442], cx
  00159	eb d8		 jmp	 SHORT $LN8@Decoder_am
$LN10@Decoder_am:

; 192  :   }
; 193  :   
; 194  :   for (i = 0; i < 9; i++)

  0015b	33 c0		 xor	 eax, eax
  0015d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00161	eb 0c		 jmp	 SHORT $LN6@Decoder_am
$LN5@Decoder_am:
  00163	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00167	66 83 c0 01	 add	 ax, 1
  0016b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN6@Decoder_am:
  0016f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00173	83 f8 09	 cmp	 eax, 9
  00176	7d 13		 jge	 SHORT $LN4@Decoder_am

; 195  :      state->ltpGainHistory[i] = 0;

  00178	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0017c	33 c9		 xor	 ecx, ecx
  0017e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00181	66 89 8c 42 d2
	01 00 00	 mov	 WORD PTR [edx+eax*2+466], cx
  00189	eb d8		 jmp	 SHORT $LN5@Decoder_am
$LN4@Decoder_am:

; 196  : 
; 197  :   Cb_gain_average_reset(state->Cb_gain_averState);

  0018b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0018e	8b 88 ec 01 00
	00		 mov	 ecx, DWORD PTR [eax+492]
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 _Cb_gain_average_reset
  0019a	83 c4 04	 add	 esp, 4

; 198  :   if (mode != MRDTX)

  0019d	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  001a1	74 12		 je	 SHORT $LN3@Decoder_am

; 199  :      lsp_avg_reset(state->lsp_avg_st);

  001a3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001a6	8b 88 f0 01 00
	00		 mov	 ecx, DWORD PTR [eax+496]
  001ac	51		 push	 ecx
  001ad	e8 00 00 00 00	 call	 _lsp_avg_reset
  001b2	83 c4 04	 add	 esp, 4
$LN3@Decoder_am:

; 200  :   D_plsf_reset(state->lsfState);

  001b5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001b8	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR [eax+500]
  001be	51		 push	 ecx
  001bf	e8 00 00 00 00	 call	 _D_plsf_reset
  001c4	83 c4 04	 add	 esp, 4

; 201  :   ec_gain_pitch_reset(state->ec_gain_p_st);

  001c7	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001ca	8b 88 f8 01 00
	00		 mov	 ecx, DWORD PTR [eax+504]
  001d0	51		 push	 ecx
  001d1	e8 00 00 00 00	 call	 _ec_gain_pitch_reset
  001d6	83 c4 04	 add	 esp, 4

; 202  :   ec_gain_code_reset(state->ec_gain_c_st);

  001d9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001dc	8b 88 fc 01 00
	00		 mov	 ecx, DWORD PTR [eax+508]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 _ec_gain_code_reset
  001e8	83 c4 04	 add	 esp, 4

; 203  : 
; 204  :   if (mode != MRDTX)

  001eb	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  001ef	74 12		 je	 SHORT $LN2@Decoder_am

; 205  :      gc_pred_reset(state->pred_state);

  001f1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001f4	8b 88 00 02 00
	00		 mov	 ecx, DWORD PTR [eax+512]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 _gc_pred_reset
  00200	83 c4 04	 add	 esp, 4
$LN2@Decoder_am:

; 206  : 
; 207  :   Bgn_scd_reset(state->background_state);

  00203	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00206	8b 88 e4 01 00
	00		 mov	 ecx, DWORD PTR [eax+484]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 _Bgn_scd_reset
  00212	83 c4 04	 add	 esp, 4

; 208  :   state->nodataSeed = 21845;

  00215	b8 55 55 00 00	 mov	 eax, 21845		; 00005555H
  0021a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0021d	66 89 81 e8 01
	00 00		 mov	 WORD PTR [ecx+488], ax

; 209  :   ph_disp_reset(state->ph_disp_st);

  00224	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00227	8b 88 04 02 00
	00		 mov	 ecx, DWORD PTR [eax+516]
  0022d	51		 push	 ecx
  0022e	e8 00 00 00 00	 call	 _ph_disp_reset
  00233	83 c4 04	 add	 esp, 4

; 210  :   if (mode != MRDTX)

  00236	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  0023a	74 12		 je	 SHORT $LN1@Decoder_am

; 211  :      dtx_dec_reset(state->dtxDecoderState);

  0023c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0023f	8b 88 08 02 00
	00		 mov	 ecx, DWORD PTR [eax+520]
  00245	51		 push	 ecx
  00246	e8 00 00 00 00	 call	 _dtx_dec_reset
  0024b	83 c4 04	 add	 esp, 4
$LN1@Decoder_am:

; 212  :   
; 213  :   return 0;

  0024e	33 c0		 xor	 eax, eax
$LN14@Decoder_am:

; 214  : }

  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00259	3b ec		 cmp	 ebp, esp
  0025b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_Decoder_amr_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_init
_TEXT	SEGMENT
_i$ = -20						; size = 2
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Decoder_amr_init PROC					; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 98   :   Decoder_amrState* s;
; 99   :   Word16 i;
; 100  :  
; 101  :   if (state == (Decoder_amrState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN7@Decoder_am

; 102  :       fprintf(stderr, "Decoder_amr_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 103  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 fe 01 00 00	 jmp	 $LN8@Decoder_am
$LN7@Decoder_am:

; 104  :   }
; 105  :   *state = NULL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 106  :  
; 107  :   /* allocate memory */
; 108  :   if ((s= (Decoder_amrState *) malloc(sizeof(Decoder_amrState))) == NULL){

  00065	8b f4		 mov	 esi, esp
  00067	68 0c 02 00 00	 push	 524			; 0000020cH
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00072	83 c4 04	 add	 esp, 4
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007f	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00083	75 38		 jne	 SHORT $LN6@Decoder_am

; 109  :       fprintf(stderr, "Decoder_amr_init: can not malloc state structure\n");

  00085	8b f4		 mov	 esi, esp
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@
  0008c	8b fc		 mov	 edi, esp
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00094	3b fc		 cmp	 edi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a0	d1 e1		 shl	 ecx, 1
  000a2	03 c1		 add	 eax, ecx
  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000ab	83 c4 08	 add	 esp, 8
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 110  :       return -1;

  000b5	83 c8 ff	 or	 eax, -1
  000b8	e9 9d 01 00 00	 jmp	 $LN8@Decoder_am
$LN6@Decoder_am:

; 111  :   }
; 112  :   
; 113  :   s->T0_lagBuff = 40;

  000bd	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c5	66 89 81 cc 01
	00 00		 mov	 WORD PTR [ecx+460], ax

; 114  :   s->inBackgroundNoise = 0;

  000cc	33 c0		 xor	 eax, eax
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000d1	66 89 81 ce 01
	00 00		 mov	 WORD PTR [ecx+462], ax

; 115  :   s->voicedHangover = 0;

  000d8	33 c0		 xor	 eax, eax
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000dd	66 89 81 d0 01
	00 00		 mov	 WORD PTR [ecx+464], ax

; 116  :   for (i = 0; i < 9; i++)

  000e4	33 c0		 xor	 eax, eax
  000e6	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  000ea	eb 0c		 jmp	 SHORT $LN5@Decoder_am
$LN4@Decoder_am:
  000ec	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  000f0	66 83 c0 01	 add	 ax, 1
  000f4	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN5@Decoder_am:
  000f8	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  000fc	83 f8 09	 cmp	 eax, 9
  000ff	7d 13		 jge	 SHORT $LN3@Decoder_am

; 117  :      s->ltpGainHistory[i] = 0;

  00101	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00105	33 c9		 xor	 ecx, ecx
  00107	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0010a	66 89 8c 42 d2
	01 00 00	 mov	 WORD PTR [edx+eax*2+466], cx
  00112	eb d8		 jmp	 SHORT $LN4@Decoder_am
$LN3@Decoder_am:

; 118  : 
; 119  :   s->lsfState = NULL;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00117	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+500], 0

; 120  :   s->ec_gain_p_st = NULL;

  00121	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00124	c7 80 f8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+504], 0

; 121  :   s->ec_gain_c_st = NULL;  

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00131	c7 80 fc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+508], 0

; 122  :   s->pred_state = NULL;

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0013e	c7 80 00 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+512], 0

; 123  :   s->ph_disp_st = NULL;

  00148	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0014b	c7 80 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+516], 0

; 124  :   s->dtxDecoderState = NULL;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00158	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+520], 0

; 125  :   
; 126  :   if (D_plsf_init(&s->lsfState) ||
; 127  :       ec_gain_pitch_init(&s->ec_gain_p_st) ||
; 128  :       ec_gain_code_init(&s->ec_gain_c_st) ||
; 129  :       gc_pred_init(&s->pred_state) ||
; 130  :       Cb_gain_average_init(&s->Cb_gain_averState) ||
; 131  :       lsp_avg_init(&s->lsp_avg_st) ||      
; 132  :       Bgn_scd_init(&s->background_state) ||      
; 133  :       ph_disp_init(&s->ph_disp_st) || 
; 134  :       dtx_dec_init(&s->dtxDecoderState)) {

  00162	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00165	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _D_plsf_init
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	0f 85 b6 00 00
	00		 jne	 $LN1@Decoder_am
  0017b	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0017e	05 f8 01 00 00	 add	 eax, 504		; 000001f8H
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _ec_gain_pitch_init
  00189	83 c4 04	 add	 esp, 4
  0018c	85 c0		 test	 eax, eax
  0018e	0f 85 9d 00 00
	00		 jne	 $LN1@Decoder_am
  00194	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00197	05 fc 01 00 00	 add	 eax, 508		; 000001fcH
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _ec_gain_code_init
  001a2	83 c4 04	 add	 esp, 4
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 84 00 00
	00		 jne	 $LN1@Decoder_am
  001ad	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001b0	05 00 02 00 00	 add	 eax, 512		; 00000200H
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _gc_pred_init
  001bb	83 c4 04	 add	 esp, 4
  001be	85 c0		 test	 eax, eax
  001c0	75 6f		 jne	 SHORT $LN1@Decoder_am
  001c2	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001c5	05 ec 01 00 00	 add	 eax, 492		; 000001ecH
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _Cb_gain_average_init
  001d0	83 c4 04	 add	 esp, 4
  001d3	0f bf c8	 movsx	 ecx, ax
  001d6	85 c9		 test	 ecx, ecx
  001d8	75 57		 jne	 SHORT $LN1@Decoder_am
  001da	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001dd	05 f0 01 00 00	 add	 eax, 496		; 000001f0H
  001e2	50		 push	 eax
  001e3	e8 00 00 00 00	 call	 _lsp_avg_init
  001e8	83 c4 04	 add	 esp, 4
  001eb	85 c0		 test	 eax, eax
  001ed	75 42		 jne	 SHORT $LN1@Decoder_am
  001ef	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001f2	05 e4 01 00 00	 add	 eax, 484		; 000001e4H
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _Bgn_scd_init
  001fd	83 c4 04	 add	 esp, 4
  00200	0f bf c8	 movsx	 ecx, ax
  00203	85 c9		 test	 ecx, ecx
  00205	75 2a		 jne	 SHORT $LN1@Decoder_am
  00207	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0020a	05 04 02 00 00	 add	 eax, 516		; 00000204H
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 _ph_disp_init
  00215	83 c4 04	 add	 esp, 4
  00218	85 c0		 test	 eax, eax
  0021a	75 15		 jne	 SHORT $LN1@Decoder_am
  0021c	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0021f	05 08 02 00 00	 add	 eax, 520		; 00000208H
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _dtx_dec_init
  0022a	83 c4 04	 add	 esp, 4
  0022d	85 c0		 test	 eax, eax
  0022f	74 11		 je	 SHORT $LN2@Decoder_am
$LN1@Decoder_am:

; 135  :       Decoder_amr_exit(&s);

  00231	8d 45 f8	 lea	 eax, DWORD PTR _s$[ebp]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 _Decoder_amr_exit
  0023a	83 c4 04	 add	 esp, 4

; 136  :       return -1;

  0023d	83 c8 ff	 or	 eax, -1
  00240	eb 18		 jmp	 SHORT $LN8@Decoder_am
$LN2@Decoder_am:

; 137  :   }
; 138  :       
; 139  :   Decoder_amr_reset(s, (enum Mode)0);

  00242	6a 00		 push	 0
  00244	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 _Decoder_amr_reset
  0024d	83 c4 08	 add	 esp, 8

; 140  :   *state = s;

  00250	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00253	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00256	89 08		 mov	 DWORD PTR [eax], ecx

; 141  :   
; 142  :   return 0;

  00258	33 c0		 xor	 eax, eax
$LN8@Decoder_am:

; 143  : }

  0025a	52		 push	 edx
  0025b	8b cd		 mov	 ecx, ebp
  0025d	50		 push	 eax
  0025e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Decoder_am
  00264	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00269	58		 pop	 eax
  0026a	5a		 pop	 edx
  0026b	5f		 pop	 edi
  0026c	5e		 pop	 esi
  0026d	5b		 pop	 ebx
  0026e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00274	3b ec		 cmp	 ebp, esp
  00276	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027b	8b e5		 mov	 esp, ebp
  0027d	5d		 pop	 ebp
  0027e	c3		 ret	 0
  0027f	90		 npad	 1
$LN12@Decoder_am:
  00280	01 00 00 00	 DD	 1
  00284	00 00 00 00	 DD	 $LN11@Decoder_am
$LN11@Decoder_am:
  00288	f8 ff ff ff	 DD	 -8			; fffffff8H
  0028c	04 00 00 00	 DD	 4
  00290	00 00 00 00	 DD	 $LN10@Decoder_am
$LN10@Decoder_am:
  00294	73		 DB	 115			; 00000073H
  00295	00		 DB	 0
_Decoder_amr_init ENDP
_TEXT	ENDS
END
