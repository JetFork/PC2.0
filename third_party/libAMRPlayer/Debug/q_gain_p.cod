; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\q_gain_p.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_q_gain_p_id
CONST	SEGMENT
_q_gain_p_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_qua_gain_pitch DW 00H
	DW	0ccdH
	DW	0199cH
	DW	02000H
	DW	02666H
	DW	02ccdH
	DW	03000H
	DW	03333H
	DW	03666H
	DW	0399aH
	DW	03ccdH
	DW	04000H
	DW	04333H
	DW	04666H
	DW	0499aH
	DW	04ccdH
_qua_gain_code DW 09fH
	DW	0f140H
	DW	0a735H
	DW	0ceH
	DW	0f2beH
	DW	0b034H
	DW	010cH
	DW	0f443H
	DW	0b958H
	DW	015dH
	DW	0f5c9H
	DW	0c285H
	DW	01a3H
	DW	0f6d7H
	DW	0c8dfH
	DW	01e2H
	DW	0f7a6H
	DW	0cdbdH
	DW	022aH
	DW	0f874H
	DW	0d293H
	DW	027dH
	DW	0f942H
	DW	0d76dH
	DW	02ddH
	DW	0fa12H
	DW	0dc4dH
	DW	034aH
	DW	0fadeH
	DW	0e11eH
	DW	03c9H
	DW	0fbaeH
	DW	0e600H
	DW	045aH
	DW	0fc7cH
	DW	0ead8H
	DW	0501H
	DW	0fd4aH
	DW	0efb3H
	DW	05c1H
	DW	0fe19H
	DW	0f48dH
	DW	069eH
	DW	0fee7H
	DW	0f968H
	DW	079cH
	DW	0ffb5H
	DW	0fe43H
	DW	08c1H
	DW	085H
	DW	0321H
	DW	0a11H
	DW	0153H
	DW	07fcH
	DW	0b93H
	DW	0221H
	DW	0cd5H
	DW	0d50H
	DW	02f0H
	DW	011b2H
	DW	0f4fH
	DW	03beH
	DW	0168cH
	DW	0119bH
	DW	048dH
	DW	01b68H
	DW	0143fH
	DW	055bH
	DW	02043H
	DW	01748H
	DW	0629H
	DW	0251dH
	DW	01ac7H
	DW	06f8H
	DW	029f9H
	DW	01ecbH
	DW	07c7H
	DW	02ed4H
	DW	02369H
	DW	0895H
	DW	033afH
	DW	028b9H
	DW	0964H
	DW	0388aH
	DW	030deH
	DW	0a71H
	DW	03ee0H
	DW	03f87H
	DW	0bf4H
	DW	047fdH
	DW	05296H
	DW	0d78H
	DW	0511bH
	DW	06b5dH
	DW	0efcH
	DW	05a39H
CONST	ENDS
PUBLIC	_q_gain_pitch
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\q_gain_p.c
;	COMDAT _q_gain_pitch
_TEXT	SEGMENT
_ii$1 = -56						; size = 2
_err_min$ = -44						; size = 2
_err$ = -32						; size = 2
_index$ = -20						; size = 2
_i$ = -8						; size = 2
_mode$ = 8						; size = 4
_gp_limit$ = 12						; size = 2
_gain$ = 16						; size = 4
_gain_cand$ = 20					; size = 4
_gain_cind$ = 24					; size = 4
_q_gain_pitch PROC					; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 56   :     Word16 i, index, err, err_min;
; 57   : 
; 58   :     err_min = abs_s (sub (*gain, qua_gain_pitch[0]));

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR _qua_gain_pitch[ecx]
  0002d	52		 push	 edx
  0002e	8b 45 10	 mov	 eax, DWORD PTR _gain$[ebp]
  00031	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _sub
  0003a	83 c4 08	 add	 esp, 8
  0003d	0f b7 d0	 movzx	 edx, ax
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _abs_s
  00046	83 c4 04	 add	 esp, 4
  00049	66 89 45 d4	 mov	 WORD PTR _err_min$[ebp], ax

; 59   :     index = 0;                                              move16 (); 

  0004d	33 c0		 xor	 eax, eax
  0004f	66 89 45 ec	 mov	 WORD PTR _index$[ebp], ax
  00053	e8 00 00 00 00	 call	 _move16

; 60   : 
; 61   :     for (i = 1; i < NB_QUA_PITCH; i++)

  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00061	eb 0c		 jmp	 SHORT $LN17@q_gain_pit
$LN16@q_gain_pit:
  00063	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00067	66 83 c0 01	 add	 ax, 1
  0006b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN17@q_gain_pit:
  0006f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00073	83 f8 10	 cmp	 eax, 16			; 00000010H
  00076	0f 8d 8d 00 00
	00		 jge	 $LN15@q_gain_pit

; 62   :     {
; 63   :         test ();

  0007c	e8 00 00 00 00	 call	 _test

; 64   :         if (sub (qua_gain_pitch[i], gp_limit) <= 0)

  00081	0f b7 45 0c	 movzx	 eax, WORD PTR _gp_limit$[ebp]
  00085	50		 push	 eax
  00086	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0008a	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR _qua_gain_pitch[ecx*2]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _sub
  00098	83 c4 08	 add	 esp, 8
  0009b	98		 cwde
  0009c	85 c0		 test	 eax, eax
  0009e	7f 64		 jg	 SHORT $LN14@q_gain_pit

; 65   :         {
; 66   :             err = abs_s (sub (*gain, qua_gain_pitch[i]));

  000a0	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000a4	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _qua_gain_pitch[eax*2]
  000ac	51		 push	 ecx
  000ad	8b 55 10	 mov	 edx, DWORD PTR _gain$[ebp]
  000b0	0f b7 02	 movzx	 eax, WORD PTR [edx]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _sub
  000b9	83 c4 08	 add	 esp, 8
  000bc	0f b7 c8	 movzx	 ecx, ax
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _abs_s
  000c5	83 c4 04	 add	 esp, 4
  000c8	66 89 45 e0	 mov	 WORD PTR _err$[ebp], ax

; 67   :             
; 68   :             test (); 

  000cc	e8 00 00 00 00	 call	 _test

; 69   :             if (sub (err, err_min) < 0)

  000d1	0f b7 45 d4	 movzx	 eax, WORD PTR _err_min$[ebp]
  000d5	50		 push	 eax
  000d6	0f b7 4d e0	 movzx	 ecx, WORD PTR _err$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _sub
  000e0	83 c4 08	 add	 esp, 8
  000e3	0f bf d0	 movsx	 edx, ax
  000e6	85 d2		 test	 edx, edx
  000e8	7d 1a		 jge	 SHORT $LN14@q_gain_pit

; 70   :             {
; 71   :                 err_min = err;                                  move16 (); 

  000ea	66 8b 45 e0	 mov	 ax, WORD PTR _err$[ebp]
  000ee	66 89 45 d4	 mov	 WORD PTR _err_min$[ebp], ax
  000f2	e8 00 00 00 00	 call	 _move16

; 72   :                 index = i;                                      move16 (); 

  000f7	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000fb	66 89 45 ec	 mov	 WORD PTR _index$[ebp], ax
  000ff	e8 00 00 00 00	 call	 _move16
$LN14@q_gain_pit:

; 73   :             }
; 74   :         }
; 75   :     }

  00104	e9 5a ff ff ff	 jmp	 $LN16@q_gain_pit
$LN15@q_gain_pit:

; 76   : 
; 77   :     test ();

  00109	e8 00 00 00 00	 call	 _test

; 78   :     if (sub (mode, MR795) == 0)

  0010e	6a 05		 push	 5
  00110	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _sub
  0011a	83 c4 08	 add	 esp, 8
  0011d	0f bf c8	 movsx	 ecx, ax
  00120	85 c9		 test	 ecx, ecx
  00122	0f 85 fe 00 00
	00		 jne	 $LN12@q_gain_pit

; 79   :     {
; 80   :         /* in MR795 mode, compute three gain_pit candidates around the index
; 81   :          * found in the quantization loop: the index found and the two direct
; 82   :          * neighbours, except for the extreme cases (i=0 or i=NB_QUA_PITCH-1),
; 83   :          * where the direct neighbour and the neighbour to that is used.
; 84   :          */
; 85   :         Word16 ii;
; 86   : 
; 87   :         test ();

  00128	e8 00 00 00 00	 call	 _test

; 88   :         if (index == 0)

  0012d	0f bf 45 ec	 movsx	 eax, WORD PTR _index$[ebp]
  00131	85 c0		 test	 eax, eax
  00133	75 0f		 jne	 SHORT $LN11@q_gain_pit

; 89   :         {
; 90   :             ii = index;                                     move16 ();

  00135	66 8b 45 ec	 mov	 ax, WORD PTR _index$[ebp]
  00139	66 89 45 c8	 mov	 WORD PTR _ii$1[ebp], ax
  0013d	e8 00 00 00 00	 call	 _move16

; 91   :         }
; 92   :         else

  00142	eb 67		 jmp	 SHORT $LN10@q_gain_pit
$LN11@q_gain_pit:

; 93   :         {
; 94   :             test (); test ();

  00144	e8 00 00 00 00	 call	 _test
  00149	e8 00 00 00 00	 call	 _test

; 95   :             if (   sub (index, NB_QUA_PITCH-1) == 0
; 96   :                 || sub (qua_gain_pitch[index+1], gp_limit) > 0)

  0014e	6a 0f		 push	 15			; 0000000fH
  00150	0f b7 45 ec	 movzx	 eax, WORD PTR _index$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _sub
  0015a	83 c4 08	 add	 esp, 8
  0015d	0f bf c8	 movsx	 ecx, ax
  00160	85 c9		 test	 ecx, ecx
  00162	74 1f		 je	 SHORT $LN8@q_gain_pit
  00164	0f b7 45 0c	 movzx	 eax, WORD PTR _gp_limit$[ebp]
  00168	50		 push	 eax
  00169	0f bf 4d ec	 movsx	 ecx, WORD PTR _index$[ebp]
  0016d	0f b7 14 4d 02
	00 00 00	 movzx	 edx, WORD PTR _qua_gain_pitch[ecx*2+2]
  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 _sub
  0017b	83 c4 08	 add	 esp, 8
  0017e	98		 cwde
  0017f	85 c0		 test	 eax, eax
  00181	7e 15		 jle	 SHORT $LN9@q_gain_pit
$LN8@q_gain_pit:

; 97   :             {
; 98   :                 ii = sub (index, 2);

  00183	6a 02		 push	 2
  00185	0f b7 45 ec	 movzx	 eax, WORD PTR _index$[ebp]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 _sub
  0018f	83 c4 08	 add	 esp, 8
  00192	66 89 45 c8	 mov	 WORD PTR _ii$1[ebp], ax

; 99   :             }
; 100  :             else

  00196	eb 13		 jmp	 SHORT $LN10@q_gain_pit
$LN9@q_gain_pit:

; 101  :             {
; 102  :                 ii = sub (index, 1);

  00198	6a 01		 push	 1
  0019a	0f b7 45 ec	 movzx	 eax, WORD PTR _index$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 _sub
  001a4	83 c4 08	 add	 esp, 8
  001a7	66 89 45 c8	 mov	 WORD PTR _ii$1[ebp], ax
$LN10@q_gain_pit:

; 103  :             }
; 104  :         }
; 105  : 
; 106  :         /* store candidate indices and values */
; 107  :         for (i = 0; i < 3; i++)

  001ab	33 c0		 xor	 eax, eax
  001ad	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  001b1	eb 0c		 jmp	 SHORT $LN6@q_gain_pit
$LN5@q_gain_pit:
  001b3	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  001b7	66 83 c0 01	 add	 ax, 1
  001bb	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN6@q_gain_pit:
  001bf	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001c3	83 f8 03	 cmp	 eax, 3
  001c6	7d 45		 jge	 SHORT $LN4@q_gain_pit

; 108  :         {
; 109  :             gain_cind[i] = ii;                              move16 ();

  001c8	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001cc	8b 4d 18	 mov	 ecx, DWORD PTR _gain_cind$[ebp]
  001cf	66 8b 55 c8	 mov	 dx, WORD PTR _ii$1[ebp]
  001d3	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  001d7	e8 00 00 00 00	 call	 _move16

; 110  :             gain_cand[i] = qua_gain_pitch[ii];              move16 ();

  001dc	0f bf 45 c8	 movsx	 eax, WORD PTR _ii$1[ebp]
  001e0	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  001e4	8b 55 14	 mov	 edx, DWORD PTR _gain_cand$[ebp]
  001e7	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _qua_gain_pitch[eax*2]
  001ef	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  001f3	e8 00 00 00 00	 call	 _move16

; 111  :             ii = add (ii, 1);

  001f8	6a 01		 push	 1
  001fa	0f b7 45 c8	 movzx	 eax, WORD PTR _ii$1[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _add
  00204	83 c4 08	 add	 esp, 8
  00207	66 89 45 c8	 mov	 WORD PTR _ii$1[ebp], ax

; 112  :         }

  0020b	eb a6		 jmp	 SHORT $LN5@q_gain_pit
$LN4@q_gain_pit:

; 113  :         
; 114  :         *gain = qua_gain_pitch[index];                      move16 (); 

  0020d	0f bf 45 ec	 movsx	 eax, WORD PTR _index$[ebp]
  00211	8b 4d 10	 mov	 ecx, DWORD PTR _gain$[ebp]
  00214	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _qua_gain_pitch[eax*2]
  0021c	66 89 11	 mov	 WORD PTR [ecx], dx
  0021f	e8 00 00 00 00	 call	 _move16

; 115  :     }
; 116  :     else

  00224	eb 56		 jmp	 SHORT $LN3@q_gain_pit
$LN12@q_gain_pit:

; 117  :     {
; 118  :         /* in MR122 mode, just return the index and gain pitch found.
; 119  :          * If bitexactness is required, mask away the two LSBs (because
; 120  :          * in the original EFR, gain_pit was scaled Q12)
; 121  :          */
; 122  :        test ();

  00226	e8 00 00 00 00	 call	 _test

; 123  :        if (sub(mode, MR122) == 0)

  0022b	6a 07		 push	 7
  0022d	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 _sub
  00237	83 c4 08	 add	 esp, 8
  0023a	0f bf c8	 movsx	 ecx, ax
  0023d	85 c9		 test	 ecx, ecx
  0023f	75 24		 jne	 SHORT $LN2@q_gain_pit

; 124  :        {
; 125  :           /* clear 2 LSBits */
; 126  :           *gain = qua_gain_pitch[index] & 0xFFFC; logic16 (); move16 ();

  00241	0f bf 45 ec	 movsx	 eax, WORD PTR _index$[ebp]
  00245	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _qua_gain_pitch[eax*2]
  0024d	81 e1 fc ff 00
	00		 and	 ecx, 65532		; 0000fffcH
  00253	8b 55 10	 mov	 edx, DWORD PTR _gain$[ebp]
  00256	66 89 0a	 mov	 WORD PTR [edx], cx
  00259	e8 00 00 00 00	 call	 _logic16
  0025e	e8 00 00 00 00	 call	 _move16

; 127  :        }
; 128  :        else

  00263	eb 17		 jmp	 SHORT $LN3@q_gain_pit
$LN2@q_gain_pit:

; 129  :        {
; 130  :           *gain = qua_gain_pitch[index];                      move16 (); 

  00265	0f bf 45 ec	 movsx	 eax, WORD PTR _index$[ebp]
  00269	8b 4d 10	 mov	 ecx, DWORD PTR _gain$[ebp]
  0026c	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _qua_gain_pitch[eax*2]
  00274	66 89 11	 mov	 WORD PTR [ecx], dx
  00277	e8 00 00 00 00	 call	 _move16
$LN3@q_gain_pit:

; 131  :        }
; 132  :     }
; 133  :     return index;

  0027c	66 8b 45 ec	 mov	 ax, WORD PTR _index$[ebp]

; 134  : }

  00280	5f		 pop	 edi
  00281	5e		 pop	 esi
  00282	5b		 pop	 ebx
  00283	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00289	3b ec		 cmp	 ebp, esp
  0028b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00290	8b e5		 mov	 esp, ebp
  00292	5d		 pop	 ebp
  00293	c3		 ret	 0
_q_gain_pitch ENDP
_TEXT	ENDS
END
