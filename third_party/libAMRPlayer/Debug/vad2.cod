; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\vad2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vad2_id
_DATA	SEGMENT
?ch_tbl@?1??vad2@@9@9 DW 02H				; `vad2'::`2'::ch_tbl
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	010H
	DW	011H
	DW	013H
	DW	014H
	DW	016H
	DW	017H
	DW	01aH
	DW	01bH
	DW	01eH
	DW	01fH
	DW	023H
	DW	024H
	DW	029H
	DW	02aH
	DW	030H
	DW	031H
	DW	037H
	DW	038H
	DW	03fH
?ch_tbl_sh@?1??vad2@@9@9 DW 04000H			; `vad2'::`2'::ch_tbl_sh
	DW	04000H
	DW	04000H
	DW	04000H
	DW	04000H
	DW	04000H
	DW	02aabH
	DW	02aabH
	DW	02aabH
	DW	02000H
	DW	02000H
	DW	0199aH
	DW	01555H
	DW	01249H
	DW	01249H
	DW	01000H
?vm_tbl@?1??vad2@@9@9 DW 02H				; `vad2'::`2'::vm_tbl
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	04H
	DW	04H
	DW	05H
	DW	05H
	DW	05H
	DW	06H
	DW	06H
	DW	07H
	DW	07H
	DW	07H
	DW	08H
	DW	08H
	DW	09H
	DW	09H
	DW	0aH
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0cH
	DW	0dH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	0fH
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	024H
	DW	025H
	DW	025H
	DW	026H
	DW	027H
	DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
	DW	030H
	DW	031H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
	DW	032H
?hangover_table@?1??vad2@@9@9 DW 01eH			; `vad2'::`2'::hangover_table
	DW	01eH
	DW	01eH
	DW	01eH
	DW	01eH
	DW	01eH
	DW	01cH
	DW	01aH
	DW	018H
	DW	016H
	DW	014H
	DW	012H
	DW	010H
	DW	0eH
	DW	0cH
	DW	0aH
	DW	08H
	DW	08H
	DW	08H
	DW	08H
?burstcount_table@?1??vad2@@9@9 DW 08H			; `vad2'::`2'::burstcount_table
	DW	08H
	DW	08H
	DW	08H
	DW	08H
	DW	08H
	DW	08H
	DW	08H
	DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
?vm_threshold_table@?1??vad2@@9@9 DW 022H		; `vad2'::`2'::vm_threshold_table
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	022H
	DW	028H
	DW	033H
	DW	047H
	DW	064H
	DW	08bH
	DW	0bfH
	DW	0101H
	DW	0151H
	DW	01b0H
?noise_floor_chan@?1??vad2@@9@9 DW 0200H		; `vad2'::`2'::noise_floor_chan
	DW	010H
?min_chan_enrg@?1??vad2@@9@9 DW 020H			; `vad2'::`2'::min_chan_enrg
	DW	01H
?ine_noise@?1??vad2@@9@9 DW 02000H			; `vad2'::`2'::ine_noise
	DW	0100H
?fbits@?1??vad2@@9@9 DW 09H				; `vad2'::`2'::fbits
	DW	04H
?state_change_shift_r@?1??vad2@@9@9 DW 0fffbH		; `vad2'::`2'::state_change_shift_r
	DW	05H
?enrg_norm_shift@?1??vad2@@9@9 DW 0aH			; `vad2'::`2'::enrg_norm_shift
	DW	05H
_DATA	ENDS
CONST	SEGMENT
_vad2_id DB	'@(#)$Id $', 00H
CONST	ENDS
PUBLIC	_vad2
PUBLIC	_vad2_init
PUBLIC	_vad2_reset
PUBLIC	_vad2_exit
PUBLIC	_fn10Log10
PUBLIC	_block_norm
PUBLIC	??_C@_0BO@FIBHOLLF@vad2_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@GOOICBKM@vad2_init?3?5can?5not?5malloc?5state?5@ ; `string'
PUBLIC	??_C@_0BP@CFPNGBID@vad2_reset?3?5invalid?5parameter?6?$AA@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_sub:PROC
EXTRN	_mult_r:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_shr_r:PROC
EXTRN	_L_shr_r:PROC
EXTRN	_norm_s:PROC
EXTRN	_div_s:PROC
EXTRN	_L_Extract:PROC
EXTRN	_Mpy_32_16:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	_Log2:PROC
EXTRN	_Pow2:PROC
EXTRN	_r_fft:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BP@CFPNGBID@vad2_reset?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BP@CFPNGBID@vad2_reset?3?5invalid?5parameter?6?$AA@ DB 'vad2_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GOOICBKM@vad2_init?3?5can?5not?5malloc?5state?5@
CONST	SEGMENT
??_C@_0CL@GOOICBKM@vad2_init?3?5can?5not?5malloc?5state?5@ DB 'vad2_init:'
	DB	' can not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FIBHOLLF@vad2_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BO@FIBHOLLF@vad2_init?3?5invalid?5parameter?6?$AA@ DB 'vad2_init: '
	DB	'invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _block_norm
_TEXT	SEGMENT
_adata$ = -44						; size = 2
_scnt$ = -32						; size = 2
_max$ = -20						; size = 2
_i$ = -8						; size = 2
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_length$ = 16						; size = 2
_headroom$ = 20						; size = 2
_block_norm PROC					; COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 168  : 
; 169  : 	Word16 i, max, scnt, adata;
; 170  : 
; 171  :         max = abs_s(in[0]);

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00029	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _abs_s
  00033	83 c4 04	 add	 esp, 4
  00036	66 89 45 ec	 mov	 WORD PTR _max$[ebp], ax

; 172  : 	for (i = 1; i < length; i++)

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00043	eb 0c		 jmp	 SHORT $LN12@block_norm
$LN11@block_norm:
  00045	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00049	66 83 c0 01	 add	 ax, 1
  0004d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN12@block_norm:
  00051	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00055	0f bf 4d 10	 movsx	 ecx, WORD PTR _length$[ebp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7d 45		 jge	 SHORT $LN10@block_norm

; 173  : 	{
; 174  :                 adata = abs_s(in[i]);                           test();

  0005d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00064	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _abs_s
  0006e	83 c4 04	 add	 esp, 4
  00071	66 89 45 d4	 mov	 WORD PTR _adata$[ebp], ax
  00075	e8 00 00 00 00	 call	 _test

; 175  : 		if (sub(adata, max) > 0)

  0007a	0f b7 45 ec	 movzx	 eax, WORD PTR _max$[ebp]
  0007e	50		 push	 eax
  0007f	0f b7 4d d4	 movzx	 ecx, WORD PTR _adata$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _sub
  00089	83 c4 08	 add	 esp, 8
  0008c	0f bf d0	 movsx	 edx, ax
  0008f	85 d2		 test	 edx, edx
  00091	7e 0d		 jle	 SHORT $LN9@block_norm

; 176  : 		{
; 177  : 			max = adata;				move16();

  00093	66 8b 45 d4	 mov	 ax, WORD PTR _adata$[ebp]
  00097	66 89 45 ec	 mov	 WORD PTR _max$[ebp], ax
  0009b	e8 00 00 00 00	 call	 _move16
$LN9@block_norm:

; 178  : 		}
; 179  : 	}

  000a0	eb a3		 jmp	 SHORT $LN11@block_norm
$LN10@block_norm:

; 180  : 	test();

  000a2	e8 00 00 00 00	 call	 _test

; 181  : 	if (max != 0)

  000a7	0f bf 45 ec	 movsx	 eax, WORD PTR _max$[ebp]
  000ab	85 c0		 test	 eax, eax
  000ad	74 6f		 je	 SHORT $LN8@block_norm

; 182  : 	{
; 183  : 		scnt = sub(norm_s(max), headroom);

  000af	0f b7 45 14	 movzx	 eax, WORD PTR _headroom$[ebp]
  000b3	50		 push	 eax
  000b4	0f b7 4d ec	 movzx	 ecx, WORD PTR _max$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _norm_s
  000be	83 c4 04	 add	 esp, 4
  000c1	0f b7 d0	 movzx	 edx, ax
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 _sub
  000ca	83 c4 08	 add	 esp, 8
  000cd	66 89 45 e0	 mov	 WORD PTR _scnt$[ebp], ax

; 184  : 		for (i = 0; i < length; i++)

  000d1	33 c0		 xor	 eax, eax
  000d3	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000d7	eb 0c		 jmp	 SHORT $LN7@block_norm
$LN6@block_norm:
  000d9	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000dd	66 83 c0 01	 add	 ax, 1
  000e1	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN7@block_norm:
  000e5	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000e9	0f bf 4d 10	 movsx	 ecx, WORD PTR _length$[ebp]
  000ed	3b c1		 cmp	 eax, ecx
  000ef	7d 2b		 jge	 SHORT $LN5@block_norm

; 185  : 		{
; 186  : 			out[i] = shl(in[i], scnt);	       	move16();

  000f1	0f b7 45 e0	 movzx	 eax, WORD PTR _scnt$[ebp]
  000f5	50		 push	 eax
  000f6	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  000fa	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  000fd	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _shl
  00107	83 c4 08	 add	 esp, 8
  0010a	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00111	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00115	e8 00 00 00 00	 call	 _move16

; 187  : 		}

  0011a	eb bd		 jmp	 SHORT $LN6@block_norm
$LN5@block_norm:

; 188  : 	}
; 189  : 	else

  0011c	eb 47		 jmp	 SHORT $LN4@block_norm
$LN8@block_norm:

; 190  : 	{
; 191  : 		scnt = sub(16, headroom);

  0011e	0f b7 45 14	 movzx	 eax, WORD PTR _headroom$[ebp]
  00122	50		 push	 eax
  00123	6a 10		 push	 16			; 00000010H
  00125	e8 00 00 00 00	 call	 _sub
  0012a	83 c4 08	 add	 esp, 8
  0012d	66 89 45 e0	 mov	 WORD PTR _scnt$[ebp], ax

; 192  : 		for (i = 0; i < length; i++)

  00131	33 c0		 xor	 eax, eax
  00133	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00137	eb 0c		 jmp	 SHORT $LN3@block_norm
$LN2@block_norm:
  00139	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0013d	66 83 c0 01	 add	 ax, 1
  00141	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@block_norm:
  00145	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00149	0f bf 4d 10	 movsx	 ecx, WORD PTR _length$[ebp]
  0014d	3b c1		 cmp	 eax, ecx
  0014f	7d 14		 jge	 SHORT $LN4@block_norm

; 193  : 		{
; 194  : 			out[i] = 0;                             move16();

  00151	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00155	33 c9		 xor	 ecx, ecx
  00157	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0015a	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0015e	e8 00 00 00 00	 call	 _move16

; 195  : 		}

  00163	eb d4		 jmp	 SHORT $LN2@block_norm
$LN4@block_norm:

; 196  : 	}
; 197  : 	return (scnt);

  00165	66 8b 45 e0	 mov	 ax, WORD PTR _scnt$[ebp]

; 198  : }

  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_block_norm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _fn10Log10
_TEXT	SEGMENT
_tmp$ = -44						; size = 2
_Ltmp$ = -32						; size = 4
_fraction$ = -20					; size = 2
_integer$ = -8						; size = 2
_L_Input$ = 8						; size = 4
_fbits$ = 12						; size = 2
_fn10Log10 PROC						; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 107  : 
; 108  : 	Word16 integer;		/* Integer part of Log2.   (range: 0<=val<=30) */
; 109  : 	Word16 fraction;	/* Fractional part of Log2. (range: 0<=val<1) */
; 110  : 
; 111  : 	Word32 Ltmp;
; 112  : 	Word16 tmp;
; 113  : 
; 114  :         Log2(L_Input, &integer, &fraction);

  0001e	8d 45 ec	 lea	 eax, DWORD PTR _fraction$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f8	 lea	 ecx, DWORD PTR _integer$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _L_Input$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 _Log2
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 
; 116  : 	integer = sub(integer, fbits);

  00032	0f b7 45 0c	 movzx	 eax, WORD PTR _fbits$[ebp]
  00036	50		 push	 eax
  00037	0f b7 4d f8	 movzx	 ecx, WORD PTR _integer$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _sub
  00041	83 c4 08	 add	 esp, 8
  00044	66 89 45 f8	 mov	 WORD PTR _integer$[ebp], ax

; 117  : 	Ltmp = Mpy_32_16 (integer, fraction, 24660);	/* 24660 = 10*log10(2)/4 scaled 0,15 */

  00048	68 54 60 00 00	 push	 24660			; 00006054H
  0004d	0f b7 45 ec	 movzx	 eax, WORD PTR _fraction$[ebp]
  00051	50		 push	 eax
  00052	0f b7 4d f8	 movzx	 ecx, WORD PTR _integer$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _Mpy_32_16
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	89 45 e0	 mov	 DWORD PTR _Ltmp$[ebp], eax

; 118  : 	Ltmp = L_shr_r(Ltmp, 5+1);			/* extra shift for 30,1 => 15,0 extract correction */

  00062	6a 06		 push	 6
  00064	8b 45 e0	 mov	 eax, DWORD PTR _Ltmp$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _L_shr_r
  0006d	83 c4 08	 add	 esp, 8
  00070	89 45 e0	 mov	 DWORD PTR _Ltmp$[ebp], eax

; 119  :         tmp = extract_l(Ltmp);

  00073	8b 45 e0	 mov	 eax, DWORD PTR _Ltmp$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _extract_l
  0007c	83 c4 04	 add	 esp, 4
  0007f	66 89 45 d4	 mov	 WORD PTR _tmp$[ebp], ax

; 120  : 
; 121  :         return (tmp);

  00083	66 8b 45 d4	 mov	 ax, WORD PTR _tmp$[ebp]

; 122  : }

  00087	52		 push	 edx
  00088	8b cd		 mov	 ecx, ebp
  0008a	50		 push	 eax
  0008b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@fn10Log10
  00091	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00096	58		 pop	 eax
  00097	5a		 pop	 edx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN6@fn10Log10:
  000ac	02 00 00 00	 DD	 2
  000b0	00 00 00 00	 DD	 $LN5@fn10Log10
$LN5@fn10Log10:
  000b4	f8 ff ff ff	 DD	 -8			; fffffff8H
  000b8	02 00 00 00	 DD	 2
  000bc	00 00 00 00	 DD	 $LN3@fn10Log10
  000c0	ec ff ff ff	 DD	 -20			; ffffffecH
  000c4	02 00 00 00	 DD	 2
  000c8	00 00 00 00	 DD	 $LN4@fn10Log10
$LN4@fn10Log10:
  000cc	66		 DB	 102			; 00000066H
  000cd	72		 DB	 114			; 00000072H
  000ce	61		 DB	 97			; 00000061H
  000cf	63		 DB	 99			; 00000063H
  000d0	74		 DB	 116			; 00000074H
  000d1	69		 DB	 105			; 00000069H
  000d2	6f		 DB	 111			; 0000006fH
  000d3	6e		 DB	 110			; 0000006eH
  000d4	00		 DB	 0
$LN3@fn10Log10:
  000d5	69		 DB	 105			; 00000069H
  000d6	6e		 DB	 110			; 0000006eH
  000d7	74		 DB	 116			; 00000074H
  000d8	65		 DB	 101			; 00000065H
  000d9	67		 DB	 103			; 00000067H
  000da	65		 DB	 101			; 00000065H
  000db	72		 DB	 114			; 00000072H
  000dc	00		 DB	 0
_fn10Log10 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _vad2_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_vad2_exit PROC						; COMDAT

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 905  :     if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@vad2_exit
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@vad2_exit
$LN1@vad2_exit:

; 906  :         return;

  0002c	eb 21		 jmp	 SHORT $LN3@vad2_exit
$LN2@vad2_exit:

; 907  :     
; 908  :     /* deallocate memory */
; 909  :     free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 910  :     *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@vad2_exit:

; 911  :     
; 912  :     return;
; 913  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_vad2_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _vad2_reset
_TEXT	SEGMENT
_ptr$ = -20						; size = 4
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_vad2_reset PROC					; COMDAT

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 879  : 	Word16	i;
; 880  : 	Word16	*ptr;
; 881  : 
; 882  : 	if (st == (vadState2 *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@vad2_reset

; 883  : 		fprintf(stderr, "vad2_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CFPNGBID@vad2_reset?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 884  : 		return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 42		 jmp	 SHORT $LN5@vad2_reset
$LN4@vad2_reset:

; 885  : 	}
; 886  : 	ptr = (Word16 *)st;				move16();

  00059	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005c	89 45 ec	 mov	 DWORD PTR _ptr$[ebp], eax
  0005f	e8 00 00 00 00	 call	 _move16

; 887  : 
; 888  : 	for (i = 0; i < sizeof(vadState2)/2; i++)

  00064	33 c0		 xor	 eax, eax
  00066	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0006a	eb 0c		 jmp	 SHORT $LN3@vad2_reset
$LN2@vad2_reset:
  0006c	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00070	66 83 c0 01	 add	 ax, 1
  00074	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@vad2_reset:
  00078	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0007f	73 18		 jae	 SHORT $LN1@vad2_reset

; 889  : 	{
; 890  : 		*ptr++ = 0;				move16();

  00081	33 c0		 xor	 eax, eax
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00086	66 89 01	 mov	 WORD PTR [ecx], ax
  00089	8b 55 ec	 mov	 edx, DWORD PTR _ptr$[ebp]
  0008c	83 c2 02	 add	 edx, 2
  0008f	89 55 ec	 mov	 DWORD PTR _ptr$[ebp], edx
  00092	e8 00 00 00 00	 call	 _move16

; 891  : 	}

  00097	eb d3		 jmp	 SHORT $LN2@vad2_reset
$LN1@vad2_reset:

; 892  : 
; 893  : 	return 0;

  00099	33 c0		 xor	 eax, eax
$LN5@vad2_reset:

; 894  : }						/* end of vad2_reset () */

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_vad2_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _vad2_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_vad2_init PROC						; COMDAT

; 824  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 825  :     vadState2* s;
; 826  :     
; 827  :     if (state == (vadState2 **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@vad2_init

; 828  :         fprintf(stderr, "vad2_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FIBHOLLF@vad2_init?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 829  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 74		 jmp	 SHORT $LN3@vad2_init
$LN2@vad2_init:

; 830  :     }
; 831  :     *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 832  :     
; 833  :     /* allocate memory */
; 834  :     if ((s = (vadState2 *) malloc(sizeof(vadState2))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	68 c8 00 00 00	 push	 200			; 000000c8H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 35		 jne	 SHORT $LN1@vad2_init

; 835  :         fprintf(stderr, "vad2_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GOOICBKM@vad2_init?3?5can?5not?5malloc?5state?5@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 836  :         return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 16		 jmp	 SHORT $LN3@vad2_init
$LN1@vad2_init:

; 837  :     }
; 838  :     
; 839  :     vad2_reset(s);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _vad2_reset
  000c0	83 c4 04	 add	 esp, 4

; 840  :     
; 841  :     *state = s;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c9	89 08		 mov	 DWORD PTR [eax], ecx

; 842  :     
; 843  :     return 0;

  000cb	33 c0		 xor	 eax, eax
$LN3@vad2_init:

; 844  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
_vad2_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad2.c
;	COMDAT _vad2
_TEXT	SEGMENT
$T1 = -1076						; size = 4
$T2 = -1064						; size = 4
_state_change$ = -860					; size = 2
_xt$ = -848						; size = 2
_tsnrq$ = -836						; size = 2
_ivad$ = -824						; size = 2
_normb_shift$ = -812					; size = 2
_tmp$ = -800						; size = 2
_Ltmp2$ = -788						; size = 4
_Ltmp1$ = -776						; size = 4
_Ltmp$ = -764						; size = 4
_lo1$ = -752						; size = 2
_hi1$ = -740						; size = 2
_j2$ = -728						; size = 2
_j1$ = -716						; size = 2
_j$ = -704						; size = 2
_i$ = -692						; size = 2
_update_flag$ = -680					; size = 2
_one_m_alpha$ = -668					; size = 2
_alpha$ = -656						; size = 2
_ch_noise_db$ = -644					; size = 2
_ch_enrg_db$ = -632					; size = 32
_p2a_flag$ = -592					; size = 2
_Lpeak$ = -580						; size = 4
_ch_enrg_dev$ = -568					; size = 2
_vm_sum$ = -556						; size = 2
_ch_snrq$ = -544					; size = 2
_ch_snr$ = -532						; size = 32
_data_buffer$ = -492					; size = 256
_input_buffer$ = -228					; size = 160
_tce_db$ = -60						; size = 2
_tne_db$ = -48						; size = 2
_Ltce$ = -36						; size = 4
_Ltne$ = -24						; size = 4
_Lenrg$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_farray_ptr$ = 8					; size = 4
_st$ = 12						; size = 4
_vad2	PROC						; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 04 00
	00		 sub	 esp, 1080		; 00000438H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1080]
  00012	b9 0e 01 00 00	 mov	 ecx, 270		; 0000010eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 206  : 
; 207  : 	/*
; 208  : 	 * The channel table is defined below.  In this table, the
; 209  : 	 * lower and higher frequency coefficients for each of the 16
; 210  : 	 * channels are specified.  The table excludes the coefficients
; 211  : 	 * with numbers 0 (DC), 1, and 64 (Foldover frequency).
; 212  : 	 */
; 213  : 
; 214  : 	static Word16 ch_tbl[NUM_CHAN][2] =
; 215  : 	{
; 216  : 
; 217  : 		{2, 3},
; 218  : 		{4, 5},
; 219  : 		{6, 7},
; 220  : 		{8, 9},
; 221  : 		{10, 11},
; 222  : 		{12, 13},
; 223  : 		{14, 16},
; 224  : 		{17, 19},
; 225  : 		{20, 22},
; 226  : 		{23, 26},
; 227  : 		{27, 30},
; 228  : 		{31, 35},
; 229  : 		{36, 41},
; 230  : 		{42, 48},
; 231  : 		{49, 55},
; 232  : 		{56, 63}
; 233  : 
; 234  : 	};
; 235  : 
; 236  : 	/* channel energy scaling table - allows efficient division by number
; 237  :          * of DFT bins in the channel: 1/2, 1/3, 1/4, etc.
; 238  : 	 */
; 239  : 
; 240  : 	static Word16 ch_tbl_sh[NUM_CHAN] =
; 241  : 	{
; 242  : 		16384, 16384, 16384, 16384, 16384, 16384, 10923, 10923,
; 243  : 		10923, 8192, 8192, 6554, 5461, 4681, 4681, 4096
; 244  : 	};
; 245  : 
; 246  : 	/*
; 247  : 	 * The voice metric table is defined below.  It is a non-
; 248  : 	 * linear table with a deadband near zero.  It maps the SNR
; 249  : 	 * index (quantized SNR value) to a number that is a measure
; 250  : 	 * of voice quality.
; 251  : 	 */
; 252  : 
; 253  : 	static Word16 vm_tbl[90] =
; 254  : 	{
; 255  : 		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
; 256  : 		3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7,
; 257  : 		8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15,
; 258  : 		15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 24,
; 259  : 		24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34,
; 260  : 		35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45,
; 261  : 		46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50,
; 262  : 		50, 50
; 263  : 	};
; 264  : 
; 265  : 	/* hangover as a function of peak SNR (3 dB steps) */
; 266  : 	static Word16 hangover_table[20] =
; 267  : 	{
; 268  : 		30, 30, 30, 30, 30, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 8, 8, 8
; 269  : 	};
; 270  : 
; 271  : 	/* burst sensitivity as a function of peak SNR (3 dB steps) */
; 272  : 	static Word16 burstcount_table[20] =
; 273  : 	{
; 274  : 		8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4
; 275  : 	};
; 276  : 
; 277  : 	/* voice metric sensitivity as a function of peak SNR (3 dB steps) */
; 278  : 	static Word16 vm_threshold_table[20] =
; 279  : 	{
; 280  :                 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 40, 51, 71, 100, 139, 191, 257, 337, 432
; 281  : 	};
; 282  : 
; 283  : 
; 284  : 	/* State tables that use 22,9 or 27,4 scaling for ch_enrg[] */
; 285  : 
; 286  : 	static Word16 noise_floor_chan[2] =	{NOISE_FLOOR_CHAN_0, NOISE_FLOOR_CHAN_1};
; 287  : 	static Word16 min_chan_enrg[2] =	{MIN_CHAN_ENRG_0, MIN_CHAN_ENRG_1};
; 288  : 	static Word16 ine_noise[2] = 		{INE_NOISE_0, INE_NOISE_1};
; 289  : 	static Word16 fbits[2] = 		{FRACTIONAL_BITS_0, FRACTIONAL_BITS_1};
; 290  : 	static Word16 state_change_shift_r[2] = {STATE_1_TO_0_SHIFT_R, STATE_0_TO_1_SHIFT_R};
; 291  : 
; 292  : 	/* Energy scale table given 30,1 input scaling (also account for -6 dB shift on input) */
; 293  : 	static Word16 enrg_norm_shift[2] = 	{(FRACTIONAL_BITS_0-1+2), (FRACTIONAL_BITS_1-1+2)};
; 294  : 
; 295  : 
; 296  : 	/* Automatic variables */
; 297  : 
; 298  : 	Word32 Lenrg;				/* scaled as 30,1 */
; 299  : 	Word32 Ltne;				/* scaled as 22,9 */
; 300  : 	Word32 Ltce;				/* scaled as 22,9 or 27,4 */
; 301  : 
; 302  : 	Word16 tne_db;				/* scaled as 7,8 */
; 303  : 	Word16 tce_db;				/* scaled as 7,8 */
; 304  : 
; 305  : 	Word16 input_buffer[FRM_LEN];		/* used for block normalising input data */
; 306  : 	Word16 data_buffer[FFT_LEN];		/* used for in-place FFT */
; 307  : 
; 308  : 	Word16 ch_snr[NUM_CHAN];		/* scaled as 7,8 */
; 309  : 	Word16 ch_snrq;				/* scaled as 15,0 (in 0.375 dB steps) */
; 310  : 	Word16 vm_sum;				/* scaled as 15,0 */
; 311  : 	Word16 ch_enrg_dev;			/* scaled as 7,8 */
; 312  : 
; 313  : 	Word32 Lpeak;				/* maximum channel energy */
; 314  : 	Word16 p2a_flag;			/* flag to indicate spectral peak-to-average ratio > 10 dB */
; 315  : 
; 316  : 	Word16 ch_enrg_db[NUM_CHAN];		/* scaled as 7,8 */
; 317  : 	Word16 ch_noise_db;			/* scaled as 7,8 */
; 318  : 
; 319  : 	Word16 alpha;				/* scaled as 0,15 */
; 320  : 	Word16 one_m_alpha;			/* scaled as 0,15 */
; 321  : 	Word16 update_flag;			/* set to indicate a background noise estimate update */
; 322  : 
; 323  : 	Word16 i, j, j1, j2;			/* Scratch variables */
; 324  : 	Word16 hi1, lo1;
; 325  : 
; 326  : 	Word32 Ltmp, Ltmp1, Ltmp2;
; 327  : 	Word16 tmp;
; 328  : 
; 329  : 	Word16 normb_shift;		/* block norm shift count */
; 330  : 
; 331  : 	Word16 ivad;			/* intermediate VAD decision (return value) */
; 332  : 	Word16 tsnrq;			/* total signal-to-noise ratio (quantized 3 dB steps) scaled as 15,0 */
; 333  : 	Word16 xt;			/* instantaneous frame SNR in dB, scaled as 7,8 */
; 334  : 
; 335  : 	Word16 state_change;
; 336  : 
; 337  : 
; 338  : 	/* Increment frame counter */
; 339  : 	st->Lframe_cnt = L_add(st->Lframe_cnt, 1);

  00028	6a 01		 push	 1
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0002d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _L_add
  00036	83 c4 08	 add	 esp, 8
  00039	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  0003c	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 340  : 
; 341  : 	/* Block normalize the input */
; 342  : 	normb_shift = block_norm(farray_ptr, input_buffer, FRM_LEN, FFT_HEADROOM);

  0003f	6a 02		 push	 2
  00041	6a 50		 push	 80			; 00000050H
  00043	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _input_buffer$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _farray_ptr$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _block_norm
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	66 89 85 d4 fc
	ff ff		 mov	 WORD PTR _normb_shift$[ebp], ax

; 343  : 
; 344  : 	/* Pre-emphasize the input data and store in the data buffer with the appropriate offset */
; 345  : 	for (i = 0; i < DELAY; i++)

  0005d	33 c0		 xor	 eax, eax
  0005f	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00066	eb 12		 jmp	 SHORT $LN113@vad2
$LN112@vad2:
  00068	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  0006f	66 83 c0 01	 add	 ax, 1
  00073	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN113@vad2:
  0007a	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00081	83 f8 18	 cmp	 eax, 24			; 00000018H
  00084	7d 39		 jge	 SHORT $LN111@vad2

; 346  : 	{
; 347  : 		data_buffer[i] = 0;									move16();

  00086	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0008d	d1 e0		 shl	 eax, 1
  0008f	89 85 cc fb ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00095	81 bd cc fb ff
	ff 00 01 00 00	 cmp	 DWORD PTR $T1[ebp], 256	; 00000100H
  0009f	73 02		 jae	 SHORT $LN116@vad2
  000a1	eb 05		 jmp	 SHORT $LN117@vad2
$LN116@vad2:
  000a3	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN117@vad2:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	8b 95 cc fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000b0	66 89 8c 15 14
	fe ff ff	 mov	 WORD PTR _data_buffer$[ebp+edx], cx
  000b8	e8 00 00 00 00	 call	 _move16

; 348  : 	}

  000bd	eb a9		 jmp	 SHORT $LN112@vad2
$LN111@vad2:

; 349  : 
; 350  : 	st->pre_emp_mem = shr_r(st->pre_emp_mem, sub(st->last_normb_shift, normb_shift));

  000bf	0f b7 85 d4 fc
	ff ff		 movzx	 eax, WORD PTR _normb_shift$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  000ca	0f b7 91 ac 00
	00 00		 movzx	 edx, WORD PTR [ecx+172]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _sub
  000d7	83 c4 08	 add	 esp, 8
  000da	0f b7 c0	 movzx	 eax, ax
  000dd	50		 push	 eax
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  000e1	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _shr_r
  000ea	83 c4 08	 add	 esp, 8
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  000f0	66 89 01	 mov	 WORD PTR [ecx], ax

; 351  : 	st->last_normb_shift = normb_shift;								move16();

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  000f6	66 8b 8d d4 fc
	ff ff		 mov	 cx, WORD PTR _normb_shift$[ebp]
  000fd	66 89 88 ac 00
	00 00		 mov	 WORD PTR [eax+172], cx
  00104	e8 00 00 00 00	 call	 _move16

; 352  : 
; 353  : 	data_buffer[DELAY] = add(input_buffer[0], mult(PRE_EMP_FAC, st->pre_emp_mem));			move16();

  00109	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0010c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0010f	51		 push	 ecx
  00110	68 9a 99 ff ff	 push	 -26214			; ffff999aH
  00115	e8 00 00 00 00	 call	 _mult
  0011a	83 c4 08	 add	 esp, 8
  0011d	0f b7 d0	 movzx	 edx, ax
  00120	52		 push	 edx
  00121	b8 02 00 00 00	 mov	 eax, 2
  00126	6b c8 00	 imul	 ecx, eax, 0
  00129	0f b7 94 0d 1c
	ff ff ff	 movzx	 edx, WORD PTR _input_buffer$[ebp+ecx]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _add
  00137	83 c4 08	 add	 esp, 8
  0013a	b9 02 00 00 00	 mov	 ecx, 2
  0013f	6b d1 18	 imul	 edx, ecx, 24
  00142	66 89 84 15 14
	fe ff ff	 mov	 WORD PTR _data_buffer$[ebp+edx], ax
  0014a	e8 00 00 00 00	 call	 _move16

; 354  : 
; 355  : 	for (i = DELAY + 1, j = 1; i < DELAY + FRM_LEN; i++, j++)

  0014f	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  00154	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0015b	b9 01 00 00 00	 mov	 ecx, 1
  00160	66 89 8d 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], cx
  00167	eb 24		 jmp	 SHORT $LN110@vad2
$LN109@vad2:
  00169	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00170	66 83 c0 01	 add	 ax, 1
  00174	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0017b	66 8b 8d 40 fd
	ff ff		 mov	 cx, WORD PTR _j$[ebp]
  00182	66 83 c1 01	 add	 cx, 1
  00186	66 89 8d 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], cx
$LN110@vad2:
  0018d	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00194	83 f8 68	 cmp	 eax, 104		; 00000068H
  00197	7d 4f		 jge	 SHORT $LN108@vad2

; 356  : 	{
; 357  : 		data_buffer[i] = add(input_buffer[j], mult(PRE_EMP_FAC, input_buffer[j-1]));		move16();

  00199	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  001a0	0f b7 8c 45 1a
	ff ff ff	 movzx	 ecx, WORD PTR _input_buffer$[ebp+eax*2-2]
  001a8	51		 push	 ecx
  001a9	68 9a 99 ff ff	 push	 -26214			; ffff999aH
  001ae	e8 00 00 00 00	 call	 _mult
  001b3	83 c4 08	 add	 esp, 8
  001b6	0f b7 d0	 movzx	 edx, ax
  001b9	52		 push	 edx
  001ba	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  001c1	0f b7 8c 45 1c
	ff ff ff	 movzx	 ecx, WORD PTR _input_buffer$[ebp+eax*2]
  001c9	51		 push	 ecx
  001ca	e8 00 00 00 00	 call	 _add
  001cf	83 c4 08	 add	 esp, 8
  001d2	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  001d9	66 89 84 55 14
	fe ff ff	 mov	 WORD PTR _data_buffer$[ebp+edx*2], ax
  001e1	e8 00 00 00 00	 call	 _move16

; 358  : 	}

  001e6	eb 81		 jmp	 SHORT $LN109@vad2
$LN108@vad2:

; 359  : 	st->pre_emp_mem = input_buffer[FRM_LEN-1];							move16();

  001e8	b8 02 00 00 00	 mov	 eax, 2
  001ed	6b c8 4f	 imul	 ecx, eax, 79
  001f0	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  001f3	66 8b 84 0d 1c
	ff ff ff	 mov	 ax, WORD PTR _input_buffer$[ebp+ecx]
  001fb	66 89 02	 mov	 WORD PTR [edx], ax
  001fe	e8 00 00 00 00	 call	 _move16

; 360  : 
; 361  : 	for (i = DELAY + FRM_LEN; i < FFT_LEN; i++)

  00203	b8 68 00 00 00	 mov	 eax, 104		; 00000068H
  00208	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0020f	eb 12		 jmp	 SHORT $LN107@vad2
$LN106@vad2:
  00211	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00218	66 83 c0 01	 add	 ax, 1
  0021c	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN107@vad2:
  00223	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0022a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0022f	7d 39		 jge	 SHORT $LN105@vad2

; 362  : 	{
; 363  : 		data_buffer[i] = 0;									move16();

  00231	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00238	d1 e0		 shl	 eax, 1
  0023a	89 85 d8 fb ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00240	81 bd d8 fb ff
	ff 00 01 00 00	 cmp	 DWORD PTR $T2[ebp], 256	; 00000100H
  0024a	73 02		 jae	 SHORT $LN118@vad2
  0024c	eb 05		 jmp	 SHORT $LN119@vad2
$LN118@vad2:
  0024e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN119@vad2:
  00253	33 c9		 xor	 ecx, ecx
  00255	8b 95 d8 fb ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0025b	66 89 8c 15 14
	fe ff ff	 mov	 WORD PTR _data_buffer$[ebp+edx], cx
  00263	e8 00 00 00 00	 call	 _move16

; 364  : 	}

  00268	eb a7		 jmp	 SHORT $LN106@vad2
$LN105@vad2:

; 365  : 
; 366  : 
; 367  : 	/* Perform FFT on the data buffer */
; 368  : 	r_fft(data_buffer);

  0026a	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _data_buffer$[ebp]
  00270	50		 push	 eax
  00271	e8 00 00 00 00	 call	 _r_fft
  00276	83 c4 04	 add	 esp, 4

; 369  : 
; 370  : 
; 371  : 	/* Use normb_shift factor to determine the scaling of the energy estimates */
; 372  : 	state_change = 0;										move16();

  00279	33 c0		 xor	 eax, eax
  0027b	66 89 85 a4 fc
	ff ff		 mov	 WORD PTR _state_change$[ebp], ax
  00282	e8 00 00 00 00	 call	 _move16

; 373  : 													test();

  00287	e8 00 00 00 00	 call	 _test

; 374  : 	if (st->shift_state == 0)

  0028c	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0028f	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  00296	85 c9		 test	 ecx, ecx
  00298	75 45		 jne	 SHORT $LN104@vad2

; 375  : 	{												test();

  0029a	e8 00 00 00 00	 call	 _test

; 376  : 		if (sub(normb_shift, -FFT_HEADROOM+2) <= 0)

  0029f	6a 00		 push	 0
  002a1	0f b7 85 d4 fc
	ff ff		 movzx	 eax, WORD PTR _normb_shift$[ebp]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _sub
  002ae	83 c4 08	 add	 esp, 8
  002b1	0f bf c8	 movsx	 ecx, ax
  002b4	85 c9		 test	 ecx, ecx
  002b6	7f 25		 jg	 SHORT $LN103@vad2

; 377  : 		{
; 378  : 			state_change = 1;								move16();

  002b8	b8 01 00 00 00	 mov	 eax, 1
  002bd	66 89 85 a4 fc
	ff ff		 mov	 WORD PTR _state_change$[ebp], ax
  002c4	e8 00 00 00 00	 call	 _move16

; 379  : 			st->shift_state = 1;								move16();

  002c9	b8 01 00 00 00	 mov	 eax, 1
  002ce	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  002d1	66 89 81 ba 00
	00 00		 mov	 WORD PTR [ecx+186], ax
  002d8	e8 00 00 00 00	 call	 _move16
$LN103@vad2:

; 380  : 		}
; 381  : 	}
; 382  : 	else

  002dd	eb 40		 jmp	 SHORT $LN102@vad2
$LN104@vad2:

; 383  : 	{												test();

  002df	e8 00 00 00 00	 call	 _test

; 384  : 		if (sub(normb_shift, -FFT_HEADROOM+5) >= 0)

  002e4	6a 03		 push	 3
  002e6	0f b7 85 d4 fc
	ff ff		 movzx	 eax, WORD PTR _normb_shift$[ebp]
  002ed	50		 push	 eax
  002ee	e8 00 00 00 00	 call	 _sub
  002f3	83 c4 08	 add	 esp, 8
  002f6	0f bf c8	 movsx	 ecx, ax
  002f9	85 c9		 test	 ecx, ecx
  002fb	7c 22		 jl	 SHORT $LN102@vad2

; 385  : 		{
; 386  : 			state_change = 1;								move16();

  002fd	b8 01 00 00 00	 mov	 eax, 1
  00302	66 89 85 a4 fc
	ff ff		 mov	 WORD PTR _state_change$[ebp], ax
  00309	e8 00 00 00 00	 call	 _move16

; 387  : 			st->shift_state = 0;								move16();

  0030e	33 c0		 xor	 eax, eax
  00310	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00313	66 89 81 ba 00
	00 00		 mov	 WORD PTR [ecx+186], ax
  0031a	e8 00 00 00 00	 call	 _move16
$LN102@vad2:

; 388  : 		}
; 389  : 	}
; 390  : 
; 391  : 	/* Scale channel energy estimate */								test();

  0031f	e8 00 00 00 00	 call	 _test

; 392  : 	if (state_change)

  00324	0f bf 85 a4 fc
	ff ff		 movsx	 eax, WORD PTR _state_change$[ebp]
  0032b	85 c0		 test	 eax, eax
  0032d	74 68		 je	 SHORT $LN100@vad2

; 393  : 	{
; 394  : 		for (i = LO_CHAN; i <= HI_CHAN; i++)

  0032f	33 c0		 xor	 eax, eax
  00331	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00338	eb 12		 jmp	 SHORT $LN99@vad2
$LN98@vad2:
  0033a	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00341	66 83 c0 01	 add	 ax, 1
  00345	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN99@vad2:
  0034c	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00353	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00356	7f 3f		 jg	 SHORT $LN100@vad2

; 395  : 		{
; 396  : 			st->Lch_enrg[i] = L_shr(st->Lch_enrg[i], state_change_shift_r[st->shift_state]);	move32();

  00358	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0035b	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  00362	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?state_change_shift_r@?1??vad2@@9@9[ecx*2]
  0036a	52		 push	 edx
  0036b	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00372	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00375	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  00379	52		 push	 edx
  0037a	e8 00 00 00 00	 call	 _L_shr
  0037f	83 c4 08	 add	 esp, 8
  00382	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00389	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  0038c	89 44 8a 2c	 mov	 DWORD PTR [edx+ecx*4+44], eax
  00390	e8 00 00 00 00	 call	 _move32

; 397  : 		}

  00395	eb a3		 jmp	 SHORT $LN98@vad2
$LN100@vad2:

; 398  : 	}
; 399  : 
; 400  : 
; 401  : 	/* Estimate the energy in each channel */
; 402  : 													test();

  00397	e8 00 00 00 00	 call	 _test

; 403  : 	if (L_sub(st->Lframe_cnt, 1) == 0)

  0039c	6a 01		 push	 1
  0039e	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  003a1	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  003a4	51		 push	 ecx
  003a5	e8 00 00 00 00	 call	 _L_sub
  003aa	83 c4 08	 add	 esp, 8
  003ad	85 c0		 test	 eax, eax
  003af	75 21		 jne	 SHORT $LN96@vad2

; 404  : 	{
; 405  : 		alpha = 32767;										move16();

  003b1	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  003b6	66 89 85 70 fd
	ff ff		 mov	 WORD PTR _alpha$[ebp], ax
  003bd	e8 00 00 00 00	 call	 _move16

; 406  : 		one_m_alpha = 0;									move16();

  003c2	33 c0		 xor	 eax, eax
  003c4	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _one_m_alpha$[ebp], ax
  003cb	e8 00 00 00 00	 call	 _move16

; 407  : 	}
; 408  : 	else

  003d0	eb 22		 jmp	 SHORT $LN95@vad2
$LN96@vad2:

; 409  : 	{
; 410  : 		alpha = CEE_SM_FAC;									move16();

  003d2	b8 66 46 00 00	 mov	 eax, 18022		; 00004666H
  003d7	66 89 85 70 fd
	ff ff		 mov	 WORD PTR _alpha$[ebp], ax
  003de	e8 00 00 00 00	 call	 _move16

; 411  : 		one_m_alpha = ONE_MINUS_CEE_SM_FAC;							move16();

  003e3	b8 9a 39 00 00	 mov	 eax, 14746		; 0000399aH
  003e8	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _one_m_alpha$[ebp], ax
  003ef	e8 00 00 00 00	 call	 _move16
$LN95@vad2:

; 412  : 	}
; 413  : 
; 414  : 	for (i = LO_CHAN; i <= HI_CHAN; i++)

  003f4	33 c0		 xor	 eax, eax
  003f6	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  003fd	eb 12		 jmp	 SHORT $LN94@vad2
$LN93@vad2:
  003ff	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00406	66 83 c0 01	 add	 ax, 1
  0040a	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN94@vad2:
  00411	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00418	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0041b	0f 8f 61 02 00
	00		 jg	 $LN92@vad2

; 415  : 	{
; 416  : 		Lenrg = 0;										move16();

  00421	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Lenrg$[ebp], 0
  00428	e8 00 00 00 00	 call	 _move16

; 417  : 		j1 = ch_tbl[i][0];									move16();

  0042d	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00434	b9 02 00 00 00	 mov	 ecx, 2
  00439	6b d1 00	 imul	 edx, ecx, 0
  0043c	66 8b 84 82 00
	00 00 00	 mov	 ax, WORD PTR ?ch_tbl@?1??vad2@@9@9[edx+eax*4]
  00444	66 89 85 34 fd
	ff ff		 mov	 WORD PTR _j1$[ebp], ax
  0044b	e8 00 00 00 00	 call	 _move16

; 418  : 		j2 = ch_tbl[i][1];									move16();

  00450	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00457	b9 02 00 00 00	 mov	 ecx, 2
  0045c	c1 e1 00	 shl	 ecx, 0
  0045f	66 8b 94 81 00
	00 00 00	 mov	 dx, WORD PTR ?ch_tbl@?1??vad2@@9@9[ecx+eax*4]
  00467	66 89 95 28 fd
	ff ff		 mov	 WORD PTR _j2$[ebp], dx
  0046e	e8 00 00 00 00	 call	 _move16

; 419  : 
; 420  : 		for (j = j1; j <= j2; j++)

  00473	66 8b 85 34 fd
	ff ff		 mov	 ax, WORD PTR _j1$[ebp]
  0047a	66 89 85 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00481	eb 12		 jmp	 SHORT $LN91@vad2
$LN90@vad2:
  00483	66 8b 85 40 fd
	ff ff		 mov	 ax, WORD PTR _j$[ebp]
  0048a	66 83 c0 01	 add	 ax, 1
  0048e	66 89 85 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], ax
$LN91@vad2:
  00495	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  0049c	0f bf 8d 28 fd
	ff ff		 movsx	 ecx, WORD PTR _j2$[ebp]
  004a3	3b c1		 cmp	 eax, ecx
  004a5	7f 6b		 jg	 SHORT $LN89@vad2

; 421  : 		{
; 422  : 			Lenrg = L_mac(Lenrg, data_buffer[2 * j], data_buffer[2 * j]);

  004a7	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  004ae	d1 e0		 shl	 eax, 1
  004b0	0f b7 8c 45 14
	fe ff ff	 movzx	 ecx, WORD PTR _data_buffer$[ebp+eax*2]
  004b8	51		 push	 ecx
  004b9	0f bf 95 40 fd
	ff ff		 movsx	 edx, WORD PTR _j$[ebp]
  004c0	d1 e2		 shl	 edx, 1
  004c2	0f b7 84 55 14
	fe ff ff	 movzx	 eax, WORD PTR _data_buffer$[ebp+edx*2]
  004ca	50		 push	 eax
  004cb	8b 4d f4	 mov	 ecx, DWORD PTR _Lenrg$[ebp]
  004ce	51		 push	 ecx
  004cf	e8 00 00 00 00	 call	 _L_mac
  004d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d7	89 45 f4	 mov	 DWORD PTR _Lenrg$[ebp], eax

; 423  : 			Lenrg = L_mac(Lenrg, data_buffer[2 * j + 1], data_buffer[2 * j + 1]);

  004da	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  004e1	d1 e0		 shl	 eax, 1
  004e3	0f b7 8c 45 16
	fe ff ff	 movzx	 ecx, WORD PTR _data_buffer$[ebp+eax*2+2]
  004eb	51		 push	 ecx
  004ec	0f bf 95 40 fd
	ff ff		 movsx	 edx, WORD PTR _j$[ebp]
  004f3	d1 e2		 shl	 edx, 1
  004f5	0f b7 84 55 16
	fe ff ff	 movzx	 eax, WORD PTR _data_buffer$[ebp+edx*2+2]
  004fd	50		 push	 eax
  004fe	8b 4d f4	 mov	 ecx, DWORD PTR _Lenrg$[ebp]
  00501	51		 push	 ecx
  00502	e8 00 00 00 00	 call	 _L_mac
  00507	83 c4 0c	 add	 esp, 12			; 0000000cH
  0050a	89 45 f4	 mov	 DWORD PTR _Lenrg$[ebp], eax

; 424  : 		}

  0050d	e9 71 ff ff ff	 jmp	 $LN90@vad2
$LN89@vad2:

; 425  : 
; 426  : 		/* Denorm energy & scale 30,1 according to the state */
; 427  : 		Lenrg = L_shr_r(Lenrg, sub(shl(normb_shift, 1), enrg_norm_shift[st->shift_state]));

  00512	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00515	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  0051c	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?enrg_norm_shift@?1??vad2@@9@9[ecx*2]
  00524	52		 push	 edx
  00525	6a 01		 push	 1
  00527	0f b7 85 d4 fc
	ff ff		 movzx	 eax, WORD PTR _normb_shift$[ebp]
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 _shl
  00534	83 c4 08	 add	 esp, 8
  00537	0f b7 c8	 movzx	 ecx, ax
  0053a	51		 push	 ecx
  0053b	e8 00 00 00 00	 call	 _sub
  00540	83 c4 08	 add	 esp, 8
  00543	0f b7 d0	 movzx	 edx, ax
  00546	52		 push	 edx
  00547	8b 45 f4	 mov	 eax, DWORD PTR _Lenrg$[ebp]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 _L_shr_r
  00550	83 c4 08	 add	 esp, 8
  00553	89 45 f4	 mov	 DWORD PTR _Lenrg$[ebp], eax

; 428  : 
; 429  : 		/* integrate over time: e[i] = (1-alpha)*e[i] + alpha*enrg/num_bins_in_chan */
; 430  : 		tmp = mult(alpha, ch_tbl_sh[i]);

  00556	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0055d	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?ch_tbl_sh@?1??vad2@@9@9[eax*2]
  00565	51		 push	 ecx
  00566	0f b7 95 70 fd
	ff ff		 movzx	 edx, WORD PTR _alpha$[ebp]
  0056d	52		 push	 edx
  0056e	e8 00 00 00 00	 call	 _mult
  00573	83 c4 08	 add	 esp, 8
  00576	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax

; 431  : 		L_Extract (Lenrg, &hi1, &lo1);

  0057d	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  00583	50		 push	 eax
  00584	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  0058a	51		 push	 ecx
  0058b	8b 55 f4	 mov	 edx, DWORD PTR _Lenrg$[ebp]
  0058e	52		 push	 edx
  0058f	e8 00 00 00 00	 call	 _L_Extract
  00594	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		Ltmp = Mpy_32_16(hi1, lo1, tmp);

  00597	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  0059e	50		 push	 eax
  0059f	0f b7 8d 10 fd
	ff ff		 movzx	 ecx, WORD PTR _lo1$[ebp]
  005a6	51		 push	 ecx
  005a7	0f b7 95 1c fd
	ff ff		 movzx	 edx, WORD PTR _hi1$[ebp]
  005ae	52		 push	 edx
  005af	e8 00 00 00 00	 call	 _Mpy_32_16
  005b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b7	89 85 04 fd ff
	ff		 mov	 DWORD PTR _Ltmp$[ebp], eax

; 433  : 
; 434  : 		L_Extract (st->Lch_enrg[i], &hi1, &lo1);

  005bd	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  005c3	50		 push	 eax
  005c4	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  005ca	51		 push	 ecx
  005cb	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  005d2	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  005d5	8b 4c 90 2c	 mov	 ecx, DWORD PTR [eax+edx*4+44]
  005d9	51		 push	 ecx
  005da	e8 00 00 00 00	 call	 _L_Extract
  005df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 		st->Lch_enrg[i] = L_add(Ltmp, Mpy_32_16(hi1, lo1, one_m_alpha));			move32();

  005e2	0f b7 85 64 fd
	ff ff		 movzx	 eax, WORD PTR _one_m_alpha$[ebp]
  005e9	50		 push	 eax
  005ea	0f b7 8d 10 fd
	ff ff		 movzx	 ecx, WORD PTR _lo1$[ebp]
  005f1	51		 push	 ecx
  005f2	0f b7 95 1c fd
	ff ff		 movzx	 edx, WORD PTR _hi1$[ebp]
  005f9	52		 push	 edx
  005fa	e8 00 00 00 00	 call	 _Mpy_32_16
  005ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00602	50		 push	 eax
  00603	8b 85 04 fd ff
	ff		 mov	 eax, DWORD PTR _Ltmp$[ebp]
  00609	50		 push	 eax
  0060a	e8 00 00 00 00	 call	 _L_add
  0060f	83 c4 08	 add	 esp, 8
  00612	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00619	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  0061c	89 44 8a 2c	 mov	 DWORD PTR [edx+ecx*4+44], eax
  00620	e8 00 00 00 00	 call	 _move32

; 436  : 													test();

  00625	e8 00 00 00 00	 call	 _test

; 437  : 		if (L_sub(st->Lch_enrg[i], min_chan_enrg[st->shift_state]) < 0)

  0062a	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0062d	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  00634	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?min_chan_enrg@?1??vad2@@9@9[ecx*2]
  0063c	52		 push	 edx
  0063d	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00644	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00647	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  0064b	52		 push	 edx
  0064c	e8 00 00 00 00	 call	 _L_sub
  00651	83 c4 08	 add	 esp, 8
  00654	85 c0		 test	 eax, eax
  00656	7d 25		 jge	 SHORT $LN88@vad2

; 438  : 		{
; 439  : 			st->Lch_enrg[i] = min_chan_enrg[st->shift_state];				move32();

  00658	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0065b	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  00662	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  00669	0f bf 04 4d 00
	00 00 00	 movsx	 eax, WORD PTR ?min_chan_enrg@?1??vad2@@9@9[ecx*2]
  00671	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00674	89 44 91 2c	 mov	 DWORD PTR [ecx+edx*4+44], eax
  00678	e8 00 00 00 00	 call	 _move32
$LN88@vad2:

; 440  : 		}
; 441  : 
; 442  : 	}

  0067d	e9 7d fd ff ff	 jmp	 $LN93@vad2
$LN92@vad2:

; 443  : 
; 444  : 
; 445  : 	/* Compute the total channel energy estimate (Ltce) */
; 446  : 	Ltce = 0;											move16();

  00682	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Ltce$[ebp], 0
  00689	e8 00 00 00 00	 call	 _move16

; 447  : 	for (i = LO_CHAN; i <= HI_CHAN; i++)

  0068e	33 c0		 xor	 eax, eax
  00690	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00697	eb 12		 jmp	 SHORT $LN87@vad2
$LN86@vad2:
  00699	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  006a0	66 83 c0 01	 add	 ax, 1
  006a4	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN87@vad2:
  006ab	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  006b2	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  006b5	7f 20		 jg	 SHORT $LN85@vad2

; 448  : 	{
; 449  : 		Ltce = L_add(Ltce, st->Lch_enrg[i]);

  006b7	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  006be	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  006c1	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  006c5	52		 push	 edx
  006c6	8b 45 dc	 mov	 eax, DWORD PTR _Ltce$[ebp]
  006c9	50		 push	 eax
  006ca	e8 00 00 00 00	 call	 _L_add
  006cf	83 c4 08	 add	 esp, 8
  006d2	89 45 dc	 mov	 DWORD PTR _Ltce$[ebp], eax

; 450  : 	}

  006d5	eb c2		 jmp	 SHORT $LN86@vad2
$LN85@vad2:

; 451  : 
; 452  : 
; 453  : 	/* Calculate spectral peak-to-average ratio, set flag if p2a > 10 dB */
; 454  : 	Lpeak = 0;											move32();

  006d7	c7 85 bc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _Lpeak$[ebp], 0
  006e1	e8 00 00 00 00	 call	 _move32

; 455  : 	for (i = LO_CHAN+2; i <= HI_CHAN; i++)	/* Sine waves not valid for low frequencies */

  006e6	b8 02 00 00 00	 mov	 eax, 2
  006eb	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  006f2	eb 12		 jmp	 SHORT $LN84@vad2
$LN83@vad2:
  006f4	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  006fb	66 83 c0 01	 add	 ax, 1
  006ff	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN84@vad2:
  00706	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0070d	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00710	7f 42		 jg	 SHORT $LN82@vad2

; 456  : 	{												test();

  00712	e8 00 00 00 00	 call	 _test

; 457  : 		if (L_sub(st->Lch_enrg [i], Lpeak) > 0)

  00717	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _Lpeak$[ebp]
  0071d	50		 push	 eax
  0071e	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00725	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  00728	8b 44 8a 2c	 mov	 eax, DWORD PTR [edx+ecx*4+44]
  0072c	50		 push	 eax
  0072d	e8 00 00 00 00	 call	 _L_sub
  00732	83 c4 08	 add	 esp, 8
  00735	85 c0		 test	 eax, eax
  00737	7e 19		 jle	 SHORT $LN81@vad2

; 458  : 		{
; 459  : 			Lpeak = st->Lch_enrg [i];							move32();

  00739	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00740	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00743	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  00747	89 95 bc fd ff
	ff		 mov	 DWORD PTR _Lpeak$[ebp], edx
  0074d	e8 00 00 00 00	 call	 _move32
$LN81@vad2:

; 460  : 		}
; 461  : 	}

  00752	eb a0		 jmp	 SHORT $LN83@vad2
$LN82@vad2:

; 462  : 
; 463  : 	/* Set p2a_flag if peak (dB) > average channel energy (dB) + 10 dB */
; 464  : 	/*   Lpeak > Ltce/num_channels * 10^(10/10)                        */
; 465  : 	/*   Lpeak > (10/16)*Ltce                                          */
; 466  : 
; 467  : 	L_Extract (Ltce, &hi1, &lo1);

  00754	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  0075a	50		 push	 eax
  0075b	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  00761	51		 push	 ecx
  00762	8b 55 dc	 mov	 edx, DWORD PTR _Ltce$[ebp]
  00765	52		 push	 edx
  00766	e8 00 00 00 00	 call	 _L_Extract
  0076b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 	Ltmp = Mpy_32_16(hi1, lo1, 20480);

  0076e	68 00 50 00 00	 push	 20480			; 00005000H
  00773	0f b7 85 10 fd
	ff ff		 movzx	 eax, WORD PTR _lo1$[ebp]
  0077a	50		 push	 eax
  0077b	0f b7 8d 1c fd
	ff ff		 movzx	 ecx, WORD PTR _hi1$[ebp]
  00782	51		 push	 ecx
  00783	e8 00 00 00 00	 call	 _Mpy_32_16
  00788	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078b	89 85 04 fd ff
	ff		 mov	 DWORD PTR _Ltmp$[ebp], eax

; 469  : 													test();

  00791	e8 00 00 00 00	 call	 _test

; 470  : 	if (L_sub(Lpeak, Ltmp) > 0)

  00796	8b 85 04 fd ff
	ff		 mov	 eax, DWORD PTR _Ltmp$[ebp]
  0079c	50		 push	 eax
  0079d	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR _Lpeak$[ebp]
  007a3	51		 push	 ecx
  007a4	e8 00 00 00 00	 call	 _L_sub
  007a9	83 c4 08	 add	 esp, 8
  007ac	85 c0		 test	 eax, eax
  007ae	7e 13		 jle	 SHORT $LN80@vad2

; 471  : 	{
; 472  : 		p2a_flag = TRUE;									move16();

  007b0	b8 01 00 00 00	 mov	 eax, 1
  007b5	66 89 85 b0 fd
	ff ff		 mov	 WORD PTR _p2a_flag$[ebp], ax
  007bc	e8 00 00 00 00	 call	 _move16

; 473  : 	}
; 474  : 	else

  007c1	eb 0e		 jmp	 SHORT $LN79@vad2
$LN80@vad2:

; 475  : 	{
; 476  : 		p2a_flag = FALSE;									move16();

  007c3	33 c0		 xor	 eax, eax
  007c5	66 89 85 b0 fd
	ff ff		 mov	 WORD PTR _p2a_flag$[ebp], ax
  007cc	e8 00 00 00 00	 call	 _move16
$LN79@vad2:

; 477  : 	}
; 478  : 
; 479  : 
; 480  : 	/* Initialize channel noise estimate to either the channel energy or fixed level  */
; 481  : 	/*   Scale the energy appropriately to yield state 0 (22,9) scaling for noise */
; 482  : 													test();

  007d1	e8 00 00 00 00	 call	 _test

; 483  : 	if (L_sub(st->Lframe_cnt, 4) <= 0)

  007d6	6a 04		 push	 4
  007d8	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  007db	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  007de	51		 push	 ecx
  007df	e8 00 00 00 00	 call	 _L_sub
  007e4	83 c4 08	 add	 esp, 8
  007e7	85 c0		 test	 eax, eax
  007e9	0f 8f 47 01 00
	00		 jg	 $LN78@vad2

; 484  : 	{												test();

  007ef	e8 00 00 00 00	 call	 _test

; 485  : 		if (p2a_flag == TRUE)

  007f4	0f bf 85 b0 fd
	ff ff		 movsx	 eax, WORD PTR _p2a_flag$[ebp]
  007fb	83 f8 01	 cmp	 eax, 1
  007fe	75 47		 jne	 SHORT $LN77@vad2

; 486  : 		{
; 487  : 			for (i = LO_CHAN; i <= HI_CHAN; i++)

  00800	33 c0		 xor	 eax, eax
  00802	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00809	eb 12		 jmp	 SHORT $LN76@vad2
$LN75@vad2:
  0080b	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00812	66 83 c0 01	 add	 ax, 1
  00816	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN76@vad2:
  0081d	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00824	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00827	7f 19		 jg	 SHORT $LN74@vad2

; 488  : 			{
; 489  : 				st->Lch_noise[i] = INE_NOISE_0;						move32();

  00829	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00830	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00833	c7 44 81 6c 00
	20 00 00	 mov	 DWORD PTR [ecx+eax*4+108], 8192 ; 00002000H
  0083b	e8 00 00 00 00	 call	 _move32

; 490  : 			}

  00840	eb c9		 jmp	 SHORT $LN75@vad2
$LN74@vad2:

; 491  : 		}
; 492  : 		else

  00842	e9 ef 00 00 00	 jmp	 $LN78@vad2
$LN77@vad2:

; 493  : 		{
; 494  : 			for (i = LO_CHAN; i <= HI_CHAN; i++)

  00847	33 c0		 xor	 eax, eax
  00849	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00850	eb 12		 jmp	 SHORT $LN72@vad2
$LN71@vad2:
  00852	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00859	66 83 c0 01	 add	 ax, 1
  0085d	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN72@vad2:
  00864	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0086b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0086e	0f 8f c2 00 00
	00		 jg	 $LN78@vad2

; 495  : 			{										test();

  00874	e8 00 00 00 00	 call	 _test

; 496  : 				if (L_sub(st->Lch_enrg[i], ine_noise[st->shift_state]) < 0)

  00879	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0087c	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  00883	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?ine_noise@?1??vad2@@9@9[ecx*2]
  0088b	52		 push	 edx
  0088c	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00893	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00896	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  0089a	52		 push	 edx
  0089b	e8 00 00 00 00	 call	 _L_sub
  008a0	83 c4 08	 add	 esp, 8
  008a3	85 c0		 test	 eax, eax
  008a5	7d 19		 jge	 SHORT $LN69@vad2

; 497  : 				{
; 498  : 					st->Lch_noise[i] = INE_NOISE_0;					move32();

  008a7	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  008ae	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  008b1	c7 44 81 6c 00
	20 00 00	 mov	 DWORD PTR [ecx+eax*4+108], 8192 ; 00002000H
  008b9	e8 00 00 00 00	 call	 _move32

; 499  : 				}
; 500  : 				else

  008be	eb 71		 jmp	 SHORT $LN68@vad2
$LN69@vad2:

; 501  : 				{									test();

  008c0	e8 00 00 00 00	 call	 _test

; 502  : 					if (st->shift_state == 1)

  008c5	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  008c8	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  008cf	83 f9 01	 cmp	 ecx, 1
  008d2	75 3c		 jne	 SHORT $LN67@vad2

; 503  : 					{
; 504  : 						st->Lch_noise[i] = L_shr(st->Lch_enrg[i], state_change_shift_r[0]);

  008d4	b8 02 00 00 00	 mov	 eax, 2
  008d9	6b c8 00	 imul	 ecx, eax, 0
  008dc	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR ?state_change_shift_r@?1??vad2@@9@9[ecx]
  008e3	52		 push	 edx
  008e4	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  008eb	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  008ee	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  008f2	52		 push	 edx
  008f3	e8 00 00 00 00	 call	 _L_shr
  008f8	83 c4 08	 add	 esp, 8
  008fb	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00902	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  00905	89 44 8a 6c	 mov	 DWORD PTR [edx+ecx*4+108], eax

; 505  : 													move32();

  00909	e8 00 00 00 00	 call	 _move32

; 506  : 					}
; 507  : 					else

  0090e	eb 21		 jmp	 SHORT $LN68@vad2
$LN67@vad2:

; 508  : 					{
; 509  : 						st->Lch_noise[i] = st->Lch_enrg[i];			move32();

  00910	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00917	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  0091e	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  00921	8b 75 0c	 mov	 esi, DWORD PTR _st$[ebp]
  00924	8b 44 86 2c	 mov	 eax, DWORD PTR [esi+eax*4+44]
  00928	89 44 8a 6c	 mov	 DWORD PTR [edx+ecx*4+108], eax
  0092c	e8 00 00 00 00	 call	 _move32
$LN68@vad2:

; 510  : 					}
; 511  : 				}
; 512  : 			}

  00931	e9 1c ff ff ff	 jmp	 $LN71@vad2
$LN78@vad2:

; 513  : 		}
; 514  : 	}
; 515  : 
; 516  : 
; 517  : 	/* Compute the channel energy (in dB), the channel SNRs, and the sum of voice metrics */
; 518  : 	vm_sum = 0;											move16();

  00936	33 c0		 xor	 eax, eax
  00938	66 89 85 d4 fd
	ff ff		 mov	 WORD PTR _vm_sum$[ebp], ax
  0093f	e8 00 00 00 00	 call	 _move16

; 519  : 	for (i = LO_CHAN; i <= HI_CHAN; i++)

  00944	33 c0		 xor	 eax, eax
  00946	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0094d	eb 12		 jmp	 SHORT $LN65@vad2
$LN64@vad2:
  0094f	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00956	66 83 c0 01	 add	 ax, 1
  0095a	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN65@vad2:
  00961	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00968	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0096b	0f 8f 54 01 00
	00		 jg	 $LN63@vad2

; 520  : 	{
; 521  : 		ch_enrg_db[i] = fn10Log10(st->Lch_enrg[i], fbits[st->shift_state]);			move16();

  00971	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00974	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  0097b	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?fbits@?1??vad2@@9@9[ecx*2]
  00983	52		 push	 edx
  00984	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0098b	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  0098e	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  00992	52		 push	 edx
  00993	e8 00 00 00 00	 call	 _fn10Log10
  00998	83 c4 08	 add	 esp, 8
  0099b	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  009a2	66 89 84 4d 88
	fd ff ff	 mov	 WORD PTR _ch_enrg_db$[ebp+ecx*2], ax
  009aa	e8 00 00 00 00	 call	 _move16

; 522  : 		ch_noise_db = fn10Log10(st->Lch_noise[i], FRACTIONAL_BITS_0);

  009af	6a 09		 push	 9
  009b1	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  009b8	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  009bb	8b 54 81 6c	 mov	 edx, DWORD PTR [ecx+eax*4+108]
  009bf	52		 push	 edx
  009c0	e8 00 00 00 00	 call	 _fn10Log10
  009c5	83 c4 08	 add	 esp, 8
  009c8	66 89 85 7c fd
	ff ff		 mov	 WORD PTR _ch_noise_db$[ebp], ax

; 523  : 
; 524  : 		ch_snr[i] = sub(ch_enrg_db[i], ch_noise_db);						move16();

  009cf	0f b7 85 7c fd
	ff ff		 movzx	 eax, WORD PTR _ch_noise_db$[ebp]
  009d6	50		 push	 eax
  009d7	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  009de	0f b7 94 4d 88
	fd ff ff	 movzx	 edx, WORD PTR _ch_enrg_db$[ebp+ecx*2]
  009e6	52		 push	 edx
  009e7	e8 00 00 00 00	 call	 _sub
  009ec	83 c4 08	 add	 esp, 8
  009ef	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  009f6	66 89 84 4d ec
	fd ff ff	 mov	 WORD PTR _ch_snr$[ebp+ecx*2], ax
  009fe	e8 00 00 00 00	 call	 _move16

; 525  : 
; 526  : 		/* quantize channel SNR in 3/8 dB steps (scaled 7,8 => 15,0) */
; 527  : 		/*   ch_snr = round((snr/(3/8))>>8)                          */
; 528  : 		/*          = round(((0.6667*snr)<<2)>>8)                    */
; 529  : 		/*          = round((0.6667*snr)>>6)                         */
; 530  : 
; 531  : 		ch_snrq = shr_r(mult(21845, ch_snr[i]), 6);

  00a03	6a 06		 push	 6
  00a05	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00a0c	0f b7 8c 45 ec
	fd ff ff	 movzx	 ecx, WORD PTR _ch_snr$[ebp+eax*2]
  00a14	51		 push	 ecx
  00a15	68 55 55 00 00	 push	 21845			; 00005555H
  00a1a	e8 00 00 00 00	 call	 _mult
  00a1f	83 c4 08	 add	 esp, 8
  00a22	0f b7 d0	 movzx	 edx, ax
  00a25	52		 push	 edx
  00a26	e8 00 00 00 00	 call	 _shr_r
  00a2b	83 c4 08	 add	 esp, 8
  00a2e	66 89 85 e0 fd
	ff ff		 mov	 WORD PTR _ch_snrq$[ebp], ax

; 532  : 
; 533  : 		/* Accumulate the sum of voice metrics	*/						test();

  00a35	e8 00 00 00 00	 call	 _test

; 534  : 		if (sub(ch_snrq, 89) < 0)

  00a3a	6a 59		 push	 89			; 00000059H
  00a3c	0f b7 85 e0 fd
	ff ff		 movzx	 eax, WORD PTR _ch_snrq$[ebp]
  00a43	50		 push	 eax
  00a44	e8 00 00 00 00	 call	 _sub
  00a49	83 c4 08	 add	 esp, 8
  00a4c	0f bf c8	 movsx	 ecx, ax
  00a4f	85 c9		 test	 ecx, ecx
  00a51	7d 35		 jge	 SHORT $LN62@vad2

; 535  : 		{											test();

  00a53	e8 00 00 00 00	 call	 _test

; 536  : 			if (ch_snrq > 0)

  00a58	0f bf 85 e0 fd
	ff ff		 movsx	 eax, WORD PTR _ch_snrq$[ebp]
  00a5f	85 c0		 test	 eax, eax
  00a61	7e 15		 jle	 SHORT $LN61@vad2

; 537  : 			{
; 538  : 				j = ch_snrq;								move16();

  00a63	66 8b 85 e0 fd
	ff ff		 mov	 ax, WORD PTR _ch_snrq$[ebp]
  00a6a	66 89 85 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00a71	e8 00 00 00 00	 call	 _move16

; 539  : 			}
; 540  : 			else

  00a76	eb 0e		 jmp	 SHORT $LN60@vad2
$LN61@vad2:

; 541  : 			{
; 542  : 				j = 0;									move16();

  00a78	33 c0		 xor	 eax, eax
  00a7a	66 89 85 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00a81	e8 00 00 00 00	 call	 _move16
$LN60@vad2:

; 543  : 			}
; 544  : 		}
; 545  : 		else

  00a86	eb 11		 jmp	 SHORT $LN59@vad2
$LN62@vad2:

; 546  : 		{
; 547  : 			j = 89;										move16();

  00a88	b8 59 00 00 00	 mov	 eax, 89			; 00000059H
  00a8d	66 89 85 40 fd
	ff ff		 mov	 WORD PTR _j$[ebp], ax
  00a94	e8 00 00 00 00	 call	 _move16
$LN59@vad2:

; 548  : 		}
; 549  : 		vm_sum = add(vm_sum, vm_tbl[j]);

  00a99	0f bf 85 40 fd
	ff ff		 movsx	 eax, WORD PTR _j$[ebp]
  00aa0	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?vm_tbl@?1??vad2@@9@9[eax*2]
  00aa8	51		 push	 ecx
  00aa9	0f b7 95 d4 fd
	ff ff		 movzx	 edx, WORD PTR _vm_sum$[ebp]
  00ab0	52		 push	 edx
  00ab1	e8 00 00 00 00	 call	 _add
  00ab6	83 c4 08	 add	 esp, 8
  00ab9	66 89 85 d4 fd
	ff ff		 mov	 WORD PTR _vm_sum$[ebp], ax

; 550  : 	}

  00ac0	e9 8a fe ff ff	 jmp	 $LN64@vad2
$LN63@vad2:

; 551  : 
; 552  : 
; 553  : 	/* Initialize NOMINAL peak voice energy and average noise energy, calculate instantaneous SNR */ 
; 554  : 												test(),test(),logic16();

  00ac5	e8 00 00 00 00	 call	 _test
  00aca	e8 00 00 00 00	 call	 _test
  00acf	e8 00 00 00 00	 call	 _logic16

; 555  : 	if (L_sub(st->Lframe_cnt, 4) <= 0 || st->fupdate_flag == TRUE)

  00ad4	6a 04		 push	 4
  00ad6	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00ad9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00adc	51		 push	 ecx
  00add	e8 00 00 00 00	 call	 _L_sub
  00ae2	83 c4 08	 add	 esp, 8
  00ae5	85 c0		 test	 eax, eax
  00ae7	7e 13		 jle	 SHORT $LN57@vad2
  00ae9	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00aec	0f bf 88 b4 00
	00 00		 movsx	 ecx, WORD PTR [eax+180]
  00af3	83 f9 01	 cmp	 ecx, 1
  00af6	0f 85 cb 00 00
	00		 jne	 $LN58@vad2
$LN57@vad2:

; 556  : 	{
; 557  : 		/* tce_db = (96 - 22 - 10*log10(64) (due to FFT)) scaled as 7,8 */
; 558  : 		tce_db = 14320;										move16();

  00afc	b8 f0 37 00 00	 mov	 eax, 14320		; 000037f0H
  00b01	66 89 45 c4	 mov	 WORD PTR _tce_db$[ebp], ax
  00b05	e8 00 00 00 00	 call	 _move16

; 559  : 		st->negSNRvar = 0;									move16();

  00b0a	33 c0		 xor	 eax, eax
  00b0c	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00b0f	66 89 81 b6 00
	00 00		 mov	 WORD PTR [ecx+182], ax
  00b16	e8 00 00 00 00	 call	 _move16

; 560  : 		st->negSNRbias = 0;									move16();

  00b1b	33 c0		 xor	 eax, eax
  00b1d	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00b20	66 89 81 b8 00
	00 00		 mov	 WORD PTR [ecx+184], ax
  00b27	e8 00 00 00 00	 call	 _move16

; 561  : 
; 562  : 		/* Compute the total noise estimate (Ltne) */
; 563  : 		Ltne = 0;										move32();

  00b2c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Ltne$[ebp], 0
  00b33	e8 00 00 00 00	 call	 _move32

; 564  : 		for (i = LO_CHAN; i <= HI_CHAN; i++)

  00b38	33 c0		 xor	 eax, eax
  00b3a	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00b41	eb 12		 jmp	 SHORT $LN56@vad2
$LN55@vad2:
  00b43	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00b4a	66 83 c0 01	 add	 ax, 1
  00b4e	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN56@vad2:
  00b55	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00b5c	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00b5f	7f 20		 jg	 SHORT $LN54@vad2

; 565  : 		{
; 566  : 			Ltne = L_add(Ltne, st->Lch_noise[i]);

  00b61	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00b68	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00b6b	8b 54 81 6c	 mov	 edx, DWORD PTR [ecx+eax*4+108]
  00b6f	52		 push	 edx
  00b70	8b 45 e8	 mov	 eax, DWORD PTR _Ltne$[ebp]
  00b73	50		 push	 eax
  00b74	e8 00 00 00 00	 call	 _L_add
  00b79	83 c4 08	 add	 esp, 8
  00b7c	89 45 e8	 mov	 DWORD PTR _Ltne$[ebp], eax

; 567  : 		}

  00b7f	eb c2		 jmp	 SHORT $LN55@vad2
$LN54@vad2:

; 568  : 
; 569  : 		/* Get total noise in dB */
; 570  : 		tne_db = fn10Log10(Ltne, FRACTIONAL_BITS_0);

  00b81	6a 09		 push	 9
  00b83	8b 45 e8	 mov	 eax, DWORD PTR _Ltne$[ebp]
  00b86	50		 push	 eax
  00b87	e8 00 00 00 00	 call	 _fn10Log10
  00b8c	83 c4 08	 add	 esp, 8
  00b8f	66 89 45 d0	 mov	 WORD PTR _tne_db$[ebp], ax

; 571  : 
; 572  : 		/* Initialise instantaneous and long-term peak signal-to-noise ratios */
; 573  : 		xt = sub(tce_db, tne_db);

  00b93	0f b7 45 d0	 movzx	 eax, WORD PTR _tne_db$[ebp]
  00b97	50		 push	 eax
  00b98	0f b7 4d c4	 movzx	 ecx, WORD PTR _tce_db$[ebp]
  00b9c	51		 push	 ecx
  00b9d	e8 00 00 00 00	 call	 _sub
  00ba2	83 c4 08	 add	 esp, 8
  00ba5	66 89 85 b0 fc
	ff ff		 mov	 WORD PTR _xt$[ebp], ax

; 574  : 		st->tsnr = xt;										move16();

  00bac	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00baf	66 8b 8d b0 fc
	ff ff		 mov	 cx, WORD PTR _xt$[ebp]
  00bb6	66 89 88 ae 00
	00 00		 mov	 WORD PTR [eax+174], cx
  00bbd	e8 00 00 00 00	 call	 _move16

; 575  : 	}
; 576  : 	else

  00bc2	e9 db 01 00 00	 jmp	 $LN53@vad2
$LN58@vad2:

; 577  : 	{
; 578  : 		/* Calculate instantaneous frame signal-to-noise ratio */
; 579  : 		/* xt = 10*log10( sum(2.^(ch_snr*0.1*log2(10)))/length(ch_snr) ) */
; 580  : 		Ltmp1 = 0;										move32();

  00bc7	c7 85 f8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _Ltmp1$[ebp], 0
  00bd1	e8 00 00 00 00	 call	 _move32

; 581  : 		for (i=LO_CHAN; i<=HI_CHAN; i++) {

  00bd6	33 c0		 xor	 eax, eax
  00bd8	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00bdf	eb 12		 jmp	 SHORT $LN52@vad2
$LN51@vad2:
  00be1	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00be8	66 83 c0 01	 add	 ax, 1
  00bec	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN52@vad2:
  00bf3	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00bfa	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00bfd	0f 8f 97 00 00
	00		 jg	 $LN50@vad2

; 582  : 			/* Ltmp2 = ch_snr[i] * 0.1 * log2(10); (ch_snr scaled as 7,8) */
; 583  : 			Ltmp2 = L_shr(L_mult(ch_snr[i], 10885), 8);

  00c03	6a 08		 push	 8
  00c05	68 85 2a 00 00	 push	 10885			; 00002a85H
  00c0a	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00c11	0f b7 8c 45 ec
	fd ff ff	 movzx	 ecx, WORD PTR _ch_snr$[ebp+eax*2]
  00c19	51		 push	 ecx
  00c1a	e8 00 00 00 00	 call	 _L_mult
  00c1f	83 c4 08	 add	 esp, 8
  00c22	50		 push	 eax
  00c23	e8 00 00 00 00	 call	 _L_shr
  00c28	83 c4 08	 add	 esp, 8
  00c2b	89 85 ec fc ff
	ff		 mov	 DWORD PTR _Ltmp2$[ebp], eax

; 584  : 			L_Extract(Ltmp2, &hi1, &lo1);

  00c31	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  00c37	50		 push	 eax
  00c38	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  00c3e	51		 push	 ecx
  00c3f	8b 95 ec fc ff
	ff		 mov	 edx, DWORD PTR _Ltmp2$[ebp]
  00c45	52		 push	 edx
  00c46	e8 00 00 00 00	 call	 _L_Extract
  00c4b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 585  : 			hi1 = add(hi1, 3);			/* 2^3 to compensate for negative SNR */

  00c4e	6a 03		 push	 3
  00c50	0f b7 85 1c fd
	ff ff		 movzx	 eax, WORD PTR _hi1$[ebp]
  00c57	50		 push	 eax
  00c58	e8 00 00 00 00	 call	 _add
  00c5d	83 c4 08	 add	 esp, 8
  00c60	66 89 85 1c fd
	ff ff		 mov	 WORD PTR _hi1$[ebp], ax

; 586  : 			Ltmp1 = L_add(Ltmp1, Pow2(hi1, lo1));

  00c67	0f b7 85 10 fd
	ff ff		 movzx	 eax, WORD PTR _lo1$[ebp]
  00c6e	50		 push	 eax
  00c6f	0f b7 8d 1c fd
	ff ff		 movzx	 ecx, WORD PTR _hi1$[ebp]
  00c76	51		 push	 ecx
  00c77	e8 00 00 00 00	 call	 _Pow2
  00c7c	83 c4 08	 add	 esp, 8
  00c7f	50		 push	 eax
  00c80	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _Ltmp1$[ebp]
  00c86	52		 push	 edx
  00c87	e8 00 00 00 00	 call	 _L_add
  00c8c	83 c4 08	 add	 esp, 8
  00c8f	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _Ltmp1$[ebp], eax

; 587  : 		}

  00c95	e9 47 ff ff ff	 jmp	 $LN51@vad2
$LN50@vad2:

; 588  : 		xt = fn10Log10(Ltmp1, 4+3);			/* average by 16, inverse compensation 2^3 */

  00c9a	6a 07		 push	 7
  00c9c	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _Ltmp1$[ebp]
  00ca2	50		 push	 eax
  00ca3	e8 00 00 00 00	 call	 _fn10Log10
  00ca8	83 c4 08	 add	 esp, 8
  00cab	66 89 85 b0 fc
	ff ff		 mov	 WORD PTR _xt$[ebp], ax

; 589  : 
; 590  : 		/* Estimate long-term "peak" SNR */							test(),test();

  00cb2	e8 00 00 00 00	 call	 _test
  00cb7	e8 00 00 00 00	 call	 _test

; 591  : 		if (sub(xt, st->tsnr) > 0)

  00cbc	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00cbf	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  00cc6	51		 push	 ecx
  00cc7	0f b7 95 b0 fc
	ff ff		 movzx	 edx, WORD PTR _xt$[ebp]
  00cce	52		 push	 edx
  00ccf	e8 00 00 00 00	 call	 _sub
  00cd4	83 c4 08	 add	 esp, 8
  00cd7	98		 cwde
  00cd8	85 c0		 test	 eax, eax
  00cda	7e 4c		 jle	 SHORT $LN49@vad2

; 592  : 		{
; 593  : 			/* tsnr = 0.9*tsnr + 0.1*xt; */
; 594  : 			st->tsnr = round(L_add(L_mult(29491, st->tsnr), L_mult(3277, xt)));

  00cdc	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _xt$[ebp]
  00ce3	50		 push	 eax
  00ce4	68 cd 0c 00 00	 push	 3277			; 00000ccdH
  00ce9	e8 00 00 00 00	 call	 _L_mult
  00cee	83 c4 08	 add	 esp, 8
  00cf1	50		 push	 eax
  00cf2	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00cf5	0f b7 91 ae 00
	00 00		 movzx	 edx, WORD PTR [ecx+174]
  00cfc	52		 push	 edx
  00cfd	68 33 73 00 00	 push	 29491			; 00007333H
  00d02	e8 00 00 00 00	 call	 _L_mult
  00d07	83 c4 08	 add	 esp, 8
  00d0a	50		 push	 eax
  00d0b	e8 00 00 00 00	 call	 _L_add
  00d10	83 c4 08	 add	 esp, 8
  00d13	50		 push	 eax
  00d14	e8 00 00 00 00	 call	 _round
  00d19	83 c4 04	 add	 esp, 4
  00d1c	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00d1f	66 89 81 ae 00
	00 00		 mov	 WORD PTR [ecx+174], ax
  00d26	eb 7a		 jmp	 SHORT $LN53@vad2
$LN49@vad2:

; 595  : 		}
; 596  : 		/* else if (xt > 0.625*tsnr) */	
; 597  : 		else if (sub(xt, mult(20480, st->tsnr)) > 0)

  00d28	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00d2b	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  00d32	51		 push	 ecx
  00d33	68 00 50 00 00	 push	 20480			; 00005000H
  00d38	e8 00 00 00 00	 call	 _mult
  00d3d	83 c4 08	 add	 esp, 8
  00d40	0f b7 d0	 movzx	 edx, ax
  00d43	52		 push	 edx
  00d44	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _xt$[ebp]
  00d4b	50		 push	 eax
  00d4c	e8 00 00 00 00	 call	 _sub
  00d51	83 c4 08	 add	 esp, 8
  00d54	0f bf c8	 movsx	 ecx, ax
  00d57	85 c9		 test	 ecx, ecx
  00d59	7e 47		 jle	 SHORT $LN53@vad2

; 598  : 		{
; 599  : 			/* tsnr = 0.998*tsnr + 0.002*xt; */
; 600  : 			st->tsnr = round(L_add(L_mult(32702, st->tsnr), L_mult(66, xt)));

  00d5b	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _xt$[ebp]
  00d62	50		 push	 eax
  00d63	6a 42		 push	 66			; 00000042H
  00d65	e8 00 00 00 00	 call	 _L_mult
  00d6a	83 c4 08	 add	 esp, 8
  00d6d	50		 push	 eax
  00d6e	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00d71	0f b7 91 ae 00
	00 00		 movzx	 edx, WORD PTR [ecx+174]
  00d78	52		 push	 edx
  00d79	68 be 7f 00 00	 push	 32702			; 00007fbeH
  00d7e	e8 00 00 00 00	 call	 _L_mult
  00d83	83 c4 08	 add	 esp, 8
  00d86	50		 push	 eax
  00d87	e8 00 00 00 00	 call	 _L_add
  00d8c	83 c4 08	 add	 esp, 8
  00d8f	50		 push	 eax
  00d90	e8 00 00 00 00	 call	 _round
  00d95	83 c4 04	 add	 esp, 4
  00d98	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00d9b	66 89 81 ae 00
	00 00		 mov	 WORD PTR [ecx+174], ax
$LN53@vad2:

; 601  : 		}
; 602  : 	}
; 603  : 
; 604  : 	/* Quantize the long-term SNR in 3 dB steps, limit to 0 <= tsnrq <= 19 */
; 605  : 	tsnrq = shr(mult(st->tsnr, 10923), 8);

  00da2	6a 08		 push	 8
  00da4	68 ab 2a 00 00	 push	 10923			; 00002aabH
  00da9	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00dac	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  00db3	51		 push	 ecx
  00db4	e8 00 00 00 00	 call	 _mult
  00db9	83 c4 08	 add	 esp, 8
  00dbc	0f b7 d0	 movzx	 edx, ax
  00dbf	52		 push	 edx
  00dc0	e8 00 00 00 00	 call	 _shr
  00dc5	83 c4 08	 add	 esp, 8
  00dc8	66 89 85 bc fc
	ff ff		 mov	 WORD PTR _tsnrq$[ebp], ax

; 606  : 
; 607  : 	/* tsnrq = min(19, max(0, tsnrq)); */								test(),test();

  00dcf	e8 00 00 00 00	 call	 _test
  00dd4	e8 00 00 00 00	 call	 _test

; 608  : 	if (sub(tsnrq, 19) > 0)

  00dd9	6a 13		 push	 19			; 00000013H
  00ddb	0f b7 85 bc fc
	ff ff		 movzx	 eax, WORD PTR _tsnrq$[ebp]
  00de2	50		 push	 eax
  00de3	e8 00 00 00 00	 call	 _sub
  00de8	83 c4 08	 add	 esp, 8
  00deb	0f bf c8	 movsx	 ecx, ax
  00dee	85 c9		 test	 ecx, ecx
  00df0	7e 13		 jle	 SHORT $LN46@vad2

; 609  : 	{
; 610  : 		tsnrq = 19;										move16();

  00df2	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00df7	66 89 85 bc fc
	ff ff		 mov	 WORD PTR _tsnrq$[ebp], ax
  00dfe	e8 00 00 00 00	 call	 _move16
  00e03	eb 19		 jmp	 SHORT $LN45@vad2
$LN46@vad2:

; 611  : 	}
; 612  : 	else if (tsnrq < 0)

  00e05	0f bf 85 bc fc
	ff ff		 movsx	 eax, WORD PTR _tsnrq$[ebp]
  00e0c	85 c0		 test	 eax, eax
  00e0e	7d 0e		 jge	 SHORT $LN45@vad2

; 613  : 	{
; 614  : 		tsnrq = 0;										move16();

  00e10	33 c0		 xor	 eax, eax
  00e12	66 89 85 bc fc
	ff ff		 mov	 WORD PTR _tsnrq$[ebp], ax
  00e19	e8 00 00 00 00	 call	 _move16
$LN45@vad2:

; 615  : 	}
; 616  : 
; 617  : 	/* Calculate the negative SNR sensitivity bias */
; 618  : 													test();

  00e1e	e8 00 00 00 00	 call	 _test

; 619  : 	if (xt < 0)

  00e23	0f bf 85 b0 fc
	ff ff		 movsx	 eax, WORD PTR _xt$[ebp]
  00e2a	85 c0		 test	 eax, eax
  00e2c	0f 8d 32 01 00
	00		 jge	 $LN43@vad2

; 620  : 	{
; 621  : 		/* negSNRvar = 0.99*negSNRvar + 0.01*xt*xt; */
; 622  : 		/*   xt scaled as 7,8 => xt*xt scaled as 14,17, shift to 7,8 and round */
; 623  : 		tmp = round(L_shl(L_mult(xt, xt), 7));

  00e32	6a 07		 push	 7
  00e34	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _xt$[ebp]
  00e3b	50		 push	 eax
  00e3c	0f b7 8d b0 fc
	ff ff		 movzx	 ecx, WORD PTR _xt$[ebp]
  00e43	51		 push	 ecx
  00e44	e8 00 00 00 00	 call	 _L_mult
  00e49	83 c4 08	 add	 esp, 8
  00e4c	50		 push	 eax
  00e4d	e8 00 00 00 00	 call	 _L_shl
  00e52	83 c4 08	 add	 esp, 8
  00e55	50		 push	 eax
  00e56	e8 00 00 00 00	 call	 _round
  00e5b	83 c4 04	 add	 esp, 4
  00e5e	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax

; 624  : 		st->negSNRvar = round(L_add(L_mult(32440, st->negSNRvar), L_mult(328, tmp)));

  00e65	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  00e6c	50		 push	 eax
  00e6d	68 48 01 00 00	 push	 328			; 00000148H
  00e72	e8 00 00 00 00	 call	 _L_mult
  00e77	83 c4 08	 add	 esp, 8
  00e7a	50		 push	 eax
  00e7b	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00e7e	0f b7 91 b6 00
	00 00		 movzx	 edx, WORD PTR [ecx+182]
  00e85	52		 push	 edx
  00e86	68 b8 7e 00 00	 push	 32440			; 00007eb8H
  00e8b	e8 00 00 00 00	 call	 _L_mult
  00e90	83 c4 08	 add	 esp, 8
  00e93	50		 push	 eax
  00e94	e8 00 00 00 00	 call	 _L_add
  00e99	83 c4 08	 add	 esp, 8
  00e9c	50		 push	 eax
  00e9d	e8 00 00 00 00	 call	 _round
  00ea2	83 c4 04	 add	 esp, 4
  00ea5	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00ea8	66 89 81 b6 00
	00 00		 mov	 WORD PTR [ecx+182], ax

; 625  : 
; 626  : 		/* if (negSNRvar > 4.0) negSNRvar = 4.0;  */						test();

  00eaf	e8 00 00 00 00	 call	 _test

; 627  : 		if (sub(st->negSNRvar, 1024) > 0)

  00eb4	68 00 04 00 00	 push	 1024			; 00000400H
  00eb9	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00ebc	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  00ec3	51		 push	 ecx
  00ec4	e8 00 00 00 00	 call	 _sub
  00ec9	83 c4 08	 add	 esp, 8
  00ecc	0f bf d0	 movsx	 edx, ax
  00ecf	85 d2		 test	 edx, edx
  00ed1	7e 14		 jle	 SHORT $LN42@vad2

; 628  : 		{
; 629  : 			st->negSNRvar = 1024;								move16();

  00ed3	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00ed8	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00edb	66 89 81 b6 00
	00 00		 mov	 WORD PTR [ecx+182], ax
  00ee2	e8 00 00 00 00	 call	 _move16
$LN42@vad2:

; 630  : 		}
; 631  : 
; 632  : 		/* negSNRbias = max(12.0*(negSNRvar - 0.65), 0.0); */
; 633  : 		tmp = mult_r(shl(sub(st->negSNRvar, 166), 4), 24576);					test();

  00ee7	68 00 60 00 00	 push	 24576			; 00006000H
  00eec	6a 04		 push	 4
  00eee	68 a6 00 00 00	 push	 166			; 000000a6H
  00ef3	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00ef6	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  00efd	51		 push	 ecx
  00efe	e8 00 00 00 00	 call	 _sub
  00f03	83 c4 08	 add	 esp, 8
  00f06	0f b7 d0	 movzx	 edx, ax
  00f09	52		 push	 edx
  00f0a	e8 00 00 00 00	 call	 _shl
  00f0f	83 c4 08	 add	 esp, 8
  00f12	0f b7 c0	 movzx	 eax, ax
  00f15	50		 push	 eax
  00f16	e8 00 00 00 00	 call	 _mult_r
  00f1b	83 c4 08	 add	 esp, 8
  00f1e	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax
  00f25	e8 00 00 00 00	 call	 _test

; 634  : 
; 635  : 		if (tmp < 0)

  00f2a	0f bf 85 e0 fc
	ff ff		 movsx	 eax, WORD PTR _tmp$[ebp]
  00f31	85 c0		 test	 eax, eax
  00f33	7d 13		 jge	 SHORT $LN41@vad2

; 636  : 		{
; 637  : 			st->negSNRbias = 0;								move16();

  00f35	33 c0		 xor	 eax, eax
  00f37	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00f3a	66 89 81 b8 00
	00 00		 mov	 WORD PTR [ecx+184], ax
  00f41	e8 00 00 00 00	 call	 _move16

; 638  : 		}
; 639  : 		else

  00f46	eb 1c		 jmp	 SHORT $LN43@vad2
$LN41@vad2:

; 640  : 		{
; 641  : 			st->negSNRbias = shr(tmp, 8);

  00f48	6a 08		 push	 8
  00f4a	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  00f51	50		 push	 eax
  00f52	e8 00 00 00 00	 call	 _shr
  00f57	83 c4 08	 add	 esp, 8
  00f5a	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  00f5d	66 89 81 b8 00
	00 00		 mov	 WORD PTR [ecx+184], ax
$LN43@vad2:

; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 
; 646  : 	/* Determine VAD as a function of the voice metric sum and quantized SNR */
; 647  : 
; 648  : 	tmp = add(vm_threshold_table[tsnrq], st->negSNRbias);						test();

  00f64	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00f67	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00f6e	51		 push	 ecx
  00f6f	0f bf 95 bc fc
	ff ff		 movsx	 edx, WORD PTR _tsnrq$[ebp]
  00f76	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR ?vm_threshold_table@?1??vad2@@9@9[edx*2]
  00f7e	50		 push	 eax
  00f7f	e8 00 00 00 00	 call	 _add
  00f84	83 c4 08	 add	 esp, 8
  00f87	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax
  00f8e	e8 00 00 00 00	 call	 _test

; 649  : 	if (sub(vm_sum, tmp) > 0)

  00f93	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  00f9a	50		 push	 eax
  00f9b	0f b7 8d d4 fd
	ff ff		 movzx	 ecx, WORD PTR _vm_sum$[ebp]
  00fa2	51		 push	 ecx
  00fa3	e8 00 00 00 00	 call	 _sub
  00fa8	83 c4 08	 add	 esp, 8
  00fab	0f bf d0	 movsx	 edx, ax
  00fae	85 d2		 test	 edx, edx
  00fb0	7e 7f		 jle	 SHORT $LN39@vad2

; 650  : 	{
; 651  : 		ivad = 1;										move16();

  00fb2	b8 01 00 00 00	 mov	 eax, 1
  00fb7	66 89 85 c8 fc
	ff ff		 mov	 WORD PTR _ivad$[ebp], ax
  00fbe	e8 00 00 00 00	 call	 _move16

; 652  : 		st->burstcount = add(st->burstcount, 1);						test();

  00fc3	6a 01		 push	 1
  00fc5	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  00fc8	0f b7 88 b2 00
	00 00		 movzx	 ecx, WORD PTR [eax+178]
  00fcf	51		 push	 ecx
  00fd0	e8 00 00 00 00	 call	 _add
  00fd5	83 c4 08	 add	 esp, 8
  00fd8	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  00fdb	66 89 82 b2 00
	00 00		 mov	 WORD PTR [edx+178], ax
  00fe2	e8 00 00 00 00	 call	 _test

; 653  : 		if (sub(st->burstcount, burstcount_table[tsnrq]) > 0)

  00fe7	0f bf 85 bc fc
	ff ff		 movsx	 eax, WORD PTR _tsnrq$[ebp]
  00fee	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?burstcount_table@?1??vad2@@9@9[eax*2]
  00ff6	51		 push	 ecx
  00ff7	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  00ffa	0f b7 82 b2 00
	00 00		 movzx	 eax, WORD PTR [edx+178]
  01001	50		 push	 eax
  01002	e8 00 00 00 00	 call	 _sub
  01007	83 c4 08	 add	 esp, 8
  0100a	0f bf c8	 movsx	 ecx, ax
  0100d	85 c9		 test	 ecx, ecx
  0100f	7e 1e		 jle	 SHORT $LN38@vad2

; 654  : 		{
; 655  : 			st->hangover = hangover_table[tsnrq];						move16();

  01011	0f bf 85 bc fc
	ff ff		 movsx	 eax, WORD PTR _tsnrq$[ebp]
  01018	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  0101b	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR ?hangover_table@?1??vad2@@9@9[eax*2]
  01023	66 89 91 b0 00
	00 00		 mov	 WORD PTR [ecx+176], dx
  0102a	e8 00 00 00 00	 call	 _move16
$LN38@vad2:

; 656  : 		}
; 657  : 	}
; 658  : 	else

  0102f	eb 75		 jmp	 SHORT $LN37@vad2
$LN39@vad2:

; 659  : 	{
; 660  : 		st->burstcount = 0;									move16();

  01031	33 c0		 xor	 eax, eax
  01033	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01036	66 89 81 b2 00
	00 00		 mov	 WORD PTR [ecx+178], ax
  0103d	e8 00 00 00 00	 call	 _move16

; 661  : 		st->hangover = sub(st->hangover, 1);							test();

  01042	6a 01		 push	 1
  01044	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01047	0f b7 88 b0 00
	00 00		 movzx	 ecx, WORD PTR [eax+176]
  0104e	51		 push	 ecx
  0104f	e8 00 00 00 00	 call	 _sub
  01054	83 c4 08	 add	 esp, 8
  01057	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  0105a	66 89 82 b0 00
	00 00		 mov	 WORD PTR [edx+176], ax
  01061	e8 00 00 00 00	 call	 _test

; 662  : 		if (st->hangover <= 0)

  01066	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01069	0f bf 88 b0 00
	00 00		 movsx	 ecx, WORD PTR [eax+176]
  01070	85 c9		 test	 ecx, ecx
  01072	7f 21		 jg	 SHORT $LN36@vad2

; 663  : 		{
; 664  : 			ivad = 0;									move16();

  01074	33 c0		 xor	 eax, eax
  01076	66 89 85 c8 fc
	ff ff		 mov	 WORD PTR _ivad$[ebp], ax
  0107d	e8 00 00 00 00	 call	 _move16

; 665  : 			st->hangover = 0;								move16();

  01082	33 c0		 xor	 eax, eax
  01084	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01087	66 89 81 b0 00
	00 00		 mov	 WORD PTR [ecx+176], ax
  0108e	e8 00 00 00 00	 call	 _move16

; 666  : 		}
; 667  : 		else

  01093	eb 11		 jmp	 SHORT $LN37@vad2
$LN36@vad2:

; 668  : 		{
; 669  : 			ivad = 1;									move16();

  01095	b8 01 00 00 00	 mov	 eax, 1
  0109a	66 89 85 c8 fc
	ff ff		 mov	 WORD PTR _ivad$[ebp], ax
  010a1	e8 00 00 00 00	 call	 _move16
$LN37@vad2:

; 670  : 		}
; 671  : 	}
; 672  : 
; 673  : 
; 674  : 	/* Calculate log spectral deviation */
; 675  : 	ch_enrg_dev = 0;										move16();

  010a6	33 c0		 xor	 eax, eax
  010a8	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _ch_enrg_dev$[ebp], ax
  010af	e8 00 00 00 00	 call	 _move16

; 676  : 													test();

  010b4	e8 00 00 00 00	 call	 _test

; 677  : 	if (L_sub(st->Lframe_cnt, 1) == 0)

  010b9	6a 01		 push	 1
  010bb	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  010be	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  010c1	51		 push	 ecx
  010c2	e8 00 00 00 00	 call	 _L_sub
  010c7	83 c4 08	 add	 esp, 8
  010ca	85 c0		 test	 eax, eax
  010cc	75 53		 jne	 SHORT $LN34@vad2

; 678  : 	{
; 679  : 		for (i = LO_CHAN; i <= HI_CHAN; i++)

  010ce	33 c0		 xor	 eax, eax
  010d0	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  010d7	eb 12		 jmp	 SHORT $LN33@vad2
$LN32@vad2:
  010d9	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  010e0	66 83 c0 01	 add	 ax, 1
  010e4	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN33@vad2:
  010eb	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  010f2	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  010f5	7f 25		 jg	 SHORT $LN31@vad2

; 680  : 		{
; 681  : 			st->ch_enrg_long_db[i] = ch_enrg_db[i];						move16();

  010f7	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  010fe	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01105	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  01108	66 8b 84 45 88
	fd ff ff	 mov	 ax, WORD PTR _ch_enrg_db$[ebp+eax*2]
  01110	66 89 44 4a 08	 mov	 WORD PTR [edx+ecx*2+8], ax
  01115	e8 00 00 00 00	 call	 _move16

; 682  : 		}

  0111a	eb bd		 jmp	 SHORT $LN32@vad2
$LN31@vad2:

; 683  : 	}
; 684  : 	else

  0111c	e9 85 00 00 00	 jmp	 $LN30@vad2
$LN34@vad2:

; 685  : 	{
; 686  : 		for (i = LO_CHAN; i <= HI_CHAN; i++)

  01121	33 c0		 xor	 eax, eax
  01123	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0112a	eb 12		 jmp	 SHORT $LN29@vad2
$LN28@vad2:
  0112c	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  01133	66 83 c0 01	 add	 ax, 1
  01137	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN29@vad2:
  0113e	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01145	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01148	7f 5c		 jg	 SHORT $LN30@vad2

; 687  : 		{
; 688  : 			tmp = abs_s(sub(st->ch_enrg_long_db[i], ch_enrg_db[i]));

  0114a	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01151	0f b7 8c 45 88
	fd ff ff	 movzx	 ecx, WORD PTR _ch_enrg_db$[ebp+eax*2]
  01159	51		 push	 ecx
  0115a	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  01161	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01164	0f b7 4c 50 08	 movzx	 ecx, WORD PTR [eax+edx*2+8]
  01169	51		 push	 ecx
  0116a	e8 00 00 00 00	 call	 _sub
  0116f	83 c4 08	 add	 esp, 8
  01172	0f b7 d0	 movzx	 edx, ax
  01175	52		 push	 edx
  01176	e8 00 00 00 00	 call	 _abs_s
  0117b	83 c4 04	 add	 esp, 4
  0117e	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax

; 689  : 			ch_enrg_dev = add(ch_enrg_dev, tmp);

  01185	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  0118c	50		 push	 eax
  0118d	0f b7 8d c8 fd
	ff ff		 movzx	 ecx, WORD PTR _ch_enrg_dev$[ebp]
  01194	51		 push	 ecx
  01195	e8 00 00 00 00	 call	 _add
  0119a	83 c4 08	 add	 esp, 8
  0119d	66 89 85 c8 fd
	ff ff		 mov	 WORD PTR _ch_enrg_dev$[ebp], ax

; 690  : 		}

  011a4	eb 86		 jmp	 SHORT $LN28@vad2
$LN30@vad2:

; 691  : 	}
; 692  : 
; 693  : 	/*
; 694  : 	 * Calculate long term integration constant as a function of instantaneous SNR
; 695  : 	 * (i.e., high SNR (tsnr dB) -> slower integration (alpha = HIGH_ALPHA),
; 696  : 	 *         low SNR (0 dB) -> faster integration (alpha = LOW_ALPHA)
; 697  : 	 */
; 698  : 
; 699  : 	/* alpha = HIGH_ALPHA - ALPHA_RANGE * (tsnr - xt) / tsnr, low <= alpha <= high */
; 700  : 	tmp = sub(st->tsnr, xt);						test(),logic16(),test(),test();

  011a6	0f b7 85 b0 fc
	ff ff		 movzx	 eax, WORD PTR _xt$[ebp]
  011ad	50		 push	 eax
  011ae	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  011b1	0f b7 91 ae 00
	00 00		 movzx	 edx, WORD PTR [ecx+174]
  011b8	52		 push	 edx
  011b9	e8 00 00 00 00	 call	 _sub
  011be	83 c4 08	 add	 esp, 8
  011c1	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax
  011c8	e8 00 00 00 00	 call	 _test
  011cd	e8 00 00 00 00	 call	 _logic16
  011d2	e8 00 00 00 00	 call	 _test
  011d7	e8 00 00 00 00	 call	 _test

; 701  : 	if (tmp <= 0 || st->tsnr <= 0)

  011dc	0f bf 85 e0 fc
	ff ff		 movsx	 eax, WORD PTR _tmp$[ebp]
  011e3	85 c0		 test	 eax, eax
  011e5	7e 0e		 jle	 SHORT $LN25@vad2
  011e7	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  011ea	0f bf 88 ae 00
	00 00		 movsx	 ecx, WORD PTR [eax+174]
  011f1	85 c9		 test	 ecx, ecx
  011f3	7f 27		 jg	 SHORT $LN26@vad2
$LN25@vad2:

; 702  : 	{
; 703  : 		alpha = HIGH_ALPHA;								move16();

  011f5	b8 33 73 00 00	 mov	 eax, 29491		; 00007333H
  011fa	66 89 85 70 fd
	ff ff		 mov	 WORD PTR _alpha$[ebp], ax
  01201	e8 00 00 00 00	 call	 _move16

; 704  : 		one_m_alpha = 32768L-HIGH_ALPHA;						move16();

  01206	b8 cd 0c 00 00	 mov	 eax, 3277		; 00000ccdH
  0120b	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _one_m_alpha$[ebp], ax
  01212	e8 00 00 00 00	 call	 _move16
  01217	e9 af 00 00 00	 jmp	 $LN24@vad2
$LN26@vad2:

; 705  : 	}
; 706  : 	else if (sub(tmp, st->tsnr) > 0)

  0121c	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0121f	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  01226	51		 push	 ecx
  01227	0f b7 95 e0 fc
	ff ff		 movzx	 edx, WORD PTR _tmp$[ebp]
  0122e	52		 push	 edx
  0122f	e8 00 00 00 00	 call	 _sub
  01234	83 c4 08	 add	 esp, 8
  01237	98		 cwde
  01238	85 c0		 test	 eax, eax
  0123a	7e 24		 jle	 SHORT $LN23@vad2

; 707  : 	{
; 708  : 		alpha = LOW_ALPHA;								move16();

  0123c	b8 9a 59 00 00	 mov	 eax, 22938		; 0000599aH
  01241	66 89 85 70 fd
	ff ff		 mov	 WORD PTR _alpha$[ebp], ax
  01248	e8 00 00 00 00	 call	 _move16

; 709  : 		one_m_alpha = 32768L-LOW_ALPHA;							move16();

  0124d	b8 66 26 00 00	 mov	 eax, 9830		; 00002666H
  01252	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _one_m_alpha$[ebp], ax
  01259	e8 00 00 00 00	 call	 _move16

; 710  : 	}
; 711  : 	else

  0125e	eb 6b		 jmp	 SHORT $LN24@vad2
$LN23@vad2:

; 712  : 	{
; 713  : 		tmp = div_s(tmp, st->tsnr);

  01260	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01263	0f b7 88 ae 00
	00 00		 movzx	 ecx, WORD PTR [eax+174]
  0126a	51		 push	 ecx
  0126b	0f b7 95 e0 fc
	ff ff		 movzx	 edx, WORD PTR _tmp$[ebp]
  01272	52		 push	 edx
  01273	e8 00 00 00 00	 call	 _div_s
  01278	83 c4 08	 add	 esp, 8
  0127b	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax

; 714  : 		alpha = sub(HIGH_ALPHA, mult(ALPHA_RANGE, tmp));

  01282	0f b7 85 e0 fc
	ff ff		 movzx	 eax, WORD PTR _tmp$[ebp]
  01289	50		 push	 eax
  0128a	68 99 19 00 00	 push	 6553			; 00001999H
  0128f	e8 00 00 00 00	 call	 _mult
  01294	83 c4 08	 add	 esp, 8
  01297	0f b7 c8	 movzx	 ecx, ax
  0129a	51		 push	 ecx
  0129b	68 33 73 00 00	 push	 29491			; 00007333H
  012a0	e8 00 00 00 00	 call	 _sub
  012a5	83 c4 08	 add	 esp, 8
  012a8	66 89 85 70 fd
	ff ff		 mov	 WORD PTR _alpha$[ebp], ax

; 715  : 		one_m_alpha = sub(32767, alpha);

  012af	0f b7 85 70 fd
	ff ff		 movzx	 eax, WORD PTR _alpha$[ebp]
  012b6	50		 push	 eax
  012b7	68 ff 7f 00 00	 push	 32767			; 00007fffH
  012bc	e8 00 00 00 00	 call	 _sub
  012c1	83 c4 08	 add	 esp, 8
  012c4	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _one_m_alpha$[ebp], ax
$LN24@vad2:

; 716  : 	}
; 717  : 
; 718  : 	/* Calc long term log spectral energy */
; 719  : 	for (i = LO_CHAN; i <= HI_CHAN; i++)

  012cb	33 c0		 xor	 eax, eax
  012cd	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  012d4	eb 12		 jmp	 SHORT $LN21@vad2
$LN20@vad2:
  012d6	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  012dd	66 83 c0 01	 add	 ax, 1
  012e1	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN21@vad2:
  012e8	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  012ef	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  012f2	7f 7f		 jg	 SHORT $LN19@vad2

; 720  : 	{
; 721  : 		Ltmp1 = L_mult(one_m_alpha, ch_enrg_db[i]);

  012f4	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  012fb	0f b7 8c 45 88
	fd ff ff	 movzx	 ecx, WORD PTR _ch_enrg_db$[ebp+eax*2]
  01303	51		 push	 ecx
  01304	0f b7 95 64 fd
	ff ff		 movzx	 edx, WORD PTR _one_m_alpha$[ebp]
  0130b	52		 push	 edx
  0130c	e8 00 00 00 00	 call	 _L_mult
  01311	83 c4 08	 add	 esp, 8
  01314	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _Ltmp1$[ebp], eax

; 722  : 		Ltmp2 = L_mult(alpha, st->ch_enrg_long_db[i]);

  0131a	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  01321	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01324	0f b7 54 41 08	 movzx	 edx, WORD PTR [ecx+eax*2+8]
  01329	52		 push	 edx
  0132a	0f b7 85 70 fd
	ff ff		 movzx	 eax, WORD PTR _alpha$[ebp]
  01331	50		 push	 eax
  01332	e8 00 00 00 00	 call	 _L_mult
  01337	83 c4 08	 add	 esp, 8
  0133a	89 85 ec fc ff
	ff		 mov	 DWORD PTR _Ltmp2$[ebp], eax

; 723  : 		st->ch_enrg_long_db[i] = round(L_add(Ltmp1, Ltmp2));

  01340	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _Ltmp2$[ebp]
  01346	50		 push	 eax
  01347	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _Ltmp1$[ebp]
  0134d	51		 push	 ecx
  0134e	e8 00 00 00 00	 call	 _L_add
  01353	83 c4 08	 add	 esp, 8
  01356	50		 push	 eax
  01357	e8 00 00 00 00	 call	 _round
  0135c	83 c4 04	 add	 esp, 4
  0135f	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  01366	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01369	66 89 44 51 08	 mov	 WORD PTR [ecx+edx*2+8], ax

; 724  : 	}

  0136e	e9 63 ff ff ff	 jmp	 $LN20@vad2
$LN19@vad2:

; 725  : 
; 726  : 
; 727  : 	/* Set or clear the noise update flags */
; 728  : 	update_flag = FALSE;										move16();

  01373	33 c0		 xor	 eax, eax
  01375	66 89 85 58 fd
	ff ff		 mov	 WORD PTR _update_flag$[ebp], ax
  0137c	e8 00 00 00 00	 call	 _move16

; 729  : 	st->fupdate_flag = FALSE;									move16();

  01381	33 c0		 xor	 eax, eax
  01383	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01386	66 89 81 b4 00
	00 00		 mov	 WORD PTR [ecx+180], ax
  0138d	e8 00 00 00 00	 call	 _move16

; 730  : 													test(),test();

  01392	e8 00 00 00 00	 call	 _test
  01397	e8 00 00 00 00	 call	 _test

; 731  : 	if (sub(vm_sum, UPDATE_THLD) <= 0)

  0139c	6a 23		 push	 35			; 00000023H
  0139e	0f b7 85 d4 fd
	ff ff		 movzx	 eax, WORD PTR _vm_sum$[ebp]
  013a5	50		 push	 eax
  013a6	e8 00 00 00 00	 call	 _sub
  013ab	83 c4 08	 add	 esp, 8
  013ae	0f bf c8	 movsx	 ecx, ax
  013b1	85 c9		 test	 ecx, ecx
  013b3	7f 37		 jg	 SHORT $LN18@vad2

; 732  : 	{												test();

  013b5	e8 00 00 00 00	 call	 _test

; 733  : 		if (st->burstcount == 0)

  013ba	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  013bd	0f bf 88 b2 00
	00 00		 movsx	 ecx, WORD PTR [eax+178]
  013c4	85 c9		 test	 ecx, ecx
  013c6	75 1f		 jne	 SHORT $LN17@vad2

; 734  : 		{
; 735  : 			update_flag = TRUE;								move16();

  013c8	b8 01 00 00 00	 mov	 eax, 1
  013cd	66 89 85 58 fd
	ff ff		 mov	 WORD PTR _update_flag$[ebp], ax
  013d4	e8 00 00 00 00	 call	 _move16

; 736  : 			st->update_cnt = 0;								move16();

  013d9	33 c0		 xor	 eax, eax
  013db	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  013de	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  013e2	e8 00 00 00 00	 call	 _move16
$LN17@vad2:

; 737  : 		}

  013e7	e9 c5 00 00 00	 jmp	 $LN16@vad2
$LN18@vad2:

; 738  : 	}
; 739  : 	else if (L_sub(Ltce, noise_floor_chan[st->shift_state]) > 0)

  013ec	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  013ef	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  013f6	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?noise_floor_chan@?1??vad2@@9@9[ecx*2]
  013fe	52		 push	 edx
  013ff	8b 45 dc	 mov	 eax, DWORD PTR _Ltce$[ebp]
  01402	50		 push	 eax
  01403	e8 00 00 00 00	 call	 _L_sub
  01408	83 c4 08	 add	 esp, 8
  0140b	85 c0		 test	 eax, eax
  0140d	0f 8e 9e 00 00
	00		 jle	 $LN16@vad2

; 740  : 	{												test();

  01413	e8 00 00 00 00	 call	 _test

; 741  : 		if (sub(ch_enrg_dev, DEV_THLD) < 0)

  01418	68 00 1c 00 00	 push	 7168			; 00001c00H
  0141d	0f b7 85 c8 fd
	ff ff		 movzx	 eax, WORD PTR _ch_enrg_dev$[ebp]
  01424	50		 push	 eax
  01425	e8 00 00 00 00	 call	 _sub
  0142a	83 c4 08	 add	 esp, 8
  0142d	0f bf c8	 movsx	 ecx, ax
  01430	85 c9		 test	 ecx, ecx
  01432	7d 7d		 jge	 SHORT $LN16@vad2

; 742  : 		{											test();

  01434	e8 00 00 00 00	 call	 _test

; 743  : 			if (p2a_flag == FALSE)

  01439	0f bf 85 b0 fd
	ff ff		 movsx	 eax, WORD PTR _p2a_flag$[ebp]
  01440	85 c0		 test	 eax, eax
  01442	75 6d		 jne	 SHORT $LN16@vad2

; 744  : 			{										test();

  01444	e8 00 00 00 00	 call	 _test

; 745  : 				if (st->LTP_flag == FALSE)

  01449	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0144c	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR [eax+196], 0
  01453	75 5c		 jne	 SHORT $LN16@vad2

; 746  : 				{
; 747  : 					st->update_cnt = add(st->update_cnt, 1);			test();

  01455	6a 01		 push	 1
  01457	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0145a	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0145e	51		 push	 ecx
  0145f	e8 00 00 00 00	 call	 _add
  01464	83 c4 08	 add	 esp, 8
  01467	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  0146a	66 89 42 02	 mov	 WORD PTR [edx+2], ax
  0146e	e8 00 00 00 00	 call	 _test

; 748  : 					if (sub(st->update_cnt, UPDATE_CNT_THLD) >= 0)

  01473	6a 32		 push	 50			; 00000032H
  01475	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01478	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0147c	51		 push	 ecx
  0147d	e8 00 00 00 00	 call	 _sub
  01482	83 c4 08	 add	 esp, 8
  01485	0f bf d0	 movsx	 edx, ax
  01488	85 d2		 test	 edx, edx
  0148a	7c 25		 jl	 SHORT $LN16@vad2

; 749  : 					{
; 750  : 						update_flag = TRUE;					move16();

  0148c	b8 01 00 00 00	 mov	 eax, 1
  01491	66 89 85 58 fd
	ff ff		 mov	 WORD PTR _update_flag$[ebp], ax
  01498	e8 00 00 00 00	 call	 _move16

; 751  : 						st->fupdate_flag = TRUE;				move16();

  0149d	b8 01 00 00 00	 mov	 eax, 1
  014a2	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  014a5	66 89 81 b4 00
	00 00		 mov	 WORD PTR [ecx+180], ax
  014ac	e8 00 00 00 00	 call	 _move16
$LN16@vad2:

; 752  : 					}
; 753  : 				}
; 754  : 			}
; 755  : 		}
; 756  : 	}
; 757  : 													test();

  014b1	e8 00 00 00 00	 call	 _test

; 758  : 	if (sub(st->update_cnt, st->last_update_cnt) == 0)

  014b6	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  014b9	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  014bd	51		 push	 ecx
  014be	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  014c1	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  014c5	50		 push	 eax
  014c6	e8 00 00 00 00	 call	 _sub
  014cb	83 c4 08	 add	 esp, 8
  014ce	0f bf c8	 movsx	 ecx, ax
  014d1	85 c9		 test	 ecx, ecx
  014d3	75 1b		 jne	 SHORT $LN10@vad2

; 759  : 	{
; 760  : 		st->hyster_cnt = add(st->hyster_cnt, 1);

  014d5	6a 01		 push	 1
  014d7	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  014da	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  014de	51		 push	 ecx
  014df	e8 00 00 00 00	 call	 _add
  014e4	83 c4 08	 add	 esp, 8
  014e7	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  014ea	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 761  : 	}
; 762  : 	else

  014ee	eb 0e		 jmp	 SHORT $LN9@vad2
$LN10@vad2:

; 763  : 	{
; 764  : 		st->hyster_cnt = 0;									move16();

  014f0	33 c0		 xor	 eax, eax
  014f2	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  014f5	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  014f9	e8 00 00 00 00	 call	 _move16
$LN9@vad2:

; 765  : 	}
; 766  : 
; 767  : 	st->last_update_cnt = st->update_cnt;								move16();

  014fe	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01501	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01504	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  01508	66 89 50 06	 mov	 WORD PTR [eax+6], dx
  0150c	e8 00 00 00 00	 call	 _move16

; 768  : 													test();

  01511	e8 00 00 00 00	 call	 _test

; 769  : 	if (sub(st->hyster_cnt, HYSTER_CNT_THLD) > 0)

  01516	6a 06		 push	 6
  01518	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0151b	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0151f	51		 push	 ecx
  01520	e8 00 00 00 00	 call	 _sub
  01525	83 c4 08	 add	 esp, 8
  01528	0f bf d0	 movsx	 edx, ax
  0152b	85 d2		 test	 edx, edx
  0152d	7e 0e		 jle	 SHORT $LN8@vad2

; 770  : 	{
; 771  : 		st->update_cnt = 0;									move16();

  0152f	33 c0		 xor	 eax, eax
  01531	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01534	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  01538	e8 00 00 00 00	 call	 _move16
$LN8@vad2:

; 772  : 	}
; 773  : 
; 774  : 
; 775  : 	/* Conditionally update the channel noise estimates */
; 776  : 													test();

  0153d	e8 00 00 00 00	 call	 _test

; 777  : 	if (update_flag == TRUE)

  01542	0f bf 85 58 fd
	ff ff		 movsx	 eax, WORD PTR _update_flag$[ebp]
  01549	83 f8 01	 cmp	 eax, 1
  0154c	0f 85 6d 01 00
	00		 jne	 $LN7@vad2

; 778  : 	{
; 779  : 		/* Check shift state */									test();

  01552	e8 00 00 00 00	 call	 _test

; 780  : 		if (st->shift_state == 1)

  01557	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  0155a	0f bf 88 ba 00
	00 00		 movsx	 ecx, WORD PTR [eax+186]
  01561	83 f9 01	 cmp	 ecx, 1
  01564	75 1d		 jne	 SHORT $LN6@vad2

; 781  : 		{
; 782  : 			/* get factor to shift ch_enrg[] from state 1 to 0 (noise always state 0) */
; 783  : 			tmp = state_change_shift_r[0];							move16();

  01566	b8 02 00 00 00	 mov	 eax, 2
  0156b	6b c8 00	 imul	 ecx, eax, 0
  0156e	66 8b 91 00 00
	00 00		 mov	 dx, WORD PTR ?state_change_shift_r@?1??vad2@@9@9[ecx]
  01575	66 89 95 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], dx
  0157c	e8 00 00 00 00	 call	 _move16

; 784  : 		}
; 785  : 		else

  01581	eb 0e		 jmp	 SHORT $LN5@vad2
$LN6@vad2:

; 786  : 		{
; 787  : 			/* No shift if already state 0 */
; 788  : 			tmp = 0;									move16();

  01583	33 c0		 xor	 eax, eax
  01585	66 89 85 e0 fc
	ff ff		 mov	 WORD PTR _tmp$[ebp], ax
  0158c	e8 00 00 00 00	 call	 _move16
$LN5@vad2:

; 789  : 		}
; 790  : 
; 791  : 		/* Update noise energy estimate */
; 792  : 		for (i = LO_CHAN; i <= HI_CHAN; i++)

  01591	33 c0		 xor	 eax, eax
  01593	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0159a	eb 12		 jmp	 SHORT $LN4@vad2
$LN3@vad2:
  0159c	66 8b 85 4c fd
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  015a3	66 83 c0 01	 add	 ax, 1
  015a7	66 89 85 4c fd
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN4@vad2:
  015ae	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  015b5	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  015b8	0f 8f 01 01 00
	00		 jg	 $LN7@vad2

; 793  : 		{											test();

  015be	e8 00 00 00 00	 call	 _test

; 794  : 			/* integrate over time: en[i] = (1-alpha)*en[i] + alpha*e[n] */
; 795  : 			/* (extract with shift compensation for state 1) */
; 796  : 			L_Extract (L_shr(st->Lch_enrg[i], tmp), &hi1, &lo1);

  015c3	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  015c9	50		 push	 eax
  015ca	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  015d0	51		 push	 ecx
  015d1	0f b7 95 e0 fc
	ff ff		 movzx	 edx, WORD PTR _tmp$[ebp]
  015d8	52		 push	 edx
  015d9	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  015e0	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  015e3	8b 54 81 2c	 mov	 edx, DWORD PTR [ecx+eax*4+44]
  015e7	52		 push	 edx
  015e8	e8 00 00 00 00	 call	 _L_shr
  015ed	83 c4 08	 add	 esp, 8
  015f0	50		 push	 eax
  015f1	e8 00 00 00 00	 call	 _L_Extract
  015f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 797  : 			Ltmp = Mpy_32_16(hi1, lo1, CNE_SM_FAC);

  015f9	68 cd 0c 00 00	 push	 3277			; 00000ccdH
  015fe	0f b7 85 10 fd
	ff ff		 movzx	 eax, WORD PTR _lo1$[ebp]
  01605	50		 push	 eax
  01606	0f b7 8d 1c fd
	ff ff		 movzx	 ecx, WORD PTR _hi1$[ebp]
  0160d	51		 push	 ecx
  0160e	e8 00 00 00 00	 call	 _Mpy_32_16
  01613	83 c4 0c	 add	 esp, 12			; 0000000cH
  01616	89 85 04 fd ff
	ff		 mov	 DWORD PTR _Ltmp$[ebp], eax

; 798  : 
; 799  : 			L_Extract (st->Lch_noise[i], &hi1, &lo1);

  0161c	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _lo1$[ebp]
  01622	50		 push	 eax
  01623	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _hi1$[ebp]
  01629	51		 push	 ecx
  0162a	0f bf 95 4c fd
	ff ff		 movsx	 edx, WORD PTR _i$[ebp]
  01631	8b 45 0c	 mov	 eax, DWORD PTR _st$[ebp]
  01634	8b 4c 90 6c	 mov	 ecx, DWORD PTR [eax+edx*4+108]
  01638	51		 push	 ecx
  01639	e8 00 00 00 00	 call	 _L_Extract
  0163e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 800  : 			st->Lch_noise[i] = L_add(Ltmp, Mpy_32_16(hi1, lo1, ONE_MINUS_CNE_SM_FAC));	move32();

  01641	68 33 73 00 00	 push	 29491			; 00007333H
  01646	0f b7 85 10 fd
	ff ff		 movzx	 eax, WORD PTR _lo1$[ebp]
  0164d	50		 push	 eax
  0164e	0f b7 8d 1c fd
	ff ff		 movzx	 ecx, WORD PTR _hi1$[ebp]
  01655	51		 push	 ecx
  01656	e8 00 00 00 00	 call	 _Mpy_32_16
  0165b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0165e	50		 push	 eax
  0165f	8b 95 04 fd ff
	ff		 mov	 edx, DWORD PTR _Ltmp$[ebp]
  01665	52		 push	 edx
  01666	e8 00 00 00 00	 call	 _L_add
  0166b	83 c4 08	 add	 esp, 8
  0166e	0f bf 8d 4c fd
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  01675	8b 55 0c	 mov	 edx, DWORD PTR _st$[ebp]
  01678	89 44 8a 6c	 mov	 DWORD PTR [edx+ecx*4+108], eax
  0167c	e8 00 00 00 00	 call	 _move32

; 801  : 
; 802  : 			/* Limit low level noise */							test();

  01681	e8 00 00 00 00	 call	 _test

; 803  : 			if (L_sub(st->Lch_noise[i], MIN_NOISE_ENRG_0) < 0)

  01686	6a 20		 push	 32			; 00000020H
  01688	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  0168f	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  01692	8b 54 81 6c	 mov	 edx, DWORD PTR [ecx+eax*4+108]
  01696	52		 push	 edx
  01697	e8 00 00 00 00	 call	 _L_sub
  0169c	83 c4 08	 add	 esp, 8
  0169f	85 c0		 test	 eax, eax
  016a1	7d 17		 jge	 SHORT $LN1@vad2

; 804  : 			{
; 805  : 				st->Lch_noise[i] = MIN_NOISE_ENRG_0;					move32();

  016a3	0f bf 85 4c fd
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  016aa	8b 4d 0c	 mov	 ecx, DWORD PTR _st$[ebp]
  016ad	c7 44 81 6c 20
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+108], 32 ; 00000020H
  016b5	e8 00 00 00 00	 call	 _move32
$LN1@vad2:

; 806  : 			}
; 807  : 		}

  016ba	e9 dd fe ff ff	 jmp	 $LN3@vad2
$LN7@vad2:

; 808  : 	}
; 809  : 
; 810  : 	return(ivad);

  016bf	66 8b 85 c8 fc
	ff ff		 mov	 ax, WORD PTR _ivad$[ebp]
$LN115@vad2:

; 811  : }								/* end of vad2 () */

  016c6	52		 push	 edx
  016c7	8b cd		 mov	 ecx, ebp
  016c9	50		 push	 eax
  016ca	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN127@vad2
  016d0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  016d5	58		 pop	 eax
  016d6	5a		 pop	 edx
  016d7	5f		 pop	 edi
  016d8	5e		 pop	 esi
  016d9	5b		 pop	 ebx
  016da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016dd	33 cd		 xor	 ecx, ebp
  016df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016e4	81 c4 38 04 00
	00		 add	 esp, 1080		; 00000438H
  016ea	3b ec		 cmp	 ebp, esp
  016ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  016f1	8b e5		 mov	 esp, ebp
  016f3	5d		 pop	 ebp
  016f4	c3		 ret	 0
  016f5	8d 49 00	 npad	 3
$LN127@vad2:
  016f8	06 00 00 00	 DD	 6
  016fc	00 00 00 00	 DD	 $LN126@vad2
$LN126@vad2:
  01700	1c ff ff ff	 DD	 -228			; ffffff1cH
  01704	a0 00 00 00	 DD	 160			; 000000a0H
  01708	00 00 00 00	 DD	 $LN120@vad2
  0170c	14 fe ff ff	 DD	 -492			; fffffe14H
  01710	00 01 00 00	 DD	 256			; 00000100H
  01714	00 00 00 00	 DD	 $LN121@vad2
  01718	ec fd ff ff	 DD	 -532			; fffffdecH
  0171c	20 00 00 00	 DD	 32			; 00000020H
  01720	00 00 00 00	 DD	 $LN122@vad2
  01724	88 fd ff ff	 DD	 -632			; fffffd88H
  01728	20 00 00 00	 DD	 32			; 00000020H
  0172c	00 00 00 00	 DD	 $LN123@vad2
  01730	1c fd ff ff	 DD	 -740			; fffffd1cH
  01734	02 00 00 00	 DD	 2
  01738	00 00 00 00	 DD	 $LN124@vad2
  0173c	10 fd ff ff	 DD	 -752			; fffffd10H
  01740	02 00 00 00	 DD	 2
  01744	00 00 00 00	 DD	 $LN125@vad2
$LN125@vad2:
  01748	6c		 DB	 108			; 0000006cH
  01749	6f		 DB	 111			; 0000006fH
  0174a	31		 DB	 49			; 00000031H
  0174b	00		 DB	 0
$LN124@vad2:
  0174c	68		 DB	 104			; 00000068H
  0174d	69		 DB	 105			; 00000069H
  0174e	31		 DB	 49			; 00000031H
  0174f	00		 DB	 0
$LN123@vad2:
  01750	63		 DB	 99			; 00000063H
  01751	68		 DB	 104			; 00000068H
  01752	5f		 DB	 95			; 0000005fH
  01753	65		 DB	 101			; 00000065H
  01754	6e		 DB	 110			; 0000006eH
  01755	72		 DB	 114			; 00000072H
  01756	67		 DB	 103			; 00000067H
  01757	5f		 DB	 95			; 0000005fH
  01758	64		 DB	 100			; 00000064H
  01759	62		 DB	 98			; 00000062H
  0175a	00		 DB	 0
$LN122@vad2:
  0175b	63		 DB	 99			; 00000063H
  0175c	68		 DB	 104			; 00000068H
  0175d	5f		 DB	 95			; 0000005fH
  0175e	73		 DB	 115			; 00000073H
  0175f	6e		 DB	 110			; 0000006eH
  01760	72		 DB	 114			; 00000072H
  01761	00		 DB	 0
$LN121@vad2:
  01762	64		 DB	 100			; 00000064H
  01763	61		 DB	 97			; 00000061H
  01764	74		 DB	 116			; 00000074H
  01765	61		 DB	 97			; 00000061H
  01766	5f		 DB	 95			; 0000005fH
  01767	62		 DB	 98			; 00000062H
  01768	75		 DB	 117			; 00000075H
  01769	66		 DB	 102			; 00000066H
  0176a	66		 DB	 102			; 00000066H
  0176b	65		 DB	 101			; 00000065H
  0176c	72		 DB	 114			; 00000072H
  0176d	00		 DB	 0
$LN120@vad2:
  0176e	69		 DB	 105			; 00000069H
  0176f	6e		 DB	 110			; 0000006eH
  01770	70		 DB	 112			; 00000070H
  01771	75		 DB	 117			; 00000075H
  01772	74		 DB	 116			; 00000074H
  01773	5f		 DB	 95			; 0000005fH
  01774	62		 DB	 98			; 00000062H
  01775	75		 DB	 117			; 00000075H
  01776	66		 DB	 102			; 00000066H
  01777	66		 DB	 102			; 00000066H
  01778	65		 DB	 101			; 00000065H
  01779	72		 DB	 114			; 00000072H
  0177a	00		 DB	 0
_vad2	ENDP
_TEXT	ENDS
END
