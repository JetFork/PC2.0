; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\pre_proc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pre_proc_id
CONST	SEGMENT
_pre_proc_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_b	DW	076bH
	DW	0f12aH
	DW	076bH
	ORG $+2
_a	DW	01000H
	DW	01e7fH
	DW	0f16bH
CONST	ENDS
PUBLIC	_Pre_Process_init
PUBLIC	_Pre_Process_reset
PUBLIC	_Pre_Process_exit
PUBLIC	_Pre_Process
PUBLIC	??_C@_0CF@PEBLMLNP@Pre_Process_init?3?5invalid?5parame@ ; `string'
PUBLIC	??_C@_0DC@PLALDOLE@Pre_Process_init?3?5can?5not?5malloc@ ; `string'
PUBLIC	??_C@_0CG@IIDGOFOF@Pre_Process_reset?3?5invalid?5param@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_Extract:PROC
EXTRN	_Mpy_32_16:PROC
EXTRN	_move16:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CG@IIDGOFOF@Pre_Process_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@IIDGOFOF@Pre_Process_reset?3?5invalid?5param@ DB 'Pre_Process_r'
	DB	'eset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PLALDOLE@Pre_Process_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@PLALDOLE@Pre_Process_init?3?5can?5not?5malloc@ DB 'Pre_Process_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEBLMLNP@Pre_Process_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@PEBLMLNP@Pre_Process_init?3?5invalid?5parame@ DB 'Pre_Process_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pre_proc.c
;	COMDAT _Pre_Process
_TEXT	SEGMENT
_L_tmp$ = -32						; size = 4
_x2$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_signal$ = 12						; size = 4
_lg$ = 16						; size = 2
_Pre_Process PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 148  :     Word16 i, x2;
; 149  :     Word32 L_tmp;
; 150  : 
; 151  :     for (i = 0; i < lg; i++)

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00024	eb 0c		 jmp	 SHORT $LN3@Pre_Proces
$LN2@Pre_Proces:
  00026	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002a	66 83 c0 01	 add	 ax, 1
  0002e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@Pre_Proces:
  00032	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00036	0f bf 4d 10	 movsx	 ecx, WORD PTR _lg$[ebp]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	0f 8d 7d 01 00
	00		 jge	 $LN1@Pre_Proces

; 152  :     {
; 153  :         x2 = st->x1;                   move16 (); 

  00042	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00045	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  00049	66 89 4d ec	 mov	 WORD PTR _x2$[ebp], cx
  0004d	e8 00 00 00 00	 call	 _move16

; 154  :         st->x1 = st->x0;               move16 (); 

  00052	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00058	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  0005c	66 89 50 0a	 mov	 WORD PTR [eax+10], dx
  00060	e8 00 00 00 00	 call	 _move16

; 155  :         st->x0 = signal[i];            move16 (); 

  00065	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _signal$[ebp]
  0006f	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  00073	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00077	e8 00 00 00 00	 call	 _move16

; 156  : 
; 157  :         /*  y[i] = b[0]*x[i]/2 + b[1]*x[i-1]/2 + b140[2]*x[i-2]/2  */
; 158  :         /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */
; 159  : 
; 160  :         L_tmp = Mpy_32_16 (st->y1_hi, st->y1_lo, a[1]);

  0007c	b8 02 00 00 00	 mov	 eax, 2
  00081	c1 e0 00	 shl	 eax, 0
  00084	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _a[eax]
  0008b	51		 push	 ecx
  0008c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0008f	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00097	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 _Mpy_32_16
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 161  :         L_tmp = L_add (L_tmp, Mpy_32_16 (st->y2_hi, st->y2_lo, a[2]));

  000a7	b8 02 00 00 00	 mov	 eax, 2
  000ac	d1 e0		 shl	 eax, 1
  000ae	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _a[eax]
  000b5	51		 push	 ecx
  000b6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000b9	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000c1	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 _Mpy_32_16
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cd	50		 push	 eax
  000ce	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _L_add
  000d7	83 c4 08	 add	 esp, 8
  000da	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 162  :         L_tmp = L_mac (L_tmp, st->x0, b[0]);

  000dd	b8 02 00 00 00	 mov	 eax, 2
  000e2	6b c8 00	 imul	 ecx, eax, 0
  000e5	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR _b[ecx]
  000ec	52		 push	 edx
  000ed	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000f0	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  000f4	51		 push	 ecx
  000f5	8b 55 e0	 mov	 edx, DWORD PTR _L_tmp$[ebp]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _L_mac
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 163  :         L_tmp = L_mac (L_tmp, st->x1, b[1]);

  00104	b8 02 00 00 00	 mov	 eax, 2
  00109	c1 e0 00	 shl	 eax, 0
  0010c	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _b[eax]
  00113	51		 push	 ecx
  00114	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00117	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  0011b	50		 push	 eax
  0011c	8b 4d e0	 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 _L_mac
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 164  :         L_tmp = L_mac (L_tmp, x2, b[2]);

  0012b	b8 02 00 00 00	 mov	 eax, 2
  00130	d1 e0		 shl	 eax, 1
  00132	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _b[eax]
  00139	51		 push	 ecx
  0013a	0f b7 55 ec	 movzx	 edx, WORD PTR _x2$[ebp]
  0013e	52		 push	 edx
  0013f	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _L_mac
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014b	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 165  :         L_tmp = L_shl (L_tmp, 3);

  0014e	6a 03		 push	 3
  00150	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _L_shl
  00159	83 c4 08	 add	 esp, 8
  0015c	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 166  :         signal[i] = round (L_tmp); move16 (); 

  0015f	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _round
  00168	83 c4 04	 add	 esp, 4
  0016b	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0016f	8b 55 0c	 mov	 edx, DWORD PTR _signal$[ebp]
  00172	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00176	e8 00 00 00 00	 call	 _move16

; 167  : 
; 168  :         st->y2_hi = st->y1_hi;             move16 (); 

  0017b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00181	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00185	66 89 10	 mov	 WORD PTR [eax], dx
  00188	e8 00 00 00 00	 call	 _move16

; 169  :         st->y2_lo = st->y1_lo;             move16 (); 

  0018d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00193	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00197	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  0019b	e8 00 00 00 00	 call	 _move16

; 170  :         L_Extract (L_tmp, &st->y1_hi, &st->y1_lo);

  001a0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001a3	83 c0 06	 add	 eax, 6
  001a6	50		 push	 eax
  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001aa	83 c1 04	 add	 ecx, 4
  001ad	51		 push	 ecx
  001ae	8b 55 e0	 mov	 edx, DWORD PTR _L_tmp$[ebp]
  001b1	52		 push	 edx
  001b2	e8 00 00 00 00	 call	 _L_Extract
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  :     }

  001ba	e9 67 fe ff ff	 jmp	 $LN2@Pre_Proces
$LN1@Pre_Proces:

; 172  :     return 0;

  001bf	33 c0		 xor	 eax, eax

; 173  : }

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001ca	3b ec		 cmp	 ebp, esp
  001cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0
_Pre_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pre_proc.c
;	COMDAT _Pre_Process_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Pre_Process_exit PROC					; COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 113  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Pre_Proces
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@Pre_Proces
$LN1@Pre_Proces:

; 114  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@Pre_Proces
$LN2@Pre_Proces:

; 115  :  
; 116  :   /* deallocate memory */
; 117  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 118  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Pre_Proces:

; 119  :   
; 120  :   return;
; 121  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Pre_Process_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pre_proc.c
;	COMDAT _Pre_Process_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Pre_Process_reset PROC					; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 89   :   if (state == (Pre_ProcessState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@Pre_Proces

; 90   :       fprintf(stderr, "Pre_Process_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IIDGOFOF@Pre_Process_reset?3?5invalid?5param@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 91   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 37		 jmp	 SHORT $LN2@Pre_Proces
$LN1@Pre_Proces:

; 92   :   }
; 93   :   
; 94   :   state->y2_hi = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 95   :   state->y2_lo = 0;

  00061	33 c0		 xor	 eax, eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 96   :   state->y1_hi = 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 97   :   state->y1_lo = 0;

  00073	33 c0		 xor	 eax, eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00078	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 98   :   state->x0 = 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 99   :   state->x1 = 0;

  00085	33 c0		 xor	 eax, eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 100  :  
; 101  :   return 0;

  0008e	33 c0		 xor	 eax, eax
$LN2@Pre_Proces:

; 102  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_Pre_Process_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pre_proc.c
;	COMDAT _Pre_Process_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Pre_Process_init PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   :   Pre_ProcessState* s;
; 61   :  
; 62   :   if (state == (Pre_ProcessState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@Pre_Proces

; 63   :       fprintf(stderr, "Pre_Process_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PEBLMLNP@Pre_Process_init?3?5invalid?5parame@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 64   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@Pre_Proces
$LN2@Pre_Proces:

; 65   :   }
; 66   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 67   :  
; 68   :   /* allocate memory */
; 69   :   if ((s= (Pre_ProcessState *) malloc(sizeof(Pre_ProcessState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 0c		 push	 12			; 0000000cH
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@Pre_Proces

; 70   :       fprintf(stderr, "Pre_Process_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@PLALDOLE@Pre_Process_init?3?5can?5not?5malloc@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 71   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@Pre_Proces
$LN1@Pre_Proces:

; 72   :   }
; 73   :   
; 74   :   Pre_Process_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _Pre_Process_reset
  000bd	83 c4 04	 add	 esp, 4

; 75   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :   
; 77   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@Pre_Proces:

; 78   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_Pre_Process_init ENDP
_TEXT	ENDS
END
