; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ec_gains.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ec_gains_id
CONST	SEGMENT
_ec_gains_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_qua_gain_pitch DW 00H
	DW	0ccdH
	DW	0199cH
	DW	02000H
	DW	02666H
	DW	02ccdH
	DW	03000H
	DW	03333H
	DW	03666H
	DW	0399aH
	DW	03ccdH
	DW	04000H
	DW	04333H
	DW	04666H
	DW	0499aH
	DW	04ccdH
_qua_gain_code DW 09fH
	DW	0f140H
	DW	0a735H
	DW	0ceH
	DW	0f2beH
	DW	0b034H
	DW	010cH
	DW	0f443H
	DW	0b958H
	DW	015dH
	DW	0f5c9H
	DW	0c285H
	DW	01a3H
	DW	0f6d7H
	DW	0c8dfH
	DW	01e2H
	DW	0f7a6H
	DW	0cdbdH
	DW	022aH
	DW	0f874H
	DW	0d293H
	DW	027dH
	DW	0f942H
	DW	0d76dH
	DW	02ddH
	DW	0fa12H
	DW	0dc4dH
	DW	034aH
	DW	0fadeH
	DW	0e11eH
	DW	03c9H
	DW	0fbaeH
	DW	0e600H
	DW	045aH
	DW	0fc7cH
	DW	0ead8H
	DW	0501H
	DW	0fd4aH
	DW	0efb3H
	DW	05c1H
	DW	0fe19H
	DW	0f48dH
	DW	069eH
	DW	0fee7H
	DW	0f968H
	DW	079cH
	DW	0ffb5H
	DW	0fe43H
	DW	08c1H
	DW	085H
	DW	0321H
	DW	0a11H
	DW	0153H
	DW	07fcH
	DW	0b93H
	DW	0221H
	DW	0cd5H
	DW	0d50H
	DW	02f0H
	DW	011b2H
	DW	0f4fH
	DW	03beH
	DW	0168cH
	DW	0119bH
	DW	048dH
	DW	01b68H
	DW	0143fH
	DW	055bH
	DW	02043H
	DW	01748H
	DW	0629H
	DW	0251dH
	DW	01ac7H
	DW	06f8H
	DW	029f9H
	DW	01ecbH
	DW	07c7H
	DW	02ed4H
	DW	02369H
	DW	0895H
	DW	033afH
	DW	028b9H
	DW	0964H
	DW	0388aH
	DW	030deH
	DW	0a71H
	DW	03ee0H
	DW	03f87H
	DW	0bf4H
	DW	047fdH
	DW	05296H
	DW	0d78H
	DW	0511bH
	DW	06b5dH
	DW	0efcH
	DW	05a39H
?cdown@?1??ec_gain_code@@9@9 DW 07fffH			; `ec_gain_code'::`2'::cdown
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	05999H
	ORG $+2
?pdown@?1??ec_gain_pitch@@9@9 DW 07fffH			; `ec_gain_pitch'::`2'::pdown
	DW	07d70H
	DW	07d70H
	DW	06666H
	DW	02666H
	DW	01999H
	DW	01999H
CONST	ENDS
PUBLIC	_ec_gain_code_init
PUBLIC	_ec_gain_code_reset
PUBLIC	_ec_gain_code_exit
PUBLIC	_ec_gain_code
PUBLIC	_ec_gain_code_update
PUBLIC	_ec_gain_pitch_init
PUBLIC	_ec_gain_pitch_reset
PUBLIC	_ec_gain_pitch_exit
PUBLIC	_ec_gain_pitch
PUBLIC	_ec_gain_pitch_update
PUBLIC	??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@ ; `string'
PUBLIC	??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@ ; `string'
PUBLIC	??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@ ; `string'
PUBLIC	??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@ ; `string'
PUBLIC	??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@ ; `string'
EXTRN	_gc_pred_update:PROC
EXTRN	_gc_pred_average_limited:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_sub:PROC
EXTRN	_mult:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_gmed_n:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@
CONST	SEGMENT
??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@ DB 'ec_gain_pitch'
	DB	'_reset: invalid parameter', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@
CONST	SEGMENT
??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@ DB 'ec_gain_pitc'
	DB	'h_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@ DB 'ec_gain_pitch'
	DB	'_init: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@ DB 'ec_gain_code_'
	DB	'reset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@
CONST	SEGMENT
??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@ DB 'ec_gain_code'
	DB	'_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@ DB 'ec_gain_code_'
	DB	'init: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_update
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_bfi$ = 12						; size = 2
_prev_bf$ = 16						; size = 2
_gain_pitch$ = 20					; size = 4
_ec_gain_pitch_update PROC				; COMDAT

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 350  :     Word16 i;
; 351  : 
; 352  :     test (); 

  0001e	e8 00 00 00 00	 call	 _test

; 353  :     if (bfi == 0)

  00023	0f bf 45 0c	 movsx	 eax, WORD PTR _bfi$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	75 4f		 jne	 SHORT $LN7@ec_gain_pi

; 354  :     {
; 355  :         test ();

  0002b	e8 00 00 00 00	 call	 _test

; 356  :         if (prev_bf != 0)

  00030	0f bf 45 10	 movsx	 eax, WORD PTR _prev_bf$[ebp]
  00034	85 c0		 test	 eax, eax
  00036	74 30		 je	 SHORT $LN6@ec_gain_pi

; 357  :         {
; 358  :             test (); 

  00038	e8 00 00 00 00	 call	 _test

; 359  :             if (sub (*gain_pitch, st->prev_gp) > 0)

  0003d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00040	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _gain_pitch$[ebp]
  00048	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _sub
  00051	83 c4 08	 add	 esp, 8
  00054	0f bf c8	 movsx	 ecx, ax
  00057	85 c9		 test	 ecx, ecx
  00059	7e 0d		 jle	 SHORT $LN6@ec_gain_pi

; 360  :             {
; 361  :                 *gain_pitch = st->prev_gp;

  0005b	8b 45 14	 mov	 eax, DWORD PTR _gain_pitch$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00061	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00065	66 89 10	 mov	 WORD PTR [eax], dx
$LN6@ec_gain_pi:

; 362  :             }
; 363  :         }
; 364  :         st->prev_gp = *gain_pitch;                         move16 (); 

  00068	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0006b	8b 4d 14	 mov	 ecx, DWORD PTR _gain_pitch$[ebp]
  0006e	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00071	66 89 50 0c	 mov	 WORD PTR [eax+12], dx
  00075	e8 00 00 00 00	 call	 _move16
$LN7@ec_gain_pi:

; 365  :     }
; 366  :     
; 367  :     st->past_gain_pit = *gain_pitch;                       move16 ();

  0007a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0007d	8b 4d 14	 mov	 ecx, DWORD PTR _gain_pitch$[ebp]
  00080	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00083	66 89 50 0a	 mov	 WORD PTR [eax+10], dx
  00087	e8 00 00 00 00	 call	 _move16

; 368  : 
; 369  :     test (); 

  0008c	e8 00 00 00 00	 call	 _test

; 370  :     if (sub (st->past_gain_pit, 16384) > 0)  /* if (st->past_gain_pit > 1.0) */

  00091	68 00 40 00 00	 push	 16384			; 00004000H
  00096	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00099	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _sub
  000a3	83 c4 08	 add	 esp, 8
  000a6	0f bf d0	 movsx	 edx, ax
  000a9	85 d2		 test	 edx, edx
  000ab	7e 11		 jle	 SHORT $LN4@ec_gain_pi

; 371  :     {
; 372  :         st->past_gain_pit = 16384;                         move16 (); 

  000ad	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000b5	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax
  000b9	e8 00 00 00 00	 call	 _move16
$LN4@ec_gain_pi:

; 373  :     }
; 374  :     for (i = 1; i < 5; i++)

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000c7	eb 0c		 jmp	 SHORT $LN3@ec_gain_pi
$LN2@ec_gain_pi:
  000c9	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000cd	66 83 c0 01	 add	 ax, 1
  000d1	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@ec_gain_pi:
  000d5	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000d9	83 f8 05	 cmp	 eax, 5
  000dc	7d 1e		 jge	 SHORT $LN1@ec_gain_pi

; 375  :     {
; 376  :         st->pbuf[i - 1] = st->pbuf[i];                     move16 (); 

  000de	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000e2	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  000e6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000e9	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  000ec	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  000f0	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  000f5	e8 00 00 00 00	 call	 _move16

; 377  :     }

  000fa	eb cd		 jmp	 SHORT $LN2@ec_gain_pi
$LN1@ec_gain_pi:

; 378  :     st->pbuf[4] = st->past_gain_pit;                       move16 (); 

  000fc	b8 02 00 00 00	 mov	 eax, 2
  00101	c1 e0 02	 shl	 eax, 2
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00107	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0010a	66 8b 52 0a	 mov	 dx, WORD PTR [edx+10]
  0010e	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00112	e8 00 00 00 00	 call	 _move16

; 379  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_ec_gain_pitch_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch
_TEXT	SEGMENT
_tmp$ = -8						; size = 2
_st$ = 8						; size = 4
_state$ = 12						; size = 2
_gain_pitch$ = 16					; size = 4
_ec_gain_pitch PROC					; COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 312  :     static const Word16 pdown[7] =
; 313  :     {
; 314  :         32767, 32112, 32112, 26214,
; 315  :         9830, 6553, 6553
; 316  :     };
; 317  : 
; 318  :     Word16 tmp;
; 319  : 
; 320  :     /* calculate median of last five gains */
; 321  :     tmp = gmed_n (st->pbuf, 5);                        move16 (); 

  0001e	6a 05		 push	 5
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _gmed_n
  00029	83 c4 08	 add	 esp, 8
  0002c	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp], ax
  00030	e8 00 00 00 00	 call	 _move16

; 322  : 
; 323  :     /* new gain = minimum(median, past_gain) * pdown[state] */
; 324  :     test (); 

  00035	e8 00 00 00 00	 call	 _test

; 325  :     if (sub (tmp, st->past_gain_pit) > 0)

  0003a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0003d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00041	51		 push	 ecx
  00042	0f b7 55 f8	 movzx	 edx, WORD PTR _tmp$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _sub
  0004c	83 c4 08	 add	 esp, 8
  0004f	98		 cwde
  00050	85 c0		 test	 eax, eax
  00052	7e 10		 jle	 SHORT $LN1@ec_gain_pi

; 326  :     {
; 327  :         tmp = st->past_gain_pit;                       move16 (); 

  00054	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00057	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  0005b	66 89 4d f8	 mov	 WORD PTR _tmp$[ebp], cx
  0005f	e8 00 00 00 00	 call	 _move16
$LN1@ec_gain_pi:

; 328  :     }
; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  00064	0f bf 45 0c	 movsx	 eax, WORD PTR _state$[ebp]
  00068	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?pdown@?1??ec_gain_pitch@@9@9[eax*2]
  00070	51		 push	 ecx
  00071	0f b7 55 f8	 movzx	 edx, WORD PTR _tmp$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _mult
  0007b	83 c4 08	 add	 esp, 8
  0007e	8b 4d 10	 mov	 ecx, DWORD PTR _gain_pitch$[ebp]
  00081	66 89 01	 mov	 WORD PTR [ecx], ax

; 330  : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_ec_gain_pitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ec_gain_pitch_exit PROC				; COMDAT

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 286  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@ec_gain_pi
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@ec_gain_pi
$LN1@ec_gain_pi:

; 287  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@ec_gain_pi
$LN2@ec_gain_pi:

; 288  :  
; 289  :   /* deallocate memory */
; 290  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 291  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@ec_gain_pi:

; 292  :   
; 293  :   return;
; 294  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_ec_gain_pitch_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_ec_gain_pitch_reset PROC				; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 262  :   Word16 i;
; 263  :   
; 264  :   if (state == (ec_gain_pitchState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@ec_gain_pi

; 265  :       fprintf(stderr, "ec_gain_pitch_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 266  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 46		 jmp	 SHORT $LN5@ec_gain_pi
$LN4@ec_gain_pi:

; 267  :   }
; 268  :   
; 269  :   for(i = 0; i < 5; i++)

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN3@ec_gain_pi
$LN2@ec_gain_pi:
  00061	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@ec_gain_pi:
  0006d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00071	83 f8 05	 cmp	 eax, 5
  00074	7d 12		 jge	 SHORT $LN1@ec_gain_pi

; 270  :       state->pbuf[i] = 1640;

  00076	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	b9 68 06 00 00	 mov	 ecx, 1640		; 00000668H
  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00086	eb d9		 jmp	 SHORT $LN2@ec_gain_pi
$LN1@ec_gain_pi:

; 271  :   state->past_gain_pit = 0; 

  00088	33 c0		 xor	 eax, eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008d	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 272  :   state->prev_gp = 16384;   

  00091	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00099	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 273  : 
; 274  :   return 0;

  0009d	33 c0		 xor	 eax, eax
$LN5@ec_gain_pi:

; 275  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_ec_gain_pitch_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_ec_gain_pitch_init PROC				; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 232  :   ec_gain_pitchState* s;
; 233  :  
; 234  :   if (state == (ec_gain_pitchState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@ec_gain_pi

; 235  :       fprintf(stderr, "ec_gain_pitch_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 236  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@ec_gain_pi
$LN2@ec_gain_pi:

; 237  :   }
; 238  :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 239  :  
; 240  :   /* allocate memory */
; 241  :   if ((s= (ec_gain_pitchState *) malloc(sizeof(ec_gain_pitchState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 0e		 push	 14			; 0000000eH
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@ec_gain_pi

; 242  :       fprintf(stderr, "ec_gain_pitch_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 243  :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@ec_gain_pi
$LN1@ec_gain_pi:

; 244  :   }
; 245  :   
; 246  :   ec_gain_pitch_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _ec_gain_pitch_reset
  000bd	83 c4 04	 add	 esp, 4

; 247  :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 248  :   
; 249  :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@ec_gain_pi:

; 250  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_ec_gain_pitch_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_update
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_bfi$ = 12						; size = 2
_prev_bf$ = 16						; size = 2
_gain_code$ = 20					; size = 4
_ec_gain_code_update PROC				; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 191  :     Word16 i;
; 192  :     
; 193  :     /* limit gain_code by previous good gain if previous frame was bad */
; 194  :     test ();

  0001e	e8 00 00 00 00	 call	 _test

; 195  :     if (bfi == 0)

  00023	0f bf 45 0c	 movsx	 eax, WORD PTR _bfi$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	75 54		 jne	 SHORT $LN6@ec_gain_co

; 196  :     {
; 197  : 		test ();

  0002b	e8 00 00 00 00	 call	 _test

; 198  :         if (prev_bf != 0)

  00030	0f bf 45 10	 movsx	 eax, WORD PTR _prev_bf$[ebp]
  00034	85 c0		 test	 eax, eax
  00036	74 35		 je	 SHORT $LN5@ec_gain_co

; 199  :         {
; 200  :             test (); 

  00038	e8 00 00 00 00	 call	 _test

; 201  :             if (sub (*gain_code, st->prev_gc) > 0)

  0003d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00040	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00044	51		 push	 ecx
  00045	8b 55 14	 mov	 edx, DWORD PTR _gain_code$[ebp]
  00048	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _sub
  00051	83 c4 08	 add	 esp, 8
  00054	0f bf c8	 movsx	 ecx, ax
  00057	85 c9		 test	 ecx, ecx
  00059	7e 12		 jle	 SHORT $LN5@ec_gain_co

; 202  :             {
; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  0005b	8b 45 14	 mov	 eax, DWORD PTR _gain_code$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00061	66 8b 51 0c	 mov	 dx, WORD PTR [ecx+12]
  00065	66 89 10	 mov	 WORD PTR [eax], dx
  00068	e8 00 00 00 00	 call	 _move16
$LN5@ec_gain_co:

; 204  :             }
; 205  :         }
; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  0006d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00070	8b 4d 14	 mov	 ecx, DWORD PTR _gain_code$[ebp]
  00073	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00076	66 89 50 0c	 mov	 WORD PTR [eax+12], dx
  0007a	e8 00 00 00 00	 call	 _move16
$LN6@ec_gain_co:

; 207  :     }
; 208  : 
; 209  :     /* update EC states: previous gain, gain buffer */
; 210  :     st->past_gain_code = *gain_code;                       move16 (); 

  0007f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00082	8b 4d 14	 mov	 ecx, DWORD PTR _gain_code$[ebp]
  00085	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00088	66 89 50 0a	 mov	 WORD PTR [eax+10], dx
  0008c	e8 00 00 00 00	 call	 _move16

; 211  :     
; 212  :     for (i = 1; i < 5; i++)

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0009a	eb 0c		 jmp	 SHORT $LN3@ec_gain_co
$LN2@ec_gain_co:
  0009c	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000a0	66 83 c0 01	 add	 ax, 1
  000a4	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@ec_gain_co:
  000a8	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000ac	83 f8 05	 cmp	 eax, 5
  000af	7d 1e		 jge	 SHORT $LN1@ec_gain_co

; 213  :     {
; 214  :         st->gbuf[i - 1] = st->gbuf[i];                     move16 (); 

  000b1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000b5	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  000b9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000bc	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  000bf	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  000c3	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  000c8	e8 00 00 00 00	 call	 _move16

; 215  :     }

  000cd	eb cd		 jmp	 SHORT $LN2@ec_gain_co
$LN1@ec_gain_co:

; 216  :     st->gbuf[4] = *gain_code;                              move16 (); 

  000cf	b8 02 00 00 00	 mov	 eax, 2
  000d4	c1 e0 02	 shl	 eax, 2
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000da	8b 55 14	 mov	 edx, DWORD PTR _gain_code$[ebp]
  000dd	66 8b 12	 mov	 dx, WORD PTR [edx]
  000e0	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  000e4	e8 00 00 00 00	 call	 _move16

; 217  : 
; 218  :     return;
; 219  : }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_ec_gain_code_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code
_TEXT	SEGMENT
_qua_ener$ = -32					; size = 2
_qua_ener_MR122$ = -20					; size = 2
_tmp$ = -8						; size = 2
_st$ = 8						; size = 4
_pred_state$ = 12					; size = 4
_state$ = 16						; size = 2
_gain_code$ = 20					; size = 4
_ec_gain_code PROC					; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 144  :     static const Word16 cdown[7] =
; 145  :     {
; 146  :         32767, 32112, 32112, 32112,
; 147  :         32112, 32112, 22937
; 148  :     };
; 149  : 
; 150  :     Word16 tmp;
; 151  :     Word16 qua_ener_MR122;
; 152  :     Word16 qua_ener;
; 153  :     
; 154  :     /* calculate median of last five gain values */
; 155  :     tmp = gmed_n (st->gbuf,5);                                 move16 ();

  0001e	6a 05		 push	 5
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _gmed_n
  00029	83 c4 08	 add	 esp, 8
  0002c	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp], ax
  00030	e8 00 00 00 00	 call	 _move16

; 156  : 
; 157  :     /* new gain = minimum(median, past_gain) * cdown[state] */
; 158  :     test (); 

  00035	e8 00 00 00 00	 call	 _test

; 159  :     if (sub (tmp, st->past_gain_code) > 0)

  0003a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0003d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00041	51		 push	 ecx
  00042	0f b7 55 f8	 movzx	 edx, WORD PTR _tmp$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _sub
  0004c	83 c4 08	 add	 esp, 8
  0004f	98		 cwde
  00050	85 c0		 test	 eax, eax
  00052	7e 10		 jle	 SHORT $LN1@ec_gain_co

; 160  :     {
; 161  :         tmp = st->past_gain_code;                              move16 (); 

  00054	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00057	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  0005b	66 89 4d f8	 mov	 WORD PTR _tmp$[ebp], cx
  0005f	e8 00 00 00 00	 call	 _move16
$LN1@ec_gain_co:

; 162  :     }
; 163  :     tmp = mult (tmp, cdown[state]);

  00064	0f bf 45 10	 movsx	 eax, WORD PTR _state$[ebp]
  00068	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?cdown@?1??ec_gain_code@@9@9[eax*2]
  00070	51		 push	 ecx
  00071	0f b7 55 f8	 movzx	 edx, WORD PTR _tmp$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _mult
  0007b	83 c4 08	 add	 esp, 8
  0007e	66 89 45 f8	 mov	 WORD PTR _tmp$[ebp], ax

; 164  :     *gain_code = tmp;                                          move16 (); 

  00082	8b 45 14	 mov	 eax, DWORD PTR _gain_code$[ebp]
  00085	66 8b 4d f8	 mov	 cx, WORD PTR _tmp$[ebp]
  00089	66 89 08	 mov	 WORD PTR [eax], cx
  0008c	e8 00 00 00 00	 call	 _move16

; 165  : 
; 166  :     /* update table of past quantized energies with average of
; 167  :      * current values
; 168  :      */
; 169  :     gc_pred_average_limited(pred_state, &qua_ener_MR122, &qua_ener);

  00091	8d 45 e0	 lea	 eax, DWORD PTR _qua_ener$[ebp]
  00094	50		 push	 eax
  00095	8d 4d ec	 lea	 ecx, DWORD PTR _qua_ener_MR122$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 0c	 mov	 edx, DWORD PTR _pred_state$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _gc_pred_average_limited
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  :     gc_pred_update(pred_state, qua_ener_MR122, qua_ener);

  000a5	0f b7 45 e0	 movzx	 eax, WORD PTR _qua_ener$[ebp]
  000a9	50		 push	 eax
  000aa	0f b7 4d ec	 movzx	 ecx, WORD PTR _qua_ener_MR122$[ebp]
  000ae	51		 push	 ecx
  000af	8b 55 0c	 mov	 edx, DWORD PTR _pred_state$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 _gc_pred_update
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  : }

  000bb	52		 push	 edx
  000bc	8b cd		 mov	 ecx, ebp
  000be	50		 push	 eax
  000bf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@ec_gain_co
  000c5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ca	58		 pop	 eax
  000cb	5a		 pop	 edx
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000d5	3b ec		 cmp	 ebp, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN7@ec_gain_co:
  000e0	02 00 00 00	 DD	 2
  000e4	00 00 00 00	 DD	 $LN6@ec_gain_co
$LN6@ec_gain_co:
  000e8	ec ff ff ff	 DD	 -20			; ffffffecH
  000ec	02 00 00 00	 DD	 2
  000f0	00 00 00 00	 DD	 $LN4@ec_gain_co
  000f4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000f8	02 00 00 00	 DD	 2
  000fc	00 00 00 00	 DD	 $LN5@ec_gain_co
$LN5@ec_gain_co:
  00100	71		 DB	 113			; 00000071H
  00101	75		 DB	 117			; 00000075H
  00102	61		 DB	 97			; 00000061H
  00103	5f		 DB	 95			; 0000005fH
  00104	65		 DB	 101			; 00000065H
  00105	6e		 DB	 110			; 0000006eH
  00106	65		 DB	 101			; 00000065H
  00107	72		 DB	 114			; 00000072H
  00108	00		 DB	 0
$LN4@ec_gain_co:
  00109	71		 DB	 113			; 00000071H
  0010a	75		 DB	 117			; 00000075H
  0010b	61		 DB	 97			; 00000061H
  0010c	5f		 DB	 95			; 0000005fH
  0010d	65		 DB	 101			; 00000065H
  0010e	6e		 DB	 110			; 0000006eH
  0010f	65		 DB	 101			; 00000065H
  00110	72		 DB	 114			; 00000072H
  00111	5f		 DB	 95			; 0000005fH
  00112	4d		 DB	 77			; 0000004dH
  00113	52		 DB	 82			; 00000052H
  00114	31		 DB	 49			; 00000031H
  00115	32		 DB	 50			; 00000032H
  00116	32		 DB	 50			; 00000032H
  00117	00		 DB	 0
_ec_gain_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ec_gain_code_exit PROC					; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 117  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@ec_gain_co
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@ec_gain_co
$LN1@ec_gain_co:

; 118  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@ec_gain_co
$LN2@ec_gain_co:

; 119  : 
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 122  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@ec_gain_co:

; 123  :   
; 124  :   return;
; 125  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_ec_gain_code_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_ec_gain_code_reset PROC				; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 92   :   Word16 i;
; 93   :   
; 94   :   if (state == (ec_gain_codeState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@ec_gain_co

; 95   :       fprintf(stderr, "ec_gain_code_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 96   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 46		 jmp	 SHORT $LN5@ec_gain_co
$LN4@ec_gain_co:

; 97   :   }
; 98   : 
; 99   :   for ( i = 0; i < 5; i++)

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN3@ec_gain_co
$LN2@ec_gain_co:
  00061	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@ec_gain_co:
  0006d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00071	83 f8 05	 cmp	 eax, 5
  00074	7d 12		 jge	 SHORT $LN1@ec_gain_co

; 100  :       state->gbuf[i] = 1;

  00076	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00086	eb d9		 jmp	 SHORT $LN2@ec_gain_co
$LN1@ec_gain_co:

; 101  :   state->past_gain_code = 0;

  00088	33 c0		 xor	 eax, eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008d	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 102  :   state->prev_gc = 1;       

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00099	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 103  : 
; 104  :   return 0;

  0009d	33 c0		 xor	 eax, eax
$LN5@ec_gain_co:

; 105  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_ec_gain_code_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_ec_gain_code_init PROC					; COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 62   :   ec_gain_codeState* s;
; 63   :  
; 64   :   if (state == (ec_gain_codeState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@ec_gain_co

; 65   :       fprintf(stderr, "ec_gain_code_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@ec_gain_co
$LN2@ec_gain_co:

; 67   :   }
; 68   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 69   :  
; 70   :   /* allocate memory */
; 71   :   if ((s= (ec_gain_codeState *) malloc(sizeof(ec_gain_codeState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 0e		 push	 14			; 0000000eH
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@ec_gain_co

; 72   :       fprintf(stderr, "ec_gain_code_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 73   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@ec_gain_co
$LN1@ec_gain_co:

; 74   :   }
; 75   : 
; 76   :   ec_gain_code_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _ec_gain_code_reset
  000bd	83 c4 04	 add	 esp, 4

; 77   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 78   :   
; 79   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@ec_gain_co:

; 80   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_ec_gain_code_init ENDP
_TEXT	ENDS
END
