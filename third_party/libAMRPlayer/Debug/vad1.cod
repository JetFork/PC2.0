; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\vad1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vad1_id
CONST	SEGMENT
_vad1_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_vad1_init
PUBLIC	_vad1_reset
PUBLIC	_vad1_exit
PUBLIC	_vad_complex_detection_update
PUBLIC	_vad_tone_detection
PUBLIC	_vad_tone_detection_update
PUBLIC	_vad_pitch_detection
PUBLIC	_vad1
PUBLIC	??_C@_0BN@GALCDIAP@vad_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@CDIILMGI@vad_init?3?5can?5not?5malloc?5state?5s@ ; `string'
PUBLIC	??_C@_0BO@OHBJOMC@vad_reset?3?5invalid?5parameter?6?$AA@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_add:PROC
EXTRN	_L_sub:PROC
EXTRN	_mult_r:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_deposit_h:PROC
EXTRN	_norm_s:PROC
EXTRN	_div_s:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BO@OHBJOMC@vad_reset?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BO@OHBJOMC@vad_reset?3?5invalid?5parameter?6?$AA@ DB 'vad_reset: i'
	DB	'nvalid parameter', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CDIILMGI@vad_init?3?5can?5not?5malloc?5state?5s@
CONST	SEGMENT
??_C@_0CK@CDIILMGI@vad_init?3?5can?5not?5malloc?5state?5s@ DB 'vad_init: '
	DB	'can not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GALCDIAP@vad_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BN@GALCDIAP@vad_init?3?5invalid?5parameter?6?$AA@ DB 'vad_init: in'
	DB	'valid parameter', 0aH, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad_decision
_TEXT	SEGMENT
_exp$1 = -92						; size = 2
_low_power_flag$ = -80					; size = 2
_noise_level$ = -68					; size = 2
_temp$ = -56						; size = 2
_vad_thr$ = -44						; size = 2
_L_temp$ = -32						; size = 4
_snr_sum$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_level$ = 12						; size = 4
_pow_sum$ = 16						; size = 4
_vad_decision PROC					; COMDAT

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 710  :    Word16 i;
; 711  :    Word16 snr_sum;
; 712  :    Word32 L_temp;
; 713  :    Word16 vad_thr, temp, noise_level;
; 714  :    Word16 low_power_flag;
; 715  :    
; 716  :    /* 
; 717  :       Calculate squared sum of the input levels (level)
; 718  :       divided by the background noise components (bckr_est).
; 719  :       */
; 720  :    L_temp = 0;                                            move32();

  0001e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _L_temp$[ebp], 0
  00025	e8 00 00 00 00	 call	 _move32

; 721  :    for (i = 0; i < COMPLEN; i++)

  0002a	33 c0		 xor	 eax, eax
  0002c	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00030	eb 0c		 jmp	 SHORT $LN10@vad_decisi
$LN9@vad_decisi:
  00032	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00036	66 83 c0 01	 add	 ax, 1
  0003a	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN10@vad_decisi:
  0003e	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00042	83 f8 09	 cmp	 eax, 9
  00045	0f 8d a2 00 00
	00		 jge	 $LN8@vad_decisi

; 722  :    {
; 723  :       Word16 exp;
; 724  :       
; 725  :       exp = norm_s(st->bckr_est[i]);

  0004b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00052	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 _norm_s
  0005c	83 c4 04	 add	 esp, 4
  0005f	66 89 45 a4	 mov	 WORD PTR _exp$1[ebp], ax

; 726  :       temp = shl(st->bckr_est[i], exp);

  00063	0f b7 45 a4	 movzx	 eax, WORD PTR _exp$1[ebp]
  00067	50		 push	 eax
  00068	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0006c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0006f	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _shl
  00079	83 c4 08	 add	 esp, 8
  0007c	66 89 45 c8	 mov	 WORD PTR _temp$[ebp], ax

; 727  :       temp = div_s(shr(level[i], 1), temp);

  00080	0f b7 45 c8	 movzx	 eax, WORD PTR _temp$[ebp]
  00084	50		 push	 eax
  00085	6a 01		 push	 1
  00087	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  0008e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _shr
  00098	83 c4 08	 add	 esp, 8
  0009b	0f b7 c8	 movzx	 ecx, ax
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _div_s
  000a4	83 c4 08	 add	 esp, 8
  000a7	66 89 45 c8	 mov	 WORD PTR _temp$[ebp], ax

; 728  :       temp = shl(temp, sub(exp, UNIRSHFT-1));

  000ab	6a 05		 push	 5
  000ad	0f b7 45 a4	 movzx	 eax, WORD PTR _exp$1[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _sub
  000b7	83 c4 08	 add	 esp, 8
  000ba	0f b7 c8	 movzx	 ecx, ax
  000bd	51		 push	 ecx
  000be	0f b7 55 c8	 movzx	 edx, WORD PTR _temp$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _shl
  000c8	83 c4 08	 add	 esp, 8
  000cb	66 89 45 c8	 mov	 WORD PTR _temp$[ebp], ax

; 729  :       L_temp = L_mac(L_temp, temp, temp);

  000cf	0f b7 45 c8	 movzx	 eax, WORD PTR _temp$[ebp]
  000d3	50		 push	 eax
  000d4	0f b7 4d c8	 movzx	 ecx, WORD PTR _temp$[ebp]
  000d8	51		 push	 ecx
  000d9	8b 55 e0	 mov	 edx, DWORD PTR _L_temp$[ebp]
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 _L_mac
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 730  :    }

  000e8	e9 45 ff ff ff	 jmp	 $LN9@vad_decisi
$LN8@vad_decisi:

; 731  :    snr_sum = extract_h(L_shl(L_temp, 6));

  000ed	6a 06		 push	 6
  000ef	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _L_shl
  000f8	83 c4 08	 add	 esp, 8
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _extract_h
  00101	83 c4 04	 add	 esp, 4
  00104	66 89 45 ec	 mov	 WORD PTR _snr_sum$[ebp], ax

; 732  :    snr_sum = mult(snr_sum, INV_COMPLEN);

  00108	68 39 0e 00 00	 push	 3641			; 00000e39H
  0010d	0f b7 45 ec	 movzx	 eax, WORD PTR _snr_sum$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _mult
  00117	83 c4 08	 add	 esp, 8
  0011a	66 89 45 ec	 mov	 WORD PTR _snr_sum$[ebp], ax

; 733  : 
; 734  :    /* Calculate average level of estimated background noise */
; 735  :    L_temp = 0;                                            move32();

  0011e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _L_temp$[ebp], 0
  00125	e8 00 00 00 00	 call	 _move32

; 736  :    for (i = 0; i < COMPLEN; i++)

  0012a	33 c0		 xor	 eax, eax
  0012c	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00130	eb 0c		 jmp	 SHORT $LN7@vad_decisi
$LN6@vad_decisi:
  00132	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00136	66 83 c0 01	 add	 ax, 1
  0013a	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN7@vad_decisi:
  0013e	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00142	83 f8 09	 cmp	 eax, 9
  00145	7d 1d		 jge	 SHORT $LN5@vad_decisi

; 737  :    {
; 738  :       L_temp = L_add(L_temp, st->bckr_est[i]);

  00147	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0014e	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00152	52		 push	 edx
  00153	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _L_add
  0015c	83 c4 08	 add	 esp, 8
  0015f	89 45 e0	 mov	 DWORD PTR _L_temp$[ebp], eax

; 739  :    }

  00162	eb ce		 jmp	 SHORT $LN6@vad_decisi
$LN5@vad_decisi:

; 740  :    
; 741  :    noise_level = extract_h(L_shl(L_temp, 13));

  00164	6a 0d		 push	 13			; 0000000dH
  00166	8b 45 e0	 mov	 eax, DWORD PTR _L_temp$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _L_shl
  0016f	83 c4 08	 add	 esp, 8
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _extract_h
  00178	83 c4 04	 add	 esp, 4
  0017b	66 89 45 bc	 mov	 WORD PTR _noise_level$[ebp], ax

; 742  :    
; 743  :    /* Calculate VAD threshold */
; 744  :    vad_thr = add(mult(VAD_SLOPE, sub(noise_level, VAD_P1)), VAD_THR_HIGH);

  0017f	68 ec 04 00 00	 push	 1260			; 000004ecH
  00184	6a 00		 push	 0
  00186	0f b7 45 bc	 movzx	 eax, WORD PTR _noise_level$[ebp]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _sub
  00190	83 c4 08	 add	 esp, 8
  00193	0f b7 c8	 movzx	 ecx, ax
  00196	51		 push	 ecx
  00197	68 08 f5 ff ff	 push	 -2808			; fffff508H
  0019c	e8 00 00 00 00	 call	 _mult
  001a1	83 c4 08	 add	 esp, 8
  001a4	0f b7 d0	 movzx	 edx, ax
  001a7	52		 push	 edx
  001a8	e8 00 00 00 00	 call	 _add
  001ad	83 c4 08	 add	 esp, 8
  001b0	66 89 45 d4	 mov	 WORD PTR _vad_thr$[ebp], ax

; 745  :    
; 746  :    test ();

  001b4	e8 00 00 00 00	 call	 _test

; 747  :    if (sub(vad_thr, VAD_THR_LOW) < 0)

  001b9	68 d0 02 00 00	 push	 720			; 000002d0H
  001be	0f b7 45 d4	 movzx	 eax, WORD PTR _vad_thr$[ebp]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 _sub
  001c8	83 c4 08	 add	 esp, 8
  001cb	0f bf c8	 movsx	 ecx, ax
  001ce	85 c9		 test	 ecx, ecx
  001d0	7d 0e		 jge	 SHORT $LN4@vad_decisi

; 748  :    {
; 749  :       vad_thr = VAD_THR_LOW;                              move16 ();

  001d2	b8 d0 02 00 00	 mov	 eax, 720		; 000002d0H
  001d7	66 89 45 d4	 mov	 WORD PTR _vad_thr$[ebp], ax
  001db	e8 00 00 00 00	 call	 _move16
$LN4@vad_decisi:

; 750  :    }
; 751  :    
; 752  :    /* Shift VAD decision register */
; 753  :    st->vadreg = shr(st->vadreg, 1);                       move16 ();

  001e0	6a 01		 push	 1
  001e2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001e5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 _shr
  001ef	83 c4 08	 add	 esp, 8
  001f2	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001f5	66 89 42 64	 mov	 WORD PTR [edx+100], ax
  001f9	e8 00 00 00 00	 call	 _move16

; 754  :    
; 755  :    /* Make intermediate VAD decision */
; 756  :    test ();

  001fe	e8 00 00 00 00	 call	 _test

; 757  :    if (sub(snr_sum, vad_thr) > 0)

  00203	0f b7 45 d4	 movzx	 eax, WORD PTR _vad_thr$[ebp]
  00207	50		 push	 eax
  00208	0f b7 4d ec	 movzx	 ecx, WORD PTR _snr_sum$[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 _sub
  00212	83 c4 08	 add	 esp, 8
  00215	0f bf d0	 movsx	 edx, ax
  00218	85 d2		 test	 edx, edx
  0021a	7e 1e		 jle	 SHORT $LN3@vad_decisi

; 758  :    {
; 759  :       st->vadreg = st->vadreg | 0x4000;       logic16 (); move16 ();

  0021c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0021f	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  00223	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00229	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0022c	66 89 4a 64	 mov	 WORD PTR [edx+100], cx
  00230	e8 00 00 00 00	 call	 _logic16
  00235	e8 00 00 00 00	 call	 _move16
$LN3@vad_decisi:

; 760  :    }
; 761  :    /* primary vad decsion made */
; 762  :    
; 763  :    /* check if the input power (pow_sum) is lower than a threshold" */
; 764  :    test ();

  0023a	e8 00 00 00 00	 call	 _test

; 765  :    if (L_sub(pow_sum, VAD_POW_LOW) < 0)

  0023f	68 98 3a 00 00	 push	 15000			; 00003a98H
  00244	8b 45 10	 mov	 eax, DWORD PTR _pow_sum$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 _L_sub
  0024d	83 c4 08	 add	 esp, 8
  00250	85 c0		 test	 eax, eax
  00252	7d 10		 jge	 SHORT $LN2@vad_decisi

; 766  :    {
; 767  :       low_power_flag = 1;                                 move16 ();

  00254	b8 01 00 00 00	 mov	 eax, 1
  00259	66 89 45 b0	 mov	 WORD PTR _low_power_flag$[ebp], ax
  0025d	e8 00 00 00 00	 call	 _move16

; 768  :    }
; 769  :    else

  00262	eb 0b		 jmp	 SHORT $LN1@vad_decisi
$LN2@vad_decisi:

; 770  :    {
; 771  :       low_power_flag = 0;                                 move16 ();

  00264	33 c0		 xor	 eax, eax
  00266	66 89 45 b0	 mov	 WORD PTR _low_power_flag$[ebp], ax
  0026a	e8 00 00 00 00	 call	 _move16
$LN1@vad_decisi:

; 772  :    }
; 773  :    
; 774  :    /* update complex signal estimate st->corr_hp_fast and hangover reset timer using */
; 775  :    /* low_power_flag and corr_hp_fast  and various adaptation speeds                 */
; 776  :    complex_estimate_adapt(st, low_power_flag);

  0026f	0f b7 45 b0	 movzx	 eax, WORD PTR _low_power_flag$[ebp]
  00273	50		 push	 eax
  00274	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 _complex_estimate_adapt
  0027d	83 c4 08	 add	 esp, 8

; 777  : 
; 778  :    /* check multiple thresholds of the st->corr_hp_fast value */
; 779  :    st->complex_warning = complex_vad(st, low_power_flag); move16();    

  00280	0f b7 45 b0	 movzx	 eax, WORD PTR _low_power_flag$[ebp]
  00284	50		 push	 eax
  00285	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00288	51		 push	 ecx
  00289	e8 00 00 00 00	 call	 _complex_vad
  0028e	83 c4 08	 add	 esp, 8
  00291	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00294	66 89 42 7a	 mov	 WORD PTR [edx+122], ax
  00298	e8 00 00 00 00	 call	 _move16

; 780  : 
; 781  :    /* Update speech subband vad background noise estimates */
; 782  :    noise_estimate_update(st, level);

  0029d	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  002a0	50		 push	 eax
  002a1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002a4	51		 push	 ecx
  002a5	e8 00 00 00 00	 call	 _noise_estimate_update
  002aa	83 c4 08	 add	 esp, 8

; 783  :      
; 784  :    /*  Add speech and complex hangover and return speech VAD_flag */
; 785  :    /*  long term complex hangover may be added */
; 786  :    st->speech_vad_decision = hangover_addition(st, noise_level, low_power_flag);

  002ad	0f b7 45 b0	 movzx	 eax, WORD PTR _low_power_flag$[ebp]
  002b1	50		 push	 eax
  002b2	0f b7 4d bc	 movzx	 ecx, WORD PTR _noise_level$[ebp]
  002b6	51		 push	 ecx
  002b7	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  002ba	52		 push	 edx
  002bb	e8 00 00 00 00	 call	 _hangover_addition
  002c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002c6	66 89 41 78	 mov	 WORD PTR [ecx+120], ax

; 787  :    move16 ();

  002ca	e8 00 00 00 00	 call	 _move16

; 788  :    
; 789  :    return (st->speech_vad_decision);

  002cf	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002d2	66 8b 40 78	 mov	 ax, WORD PTR [eax+120]

; 790  : }

  002d6	5f		 pop	 edi
  002d7	5e		 pop	 esi
  002d8	5b		 pop	 ebx
  002d9	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  002df	3b ec		 cmp	 ebp, esp
  002e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e6	8b e5		 mov	 esp, ebp
  002e8	5d		 pop	 ebp
  002e9	c3		 ret	 0
_vad_decision ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _complex_vad
_TEXT	SEGMENT
tv160 = -196						; size = 4
_st$ = 8						; size = 4
_low_power$ = 12					; size = 2
_complex_vad PROC					; COMDAT

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 659  :    st->complex_high = shr(st->complex_high, 1);                      move16 ();

  0001e	6a 01		 push	 1
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	0f b7 48 6a	 movzx	 ecx, WORD PTR [eax+106]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _shr
  0002d	83 c4 08	 add	 esp, 8
  00030	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00033	66 89 42 6a	 mov	 WORD PTR [edx+106], ax
  00037	e8 00 00 00 00	 call	 _move16

; 660  :    st->complex_low = shr(st->complex_low, 1);                        move16 ();

  0003c	6a 01		 push	 1
  0003e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00041	0f b7 48 6c	 movzx	 ecx, WORD PTR [eax+108]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _shr
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00051	66 89 42 6c	 mov	 WORD PTR [edx+108], ax
  00055	e8 00 00 00 00	 call	 _move16

; 661  : 
; 662  :    test ();

  0005a	e8 00 00 00 00	 call	 _test

; 663  :    if (low_power == 0)

  0005f	0f bf 45 0c	 movsx	 eax, WORD PTR _low_power$[ebp]
  00063	85 c0		 test	 eax, eax
  00065	75 7e		 jne	 SHORT $LN5@complex_va

; 664  :    {
; 665  :       test ();

  00067	e8 00 00 00 00	 call	 _test

; 666  :       if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) > 0)

  0006c	68 cc 4c 00 00	 push	 19660			; 00004cccH
  00071	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00074	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _sub
  0007e	83 c4 08	 add	 esp, 8
  00081	0f bf d0	 movsx	 edx, ax
  00084	85 d2		 test	 edx, edx
  00086	7e 1e		 jle	 SHORT $LN4@complex_va

; 667  :       {
; 668  :          st->complex_high = st->complex_high | 0x4000;   logic16 (); move16 ();

  00088	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0008b	0f bf 48 6a	 movsx	 ecx, WORD PTR [eax+106]
  0008f	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00095	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00098	66 89 4a 6a	 mov	 WORD PTR [edx+106], cx
  0009c	e8 00 00 00 00	 call	 _logic16
  000a1	e8 00 00 00 00	 call	 _move16
$LN4@complex_va:

; 669  :       }
; 670  :       
; 671  :       test ();

  000a6	e8 00 00 00 00	 call	 _test

; 672  :       if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_LOW) > 0 )

  000ab	68 ff 3f 00 00	 push	 16383			; 00003fffH
  000b0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000b3	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _sub
  000bd	83 c4 08	 add	 esp, 8
  000c0	0f bf d0	 movsx	 edx, ax
  000c3	85 d2		 test	 edx, edx
  000c5	7e 1e		 jle	 SHORT $LN5@complex_va

; 673  :       {
; 674  :          st->complex_low = st->complex_low | 0x4000;     logic16 (); move16 ();

  000c7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ca	0f bf 48 6c	 movsx	 ecx, WORD PTR [eax+108]
  000ce	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  000d4	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000d7	66 89 4a 6c	 mov	 WORD PTR [edx+108], cx
  000db	e8 00 00 00 00	 call	 _logic16
  000e0	e8 00 00 00 00	 call	 _move16
$LN5@complex_va:

; 675  :       }
; 676  :    }
; 677  : 
; 678  :    test ();

  000e5	e8 00 00 00 00	 call	 _test

; 679  :    if (sub(st->corr_hp_fast, CVAD_THRESH_HANG) > 0)

  000ea	68 98 59 00 00	 push	 22936			; 00005998H
  000ef	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000f2	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 _sub
  000fc	83 c4 08	 add	 esp, 8
  000ff	0f bf d0	 movsx	 edx, ax
  00102	85 d2		 test	 edx, edx
  00104	7e 20		 jle	 SHORT $LN2@complex_va

; 680  :    {
; 681  :       st->complex_hang_timer = add(st->complex_hang_timer, 1);       move16 ();

  00106	6a 01		 push	 1
  00108	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0010b	0f b7 48 74	 movzx	 ecx, WORD PTR [eax+116]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _add
  00115	83 c4 08	 add	 esp, 8
  00118	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0011b	66 89 42 74	 mov	 WORD PTR [edx+116], ax
  0011f	e8 00 00 00 00	 call	 _move16

; 682  :    }
; 683  :    else

  00124	eb 0e		 jmp	 SHORT $LN1@complex_va
$LN2@complex_va:

; 684  :    {
; 685  :       st->complex_hang_timer =  0;                                   move16 ();

  00126	33 c0		 xor	 eax, eax
  00128	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0012b	66 89 41 74	 mov	 WORD PTR [ecx+116], ax
  0012f	e8 00 00 00 00	 call	 _move16
$LN1@complex_va:

; 686  :    }               
; 687  :    
; 688  :    test (); logic16 (); test (); logic16 ();

  00134	e8 00 00 00 00	 call	 _test
  00139	e8 00 00 00 00	 call	 _logic16
  0013e	e8 00 00 00 00	 call	 _test
  00143	e8 00 00 00 00	 call	 _logic16

; 689  :    return ((sub((st->complex_high & 0x7f80), 0x7f80) == 0) ||
; 690  :            (sub((st->complex_low & 0x7fff), 0x7fff) == 0));

  00148	68 80 7f 00 00	 push	 32640			; 00007f80H
  0014d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00150	0f bf 48 6a	 movsx	 ecx, WORD PTR [eax+106]
  00154	81 e1 80 7f 00
	00		 and	 ecx, 32640		; 00007f80H
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 _sub
  00160	83 c4 08	 add	 esp, 8
  00163	0f bf d0	 movsx	 edx, ax
  00166	85 d2		 test	 edx, edx
  00168	74 2e		 je	 SHORT $LN8@complex_va
  0016a	68 ff 7f 00 00	 push	 32767			; 00007fffH
  0016f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00172	0f bf 48 6c	 movsx	 ecx, WORD PTR [eax+108]
  00176	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 _sub
  00182	83 c4 08	 add	 esp, 8
  00185	0f bf d0	 movsx	 edx, ax
  00188	85 d2		 test	 edx, edx
  0018a	74 0c		 je	 SHORT $LN8@complex_va
  0018c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
  00196	eb 0a		 jmp	 SHORT $LN9@complex_va
$LN8@complex_va:
  00198	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv160[ebp], 1
$LN9@complex_va:
  001a2	66 8b 85 3c ff
	ff ff		 mov	 ax, WORD PTR tv160[ebp]

; 691  : }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  001b2	3b ec		 cmp	 ebp, esp
  001b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
_complex_vad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _complex_estimate_adapt
_TEXT	SEGMENT
_L_tmp$ = -20						; size = 4
_alpha$ = -8						; size = 2
_st$ = 8						; size = 4
_low_power$ = 12					; size = 2
_complex_estimate_adapt PROC				; COMDAT

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 599  :    Word16 alpha;            /* Q15 */
; 600  :    Word32 L_tmp;            /* Q31 */
; 601  : 
; 602  : 
; 603  :    /* adapt speed on own state */
; 604  :    test ();

  0001e	e8 00 00 00 00	 call	 _test

; 605  :    if (sub(st->best_corr_hp, st->corr_hp_fast) < 0) /* decrease */

  00023	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00026	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0002e	0f b7 42 76	 movzx	 eax, WORD PTR [edx+118]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _sub
  00038	83 c4 08	 add	 esp, 8
  0003b	0f bf c8	 movsx	 ecx, ax
  0003e	85 c9		 test	 ecx, ecx
  00040	7d 41		 jge	 SHORT $LN8@complex_es

; 606  :    {
; 607  :       test ();

  00042	e8 00 00 00 00	 call	 _test

; 608  :       if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) < 0)

  00047	68 cc 4c 00 00	 push	 19660			; 00004cccH
  0004c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0004f	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 _sub
  00059	83 c4 08	 add	 esp, 8
  0005c	0f bf d0	 movsx	 edx, ax
  0005f	85 d2		 test	 edx, edx
  00061	7d 10		 jge	 SHORT $LN7@complex_es

; 609  :       {  /* low state  */
; 610  :          alpha = CVAD_ADAPT_FAST;                          move16(); 

  00063	b8 3d 0a 00 00	 mov	 eax, 2621		; 00000a3dH
  00068	66 89 45 f8	 mov	 WORD PTR _alpha$[ebp], ax
  0006c	e8 00 00 00 00	 call	 _move16

; 611  :       }  
; 612  :       else 

  00071	eb 0e		 jmp	 SHORT $LN6@complex_es
$LN7@complex_es:

; 613  :       {  /* high state */
; 614  :          alpha = CVAD_ADAPT_REALLY_FAST;                   move16();   

  00073	b8 99 19 00 00	 mov	 eax, 6553		; 00001999H
  00078	66 89 45 f8	 mov	 WORD PTR _alpha$[ebp], ax
  0007c	e8 00 00 00 00	 call	 _move16
$LN6@complex_es:

; 615  :       }      
; 616  :    }
; 617  :    else  /* increase */ 

  00081	eb 3f		 jmp	 SHORT $LN5@complex_es
$LN8@complex_es:

; 618  :    {
; 619  :       test ();

  00083	e8 00 00 00 00	 call	 _test

; 620  :       if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) < 0)

  00088	68 cc 4c 00 00	 push	 19660			; 00004cccH
  0008d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00090	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _sub
  0009a	83 c4 08	 add	 esp, 8
  0009d	0f bf d0	 movsx	 edx, ax
  000a0	85 d2		 test	 edx, edx
  000a2	7d 10		 jge	 SHORT $LN4@complex_es

; 621  :       {  
; 622  :          alpha = CVAD_ADAPT_FAST;                          move16(); 

  000a4	b8 3d 0a 00 00	 mov	 eax, 2621		; 00000a3dH
  000a9	66 89 45 f8	 mov	 WORD PTR _alpha$[ebp], ax
  000ad	e8 00 00 00 00	 call	 _move16

; 623  :       }  
; 624  :       else 

  000b2	eb 0e		 jmp	 SHORT $LN5@complex_es
$LN4@complex_es:

; 625  :       {  
; 626  :          alpha = CVAD_ADAPT_SLOW;                          move16();

  000b4	b8 8f 02 00 00	 mov	 eax, 655		; 0000028fH
  000b9	66 89 45 f8	 mov	 WORD PTR _alpha$[ebp], ax
  000bd	e8 00 00 00 00	 call	 _move16
$LN5@complex_es:

; 627  :       }      
; 628  :    }
; 629  : 
; 630  :    L_tmp = L_deposit_h(st->corr_hp_fast);

  000c2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c5	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _L_deposit_h
  000cf	83 c4 04	 add	 esp, 4
  000d2	89 45 ec	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 631  :    L_tmp = L_msu(L_tmp, alpha, st->corr_hp_fast);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d8	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  000dc	51		 push	 ecx
  000dd	0f b7 55 f8	 movzx	 edx, WORD PTR _alpha$[ebp]
  000e1	52		 push	 edx
  000e2	8b 45 ec	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _L_msu
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	89 45 ec	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 632  :    L_tmp = L_mac(L_tmp, alpha, st->best_corr_hp);

  000f1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000f4	0f b7 48 76	 movzx	 ecx, WORD PTR [eax+118]
  000f8	51		 push	 ecx
  000f9	0f b7 55 f8	 movzx	 edx, WORD PTR _alpha$[ebp]
  000fd	52		 push	 edx
  000fe	8b 45 ec	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _L_mac
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 45 ec	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 633  :    st->corr_hp_fast = round(L_tmp);           /* Q15 */    move16();   

  0010d	8b 45 ec	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _round
  00116	83 c4 04	 add	 esp, 4
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0011c	66 89 41 7e	 mov	 WORD PTR [ecx+126], ax
  00120	e8 00 00 00 00	 call	 _move16

; 634  : 
; 635  :    test ();

  00125	e8 00 00 00 00	 call	 _test

; 636  :    if (sub(st->corr_hp_fast, CVAD_MIN_CORR) <  0)

  0012a	68 32 33 00 00	 push	 13106			; 00003332H
  0012f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00132	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _sub
  0013c	83 c4 08	 add	 esp, 8
  0013f	0f bf d0	 movsx	 edx, ax
  00142	85 d2		 test	 edx, edx
  00144	7d 11		 jge	 SHORT $LN2@complex_es

; 637  :    {
; 638  :       st->corr_hp_fast = CVAD_MIN_CORR;                    move16();

  00146	b8 32 33 00 00	 mov	 eax, 13106		; 00003332H
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0014e	66 89 41 7e	 mov	 WORD PTR [ecx+126], ax
  00152	e8 00 00 00 00	 call	 _move16
$LN2@complex_es:

; 639  :    }
; 640  : 
; 641  :    test ();

  00157	e8 00 00 00 00	 call	 _test

; 642  :    if (low_power != 0)

  0015c	0f bf 45 0c	 movsx	 eax, WORD PTR _low_power$[ebp]
  00160	85 c0		 test	 eax, eax
  00162	74 11		 je	 SHORT $LN9@complex_es

; 643  :    {
; 644  :       st->corr_hp_fast = CVAD_MIN_CORR;                    move16();

  00164	b8 32 33 00 00	 mov	 eax, 13106		; 00003332H
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0016c	66 89 41 7e	 mov	 WORD PTR [ecx+126], ax
  00170	e8 00 00 00 00	 call	 _move16
$LN9@complex_es:

; 645  :    }   
; 646  : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0017e	3b ec		 cmp	 ebp, esp
  00180	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_complex_estimate_adapt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _noise_estimate_update
_TEXT	SEGMENT
_temp$1 = -56						; size = 2
_bckr_add$ = -44					; size = 2
_alpha_down$ = -32					; size = 2
_alpha_up$ = -20					; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_level$ = 12						; size = 4
_noise_estimate_update PROC				; COMDAT

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 513  :    Word16 i, alpha_up, alpha_down, bckr_add;
; 514  :    
; 515  :    /* Control update of bckr_est[] */
; 516  :    update_cntrl(st, level);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _level$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _update_cntrl
  0002b	83 c4 08	 add	 esp, 8

; 517  :    
; 518  :    /* Choose update speed */
; 519  :    bckr_add = 2;                                           move16 ();

  0002e	b8 02 00 00 00	 mov	 eax, 2
  00033	66 89 45 d4	 mov	 WORD PTR _bckr_add$[ebp], ax
  00037	e8 00 00 00 00	 call	 _move16

; 520  :    
; 521  :    logic16 (); test (); logic16 (); test (); test ();

  0003c	e8 00 00 00 00	 call	 _logic16
  00041	e8 00 00 00 00	 call	 _test
  00046	e8 00 00 00 00	 call	 _logic16
  0004b	e8 00 00 00 00	 call	 _test
  00050	e8 00 00 00 00	 call	 _test

; 522  :    if (((0x7800 & st->vadreg) == 0) && 
; 523  :        ((st->pitch & 0x7800) == 0) 
; 524  :        &&  (st->complex_hang_count == 0))

  00055	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00058	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  0005c	81 e1 00 78 00
	00		 and	 ecx, 30720		; 00007800H
  00062	75 38		 jne	 SHORT $LN14@noise_esti
  00064	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00067	0f bf 48 66	 movsx	 ecx, WORD PTR [eax+102]
  0006b	81 e1 00 78 00
	00		 and	 ecx, 30720		; 00007800H
  00071	75 29		 jne	 SHORT $LN14@noise_esti
  00073	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00076	0f bf 48 72	 movsx	 ecx, WORD PTR [eax+114]
  0007a	85 c9		 test	 ecx, ecx
  0007c	75 1e		 jne	 SHORT $LN14@noise_esti

; 525  :    {
; 526  :       alpha_up = ALPHA_UP1;                                move16 ();

  0007e	b8 66 06 00 00	 mov	 eax, 1638		; 00000666H
  00083	66 89 45 ec	 mov	 WORD PTR _alpha_up$[ebp], ax
  00087	e8 00 00 00 00	 call	 _move16

; 527  :       alpha_down = ALPHA_DOWN1;                            move16 ();

  0008c	b8 31 08 00 00	 mov	 eax, 2097		; 00000831H
  00091	66 89 45 e0	 mov	 WORD PTR _alpha_down$[ebp], ax
  00095	e8 00 00 00 00	 call	 _move16

; 528  :    }
; 529  :    else 

  0009a	eb 62		 jmp	 SHORT $LN13@noise_esti
$LN14@noise_esti:

; 530  :    {
; 531  :       test (); test ();

  0009c	e8 00 00 00 00	 call	 _test
  000a1	e8 00 00 00 00	 call	 _test

; 532  :       if ((st->stat_count == 0) 
; 533  :           && (st->complex_hang_count == 0))

  000a6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000a9	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  000ad	85 c9		 test	 ecx, ecx
  000af	75 29		 jne	 SHORT $LN12@noise_esti
  000b1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000b4	0f bf 48 72	 movsx	 ecx, WORD PTR [eax+114]
  000b8	85 c9		 test	 ecx, ecx
  000ba	75 1e		 jne	 SHORT $LN12@noise_esti

; 534  :       {
; 535  :          alpha_up = ALPHA_UP2;                             move16 ();

  000bc	b8 eb 01 00 00	 mov	 eax, 491		; 000001ebH
  000c1	66 89 45 ec	 mov	 WORD PTR _alpha_up$[ebp], ax
  000c5	e8 00 00 00 00	 call	 _move16

; 536  :          alpha_down = ALPHA_DOWN2;                         move16 ();

  000ca	b8 4b 07 00 00	 mov	 eax, 1867		; 0000074bH
  000cf	66 89 45 e0	 mov	 WORD PTR _alpha_down$[ebp], ax
  000d3	e8 00 00 00 00	 call	 _move16

; 537  :       }
; 538  :       else

  000d8	eb 24		 jmp	 SHORT $LN13@noise_esti
$LN12@noise_esti:

; 539  :       {
; 540  :          alpha_up = 0;                                     move16 ();

  000da	33 c0		 xor	 eax, eax
  000dc	66 89 45 ec	 mov	 WORD PTR _alpha_up$[ebp], ax
  000e0	e8 00 00 00 00	 call	 _move16

; 541  :          alpha_down = ALPHA3;                              move16 ();

  000e5	b8 66 06 00 00	 mov	 eax, 1638		; 00000666H
  000ea	66 89 45 e0	 mov	 WORD PTR _alpha_down$[ebp], ax
  000ee	e8 00 00 00 00	 call	 _move16

; 542  :          bckr_add = 0;                                     move16 ();

  000f3	33 c0		 xor	 eax, eax
  000f5	66 89 45 d4	 mov	 WORD PTR _bckr_add$[ebp], ax
  000f9	e8 00 00 00 00	 call	 _move16
$LN13@noise_esti:

; 543  :       }
; 544  :    }
; 545  :    
; 546  :    /* Update noise estimate (bckr_est) */
; 547  :    for (i = 0; i < COMPLEN; i++)

  000fe	33 c0		 xor	 eax, eax
  00100	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00104	eb 0c		 jmp	 SHORT $LN10@noise_esti
$LN9@noise_esti:
  00106	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0010a	66 83 c0 01	 add	 ax, 1
  0010e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN10@noise_esti:
  00112	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00116	83 f8 09	 cmp	 eax, 9
  00119	0f 8d 40 01 00
	00		 jge	 $LN8@noise_esti

; 548  :    {
; 549  :       Word16 temp;
; 550  :       temp = sub(st->old_level[i], st->bckr_est[i]);

  0011f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00123	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00126	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0012a	52		 push	 edx
  0012b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00132	0f b7 54 41 24	 movzx	 edx, WORD PTR [ecx+eax*2+36]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _sub
  0013d	83 c4 08	 add	 esp, 8
  00140	66 89 45 c8	 mov	 WORD PTR _temp$1[ebp], ax

; 551  :       
; 552  :       test ();

  00144	e8 00 00 00 00	 call	 _test

; 553  :       if (temp < 0)

  00149	0f bf 45 c8	 movsx	 eax, WORD PTR _temp$1[ebp]
  0014d	85 c0		 test	 eax, eax
  0014f	0f 8d 82 00 00
	00		 jge	 $LN7@noise_esti

; 554  :       { /* update downwards*/
; 555  :          st->bckr_est[i] = add(-2, add(st->bckr_est[i], mult_r(alpha_down, temp)));

  00155	0f b7 45 c8	 movzx	 eax, WORD PTR _temp$1[ebp]
  00159	50		 push	 eax
  0015a	0f b7 4d e0	 movzx	 ecx, WORD PTR _alpha_down$[ebp]
  0015e	51		 push	 ecx
  0015f	e8 00 00 00 00	 call	 _mult_r
  00164	83 c4 08	 add	 esp, 8
  00167	0f b7 d0	 movzx	 edx, ax
  0016a	52		 push	 edx
  0016b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00172	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 _add
  0017c	83 c4 08	 add	 esp, 8
  0017f	0f b7 c0	 movzx	 eax, ax
  00182	50		 push	 eax
  00183	6a fe		 push	 -2			; fffffffeH
  00185	e8 00 00 00 00	 call	 _add
  0018a	83 c4 08	 add	 esp, 8
  0018d	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00191	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00194	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 556  :          move16 ();

  00198	e8 00 00 00 00	 call	 _move16

; 557  :          
; 558  :          /* limit minimum value of the noise estimate to NOISE_MIN */
; 559  :          test ();

  0019d	e8 00 00 00 00	 call	 _test

; 560  :          if (sub(st->bckr_est[i], NOISE_MIN) < 0)

  001a2	6a 28		 push	 40			; 00000028H
  001a4	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001ab	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001af	52		 push	 edx
  001b0	e8 00 00 00 00	 call	 _sub
  001b5	83 c4 08	 add	 esp, 8
  001b8	98		 cwde
  001b9	85 c0		 test	 eax, eax
  001bb	7d 15		 jge	 SHORT $LN6@noise_esti

; 561  :          {
; 562  :             st->bckr_est[i] = NOISE_MIN;                  move16 ();

  001bd	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001c1	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  001c6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001c9	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001cd	e8 00 00 00 00	 call	 _move16
$LN6@noise_esti:

; 563  :          }
; 564  :       }
; 565  :       else

  001d2	e9 83 00 00 00	 jmp	 $LN5@noise_esti
$LN7@noise_esti:

; 566  :       { /* update upwards */
; 567  :          st->bckr_est[i] = add(bckr_add, add(st->bckr_est[i], mult_r(alpha_up, temp)));

  001d7	0f b7 45 c8	 movzx	 eax, WORD PTR _temp$1[ebp]
  001db	50		 push	 eax
  001dc	0f b7 4d ec	 movzx	 ecx, WORD PTR _alpha_up$[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 _mult_r
  001e6	83 c4 08	 add	 esp, 8
  001e9	0f b7 d0	 movzx	 edx, ax
  001ec	52		 push	 edx
  001ed	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001f4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 _add
  001fe	83 c4 08	 add	 esp, 8
  00201	0f b7 c0	 movzx	 eax, ax
  00204	50		 push	 eax
  00205	0f b7 4d d4	 movzx	 ecx, WORD PTR _bckr_add$[ebp]
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _add
  0020f	83 c4 08	 add	 esp, 8
  00212	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00216	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00219	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 568  :          move16 ();

  0021d	e8 00 00 00 00	 call	 _move16

; 569  :          
; 570  :          /* limit maximum value of the noise estimate to NOISE_MAX */
; 571  :          test ();

  00222	e8 00 00 00 00	 call	 _test

; 572  :          if (sub(st->bckr_est[i], NOISE_MAX) > 0)

  00227	68 80 3e 00 00	 push	 16000			; 00003e80H
  0022c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00230	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00233	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00237	52		 push	 edx
  00238	e8 00 00 00 00	 call	 _sub
  0023d	83 c4 08	 add	 esp, 8
  00240	98		 cwde
  00241	85 c0		 test	 eax, eax
  00243	7e 15		 jle	 SHORT $LN5@noise_esti

; 573  :          {
; 574  :             st->bckr_est[i] = NOISE_MAX;                  move16 ();

  00245	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00249	b9 80 3e 00 00	 mov	 ecx, 16000		; 00003e80H
  0024e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00251	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00255	e8 00 00 00 00	 call	 _move16
$LN5@noise_esti:

; 575  :          }
; 576  :       }
; 577  :    }

  0025a	e9 a7 fe ff ff	 jmp	 $LN9@noise_esti
$LN8@noise_esti:

; 578  :    
; 579  :    /* Update signal levels of the previous frame (old_level) */
; 580  :    for(i = 0; i < COMPLEN; i++)

  0025f	33 c0		 xor	 eax, eax
  00261	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00265	eb 0c		 jmp	 SHORT $LN3@noise_esti
$LN2@noise_esti:
  00267	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0026b	66 83 c0 01	 add	 ax, 1
  0026f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@noise_esti:
  00273	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00277	83 f8 09	 cmp	 eax, 9
  0027a	7d 1e		 jge	 SHORT $LN15@noise_esti

; 581  :    {
; 582  :       st->old_level[i] = level[i];                        move16 ();

  0027c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00280	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00284	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00287	8b 75 0c	 mov	 esi, DWORD PTR _level$[ebp]
  0028a	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  0028e	66 89 44 4a 24	 mov	 WORD PTR [edx+ecx*2+36], ax
  00293	e8 00 00 00 00	 call	 _move16

; 583  :    }

  00298	eb cd		 jmp	 SHORT $LN2@noise_esti
$LN15@noise_esti:

; 584  : }

  0029a	5f		 pop	 edi
  0029b	5e		 pop	 esi
  0029c	5b		 pop	 ebx
  0029d	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  002a3	3b ec		 cmp	 ebp, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c3		 ret	 0
_noise_estimate_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _hangover_addition
_TEXT	SEGMENT
_burst_len$ = -20					; size = 2
_hang_len$ = -8						; size = 2
_st$ = 8						; size = 4
_noise_level$ = 12					; size = 2
_low_power$ = 16					; size = 2
_hangover_addition PROC					; COMDAT

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 411  :    Word16 hang_len, burst_len;
; 412  :    
; 413  :    /* 
; 414  :       Calculate burst_len and hang_len
; 415  :       burst_len: number of consecutive intermediate vad flags with "1"-decision
; 416  :                  required for hangover addition
; 417  :       hang_len:  length of the hangover
; 418  :       */
; 419  : 
; 420  :    test ();

  0001e	e8 00 00 00 00	 call	 _test

; 421  :    if (sub(noise_level, HANG_NOISE_THR) > 0)

  00023	6a 64		 push	 100			; 00000064H
  00025	0f b7 45 0c	 movzx	 eax, WORD PTR _noise_level$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sub
  0002f	83 c4 08	 add	 esp, 8
  00032	0f bf c8	 movsx	 ecx, ax
  00035	85 c9		 test	 ecx, ecx
  00037	7e 1e		 jle	 SHORT $LN12@hangover_a

; 422  :    {
; 423  :       burst_len = BURST_LEN_HIGH_NOISE;                           move16 ();

  00039	b8 04 00 00 00	 mov	 eax, 4
  0003e	66 89 45 ec	 mov	 WORD PTR _burst_len$[ebp], ax
  00042	e8 00 00 00 00	 call	 _move16

; 424  :       hang_len = HANG_LEN_HIGH_NOISE;                             move16 ();

  00047	b8 07 00 00 00	 mov	 eax, 7
  0004c	66 89 45 f8	 mov	 WORD PTR _hang_len$[ebp], ax
  00050	e8 00 00 00 00	 call	 _move16

; 425  :    }
; 426  :    else

  00055	eb 1c		 jmp	 SHORT $LN11@hangover_a
$LN12@hangover_a:

; 427  :    {
; 428  :       burst_len = BURST_LEN_LOW_NOISE;                            move16 ();

  00057	b8 05 00 00 00	 mov	 eax, 5
  0005c	66 89 45 ec	 mov	 WORD PTR _burst_len$[ebp], ax
  00060	e8 00 00 00 00	 call	 _move16

; 429  :       hang_len = HANG_LEN_LOW_NOISE;                              move16 ();

  00065	b8 04 00 00 00	 mov	 eax, 4
  0006a	66 89 45 f8	 mov	 WORD PTR _hang_len$[ebp], ax
  0006e	e8 00 00 00 00	 call	 _move16
$LN11@hangover_a:

; 430  :    }
; 431  :    
; 432  :    /* if the input power (pow_sum) is lower than a threshold, clear
; 433  :       counters and set VAD_flag to "0"  "fast exit"                 */
; 434  :    test ();

  00073	e8 00 00 00 00	 call	 _test

; 435  :    if (low_power != 0)

  00078	0f bf 45 10	 movsx	 eax, WORD PTR _low_power$[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 3f		 je	 SHORT $LN10@hangover_a

; 436  :    {
; 437  :       st->burst_count = 0;                                        move16 ();

  00080	33 c0		 xor	 eax, eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00085	66 89 41 5e	 mov	 WORD PTR [ecx+94], ax
  00089	e8 00 00 00 00	 call	 _move16

; 438  :       st->hang_count = 0;                                         move16 ();

  0008e	33 c0		 xor	 eax, eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00093	66 89 41 60	 mov	 WORD PTR [ecx+96], ax
  00097	e8 00 00 00 00	 call	 _move16

; 439  :       st->complex_hang_count = 0;                                 move16 ();

  0009c	33 c0		 xor	 eax, eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a1	66 89 41 72	 mov	 WORD PTR [ecx+114], ax
  000a5	e8 00 00 00 00	 call	 _move16

; 440  :       st->complex_hang_timer = 0;                                 move16 ();

  000aa	33 c0		 xor	 eax, eax
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000af	66 89 41 74	 mov	 WORD PTR [ecx+116], ax
  000b3	e8 00 00 00 00	 call	 _move16

; 441  :       return 0;

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 93 01 00 00	 jmp	 $LN13@hangover_a
$LN10@hangover_a:

; 442  :    }
; 443  :    
; 444  :    test ();

  000bf	e8 00 00 00 00	 call	 _test

; 445  :    if (sub(st->complex_hang_timer, CVAD_HANG_LIMIT) > 0)

  000c4	6a 64		 push	 100			; 00000064H
  000c6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000c9	0f b7 48 74	 movzx	 ecx, WORD PTR [eax+116]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 _sub
  000d3	83 c4 08	 add	 esp, 8
  000d6	0f bf d0	 movsx	 edx, ax
  000d9	85 d2		 test	 edx, edx
  000db	7e 32		 jle	 SHORT $LN9@hangover_a

; 446  :    {
; 447  :       test ();

  000dd	e8 00 00 00 00	 call	 _test

; 448  :       if (sub(st->complex_hang_count, CVAD_HANG_LENGTH) < 0)

  000e2	68 fa 00 00 00	 push	 250			; 000000faH
  000e7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000ea	0f b7 48 72	 movzx	 ecx, WORD PTR [eax+114]
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 _sub
  000f4	83 c4 08	 add	 esp, 8
  000f7	0f bf d0	 movsx	 edx, ax
  000fa	85 d2		 test	 edx, edx
  000fc	7d 11		 jge	 SHORT $LN9@hangover_a

; 449  :       {
; 450  :          st->complex_hang_count = CVAD_HANG_LENGTH;               move16 ();

  000fe	b8 fa 00 00 00	 mov	 eax, 250		; 000000faH
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00106	66 89 41 72	 mov	 WORD PTR [ecx+114], ax
  0010a	e8 00 00 00 00	 call	 _move16
$LN9@hangover_a:

; 451  :       }      
; 452  :    }
; 453  :    
; 454  :    /* long time very complex signal override VAD output function */
; 455  :    test ();

  0010f	e8 00 00 00 00	 call	 _test

; 456  :    if (st->complex_hang_count != 0)

  00114	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00117	0f bf 48 72	 movsx	 ecx, WORD PTR [eax+114]
  0011b	85 c9		 test	 ecx, ecx
  0011d	74 3b		 je	 SHORT $LN7@hangover_a

; 457  :    {
; 458  :       st->burst_count = BURST_LEN_HIGH_NOISE;                     move16 ();

  0011f	b8 04 00 00 00	 mov	 eax, 4
  00124	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00127	66 89 41 5e	 mov	 WORD PTR [ecx+94], ax
  0012b	e8 00 00 00 00	 call	 _move16

; 459  :       st->complex_hang_count = sub(st->complex_hang_count, 1);    move16 ();

  00130	6a 01		 push	 1
  00132	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00135	0f b7 48 72	 movzx	 ecx, WORD PTR [eax+114]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _sub
  0013f	83 c4 08	 add	 esp, 8
  00142	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00145	66 89 42 72	 mov	 WORD PTR [edx+114], ax
  00149	e8 00 00 00 00	 call	 _move16

; 460  :       return 1; 

  0014e	b8 01 00 00 00	 mov	 eax, 1
  00153	e9 fa 00 00 00	 jmp	 $LN13@hangover_a

; 461  :    }
; 462  :    else

  00158	eb 44		 jmp	 SHORT $LN6@hangover_a
$LN7@hangover_a:

; 463  :    {
; 464  :       /* let hp_corr work in from a noise_period indicated by the VAD */
; 465  :       test (); test (); logic16 ();

  0015a	e8 00 00 00 00	 call	 _test
  0015f	e8 00 00 00 00	 call	 _test
  00164	e8 00 00 00 00	 call	 _logic16

; 466  :       if (((st->vadreg & 0x3ff0) == 0) &&
; 467  :           (sub(st->corr_hp_fast, CVAD_THRESH_IN_NOISE) > 0))

  00169	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0016c	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  00170	81 e1 f0 3f 00
	00		 and	 ecx, 16368		; 00003ff0H
  00176	75 26		 jne	 SHORT $LN6@hangover_a
  00178	68 32 53 00 00	 push	 21298			; 00005332H
  0017d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00180	0f b7 48 7e	 movzx	 ecx, WORD PTR [eax+126]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _sub
  0018a	83 c4 08	 add	 esp, 8
  0018d	0f bf d0	 movsx	 edx, ax
  00190	85 d2		 test	 edx, edx
  00192	7e 0a		 jle	 SHORT $LN6@hangover_a

; 468  :       {
; 469  :          return 1;

  00194	b8 01 00 00 00	 mov	 eax, 1
  00199	e9 b4 00 00 00	 jmp	 $LN13@hangover_a
$LN6@hangover_a:

; 470  :       }  
; 471  :    }
; 472  : 
; 473  :    /* update the counters (hang_count, burst_count) */
; 474  :    logic16 (); test ();

  0019e	e8 00 00 00 00	 call	 _logic16
  001a3	e8 00 00 00 00	 call	 _test

; 475  :    if ((st->vadreg & 0x4000) != 0)

  001a8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001ab	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  001af	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  001b5	74 56		 je	 SHORT $LN4@hangover_a

; 476  :    {
; 477  :       st->burst_count = add(st->burst_count, 1);                  move16 ();

  001b7	6a 01		 push	 1
  001b9	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001bc	0f b7 48 5e	 movzx	 ecx, WORD PTR [eax+94]
  001c0	51		 push	 ecx
  001c1	e8 00 00 00 00	 call	 _add
  001c6	83 c4 08	 add	 esp, 8
  001c9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001cc	66 89 42 5e	 mov	 WORD PTR [edx+94], ax
  001d0	e8 00 00 00 00	 call	 _move16

; 478  :       test ();

  001d5	e8 00 00 00 00	 call	 _test

; 479  :       if (sub(st->burst_count, burst_len) >= 0)

  001da	0f b7 45 ec	 movzx	 eax, WORD PTR _burst_len$[ebp]
  001de	50		 push	 eax
  001df	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001e2	0f b7 51 5e	 movzx	 edx, WORD PTR [ecx+94]
  001e6	52		 push	 edx
  001e7	e8 00 00 00 00	 call	 _sub
  001ec	83 c4 08	 add	 esp, 8
  001ef	98		 cwde
  001f0	85 c0		 test	 eax, eax
  001f2	7c 10		 jl	 SHORT $LN3@hangover_a

; 480  :       {
; 481  :          st->hang_count = hang_len;                               move16 ();

  001f4	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001f7	66 8b 4d f8	 mov	 cx, WORD PTR _hang_len$[ebp]
  001fb	66 89 48 60	 mov	 WORD PTR [eax+96], cx
  001ff	e8 00 00 00 00	 call	 _move16
$LN3@hangover_a:

; 482  :       }
; 483  :       return 1;

  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	eb 47		 jmp	 SHORT $LN13@hangover_a

; 484  :    }
; 485  :    else

  0020b	eb 43		 jmp	 SHORT $LN2@hangover_a
$LN4@hangover_a:

; 486  :    {
; 487  :       st->burst_count = 0;                                        move16 ();

  0020d	33 c0		 xor	 eax, eax
  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00212	66 89 41 5e	 mov	 WORD PTR [ecx+94], ax
  00216	e8 00 00 00 00	 call	 _move16

; 488  :       test ();

  0021b	e8 00 00 00 00	 call	 _test

; 489  :       if (st->hang_count > 0)

  00220	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00223	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  00227	85 c9		 test	 ecx, ecx
  00229	7e 25		 jle	 SHORT $LN2@hangover_a

; 490  :       {
; 491  :          st->hang_count = sub(st->hang_count, 1);                 move16 ();

  0022b	6a 01		 push	 1
  0022d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00230	0f b7 48 60	 movzx	 ecx, WORD PTR [eax+96]
  00234	51		 push	 ecx
  00235	e8 00 00 00 00	 call	 _sub
  0023a	83 c4 08	 add	 esp, 8
  0023d	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00240	66 89 42 60	 mov	 WORD PTR [edx+96], ax
  00244	e8 00 00 00 00	 call	 _move16

; 492  :          return 1;

  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	eb 02		 jmp	 SHORT $LN13@hangover_a
$LN2@hangover_a:

; 493  :       }
; 494  :    }
; 495  :    return 0;

  00250	33 c0		 xor	 eax, eax
$LN13@hangover_a:

; 496  : }

  00252	5f		 pop	 edi
  00253	5e		 pop	 esi
  00254	5b		 pop	 ebx
  00255	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0025b	3b ec		 cmp	 ebp, esp
  0025d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c3		 ret	 0
_hangover_addition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _update_cntrl
_TEXT	SEGMENT
_alpha$ = -80						; size = 2
_denom$ = -68						; size = 2
_num$ = -56						; size = 2
_exp$ = -44						; size = 2
_stat_rat$ = -32					; size = 2
_temp$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_level$ = 12						; size = 4
_update_cntrl PROC					; COMDAT

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 279  :   Word16 i, temp, stat_rat, exp;
; 280  :   Word16 num, denom;
; 281  :   Word16 alpha; 
; 282  : 
; 283  :   /* handle highband complex signal input  separately       */
; 284  :   /* if ther has been highband correlation for some time    */
; 285  :   /* make sure that the VAD update speed is low for a while */
; 286  :   test ();

  0001e	e8 00 00 00 00	 call	 _test

; 287  :   if (st->complex_warning != 0)

  00023	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00026	0f bf 48 7a	 movsx	 ecx, WORD PTR [eax+122]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 2f		 je	 SHORT $LN24@update_cnt

; 288  :   {
; 289  :      test ();

  0002e	e8 00 00 00 00	 call	 _test

; 290  :      if (sub(st->stat_count, CAD_MIN_STAT_COUNT) < 0)

  00033	6a 05		 push	 5
  00035	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00038	0f b7 48 62	 movzx	 ecx, WORD PTR [eax+98]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _sub
  00042	83 c4 08	 add	 esp, 8
  00045	0f bf d0	 movsx	 edx, ax
  00048	85 d2		 test	 edx, edx
  0004a	7d 11		 jge	 SHORT $LN24@update_cnt

; 291  :      {
; 292  :         st->stat_count = CAD_MIN_STAT_COUNT;              move16 ();    

  0004c	b8 05 00 00 00	 mov	 eax, 5
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00054	66 89 41 62	 mov	 WORD PTR [ecx+98], ax
  00058	e8 00 00 00 00	 call	 _move16
$LN24@update_cnt:

; 293  :      }
; 294  :   }
; 295  :   /* NB stat_count is allowed to be decreased by one below again  */
; 296  :   /* deadlock in speech is not possible unless the signal is very */
; 297  :   /* complex and need a high rate                                 */
; 298  : 
; 299  :   /* if fullband pitch or tone have been detected for a while, initialize stat_count */
; 300  :   logic16 (); test (); logic16 (); test ();

  0005d	e8 00 00 00 00	 call	 _logic16
  00062	e8 00 00 00 00	 call	 _test
  00067	e8 00 00 00 00	 call	 _logic16
  0006c	e8 00 00 00 00	 call	 _test

; 301  :   if ((sub((st->pitch & 0x6000), 0x6000) == 0) ||
; 302  :       (sub((st->tone & 0x7c00), 0x7c00) == 0))

  00071	68 00 60 00 00	 push	 24576			; 00006000H
  00076	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00079	0f bf 48 66	 movsx	 ecx, WORD PTR [eax+102]
  0007d	81 e1 00 60 00
	00		 and	 ecx, 24576		; 00006000H
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _sub
  00089	83 c4 08	 add	 esp, 8
  0008c	0f bf d0	 movsx	 edx, ax
  0008f	85 d2		 test	 edx, edx
  00091	74 22		 je	 SHORT $LN21@update_cnt
  00093	68 00 7c 00 00	 push	 31744			; 00007c00H
  00098	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0009b	0f bf 48 68	 movsx	 ecx, WORD PTR [eax+104]
  0009f	81 e1 00 7c 00
	00		 and	 ecx, 31744		; 00007c00H
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _sub
  000ab	83 c4 08	 add	 esp, 8
  000ae	0f bf d0	 movsx	 edx, ax
  000b1	85 d2		 test	 edx, edx
  000b3	75 16		 jne	 SHORT $LN22@update_cnt
$LN21@update_cnt:

; 303  :   {
; 304  :      st->stat_count = STAT_COUNT;                          move16 ();  

  000b5	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000bd	66 89 41 62	 mov	 WORD PTR [ecx+98], ax
  000c1	e8 00 00 00 00	 call	 _move16

; 305  :   }
; 306  :   else

  000c6	e9 2f 02 00 00	 jmp	 $LN20@update_cnt
$LN22@update_cnt:

; 307  :   {
; 308  :      /* if 8 last vad-decisions have been "0", reinitialize stat_count */
; 309  :      logic16 (); test ();

  000cb	e8 00 00 00 00	 call	 _logic16
  000d0	e8 00 00 00 00	 call	 _test

; 310  :      if ((st->vadreg & 0x7f80) == 0) 

  000d5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d8	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  000dc	81 e1 80 7f 00
	00		 and	 ecx, 32640		; 00007f80H
  000e2	75 16		 jne	 SHORT $LN19@update_cnt

; 311  :      { 
; 312  :         st->stat_count = STAT_COUNT;                       move16 ();

  000e4	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000ec	66 89 41 62	 mov	 WORD PTR [ecx+98], ax
  000f0	e8 00 00 00 00	 call	 _move16

; 313  :      }
; 314  :      else

  000f5	e9 00 02 00 00	 jmp	 $LN20@update_cnt
$LN19@update_cnt:

; 315  :      {
; 316  :         stat_rat = 0;                                      move16 ();

  000fa	33 c0		 xor	 eax, eax
  000fc	66 89 45 e0	 mov	 WORD PTR _stat_rat$[ebp], ax
  00100	e8 00 00 00 00	 call	 _move16

; 317  :         for (i = 0; i < COMPLEN; i++)

  00105	33 c0		 xor	 eax, eax
  00107	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0010b	eb 0c		 jmp	 SHORT $LN17@update_cnt
$LN16@update_cnt:
  0010d	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00111	66 83 c0 01	 add	 ax, 1
  00115	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN17@update_cnt:
  00119	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0011d	83 f8 09	 cmp	 eax, 9
  00120	0f 8d 5c 01 00
	00		 jge	 $LN15@update_cnt

; 318  :         {
; 319  :            test ();

  00126	e8 00 00 00 00	 call	 _test

; 320  :            if (sub(level[i], st->ave_level[i]) > 0)

  0012b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00132	0f b7 54 41 12	 movzx	 edx, WORD PTR [ecx+eax*2+18]
  00137	52		 push	 edx
  00138	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0013c	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  0013f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _sub
  00149	83 c4 08	 add	 esp, 8
  0014c	98		 cwde
  0014d	85 c0		 test	 eax, eax
  0014f	7e 2b		 jle	 SHORT $LN14@update_cnt

; 321  :            {
; 322  :               num = level[i];                              move16 ();

  00151	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00155	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  00158	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0015c	66 89 55 c8	 mov	 WORD PTR _num$[ebp], dx
  00160	e8 00 00 00 00	 call	 _move16

; 323  :               denom = st->ave_level[i];                    move16 ();

  00165	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0016c	66 8b 54 41 12	 mov	 dx, WORD PTR [ecx+eax*2+18]
  00171	66 89 55 bc	 mov	 WORD PTR _denom$[ebp], dx
  00175	e8 00 00 00 00	 call	 _move16

; 324  :            }
; 325  :            else

  0017a	eb 29		 jmp	 SHORT $LN13@update_cnt
$LN14@update_cnt:

; 326  :            {
; 327  :               num = st->ave_level[i];                      move16 ();

  0017c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00183	66 8b 54 41 12	 mov	 dx, WORD PTR [ecx+eax*2+18]
  00188	66 89 55 c8	 mov	 WORD PTR _num$[ebp], dx
  0018c	e8 00 00 00 00	 call	 _move16

; 328  :               denom = level[i];                            move16 ();

  00191	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  00198	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0019c	66 89 55 bc	 mov	 WORD PTR _denom$[ebp], dx
  001a0	e8 00 00 00 00	 call	 _move16
$LN13@update_cnt:

; 329  :            }
; 330  :            /* Limit nimimum value of num and denom to STAT_THR_LEVEL */
; 331  :            test ();

  001a5	e8 00 00 00 00	 call	 _test

; 332  :            if (sub(num, STAT_THR_LEVEL) < 0)

  001aa	68 b8 00 00 00	 push	 184			; 000000b8H
  001af	0f b7 45 c8	 movzx	 eax, WORD PTR _num$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _sub
  001b9	83 c4 08	 add	 esp, 8
  001bc	0f bf c8	 movsx	 ecx, ax
  001bf	85 c9		 test	 ecx, ecx
  001c1	7d 0e		 jge	 SHORT $LN12@update_cnt

; 333  :            {
; 334  :               num = STAT_THR_LEVEL;                        move16 ();

  001c3	b8 b8 00 00 00	 mov	 eax, 184		; 000000b8H
  001c8	66 89 45 c8	 mov	 WORD PTR _num$[ebp], ax
  001cc	e8 00 00 00 00	 call	 _move16
$LN12@update_cnt:

; 335  :            }
; 336  :            test ();

  001d1	e8 00 00 00 00	 call	 _test

; 337  :            if (sub(denom, STAT_THR_LEVEL) < 0)

  001d6	68 b8 00 00 00	 push	 184			; 000000b8H
  001db	0f b7 45 bc	 movzx	 eax, WORD PTR _denom$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _sub
  001e5	83 c4 08	 add	 esp, 8
  001e8	0f bf c8	 movsx	 ecx, ax
  001eb	85 c9		 test	 ecx, ecx
  001ed	7d 0e		 jge	 SHORT $LN11@update_cnt

; 338  :            {
; 339  :               denom = STAT_THR_LEVEL;                      move16 ();

  001ef	b8 b8 00 00 00	 mov	 eax, 184		; 000000b8H
  001f4	66 89 45 bc	 mov	 WORD PTR _denom$[ebp], ax
  001f8	e8 00 00 00 00	 call	 _move16
$LN11@update_cnt:

; 340  :            }
; 341  :            
; 342  :            exp = norm_s(denom);

  001fd	0f b7 45 bc	 movzx	 eax, WORD PTR _denom$[ebp]
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 _norm_s
  00207	83 c4 04	 add	 esp, 4
  0020a	66 89 45 d4	 mov	 WORD PTR _exp$[ebp], ax

; 343  :            denom = shl(denom, exp);

  0020e	0f b7 45 d4	 movzx	 eax, WORD PTR _exp$[ebp]
  00212	50		 push	 eax
  00213	0f b7 4d bc	 movzx	 ecx, WORD PTR _denom$[ebp]
  00217	51		 push	 ecx
  00218	e8 00 00 00 00	 call	 _shl
  0021d	83 c4 08	 add	 esp, 8
  00220	66 89 45 bc	 mov	 WORD PTR _denom$[ebp], ax

; 344  :            
; 345  :            /* stat_rat = num/denom * 64 */
; 346  :            temp = div_s(shr(num, 1), denom);

  00224	0f b7 45 bc	 movzx	 eax, WORD PTR _denom$[ebp]
  00228	50		 push	 eax
  00229	6a 01		 push	 1
  0022b	0f b7 4d c8	 movzx	 ecx, WORD PTR _num$[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _shr
  00235	83 c4 08	 add	 esp, 8
  00238	0f b7 d0	 movzx	 edx, ax
  0023b	52		 push	 edx
  0023c	e8 00 00 00 00	 call	 _div_s
  00241	83 c4 08	 add	 esp, 8
  00244	66 89 45 ec	 mov	 WORD PTR _temp$[ebp], ax

; 347  :            stat_rat = add(stat_rat, shr(temp, sub(8, exp)));

  00248	0f b7 45 d4	 movzx	 eax, WORD PTR _exp$[ebp]
  0024c	50		 push	 eax
  0024d	6a 08		 push	 8
  0024f	e8 00 00 00 00	 call	 _sub
  00254	83 c4 08	 add	 esp, 8
  00257	0f b7 c8	 movzx	 ecx, ax
  0025a	51		 push	 ecx
  0025b	0f b7 55 ec	 movzx	 edx, WORD PTR _temp$[ebp]
  0025f	52		 push	 edx
  00260	e8 00 00 00 00	 call	 _shr
  00265	83 c4 08	 add	 esp, 8
  00268	0f b7 c0	 movzx	 eax, ax
  0026b	50		 push	 eax
  0026c	0f b7 4d e0	 movzx	 ecx, WORD PTR _stat_rat$[ebp]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 _add
  00276	83 c4 08	 add	 esp, 8
  00279	66 89 45 e0	 mov	 WORD PTR _stat_rat$[ebp], ax

; 348  :         }

  0027d	e9 8b fe ff ff	 jmp	 $LN16@update_cnt
$LN15@update_cnt:

; 349  :         
; 350  :         /* compare stat_rat with a threshold and update stat_count */
; 351  :         test ();

  00282	e8 00 00 00 00	 call	 _test

; 352  :         if (sub(stat_rat, STAT_THR) > 0)

  00287	68 e8 03 00 00	 push	 1000			; 000003e8H
  0028c	0f b7 45 e0	 movzx	 eax, WORD PTR _stat_rat$[ebp]
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 _sub
  00296	83 c4 08	 add	 esp, 8
  00299	0f bf c8	 movsx	 ecx, ax
  0029c	85 c9		 test	 ecx, ecx
  0029e	7e 13		 jle	 SHORT $LN10@update_cnt

; 353  :         {
; 354  :            st->stat_count = STAT_COUNT;                    move16 ();

  002a0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002a8	66 89 41 62	 mov	 WORD PTR [ecx+98], ax
  002ac	e8 00 00 00 00	 call	 _move16

; 355  :         }
; 356  :         else

  002b1	eb 47		 jmp	 SHORT $LN20@update_cnt
$LN10@update_cnt:

; 357  :         {
; 358  :            logic16 ();test ();

  002b3	e8 00 00 00 00	 call	 _logic16
  002b8	e8 00 00 00 00	 call	 _test

; 359  :            if ((st->vadreg & 0x4000) != 0)

  002bd	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002c0	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  002c4	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  002ca	74 2e		 je	 SHORT $LN20@update_cnt

; 360  :            {
; 361  :               test ();

  002cc	e8 00 00 00 00	 call	 _test

; 362  :               if (st->stat_count != 0)

  002d1	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002d4	0f bf 48 62	 movsx	 ecx, WORD PTR [eax+98]
  002d8	85 c9		 test	 ecx, ecx
  002da	74 1e		 je	 SHORT $LN20@update_cnt

; 363  :               {
; 364  :                  st->stat_count = sub(st->stat_count, 1);  move16 ();

  002dc	6a 01		 push	 1
  002de	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002e1	0f b7 48 62	 movzx	 ecx, WORD PTR [eax+98]
  002e5	51		 push	 ecx
  002e6	e8 00 00 00 00	 call	 _sub
  002eb	83 c4 08	 add	 esp, 8
  002ee	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  002f1	66 89 42 62	 mov	 WORD PTR [edx+98], ax
  002f5	e8 00 00 00 00	 call	 _move16
$LN20@update_cnt:

; 365  :               }
; 366  :            }
; 367  :         }
; 368  :      }
; 369  :   }
; 370  :   
; 371  :   /* Update average amplitude estimate for stationarity estimation */
; 372  :   alpha = ALPHA4;                                          move16 ();

  002fa	b8 cc 0c 00 00	 mov	 eax, 3276		; 00000cccH
  002ff	66 89 45 b0	 mov	 WORD PTR _alpha$[ebp], ax
  00303	e8 00 00 00 00	 call	 _move16

; 373  :   test ();

  00308	e8 00 00 00 00	 call	 _test

; 374  :   if (sub(st->stat_count, STAT_COUNT) == 0) 

  0030d	6a 14		 push	 20			; 00000014H
  0030f	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00312	0f b7 48 62	 movzx	 ecx, WORD PTR [eax+98]
  00316	51		 push	 ecx
  00317	e8 00 00 00 00	 call	 _sub
  0031c	83 c4 08	 add	 esp, 8
  0031f	0f bf d0	 movsx	 edx, ax
  00322	85 d2		 test	 edx, edx
  00324	75 10		 jne	 SHORT $LN6@update_cnt

; 375  :   {
; 376  :      alpha = 32767;                                        move16 ();

  00326	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0032b	66 89 45 b0	 mov	 WORD PTR _alpha$[ebp], ax
  0032f	e8 00 00 00 00	 call	 _move16
  00334	eb 27		 jmp	 SHORT $LN5@update_cnt
$LN6@update_cnt:

; 377  :   }
; 378  :   else if ((st->vadreg & 0x4000) == 0) 

  00336	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00339	0f bf 48 64	 movsx	 ecx, WORD PTR [eax+100]
  0033d	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00343	75 18		 jne	 SHORT $LN5@update_cnt

; 379  :   {
; 380  :      logic16 (); test ();

  00345	e8 00 00 00 00	 call	 _logic16
  0034a	e8 00 00 00 00	 call	 _test

; 381  :      alpha = ALPHA5;                                       move16 ();

  0034f	b8 ff 3f 00 00	 mov	 eax, 16383		; 00003fffH
  00354	66 89 45 b0	 mov	 WORD PTR _alpha$[ebp], ax
  00358	e8 00 00 00 00	 call	 _move16
$LN5@update_cnt:

; 382  :   }
; 383  :   
; 384  :   for (i = 0; i < COMPLEN; i++)

  0035d	33 c0		 xor	 eax, eax
  0035f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00363	eb 0c		 jmp	 SHORT $LN3@update_cnt
$LN2@update_cnt:
  00365	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00369	66 83 c0 01	 add	 ax, 1
  0036d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@update_cnt:
  00371	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00375	83 f8 09	 cmp	 eax, 9
  00378	7d 5e		 jge	 SHORT $LN25@update_cnt

; 385  :   {
; 386  :      st->ave_level[i] = add(st->ave_level[i],
; 387  :                             mult_r(alpha, sub(level[i], st->ave_level[i])));

  0037a	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0037e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00381	0f b7 54 41 12	 movzx	 edx, WORD PTR [ecx+eax*2+18]
  00386	52		 push	 edx
  00387	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0038b	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  0038e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00392	52		 push	 edx
  00393	e8 00 00 00 00	 call	 _sub
  00398	83 c4 08	 add	 esp, 8
  0039b	0f b7 c0	 movzx	 eax, ax
  0039e	50		 push	 eax
  0039f	0f b7 4d b0	 movzx	 ecx, WORD PTR _alpha$[ebp]
  003a3	51		 push	 ecx
  003a4	e8 00 00 00 00	 call	 _mult_r
  003a9	83 c4 08	 add	 esp, 8
  003ac	0f b7 d0	 movzx	 edx, ax
  003af	52		 push	 edx
  003b0	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  003b4	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  003b7	0f b7 54 41 12	 movzx	 edx, WORD PTR [ecx+eax*2+18]
  003bc	52		 push	 edx
  003bd	e8 00 00 00 00	 call	 _add
  003c2	83 c4 08	 add	 esp, 8
  003c5	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  003c9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  003cc	66 89 44 4a 12	 mov	 WORD PTR [edx+ecx*2+18], ax

; 388  :      move16 ();

  003d1	e8 00 00 00 00	 call	 _move16

; 389  :   }  

  003d6	eb 8d		 jmp	 SHORT $LN2@update_cnt
$LN25@update_cnt:

; 390  : }

  003d8	5f		 pop	 edi
  003d9	5e		 pop	 esi
  003da	5b		 pop	 ebx
  003db	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  003e1	3b ec		 cmp	 ebp, esp
  003e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e8	8b e5		 mov	 esp, ebp
  003ea	5d		 pop	 ebp
  003eb	c3		 ret	 0
_update_cntrl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _filter_bank
_TEXT	SEGMENT
_tmp_buf$ = -340					; size = 320
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_in$ = 12						; size = 4
_level$ = 16						; size = 4
_filter_bank PROC					; COMDAT

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-536]
  00012	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 198  :   Word16 i;
; 199  :   Word16 tmp_buf[FRAME_LEN];
; 200  : 
; 201  :   /* calculate the filter bank */
; 202  : 
; 203  :   first_filter_stage(in, tmp_buf, st->a_data5[0]);

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00033	8d 44 0a 48	 lea	 eax, DWORD PTR [edx+ecx+72]
  00037	50		 push	 eax
  00038	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _in$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 _first_filter_stage
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  :   
; 205  :   for (i = 0; i < FRAME_LEN/4; i++)

  0004b	33 c0		 xor	 eax, eax
  0004d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00051	eb 0c		 jmp	 SHORT $LN9@filter_ban
$LN8@filter_ban:
  00053	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00057	66 83 c0 01	 add	 ax, 1
  0005b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN9@filter_ban:
  0005f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00063	83 f8 28	 cmp	 eax, 40			; 00000028H
  00066	7d 70		 jge	 SHORT $LN7@filter_ban

; 206  :   {
; 207  :      filter5(&tmp_buf[4*i], &tmp_buf[4*i+2], st->a_data5[1]);

  00068	b8 04 00 00 00	 mov	 eax, 4
  0006d	c1 e0 00	 shl	 eax, 0
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00073	8d 54 01 48	 lea	 edx, DWORD PTR [ecx+eax+72]
  00077	52		 push	 edx
  00078	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	8d 8c 45 b0 fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+4]
  00086	51		 push	 ecx
  00087	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  0008b	c1 e2 02	 shl	 edx, 2
  0008e	8d 84 55 ac fe
	ff ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp+edx*2]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _filter5
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  :      filter5(&tmp_buf[4*i+1], &tmp_buf[4*i+3], st->a_data5[2]);

  0009e	b8 04 00 00 00	 mov	 eax, 4
  000a3	d1 e0		 shl	 eax, 1
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a8	8d 54 01 48	 lea	 edx, DWORD PTR [ecx+eax+72]
  000ac	52		 push	 edx
  000ad	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000b1	c1 e0 02	 shl	 eax, 2
  000b4	8d 8c 45 b2 fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+6]
  000bb	51		 push	 ecx
  000bc	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  000c0	c1 e2 02	 shl	 edx, 2
  000c3	8d 84 55 ae fe
	ff ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp+edx*2+2]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _filter5
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :   }

  000d3	e9 7b ff ff ff	 jmp	 $LN8@filter_ban
$LN7@filter_ban:

; 210  :   for (i = 0; i < FRAME_LEN/8; i++)

  000d8	33 c0		 xor	 eax, eax
  000da	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  000de	eb 0c		 jmp	 SHORT $LN6@filter_ban
$LN5@filter_ban:
  000e0	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  000e4	66 83 c0 01	 add	 ax, 1
  000e8	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN6@filter_ban:
  000ec	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000f0	83 f8 14	 cmp	 eax, 20			; 00000014H
  000f3	0f 8d a7 00 00
	00		 jge	 $LN4@filter_ban

; 211  :   {
; 212  :      filter3(&tmp_buf[8*i+0], &tmp_buf[8*i+4], &st->a_data3[0]);

  000f9	b8 02 00 00 00	 mov	 eax, 2
  000fe	6b c8 00	 imul	 ecx, eax, 0
  00101	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00104	8d 44 0a 54	 lea	 eax, DWORD PTR [edx+ecx+84]
  00108	50		 push	 eax
  00109	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0010d	c1 e1 03	 shl	 ecx, 3
  00110	8d 94 4d b4 fe
	ff ff		 lea	 edx, DWORD PTR _tmp_buf$[ebp+ecx*2+8]
  00117	52		 push	 edx
  00118	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0011c	c1 e0 03	 shl	 eax, 3
  0011f	8d 8c 45 ac fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2]
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 _filter3
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  :      filter3(&tmp_buf[8*i+2], &tmp_buf[8*i+6], &st->a_data3[1]);

  0012f	b8 02 00 00 00	 mov	 eax, 2
  00134	c1 e0 00	 shl	 eax, 0
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0013a	8d 54 01 54	 lea	 edx, DWORD PTR [ecx+eax+84]
  0013e	52		 push	 edx
  0013f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00143	c1 e0 03	 shl	 eax, 3
  00146	8d 8c 45 b8 fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+12]
  0014d	51		 push	 ecx
  0014e	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00152	c1 e2 03	 shl	 edx, 3
  00155	8d 84 55 b0 fe
	ff ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp+edx*2+4]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _filter3
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  :      filter3(&tmp_buf[8*i+3], &tmp_buf[8*i+7], &st->a_data3[4]);

  00165	b8 02 00 00 00	 mov	 eax, 2
  0016a	c1 e0 02	 shl	 eax, 2
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00170	8d 54 01 54	 lea	 edx, DWORD PTR [ecx+eax+84]
  00174	52		 push	 edx
  00175	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00179	c1 e0 03	 shl	 eax, 3
  0017c	8d 8c 45 ba fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+14]
  00183	51		 push	 ecx
  00184	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00188	c1 e2 03	 shl	 edx, 3
  0018b	8d 84 55 b2 fe
	ff ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp+edx*2+6]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 _filter3
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH

; 215  :   }

  0019b	e9 40 ff ff ff	 jmp	 $LN5@filter_ban
$LN4@filter_ban:

; 216  :   
; 217  :   for (i = 0; i < FRAME_LEN/16; i++)

  001a0	33 c0		 xor	 eax, eax
  001a2	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  001a6	eb 0c		 jmp	 SHORT $LN3@filter_ban
$LN2@filter_ban:
  001a8	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  001ac	66 83 c0 01	 add	 ax, 1
  001b0	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@filter_ban:
  001b4	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001b8	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001bb	7d 70		 jge	 SHORT $LN1@filter_ban

; 218  :   {
; 219  :      filter3(&tmp_buf[16*i+0], &tmp_buf[16*i+8], &st->a_data3[2]);

  001bd	b8 02 00 00 00	 mov	 eax, 2
  001c2	d1 e0		 shl	 eax, 1
  001c4	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001c7	8d 54 01 54	 lea	 edx, DWORD PTR [ecx+eax+84]
  001cb	52		 push	 edx
  001cc	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001d0	c1 e0 04	 shl	 eax, 4
  001d3	8d 8c 45 bc fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+16]
  001da	51		 push	 ecx
  001db	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  001df	c1 e2 04	 shl	 edx, 4
  001e2	8d 84 55 ac fe
	ff ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp+edx*2]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _filter3
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  :      filter3(&tmp_buf[16*i+4], &tmp_buf[16*i+12], &st->a_data3[3]);

  001f2	b8 02 00 00 00	 mov	 eax, 2
  001f7	6b c8 03	 imul	 ecx, eax, 3
  001fa	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001fd	8d 44 0a 54	 lea	 eax, DWORD PTR [edx+ecx+84]
  00201	50		 push	 eax
  00202	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00206	c1 e1 04	 shl	 ecx, 4
  00209	8d 94 4d c4 fe
	ff ff		 lea	 edx, DWORD PTR _tmp_buf$[ebp+ecx*2+24]
  00210	52		 push	 edx
  00211	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00215	c1 e0 04	 shl	 eax, 4
  00218	8d 8c 45 b4 fe
	ff ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp+eax*2+8]
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 _filter3
  00225	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  :   }

  00228	e9 7b ff ff ff	 jmp	 $LN2@filter_ban
$LN1@filter_ban:

; 222  :   
; 223  :   /* calculate levels in each frequency band */
; 224  :   
; 225  :   /* 3000 - 4000 Hz*/
; 226  :   level[8] = level_calculation(tmp_buf, &st->sub_level[8], FRAME_LEN/4-8,
; 227  :                                FRAME_LEN/4, 4, 1, 15);

  0022d	6a 0f		 push	 15			; 0000000fH
  0022f	6a 01		 push	 1
  00231	6a 04		 push	 4
  00233	6a 28		 push	 40			; 00000028H
  00235	6a 20		 push	 32			; 00000020H
  00237	b8 02 00 00 00	 mov	 eax, 2
  0023c	c1 e0 03	 shl	 eax, 3
  0023f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00242	8d 54 01 36	 lea	 edx, DWORD PTR [ecx+eax+54]
  00246	52		 push	 edx
  00247	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _level_calculation
  00253	83 c4 1c	 add	 esp, 28			; 0000001cH
  00256	b9 02 00 00 00	 mov	 ecx, 2
  0025b	c1 e1 03	 shl	 ecx, 3
  0025e	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00261	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 228  :   move16 ();

  00265	e8 00 00 00 00	 call	 _move16

; 229  :   /* 2500 - 3000 Hz*/  
; 230  :   level[7] = level_calculation(tmp_buf, &st->sub_level[7], FRAME_LEN/8-4,
; 231  :                                FRAME_LEN/8, 8, 7, 16);

  0026a	6a 10		 push	 16			; 00000010H
  0026c	6a 07		 push	 7
  0026e	6a 08		 push	 8
  00270	6a 14		 push	 20			; 00000014H
  00272	6a 10		 push	 16			; 00000010H
  00274	b8 02 00 00 00	 mov	 eax, 2
  00279	6b c8 07	 imul	 ecx, eax, 7
  0027c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0027f	8d 44 0a 36	 lea	 eax, DWORD PTR [edx+ecx+54]
  00283	50		 push	 eax
  00284	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  0028a	51		 push	 ecx
  0028b	e8 00 00 00 00	 call	 _level_calculation
  00290	83 c4 1c	 add	 esp, 28			; 0000001cH
  00293	ba 02 00 00 00	 mov	 edx, 2
  00298	6b ca 07	 imul	 ecx, edx, 7
  0029b	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  0029e	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 232  :   move16 ();

  002a2	e8 00 00 00 00	 call	 _move16

; 233  :   /* 2000 - 2500 Hz*/
; 234  :   level[6] = level_calculation(tmp_buf, &st->sub_level[6], FRAME_LEN/8-4,
; 235  :                                FRAME_LEN/8, 8, 3, 16);

  002a7	6a 10		 push	 16			; 00000010H
  002a9	6a 03		 push	 3
  002ab	6a 08		 push	 8
  002ad	6a 14		 push	 20			; 00000014H
  002af	6a 10		 push	 16			; 00000010H
  002b1	b8 02 00 00 00	 mov	 eax, 2
  002b6	6b c8 06	 imul	 ecx, eax, 6
  002b9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  002bc	8d 44 0a 36	 lea	 eax, DWORD PTR [edx+ecx+54]
  002c0	50		 push	 eax
  002c1	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  002c7	51		 push	 ecx
  002c8	e8 00 00 00 00	 call	 _level_calculation
  002cd	83 c4 1c	 add	 esp, 28			; 0000001cH
  002d0	ba 02 00 00 00	 mov	 edx, 2
  002d5	6b ca 06	 imul	 ecx, edx, 6
  002d8	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  002db	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 236  :   move16 ();

  002df	e8 00 00 00 00	 call	 _move16

; 237  :   /* 1500 - 2000 Hz*/
; 238  :   level[5] = level_calculation(tmp_buf, &st->sub_level[5], FRAME_LEN/8-4,
; 239  :                                FRAME_LEN/8, 8, 2, 16);

  002e4	6a 10		 push	 16			; 00000010H
  002e6	6a 02		 push	 2
  002e8	6a 08		 push	 8
  002ea	6a 14		 push	 20			; 00000014H
  002ec	6a 10		 push	 16			; 00000010H
  002ee	b8 02 00 00 00	 mov	 eax, 2
  002f3	6b c8 05	 imul	 ecx, eax, 5
  002f6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  002f9	8d 44 0a 36	 lea	 eax, DWORD PTR [edx+ecx+54]
  002fd	50		 push	 eax
  002fe	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 _level_calculation
  0030a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0030d	ba 02 00 00 00	 mov	 edx, 2
  00312	6b ca 05	 imul	 ecx, edx, 5
  00315	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00318	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 240  :   move16 ();

  0031c	e8 00 00 00 00	 call	 _move16

; 241  :   /* 1000 - 1500 Hz*/
; 242  :   level[4] = level_calculation(tmp_buf, &st->sub_level[4], FRAME_LEN/8-4,
; 243  :                                FRAME_LEN/8, 8, 6, 16);

  00321	6a 10		 push	 16			; 00000010H
  00323	6a 06		 push	 6
  00325	6a 08		 push	 8
  00327	6a 14		 push	 20			; 00000014H
  00329	6a 10		 push	 16			; 00000010H
  0032b	b8 02 00 00 00	 mov	 eax, 2
  00330	c1 e0 02	 shl	 eax, 2
  00333	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00336	8d 54 01 36	 lea	 edx, DWORD PTR [ecx+eax+54]
  0033a	52		 push	 edx
  0033b	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _level_calculation
  00347	83 c4 1c	 add	 esp, 28			; 0000001cH
  0034a	b9 02 00 00 00	 mov	 ecx, 2
  0034f	c1 e1 02	 shl	 ecx, 2
  00352	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00355	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 244  :   move16 ();

  00359	e8 00 00 00 00	 call	 _move16

; 245  :   /* 750 - 1000 Hz*/
; 246  :   level[3] = level_calculation(tmp_buf, &st->sub_level[3], FRAME_LEN/16-2,
; 247  :                                FRAME_LEN/16, 16, 4, 16);

  0035e	6a 10		 push	 16			; 00000010H
  00360	6a 04		 push	 4
  00362	6a 10		 push	 16			; 00000010H
  00364	6a 0a		 push	 10			; 0000000aH
  00366	6a 08		 push	 8
  00368	b8 02 00 00 00	 mov	 eax, 2
  0036d	6b c8 03	 imul	 ecx, eax, 3
  00370	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00373	8d 44 0a 36	 lea	 eax, DWORD PTR [edx+ecx+54]
  00377	50		 push	 eax
  00378	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  0037e	51		 push	 ecx
  0037f	e8 00 00 00 00	 call	 _level_calculation
  00384	83 c4 1c	 add	 esp, 28			; 0000001cH
  00387	ba 02 00 00 00	 mov	 edx, 2
  0038c	6b ca 03	 imul	 ecx, edx, 3
  0038f	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00392	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 248  :   move16 ();

  00396	e8 00 00 00 00	 call	 _move16

; 249  :   /* 500 - 750 Hz*/
; 250  :   level[2] = level_calculation(tmp_buf, &st->sub_level[2], FRAME_LEN/16-2,
; 251  :                                FRAME_LEN/16, 16, 12, 16);

  0039b	6a 10		 push	 16			; 00000010H
  0039d	6a 0c		 push	 12			; 0000000cH
  0039f	6a 10		 push	 16			; 00000010H
  003a1	6a 0a		 push	 10			; 0000000aH
  003a3	6a 08		 push	 8
  003a5	b8 02 00 00 00	 mov	 eax, 2
  003aa	d1 e0		 shl	 eax, 1
  003ac	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  003af	8d 54 01 36	 lea	 edx, DWORD PTR [ecx+eax+54]
  003b3	52		 push	 edx
  003b4	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp]
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 _level_calculation
  003c0	83 c4 1c	 add	 esp, 28			; 0000001cH
  003c3	b9 02 00 00 00	 mov	 ecx, 2
  003c8	d1 e1		 shl	 ecx, 1
  003ca	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  003cd	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 252  :   move16 ();

  003d1	e8 00 00 00 00	 call	 _move16

; 253  :   /* 250 - 500 Hz*/
; 254  :   level[1] = level_calculation(tmp_buf, &st->sub_level[1], FRAME_LEN/16-2,
; 255  :                                FRAME_LEN/16, 16, 8, 16);

  003d6	6a 10		 push	 16			; 00000010H
  003d8	6a 08		 push	 8
  003da	6a 10		 push	 16			; 00000010H
  003dc	6a 0a		 push	 10			; 0000000aH
  003de	6a 08		 push	 8
  003e0	b8 02 00 00 00	 mov	 eax, 2
  003e5	c1 e0 00	 shl	 eax, 0
  003e8	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  003eb	8d 54 01 36	 lea	 edx, DWORD PTR [ecx+eax+54]
  003ef	52		 push	 edx
  003f0	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _tmp_buf$[ebp]
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 _level_calculation
  003fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  003ff	b9 02 00 00 00	 mov	 ecx, 2
  00404	c1 e1 00	 shl	 ecx, 0
  00407	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  0040a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 256  :   move16 ();

  0040e	e8 00 00 00 00	 call	 _move16

; 257  :   /* 0 - 250 Hz*/
; 258  :   level[0] = level_calculation(tmp_buf, &st->sub_level[0], FRAME_LEN/16-2,
; 259  :                                FRAME_LEN/16, 16, 0, 16);

  00413	6a 10		 push	 16			; 00000010H
  00415	6a 00		 push	 0
  00417	6a 10		 push	 16			; 00000010H
  00419	6a 0a		 push	 10			; 0000000aH
  0041b	6a 08		 push	 8
  0041d	b8 02 00 00 00	 mov	 eax, 2
  00422	6b c8 00	 imul	 ecx, eax, 0
  00425	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00428	8d 44 0a 36	 lea	 eax, DWORD PTR [edx+ecx+54]
  0042c	50		 push	 eax
  0042d	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _tmp_buf$[ebp]
  00433	51		 push	 ecx
  00434	e8 00 00 00 00	 call	 _level_calculation
  00439	83 c4 1c	 add	 esp, 28			; 0000001cH
  0043c	ba 02 00 00 00	 mov	 edx, 2
  00441	6b ca 00	 imul	 ecx, edx, 0
  00444	8b 55 10	 mov	 edx, DWORD PTR _level$[ebp]
  00447	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 260  :   move16 ();

  0044b	e8 00 00 00 00	 call	 _move16

; 261  : }

  00450	52		 push	 edx
  00451	8b cd		 mov	 ecx, ebp
  00453	50		 push	 eax
  00454	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@filter_ban
  0045a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0045f	58		 pop	 eax
  00460	5a		 pop	 edx
  00461	5f		 pop	 edi
  00462	5e		 pop	 esi
  00463	5b		 pop	 ebx
  00464	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00467	33 cd		 xor	 ecx, ebp
  00469	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046e	81 c4 18 02 00
	00		 add	 esp, 536		; 00000218H
  00474	3b ec		 cmp	 ebp, esp
  00476	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0047b	8b e5		 mov	 esp, ebp
  0047d	5d		 pop	 ebp
  0047e	c3		 ret	 0
  0047f	90		 npad	 1
$LN14@filter_ban:
  00480	01 00 00 00	 DD	 1
  00484	00 00 00 00	 DD	 $LN13@filter_ban
$LN13@filter_ban:
  00488	ac fe ff ff	 DD	 -340			; fffffeacH
  0048c	40 01 00 00	 DD	 320			; 00000140H
  00490	00 00 00 00	 DD	 $LN12@filter_ban
$LN12@filter_ban:
  00494	74		 DB	 116			; 00000074H
  00495	6d		 DB	 109			; 0000006dH
  00496	70		 DB	 112			; 00000070H
  00497	5f		 DB	 95			; 0000005fH
  00498	62		 DB	 98			; 00000062H
  00499	75		 DB	 117			; 00000075H
  0049a	66		 DB	 102			; 00000066H
  0049b	00		 DB	 0
_filter_bank ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _level_calculation
_TEXT	SEGMENT
_i$ = -44						; size = 2
_level$ = -32						; size = 2
_l_temp2$ = -20						; size = 4
_l_temp1$ = -8						; size = 4
_data$ = 8						; size = 4
_sub_level$ = 12					; size = 4
_count1$ = 16						; size = 2
_count2$ = 20						; size = 2
_ind_m$ = 24						; size = 2
_ind_a$ = 28						; size = 2
_scale$ = 32						; size = 2
_level_calculation PROC					; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 165  :   Word32 l_temp1, l_temp2;
; 166  :   Word16 level, i;
; 167  : 
; 168  :   l_temp1 = 0L;                                           move32 ();

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _l_temp1$[ebp], 0
  00025	e8 00 00 00 00	 call	 _move32

; 169  :   for (i = count1; i < count2; i++)

  0002a	66 8b 45 10	 mov	 ax, WORD PTR _count1$[ebp]
  0002e	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
  00032	eb 0c		 jmp	 SHORT $LN6@level_calc
$LN5@level_calc:
  00034	66 8b 45 d4	 mov	 ax, WORD PTR _i$[ebp]
  00038	66 83 c0 01	 add	 ax, 1
  0003c	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
$LN6@level_calc:
  00040	0f bf 45 d4	 movsx	 eax, WORD PTR _i$[ebp]
  00044	0f bf 4d 14	 movsx	 ecx, WORD PTR _count2$[ebp]
  00048	3b c1		 cmp	 eax, ecx
  0004a	7d 38		 jge	 SHORT $LN4@level_calc

; 170  :   {
; 171  :      l_temp1 = L_mac(l_temp1, 1, abs_s(data[ind_m*i+ind_a]));

  0004c	0f bf 45 18	 movsx	 eax, WORD PTR _ind_m$[ebp]
  00050	0f bf 4d d4	 movsx	 ecx, WORD PTR _i$[ebp]
  00054	0f af c1	 imul	 eax, ecx
  00057	0f bf 55 1c	 movsx	 edx, WORD PTR _ind_a$[ebp]
  0005b	03 c2		 add	 eax, edx
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00060	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _abs_s
  0006a	83 c4 04	 add	 esp, 4
  0006d	0f b7 c0	 movzx	 eax, ax
  00070	50		 push	 eax
  00071	6a 01		 push	 1
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _l_temp1$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _L_mac
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	89 45 f8	 mov	 DWORD PTR _l_temp1$[ebp], eax

; 172  :   }

  00082	eb b0		 jmp	 SHORT $LN5@level_calc
$LN4@level_calc:

; 173  :   
; 174  :   l_temp2 = L_add(l_temp1, L_shl(*sub_level, sub(16, scale)));

  00084	0f b7 45 20	 movzx	 eax, WORD PTR _scale$[ebp]
  00088	50		 push	 eax
  00089	6a 10		 push	 16			; 00000010H
  0008b	e8 00 00 00 00	 call	 _sub
  00090	83 c4 08	 add	 esp, 8
  00093	0f b7 c8	 movzx	 ecx, ax
  00096	51		 push	 ecx
  00097	8b 55 0c	 mov	 edx, DWORD PTR _sub_level$[ebp]
  0009a	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _L_shl
  000a3	83 c4 08	 add	 esp, 8
  000a6	50		 push	 eax
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _l_temp1$[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 _L_add
  000b0	83 c4 08	 add	 esp, 8
  000b3	89 45 ec	 mov	 DWORD PTR _l_temp2$[ebp], eax

; 175  :   *sub_level = extract_h(L_shl(l_temp1, scale));

  000b6	0f b7 45 20	 movzx	 eax, WORD PTR _scale$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _l_temp1$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 _L_shl
  000c4	83 c4 08	 add	 esp, 8
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _extract_h
  000cd	83 c4 04	 add	 esp, 4
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _sub_level$[ebp]
  000d3	66 89 02	 mov	 WORD PTR [edx], ax

; 176  :   
; 177  :   for (i = 0; i < count1; i++)

  000d6	33 c0		 xor	 eax, eax
  000d8	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
  000dc	eb 0c		 jmp	 SHORT $LN3@level_calc
$LN2@level_calc:
  000de	66 8b 45 d4	 mov	 ax, WORD PTR _i$[ebp]
  000e2	66 83 c0 01	 add	 ax, 1
  000e6	66 89 45 d4	 mov	 WORD PTR _i$[ebp], ax
$LN3@level_calc:
  000ea	0f bf 45 d4	 movsx	 eax, WORD PTR _i$[ebp]
  000ee	0f bf 4d 10	 movsx	 ecx, WORD PTR _count1$[ebp]
  000f2	3b c1		 cmp	 eax, ecx
  000f4	7d 38		 jge	 SHORT $LN1@level_calc

; 178  :   {
; 179  :      l_temp2 = L_mac(l_temp2, 1, abs_s(data[ind_m*i+ind_a]));

  000f6	0f bf 45 18	 movsx	 eax, WORD PTR _ind_m$[ebp]
  000fa	0f bf 4d d4	 movsx	 ecx, WORD PTR _i$[ebp]
  000fe	0f af c1	 imul	 eax, ecx
  00101	0f bf 55 1c	 movsx	 edx, WORD PTR _ind_a$[ebp]
  00105	03 c2		 add	 eax, edx
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0010a	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _abs_s
  00114	83 c4 04	 add	 esp, 4
  00117	0f b7 c0	 movzx	 eax, ax
  0011a	50		 push	 eax
  0011b	6a 01		 push	 1
  0011d	8b 4d ec	 mov	 ecx, DWORD PTR _l_temp2$[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 _L_mac
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	89 45 ec	 mov	 DWORD PTR _l_temp2$[ebp], eax

; 180  :   }

  0012c	eb b0		 jmp	 SHORT $LN2@level_calc
$LN1@level_calc:

; 181  :   level = extract_h(L_shl(l_temp2, scale));

  0012e	0f b7 45 20	 movzx	 eax, WORD PTR _scale$[ebp]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _l_temp2$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 _L_shl
  0013c	83 c4 08	 add	 esp, 8
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _extract_h
  00145	83 c4 04	 add	 esp, 4
  00148	66 89 45 e0	 mov	 WORD PTR _level$[ebp], ax

; 182  :   
; 183  :   return level;

  0014c	66 8b 45 e0	 mov	 ax, WORD PTR _level$[ebp]

; 184  : }

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00159	3b ec		 cmp	 ebp, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_level_calculation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _filter3
_TEXT	SEGMENT
_temp2$ = -20						; size = 2
_temp1$ = -8						; size = 2
_in0$ = 8						; size = 4
_in1$ = 12						; size = 4
_data$ = 16						; size = 4
_filter3 PROC						; COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 135  :   Word16 temp1, temp2;
; 136  : 
; 137  :   temp1 = sub(*in1, mult(COEFF3, *data));

  0001e	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00021	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00024	51		 push	 ecx
  00025	68 33 34 00 00	 push	 13363			; 00003433H
  0002a	e8 00 00 00 00	 call	 _mult
  0002f	83 c4 08	 add	 esp, 8
  00032	0f b7 d0	 movzx	 edx, ax
  00035	52		 push	 edx
  00036	8b 45 0c	 mov	 eax, DWORD PTR _in1$[ebp]
  00039	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _sub
  00042	83 c4 08	 add	 esp, 8
  00045	66 89 45 f8	 mov	 WORD PTR _temp1$[ebp], ax

; 138  :   temp2 = add(*data, mult(COEFF3, temp1));

  00049	0f b7 45 f8	 movzx	 eax, WORD PTR _temp1$[ebp]
  0004d	50		 push	 eax
  0004e	68 33 34 00 00	 push	 13363			; 00003433H
  00053	e8 00 00 00 00	 call	 _mult
  00058	83 c4 08	 add	 esp, 8
  0005b	0f b7 c8	 movzx	 ecx, ax
  0005e	51		 push	 ecx
  0005f	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00062	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _add
  0006b	83 c4 08	 add	 esp, 8
  0006e	66 89 45 ec	 mov	 WORD PTR _temp2$[ebp], ax

; 139  :   *data = temp1;                              move16 ();

  00072	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  00075	66 8b 4d f8	 mov	 cx, WORD PTR _temp1$[ebp]
  00079	66 89 08	 mov	 WORD PTR [eax], cx
  0007c	e8 00 00 00 00	 call	 _move16

; 140  : 
; 141  :   *in1 = shr(sub(*in0, temp2), 1);            move16 ();

  00081	6a 01		 push	 1
  00083	0f b7 45 ec	 movzx	 eax, WORD PTR _temp2$[ebp]
  00087	50		 push	 eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _in0$[ebp]
  0008b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 _sub
  00094	83 c4 08	 add	 esp, 8
  00097	0f b7 c0	 movzx	 eax, ax
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _shr
  000a0	83 c4 08	 add	 esp, 8
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _in1$[ebp]
  000a6	66 89 01	 mov	 WORD PTR [ecx], ax
  000a9	e8 00 00 00 00	 call	 _move16

; 142  :   *in0 = shr(add(*in0, temp2), 1);            move16 ();

  000ae	6a 01		 push	 1
  000b0	0f b7 45 ec	 movzx	 eax, WORD PTR _temp2$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _in0$[ebp]
  000b8	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 _add
  000c1	83 c4 08	 add	 esp, 8
  000c4	0f b7 c0	 movzx	 eax, ax
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _shr
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _in0$[ebp]
  000d3	66 89 01	 mov	 WORD PTR [ecx], ax
  000d6	e8 00 00 00 00	 call	 _move16

; 143  : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
_filter3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _filter5
_TEXT	SEGMENT
_temp2$ = -32						; size = 2
_temp1$ = -20						; size = 2
_temp0$ = -8						; size = 2
_in0$ = 8						; size = 4
_in1$ = 12						; size = 4
_data$ = 16						; size = 4
_filter5 PROC						; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 108  :   Word16 temp0, temp1, temp2;
; 109  : 
; 110  :   temp0 = sub(*in0, mult(COEFF5_1, data[0]));

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00029	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0002d	50		 push	 eax
  0002e	68 c3 55 00 00	 push	 21955			; 000055c3H
  00033	e8 00 00 00 00	 call	 _mult
  00038	83 c4 08	 add	 esp, 8
  0003b	0f b7 c8	 movzx	 ecx, ax
  0003e	51		 push	 ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _in0$[ebp]
  00042	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _sub
  0004b	83 c4 08	 add	 esp, 8
  0004e	66 89 45 f8	 mov	 WORD PTR _temp0$[ebp], ax

; 111  :   temp1 = add(data[0], mult(COEFF5_1, temp0));

  00052	0f b7 45 f8	 movzx	 eax, WORD PTR _temp0$[ebp]
  00056	50		 push	 eax
  00057	68 c3 55 00 00	 push	 21955			; 000055c3H
  0005c	e8 00 00 00 00	 call	 _mult
  00061	83 c4 08	 add	 esp, 8
  00064	0f b7 c8	 movzx	 ecx, ax
  00067	51		 push	 ecx
  00068	ba 02 00 00 00	 mov	 edx, 2
  0006d	6b c2 00	 imul	 eax, edx, 0
  00070	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  00073	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _add
  0007d	83 c4 08	 add	 esp, 8
  00080	66 89 45 ec	 mov	 WORD PTR _temp1$[ebp], ax

; 112  :   data[0] = temp0;                                move16 ();

  00084	b8 02 00 00 00	 mov	 eax, 2
  00089	6b c8 00	 imul	 ecx, eax, 0
  0008c	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  0008f	66 8b 45 f8	 mov	 ax, WORD PTR _temp0$[ebp]
  00093	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00097	e8 00 00 00 00	 call	 _move16

; 113  : 
; 114  :   temp0 = sub(*in1, mult(COEFF5_2, data[1]));

  0009c	b8 02 00 00 00	 mov	 eax, 2
  000a1	c1 e0 00	 shl	 eax, 0
  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  000a7	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  000ab	52		 push	 edx
  000ac	68 f6 18 00 00	 push	 6390			; 000018f6H
  000b1	e8 00 00 00 00	 call	 _mult
  000b6	83 c4 08	 add	 esp, 8
  000b9	0f b7 c0	 movzx	 eax, ax
  000bc	50		 push	 eax
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _in1$[ebp]
  000c0	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _sub
  000c9	83 c4 08	 add	 esp, 8
  000cc	66 89 45 f8	 mov	 WORD PTR _temp0$[ebp], ax

; 115  :   temp2 = add(data[1], mult(COEFF5_2, temp0));

  000d0	0f b7 45 f8	 movzx	 eax, WORD PTR _temp0$[ebp]
  000d4	50		 push	 eax
  000d5	68 f6 18 00 00	 push	 6390			; 000018f6H
  000da	e8 00 00 00 00	 call	 _mult
  000df	83 c4 08	 add	 esp, 8
  000e2	0f b7 c8	 movzx	 ecx, ax
  000e5	51		 push	 ecx
  000e6	ba 02 00 00 00	 mov	 edx, 2
  000eb	c1 e2 00	 shl	 edx, 0
  000ee	8b 45 10	 mov	 eax, DWORD PTR _data$[ebp]
  000f1	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  000f5	51		 push	 ecx
  000f6	e8 00 00 00 00	 call	 _add
  000fb	83 c4 08	 add	 esp, 8
  000fe	66 89 45 e0	 mov	 WORD PTR _temp2$[ebp], ax

; 116  :   data[1] = temp0;                                move16 ();

  00102	b8 02 00 00 00	 mov	 eax, 2
  00107	c1 e0 00	 shl	 eax, 0
  0010a	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  0010d	66 8b 55 f8	 mov	 dx, WORD PTR _temp0$[ebp]
  00111	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00115	e8 00 00 00 00	 call	 _move16

; 117  : 
; 118  :   *in0 = shr(add(temp1, temp2), 1);               move16 ();

  0011a	6a 01		 push	 1
  0011c	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  00120	50		 push	 eax
  00121	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 _add
  0012b	83 c4 08	 add	 esp, 8
  0012e	0f b7 d0	 movzx	 edx, ax
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _shr
  00137	83 c4 08	 add	 esp, 8
  0013a	8b 4d 08	 mov	 ecx, DWORD PTR _in0$[ebp]
  0013d	66 89 01	 mov	 WORD PTR [ecx], ax
  00140	e8 00 00 00 00	 call	 _move16

; 119  :   *in1 = shr(sub(temp1, temp2), 1);               move16 ();

  00145	6a 01		 push	 1
  00147	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  0014b	50		 push	 eax
  0014c	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 _sub
  00156	83 c4 08	 add	 esp, 8
  00159	0f b7 d0	 movzx	 edx, ax
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 _shr
  00162	83 c4 08	 add	 esp, 8
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR _in1$[ebp]
  00168	66 89 01	 mov	 WORD PTR [ecx], ax
  0016b	e8 00 00 00 00	 call	 _move16

; 120  : }

  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00179	3b ec		 cmp	 ebp, esp
  0017b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_filter5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _first_filter_stage
_TEXT	SEGMENT
_data1$ = -80						; size = 2
_data0$ = -68						; size = 2
_i$ = -56						; size = 2
_temp3$ = -44						; size = 2
_temp2$ = -32						; size = 2
_temp1$ = -20						; size = 2
_temp0$ = -8						; size = 2
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_data$ = 16						; size = 4
_first_filter_stage PROC				; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 65   :   Word16 temp0, temp1, temp2, temp3, i;
; 66   :   Word16 data0, data1;
; 67   : 
; 68   :   data0 = data[0];                                          move16 ();

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00029	66 8b 04 0a	 mov	 ax, WORD PTR [edx+ecx]
  0002d	66 89 45 bc	 mov	 WORD PTR _data0$[ebp], ax
  00031	e8 00 00 00 00	 call	 _move16

; 69   :   data1 = data[1];                                          move16 ();

  00036	b8 02 00 00 00	 mov	 eax, 2
  0003b	c1 e0 00	 shl	 eax, 0
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  00041	66 8b 14 01	 mov	 dx, WORD PTR [ecx+eax]
  00045	66 89 55 b0	 mov	 WORD PTR _data1$[ebp], dx
  00049	e8 00 00 00 00	 call	 _move16

; 70   :  
; 71   :   for (i = 0; i < FRAME_LEN/4; i++)

  0004e	33 c0		 xor	 eax, eax
  00050	66 89 45 c8	 mov	 WORD PTR _i$[ebp], ax
  00054	eb 0c		 jmp	 SHORT $LN3@first_filt
$LN2@first_filt:
  00056	66 8b 45 c8	 mov	 ax, WORD PTR _i$[ebp]
  0005a	66 83 c0 01	 add	 ax, 1
  0005e	66 89 45 c8	 mov	 WORD PTR _i$[ebp], ax
$LN3@first_filt:
  00062	0f bf 45 c8	 movsx	 eax, WORD PTR _i$[ebp]
  00066	83 f8 28	 cmp	 eax, 40			; 00000028H
  00069	0f 8d 37 02 00
	00		 jge	 $LN1@first_filt

; 72   :   {
; 73   :      temp0 = sub(shr(in[4*i+0], 2), mult(COEFF5_1, data0));

  0006f	0f b7 45 bc	 movzx	 eax, WORD PTR _data0$[ebp]
  00073	50		 push	 eax
  00074	68 c3 55 00 00	 push	 21955			; 000055c3H
  00079	e8 00 00 00 00	 call	 _mult
  0007e	83 c4 08	 add	 esp, 8
  00081	0f b7 c8	 movzx	 ecx, ax
  00084	51		 push	 ecx
  00085	6a 02		 push	 2
  00087	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  0008b	c1 e2 02	 shl	 edx, 2
  0008e	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00091	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _shr
  0009b	83 c4 08	 add	 esp, 8
  0009e	0f b7 d0	 movzx	 edx, ax
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 _sub
  000a7	83 c4 08	 add	 esp, 8
  000aa	66 89 45 f8	 mov	 WORD PTR _temp0$[ebp], ax

; 74   :      temp1 = add(data0, mult(COEFF5_1, temp0));

  000ae	0f b7 45 f8	 movzx	 eax, WORD PTR _temp0$[ebp]
  000b2	50		 push	 eax
  000b3	68 c3 55 00 00	 push	 21955			; 000055c3H
  000b8	e8 00 00 00 00	 call	 _mult
  000bd	83 c4 08	 add	 esp, 8
  000c0	0f b7 c8	 movzx	 ecx, ax
  000c3	51		 push	 ecx
  000c4	0f b7 55 bc	 movzx	 edx, WORD PTR _data0$[ebp]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _add
  000ce	83 c4 08	 add	 esp, 8
  000d1	66 89 45 ec	 mov	 WORD PTR _temp1$[ebp], ax

; 75   :      
; 76   :      temp3 = sub(shr(in[4*i+1], 2), mult(COEFF5_2, data1));

  000d5	0f b7 45 b0	 movzx	 eax, WORD PTR _data1$[ebp]
  000d9	50		 push	 eax
  000da	68 f6 18 00 00	 push	 6390			; 000018f6H
  000df	e8 00 00 00 00	 call	 _mult
  000e4	83 c4 08	 add	 esp, 8
  000e7	0f b7 c8	 movzx	 ecx, ax
  000ea	51		 push	 ecx
  000eb	6a 02		 push	 2
  000ed	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  000f1	c1 e2 02	 shl	 edx, 2
  000f4	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  000f7	0f b7 4c 50 02	 movzx	 ecx, WORD PTR [eax+edx*2+2]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 _shr
  00102	83 c4 08	 add	 esp, 8
  00105	0f b7 d0	 movzx	 edx, ax
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 _sub
  0010e	83 c4 08	 add	 esp, 8
  00111	66 89 45 d4	 mov	 WORD PTR _temp3$[ebp], ax

; 77   :      temp2 = add(data1, mult(COEFF5_2, temp3));

  00115	0f b7 45 d4	 movzx	 eax, WORD PTR _temp3$[ebp]
  00119	50		 push	 eax
  0011a	68 f6 18 00 00	 push	 6390			; 000018f6H
  0011f	e8 00 00 00 00	 call	 _mult
  00124	83 c4 08	 add	 esp, 8
  00127	0f b7 c8	 movzx	 ecx, ax
  0012a	51		 push	 ecx
  0012b	0f b7 55 b0	 movzx	 edx, WORD PTR _data1$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 _add
  00135	83 c4 08	 add	 esp, 8
  00138	66 89 45 e0	 mov	 WORD PTR _temp2$[ebp], ax

; 78   :      
; 79   :      out[4*i+0] = add(temp1, temp2);                        move16 ();

  0013c	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  00140	50		 push	 eax
  00141	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _add
  0014b	83 c4 08	 add	 esp, 8
  0014e	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  00152	c1 e2 02	 shl	 edx, 2
  00155	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00158	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  0015c	e8 00 00 00 00	 call	 _move16

; 80   :      out[4*i+1] = sub(temp1, temp2);                        move16 ();

  00161	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  00165	50		 push	 eax
  00166	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _sub
  00170	83 c4 08	 add	 esp, 8
  00173	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  00177	c1 e2 02	 shl	 edx, 2
  0017a	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0017d	66 89 44 51 02	 mov	 WORD PTR [ecx+edx*2+2], ax
  00182	e8 00 00 00 00	 call	 _move16

; 81   :      
; 82   :      data0 = sub(shr(in[4*i+2], 2), mult(COEFF5_1, temp0));

  00187	0f b7 45 f8	 movzx	 eax, WORD PTR _temp0$[ebp]
  0018b	50		 push	 eax
  0018c	68 c3 55 00 00	 push	 21955			; 000055c3H
  00191	e8 00 00 00 00	 call	 _mult
  00196	83 c4 08	 add	 esp, 8
  00199	0f b7 c8	 movzx	 ecx, ax
  0019c	51		 push	 ecx
  0019d	6a 02		 push	 2
  0019f	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  001a3	c1 e2 02	 shl	 edx, 2
  001a6	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  001a9	0f b7 4c 50 04	 movzx	 ecx, WORD PTR [eax+edx*2+4]
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _shr
  001b4	83 c4 08	 add	 esp, 8
  001b7	0f b7 d0	 movzx	 edx, ax
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 _sub
  001c0	83 c4 08	 add	 esp, 8
  001c3	66 89 45 bc	 mov	 WORD PTR _data0$[ebp], ax

; 83   :      temp1 = add(temp0, mult(COEFF5_1, data0));

  001c7	0f b7 45 bc	 movzx	 eax, WORD PTR _data0$[ebp]
  001cb	50		 push	 eax
  001cc	68 c3 55 00 00	 push	 21955			; 000055c3H
  001d1	e8 00 00 00 00	 call	 _mult
  001d6	83 c4 08	 add	 esp, 8
  001d9	0f b7 c8	 movzx	 ecx, ax
  001dc	51		 push	 ecx
  001dd	0f b7 55 f8	 movzx	 edx, WORD PTR _temp0$[ebp]
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 _add
  001e7	83 c4 08	 add	 esp, 8
  001ea	66 89 45 ec	 mov	 WORD PTR _temp1$[ebp], ax

; 84   :      
; 85   :      data1 = sub(shr(in[4*i+3], 2), mult(COEFF5_2, temp3));

  001ee	0f b7 45 d4	 movzx	 eax, WORD PTR _temp3$[ebp]
  001f2	50		 push	 eax
  001f3	68 f6 18 00 00	 push	 6390			; 000018f6H
  001f8	e8 00 00 00 00	 call	 _mult
  001fd	83 c4 08	 add	 esp, 8
  00200	0f b7 c8	 movzx	 ecx, ax
  00203	51		 push	 ecx
  00204	6a 02		 push	 2
  00206	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  0020a	c1 e2 02	 shl	 edx, 2
  0020d	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00210	0f b7 4c 50 06	 movzx	 ecx, WORD PTR [eax+edx*2+6]
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 _shr
  0021b	83 c4 08	 add	 esp, 8
  0021e	0f b7 d0	 movzx	 edx, ax
  00221	52		 push	 edx
  00222	e8 00 00 00 00	 call	 _sub
  00227	83 c4 08	 add	 esp, 8
  0022a	66 89 45 b0	 mov	 WORD PTR _data1$[ebp], ax

; 86   :      temp2 = add(temp3, mult(COEFF5_2, data1));

  0022e	0f b7 45 b0	 movzx	 eax, WORD PTR _data1$[ebp]
  00232	50		 push	 eax
  00233	68 f6 18 00 00	 push	 6390			; 000018f6H
  00238	e8 00 00 00 00	 call	 _mult
  0023d	83 c4 08	 add	 esp, 8
  00240	0f b7 c8	 movzx	 ecx, ax
  00243	51		 push	 ecx
  00244	0f b7 55 d4	 movzx	 edx, WORD PTR _temp3$[ebp]
  00248	52		 push	 edx
  00249	e8 00 00 00 00	 call	 _add
  0024e	83 c4 08	 add	 esp, 8
  00251	66 89 45 e0	 mov	 WORD PTR _temp2$[ebp], ax

; 87   :      
; 88   :      out[4*i+2] = add(temp1, temp2);                       move16 ();

  00255	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  00259	50		 push	 eax
  0025a	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  0025e	51		 push	 ecx
  0025f	e8 00 00 00 00	 call	 _add
  00264	83 c4 08	 add	 esp, 8
  00267	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  0026b	c1 e2 02	 shl	 edx, 2
  0026e	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00271	66 89 44 51 04	 mov	 WORD PTR [ecx+edx*2+4], ax
  00276	e8 00 00 00 00	 call	 _move16

; 89   :      out[4*i+3] = sub(temp1, temp2);                       move16 ();

  0027b	0f b7 45 e0	 movzx	 eax, WORD PTR _temp2$[ebp]
  0027f	50		 push	 eax
  00280	0f b7 4d ec	 movzx	 ecx, WORD PTR _temp1$[ebp]
  00284	51		 push	 ecx
  00285	e8 00 00 00 00	 call	 _sub
  0028a	83 c4 08	 add	 esp, 8
  0028d	0f bf 55 c8	 movsx	 edx, WORD PTR _i$[ebp]
  00291	c1 e2 02	 shl	 edx, 2
  00294	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00297	66 89 44 51 06	 mov	 WORD PTR [ecx+edx*2+6], ax
  0029c	e8 00 00 00 00	 call	 _move16

; 90   :   } 

  002a1	e9 b0 fd ff ff	 jmp	 $LN2@first_filt
$LN1@first_filt:

; 91   :   
; 92   :   data[0] = data0;                                         move16 ();

  002a6	b8 02 00 00 00	 mov	 eax, 2
  002ab	6b c8 00	 imul	 ecx, eax, 0
  002ae	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  002b1	66 8b 45 bc	 mov	 ax, WORD PTR _data0$[ebp]
  002b5	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  002b9	e8 00 00 00 00	 call	 _move16

; 93   :   data[1] = data1;                                         move16 ();

  002be	b8 02 00 00 00	 mov	 eax, 2
  002c3	c1 e0 00	 shl	 eax, 0
  002c6	8b 4d 10	 mov	 ecx, DWORD PTR _data$[ebp]
  002c9	66 8b 55 b0	 mov	 dx, WORD PTR _data1$[ebp]
  002cd	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  002d1	e8 00 00 00 00	 call	 _move16

; 94   : }

  002d6	5f		 pop	 edi
  002d7	5e		 pop	 esi
  002d8	5b		 pop	 ebx
  002d9	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  002df	3b ec		 cmp	 ebp, esp
  002e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e6	8b e5		 mov	 esp, ebp
  002e8	5d		 pop	 ebp
  002e9	c3		 ret	 0
_first_filter_stage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad1
_TEXT	SEGMENT
_i$ = -52						; size = 2
_pow_sum$ = -40						; size = 4
_level$ = -28						; size = 18
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_in_buf$ = 12						; size = 4
_vad1	PROC						; COMDAT

; 1034 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1035 :    Word16 level[COMPLEN];
; 1036 :    Word32 pow_sum;
; 1037 :    Word16 i;
; 1038 :    
; 1039 :    /* Calculate power of the input frame. */
; 1040 :    pow_sum = 0L;                                     move32 ();

  00028	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pow_sum$[ebp], 0
  0002f	e8 00 00 00 00	 call	 _move32

; 1041 : 
; 1042 :    for (i = 0; i < FRAME_LEN; i++)

  00034	33 c0		 xor	 eax, eax
  00036	66 89 45 cc	 mov	 WORD PTR _i$[ebp], ax
  0003a	eb 0c		 jmp	 SHORT $LN5@vad1
$LN4@vad1:
  0003c	66 8b 45 cc	 mov	 ax, WORD PTR _i$[ebp]
  00040	66 83 c0 01	 add	 ax, 1
  00044	66 89 45 cc	 mov	 WORD PTR _i$[ebp], ax
$LN5@vad1:
  00048	0f bf 45 cc	 movsx	 eax, WORD PTR _i$[ebp]
  0004c	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00051	7d 2b		 jge	 SHORT $LN3@vad1

; 1043 :    {  
; 1044 :       pow_sum = L_mac(pow_sum, in_buf[i-LOOKAHEAD], in_buf[i-LOOKAHEAD]);

  00053	0f bf 45 cc	 movsx	 eax, WORD PTR _i$[ebp]
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _in_buf$[ebp]
  0005a	0f b7 54 41 b0	 movzx	 edx, WORD PTR [ecx+eax*2-80]
  0005f	52		 push	 edx
  00060	0f bf 45 cc	 movsx	 eax, WORD PTR _i$[ebp]
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _in_buf$[ebp]
  00067	0f b7 54 41 b0	 movzx	 edx, WORD PTR [ecx+eax*2-80]
  0006c	52		 push	 edx
  0006d	8b 45 d8	 mov	 eax, DWORD PTR _pow_sum$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _L_mac
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	89 45 d8	 mov	 DWORD PTR _pow_sum$[ebp], eax

; 1045 :    }

  0007c	eb be		 jmp	 SHORT $LN4@vad1
$LN3@vad1:

; 1046 : 
; 1047 :    /*
; 1048 :      If input power is very low, clear pitch flag of the current frame
; 1049 :      */
; 1050 :    test ();

  0007e	e8 00 00 00 00	 call	 _test

; 1051 :    if (L_sub(pow_sum, POW_PITCH_THR) < 0)

  00083	68 00 3c 05 00	 push	 343040			; 00053c00H
  00088	8b 45 d8	 mov	 eax, DWORD PTR _pow_sum$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _L_sub
  00091	83 c4 08	 add	 esp, 8
  00094	85 c0		 test	 eax, eax
  00096	7d 1e		 jge	 SHORT $LN2@vad1

; 1052 :    {
; 1053 :       st->pitch = st->pitch & 0x3fff;                logic16 (); move16 ();

  00098	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0009b	0f bf 48 66	 movsx	 ecx, WORD PTR [eax+102]
  0009f	81 e1 ff 3f 00
	00		 and	 ecx, 16383		; 00003fffH
  000a5	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000a8	66 89 4a 66	 mov	 WORD PTR [edx+102], cx
  000ac	e8 00 00 00 00	 call	 _logic16
  000b1	e8 00 00 00 00	 call	 _move16
$LN2@vad1:

; 1054 :    }
; 1055 : 
; 1056 :    /*
; 1057 :      If input power is very low, clear complex flag of the "current" frame
; 1058 :      */
; 1059 :    test ();

  000b6	e8 00 00 00 00	 call	 _test

; 1060 :    if (L_sub(pow_sum, POW_COMPLEX_THR) < 0)

  000bb	68 98 3a 00 00	 push	 15000			; 00003a98H
  000c0	8b 45 d8	 mov	 eax, DWORD PTR _pow_sum$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _L_sub
  000c9	83 c4 08	 add	 esp, 8
  000cc	85 c0		 test	 eax, eax
  000ce	7d 1e		 jge	 SHORT $LN1@vad1

; 1061 :    {
; 1062 :       st->complex_low = st->complex_low & 0x3fff;    logic16 (); move16 ();

  000d0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d3	0f bf 48 6c	 movsx	 ecx, WORD PTR [eax+108]
  000d7	81 e1 ff 3f 00
	00		 and	 ecx, 16383		; 00003fffH
  000dd	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000e0	66 89 4a 6c	 mov	 WORD PTR [edx+108], cx
  000e4	e8 00 00 00 00	 call	 _logic16
  000e9	e8 00 00 00 00	 call	 _move16
$LN1@vad1:

; 1063 :    }
; 1064 :    
; 1065 :    /*
; 1066 :      Run the filter bank which calculates signal levels at each band
; 1067 :      */
; 1068 :    filter_bank(st, in_buf, level);

  000ee	8d 45 e4	 lea	 eax, DWORD PTR _level$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _in_buf$[ebp]
  000f5	51		 push	 ecx
  000f6	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _filter_bank
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1069 :    
; 1070 :    return (vad_decision(st, level, pow_sum));

  00102	8b 45 d8	 mov	 eax, DWORD PTR _pow_sum$[ebp]
  00105	50		 push	 eax
  00106	8d 4d e4	 lea	 ecx, DWORD PTR _level$[ebp]
  00109	51		 push	 ecx
  0010a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _vad_decision
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1071 : }

  00116	52		 push	 edx
  00117	8b cd		 mov	 ecx, ebp
  00119	50		 push	 eax
  0011a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@vad1
  00120	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00125	58		 pop	 eax
  00126	5a		 pop	 edx
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0013a	3b ec		 cmp	 ebp, esp
  0013c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
  00145	8d 49 00	 npad	 3
$LN10@vad1:
  00148	01 00 00 00	 DD	 1
  0014c	00 00 00 00	 DD	 $LN9@vad1
$LN9@vad1:
  00150	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00154	12 00 00 00	 DD	 18			; 00000012H
  00158	00 00 00 00	 DD	 $LN8@vad1
$LN8@vad1:
  0015c	6c		 DB	 108			; 0000006cH
  0015d	65		 DB	 101			; 00000065H
  0015e	76		 DB	 118			; 00000076H
  0015f	65		 DB	 101			; 00000065H
  00160	6c		 DB	 108			; 0000006cH
  00161	00		 DB	 0
_vad1	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad_pitch_detection
_TEXT	SEGMENT
_i$ = -20						; size = 2
_lagcount$ = -8						; size = 2
_st$ = 8						; size = 4
_T_op$ = 12						; size = 4
_vad_pitch_detection PROC				; COMDAT

; 992  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 993  :    Word16 lagcount, i;
; 994  :    
; 995  :    lagcount = 0;               move16 ();

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _lagcount$[ebp], ax
  00024	e8 00 00 00 00	 call	 _move16

; 996  :    
; 997  :    for (i = 0; i < 2; i++)

  00029	33 c0		 xor	 eax, eax
  0002b	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  0002f	eb 0c		 jmp	 SHORT $LN5@vad_pitch_
$LN4@vad_pitch_:
  00031	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  00035	66 83 c0 01	 add	 ax, 1
  00039	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN5@vad_pitch_:
  0003d	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00041	83 f8 02	 cmp	 eax, 2
  00044	7d 71		 jge	 SHORT $LN3@vad_pitch_

; 998  :    {
; 999  :       test ();

  00046	e8 00 00 00 00	 call	 _test

; 1000 :       if (sub (abs_s (sub (st->oldlag, T_op[i])), LTHRESH) < 0)

  0004b	6a 04		 push	 4
  0004d	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _T_op$[ebp]
  00054	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005c	0f b7 48 70	 movzx	 ecx, WORD PTR [eax+112]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _sub
  00066	83 c4 08	 add	 esp, 8
  00069	0f b7 d0	 movzx	 edx, ax
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _abs_s
  00072	83 c4 04	 add	 esp, 4
  00075	0f b7 c0	 movzx	 eax, ax
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _sub
  0007e	83 c4 08	 add	 esp, 8
  00081	0f bf c8	 movsx	 ecx, ax
  00084	85 c9		 test	 ecx, ecx
  00086	7d 13		 jge	 SHORT $LN2@vad_pitch_

; 1001 :       {
; 1002 :          lagcount = add (lagcount, 1);

  00088	6a 01		 push	 1
  0008a	0f b7 45 f8	 movzx	 eax, WORD PTR _lagcount$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _add
  00094	83 c4 08	 add	 esp, 8
  00097	66 89 45 f8	 mov	 WORD PTR _lagcount$[ebp], ax
$LN2@vad_pitch_:

; 1003 :       }
; 1004 :       
; 1005 :       /* Save the current LTP lag */
; 1006 :       st->oldlag = T_op[i];       move16 ();

  0009b	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a2	8b 55 0c	 mov	 edx, DWORD PTR _T_op$[ebp]
  000a5	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  000a9	66 89 41 70	 mov	 WORD PTR [ecx+112], ax
  000ad	e8 00 00 00 00	 call	 _move16

; 1007 :    }

  000b2	e9 7a ff ff ff	 jmp	 $LN4@vad_pitch_
$LN3@vad_pitch_:

; 1008 :    
; 1009 :    /* Make pitch decision.
; 1010 :       Save flag of the pitch detection to the variable pitch.
; 1011 :       */
; 1012 :    st->pitch = shr(st->pitch, 1); move16();

  000b7	6a 01		 push	 1
  000b9	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000bc	0f b7 48 66	 movzx	 ecx, WORD PTR [eax+102]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _shr
  000c6	83 c4 08	 add	 esp, 8
  000c9	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000cc	66 89 42 66	 mov	 WORD PTR [edx+102], ax
  000d0	e8 00 00 00 00	 call	 _move16

; 1013 :    
; 1014 :    test ();

  000d5	e8 00 00 00 00	 call	 _test

; 1015 :    if (sub ( add (st->oldlag_count, lagcount), NTHRESH) >= 0)

  000da	6a 04		 push	 4
  000dc	0f b7 45 f8	 movzx	 eax, WORD PTR _lagcount$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000e4	0f b7 51 6e	 movzx	 edx, WORD PTR [ecx+110]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _add
  000ee	83 c4 08	 add	 esp, 8
  000f1	0f b7 c0	 movzx	 eax, ax
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _sub
  000fa	83 c4 08	 add	 esp, 8
  000fd	0f bf c8	 movsx	 ecx, ax
  00100	85 c9		 test	 ecx, ecx
  00102	7c 1e		 jl	 SHORT $LN1@vad_pitch_

; 1016 :    {
; 1017 :       st->pitch = st->pitch | 0x4000; logic16(); move16();

  00104	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00107	0f bf 48 66	 movsx	 ecx, WORD PTR [eax+102]
  0010b	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00111	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00114	66 89 4a 66	 mov	 WORD PTR [edx+102], cx
  00118	e8 00 00 00 00	 call	 _logic16
  0011d	e8 00 00 00 00	 call	 _move16
$LN1@vad_pitch_:

; 1018 :    }
; 1019 :    
; 1020 :    /* Update oldlagcount */
; 1021 :    st->oldlag_count = lagcount;     move16 ();

  00122	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00125	66 8b 4d f8	 mov	 cx, WORD PTR _lagcount$[ebp]
  00129	66 89 48 6e	 mov	 WORD PTR [eax+110], cx
  0012d	e8 00 00 00 00	 call	 _move16

; 1022 : }

  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
  00135	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0013b	3b ec		 cmp	 ebp, esp
  0013d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
_vad_pitch_detection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad_tone_detection_update
_TEXT	SEGMENT
_st$ = 8						; size = 4
_one_lag_per_frame$ = 12				; size = 2
_vad_tone_detection_update PROC				; COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 969  :    /* Shift tone flags right by one bit */
; 970  :    st->tone = shr(st->tone, 1);                move16 ();

  0001e	6a 01		 push	 1
  00020	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00023	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _shr
  0002d	83 c4 08	 add	 esp, 8
  00030	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00033	66 89 42 68	 mov	 WORD PTR [edx+104], ax
  00037	e8 00 00 00 00	 call	 _move16

; 971  :    
; 972  :    /* If open-loop lag is calculated only once in each frame, do extra update
; 973  :       and assume that the other tone flag of the frame is one. */
; 974  :    if (one_lag_per_frame != 0)

  0003c	0f bf 45 0c	 movsx	 eax, WORD PTR _one_lag_per_frame$[ebp]
  00040	85 c0		 test	 eax, eax
  00042	74 37		 je	 SHORT $LN2@vad_tone_d

; 975  :    {
; 976  :       st->tone = shr(st->tone, 1);            

  00044	6a 01		 push	 1
  00046	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00049	0f b7 48 68	 movzx	 ecx, WORD PTR [eax+104]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _shr
  00053	83 c4 08	 add	 esp, 8
  00056	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00059	66 89 42 68	 mov	 WORD PTR [edx+104], ax

; 977  :       st->tone = st->tone | 0x2000;            logic16 (); move16 ();

  0005d	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00060	0f bf 48 68	 movsx	 ecx, WORD PTR [eax+104]
  00064	81 c9 00 20 00
	00		 or	 ecx, 8192		; 00002000H
  0006a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0006d	66 89 4a 68	 mov	 WORD PTR [edx+104], cx
  00071	e8 00 00 00 00	 call	 _logic16
  00076	e8 00 00 00 00	 call	 _move16
$LN2@vad_tone_d:

; 978  :    }
; 979  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_vad_tone_detection_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad_tone_detection
_TEXT	SEGMENT
_temp$ = -8						; size = 2
_st$ = 8						; size = 4
_t0$ = 12						; size = 4
_t1$ = 16						; size = 4
_vad_tone_detection PROC				; COMDAT

; 939  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 940  :    Word16 temp;
; 941  :    /* 
; 942  :       if (t0 > TONE_THR * t1)
; 943  :       set tone flag
; 944  :       */
; 945  :    temp = round(t1);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _t1$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _round
  00027	83 c4 04	 add	 esp, 4
  0002a	66 89 45 f8	 mov	 WORD PTR _temp$[ebp], ax

; 946  :    
; 947  :    test (); test ();

  0002e	e8 00 00 00 00	 call	 _test
  00033	e8 00 00 00 00	 call	 _test

; 948  :    if ((temp > 0) && (L_msu(t0, temp, TONE_THR) > 0))

  00038	0f bf 45 f8	 movsx	 eax, WORD PTR _temp$[ebp]
  0003c	85 c0		 test	 eax, eax
  0003e	7e 38		 jle	 SHORT $LN2@vad_tone_d
  00040	68 32 53 00 00	 push	 21298			; 00005332H
  00045	0f b7 45 f8	 movzx	 eax, WORD PTR _temp$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _t0$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 _L_msu
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	85 c0		 test	 eax, eax
  00058	7e 1e		 jle	 SHORT $LN2@vad_tone_d

; 949  :    {
; 950  :       st->tone = st->tone | 0x4000;              logic16 (); move16 ();

  0005a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005d	0f bf 48 68	 movsx	 ecx, WORD PTR [eax+104]
  00061	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00067	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0006a	66 89 4a 68	 mov	 WORD PTR [edx+104], cx
  0006e	e8 00 00 00 00	 call	 _logic16
  00073	e8 00 00 00 00	 call	 _move16
$LN2@vad_tone_d:

; 951  :    }
; 952  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_vad_tone_detection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad_complex_detection_update
_TEXT	SEGMENT
_st$ = 8						; size = 4
_best_corr_hp$ = 12					; size = 2
_vad_complex_detection_update PROC			; COMDAT

; 922  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 923  :    st->best_corr_hp = best_corr_hp;         move16();

  0001e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00021	66 8b 4d 0c	 mov	 cx, WORD PTR _best_corr_hp$[ebp]
  00025	66 89 48 76	 mov	 WORD PTR [eax+118], cx
  00029	e8 00 00 00 00	 call	 _move16

; 924  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_vad_complex_detection_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad1_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_vad1_exit PROC						; COMDAT

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 903  :     if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@vad1_exit
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@vad1_exit
$LN1@vad1_exit:

; 904  :         return;

  0002c	eb 21		 jmp	 SHORT $LN3@vad1_exit
$LN2@vad1_exit:

; 905  :     
; 906  :     /* deallocate memory */
; 907  :     free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 908  :     *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@vad1_exit:

; 909  :     
; 910  :     return;
; 911  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_vad1_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad1_reset
_TEXT	SEGMENT
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_vad1_reset PROC					; COMDAT

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 836  :    Word16 i, j;
; 837  :    
; 838  :    if (state == (vadState1 *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 38		 jne	 SHORT $LN13@vad1_reset

; 839  :       fprintf(stderr, "vad_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OHBJOMC@vad_reset?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 840  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 80 01 00 00	 jmp	 $LN14@vad1_reset
$LN13@vad1_reset:

; 841  :    }
; 842  :    
; 843  :    /* Initialize pitch detection variables */
; 844  :    state->oldlag_count = 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00061	66 89 41 6e	 mov	 WORD PTR [ecx+110], ax

; 845  :    state->oldlag = 0;         

  00065	33 c0		 xor	 eax, eax
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006a	66 89 41 70	 mov	 WORD PTR [ecx+112], ax

; 846  :    state->pitch = 0;

  0006e	33 c0		 xor	 eax, eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00073	66 89 41 66	 mov	 WORD PTR [ecx+102], ax

; 847  :    state->tone = 0;            

  00077	33 c0		 xor	 eax, eax
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	66 89 41 68	 mov	 WORD PTR [ecx+104], ax

; 848  : 
; 849  :    state->complex_high = 0;            

  00080	33 c0		 xor	 eax, eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00085	66 89 41 6a	 mov	 WORD PTR [ecx+106], ax

; 850  :    state->complex_low = 0;            

  00089	33 c0		 xor	 eax, eax
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008e	66 89 41 6c	 mov	 WORD PTR [ecx+108], ax

; 851  :    state->complex_hang_timer = 0;

  00092	33 c0		 xor	 eax, eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00097	66 89 41 74	 mov	 WORD PTR [ecx+116], ax

; 852  : 
; 853  :    state->vadreg = 0;         

  0009b	33 c0		 xor	 eax, eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a0	66 89 41 64	 mov	 WORD PTR [ecx+100], ax

; 854  : 
; 855  :    state->stat_count = 0;    

  000a4	33 c0		 xor	 eax, eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a9	66 89 41 62	 mov	 WORD PTR [ecx+98], ax

; 856  :    state->burst_count = 0;    

  000ad	33 c0		 xor	 eax, eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000b2	66 89 41 5e	 mov	 WORD PTR [ecx+94], ax

; 857  :    state->hang_count = 0;     

  000b6	33 c0		 xor	 eax, eax
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000bb	66 89 41 60	 mov	 WORD PTR [ecx+96], ax

; 858  :    state->complex_hang_count = 0;     

  000bf	33 c0		 xor	 eax, eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c4	66 89 41 72	 mov	 WORD PTR [ecx+114], ax

; 859  :    
; 860  :    /* initialize memory used by the filter bank */
; 861  :    for (i = 0; i < 3; i++)

  000c8	33 c0		 xor	 eax, eax
  000ca	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000ce	eb 0c		 jmp	 SHORT $LN12@vad1_reset
$LN11@vad1_reset:
  000d0	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000d4	66 83 c0 01	 add	 ax, 1
  000d8	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN12@vad1_reset:
  000dc	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000e0	83 f8 03	 cmp	 eax, 3
  000e3	7d 36		 jge	 SHORT $LN10@vad1_reset

; 862  :    {
; 863  :       for (j = 0; j < 2; j++) 

  000e5	33 c0		 xor	 eax, eax
  000e7	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  000eb	eb 0c		 jmp	 SHORT $LN9@vad1_reset
$LN8@vad1_reset:
  000ed	66 8b 45 ec	 mov	 ax, WORD PTR _j$[ebp]
  000f1	66 83 c0 01	 add	 ax, 1
  000f5	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
$LN9@vad1_reset:
  000f9	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  000fd	83 f8 02	 cmp	 eax, 2
  00100	7d 17		 jge	 SHORT $LN7@vad1_reset

; 864  :       {
; 865  :          state->a_data5[i][j] = 0;  

  00102	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00106	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00109	8d 54 81 48	 lea	 edx, DWORD PTR [ecx+eax*4+72]
  0010d	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00111	33 c9		 xor	 ecx, ecx
  00113	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 866  :       }

  00117	eb d4		 jmp	 SHORT $LN8@vad1_reset
$LN7@vad1_reset:

; 867  :    }

  00119	eb b5		 jmp	 SHORT $LN11@vad1_reset
$LN10@vad1_reset:

; 868  :    
; 869  :    for (i = 0; i < 5; i++)

  0011b	33 c0		 xor	 eax, eax
  0011d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00121	eb 0c		 jmp	 SHORT $LN6@vad1_reset
$LN5@vad1_reset:
  00123	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00127	66 83 c0 01	 add	 ax, 1
  0012b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN6@vad1_reset:
  0012f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00133	83 f8 05	 cmp	 eax, 5
  00136	7d 10		 jge	 SHORT $LN4@vad1_reset

; 870  :    {
; 871  :       state->a_data3[i] = 0;        

  00138	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0013c	33 c9		 xor	 ecx, ecx
  0013e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00141	66 89 4c 42 54	 mov	 WORD PTR [edx+eax*2+84], cx

; 872  :    }

  00146	eb db		 jmp	 SHORT $LN5@vad1_reset
$LN4@vad1_reset:

; 873  :    
; 874  :    /* initialize the rest of the memory */
; 875  :    for (i = 0; i < COMPLEN; i++)

  00148	33 c0		 xor	 eax, eax
  0014a	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0014e	eb 0c		 jmp	 SHORT $LN3@vad1_reset
$LN2@vad1_reset:
  00150	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00154	66 83 c0 01	 add	 ax, 1
  00158	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@vad1_reset:
  0015c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00160	83 f8 09	 cmp	 eax, 9
  00163	7d 42		 jge	 SHORT $LN1@vad1_reset

; 876  :    {
; 877  :       state->bckr_est[i] = NOISE_INIT;  

  00165	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00169	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  0016e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00171	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 878  :       state->old_level[i] = NOISE_INIT; 

  00175	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00179	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  0017e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00181	66 89 4c 42 24	 mov	 WORD PTR [edx+eax*2+36], cx

; 879  :       state->ave_level[i] = NOISE_INIT; 

  00186	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0018a	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  0018f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00192	66 89 4c 42 12	 mov	 WORD PTR [edx+eax*2+18], cx

; 880  :       state->sub_level[i] = 0;          

  00197	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0019b	33 c9		 xor	 ecx, ecx
  0019d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001a0	66 89 4c 42 36	 mov	 WORD PTR [edx+eax*2+54], cx

; 881  :    }

  001a5	eb a9		 jmp	 SHORT $LN2@vad1_reset
$LN1@vad1_reset:

; 882  :    
; 883  :    state->best_corr_hp = CVAD_LOWPOW_RESET; 

  001a7	b8 32 33 00 00	 mov	 eax, 13106		; 00003332H
  001ac	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001af	66 89 41 76	 mov	 WORD PTR [ecx+118], ax

; 884  : 
; 885  :    state->speech_vad_decision = 0;

  001b3	33 c0		 xor	 eax, eax
  001b5	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001b8	66 89 41 78	 mov	 WORD PTR [ecx+120], ax

; 886  :    state->complex_warning = 0;

  001bc	33 c0		 xor	 eax, eax
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001c1	66 89 41 7a	 mov	 WORD PTR [ecx+122], ax

; 887  :    state->sp_burst_count = 0;        

  001c5	33 c0		 xor	 eax, eax
  001c7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001ca	66 89 41 7c	 mov	 WORD PTR [ecx+124], ax

; 888  : 
; 889  :    state->corr_hp_fast = CVAD_LOWPOW_RESET;

  001ce	b8 32 33 00 00	 mov	 eax, 13106		; 00003332H
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001d6	66 89 41 7e	 mov	 WORD PTR [ecx+126], ax

; 890  :  
; 891  :    return 0;

  001da	33 c0		 xor	 eax, eax
$LN14@vad1_reset:

; 892  : }

  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx
  001df	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001e5	3b ec		 cmp	 ebp, esp
  001e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
_vad1_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\vad1.c
;	COMDAT _vad1_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_vad1_init PROC						; COMDAT

; 805  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 806  :     vadState1* s;
; 807  :     
; 808  :     if (state == (vadState1 **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@vad1_init

; 809  :         fprintf(stderr, "vad_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GALCDIAP@vad_init?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 810  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 74		 jmp	 SHORT $LN3@vad1_init
$LN2@vad1_init:

; 811  :     }
; 812  :     *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 813  :     
; 814  :     /* allocate memory */
; 815  :     if ((s = (vadState1 *) malloc(sizeof(vadState1))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	68 80 00 00 00	 push	 128			; 00000080H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 35		 jne	 SHORT $LN1@vad1_init

; 816  :         fprintf(stderr, "vad_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CDIILMGI@vad_init?3?5can?5not?5malloc?5state?5s@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 817  :         return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 16		 jmp	 SHORT $LN3@vad1_init
$LN1@vad1_init:

; 818  :     }
; 819  :     
; 820  :     vad1_reset(s);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _vad1_reset
  000c0	83 c4 04	 add	 esp, 4

; 821  :     
; 822  :     *state = s;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c9	89 08		 mov	 DWORD PTR [eax], ecx

; 823  :     
; 824  :     return 0;

  000cb	33 c0		 xor	 eax, eax
$LN3@vad1_init:

; 825  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d6	3b ec		 cmp	 ebp, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
_vad1_init ENDP
_TEXT	ENDS
END
