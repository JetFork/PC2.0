; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d1035pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_d1035pf_id
CONST	SEGMENT
_d1035pf_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_gray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	06H
	DW	04H
	DW	05H
	DW	07H
_dgray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	06H
	DW	04H
	DW	07H
CONST	ENDS
PUBLIC	_dec_10i40_35bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_L_mult:PROC
EXTRN	_negate:PROC
EXTRN	_extract_l:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
;	COMDAT _dec_10i40_35bits
_TEXT	SEGMENT
_tmp$ = -68						; size = 2
_sign$ = -56						; size = 2
_pos2$ = -44						; size = 2
_pos1$ = -32						; size = 2
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_index$ = 8						; size = 4
_cod$ = 12						; size = 4
_dec_10i40_35bits PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   :     Word16 i, j, pos1, pos2, sign, tmp;
; 65   : 
; 66   :     for (i = 0; i < L_CODE; i++)

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00024	eb 0c		 jmp	 SHORT $LN9@dec_10i40_
$LN8@dec_10i40_:
  00026	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002a	66 83 c0 01	 add	 ax, 1
  0002e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN9@dec_10i40_:
  00032	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00036	83 f8 28	 cmp	 eax, 40			; 00000028H
  00039	7d 14		 jge	 SHORT $LN7@dec_10i40_

; 67   :     {
; 68   :         cod[i] = 0;                                     move16 (); 

  0003b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0003f	33 c9		 xor	 ecx, ecx
  00041	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  00044	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00048	e8 00 00 00 00	 call	 _move16

; 69   :     }

  0004d	eb d7		 jmp	 SHORT $LN8@dec_10i40_
$LN7@dec_10i40_:

; 70   : 
; 71   :     /* decode the positions and signs of pulses and build the codeword */
; 72   : 
; 73   :     for (j = 0; j < NB_TRACK; j++)

  0004f	33 c0		 xor	 eax, eax
  00051	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  00055	eb 0c		 jmp	 SHORT $LN6@dec_10i40_
$LN5@dec_10i40_:
  00057	66 8b 45 ec	 mov	 ax, WORD PTR _j$[ebp]
  0005b	66 83 c0 01	 add	 ax, 1
  0005f	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
$LN6@dec_10i40_:
  00063	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00067	83 f8 05	 cmp	 eax, 5
  0006a	0f 8d a7 01 00
	00		 jge	 $LN10@dec_10i40_

; 74   :     {
; 75   :         /* compute index i */
; 76   : 
; 77   :         tmp = index[j];                                 move16 ();

  00070	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00077	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0007b	66 89 55 bc	 mov	 WORD PTR _tmp$[ebp], dx
  0007f	e8 00 00 00 00	 call	 _move16

; 78   :         i = tmp & 7;                                    logic16 (); 

  00084	0f bf 45 bc	 movsx	 eax, WORD PTR _tmp$[ebp]
  00088	83 e0 07	 and	 eax, 7
  0008b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0008f	e8 00 00 00 00	 call	 _logic16

; 79   :         i = dgray[i];                                   move16 (); 

  00094	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00098	66 8b 0c 45 00
	00 00 00	 mov	 cx, WORD PTR _dgray[eax*2]
  000a0	66 89 4d f8	 mov	 WORD PTR _i$[ebp], cx
  000a4	e8 00 00 00 00	 call	 _move16

; 80   : 
; 81   :         i = extract_l (L_shr (L_mult (i, 5), 1));

  000a9	6a 01		 push	 1
  000ab	6a 05		 push	 5
  000ad	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _L_mult
  000b7	83 c4 08	 add	 esp, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _L_shr
  000c0	83 c4 08	 add	 esp, 8
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _extract_l
  000c9	83 c4 04	 add	 esp, 4
  000cc	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 82   :         pos1 = add (i, j); /* position of pulse "j" */

  000d0	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  000d4	50		 push	 eax
  000d5	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _add
  000df	83 c4 08	 add	 esp, 8
  000e2	66 89 45 e0	 mov	 WORD PTR _pos1$[ebp], ax

; 83   : 
; 84   :         i = shr (tmp, 3) & 1;                           logic16 (); 

  000e6	6a 03		 push	 3
  000e8	0f b7 45 bc	 movzx	 eax, WORD PTR _tmp$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _shr
  000f2	83 c4 08	 add	 esp, 8
  000f5	0f bf c8	 movsx	 ecx, ax
  000f8	83 e1 01	 and	 ecx, 1
  000fb	66 89 4d f8	 mov	 WORD PTR _i$[ebp], cx
  000ff	e8 00 00 00 00	 call	 _logic16

; 85   :         test (); 

  00104	e8 00 00 00 00	 call	 _test

; 86   :         if (i == 0)

  00109	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0010d	85 c0		 test	 eax, eax
  0010f	75 10		 jne	 SHORT $LN3@dec_10i40_

; 87   :         {
; 88   :             sign = 4096;                                move16 (); /* +1.0 */

  00111	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00116	66 89 45 c8	 mov	 WORD PTR _sign$[ebp], ax
  0011a	e8 00 00 00 00	 call	 _move16

; 89   :         }
; 90   :         else

  0011f	eb 0e		 jmp	 SHORT $LN2@dec_10i40_
$LN3@dec_10i40_:

; 91   :         {
; 92   :             sign = -4096;                               move16 (); /* -1.0 */

  00121	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  00126	66 89 45 c8	 mov	 WORD PTR _sign$[ebp], ax
  0012a	e8 00 00 00 00	 call	 _move16
$LN2@dec_10i40_:

; 93   :         }
; 94   : 
; 95   :         cod[pos1] = sign;                               move16 (); 

  0012f	0f bf 45 e0	 movsx	 eax, WORD PTR _pos1$[ebp]
  00133	8b 4d 0c	 mov	 ecx, DWORD PTR _cod$[ebp]
  00136	66 8b 55 c8	 mov	 dx, WORD PTR _sign$[ebp]
  0013a	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0013e	e8 00 00 00 00	 call	 _move16

; 96   : 
; 97   :         /* compute index i */
; 98   : 
; 99   :         i = index[add (j, 5)] & 7;                      logic16 (); 

  00143	6a 05		 push	 5
  00145	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 _add
  0014f	83 c4 08	 add	 esp, 8
  00152	0f bf c8	 movsx	 ecx, ax
  00155	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00158	0f bf 04 4a	 movsx	 eax, WORD PTR [edx+ecx*2]
  0015c	83 e0 07	 and	 eax, 7
  0015f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00163	e8 00 00 00 00	 call	 _logic16

; 100  :         i = dgray[i];                                   move16 (); 

  00168	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0016c	66 8b 0c 45 00
	00 00 00	 mov	 cx, WORD PTR _dgray[eax*2]
  00174	66 89 4d f8	 mov	 WORD PTR _i$[ebp], cx
  00178	e8 00 00 00 00	 call	 _move16

; 101  :         i = extract_l (L_shr (L_mult (i, 5), 1));

  0017d	6a 01		 push	 1
  0017f	6a 05		 push	 5
  00181	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _L_mult
  0018b	83 c4 08	 add	 esp, 8
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _L_shr
  00194	83 c4 08	 add	 esp, 8
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 _extract_l
  0019d	83 c4 04	 add	 esp, 4
  001a0	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 102  : 
; 103  :         pos2 = add (i, j);      /* position of pulse "j+5" */

  001a4	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  001a8	50		 push	 eax
  001a9	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _add
  001b3	83 c4 08	 add	 esp, 8
  001b6	66 89 45 d4	 mov	 WORD PTR _pos2$[ebp], ax

; 104  : 
; 105  :         test (); 

  001ba	e8 00 00 00 00	 call	 _test

; 106  :         if (sub (pos2, pos1) < 0)

  001bf	0f b7 45 e0	 movzx	 eax, WORD PTR _pos1$[ebp]
  001c3	50		 push	 eax
  001c4	0f b7 4d d4	 movzx	 ecx, WORD PTR _pos2$[ebp]
  001c8	51		 push	 ecx
  001c9	e8 00 00 00 00	 call	 _sub
  001ce	83 c4 08	 add	 esp, 8
  001d1	0f bf d0	 movsx	 edx, ax
  001d4	85 d2		 test	 edx, edx
  001d6	7d 11		 jge	 SHORT $LN1@dec_10i40_

; 107  :         {
; 108  :             sign = negate (sign);

  001d8	0f b7 45 c8	 movzx	 eax, WORD PTR _sign$[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _negate
  001e2	83 c4 04	 add	 esp, 4
  001e5	66 89 45 c8	 mov	 WORD PTR _sign$[ebp], ax
$LN1@dec_10i40_:

; 109  :         }
; 110  :         cod[pos2] = add (cod[pos2], sign);              move16 (); 

  001e9	0f b7 45 c8	 movzx	 eax, WORD PTR _sign$[ebp]
  001ed	50		 push	 eax
  001ee	0f bf 4d d4	 movsx	 ecx, WORD PTR _pos2$[ebp]
  001f2	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  001f5	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 _add
  001ff	83 c4 08	 add	 esp, 8
  00202	0f bf 4d d4	 movsx	 ecx, WORD PTR _pos2$[ebp]
  00206	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  00209	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0020d	e8 00 00 00 00	 call	 _move16

; 111  :     }

  00212	e9 40 fe ff ff	 jmp	 $LN5@dec_10i40_
$LN10@dec_10i40_:

; 112  : 
; 113  :     return;
; 114  : }

  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx
  0021a	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00220	3b ec		 cmp	 ebp, esp
  00222	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	c3		 ret	 0
_dec_10i40_35bits ENDP
_TEXT	ENDS
END
