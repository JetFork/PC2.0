; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\set_sign.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_set_sign_id
CONST	SEGMENT
_set_sign_id DB	'@(#)$Id $@(#)$Id $', 00H
CONST	ENDS
PUBLIC	_set_sign
PUBLIC	_set_sign12k2
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_L_mult:PROC
EXTRN	_negate:PROC
EXTRN	_extract_h:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_shl:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Inv_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_sign.c
;	COMDAT _set_sign12k2
_TEXT	SEGMENT
_s$ = -208						; size = 4
_en$ = -196						; size = 80
_pos$ = -108						; size = 2
_max_of_all$ = -96					; size = 2
_max$ = -84						; size = 2
_k_dn$ = -72						; size = 2
_k_cn$ = -60						; size = 2
_cor$ = -48						; size = 2
_val$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_dn$ = 8						; size = 4
_cn$ = 12						; size = 4
_sign$ = 16						; size = 4
_pos_max$ = 20						; size = 4
_nb_track$ = 24						; size = 2
_ipos$ = 28						; size = 4
_step$ = 32						; size = 2
_set_sign12k2 PROC					; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 122  :     Word16 i, j;
; 123  :     Word16 val, cor, k_cn, k_dn, max, max_of_all;
; 124  :     Word16 pos = 0; /* initialization only needed to keep gcc silent */

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 94	 mov	 WORD PTR _pos$[ebp], ax

; 125  :     Word16 en[L_CODE];                  /* correlation vector */
; 126  :     Word32 s;
; 127  :  
; 128  :     /* calculate energy for normalization of cn[] and dn[] */
; 129  :  
; 130  :     s = 256;                                     move32 (); 

  0002e	c7 85 30 ff ff
	ff 00 01 00 00	 mov	 DWORD PTR _s$[ebp], 256	; 00000100H
  00038	e8 00 00 00 00	 call	 _move32

; 131  :     for (i = 0; i < L_CODE; i++)

  0003d	33 c0		 xor	 eax, eax
  0003f	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00043	eb 0c		 jmp	 SHORT $LN23@set_sign12
$LN22@set_sign12:
  00045	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00049	66 83 c0 01	 add	 ax, 1
  0004d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN23@set_sign12:
  00051	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00055	83 f8 28	 cmp	 eax, 40			; 00000028H
  00058	7d 2f		 jge	 SHORT $LN21@set_sign12

; 132  :     {
; 133  :         s = L_mac (s, cn[i], cn[i]);

  0005a	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _cn$[ebp]
  00061	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00065	52		 push	 edx
  00066	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _cn$[ebp]
  0006d	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00071	52		 push	 edx
  00072	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _L_mac
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	89 85 30 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 134  :     }

  00087	eb bc		 jmp	 SHORT $LN22@set_sign12
$LN21@set_sign12:

; 135  :     s = Inv_sqrt (s);                            move32 (); 

  00089	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _Inv_sqrt
  00095	83 c4 04	 add	 esp, 4
  00098	89 85 30 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax
  0009e	e8 00 00 00 00	 call	 _move32

; 136  :     k_cn = extract_h (L_shl (s, 5));

  000a3	6a 05		 push	 5
  000a5	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _L_shl
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _extract_h
  000ba	83 c4 04	 add	 esp, 4
  000bd	66 89 45 c4	 mov	 WORD PTR _k_cn$[ebp], ax

; 137  :     
; 138  :     s = 256;                                     move32 (); 

  000c1	c7 85 30 ff ff
	ff 00 01 00 00	 mov	 DWORD PTR _s$[ebp], 256	; 00000100H
  000cb	e8 00 00 00 00	 call	 _move32

; 139  :     for (i = 0; i < L_CODE; i++)

  000d0	33 c0		 xor	 eax, eax
  000d2	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  000d6	eb 0c		 jmp	 SHORT $LN20@set_sign12
$LN19@set_sign12:
  000d8	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  000dc	66 83 c0 01	 add	 ax, 1
  000e0	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN20@set_sign12:
  000e4	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000e8	83 f8 28	 cmp	 eax, 40			; 00000028H
  000eb	7d 2f		 jge	 SHORT $LN18@set_sign12

; 140  :     {
; 141  :         s = L_mac (s, dn[i], dn[i]);

  000ed	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  000f4	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000f8	52		 push	 edx
  000f9	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00100	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00104	52		 push	 edx
  00105	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _L_mac
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
  00114	89 85 30 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 142  :     }

  0011a	eb bc		 jmp	 SHORT $LN19@set_sign12
$LN18@set_sign12:

; 143  :     s = Inv_sqrt (s);                            move32 (); 

  0011c	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _Inv_sqrt
  00128	83 c4 04	 add	 esp, 4
  0012b	89 85 30 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax
  00131	e8 00 00 00 00	 call	 _move32

; 144  :     k_dn = extract_h (L_shl (s, 5));

  00136	6a 05		 push	 5
  00138	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _L_shl
  00144	83 c4 08	 add	 esp, 8
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _extract_h
  0014d	83 c4 04	 add	 esp, 4
  00150	66 89 45 b8	 mov	 WORD PTR _k_dn$[ebp], ax

; 145  :     
; 146  :     for (i = 0; i < L_CODE; i++)

  00154	33 c0		 xor	 eax, eax
  00156	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0015a	eb 0c		 jmp	 SHORT $LN17@set_sign12
$LN16@set_sign12:
  0015c	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00160	66 83 c0 01	 add	 ax, 1
  00164	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN17@set_sign12:
  00168	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0016c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0016f	0f 8d e1 00 00
	00		 jge	 $LN15@set_sign12

; 147  :     {
; 148  :         val = dn[i];                             move16 (); 

  00175	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  0017c	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00180	66 89 55 dc	 mov	 WORD PTR _val$[ebp], dx
  00184	e8 00 00 00 00	 call	 _move16

; 149  :         cor = round (L_shl (L_mac (L_mult (k_cn, cn[i]), k_dn, val), 10));

  00189	6a 0a		 push	 10			; 0000000aH
  0018b	0f b7 45 dc	 movzx	 eax, WORD PTR _val$[ebp]
  0018f	50		 push	 eax
  00190	0f b7 4d b8	 movzx	 ecx, WORD PTR _k_dn$[ebp]
  00194	51		 push	 ecx
  00195	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00199	8b 45 0c	 mov	 eax, DWORD PTR _cn$[ebp]
  0019c	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  001a0	51		 push	 ecx
  001a1	0f b7 55 c4	 movzx	 edx, WORD PTR _k_cn$[ebp]
  001a5	52		 push	 edx
  001a6	e8 00 00 00 00	 call	 _L_mult
  001ab	83 c4 08	 add	 esp, 8
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _L_mac
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 _L_shl
  001bd	83 c4 08	 add	 esp, 8
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 _round
  001c6	83 c4 04	 add	 esp, 4
  001c9	66 89 45 d0	 mov	 WORD PTR _cor$[ebp], ax

; 150  :  
; 151  :         test (); 

  001cd	e8 00 00 00 00	 call	 _test

; 152  :         if (cor >= 0)

  001d2	0f bf 45 d0	 movsx	 eax, WORD PTR _cor$[ebp]
  001d6	85 c0		 test	 eax, eax
  001d8	7c 17		 jl	 SHORT $LN14@set_sign12

; 153  :         {
; 154  :             sign[i] = 32767;                     move16 (); /* sign = +1 */

  001da	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001de	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  001e3	8b 55 10	 mov	 edx, DWORD PTR _sign$[ebp]
  001e6	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001ea	e8 00 00 00 00	 call	 _move16

; 155  :         }
; 156  :         else

  001ef	eb 37		 jmp	 SHORT $LN13@set_sign12
$LN14@set_sign12:

; 157  :         {
; 158  :             sign[i] = -32767;                    move16 (); /* sign = -1 */

  001f1	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001f5	b9 01 80 ff ff	 mov	 ecx, -32767		; ffff8001H
  001fa	8b 55 10	 mov	 edx, DWORD PTR _sign$[ebp]
  001fd	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00201	e8 00 00 00 00	 call	 _move16

; 159  :             cor = negate (cor);

  00206	0f b7 45 d0	 movzx	 eax, WORD PTR _cor$[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 _negate
  00210	83 c4 04	 add	 esp, 4
  00213	66 89 45 d0	 mov	 WORD PTR _cor$[ebp], ax

; 160  :             val = negate (val);

  00217	0f b7 45 dc	 movzx	 eax, WORD PTR _val$[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _negate
  00221	83 c4 04	 add	 esp, 4
  00224	66 89 45 dc	 mov	 WORD PTR _val$[ebp], ax
$LN13@set_sign12:

; 161  :         }
; 162  :         /* modify dn[] according to the fixed sign */        
; 163  :         dn[i] = val;                             move16 (); 

  00228	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0022c	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  0022f	66 8b 55 dc	 mov	 dx, WORD PTR _val$[ebp]
  00233	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00237	e8 00 00 00 00	 call	 _move16

; 164  :         en[i] = cor;                             move16 (); 

  0023c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00240	66 8b 4d d0	 mov	 cx, WORD PTR _cor$[ebp]
  00244	66 89 8c 45 3c
	ff ff ff	 mov	 WORD PTR _en$[ebp+eax*2], cx
  0024c	e8 00 00 00 00	 call	 _move16

; 165  :     }

  00251	e9 06 ff ff ff	 jmp	 $LN16@set_sign12
$LN15@set_sign12:

; 166  :     
; 167  :     max_of_all = -1;                             move16 (); 

  00256	83 c8 ff	 or	 eax, -1
  00259	66 89 45 a0	 mov	 WORD PTR _max_of_all$[ebp], ax
  0025d	e8 00 00 00 00	 call	 _move16

; 168  :     for (i = 0; i < nb_track; i++)

  00262	33 c0		 xor	 eax, eax
  00264	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00268	eb 0c		 jmp	 SHORT $LN12@set_sign12
$LN11@set_sign12:
  0026a	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0026e	66 83 c0 01	 add	 ax, 1
  00272	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN12@set_sign12:
  00276	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0027a	0f bf 4d 18	 movsx	 ecx, WORD PTR _nb_track$[ebp]
  0027e	3b c1		 cmp	 eax, ecx
  00280	0f 8d e2 00 00
	00		 jge	 $LN10@set_sign12

; 169  :     {
; 170  :         max = -1;                                move16 (); 

  00286	83 c8 ff	 or	 eax, -1
  00289	66 89 45 ac	 mov	 WORD PTR _max$[ebp], ax
  0028d	e8 00 00 00 00	 call	 _move16

; 171  :         
; 172  :         for (j = i; j < L_CODE; j += step)

  00292	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00296	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  0029a	eb 0e		 jmp	 SHORT $LN9@set_sign12
$LN8@set_sign12:
  0029c	0f bf 45 20	 movsx	 eax, WORD PTR _step$[ebp]
  002a0	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  002a4	03 c8		 add	 ecx, eax
  002a6	66 89 4d e8	 mov	 WORD PTR _j$[ebp], cx
$LN9@set_sign12:
  002aa	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  002ae	83 f8 28	 cmp	 eax, 40			; 00000028H
  002b1	7d 54		 jge	 SHORT $LN7@set_sign12

; 173  :         {
; 174  :             cor = en[j];                         move16 (); 

  002b3	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  002b7	66 8b 8c 45 3c
	ff ff ff	 mov	 cx, WORD PTR _en$[ebp+eax*2]
  002bf	66 89 4d d0	 mov	 WORD PTR _cor$[ebp], cx
  002c3	e8 00 00 00 00	 call	 _move16

; 175  :             val = sub (cor, max);

  002c8	0f b7 45 ac	 movzx	 eax, WORD PTR _max$[ebp]
  002cc	50		 push	 eax
  002cd	0f b7 4d d0	 movzx	 ecx, WORD PTR _cor$[ebp]
  002d1	51		 push	 ecx
  002d2	e8 00 00 00 00	 call	 _sub
  002d7	83 c4 08	 add	 esp, 8
  002da	66 89 45 dc	 mov	 WORD PTR _val$[ebp], ax

; 176  :             test (); 

  002de	e8 00 00 00 00	 call	 _test

; 177  :             if (val > 0)

  002e3	0f bf 45 dc	 movsx	 eax, WORD PTR _val$[ebp]
  002e7	85 c0		 test	 eax, eax
  002e9	7e 1a		 jle	 SHORT $LN6@set_sign12

; 178  :             {
; 179  :                 max = cor;                       move16 (); 

  002eb	66 8b 45 d0	 mov	 ax, WORD PTR _cor$[ebp]
  002ef	66 89 45 ac	 mov	 WORD PTR _max$[ebp], ax
  002f3	e8 00 00 00 00	 call	 _move16

; 180  :                 pos = j;                         move16 (); 

  002f8	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  002fc	66 89 45 94	 mov	 WORD PTR _pos$[ebp], ax
  00300	e8 00 00 00 00	 call	 _move16
$LN6@set_sign12:

; 181  :             }
; 182  :         }

  00305	eb 95		 jmp	 SHORT $LN8@set_sign12
$LN7@set_sign12:

; 183  :         /* store maximum correlation position */
; 184  :         pos_max[i] = pos;                        move16 (); 

  00307	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0030b	8b 4d 14	 mov	 ecx, DWORD PTR _pos_max$[ebp]
  0030e	66 8b 55 94	 mov	 dx, WORD PTR _pos$[ebp]
  00312	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00316	e8 00 00 00 00	 call	 _move16

; 185  :         val = sub (max, max_of_all);

  0031b	0f b7 45 a0	 movzx	 eax, WORD PTR _max_of_all$[ebp]
  0031f	50		 push	 eax
  00320	0f b7 4d ac	 movzx	 ecx, WORD PTR _max$[ebp]
  00324	51		 push	 ecx
  00325	e8 00 00 00 00	 call	 _sub
  0032a	83 c4 08	 add	 esp, 8
  0032d	66 89 45 dc	 mov	 WORD PTR _val$[ebp], ax

; 186  :         test (); 

  00331	e8 00 00 00 00	 call	 _test

; 187  :         if (val > 0)

  00336	0f bf 45 dc	 movsx	 eax, WORD PTR _val$[ebp]
  0033a	85 c0		 test	 eax, eax
  0033c	7e 25		 jle	 SHORT $LN5@set_sign12

; 188  :         {
; 189  :             max_of_all = max;                    move16 ();

  0033e	66 8b 45 ac	 mov	 ax, WORD PTR _max$[ebp]
  00342	66 89 45 a0	 mov	 WORD PTR _max_of_all$[ebp], ax
  00346	e8 00 00 00 00	 call	 _move16

; 190  :             /* starting position for i0 */            
; 191  :             ipos[0] = i;                         move16 (); 

  0034b	b8 02 00 00 00	 mov	 eax, 2
  00350	6b c8 00	 imul	 ecx, eax, 0
  00353	8b 55 1c	 mov	 edx, DWORD PTR _ipos$[ebp]
  00356	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0035a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  0035e	e8 00 00 00 00	 call	 _move16
$LN5@set_sign12:

; 192  :         }
; 193  :     }

  00363	e9 02 ff ff ff	 jmp	 $LN11@set_sign12
$LN10@set_sign12:

; 194  :     
; 195  :     /*----------------------------------------------------------------*
; 196  :      *     Set starting position of each pulse.                       *
; 197  :      *----------------------------------------------------------------*/
; 198  :     
; 199  :     pos = ipos[0];                               move16 (); 

  00368	b8 02 00 00 00	 mov	 eax, 2
  0036d	6b c8 00	 imul	 ecx, eax, 0
  00370	8b 55 1c	 mov	 edx, DWORD PTR _ipos$[ebp]
  00373	66 8b 04 0a	 mov	 ax, WORD PTR [edx+ecx]
  00377	66 89 45 94	 mov	 WORD PTR _pos$[ebp], ax
  0037b	e8 00 00 00 00	 call	 _move16

; 200  :     ipos[nb_track] = pos;                        move16 (); 

  00380	0f bf 45 18	 movsx	 eax, WORD PTR _nb_track$[ebp]
  00384	8b 4d 1c	 mov	 ecx, DWORD PTR _ipos$[ebp]
  00387	66 8b 55 94	 mov	 dx, WORD PTR _pos$[ebp]
  0038b	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0038f	e8 00 00 00 00	 call	 _move16

; 201  :     
; 202  :     for (i = 1; i < nb_track; i++)

  00394	b8 01 00 00 00	 mov	 eax, 1
  00399	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0039d	eb 0c		 jmp	 SHORT $LN4@set_sign12
$LN3@set_sign12:
  0039f	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  003a3	66 83 c0 01	 add	 ax, 1
  003a7	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN4@set_sign12:
  003ab	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  003af	0f bf 4d 18	 movsx	 ecx, WORD PTR _nb_track$[ebp]
  003b3	3b c1		 cmp	 eax, ecx
  003b5	7d 7a		 jge	 SHORT $LN24@set_sign12

; 203  :     {
; 204  :         pos = add (pos, 1);

  003b7	6a 01		 push	 1
  003b9	0f b7 45 94	 movzx	 eax, WORD PTR _pos$[ebp]
  003bd	50		 push	 eax
  003be	e8 00 00 00 00	 call	 _add
  003c3	83 c4 08	 add	 esp, 8
  003c6	66 89 45 94	 mov	 WORD PTR _pos$[ebp], ax

; 205  :         test ();

  003ca	e8 00 00 00 00	 call	 _test

; 206  :         if (sub (pos, nb_track) >= 0)

  003cf	0f b7 45 18	 movzx	 eax, WORD PTR _nb_track$[ebp]
  003d3	50		 push	 eax
  003d4	0f b7 4d 94	 movzx	 ecx, WORD PTR _pos$[ebp]
  003d8	51		 push	 ecx
  003d9	e8 00 00 00 00	 call	 _sub
  003de	83 c4 08	 add	 esp, 8
  003e1	0f bf d0	 movsx	 edx, ax
  003e4	85 d2		 test	 edx, edx
  003e6	7c 0b		 jl	 SHORT $LN1@set_sign12

; 207  :         {
; 208  :            pos = 0;                              move16 (); 

  003e8	33 c0		 xor	 eax, eax
  003ea	66 89 45 94	 mov	 WORD PTR _pos$[ebp], ax
  003ee	e8 00 00 00 00	 call	 _move16
$LN1@set_sign12:

; 209  :         }
; 210  :         ipos[i] = pos;                           move16 (); 

  003f3	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  003f7	8b 4d 1c	 mov	 ecx, DWORD PTR _ipos$[ebp]
  003fa	66 8b 55 94	 mov	 dx, WORD PTR _pos$[ebp]
  003fe	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00402	e8 00 00 00 00	 call	 _move16

; 211  :         ipos[add(i, nb_track)] = pos;            move16 (); 

  00407	0f b7 45 18	 movzx	 eax, WORD PTR _nb_track$[ebp]
  0040b	50		 push	 eax
  0040c	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  00410	51		 push	 ecx
  00411	e8 00 00 00 00	 call	 _add
  00416	83 c4 08	 add	 esp, 8
  00419	0f bf d0	 movsx	 edx, ax
  0041c	8b 45 1c	 mov	 eax, DWORD PTR _ipos$[ebp]
  0041f	66 8b 4d 94	 mov	 cx, WORD PTR _pos$[ebp]
  00423	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00427	e8 00 00 00 00	 call	 _move16

; 212  :     }

  0042c	e9 6e ff ff ff	 jmp	 $LN3@set_sign12
$LN24@set_sign12:

; 213  : }

  00431	52		 push	 edx
  00432	8b cd		 mov	 ecx, ebp
  00434	50		 push	 eax
  00435	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@set_sign12
  0043b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00440	58		 pop	 eax
  00441	5a		 pop	 edx
  00442	5f		 pop	 edi
  00443	5e		 pop	 esi
  00444	5b		 pop	 ebx
  00445	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00448	33 cd		 xor	 ecx, ebp
  0044a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044f	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00455	3b ec		 cmp	 ebp, esp
  00457	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0045c	8b e5		 mov	 esp, ebp
  0045e	5d		 pop	 ebp
  0045f	c3		 ret	 0
$LN28@set_sign12:
  00460	01 00 00 00	 DD	 1
  00464	00 00 00 00	 DD	 $LN27@set_sign12
$LN27@set_sign12:
  00468	3c ff ff ff	 DD	 -196			; ffffff3cH
  0046c	50 00 00 00	 DD	 80			; 00000050H
  00470	00 00 00 00	 DD	 $LN26@set_sign12
$LN26@set_sign12:
  00474	65		 DB	 101			; 00000065H
  00475	6e		 DB	 110			; 0000006eH
  00476	00		 DB	 0
_set_sign12k2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_sign.c
;	COMDAT _set_sign
_TEXT	SEGMENT
_pos$ = -68						; size = 2
_min$ = -56						; size = 2
_val$ = -44						; size = 2
_k$ = -32						; size = 2
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_dn$ = 8						; size = 4
_sign$ = 12						; size = 4
_dn2$ = 16						; size = 4
_n$ = 20						; size = 2
_set_sign PROC						; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 54   :    Word16 i, j, k;
; 55   :    Word16 val, min;
; 56   :    Word16 pos = 0; /* initialization only needed to keep gcc silent */

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 bc	 mov	 WORD PTR _pos$[ebp], ax

; 57   :    
; 58   :    /* set sign according to dn[] */
; 59   :    
; 60   :    for (i = 0; i < L_CODE; i++) {

  00024	33 c0		 xor	 eax, eax
  00026	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0002a	eb 0c		 jmp	 SHORT $LN16@set_sign
$LN15@set_sign:
  0002c	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00030	66 83 c0 01	 add	 ax, 1
  00034	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN16@set_sign:
  00038	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0003c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0003f	0f 8d 8b 00 00
	00		 jge	 $LN14@set_sign

; 61   :       val = dn[i];                                 move16 ();

  00045	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  0004c	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00050	66 89 55 d4	 mov	 WORD PTR _val$[ebp], dx
  00054	e8 00 00 00 00	 call	 _move16

; 62   :       
; 63   :       test ();

  00059	e8 00 00 00 00	 call	 _test

; 64   :       if (val >= 0) {

  0005e	0f bf 45 d4	 movsx	 eax, WORD PTR _val$[ebp]
  00062	85 c0		 test	 eax, eax
  00064	7c 17		 jl	 SHORT $LN13@set_sign

; 65   :          sign[i] = 32767;                          move16 ();

  00066	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0006a	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0006f	8b 55 0c	 mov	 edx, DWORD PTR _sign$[ebp]
  00072	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00076	e8 00 00 00 00	 call	 _move16

; 66   :       } else {

  0007b	eb 26		 jmp	 SHORT $LN12@set_sign
$LN13@set_sign:

; 67   :          sign[i] = -32767;                         move16 ();

  0007d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00081	b9 01 80 ff ff	 mov	 ecx, -32767		; ffff8001H
  00086	8b 55 0c	 mov	 edx, DWORD PTR _sign$[ebp]
  00089	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0008d	e8 00 00 00 00	 call	 _move16

; 68   :          val = negate(val);

  00092	0f b7 45 d4	 movzx	 eax, WORD PTR _val$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _negate
  0009c	83 c4 04	 add	 esp, 4
  0009f	66 89 45 d4	 mov	 WORD PTR _val$[ebp], ax
$LN12@set_sign:

; 69   :       }
; 70   :       dn[i] = val;    move16 (); /* modify dn[] according to the fixed sign */

  000a3	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  000aa	66 8b 55 d4	 mov	 dx, WORD PTR _val$[ebp]
  000ae	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  000b2	e8 00 00 00 00	 call	 _move16

; 71   :       dn2[i] = val;   move16 ();

  000b7	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _dn2$[ebp]
  000be	66 8b 55 d4	 mov	 dx, WORD PTR _val$[ebp]
  000c2	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  000c6	e8 00 00 00 00	 call	 _move16

; 72   :    }

  000cb	e9 5c ff ff ff	 jmp	 $LN15@set_sign
$LN14@set_sign:

; 73   :    
; 74   :    /* keep 8-n maximum positions/8 of each track and store it in dn2[] */
; 75   :    
; 76   :    for (i = 0; i < NB_TRACK; i++)

  000d0	33 c0		 xor	 eax, eax
  000d2	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000d6	eb 0c		 jmp	 SHORT $LN11@set_sign
$LN10@set_sign:
  000d8	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000dc	66 83 c0 01	 add	 ax, 1
  000e0	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN11@set_sign:
  000e4	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000e8	83 f8 05	 cmp	 eax, 5
  000eb	0f 8d da 00 00
	00		 jge	 $LN17@set_sign

; 77   :    {
; 78   :       for (k = 0; k < (8-n); k++)

  000f1	33 c0		 xor	 eax, eax
  000f3	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
  000f7	eb 0c		 jmp	 SHORT $LN8@set_sign
$LN7@set_sign:
  000f9	66 8b 45 e0	 mov	 ax, WORD PTR _k$[ebp]
  000fd	66 83 c0 01	 add	 ax, 1
  00101	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
$LN8@set_sign:
  00105	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  00109	0f bf 4d 14	 movsx	 ecx, WORD PTR _n$[ebp]
  0010d	ba 08 00 00 00	 mov	 edx, 8
  00112	2b d1		 sub	 edx, ecx
  00114	3b c2		 cmp	 eax, edx
  00116	0f 8d aa 00 00
	00		 jge	 $LN6@set_sign

; 79   :       {
; 80   :          min = 0x7fff;                             move16 ();

  0011c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00121	66 89 45 c8	 mov	 WORD PTR _min$[ebp], ax
  00125	e8 00 00 00 00	 call	 _move16

; 81   :          for (j = i; j < L_CODE; j += STEP)

  0012a	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0012e	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  00132	eb 0b		 jmp	 SHORT $LN5@set_sign
$LN4@set_sign:
  00134	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00138	83 c0 05	 add	 eax, 5
  0013b	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
$LN5@set_sign:
  0013f	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00143	83 f8 28	 cmp	 eax, 40			; 00000028H
  00146	7d 66		 jge	 SHORT $LN3@set_sign

; 82   :          {
; 83   :             test ();                               move16 ();

  00148	e8 00 00 00 00	 call	 _test
  0014d	e8 00 00 00 00	 call	 _move16

; 84   :             if (dn2[j] >= 0)

  00152	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00156	8b 4d 10	 mov	 ecx, DWORD PTR _dn2$[ebp]
  00159	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  0015d	85 d2		 test	 edx, edx
  0015f	7c 4b		 jl	 SHORT $LN2@set_sign

; 85   :             {
; 86   :                val = sub(dn2[j], min);

  00161	0f b7 45 c8	 movzx	 eax, WORD PTR _min$[ebp]
  00165	50		 push	 eax
  00166	0f bf 4d ec	 movsx	 ecx, WORD PTR _j$[ebp]
  0016a	8b 55 10	 mov	 edx, DWORD PTR _dn2$[ebp]
  0016d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _sub
  00177	83 c4 08	 add	 esp, 8
  0017a	66 89 45 d4	 mov	 WORD PTR _val$[ebp], ax

; 87   :                test ();

  0017e	e8 00 00 00 00	 call	 _test

; 88   :                if (val < 0)

  00183	0f bf 45 d4	 movsx	 eax, WORD PTR _val$[ebp]
  00187	85 c0		 test	 eax, eax
  00189	7d 21		 jge	 SHORT $LN2@set_sign

; 89   :                {
; 90   :                   min = dn2[j];                    move16 ();

  0018b	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  0018f	8b 4d 10	 mov	 ecx, DWORD PTR _dn2$[ebp]
  00192	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00196	66 89 55 c8	 mov	 WORD PTR _min$[ebp], dx
  0019a	e8 00 00 00 00	 call	 _move16

; 91   :                   pos = j;                         move16 ();

  0019f	66 8b 45 ec	 mov	 ax, WORD PTR _j$[ebp]
  001a3	66 89 45 bc	 mov	 WORD PTR _pos$[ebp], ax
  001a7	e8 00 00 00 00	 call	 _move16
$LN2@set_sign:

; 92   :                }
; 93   :             }
; 94   :          }

  001ac	eb 86		 jmp	 SHORT $LN4@set_sign
$LN3@set_sign:

; 95   :          dn2[pos] = -1;                            move16 ();

  001ae	0f bf 45 bc	 movsx	 eax, WORD PTR _pos$[ebp]
  001b2	83 c9 ff	 or	 ecx, -1
  001b5	8b 55 10	 mov	 edx, DWORD PTR _dn2$[ebp]
  001b8	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001bc	e8 00 00 00 00	 call	 _move16

; 96   :       }

  001c1	e9 33 ff ff ff	 jmp	 $LN7@set_sign
$LN6@set_sign:

; 97   :    }

  001c6	e9 0d ff ff ff	 jmp	 $LN10@set_sign
$LN17@set_sign:

; 98   :    
; 99   :    return;
; 100  : }

  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx
  001ce	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  001d4	3b ec		 cmp	 ebp, esp
  001d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c3		 ret	 0
_set_sign ENDP
_TEXT	ENDS
END
