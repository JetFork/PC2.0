; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d2_11pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_d2_11pf_c_id
CONST	SEGMENT
_d2_11pf_c_id DB '@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_decode_2i40_11bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
;	COMDAT _decode_2i40_11bits
_TEXT	SEGMENT
_pos$ = -32						; size = 4
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_sign$ = 8						; size = 2
_index$ = 12						; size = 2
_cod$ = 16						; size = 4
_decode_2i40_11bits PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   :     Word16 i, j;
; 61   :     Word16 pos[NB_PULSE];
; 62   : 
; 63   :     /* Decode the positions */
; 64   : 
; 65   :     j = index & 1;                                       logic16 ();

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  00022	83 e0 01	 and	 eax, 1
  00025	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  00029	e8 00 00 00 00	 call	 _logic16

; 66   :     index = shr(index, 1);

  0002e	6a 01		 push	 1
  00030	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _shr
  0003a	83 c4 08	 add	 esp, 8
  0003d	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 67   :     i = index & 7;                                       logic16 ();

  00041	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  00045	83 e0 07	 and	 eax, 7
  00048	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0004c	e8 00 00 00 00	 call	 _logic16

; 68   : 
; 69   :     i = add(i, shl(i, 2));        /* pos0 =i*5+1+j*2 */

  00051	6a 02		 push	 2
  00053	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _shl
  0005d	83 c4 08	 add	 esp, 8
  00060	0f b7 c8	 movzx	 ecx, ax
  00063	51		 push	 ecx
  00064	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _add
  0006e	83 c4 08	 add	 esp, 8
  00071	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 70   :     i = add(i, 1);

  00075	6a 01		 push	 1
  00077	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _add
  00081	83 c4 08	 add	 esp, 8
  00084	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 71   :     j = shl(j, 1);  

  00088	6a 01		 push	 1
  0008a	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _shl
  00094	83 c4 08	 add	 esp, 8
  00097	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax

; 72   :     pos[0] = add(i, j);                                  move16 ();

  0009b	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  0009f	50		 push	 eax
  000a0	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _add
  000aa	83 c4 08	 add	 esp, 8
  000ad	ba 02 00 00 00	 mov	 edx, 2
  000b2	6b ca 00	 imul	 ecx, edx, 0
  000b5	66 89 44 0d e0	 mov	 WORD PTR _pos$[ebp+ecx], ax
  000ba	e8 00 00 00 00	 call	 _move16

; 73   :        
; 74   :     index = shr(index, 3);

  000bf	6a 03		 push	 3
  000c1	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _shr
  000cb	83 c4 08	 add	 esp, 8
  000ce	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 75   :     j = index & 3;                                       logic16 ();

  000d2	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  000d6	83 e0 03	 and	 eax, 3
  000d9	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  000dd	e8 00 00 00 00	 call	 _logic16

; 76   :     index = shr(index, 2);

  000e2	6a 02		 push	 2
  000e4	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _shr
  000ee	83 c4 08	 add	 esp, 8
  000f1	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 77   :     i = index & 7;                                       logic16 ();

  000f5	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  000f9	83 e0 07	 and	 eax, 7
  000fc	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00100	e8 00 00 00 00	 call	 _logic16

; 78   : 
; 79   :     test();

  00105	e8 00 00 00 00	 call	 _test

; 80   : 	if (sub(j, 3) == 0)

  0010a	6a 03		 push	 3
  0010c	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _sub
  00116	83 c4 08	 add	 esp, 8
  00119	0f bf c8	 movsx	 ecx, ax
  0011c	85 c9		 test	 ecx, ecx
  0011e	75 47		 jne	 SHORT $LN10@decode_2i4

; 81   :     {       
; 82   :        i = add(i, shl(i, 2));        /* pos1 =i*5+4 */

  00120	6a 02		 push	 2
  00122	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _shl
  0012c	83 c4 08	 add	 esp, 8
  0012f	0f b7 c8	 movzx	 ecx, ax
  00132	51		 push	 ecx
  00133	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _add
  0013d	83 c4 08	 add	 esp, 8
  00140	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 83   :        pos[1] = add(i, 4);                               move16 ();

  00144	6a 04		 push	 4
  00146	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _add
  00150	83 c4 08	 add	 esp, 8
  00153	b9 02 00 00 00	 mov	 ecx, 2
  00158	c1 e1 00	 shl	 ecx, 0
  0015b	66 89 44 0d e0	 mov	 WORD PTR _pos$[ebp+ecx], ax
  00160	e8 00 00 00 00	 call	 _move16

; 84   :     }
; 85   :     else

  00165	eb 48		 jmp	 SHORT $LN9@decode_2i4
$LN10@decode_2i4:

; 86   :     {       
; 87   :        i = add(i, shl(i, 2));        /* pos1 =i*5+j */

  00167	6a 02		 push	 2
  00169	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _shl
  00173	83 c4 08	 add	 esp, 8
  00176	0f b7 c8	 movzx	 ecx, ax
  00179	51		 push	 ecx
  0017a	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 _add
  00184	83 c4 08	 add	 esp, 8
  00187	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 88   :        pos[1] = add(i, j);                               move16 ();

  0018b	0f b7 45 ec	 movzx	 eax, WORD PTR _j$[ebp]
  0018f	50		 push	 eax
  00190	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 _add
  0019a	83 c4 08	 add	 esp, 8
  0019d	ba 02 00 00 00	 mov	 edx, 2
  001a2	c1 e2 00	 shl	 edx, 0
  001a5	66 89 44 15 e0	 mov	 WORD PTR _pos$[ebp+edx], ax
  001aa	e8 00 00 00 00	 call	 _move16
$LN9@decode_2i4:

; 89   :     }
; 90   :        
; 91   :     /* decode the signs  and build the codeword */
; 92   : 
; 93   :     for (i = 0; i < L_SUBFR; i++) {

  001af	33 c0		 xor	 eax, eax
  001b1	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  001b5	eb 0c		 jmp	 SHORT $LN8@decode_2i4
$LN7@decode_2i4:
  001b7	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  001bb	66 83 c0 01	 add	 ax, 1
  001bf	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN8@decode_2i4:
  001c3	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001c7	83 f8 28	 cmp	 eax, 40			; 00000028H
  001ca	7d 14		 jge	 SHORT $LN6@decode_2i4

; 94   :         cod[i] = 0;                                      move16 ();

  001cc	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001d0	33 c9		 xor	 ecx, ecx
  001d2	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  001d5	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001d9	e8 00 00 00 00	 call	 _move16

; 95   :     }

  001de	eb d7		 jmp	 SHORT $LN7@decode_2i4
$LN6@decode_2i4:

; 96   : 
; 97   :     for (j = 0; j < NB_PULSE; j++) {

  001e0	33 c0		 xor	 eax, eax
  001e2	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  001e6	eb 0c		 jmp	 SHORT $LN5@decode_2i4
$LN4@decode_2i4:
  001e8	66 8b 45 ec	 mov	 ax, WORD PTR _j$[ebp]
  001ec	66 83 c0 01	 add	 ax, 1
  001f0	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
$LN5@decode_2i4:
  001f4	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  001f8	83 f8 02	 cmp	 eax, 2
  001fb	7d 68		 jge	 SHORT $LN11@decode_2i4

; 98   :         i = sign & 1;                                    logic16 ();

  001fd	0f bf 45 08	 movsx	 eax, WORD PTR _sign$[ebp]
  00201	83 e0 01	 and	 eax, 1
  00204	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00208	e8 00 00 00 00	 call	 _logic16

; 99   :         sign = shr(sign, 1);

  0020d	6a 01		 push	 1
  0020f	0f b7 45 08	 movzx	 eax, WORD PTR _sign$[ebp]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _shr
  00219	83 c4 08	 add	 esp, 8
  0021c	66 89 45 08	 mov	 WORD PTR _sign$[ebp], ax

; 100  : 
; 101  :         test ();

  00220	e8 00 00 00 00	 call	 _test

; 102  :         if (i != 0) {

  00225	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00229	85 c0		 test	 eax, eax
  0022b	74 1c		 je	 SHORT $LN2@decode_2i4

; 103  :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  0022d	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00231	0f bf 4c 45 e0	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  00236	ba ff 1f 00 00	 mov	 edx, 8191		; 00001fffH
  0023b	8b 45 10	 mov	 eax, DWORD PTR _cod$[ebp]
  0023e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00242	e8 00 00 00 00	 call	 _move16

; 104  :         } else {

  00247	eb 1a		 jmp	 SHORT $LN1@decode_2i4
$LN2@decode_2i4:

; 105  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  00249	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  0024d	0f bf 4c 45 e0	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  00252	ba 00 e0 ff ff	 mov	 edx, -8192		; ffffe000H
  00257	8b 45 10	 mov	 eax, DWORD PTR _cod$[ebp]
  0025a	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  0025e	e8 00 00 00 00	 call	 _move16
$LN1@decode_2i4:

; 106  :         }
; 107  :     }

  00263	eb 83		 jmp	 SHORT $LN4@decode_2i4
$LN11@decode_2i4:

; 108  : 
; 109  :     return;
; 110  : }

  00265	52		 push	 edx
  00266	8b cd		 mov	 ecx, ebp
  00268	50		 push	 eax
  00269	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@decode_2i4
  0026f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00274	58		 pop	 eax
  00275	5a		 pop	 edx
  00276	5f		 pop	 edi
  00277	5e		 pop	 esi
  00278	5b		 pop	 ebx
  00279	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0027f	3b ec		 cmp	 ebp, esp
  00281	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
  0028a	8b ff		 npad	 2
$LN15@decode_2i4:
  0028c	01 00 00 00	 DD	 1
  00290	00 00 00 00	 DD	 $LN14@decode_2i4
$LN14@decode_2i4:
  00294	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00298	04 00 00 00	 DD	 4
  0029c	00 00 00 00	 DD	 $LN13@decode_2i4
$LN13@decode_2i4:
  002a0	70		 DB	 112			; 00000070H
  002a1	6f		 DB	 111			; 0000006fH
  002a2	73		 DB	 115			; 00000073H
  002a3	00		 DB	 0
_decode_2i40_11bits ENDP
_TEXT	ENDS
END
