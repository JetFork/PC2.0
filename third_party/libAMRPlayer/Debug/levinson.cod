; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\levinson.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_levinson_id
CONST	SEGMENT
_levinson_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_Levinson_init
PUBLIC	_Levinson_reset
PUBLIC	_Levinson_exit
PUBLIC	_Levinson
PUBLIC	??_C@_0CC@IEHEBOIL@Levinson_init?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CP@MDECMGMJ@Levinson_init?3?5can?5not?5malloc?5st@ ; `string'
PUBLIC	??_C@_0CD@OEEABPNN@Levinson_reset?3?5invalid?5paramete@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_round:PROC
EXTRN	_L_add:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_negate:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_abs:PROC
EXTRN	_norm_l:PROC
EXTRN	_L_Extract:PROC
EXTRN	_L_Comp:PROC
EXTRN	_Mpy_32:PROC
EXTRN	_Div_32:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CD@OEEABPNN@Levinson_reset?3?5invalid?5paramete@
CONST	SEGMENT
??_C@_0CD@OEEABPNN@Levinson_reset?3?5invalid?5paramete@ DB 'Levinson_rese'
	DB	't: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MDECMGMJ@Levinson_init?3?5can?5not?5malloc?5st@
CONST	SEGMENT
??_C@_0CP@MDECMGMJ@Levinson_init?3?5can?5not?5malloc?5st@ DB 'Levinson_in'
	DB	'it: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IEHEBOIL@Levinson_init?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@IEHEBOIL@Levinson_init?3?5invalid?5parameter@ DB 'Levinson_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\levinson.c
;	COMDAT _Levinson
_TEXT	SEGMENT
tv376 = -470						; size = 2
_t2$ = -272						; size = 4
_t1$ = -260						; size = 4
_t0$ = -248						; size = 4
_Anl$ = -236						; size = 22
_Anh$ = -204						; size = 22
_Al$ = -172						; size = 22
_Ah$ = -140						; size = 22
_alp_exp$ = -108					; size = 2
_alp_l$ = -96						; size = 2
_alp_h$ = -84						; size = 2
_Kl$ = -72						; size = 2
_Kh$ = -60						; size = 2
_lo$ = -48						; size = 2
_hi$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_Rh$ = 12						; size = 4
_Rl$ = 16						; size = 4
_A$ = 20						; size = 4
_rc$ = 24						; size = 4
_Levinson PROC						; COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 169  :     Word16 i, j;
; 170  :     Word16 hi, lo;
; 171  :     Word16 Kh, Kl;                /* reflexion coefficient; hi and lo      */
; 172  :     Word16 alp_h, alp_l, alp_exp; /* Prediction gain; hi lo and exponent   */
; 173  :     Word16 Ah[M + 1], Al[M + 1];  /* LPC coef. in double prec.             */
; 174  :     Word16 Anh[M + 1], Anl[M + 1];/* LPC coef.for next iteration in double
; 175  :                                      prec. */
; 176  :     Word32 t0, t1, t2;            /* temporary variable                    */
; 177  : 
; 178  :     /* K = A[1] = -R[1] / R[0] */
; 179  : 
; 180  :     t1 = L_Comp (Rh[1], Rl[1]);

  00028	b8 02 00 00 00	 mov	 eax, 2
  0002d	c1 e0 00	 shl	 eax, 0
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _Rl$[ebp]
  00033	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00037	52		 push	 edx
  00038	b8 02 00 00 00	 mov	 eax, 2
  0003d	c1 e0 00	 shl	 eax, 0
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _Rh$[ebp]
  00043	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _L_Comp
  0004d	83 c4 08	 add	 esp, 8
  00050	89 85 fc fe ff
	ff		 mov	 DWORD PTR _t1$[ebp], eax

; 181  :     t2 = L_abs (t1);                    /* abs R[1]         */

  00056	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _t1$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _L_abs
  00062	83 c4 04	 add	 esp, 4
  00065	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 182  :     t0 = Div_32 (t2, Rh[0], Rl[0]);     /* R[1]/R[0]        */

  0006b	b8 02 00 00 00	 mov	 eax, 2
  00070	6b c8 00	 imul	 ecx, eax, 0
  00073	8b 55 10	 mov	 edx, DWORD PTR _Rl$[ebp]
  00076	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0007a	50		 push	 eax
  0007b	b9 02 00 00 00	 mov	 ecx, 2
  00080	6b d1 00	 imul	 edx, ecx, 0
  00083	8b 45 0c	 mov	 eax, DWORD PTR _Rh$[ebp]
  00086	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  0008a	51		 push	 ecx
  0008b	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _t2$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _Div_32
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 183  :     test (); 

  000a0	e8 00 00 00 00	 call	 _test

; 184  :     if (t1 > 0)

  000a5	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _t1$[ebp], 0
  000ac	7e 15		 jle	 SHORT $LN25@Levinson

; 185  :        t0 = L_negate (t0);             /* -R[1]/R[0]       */

  000ae	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _L_negate
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax
$LN25@Levinson:

; 186  :     L_Extract (t0, &Kh, &Kl);           /* K in DPF         */

  000c3	8d 45 b8	 lea	 eax, DWORD PTR _Kl$[ebp]
  000c6	50		 push	 eax
  000c7	8d 4d c4	 lea	 ecx, DWORD PTR _Kh$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _t0$[ebp]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _L_Extract
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  :     
; 188  :     rc[0] = round (t0);                 move16 (); 

  000da	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _round
  000e6	83 c4 04	 add	 esp, 4
  000e9	b9 02 00 00 00	 mov	 ecx, 2
  000ee	6b d1 00	 imul	 edx, ecx, 0
  000f1	8b 4d 18	 mov	 ecx, DWORD PTR _rc$[ebp]
  000f4	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  000f8	e8 00 00 00 00	 call	 _move16

; 189  : 
; 190  :     t0 = L_shr (t0, 4);                 /* A[1] in          */

  000fd	6a 04		 push	 4
  000ff	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _L_shr
  0010b	83 c4 08	 add	 esp, 8
  0010e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 191  :     L_Extract (t0, &Ah[1], &Al[1]);     /* A[1] in DPF      */

  00114	b8 02 00 00 00	 mov	 eax, 2
  00119	c1 e0 00	 shl	 eax, 0
  0011c	8d 8c 05 54 ff
	ff ff		 lea	 ecx, DWORD PTR _Al$[ebp+eax]
  00123	51		 push	 ecx
  00124	ba 02 00 00 00	 mov	 edx, 2
  00129	c1 e2 00	 shl	 edx, 0
  0012c	8d 84 15 74 ff
	ff ff		 lea	 eax, DWORD PTR _Ah$[ebp+edx]
  00133	50		 push	 eax
  00134	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _L_Extract
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 192  : 
; 193  :     /*  Alpha = R[0] * (1-K**2) */
; 194  : 
; 195  :     t0 = Mpy_32 (Kh, Kl, Kh, Kl);       /* K*K             */

  00143	0f b7 45 b8	 movzx	 eax, WORD PTR _Kl$[ebp]
  00147	50		 push	 eax
  00148	0f b7 4d c4	 movzx	 ecx, WORD PTR _Kh$[ebp]
  0014c	51		 push	 ecx
  0014d	0f b7 55 b8	 movzx	 edx, WORD PTR _Kl$[ebp]
  00151	52		 push	 edx
  00152	0f b7 45 c4	 movzx	 eax, WORD PTR _Kh$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _Mpy_32
  0015c	83 c4 10	 add	 esp, 16			; 00000010H
  0015f	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 196  :     t0 = L_abs (t0);                    /* Some case <0 !! */

  00165	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _L_abs
  00171	83 c4 04	 add	 esp, 4
  00174	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 197  :     t0 = L_sub ((Word32) 0x7fffffffL, t0); /* 1 - K*K        */

  0017a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  00180	50		 push	 eax
  00181	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00186	e8 00 00 00 00	 call	 _L_sub
  0018b	83 c4 08	 add	 esp, 8
  0018e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 198  :     L_Extract (t0, &hi, &lo);           /* DPF format      */

  00194	8d 45 d0	 lea	 eax, DWORD PTR _lo$[ebp]
  00197	50		 push	 eax
  00198	8d 4d dc	 lea	 ecx, DWORD PTR _hi$[ebp]
  0019b	51		 push	 ecx
  0019c	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _t0$[ebp]
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 _L_Extract
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  :     t0 = Mpy_32 (Rh[0], Rl[0], hi, lo); /* Alpha in        */

  001ab	0f b7 45 d0	 movzx	 eax, WORD PTR _lo$[ebp]
  001af	50		 push	 eax
  001b0	0f b7 4d dc	 movzx	 ecx, WORD PTR _hi$[ebp]
  001b4	51		 push	 ecx
  001b5	ba 02 00 00 00	 mov	 edx, 2
  001ba	6b c2 00	 imul	 eax, edx, 0
  001bd	8b 4d 10	 mov	 ecx, DWORD PTR _Rl$[ebp]
  001c0	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  001c4	52		 push	 edx
  001c5	b8 02 00 00 00	 mov	 eax, 2
  001ca	6b c8 00	 imul	 ecx, eax, 0
  001cd	8b 55 0c	 mov	 edx, DWORD PTR _Rh$[ebp]
  001d0	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 _Mpy_32
  001da	83 c4 10	 add	 esp, 16			; 00000010H
  001dd	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 200  : 
; 201  :     /* Normalize Alpha */
; 202  : 
; 203  :     alp_exp = norm_l (t0);

  001e3	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _norm_l
  001ef	83 c4 04	 add	 esp, 4
  001f2	66 89 45 94	 mov	 WORD PTR _alp_exp$[ebp], ax

; 204  :     t0 = L_shl (t0, alp_exp);

  001f6	0f b7 45 94	 movzx	 eax, WORD PTR _alp_exp$[ebp]
  001fa	50		 push	 eax
  001fb	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 _L_shl
  00207	83 c4 08	 add	 esp, 8
  0020a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 205  :     L_Extract (t0, &alp_h, &alp_l);     /* DPF format    */

  00210	8d 45 a0	 lea	 eax, DWORD PTR _alp_l$[ebp]
  00213	50		 push	 eax
  00214	8d 4d ac	 lea	 ecx, DWORD PTR _alp_h$[ebp]
  00217	51		 push	 ecx
  00218	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _t0$[ebp]
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 _L_Extract
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  : 
; 207  :     /*--------------------------------------*
; 208  :      * ITERATIONS  I=2 to M                 *
; 209  :      *--------------------------------------*/
; 210  : 
; 211  :     for (i = 2; i <= M; i++)

  00227	b8 02 00 00 00	 mov	 eax, 2
  0022c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00230	eb 0c		 jmp	 SHORT $LN24@Levinson
$LN23@Levinson:
  00232	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00236	66 83 c0 01	 add	 ax, 1
  0023a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN24@Levinson:
  0023e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00242	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00245	0f 8f 97 04 00
	00		 jg	 $LN22@Levinson

; 212  :     {
; 213  :        /* t0 = SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i] */
; 214  :        
; 215  :        t0 = 0;                         move32 (); 

  0024b	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _t0$[ebp], 0
  00255	e8 00 00 00 00	 call	 _move32

; 216  :        for (j = 1; j < i; j++)

  0025a	b8 01 00 00 00	 mov	 eax, 1
  0025f	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00263	eb 0c		 jmp	 SHORT $LN21@Levinson
$LN20@Levinson:
  00265	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00269	66 83 c0 01	 add	 ax, 1
  0026d	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN21@Levinson:
  00271	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00275	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00279	3b c1		 cmp	 eax, ecx
  0027b	7d 5e		 jge	 SHORT $LN19@Levinson

; 217  :        {
; 218  :           t0 = L_add (t0, Mpy_32 (Rh[j], Rl[j], Ah[i - j], Al[i - j]));

  0027d	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00281	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00285	2b c1		 sub	 eax, ecx
  00287	0f b7 94 45 54
	ff ff ff	 movzx	 edx, WORD PTR _Al$[ebp+eax*2]
  0028f	52		 push	 edx
  00290	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00294	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00298	2b c1		 sub	 eax, ecx
  0029a	0f b7 94 45 74
	ff ff ff	 movzx	 edx, WORD PTR _Ah$[ebp+eax*2]
  002a2	52		 push	 edx
  002a3	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  002a7	8b 4d 10	 mov	 ecx, DWORD PTR _Rl$[ebp]
  002aa	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  002ae	52		 push	 edx
  002af	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  002b3	8b 4d 0c	 mov	 ecx, DWORD PTR _Rh$[ebp]
  002b6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  002ba	52		 push	 edx
  002bb	e8 00 00 00 00	 call	 _Mpy_32
  002c0	83 c4 10	 add	 esp, 16			; 00000010H
  002c3	50		 push	 eax
  002c4	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 _L_add
  002d0	83 c4 08	 add	 esp, 8
  002d3	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 219  :        }

  002d9	eb 8a		 jmp	 SHORT $LN20@Levinson
$LN19@Levinson:

; 220  :        t0 = L_shl (t0, 4);

  002db	6a 04		 push	 4
  002dd	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 _L_shl
  002e9	83 c4 08	 add	 esp, 8
  002ec	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 221  :        
; 222  :        t1 = L_Comp (Rh[i], Rl[i]);

  002f2	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  002f6	8b 4d 10	 mov	 ecx, DWORD PTR _Rl$[ebp]
  002f9	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  002fd	52		 push	 edx
  002fe	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00302	8b 4d 0c	 mov	 ecx, DWORD PTR _Rh$[ebp]
  00305	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00309	52		 push	 edx
  0030a	e8 00 00 00 00	 call	 _L_Comp
  0030f	83 c4 08	 add	 esp, 8
  00312	89 85 fc fe ff
	ff		 mov	 DWORD PTR _t1$[ebp], eax

; 223  :        t0 = L_add (t0, t1);            /* add R[i]        */

  00318	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _t1$[ebp]
  0031e	50		 push	 eax
  0031f	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 _L_add
  0032b	83 c4 08	 add	 esp, 8
  0032e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 224  :        
; 225  :        /* K = -t0 / Alpha */
; 226  :        
; 227  :        t1 = L_abs (t0);

  00334	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 _L_abs
  00340	83 c4 04	 add	 esp, 4
  00343	89 85 fc fe ff
	ff		 mov	 DWORD PTR _t1$[ebp], eax

; 228  :        t2 = Div_32 (t1, alp_h, alp_l); /* abs(t0)/Alpha              */

  00349	0f b7 45 a0	 movzx	 eax, WORD PTR _alp_l$[ebp]
  0034d	50		 push	 eax
  0034e	0f b7 4d ac	 movzx	 ecx, WORD PTR _alp_h$[ebp]
  00352	51		 push	 ecx
  00353	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _t1$[ebp]
  00359	52		 push	 edx
  0035a	e8 00 00 00 00	 call	 _Div_32
  0035f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00362	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 229  :        test (); 

  00368	e8 00 00 00 00	 call	 _test

; 230  :        if (t0 > 0)

  0036d	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR _t0$[ebp], 0
  00374	7e 15		 jle	 SHORT $LN18@Levinson

; 231  :           t2 = L_negate (t2);         /* K =-t0/Alpha                */

  00376	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _t2$[ebp]
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 _L_negate
  00382	83 c4 04	 add	 esp, 4
  00385	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax
$LN18@Levinson:

; 232  :        t2 = L_shl (t2, alp_exp);       /* denormalize; compare to Alpha */

  0038b	0f b7 45 94	 movzx	 eax, WORD PTR _alp_exp$[ebp]
  0038f	50		 push	 eax
  00390	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _t2$[ebp]
  00396	51		 push	 ecx
  00397	e8 00 00 00 00	 call	 _L_shl
  0039c	83 c4 08	 add	 esp, 8
  0039f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 233  :        L_Extract (t2, &Kh, &Kl);       /* K in DPF                      */

  003a5	8d 45 b8	 lea	 eax, DWORD PTR _Kl$[ebp]
  003a8	50		 push	 eax
  003a9	8d 4d c4	 lea	 ecx, DWORD PTR _Kh$[ebp]
  003ac	51		 push	 ecx
  003ad	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _t2$[ebp]
  003b3	52		 push	 edx
  003b4	e8 00 00 00 00	 call	 _L_Extract
  003b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  :        
; 235  :        test (); 

  003bc	e8 00 00 00 00	 call	 _test

; 236  :        if (sub (i, 5) < 0)

  003c1	6a 05		 push	 5
  003c3	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 _sub
  003cd	83 c4 08	 add	 esp, 8
  003d0	0f bf c8	 movsx	 ecx, ax
  003d3	85 c9		 test	 ecx, ecx
  003d5	7d 20		 jge	 SHORT $LN17@Levinson

; 237  :        {
; 238  :           rc[i - 1] = round (t2);     move16 (); 

  003d7	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _t2$[ebp]
  003dd	50		 push	 eax
  003de	e8 00 00 00 00	 call	 _round
  003e3	83 c4 04	 add	 esp, 4
  003e6	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  003ea	8b 55 18	 mov	 edx, DWORD PTR _rc$[ebp]
  003ed	66 89 44 4a fe	 mov	 WORD PTR [edx+ecx*2-2], ax
  003f2	e8 00 00 00 00	 call	 _move16
$LN17@Levinson:

; 239  :        }
; 240  :        /* Test for unstable filter. If unstable keep old A(z) */
; 241  :        
; 242  :        test (); 

  003f7	e8 00 00 00 00	 call	 _test

; 243  :        if (sub (abs_s (Kh), 32750) > 0)

  003fc	68 ee 7f 00 00	 push	 32750			; 00007feeH
  00401	0f b7 45 c4	 movzx	 eax, WORD PTR _Kh$[ebp]
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 _abs_s
  0040b	83 c4 04	 add	 esp, 4
  0040e	0f b7 c8	 movzx	 ecx, ax
  00411	51		 push	 ecx
  00412	e8 00 00 00 00	 call	 _sub
  00417	83 c4 08	 add	 esp, 8
  0041a	0f bf d0	 movsx	 edx, ax
  0041d	85 d2		 test	 edx, edx
  0041f	7e 72		 jle	 SHORT $LN16@Levinson

; 244  :        {
; 245  :           for (j = 0; j <= M; j++)

  00421	33 c0		 xor	 eax, eax
  00423	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00427	eb 0c		 jmp	 SHORT $LN15@Levinson
$LN14@Levinson:
  00429	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  0042d	66 83 c0 01	 add	 ax, 1
  00431	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN15@Levinson:
  00435	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00439	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0043c	7f 1d		 jg	 SHORT $LN13@Levinson

; 246  :           {
; 247  :              A[j] = st->old_A[j];        move16 (); 

  0043e	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00442	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00446	8b 55 14	 mov	 edx, DWORD PTR _A$[ebp]
  00449	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  0044c	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  00450	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00454	e8 00 00 00 00	 call	 _move16

; 248  :           }

  00459	eb ce		 jmp	 SHORT $LN14@Levinson
$LN13@Levinson:

; 249  :           
; 250  :           for (j = 0; j < 4; j++)

  0045b	33 c0		 xor	 eax, eax
  0045d	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00461	eb 0c		 jmp	 SHORT $LN12@Levinson
$LN11@Levinson:
  00463	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00467	66 83 c0 01	 add	 ax, 1
  0046b	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN12@Levinson:
  0046f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00473	83 f8 04	 cmp	 eax, 4
  00476	7d 14		 jge	 SHORT $LN10@Levinson

; 251  :           {
; 252  :              rc[j] = 0;              move16 (); 

  00478	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0047c	33 c9		 xor	 ecx, ecx
  0047e	8b 55 18	 mov	 edx, DWORD PTR _rc$[ebp]
  00481	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00485	e8 00 00 00 00	 call	 _move16

; 253  :           }

  0048a	eb d7		 jmp	 SHORT $LN11@Levinson
$LN10@Levinson:

; 254  :           
; 255  :           return 0;

  0048c	33 c0		 xor	 eax, eax
  0048e	e9 06 03 00 00	 jmp	 $LN26@Levinson
$LN16@Levinson:

; 256  :        }
; 257  :        /*------------------------------------------*
; 258  :         *  Compute new LPC coeff. -> An[i]         *
; 259  :         *  An[j]= A[j] + K*A[i-j]     , j=1 to i-1 *
; 260  :         *  An[i]= K                                *
; 261  :         *------------------------------------------*/
; 262  :        
; 263  :        for (j = 1; j < i; j++)

  00493	b8 01 00 00 00	 mov	 eax, 1
  00498	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  0049c	eb 0c		 jmp	 SHORT $LN9@Levinson
$LN8@Levinson:
  0049e	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  004a2	66 83 c0 01	 add	 ax, 1
  004a6	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN9@Levinson:
  004aa	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  004ae	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  004b2	3b c1		 cmp	 eax, ecx
  004b4	0f 8d a2 00 00
	00		 jge	 $LN7@Levinson

; 264  :        {
; 265  :           t0 = Mpy_32 (Kh, Kl, Ah[i - j], Al[i - j]);

  004ba	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  004be	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  004c2	2b c1		 sub	 eax, ecx
  004c4	0f b7 94 45 54
	ff ff ff	 movzx	 edx, WORD PTR _Al$[ebp+eax*2]
  004cc	52		 push	 edx
  004cd	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  004d1	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  004d5	2b c1		 sub	 eax, ecx
  004d7	0f b7 94 45 74
	ff ff ff	 movzx	 edx, WORD PTR _Ah$[ebp+eax*2]
  004df	52		 push	 edx
  004e0	0f b7 45 b8	 movzx	 eax, WORD PTR _Kl$[ebp]
  004e4	50		 push	 eax
  004e5	0f b7 4d c4	 movzx	 ecx, WORD PTR _Kh$[ebp]
  004e9	51		 push	 ecx
  004ea	e8 00 00 00 00	 call	 _Mpy_32
  004ef	83 c4 10	 add	 esp, 16			; 00000010H
  004f2	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 266  :           t0 = L_add(t0, L_Comp(Ah[j], Al[j]));

  004f8	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  004fc	0f b7 8c 45 54
	ff ff ff	 movzx	 ecx, WORD PTR _Al$[ebp+eax*2]
  00504	51		 push	 ecx
  00505	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  00509	0f b7 84 55 74
	ff ff ff	 movzx	 eax, WORD PTR _Ah$[ebp+edx*2]
  00511	50		 push	 eax
  00512	e8 00 00 00 00	 call	 _L_Comp
  00517	83 c4 08	 add	 esp, 8
  0051a	50		 push	 eax
  0051b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  00521	51		 push	 ecx
  00522	e8 00 00 00 00	 call	 _L_add
  00527	83 c4 08	 add	 esp, 8
  0052a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 267  :           L_Extract (t0, &Anh[j], &Anl[j]);

  00530	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00534	8d 8c 45 14 ff
	ff ff		 lea	 ecx, DWORD PTR _Anl$[ebp+eax*2]
  0053b	51		 push	 ecx
  0053c	0f bf 55 e8	 movsx	 edx, WORD PTR _j$[ebp]
  00540	8d 84 55 34 ff
	ff ff		 lea	 eax, DWORD PTR _Anh$[ebp+edx*2]
  00547	50		 push	 eax
  00548	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  0054e	51		 push	 ecx
  0054f	e8 00 00 00 00	 call	 _L_Extract
  00554	83 c4 0c	 add	 esp, 12			; 0000000cH

; 268  :        }

  00557	e9 42 ff ff ff	 jmp	 $LN8@Levinson
$LN7@Levinson:

; 269  :        t2 = L_shr (t2, 4);

  0055c	6a 04		 push	 4
  0055e	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _t2$[ebp]
  00564	50		 push	 eax
  00565	e8 00 00 00 00	 call	 _L_shr
  0056a	83 c4 08	 add	 esp, 8
  0056d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _t2$[ebp], eax

; 270  :        L_Extract (t2, &Anh[i], &Anl[i]);

  00573	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00577	8d 8c 45 14 ff
	ff ff		 lea	 ecx, DWORD PTR _Anl$[ebp+eax*2]
  0057e	51		 push	 ecx
  0057f	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00583	8d 84 55 34 ff
	ff ff		 lea	 eax, DWORD PTR _Anh$[ebp+edx*2]
  0058a	50		 push	 eax
  0058b	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _t2$[ebp]
  00591	51		 push	 ecx
  00592	e8 00 00 00 00	 call	 _L_Extract
  00597	83 c4 0c	 add	 esp, 12			; 0000000cH

; 271  :        
; 272  :        /*  Alpha = Alpha * (1-K**2) */
; 273  :        
; 274  :        t0 = Mpy_32 (Kh, Kl, Kh, Kl);           /* K*K             */

  0059a	0f b7 45 b8	 movzx	 eax, WORD PTR _Kl$[ebp]
  0059e	50		 push	 eax
  0059f	0f b7 4d c4	 movzx	 ecx, WORD PTR _Kh$[ebp]
  005a3	51		 push	 ecx
  005a4	0f b7 55 b8	 movzx	 edx, WORD PTR _Kl$[ebp]
  005a8	52		 push	 edx
  005a9	0f b7 45 c4	 movzx	 eax, WORD PTR _Kh$[ebp]
  005ad	50		 push	 eax
  005ae	e8 00 00 00 00	 call	 _Mpy_32
  005b3	83 c4 10	 add	 esp, 16			; 00000010H
  005b6	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 275  :        t0 = L_abs (t0);                        /* Some case <0 !! */

  005bc	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  005c2	50		 push	 eax
  005c3	e8 00 00 00 00	 call	 _L_abs
  005c8	83 c4 04	 add	 esp, 4
  005cb	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 276  :        t0 = L_sub ((Word32) 0x7fffffffL, t0);  /* 1 - K*K        */

  005d1	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  005d7	50		 push	 eax
  005d8	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  005dd	e8 00 00 00 00	 call	 _L_sub
  005e2	83 c4 08	 add	 esp, 8
  005e5	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 277  :        L_Extract (t0, &hi, &lo);               /* DPF format      */

  005eb	8d 45 d0	 lea	 eax, DWORD PTR _lo$[ebp]
  005ee	50		 push	 eax
  005ef	8d 4d dc	 lea	 ecx, DWORD PTR _hi$[ebp]
  005f2	51		 push	 ecx
  005f3	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _t0$[ebp]
  005f9	52		 push	 edx
  005fa	e8 00 00 00 00	 call	 _L_Extract
  005ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 278  :        t0 = Mpy_32 (alp_h, alp_l, hi, lo);

  00602	0f b7 45 d0	 movzx	 eax, WORD PTR _lo$[ebp]
  00606	50		 push	 eax
  00607	0f b7 4d dc	 movzx	 ecx, WORD PTR _hi$[ebp]
  0060b	51		 push	 ecx
  0060c	0f b7 55 a0	 movzx	 edx, WORD PTR _alp_l$[ebp]
  00610	52		 push	 edx
  00611	0f b7 45 ac	 movzx	 eax, WORD PTR _alp_h$[ebp]
  00615	50		 push	 eax
  00616	e8 00 00 00 00	 call	 _Mpy_32
  0061b	83 c4 10	 add	 esp, 16			; 00000010H
  0061e	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 279  :        
; 280  :        /* Normalize Alpha */
; 281  :        
; 282  :        j = norm_l (t0);

  00624	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  0062a	50		 push	 eax
  0062b	e8 00 00 00 00	 call	 _norm_l
  00630	83 c4 04	 add	 esp, 4
  00633	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 283  :        t0 = L_shl (t0, j);

  00637	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  0063b	50		 push	 eax
  0063c	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _t0$[ebp]
  00642	51		 push	 ecx
  00643	e8 00 00 00 00	 call	 _L_shl
  00648	83 c4 08	 add	 esp, 8
  0064b	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 284  :        L_Extract (t0, &alp_h, &alp_l);         /* DPF format    */

  00651	8d 45 a0	 lea	 eax, DWORD PTR _alp_l$[ebp]
  00654	50		 push	 eax
  00655	8d 4d ac	 lea	 ecx, DWORD PTR _alp_h$[ebp]
  00658	51		 push	 ecx
  00659	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _t0$[ebp]
  0065f	52		 push	 edx
  00660	e8 00 00 00 00	 call	 _L_Extract
  00665	83 c4 0c	 add	 esp, 12			; 0000000cH

; 285  :        alp_exp = add (alp_exp, j);             /* Add normalization to

  00668	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  0066c	50		 push	 eax
  0066d	0f b7 4d 94	 movzx	 ecx, WORD PTR _alp_exp$[ebp]
  00671	51		 push	 ecx
  00672	e8 00 00 00 00	 call	 _add
  00677	83 c4 08	 add	 esp, 8
  0067a	66 89 45 94	 mov	 WORD PTR _alp_exp$[ebp], ax

; 286  :                                                   alp_exp */
; 287  :        
; 288  :        /* A[j] = An[j] */
; 289  :        
; 290  :        for (j = 1; j <= i; j++)

  0067e	b8 01 00 00 00	 mov	 eax, 1
  00683	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00687	eb 0c		 jmp	 SHORT $LN6@Levinson
$LN5@Levinson:
  00689	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  0068d	66 83 c0 01	 add	 ax, 1
  00691	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN6@Levinson:
  00695	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00699	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0069d	3b c1		 cmp	 eax, ecx
  0069f	7f 3c		 jg	 SHORT $LN4@Levinson

; 291  :        {
; 292  :           Ah[j] = Anh[j];                     move16 (); 

  006a1	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  006a5	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  006a9	66 8b 94 45 34
	ff ff ff	 mov	 dx, WORD PTR _Anh$[ebp+eax*2]
  006b1	66 89 94 4d 74
	ff ff ff	 mov	 WORD PTR _Ah$[ebp+ecx*2], dx
  006b9	e8 00 00 00 00	 call	 _move16

; 293  :           Al[j] = Anl[j];                     move16 (); 

  006be	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  006c2	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  006c6	66 8b 94 45 14
	ff ff ff	 mov	 dx, WORD PTR _Anl$[ebp+eax*2]
  006ce	66 89 94 4d 54
	ff ff ff	 mov	 WORD PTR _Al$[ebp+ecx*2], dx
  006d6	e8 00 00 00 00	 call	 _move16

; 294  :        }

  006db	eb ac		 jmp	 SHORT $LN5@Levinson
$LN4@Levinson:

; 295  :     }

  006dd	e9 50 fb ff ff	 jmp	 $LN23@Levinson
$LN22@Levinson:

; 296  :     
; 297  :     A[0] = 4096;                                move16 (); 

  006e2	b8 02 00 00 00	 mov	 eax, 2
  006e7	6b c8 00	 imul	 ecx, eax, 0
  006ea	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  006ef	8b 45 14	 mov	 eax, DWORD PTR _A$[ebp]
  006f2	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx
  006f6	e8 00 00 00 00	 call	 _move16

; 298  :     for (i = 1; i <= M; i++)

  006fb	b8 01 00 00 00	 mov	 eax, 1
  00700	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00704	eb 0c		 jmp	 SHORT $LN3@Levinson
$LN2@Levinson:
  00706	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0070a	66 83 c0 01	 add	 ax, 1
  0070e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@Levinson:
  00712	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00716	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00719	7f 7c		 jg	 SHORT $LN1@Levinson

; 299  :     {
; 300  :        t0 = L_Comp (Ah[i], Al[i]);

  0071b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0071f	0f b7 8c 45 54
	ff ff ff	 movzx	 ecx, WORD PTR _Al$[ebp+eax*2]
  00727	51		 push	 ecx
  00728	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  0072c	0f b7 84 55 74
	ff ff ff	 movzx	 eax, WORD PTR _Ah$[ebp+edx*2]
  00734	50		 push	 eax
  00735	e8 00 00 00 00	 call	 _L_Comp
  0073a	83 c4 08	 add	 esp, 8
  0073d	89 85 08 ff ff
	ff		 mov	 DWORD PTR _t0$[ebp], eax

; 301  :        st->old_A[i] = A[i] = round (L_shl (t0, 1));move16 (); move16 (); 

  00743	6a 01		 push	 1
  00745	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _t0$[ebp]
  0074b	50		 push	 eax
  0074c	e8 00 00 00 00	 call	 _L_shl
  00751	83 c4 08	 add	 esp, 8
  00754	50		 push	 eax
  00755	e8 00 00 00 00	 call	 _round
  0075a	83 c4 04	 add	 esp, 4
  0075d	66 89 85 2a fe
	ff ff		 mov	 WORD PTR tv376[ebp], ax
  00764	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00768	8b 55 14	 mov	 edx, DWORD PTR _A$[ebp]
  0076b	66 8b 85 2a fe
	ff ff		 mov	 ax, WORD PTR tv376[ebp]
  00772	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00776	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0077a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0077d	66 8b 85 2a fe
	ff ff		 mov	 ax, WORD PTR tv376[ebp]
  00784	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00788	e8 00 00 00 00	 call	 _move16
  0078d	e8 00 00 00 00	 call	 _move16

; 302  :     }

  00792	e9 6f ff ff ff	 jmp	 $LN2@Levinson
$LN1@Levinson:

; 303  :     
; 304  :     return 0;

  00797	33 c0		 xor	 eax, eax
$LN26@Levinson:

; 305  : }

  00799	52		 push	 edx
  0079a	8b cd		 mov	 ecx, ebp
  0079c	50		 push	 eax
  0079d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN39@Levinson
  007a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  007a8	58		 pop	 eax
  007a9	5a		 pop	 edx
  007aa	5f		 pop	 edi
  007ab	5e		 pop	 esi
  007ac	5b		 pop	 ebx
  007ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b0	33 cd		 xor	 ecx, ebp
  007b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b7	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  007bd	3b ec		 cmp	 ebp, esp
  007bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007c4	8b e5		 mov	 esp, ebp
  007c6	5d		 pop	 ebp
  007c7	c3		 ret	 0
$LN39@Levinson:
  007c8	0a 00 00 00	 DD	 10			; 0000000aH
  007cc	00 00 00 00	 DD	 $LN38@Levinson
$LN38@Levinson:
  007d0	dc ff ff ff	 DD	 -36			; ffffffdcH
  007d4	02 00 00 00	 DD	 2
  007d8	00 00 00 00	 DD	 $LN28@Levinson
  007dc	d0 ff ff ff	 DD	 -48			; ffffffd0H
  007e0	02 00 00 00	 DD	 2
  007e4	00 00 00 00	 DD	 $LN29@Levinson
  007e8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  007ec	02 00 00 00	 DD	 2
  007f0	00 00 00 00	 DD	 $LN30@Levinson
  007f4	b8 ff ff ff	 DD	 -72			; ffffffb8H
  007f8	02 00 00 00	 DD	 2
  007fc	00 00 00 00	 DD	 $LN31@Levinson
  00800	ac ff ff ff	 DD	 -84			; ffffffacH
  00804	02 00 00 00	 DD	 2
  00808	00 00 00 00	 DD	 $LN32@Levinson
  0080c	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00810	02 00 00 00	 DD	 2
  00814	00 00 00 00	 DD	 $LN33@Levinson
  00818	74 ff ff ff	 DD	 -140			; ffffff74H
  0081c	16 00 00 00	 DD	 22			; 00000016H
  00820	00 00 00 00	 DD	 $LN34@Levinson
  00824	54 ff ff ff	 DD	 -172			; ffffff54H
  00828	16 00 00 00	 DD	 22			; 00000016H
  0082c	00 00 00 00	 DD	 $LN35@Levinson
  00830	34 ff ff ff	 DD	 -204			; ffffff34H
  00834	16 00 00 00	 DD	 22			; 00000016H
  00838	00 00 00 00	 DD	 $LN36@Levinson
  0083c	14 ff ff ff	 DD	 -236			; ffffff14H
  00840	16 00 00 00	 DD	 22			; 00000016H
  00844	00 00 00 00	 DD	 $LN37@Levinson
$LN37@Levinson:
  00848	41		 DB	 65			; 00000041H
  00849	6e		 DB	 110			; 0000006eH
  0084a	6c		 DB	 108			; 0000006cH
  0084b	00		 DB	 0
$LN36@Levinson:
  0084c	41		 DB	 65			; 00000041H
  0084d	6e		 DB	 110			; 0000006eH
  0084e	68		 DB	 104			; 00000068H
  0084f	00		 DB	 0
$LN35@Levinson:
  00850	41		 DB	 65			; 00000041H
  00851	6c		 DB	 108			; 0000006cH
  00852	00		 DB	 0
$LN34@Levinson:
  00853	41		 DB	 65			; 00000041H
  00854	68		 DB	 104			; 00000068H
  00855	00		 DB	 0
$LN33@Levinson:
  00856	61		 DB	 97			; 00000061H
  00857	6c		 DB	 108			; 0000006cH
  00858	70		 DB	 112			; 00000070H
  00859	5f		 DB	 95			; 0000005fH
  0085a	6c		 DB	 108			; 0000006cH
  0085b	00		 DB	 0
$LN32@Levinson:
  0085c	61		 DB	 97			; 00000061H
  0085d	6c		 DB	 108			; 0000006cH
  0085e	70		 DB	 112			; 00000070H
  0085f	5f		 DB	 95			; 0000005fH
  00860	68		 DB	 104			; 00000068H
  00861	00		 DB	 0
$LN31@Levinson:
  00862	4b		 DB	 75			; 0000004bH
  00863	6c		 DB	 108			; 0000006cH
  00864	00		 DB	 0
$LN30@Levinson:
  00865	4b		 DB	 75			; 0000004bH
  00866	68		 DB	 104			; 00000068H
  00867	00		 DB	 0
$LN29@Levinson:
  00868	6c		 DB	 108			; 0000006cH
  00869	6f		 DB	 111			; 0000006fH
  0086a	00		 DB	 0
$LN28@Levinson:
  0086b	68		 DB	 104			; 00000068H
  0086c	69		 DB	 105			; 00000069H
  0086d	00		 DB	 0
_Levinson ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\levinson.c
;	COMDAT _Levinson_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Levinson_exit PROC					; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 117  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Levinson_e
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@Levinson_e
$LN1@Levinson_e:

; 118  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@Levinson_e
$LN2@Levinson_e:

; 119  :  
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 122  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Levinson_e:

; 123  :   
; 124  :   return;
; 125  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Levinson_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\levinson.c
;	COMDAT _Levinson_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_Levinson_reset PROC					; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 94   :   Word16 i;
; 95   :   
; 96   :   if (state == (LevinsonState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@Levinson_r

; 97   :       fprintf(stderr, "Levinson_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@OEEABPNN@Levinson_reset?3?5invalid?5paramete@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 98   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 45		 jmp	 SHORT $LN5@Levinson_r
$LN4@Levinson_r:

; 99   :   }
; 100  :   
; 101  :   state->old_A[0] = 4096;

  00059	b8 02 00 00 00	 mov	 eax, 2
  0005e	6b c8 00	 imul	 ecx, eax, 0
  00061	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00066	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00069	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 102  :   for(i = 1; i < M + 1; i++)

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00076	eb 0c		 jmp	 SHORT $LN3@Levinson_r
$LN2@Levinson_r:
  00078	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0007c	66 83 c0 01	 add	 ax, 1
  00080	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@Levinson_r:
  00084	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00088	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0008b	7d 0f		 jge	 SHORT $LN1@Levinson_r

; 103  :       state->old_A[i] = 0;

  0008d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00091	33 c9		 xor	 ecx, ecx
  00093	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00096	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0009a	eb dc		 jmp	 SHORT $LN2@Levinson_r
$LN1@Levinson_r:

; 104  :  
; 105  :   return 0;

  0009c	33 c0		 xor	 eax, eax
$LN5@Levinson_r:

; 106  : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_Levinson_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\levinson.c
;	COMDAT _Levinson_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Levinson_init PROC					; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 65   :   LevinsonState* s;
; 66   :  
; 67   :   if (state == (LevinsonState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@Levinson_i

; 68   :       fprintf(stderr, "Levinson_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IEHEBOIL@Levinson_init?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@Levinson_i
$LN2@Levinson_i:

; 70   :   }
; 71   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 72   :  
; 73   :   /* allocate memory */
; 74   :   if ((s= (LevinsonState *) malloc(sizeof(LevinsonState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 16		 push	 22			; 00000016H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@Levinson_i

; 75   :       fprintf(stderr, "Levinson_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MDECMGMJ@Levinson_init?3?5can?5not?5malloc?5st@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@Levinson_i
$LN1@Levinson_i:

; 77   :   }
; 78   :   
; 79   :   Levinson_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _Levinson_reset
  000bd	83 c4 04	 add	 esp, 4

; 80   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 81   :   
; 82   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@Levinson_i:

; 83   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_Levinson_init ENDP
_TEXT	ENDS
END
