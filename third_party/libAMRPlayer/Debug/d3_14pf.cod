; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d3_14pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_d3_14pf_c_id
CONST	SEGMENT
_d3_14pf_c_id DB '@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_decode_3i40_14bits
EXTRN	_add:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
;	COMDAT _decode_3i40_14bits
_TEXT	SEGMENT
_pos$ = -40						; size = 6
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_sign$ = 8						; size = 2
_index$ = 12						; size = 2
_cod$ = 16						; size = 4
_decode_3i40_14bits PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 60   :     Word16 i, j;
; 61   :     Word16 pos[NB_PULSE];
; 62   : 
; 63   :     /* Decode the positions */
; 64   : 
; 65   :     i = index & 7;                                       logic16 ();

  00028	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  0002c	83 e0 07	 and	 eax, 7
  0002f	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00033	e8 00 00 00 00	 call	 _logic16

; 66   : 
; 67   :     pos[0] = add(i, shl(i, 2));   /* pos0 =i*5 */        move16 ();

  00038	6a 02		 push	 2
  0003a	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _shl
  00044	83 c4 08	 add	 esp, 8
  00047	0f b7 c8	 movzx	 ecx, ax
  0004a	51		 push	 ecx
  0004b	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _add
  00055	83 c4 08	 add	 esp, 8
  00058	b9 02 00 00 00	 mov	 ecx, 2
  0005d	6b d1 00	 imul	 edx, ecx, 0
  00060	66 89 44 15 d8	 mov	 WORD PTR _pos$[ebp+edx], ax
  00065	e8 00 00 00 00	 call	 _move16

; 68   : 
; 69   :     index = shr(index, 3);

  0006a	6a 03		 push	 3
  0006c	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _shr
  00076	83 c4 08	 add	 esp, 8
  00079	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 70   :     j = index & 1;                                       logic16 ();

  0007d	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  00081	83 e0 01	 and	 eax, 1
  00084	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00088	e8 00 00 00 00	 call	 _logic16

; 71   :     index = shr(index, 1);

  0008d	6a 01		 push	 1
  0008f	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _shr
  00099	83 c4 08	 add	 esp, 8
  0009c	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 72   :     i = index & 7;                                       logic16 ();

  000a0	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  000a4	83 e0 07	 and	 eax, 7
  000a7	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  000ab	e8 00 00 00 00	 call	 _logic16

; 73   : 
; 74   :     i = add(i, shl(i, 2));        /* pos1 =i*5+1+j*2 */

  000b0	6a 02		 push	 2
  000b2	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _shl
  000bc	83 c4 08	 add	 esp, 8
  000bf	0f b7 c8	 movzx	 ecx, ax
  000c2	51		 push	 ecx
  000c3	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _add
  000cd	83 c4 08	 add	 esp, 8
  000d0	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 75   :     i = add(i, 1);

  000d4	6a 01		 push	 1
  000d6	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 _add
  000e0	83 c4 08	 add	 esp, 8
  000e3	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 76   :     j = shl(j, 1);     

  000e7	6a 01		 push	 1
  000e9	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _shl
  000f3	83 c4 08	 add	 esp, 8
  000f6	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 77   :     pos[1] = add(i, j);                                  move16 ();

  000fa	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  000fe	50		 push	 eax
  000ff	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 _add
  00109	83 c4 08	 add	 esp, 8
  0010c	ba 02 00 00 00	 mov	 edx, 2
  00111	c1 e2 00	 shl	 edx, 0
  00114	66 89 44 15 d8	 mov	 WORD PTR _pos$[ebp+edx], ax
  00119	e8 00 00 00 00	 call	 _move16

; 78   : 
; 79   :     index = shr(index, 3);

  0011e	6a 03		 push	 3
  00120	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _shr
  0012a	83 c4 08	 add	 esp, 8
  0012d	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 80   :     j = index & 1;                                       logic16 ();

  00131	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  00135	83 e0 01	 and	 eax, 1
  00138	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  0013c	e8 00 00 00 00	 call	 _logic16

; 81   :     index = shr(index, 1);

  00141	6a 01		 push	 1
  00143	0f b7 45 0c	 movzx	 eax, WORD PTR _index$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _shr
  0014d	83 c4 08	 add	 esp, 8
  00150	66 89 45 0c	 mov	 WORD PTR _index$[ebp], ax

; 82   :     i = index & 7;                                       logic16 ();

  00154	0f bf 45 0c	 movsx	 eax, WORD PTR _index$[ebp]
  00158	83 e0 07	 and	 eax, 7
  0015b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0015f	e8 00 00 00 00	 call	 _logic16

; 83   : 
; 84   :     i = add(i, shl(i, 2));        /* pos2 =i*5+2+j*2 */

  00164	6a 02		 push	 2
  00166	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _shl
  00170	83 c4 08	 add	 esp, 8
  00173	0f b7 c8	 movzx	 ecx, ax
  00176	51		 push	 ecx
  00177	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 _add
  00181	83 c4 08	 add	 esp, 8
  00184	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 85   :     i = add(i, 2); 

  00188	6a 02		 push	 2
  0018a	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _add
  00194	83 c4 08	 add	 esp, 8
  00197	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 86   :     j = shl(j, 1); 

  0019b	6a 01		 push	 1
  0019d	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _shl
  001a7	83 c4 08	 add	 esp, 8
  001aa	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 87   :     pos[2] = add(i, j);                                  move16 ();

  001ae	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  001b2	50		 push	 eax
  001b3	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 _add
  001bd	83 c4 08	 add	 esp, 8
  001c0	ba 02 00 00 00	 mov	 edx, 2
  001c5	d1 e2		 shl	 edx, 1
  001c7	66 89 44 15 d8	 mov	 WORD PTR _pos$[ebp+edx], ax
  001cc	e8 00 00 00 00	 call	 _move16

; 88   : 
; 89   :     /* decode the signs  and build the codeword */
; 90   : 
; 91   :     for (i = 0; i < L_SUBFR; i++) {

  001d1	33 c0		 xor	 eax, eax
  001d3	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  001d7	eb 0c		 jmp	 SHORT $LN8@decode_3i4
$LN7@decode_3i4:
  001d9	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  001dd	66 83 c0 01	 add	 ax, 1
  001e1	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN8@decode_3i4:
  001e5	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001e9	83 f8 28	 cmp	 eax, 40			; 00000028H
  001ec	7d 14		 jge	 SHORT $LN6@decode_3i4

; 92   :         cod[i] = 0;                                      move16 ();

  001ee	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001f2	33 c9		 xor	 ecx, ecx
  001f4	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  001f7	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001fb	e8 00 00 00 00	 call	 _move16

; 93   :     }

  00200	eb d7		 jmp	 SHORT $LN7@decode_3i4
$LN6@decode_3i4:

; 94   : 
; 95   :     for (j = 0; j < NB_PULSE; j++) {

  00202	33 c0		 xor	 eax, eax
  00204	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00208	eb 0c		 jmp	 SHORT $LN5@decode_3i4
$LN4@decode_3i4:
  0020a	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  0020e	66 83 c0 01	 add	 ax, 1
  00212	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN5@decode_3i4:
  00216	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0021a	83 f8 03	 cmp	 eax, 3
  0021d	7d 68		 jge	 SHORT $LN9@decode_3i4

; 96   :         i = sign & 1;                                    logic16 ();

  0021f	0f bf 45 08	 movsx	 eax, WORD PTR _sign$[ebp]
  00223	83 e0 01	 and	 eax, 1
  00226	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0022a	e8 00 00 00 00	 call	 _logic16

; 97   :         sign = shr(sign, 1);

  0022f	6a 01		 push	 1
  00231	0f b7 45 08	 movzx	 eax, WORD PTR _sign$[ebp]
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 _shr
  0023b	83 c4 08	 add	 esp, 8
  0023e	66 89 45 08	 mov	 WORD PTR _sign$[ebp], ax

; 98   : 
; 99   :         test ();

  00242	e8 00 00 00 00	 call	 _test

; 100  :         if (i > 0) {

  00247	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0024b	85 c0		 test	 eax, eax
  0024d	7e 1c		 jle	 SHORT $LN2@decode_3i4

; 101  :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  0024f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00253	0f bf 4c 45 d8	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  00258	ba ff 1f 00 00	 mov	 edx, 8191		; 00001fffH
  0025d	8b 45 10	 mov	 eax, DWORD PTR _cod$[ebp]
  00260	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00264	e8 00 00 00 00	 call	 _move16

; 102  :         } else {

  00269	eb 1a		 jmp	 SHORT $LN1@decode_3i4
$LN2@decode_3i4:

; 103  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  0026b	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0026f	0f bf 4c 45 d8	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  00274	ba 00 e0 ff ff	 mov	 edx, -8192		; ffffe000H
  00279	8b 45 10	 mov	 eax, DWORD PTR _cod$[ebp]
  0027c	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00280	e8 00 00 00 00	 call	 _move16
$LN1@decode_3i4:

; 104  :         }
; 105  :     }

  00285	eb 83		 jmp	 SHORT $LN4@decode_3i4
$LN9@decode_3i4:

; 106  : 
; 107  :     return;
; 108  : }

  00287	52		 push	 edx
  00288	8b cd		 mov	 ecx, ebp
  0028a	50		 push	 eax
  0028b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@decode_3i4
  00291	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00296	58		 pop	 eax
  00297	5a		 pop	 edx
  00298	5f		 pop	 edi
  00299	5e		 pop	 esi
  0029a	5b		 pop	 ebx
  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	33 cd		 xor	 ecx, ebp
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  002ab	3b ec		 cmp	 ebp, esp
  002ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
  002b6	8b ff		 npad	 2
$LN13@decode_3i4:
  002b8	01 00 00 00	 DD	 1
  002bc	00 00 00 00	 DD	 $LN12@decode_3i4
$LN12@decode_3i4:
  002c0	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002c4	06 00 00 00	 DD	 6
  002c8	00 00 00 00	 DD	 $LN11@decode_3i4
$LN11@decode_3i4:
  002cc	70		 DB	 112			; 00000070H
  002cd	6f		 DB	 111			; 0000006fH
  002ce	73		 DB	 115			; 00000073H
  002cf	00		 DB	 0
_decode_3i40_14bits ENDP
_TEXT	ENDS
END
