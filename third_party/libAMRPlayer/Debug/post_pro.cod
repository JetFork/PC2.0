; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\post_pro.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_post_pro_id
CONST	SEGMENT
_post_pro_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_b	DW	01e13H
	DW	0c3daH
	DW	01e13H
	ORG $+2
_a	DW	02000H
	DW	03ddcH
	DW	0e20dH
CONST	ENDS
PUBLIC	_Post_Process_init
PUBLIC	_Post_Process_reset
PUBLIC	_Post_Process_exit
PUBLIC	_Post_Process
PUBLIC	??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@ ; `string'
PUBLIC	??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_Extract:PROC
EXTRN	_Mpy_32_16:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@ DB 'Post_Process_'
	DB	'reset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@
CONST	SEGMENT
??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@ DB 'Post_Process'
	DB	'_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@ DB 'Post_Process_'
	DB	'init: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process
_TEXT	SEGMENT
_L_tmp$ = -32						; size = 4
_x2$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_signal$ = 12						; size = 4
_lg$ = 16						; size = 2
_Post_Process PROC					; COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 150  :     Word16 i, x2;
; 151  :     Word32 L_tmp;
; 152  : 
; 153  :     test (); test ();

  0001e	e8 00 00 00 00	 call	 _test
  00023	e8 00 00 00 00	 call	 _test

; 154  :     for (i = 0; i < lg; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN3@Post_Proce
$LN2@Post_Proce:
  00030	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@Post_Proce:
  0003c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00040	0f bf 4d 10	 movsx	 ecx, WORD PTR _lg$[ebp]
  00044	3b c1		 cmp	 eax, ecx
  00046	0f 8d 88 01 00
	00		 jge	 $LN1@Post_Proce

; 155  :     {
; 156  :         x2 = st->x1;                             move16 (); 

  0004c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0004f	66 8b 48 0a	 mov	 cx, WORD PTR [eax+10]
  00053	66 89 4d ec	 mov	 WORD PTR _x2$[ebp], cx
  00057	e8 00 00 00 00	 call	 _move16

; 157  :         st->x1 = st->x0;                         move16 (); 

  0005c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00062	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  00066	66 89 50 0a	 mov	 WORD PTR [eax+10], dx
  0006a	e8 00 00 00 00	 call	 _move16

; 158  :         st->x0 = signal[i];                      move16 (); 

  0006f	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00076	8b 55 0c	 mov	 edx, DWORD PTR _signal$[ebp]
  00079	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  0007d	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00081	e8 00 00 00 00	 call	 _move16

; 159  :         
; 160  :         /*  y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2  */
; 161  :         /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */
; 162  :         
; 163  :         L_tmp = Mpy_32_16 (st->y1_hi, st->y1_lo, a[1]);

  00086	b8 02 00 00 00	 mov	 eax, 2
  0008b	c1 e0 00	 shl	 eax, 0
  0008e	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _a[eax]
  00095	51		 push	 ecx
  00096	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00099	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  0009d	50		 push	 eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a1	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _Mpy_32_16
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 164  :         L_tmp = L_add (L_tmp, Mpy_32_16 (st->y2_hi, st->y2_lo, a[2]));

  000b1	b8 02 00 00 00	 mov	 eax, 2
  000b6	d1 e0		 shl	 eax, 1
  000b8	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _a[eax]
  000bf	51		 push	 ecx
  000c0	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  000c3	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  000c7	50		 push	 eax
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000cb	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _Mpy_32_16
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	50		 push	 eax
  000d8	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _L_add
  000e1	83 c4 08	 add	 esp, 8
  000e4	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 165  :         L_tmp = L_mac (L_tmp, st->x0, b[0]);

  000e7	b8 02 00 00 00	 mov	 eax, 2
  000ec	6b c8 00	 imul	 ecx, eax, 0
  000ef	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR _b[ecx]
  000f6	52		 push	 edx
  000f7	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000fa	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  000fe	51		 push	 ecx
  000ff	8b 55 e0	 mov	 edx, DWORD PTR _L_tmp$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 _L_mac
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 166  :         L_tmp = L_mac (L_tmp, st->x1, b[1]);

  0010e	b8 02 00 00 00	 mov	 eax, 2
  00113	c1 e0 00	 shl	 eax, 0
  00116	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _b[eax]
  0011d	51		 push	 ecx
  0011e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00121	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00125	50		 push	 eax
  00126	8b 4d e0	 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 _L_mac
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00132	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 167  :         L_tmp = L_mac (L_tmp, x2, b[2]);

  00135	b8 02 00 00 00	 mov	 eax, 2
  0013a	d1 e0		 shl	 eax, 1
  0013c	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _b[eax]
  00143	51		 push	 ecx
  00144	0f b7 55 ec	 movzx	 edx, WORD PTR _x2$[ebp]
  00148	52		 push	 edx
  00149	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _L_mac
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 168  :         L_tmp = L_shl (L_tmp, 2);

  00158	6a 02		 push	 2
  0015a	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 _L_shl
  00163	83 c4 08	 add	 esp, 8
  00166	89 45 e0	 mov	 DWORD PTR _L_tmp$[ebp], eax

; 169  :         
; 170  :         /* Multiplication by two of output speech with saturation. */
; 171  :         signal[i] = round(L_shl(L_tmp, 1));   move16 (); 

  00169	6a 01		 push	 1
  0016b	8b 45 e0	 mov	 eax, DWORD PTR _L_tmp$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _L_shl
  00174	83 c4 08	 add	 esp, 8
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _round
  0017d	83 c4 04	 add	 esp, 4
  00180	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00184	8b 55 0c	 mov	 edx, DWORD PTR _signal$[ebp]
  00187	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0018b	e8 00 00 00 00	 call	 _move16

; 172  :         
; 173  :         st->y2_hi = st->y1_hi;                   move16 (); 

  00190	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00196	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0019a	66 89 10	 mov	 WORD PTR [eax], dx
  0019d	e8 00 00 00 00	 call	 _move16

; 174  :         st->y2_lo = st->y1_lo;                   move16 (); 

  001a2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001a5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001a8	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  001ac	66 89 50 02	 mov	 WORD PTR [eax+2], dx
  001b0	e8 00 00 00 00	 call	 _move16

; 175  :         L_Extract (L_tmp, &st->y1_hi, &st->y1_lo);

  001b5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001b8	83 c0 06	 add	 eax, 6
  001bb	50		 push	 eax
  001bc	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001bf	83 c1 04	 add	 ecx, 4
  001c2	51		 push	 ecx
  001c3	8b 55 e0	 mov	 edx, DWORD PTR _L_tmp$[ebp]
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 _L_Extract
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 176  :     }

  001cf	e9 5c fe ff ff	 jmp	 $LN2@Post_Proce
$LN1@Post_Proce:

; 177  : 
; 178  :     return 0;    

  001d4	33 c0		 xor	 eax, eax

; 179  : }

  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001df	3b ec		 cmp	 ebp, esp
  001e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
_Post_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Post_Process_exit PROC					; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 117  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Post_Proce
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@Post_Proce
$LN1@Post_Proce:

; 118  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@Post_Proce
$LN2@Post_Proce:

; 119  :  
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 122  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Post_Proce:

; 123  :   
; 124  :   return;
; 125  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Post_Process_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Post_Process_reset PROC				; COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 93   :   if (state == (Post_ProcessState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@Post_Proce

; 94   :       fprintf(stderr, "Post_Process_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 95   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 37		 jmp	 SHORT $LN2@Post_Proce
$LN1@Post_Proce:

; 96   :   }
; 97   :   
; 98   :   state->y2_hi = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 99   :   state->y2_lo = 0;

  00061	33 c0		 xor	 eax, eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 100  :   state->y1_hi = 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 101  :   state->y1_lo = 0;

  00073	33 c0		 xor	 eax, eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00078	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 102  :   state->x0 = 0;

  0007c	33 c0		 xor	 eax, eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 103  :   state->x1 = 0;

  00085	33 c0		 xor	 eax, eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 104  : 
; 105  :   return 0;

  0008e	33 c0		 xor	 eax, eax
$LN2@Post_Proce:

; 106  : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_Post_Process_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Post_Process_init PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   :   Post_ProcessState* s;
; 65   :  
; 66   :   if (state == (Post_ProcessState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@Post_Proce

; 67   :       fprintf(stderr, "Post_Process_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@Post_Proce
$LN2@Post_Proce:

; 69   :   }
; 70   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 71   :  
; 72   :   /* allocate memory */
; 73   :   if ((s= (Post_ProcessState *) malloc(sizeof(Post_ProcessState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 0c		 push	 12			; 0000000cH
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@Post_Proce

; 74   :       fprintf(stderr, "Post_Process_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 75   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@Post_Proce
$LN1@Post_Proce:

; 76   :   }
; 77   :   
; 78   :   Post_Process_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _Post_Process_reset
  000bd	83 c4 04	 add	 esp, 4

; 79   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 80   :   
; 81   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@Post_Proce:

; 82   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_Post_Process_init ENDP
_TEXT	ENDS
END
