; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c2_11pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c2_11pf_id
CONST	SEGMENT
_c2_11pf_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_startPos1 DW	01H
	DW	03H
_startPos2 DW	00H
	DW	01H
	DW	02H
	DW	04H
CONST	ENDS
PUBLIC	_code_2i40_11bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_cor_h_x:PROC
EXTRN	_cor_h:PROC
EXTRN	_set_sign:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_11pf.c
;	COMDAT _build_code
_TEXT	SEGMENT
tv234 = -326						; size = 2
tv226 = -326						; size = 2
_s$ = -128						; size = 4
_p1$ = -116						; size = 4
_p0$ = -104						; size = 4
_rsign$ = -92						; size = 2
_indx$ = -80						; size = 2
__sign$ = -68						; size = 4
_index$ = -56						; size = 2
_track$ = -44						; size = 2
_k$ = -32						; size = 2
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_codvec$ = 8						; size = 4
_dn_sign$ = 12						; size = 4
_cod$ = 16						; size = 4
_h$ = 20						; size = 4
_y$ = 24						; size = 4
_sign$ = 28						; size = 4
_build_code PROC					; COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 281  :     Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
; 282  :     Word16 *p0, *p1;
; 283  :     Word32 s;
; 284  : 
; 285  :     for (i = 0; i < L_CODE; i++)

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00024	eb 0c		 jmp	 SHORT $LN22@build_code
$LN21@build_code:
  00026	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002a	66 83 c0 01	 add	 ax, 1
  0002e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN22@build_code:
  00032	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00036	83 f8 28	 cmp	 eax, 40			; 00000028H
  00039	7d 14		 jge	 SHORT $LN20@build_code

; 286  :     {
; 287  :         cod[i] = 0;                                      move16 ();

  0003b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0003f	33 c9		 xor	 ecx, ecx
  00041	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00044	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00048	e8 00 00 00 00	 call	 _move16

; 288  :     }

  0004d	eb d7		 jmp	 SHORT $LN21@build_code
$LN20@build_code:

; 289  : 
; 290  :     indx = 0;                                            move16 ();

  0004f	33 c0		 xor	 eax, eax
  00051	66 89 45 b0	 mov	 WORD PTR _indx$[ebp], ax
  00055	e8 00 00 00 00	 call	 _move16

; 291  :     rsign = 0;                                           move16 ();

  0005a	33 c0		 xor	 eax, eax
  0005c	66 89 45 a4	 mov	 WORD PTR _rsign$[ebp], ax
  00060	e8 00 00 00 00	 call	 _move16

; 292  :     for (k = 0; k < NB_PULSE; k++)

  00065	33 c0		 xor	 eax, eax
  00067	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
  0006b	eb 0c		 jmp	 SHORT $LN19@build_code
$LN18@build_code:
  0006d	66 8b 45 e0	 mov	 ax, WORD PTR _k$[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax
$LN19@build_code:
  00079	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  0007d	83 f8 02	 cmp	 eax, 2
  00080	0f 8d bc 02 00
	00		 jge	 $LN17@build_code

; 293  :     {
; 294  :         i = codvec[k];      /* read pulse position */    move16 ();

  00086	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0008d	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00091	66 89 55 f8	 mov	 WORD PTR _i$[ebp], dx
  00095	e8 00 00 00 00	 call	 _move16

; 295  :         j = dn_sign[i];     /* read sign           */    move16 ();

  0009a	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _dn_sign$[ebp]
  000a1	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000a5	66 89 55 ec	 mov	 WORD PTR _j$[ebp], dx
  000a9	e8 00 00 00 00	 call	 _move16

; 296  : 
; 297  :         index = mult(i, 6554);    /* index = pos/5 */

  000ae	68 9a 19 00 00	 push	 6554			; 0000199aH
  000b3	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _mult
  000bd	83 c4 08	 add	 esp, 8
  000c0	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax

; 298  :                                   /* track = pos%5 */
; 299  :         track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));

  000c4	6a 01		 push	 1
  000c6	6a 05		 push	 5
  000c8	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _L_mult
  000d2	83 c4 08	 add	 esp, 8
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _L_shr
  000db	83 c4 08	 add	 esp, 8
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _extract_l
  000e4	83 c4 04	 add	 esp, 4
  000e7	0f b7 c8	 movzx	 ecx, ax
  000ea	51		 push	 ecx
  000eb	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _sub
  000f5	83 c4 08	 add	 esp, 8
  000f8	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax

; 300  :         
; 301  :         test (); test (); test (); test ();

  000fc	e8 00 00 00 00	 call	 _test
  00101	e8 00 00 00 00	 call	 _test
  00106	e8 00 00 00 00	 call	 _test
  0010b	e8 00 00 00 00	 call	 _test

; 302  :         if (sub(track, 0) == 0)

  00110	6a 00		 push	 0
  00112	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _sub
  0011c	83 c4 08	 add	 esp, 8
  0011f	0f bf c8	 movsx	 ecx, ax
  00122	85 c9		 test	 ecx, ecx
  00124	75 26		 jne	 SHORT $LN16@build_code

; 303  :         {                       
; 304  :            track = 1;                                    move16 ();                

  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  0012f	e8 00 00 00 00	 call	 _move16

; 305  :            index = shl(index, 6);           

  00134	6a 06		 push	 6
  00136	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _shl
  00140	83 c4 08	 add	 esp, 8
  00143	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax
  00147	e9 58 01 00 00	 jmp	 $LN15@build_code
$LN16@build_code:

; 306  :         }
; 307  :         else if (sub(track, 1) == 0)

  0014c	6a 01		 push	 1
  0014e	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _sub
  00158	83 c4 08	 add	 esp, 8
  0015b	0f bf c8	 movsx	 ecx, ax
  0015e	85 c9		 test	 ecx, ecx
  00160	75 6f		 jne	 SHORT $LN14@build_code

; 308  :         {
; 309  :            test ();            

  00162	e8 00 00 00 00	 call	 _test

; 310  :            if (sub(k, 0) == 0)

  00167	6a 00		 push	 0
  00169	0f b7 45 e0	 movzx	 eax, WORD PTR _k$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _sub
  00173	83 c4 08	 add	 esp, 8
  00176	0f bf c8	 movsx	 ecx, ax
  00179	85 c9		 test	 ecx, ecx
  0017b	75 20		 jne	 SHORT $LN13@build_code

; 311  :            {                      
; 312  :               track = 0;                                 move16 ();     

  0017d	33 c0		 xor	 eax, eax
  0017f	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  00183	e8 00 00 00 00	 call	 _move16

; 313  :               index = shl(index, 1);

  00188	6a 01		 push	 1
  0018a	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _shl
  00194	83 c4 08	 add	 esp, 8
  00197	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax

; 314  :            }
; 315  :            else

  0019b	eb 2f		 jmp	 SHORT $LN12@build_code
$LN13@build_code:

; 316  :            {
; 317  :               track = 1;                                 move16 ();

  0019d	b8 01 00 00 00	 mov	 eax, 1
  001a2	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  001a6	e8 00 00 00 00	 call	 _move16

; 318  :               index = add(shl(index, 6), 16);              

  001ab	6a 10		 push	 16			; 00000010H
  001ad	6a 06		 push	 6
  001af	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _shl
  001b9	83 c4 08	 add	 esp, 8
  001bc	0f b7 c8	 movzx	 ecx, ax
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 _add
  001c5	83 c4 08	 add	 esp, 8
  001c8	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax
$LN12@build_code:

; 319  :            }

  001cc	e9 d3 00 00 00	 jmp	 $LN15@build_code
$LN14@build_code:

; 320  :         }
; 321  :         else if (sub(track, 2) == 0)

  001d1	6a 02		 push	 2
  001d3	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _sub
  001dd	83 c4 08	 add	 esp, 8
  001e0	0f bf c8	 movsx	 ecx, ax
  001e3	85 c9		 test	 ecx, ecx
  001e5	75 34		 jne	 SHORT $LN10@build_code

; 322  :         {      
; 323  :            track = 1;                                    move16 ();

  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  001f0	e8 00 00 00 00	 call	 _move16

; 324  :            index = add(shl(index, 6), 32);           

  001f5	6a 20		 push	 32			; 00000020H
  001f7	6a 06		 push	 6
  001f9	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 _shl
  00203	83 c4 08	 add	 esp, 8
  00206	0f b7 c8	 movzx	 ecx, ax
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _add
  0020f	83 c4 08	 add	 esp, 8
  00212	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax
  00216	e9 89 00 00 00	 jmp	 $LN15@build_code
$LN10@build_code:

; 325  :         }
; 326  :         else if (sub(track, 3) == 0)

  0021b	6a 03		 push	 3
  0021d	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 _sub
  00227	83 c4 08	 add	 esp, 8
  0022a	0f bf c8	 movsx	 ecx, ax
  0022d	85 c9		 test	 ecx, ecx
  0022f	75 2e		 jne	 SHORT $LN8@build_code

; 327  :         {
; 328  :            track = 0;                                    move16 ();     

  00231	33 c0		 xor	 eax, eax
  00233	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  00237	e8 00 00 00 00	 call	 _move16

; 329  :            index = add(shl(index, 1), 1);           

  0023c	6a 01		 push	 1
  0023e	6a 01		 push	 1
  00240	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _shl
  0024a	83 c4 08	 add	 esp, 8
  0024d	0f b7 c8	 movzx	 ecx, ax
  00250	51		 push	 ecx
  00251	e8 00 00 00 00	 call	 _add
  00256	83 c4 08	 add	 esp, 8
  00259	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax
  0025d	eb 45		 jmp	 SHORT $LN15@build_code
$LN8@build_code:

; 330  :         }
; 331  :         else if (sub(track, 4) == 0)

  0025f	6a 04		 push	 4
  00261	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _sub
  0026b	83 c4 08	 add	 esp, 8
  0026e	0f bf c8	 movsx	 ecx, ax
  00271	85 c9		 test	 ecx, ecx
  00273	75 2f		 jne	 SHORT $LN15@build_code

; 332  :         {      
; 333  :            track = 1;                                    move16 ();

  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	66 89 45 d4	 mov	 WORD PTR _track$[ebp], ax
  0027e	e8 00 00 00 00	 call	 _move16

; 334  :            index = add(shl(index, 6), 48);

  00283	6a 30		 push	 48			; 00000030H
  00285	6a 06		 push	 6
  00287	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 _shl
  00291	83 c4 08	 add	 esp, 8
  00294	0f b7 c8	 movzx	 ecx, ax
  00297	51		 push	 ecx
  00298	e8 00 00 00 00	 call	 _add
  0029d	83 c4 08	 add	 esp, 8
  002a0	66 89 45 c8	 mov	 WORD PTR _index$[ebp], ax
$LN15@build_code:

; 335  :         }
; 336  : 
; 337  :         test ();

  002a4	e8 00 00 00 00	 call	 _test

; 338  :         if (j > 0)

  002a9	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  002ad	85 c0		 test	 eax, eax
  002af	7e 4e		 jle	 SHORT $LN5@build_code

; 339  :         {
; 340  :            cod[i] = 8191;                                move16 ();

  002b1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  002b5	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  002ba	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  002bd	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  002c1	e8 00 00 00 00	 call	 _move16

; 341  :            _sign[k] = 32767;                             move16 ();

  002c6	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  002ca	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  002cf	66 89 4c 45 bc	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  002d4	e8 00 00 00 00	 call	 _move16

; 342  :            rsign = add(rsign, shl(1, track));

  002d9	0f b7 45 d4	 movzx	 eax, WORD PTR _track$[ebp]
  002dd	50		 push	 eax
  002de	6a 01		 push	 1
  002e0	e8 00 00 00 00	 call	 _shl
  002e5	83 c4 08	 add	 esp, 8
  002e8	0f b7 c8	 movzx	 ecx, ax
  002eb	51		 push	 ecx
  002ec	0f b7 55 a4	 movzx	 edx, WORD PTR _rsign$[ebp]
  002f0	52		 push	 edx
  002f1	e8 00 00 00 00	 call	 _add
  002f6	83 c4 08	 add	 esp, 8
  002f9	66 89 45 a4	 mov	 WORD PTR _rsign$[ebp], ax

; 343  :         }
; 344  :         else

  002fd	eb 28		 jmp	 SHORT $LN4@build_code
$LN5@build_code:

; 345  :         {
; 346  :            cod[i] = -8192;                               move16 ();

  002ff	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00303	b9 00 e0 ff ff	 mov	 ecx, -8192		; ffffe000H
  00308	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  0030b	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0030f	e8 00 00 00 00	 call	 _move16

; 347  :            _sign[k] = (Word16) - 32768L;                 move16 ();

  00314	0f bf 45 e0	 movsx	 eax, WORD PTR _k$[ebp]
  00318	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  0031d	66 89 4c 45 bc	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  00322	e8 00 00 00 00	 call	 _move16
$LN4@build_code:

; 348  :         }
; 349  :         
; 350  :         indx = add(indx, index);

  00327	0f b7 45 c8	 movzx	 eax, WORD PTR _index$[ebp]
  0032b	50		 push	 eax
  0032c	0f b7 4d b0	 movzx	 ecx, WORD PTR _indx$[ebp]
  00330	51		 push	 ecx
  00331	e8 00 00 00 00	 call	 _add
  00336	83 c4 08	 add	 esp, 8
  00339	66 89 45 b0	 mov	 WORD PTR _indx$[ebp], ax

; 351  :     }

  0033d	e9 2b fd ff ff	 jmp	 $LN18@build_code
$LN17@build_code:

; 352  :     *sign = rsign;                                       move16 ();

  00342	8b 45 1c	 mov	 eax, DWORD PTR _sign$[ebp]
  00345	66 8b 4d a4	 mov	 cx, WORD PTR _rsign$[ebp]
  00349	66 89 08	 mov	 WORD PTR [eax], cx
  0034c	e8 00 00 00 00	 call	 _move16

; 353  :     
; 354  :     p0 = h - codvec[0];                                  move16 ();

  00351	b8 02 00 00 00	 mov	 eax, 2
  00356	6b c8 00	 imul	 ecx, eax, 0
  00359	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  0035c	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00360	d1 e0		 shl	 eax, 1
  00362	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  00365	2b c8		 sub	 ecx, eax
  00367	89 4d 98	 mov	 DWORD PTR _p0$[ebp], ecx
  0036a	e8 00 00 00 00	 call	 _move16

; 355  :     p1 = h - codvec[1];                                  move16 ();

  0036f	b8 02 00 00 00	 mov	 eax, 2
  00374	c1 e0 00	 shl	 eax, 0
  00377	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0037a	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0037e	d1 e2		 shl	 edx, 1
  00380	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00383	2b c2		 sub	 eax, edx
  00385	89 45 8c	 mov	 DWORD PTR _p1$[ebp], eax
  00388	e8 00 00 00 00	 call	 _move16

; 356  : 
; 357  :     for (i = 0; i < L_CODE; i++)

  0038d	33 c0		 xor	 eax, eax
  0038f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00393	eb 0c		 jmp	 SHORT $LN3@build_code
$LN2@build_code:
  00395	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00399	66 83 c0 01	 add	 ax, 1
  0039d	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@build_code:
  003a1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  003a5	83 f8 28	 cmp	 eax, 40			; 00000028H
  003a8	0f 8d a3 00 00
	00		 jge	 $LN1@build_code

; 358  :     {
; 359  :         s = 0;                                           move32 ();

  003ae	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  003b5	e8 00 00 00 00	 call	 _move32

; 360  :         s = L_mac(s, *p0++, _sign[0]);

  003ba	8b 45 98	 mov	 eax, DWORD PTR _p0$[ebp]
  003bd	66 8b 08	 mov	 cx, WORD PTR [eax]
  003c0	66 89 8d ba fe
	ff ff		 mov	 WORD PTR tv226[ebp], cx
  003c7	8b 55 98	 mov	 edx, DWORD PTR _p0$[ebp]
  003ca	83 c2 02	 add	 edx, 2
  003cd	89 55 98	 mov	 DWORD PTR _p0$[ebp], edx
  003d0	b8 02 00 00 00	 mov	 eax, 2
  003d5	6b c8 00	 imul	 ecx, eax, 0
  003d8	0f b7 54 0d bc	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  003dd	52		 push	 edx
  003de	0f b7 85 ba fe
	ff ff		 movzx	 eax, WORD PTR tv226[ebp]
  003e5	50		 push	 eax
  003e6	8b 4d 80	 mov	 ecx, DWORD PTR _s$[ebp]
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 _L_mac
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f2	89 45 80	 mov	 DWORD PTR _s$[ebp], eax

; 361  :         s = L_mac(s, *p1++, _sign[1]);

  003f5	8b 45 8c	 mov	 eax, DWORD PTR _p1$[ebp]
  003f8	66 8b 08	 mov	 cx, WORD PTR [eax]
  003fb	66 89 8d ba fe
	ff ff		 mov	 WORD PTR tv234[ebp], cx
  00402	8b 55 8c	 mov	 edx, DWORD PTR _p1$[ebp]
  00405	83 c2 02	 add	 edx, 2
  00408	89 55 8c	 mov	 DWORD PTR _p1$[ebp], edx
  0040b	b8 02 00 00 00	 mov	 eax, 2
  00410	c1 e0 00	 shl	 eax, 0
  00413	0f b7 4c 05 bc	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00418	51		 push	 ecx
  00419	0f b7 95 ba fe
	ff ff		 movzx	 edx, WORD PTR tv234[ebp]
  00420	52		 push	 edx
  00421	8b 45 80	 mov	 eax, DWORD PTR _s$[ebp]
  00424	50		 push	 eax
  00425	e8 00 00 00 00	 call	 _L_mac
  0042a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042d	89 45 80	 mov	 DWORD PTR _s$[ebp], eax

; 362  :         y[i] = round(s);                                 move16 ();

  00430	8b 45 80	 mov	 eax, DWORD PTR _s$[ebp]
  00433	50		 push	 eax
  00434	e8 00 00 00 00	 call	 _round
  00439	83 c4 04	 add	 esp, 4
  0043c	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00440	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  00443	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00447	e8 00 00 00 00	 call	 _move16

; 363  :     }

  0044c	e9 44 ff ff ff	 jmp	 $LN2@build_code
$LN1@build_code:

; 364  : 
; 365  :     return indx;

  00451	66 8b 45 b0	 mov	 ax, WORD PTR _indx$[ebp]

; 366  : }

  00455	52		 push	 edx
  00456	8b cd		 mov	 ecx, ebp
  00458	50		 push	 eax
  00459	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@build_code
  0045f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00464	58		 pop	 eax
  00465	5a		 pop	 edx
  00466	5f		 pop	 edi
  00467	5e		 pop	 esi
  00468	5b		 pop	 ebx
  00469	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  0046f	3b ec		 cmp	 ebp, esp
  00471	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00476	8b e5		 mov	 esp, ebp
  00478	5d		 pop	 ebp
  00479	c3		 ret	 0
  0047a	8b ff		 npad	 2
$LN27@build_code:
  0047c	01 00 00 00	 DD	 1
  00480	00 00 00 00	 DD	 $LN26@build_code
$LN26@build_code:
  00484	bc ff ff ff	 DD	 -68			; ffffffbcH
  00488	04 00 00 00	 DD	 4
  0048c	00 00 00 00	 DD	 $LN25@build_code
$LN25@build_code:
  00490	5f		 DB	 95			; 0000005fH
  00491	73		 DB	 115			; 00000073H
  00492	69		 DB	 105			; 00000069H
  00493	67		 DB	 103			; 00000067H
  00494	6e		 DB	 110			; 0000006eH
  00495	00		 DB	 0
_build_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_11pf.c
;	COMDAT _search_2i40
_TEXT	SEGMENT
_i$ = -212						; size = 2
_alp1$ = -200						; size = 4
_alp0$ = -188						; size = 4
_s$ = -176						; size = 4
_alp_16$ = -164						; size = 2
_alp$ = -152						; size = 2
_alpk$ = -140						; size = 2
_sq1$ = -128						; size = 2
_sq$ = -116						; size = 2
_ps1$ = -104						; size = 2
_ps0$ = -92						; size = 2
_psk$ = -80						; size = 2
_ipos$ = -68						; size = 4
_track2$ = -56						; size = 2
_track1$ = -44						; size = 2
_ix$ = -32						; size = 2
_i1$ = -20						; size = 2
_i0$ = -8						; size = 2
_dn$ = 8						; size = 4
_rr$ = 12						; size = 4
_codvec$ = 16						; size = 4
_search_2i40 PROC					; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 68 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-408]
  00012	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 166  :     Word16 i0, i1;
; 167  :     Word16 ix = 0; /* initialization only needed to keep gcc silent */

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 e0	 mov	 WORD PTR _ix$[ebp], ax

; 168  :     Word16 track1, track2, ipos[NB_PULSE];
; 169  :     Word16 psk, ps0, ps1, sq, sq1;
; 170  :     Word16 alpk, alp, alp_16;
; 171  :     Word32 s, alp0, alp1;
; 172  :     Word16 i;
; 173  : 
; 174  :     psk = -1;                          move16 ();

  00024	83 c8 ff	 or	 eax, -1
  00027	66 89 45 b0	 mov	 WORD PTR _psk$[ebp], ax
  0002b	e8 00 00 00 00	 call	 _move16

; 175  :     alpk = 1;                          move16 ();

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	66 89 85 74 ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  0003c	e8 00 00 00 00	 call	 _move16

; 176  :     for (i = 0; i < NB_PULSE; i++)

  00041	33 c0		 xor	 eax, eax
  00043	66 89 85 2c ff
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  0004a	eb 12		 jmp	 SHORT $LN17@search_2i4
$LN16@search_2i4:
  0004c	66 8b 85 2c ff
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00053	66 83 c0 01	 add	 ax, 1
  00057	66 89 85 2c ff
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN17@search_2i4:
  0005e	0f bf 85 2c ff
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00065	83 f8 02	 cmp	 eax, 2
  00068	7d 1c		 jge	 SHORT $LN15@search_2i4

; 177  :     {
; 178  :        codvec[i] = i;                  move16 ();

  0006a	0f bf 85 2c ff
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00071	8b 4d 10	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00074	66 8b 95 2c ff
	ff ff		 mov	 dx, WORD PTR _i$[ebp]
  0007b	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0007f	e8 00 00 00 00	 call	 _move16

; 179  :     }

  00084	eb c6		 jmp	 SHORT $LN16@search_2i4
$LN15@search_2i4:

; 180  : 
; 181  :     /*------------------------------------------------------------------*
; 182  :      * main loop: try 2x4  tracks.                                      *
; 183  :      *------------------------------------------------------------------*/
; 184  : 
; 185  :     for (track1 = 0; track1 < 2; track1++)

  00086	33 c0		 xor	 eax, eax
  00088	66 89 45 d4	 mov	 WORD PTR _track1$[ebp], ax
  0008c	eb 0c		 jmp	 SHORT $LN14@search_2i4
$LN13@search_2i4:
  0008e	66 8b 45 d4	 mov	 ax, WORD PTR _track1$[ebp]
  00092	66 83 c0 01	 add	 ax, 1
  00096	66 89 45 d4	 mov	 WORD PTR _track1$[ebp], ax
$LN14@search_2i4:
  0009a	0f bf 45 d4	 movsx	 eax, WORD PTR _track1$[ebp]
  0009e	83 f8 02	 cmp	 eax, 2
  000a1	0f 8d e6 02 00
	00		 jge	 $LN18@search_2i4

; 186  :     {
; 187  :        for (track2 = 0; track2 < 4; track2++)

  000a7	33 c0		 xor	 eax, eax
  000a9	66 89 45 c8	 mov	 WORD PTR _track2$[ebp], ax
  000ad	eb 0c		 jmp	 SHORT $LN11@search_2i4
$LN10@search_2i4:
  000af	66 8b 45 c8	 mov	 ax, WORD PTR _track2$[ebp]
  000b3	66 83 c0 01	 add	 ax, 1
  000b7	66 89 45 c8	 mov	 WORD PTR _track2$[ebp], ax
$LN11@search_2i4:
  000bb	0f bf 45 c8	 movsx	 eax, WORD PTR _track2$[ebp]
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	0f 8d c0 02 00
	00		 jge	 $LN9@search_2i4

; 188  :        {		
; 189  :           /* fix starting position */          
; 190  :           ipos[0] = startPos1[track1]; move16 ();

  000c8	0f bf 45 d4	 movsx	 eax, WORD PTR _track1$[ebp]
  000cc	b9 02 00 00 00	 mov	 ecx, 2
  000d1	6b d1 00	 imul	 edx, ecx, 0
  000d4	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _startPos1[eax*2]
  000dc	66 89 44 15 bc	 mov	 WORD PTR _ipos$[ebp+edx], ax
  000e1	e8 00 00 00 00	 call	 _move16

; 191  :           ipos[1] = startPos2[track2]; move16 ();

  000e6	0f bf 45 c8	 movsx	 eax, WORD PTR _track2$[ebp]
  000ea	b9 02 00 00 00	 mov	 ecx, 2
  000ef	c1 e1 00	 shl	 ecx, 0
  000f2	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _startPos2[eax*2]
  000fa	66 89 54 0d bc	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  000ff	e8 00 00 00 00	 call	 _move16

; 192  :           
; 193  :           /*----------------------------------------------------------------*
; 194  :            * i0 loop: try 8 positions.                                      *
; 195  :            *----------------------------------------------------------------*/
; 196  :           move16 (); /* account for ptr. init. (rr[io]) */

  00104	e8 00 00 00 00	 call	 _move16

; 197  :           for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)

  00109	b8 02 00 00 00	 mov	 eax, 2
  0010e	6b c8 00	 imul	 ecx, eax, 0
  00111	66 8b 54 0d bc	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  00116	66 89 55 f8	 mov	 WORD PTR _i0$[ebp], dx
  0011a	eb 0b		 jmp	 SHORT $LN8@search_2i4
$LN7@search_2i4:
  0011c	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00120	83 c0 05	 add	 eax, 5
  00123	66 89 45 f8	 mov	 WORD PTR _i0$[ebp], ax
$LN8@search_2i4:
  00127	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  0012b	83 f8 28	 cmp	 eax, 40			; 00000028H
  0012e	0f 8d 4f 02 00
	00		 jge	 $LN6@search_2i4

; 198  :           {
; 199  :              ps0 = dn[i0];          move16 ();

  00134	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  0013b	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0013f	66 89 55 a4	 mov	 WORD PTR _ps0$[ebp], dx
  00143	e8 00 00 00 00	 call	 _move16

; 200  :              alp0 = L_mult(rr[i0][i0], _1_4);

  00148	68 00 20 00 00	 push	 8192			; 00002000H
  0014d	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  00151	6b c8 50	 imul	 ecx, eax, 80
  00154	03 4d 0c	 add	 ecx, DWORD PTR _rr$[ebp]
  00157	0f bf 55 f8	 movsx	 edx, WORD PTR _i0$[ebp]
  0015b	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _L_mult
  00165	83 c4 08	 add	 esp, 8
  00168	89 85 44 ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 201  :              
; 202  :              /*-------------------------------------------------------------*
; 203  :               * i1 loop: 8 positions.                                       *
; 204  :               *-------------------------------------------------------------*/
; 205  :              
; 206  :              sq = -1;               move16 ();

  0016e	83 c8 ff	 or	 eax, -1
  00171	66 89 45 8c	 mov	 WORD PTR _sq$[ebp], ax
  00175	e8 00 00 00 00	 call	 _move16

; 207  :              alp = 1;               move16 ();

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  00186	e8 00 00 00 00	 call	 _move16

; 208  :              ix = ipos[1];          move16 ();

  0018b	b8 02 00 00 00	 mov	 eax, 2
  00190	c1 e0 00	 shl	 eax, 0
  00193	66 8b 4c 05 bc	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00198	66 89 4d e0	 mov	 WORD PTR _ix$[ebp], cx
  0019c	e8 00 00 00 00	 call	 _move16

; 209  :              
; 210  :              /*---------------------------------------------------------------*
; 211  :               * These index have low complexity address computation because   *
; 212  :               * they are, in fact, pointers with fixed increment. For example,*
; 213  :               * "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"   *
; 214  :               * and incremented by "STEP".                                    *
; 215  :               *---------------------------------------------------------------*/
; 216  :              
; 217  :              move16 (); /* account for ptr. init. (rr[i1]) */

  001a1	e8 00 00 00 00	 call	 _move16

; 218  :              move16 (); /* account for ptr. init. (dn[i1]) */

  001a6	e8 00 00 00 00	 call	 _move16

; 219  :              move16 (); /* account for ptr. init. (rr[io]) */

  001ab	e8 00 00 00 00	 call	 _move16

; 220  :              for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {

  001b0	b8 02 00 00 00	 mov	 eax, 2
  001b5	c1 e0 00	 shl	 eax, 0
  001b8	66 8b 4c 05 bc	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  001bd	66 89 4d ec	 mov	 WORD PTR _i1$[ebp], cx
  001c1	eb 0b		 jmp	 SHORT $LN5@search_2i4
$LN4@search_2i4:
  001c3	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001c7	83 c0 05	 add	 eax, 5
  001ca	66 89 45 ec	 mov	 WORD PTR _i1$[ebp], ax
$LN5@search_2i4:
  001ce	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001d2	83 f8 28	 cmp	 eax, 40			; 00000028H
  001d5	0f 8d 14 01 00
	00		 jge	 $LN3@search_2i4

; 221  :                 ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */

  001db	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  001df	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  001e2	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001e6	52		 push	 edx
  001e7	0f b7 45 a4	 movzx	 eax, WORD PTR _ps0$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _add
  001f1	83 c4 08	 add	 esp, 8
  001f4	66 89 45 98	 mov	 WORD PTR _ps1$[ebp], ax

; 222  :                 
; 223  :                 /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
; 224  :                 
; 225  :                 alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */

  001f8	68 00 20 00 00	 push	 8192			; 00002000H
  001fd	0f bf 45 ec	 movsx	 eax, WORD PTR _i1$[ebp]
  00201	6b c8 50	 imul	 ecx, eax, 80
  00204	03 4d 0c	 add	 ecx, DWORD PTR _rr$[ebp]
  00207	0f bf 55 ec	 movsx	 edx, WORD PTR _i1$[ebp]
  0020b	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0020f	50		 push	 eax
  00210	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  00216	51		 push	 ecx
  00217	e8 00 00 00 00	 call	 _L_mac
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021f	89 85 38 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 226  :                 alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */

  00225	68 00 40 00 00	 push	 16384			; 00004000H
  0022a	0f bf 45 f8	 movsx	 eax, WORD PTR _i0$[ebp]
  0022e	6b c8 50	 imul	 ecx, eax, 80
  00231	03 4d 0c	 add	 ecx, DWORD PTR _rr$[ebp]
  00234	0f bf 55 ec	 movsx	 edx, WORD PTR _i1$[ebp]
  00238	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0023c	50		 push	 eax
  0023d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  00243	51		 push	 ecx
  00244	e8 00 00 00 00	 call	 _L_mac
  00249	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024c	89 85 38 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 227  :                 
; 228  :                 sq1 = mult(ps1, ps1);

  00252	0f b7 45 98	 movzx	 eax, WORD PTR _ps1$[ebp]
  00256	50		 push	 eax
  00257	0f b7 4d 98	 movzx	 ecx, WORD PTR _ps1$[ebp]
  0025b	51		 push	 ecx
  0025c	e8 00 00 00 00	 call	 _mult
  00261	83 c4 08	 add	 esp, 8
  00264	66 89 45 80	 mov	 WORD PTR _sq1$[ebp], ax

; 229  :                 
; 230  :                 alp_16 = round(alp1);

  00268	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 _round
  00274	83 c4 04	 add	 esp, 4
  00277	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 231  :                 
; 232  :                 s = L_msu(L_mult(alp, sq1), sq, alp_16);

  0027e	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  00285	50		 push	 eax
  00286	0f b7 4d 8c	 movzx	 ecx, WORD PTR _sq$[ebp]
  0028a	51		 push	 ecx
  0028b	0f b7 55 80	 movzx	 edx, WORD PTR _sq1$[ebp]
  0028f	52		 push	 edx
  00290	0f b7 85 68 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 _L_mult
  0029d	83 c4 08	 add	 esp, 8
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 _L_msu
  002a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a9	89 85 50 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 233  :                 
; 234  :                 test ();

  002af	e8 00 00 00 00	 call	 _test

; 235  :                 if (s > 0)

  002b4	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  002bb	7e 2d		 jle	 SHORT $LN2@search_2i4

; 236  :                 {
; 237  :                    sq = sq1;        move16 ();

  002bd	66 8b 45 80	 mov	 ax, WORD PTR _sq1$[ebp]
  002c1	66 89 45 8c	 mov	 WORD PTR _sq$[ebp], ax
  002c5	e8 00 00 00 00	 call	 _move16

; 238  :                    alp = alp_16;    move16 ();

  002ca	66 8b 85 5c ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  002d1	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  002d8	e8 00 00 00 00	 call	 _move16

; 239  :                    ix = i1;         move16 ();

  002dd	66 8b 45 ec	 mov	 ax, WORD PTR _i1$[ebp]
  002e1	66 89 45 e0	 mov	 WORD PTR _ix$[ebp], ax
  002e5	e8 00 00 00 00	 call	 _move16
$LN2@search_2i4:

; 240  :                 }
; 241  :              }

  002ea	e9 d4 fe ff ff	 jmp	 $LN4@search_2i4
$LN3@search_2i4:

; 242  :              
; 243  :              /*---------------------------------------------------------------*
; 244  :               * memorise codevector if this one is better than the last one.  *
; 245  :               *---------------------------------------------------------------*/
; 246  :              
; 247  :              s = L_msu(L_mult(alpk, sq), psk, alp);

  002ef	0f b7 85 68 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  002f6	50		 push	 eax
  002f7	0f b7 4d b0	 movzx	 ecx, WORD PTR _psk$[ebp]
  002fb	51		 push	 ecx
  002fc	0f b7 55 8c	 movzx	 edx, WORD PTR _sq$[ebp]
  00300	52		 push	 edx
  00301	0f b7 85 74 ff
	ff ff		 movzx	 eax, WORD PTR _alpk$[ebp]
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 _L_mult
  0030e	83 c4 08	 add	 esp, 8
  00311	50		 push	 eax
  00312	e8 00 00 00 00	 call	 _L_msu
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031a	89 85 50 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 248  :              
; 249  :              test ();

  00320	e8 00 00 00 00	 call	 _test

; 250  :              if (s > 0)

  00325	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  0032c	7e 50		 jle	 SHORT $LN1@search_2i4

; 251  :              {
; 252  :                 psk = sq;           move16 ();

  0032e	66 8b 45 8c	 mov	 ax, WORD PTR _sq$[ebp]
  00332	66 89 45 b0	 mov	 WORD PTR _psk$[ebp], ax
  00336	e8 00 00 00 00	 call	 _move16

; 253  :                 alpk = alp;         move16 ();

  0033b	66 8b 85 68 ff
	ff ff		 mov	 ax, WORD PTR _alp$[ebp]
  00342	66 89 85 74 ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  00349	e8 00 00 00 00	 call	 _move16

; 254  :                 codvec[0] = i0;     move16 ();

  0034e	b8 02 00 00 00	 mov	 eax, 2
  00353	6b c8 00	 imul	 ecx, eax, 0
  00356	8b 55 10	 mov	 edx, DWORD PTR _codvec$[ebp]
  00359	66 8b 45 f8	 mov	 ax, WORD PTR _i0$[ebp]
  0035d	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00361	e8 00 00 00 00	 call	 _move16

; 255  :                 codvec[1] = ix;     move16 ();

  00366	b8 02 00 00 00	 mov	 eax, 2
  0036b	c1 e0 00	 shl	 eax, 0
  0036e	8b 4d 10	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00371	66 8b 55 e0	 mov	 dx, WORD PTR _ix$[ebp]
  00375	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00379	e8 00 00 00 00	 call	 _move16
$LN1@search_2i4:

; 256  :              }
; 257  :           }

  0037e	e9 99 fd ff ff	 jmp	 $LN7@search_2i4
$LN6@search_2i4:

; 258  :        }

  00383	e9 27 fd ff ff	 jmp	 $LN10@search_2i4
$LN9@search_2i4:

; 259  :     }

  00388	e9 01 fd ff ff	 jmp	 $LN13@search_2i4
$LN18@search_2i4:

; 260  :     return;
; 261  : }

  0038d	52		 push	 edx
  0038e	8b cd		 mov	 ecx, ebp
  00390	50		 push	 eax
  00391	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@search_2i4
  00397	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0039c	58		 pop	 eax
  0039d	5a		 pop	 edx
  0039e	5f		 pop	 edi
  0039f	5e		 pop	 esi
  003a0	5b		 pop	 ebx
  003a1	81 c4 98 01 00
	00		 add	 esp, 408		; 00000198H
  003a7	3b ec		 cmp	 ebp, esp
  003a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ae	8b e5		 mov	 esp, ebp
  003b0	5d		 pop	 ebp
  003b1	c3		 ret	 0
  003b2	8b ff		 npad	 2
$LN22@search_2i4:
  003b4	01 00 00 00	 DD	 1
  003b8	00 00 00 00	 DD	 $LN21@search_2i4
$LN21@search_2i4:
  003bc	bc ff ff ff	 DD	 -68			; ffffffbcH
  003c0	04 00 00 00	 DD	 4
  003c4	00 00 00 00	 DD	 $LN20@search_2i4
$LN20@search_2i4:
  003c8	69		 DB	 105			; 00000069H
  003c9	70		 DB	 112			; 00000070H
  003ca	6f		 DB	 111			; 0000006fH
  003cb	73		 DB	 115			; 00000073H
  003cc	00		 DB	 0
_search_2i40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c2_11pf.c
;	COMDAT _code_2i40_11bits
_TEXT	SEGMENT
_sharp$ = -3520						; size = 2
_index$ = -3508						; size = 2
_i$ = -3496						; size = 2
_rr$ = -3484						; size = 3200
_dn_sign$ = -276					; size = 80
_dn2$ = -188						; size = 80
_dn$ = -100						; size = 80
_codvec$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_h$ = 12						; size = 4
_T0$ = 16						; size = 2
_pitch_sharp$ = 20					; size = 2
_code$ = 24						; size = 4
_y$ = 28						; size = 4
_sign$ = 32						; size = 4
_code_2i40_11bits PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 0e 00
	00		 sub	 esp, 3716		; 00000e84H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c f1 ff
	ff		 lea	 edi, DWORD PTR [ebp-3716]
  00012	b9 a1 03 00 00	 mov	 ecx, 929		; 000003a1H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 104  :     Word16 codvec[NB_PULSE];
; 105  :     Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
; 106  :     Word16 rr[L_CODE][L_CODE];
; 107  :     Word16 i, index, sharp;
; 108  : 
; 109  :     sharp = shl(pitch_sharp, 1);

  00028	6a 01		 push	 1
  0002a	0f b7 45 14	 movzx	 eax, WORD PTR _pitch_sharp$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _shl
  00034	83 c4 08	 add	 esp, 8
  00037	66 89 85 40 f2
	ff ff		 mov	 WORD PTR _sharp$[ebp], ax

; 110  :     test ();

  0003e	e8 00 00 00 00	 call	 _test

; 111  :     if (sub(T0, L_CODE) < 0)

  00043	6a 28		 push	 40			; 00000028H
  00045	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _sub
  0004f	83 c4 08	 add	 esp, 8
  00052	0f bf c8	 movsx	 ecx, ax
  00055	85 c9		 test	 ecx, ecx
  00057	0f 8d 80 00 00
	00		 jge	 $LN8@code_2i40_

; 112  :     {
; 113  :        for (i = T0; i < L_CODE; i++) {

  0005d	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00061	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00068	eb 12		 jmp	 SHORT $LN7@code_2i40_
$LN6@code_2i40_:
  0006a	66 8b 85 58 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@code_2i40_:
  0007c	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00083	83 f8 28	 cmp	 eax, 40			; 00000028H
  00086	7d 55		 jge	 SHORT $LN8@code_2i40_

; 114  :           h[i] = add(h[i], mult(h[i - T0], sharp));    move16 ();

  00088	0f b7 85 40 f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  0008f	50		 push	 eax
  00090	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00097	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  0009b	2b ca		 sub	 ecx, edx
  0009d	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  000a0	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _mult
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b7 d0	 movzx	 edx, ax
  000b0	52		 push	 edx
  000b1	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  000bb	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _add
  000c5	83 c4 08	 add	 esp, 8
  000c8	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  000cf	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000d2	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  000d6	e8 00 00 00 00	 call	 _move16

; 115  :        }

  000db	eb 8d		 jmp	 SHORT $LN6@code_2i40_
$LN8@code_2i40_:

; 116  :     }
; 117  :     
; 118  :     cor_h_x(h, x, dn, 1);

  000dd	6a 01		 push	 1
  000df	8d 45 9c	 lea	 eax, DWORD PTR _dn$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _cor_h_x
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 119  :     set_sign(dn, dn_sign, dn2, 8); /* dn2[] not used in this codebook search */

  000f3	6a 08		 push	 8
  000f5	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _dn2$[ebp]
  000fb	50		 push	 eax
  000fc	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00102	51		 push	 ecx
  00103	8d 55 9c	 lea	 edx, DWORD PTR _dn$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _set_sign
  0010c	83 c4 10	 add	 esp, 16			; 00000010H

; 120  :     cor_h(h, dn_sign, rr);

  0010f	8d 85 64 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00115	50		 push	 eax
  00116	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _cor_h
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  :     search_2i40(dn, rr, codvec);

  00129	8d 45 f4	 lea	 eax, DWORD PTR _codvec$[ebp]
  0012c	50		 push	 eax
  0012d	8d 8d 64 f2 ff
	ff		 lea	 ecx, DWORD PTR _rr$[ebp]
  00133	51		 push	 ecx
  00134	8d 55 9c	 lea	 edx, DWORD PTR _dn$[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _search_2i40
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  :                                     move16 (); /* function result */

  00140	e8 00 00 00 00	 call	 _move16

; 123  :     index = build_code(codvec, dn_sign, code, h, y, sign);

  00145	8b 45 20	 mov	 eax, DWORD PTR _sign$[ebp]
  00148	50		 push	 eax
  00149	8b 4d 1c	 mov	 ecx, DWORD PTR _y$[ebp]
  0014c	51		 push	 ecx
  0014d	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00150	52		 push	 edx
  00151	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  00154	50		 push	 eax
  00155	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  0015b	51		 push	 ecx
  0015c	8d 55 f4	 lea	 edx, DWORD PTR _codvec$[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 _build_code
  00165	83 c4 18	 add	 esp, 24			; 00000018H
  00168	66 89 85 4c f2
	ff ff		 mov	 WORD PTR _index$[ebp], ax

; 124  : 
; 125  :   /*-----------------------------------------------------------------*
; 126  :   * Compute innovation vector gain.                                 *
; 127  :   * Include fixed-gain pitch contribution into code[].              *
; 128  :   *-----------------------------------------------------------------*/
; 129  : 
; 130  :     test ();

  0016f	e8 00 00 00 00	 call	 _test

; 131  :     if (sub(T0, L_CODE) < 0)

  00174	6a 28		 push	 40			; 00000028H
  00176	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _sub
  00180	83 c4 08	 add	 esp, 8
  00183	0f bf c8	 movsx	 ecx, ax
  00186	85 c9		 test	 ecx, ecx
  00188	0f 8d 80 00 00
	00		 jge	 $LN4@code_2i40_

; 132  :     {
; 133  :        for (i = T0; i < L_CODE; i++)

  0018e	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00192	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00199	eb 12		 jmp	 SHORT $LN3@code_2i40_
$LN2@code_2i40_:
  0019b	66 8b 85 58 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  001a2	66 83 c0 01	 add	 ax, 1
  001a6	66 89 85 58 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN3@code_2i40_:
  001ad	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001b4	83 f8 28	 cmp	 eax, 40			; 00000028H
  001b7	7d 55		 jge	 SHORT $LN4@code_2i40_

; 134  :        {
; 135  :           code[i] = add(code[i], mult(code[i - T0], sharp));    move16 ();

  001b9	0f b7 85 40 f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  001c0	50		 push	 eax
  001c1	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  001c8	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  001cc	2b ca		 sub	 ecx, edx
  001ce	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  001d1	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 _mult
  001db	83 c4 08	 add	 esp, 8
  001de	0f b7 d0	 movzx	 edx, ax
  001e1	52		 push	 edx
  001e2	0f bf 85 58 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001e9	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  001ec	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001f0	52		 push	 edx
  001f1	e8 00 00 00 00	 call	 _add
  001f6	83 c4 08	 add	 esp, 8
  001f9	0f bf 8d 58 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00200	8b 55 18	 mov	 edx, DWORD PTR _code$[ebp]
  00203	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00207	e8 00 00 00 00	 call	 _move16

; 136  :        }

  0020c	eb 8d		 jmp	 SHORT $LN2@code_2i40_
$LN4@code_2i40_:

; 137  :     }
; 138  :     return index;

  0020e	66 8b 85 4c f2
	ff ff		 mov	 ax, WORD PTR _index$[ebp]

; 139  : }

  00215	52		 push	 edx
  00216	8b cd		 mov	 ecx, ebp
  00218	50		 push	 eax
  00219	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@code_2i40_
  0021f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00224	58		 pop	 eax
  00225	5a		 pop	 edx
  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx
  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	33 cd		 xor	 ecx, ebp
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	81 c4 84 0e 00
	00		 add	 esp, 3716		; 00000e84H
  00239	3b ec		 cmp	 ebp, esp
  0023b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c3		 ret	 0
$LN17@code_2i40_:
  00244	05 00 00 00	 DD	 5
  00248	00 00 00 00	 DD	 $LN16@code_2i40_
$LN16@code_2i40_:
  0024c	f4 ff ff ff	 DD	 -12			; fffffff4H
  00250	04 00 00 00	 DD	 4
  00254	00 00 00 00	 DD	 $LN11@code_2i40_
  00258	9c ff ff ff	 DD	 -100			; ffffff9cH
  0025c	50 00 00 00	 DD	 80			; 00000050H
  00260	00 00 00 00	 DD	 $LN12@code_2i40_
  00264	44 ff ff ff	 DD	 -188			; ffffff44H
  00268	50 00 00 00	 DD	 80			; 00000050H
  0026c	00 00 00 00	 DD	 $LN13@code_2i40_
  00270	ec fe ff ff	 DD	 -276			; fffffeecH
  00274	50 00 00 00	 DD	 80			; 00000050H
  00278	00 00 00 00	 DD	 $LN14@code_2i40_
  0027c	64 f2 ff ff	 DD	 -3484			; fffff264H
  00280	80 0c 00 00	 DD	 3200			; 00000c80H
  00284	00 00 00 00	 DD	 $LN15@code_2i40_
$LN15@code_2i40_:
  00288	72		 DB	 114			; 00000072H
  00289	72		 DB	 114			; 00000072H
  0028a	00		 DB	 0
$LN14@code_2i40_:
  0028b	64		 DB	 100			; 00000064H
  0028c	6e		 DB	 110			; 0000006eH
  0028d	5f		 DB	 95			; 0000005fH
  0028e	73		 DB	 115			; 00000073H
  0028f	69		 DB	 105			; 00000069H
  00290	67		 DB	 103			; 00000067H
  00291	6e		 DB	 110			; 0000006eH
  00292	00		 DB	 0
$LN13@code_2i40_:
  00293	64		 DB	 100			; 00000064H
  00294	6e		 DB	 110			; 0000006eH
  00295	32		 DB	 50			; 00000032H
  00296	00		 DB	 0
$LN12@code_2i40_:
  00297	64		 DB	 100			; 00000064H
  00298	6e		 DB	 110			; 0000006eH
  00299	00		 DB	 0
$LN11@code_2i40_:
  0029a	63		 DB	 99			; 00000063H
  0029b	6f		 DB	 111			; 0000006fH
  0029c	64		 DB	 100			; 00000064H
  0029d	76		 DB	 118			; 00000076H
  0029e	65		 DB	 101			; 00000065H
  0029f	63		 DB	 99			; 00000063H
  002a0	00		 DB	 0
_code_2i40_11bits ENDP
_TEXT	ENDS
END
