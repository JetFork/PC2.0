; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\autocorr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_autocorr_id
CONST	SEGMENT
_autocorr_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_Autocorr
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_sub:PROC
EXTRN	_mult_r:PROC
EXTRN	_L_shl:PROC
EXTRN	_norm_l:PROC
EXTRN	_L_Extract:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\autocorr.c
;	COMDAT _Autocorr
_TEXT	SEGMENT
_overfl_shft$ = -560					; size = 2
_overfl$ = -548						; size = 2
_sum$ = -536						; size = 4
_y$ = -524						; size = 480
_norm$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_m$ = 12						; size = 2
_r_h$ = 16						; size = 4
_r_l$ = 20						; size = 4
_wind$ = 24						; size = 4
_Autocorr PROC						; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 02 00
	00		 sub	 esp, 756		; 000002f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-756]
  00012	b9 bd 00 00 00	 mov	 ecx, 189		; 000000bdH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 60   :     Word16 i, j, norm;
; 61   :     Word16 y[L_WINDOW];
; 62   :     Word32 sum;
; 63   :     Word16 overfl, overfl_shft;
; 64   : 
; 65   :     /* Windowing of signal */
; 66   : 
; 67   :     for (i = 0; i < L_WINDOW; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN19@Autocorr
$LN18@Autocorr:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN19@Autocorr:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00045	7d 33		 jge	 SHORT $LN17@Autocorr

; 68   :     {
; 69   :         y[i] = mult_r (x[i], wind[i]); move16 (); 

  00047	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0004b	8b 4d 18	 mov	 ecx, DWORD PTR _wind$[ebp]
  0004e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00052	52		 push	 edx
  00053	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0005a	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 _mult_r
  00064	83 c4 08	 add	 esp, 8
  00067	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0006b	66 89 84 4d f4
	fd ff ff	 mov	 WORD PTR _y$[ebp+ecx*2], ax
  00073	e8 00 00 00 00	 call	 _move16

; 70   :     }

  00078	eb b6		 jmp	 SHORT $LN18@Autocorr
$LN17@Autocorr:

; 71   : 
; 72   :     /* Compute r[0] and test for overflow */
; 73   : 
; 74   :     overfl_shft = 0;                   move16 (); 

  0007a	33 c0		 xor	 eax, eax
  0007c	66 89 85 d0 fd
	ff ff		 mov	 WORD PTR _overfl_shft$[ebp], ax
  00083	e8 00 00 00 00	 call	 _move16
$LN16@Autocorr:

; 75   : 
; 76   :     do
; 77   :     {
; 78   :         overfl = 0;                    move16 (); 

  00088	33 c0		 xor	 eax, eax
  0008a	66 89 85 dc fd
	ff ff		 mov	 WORD PTR _overfl$[ebp], ax
  00091	e8 00 00 00 00	 call	 _move16

; 79   :         sum = 0L;                      move32 ();

  00096	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _sum$[ebp], 0
  000a0	e8 00 00 00 00	 call	 _move32

; 80   : 
; 81   :         for (i = 0; i < L_WINDOW; i++)

  000a5	33 c0		 xor	 eax, eax
  000a7	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  000ab	eb 0c		 jmp	 SHORT $LN13@Autocorr
$LN12@Autocorr:
  000ad	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  000b1	66 83 c0 01	 add	 ax, 1
  000b5	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN13@Autocorr:
  000b9	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000bd	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  000c2	7d 31		 jge	 SHORT $LN11@Autocorr

; 82   :         {
; 83   :             sum = L_mac (sum, y[i], y[i]);

  000c4	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000c8	0f b7 8c 45 f4
	fd ff ff	 movzx	 ecx, WORD PTR _y$[ebp+eax*2]
  000d0	51		 push	 ecx
  000d1	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  000d5	0f b7 84 55 f4
	fd ff ff	 movzx	 eax, WORD PTR _y$[ebp+edx*2]
  000dd	50		 push	 eax
  000de	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _sum$[ebp]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 _L_mac
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 84   :         }

  000f3	eb b8		 jmp	 SHORT $LN12@Autocorr
$LN11@Autocorr:

; 85   : 
; 86   :         /* If overflow divide y[] by 4 */
; 87   : 
; 88   :         test (); 

  000f5	e8 00 00 00 00	 call	 _test

; 89   :         if (L_sub (sum, MAX_32) == 0L)

  000fa	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000ff	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _sum$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _L_sub
  0010b	83 c4 08	 add	 esp, 8
  0010e	85 c0		 test	 eax, eax
  00110	75 73		 jne	 SHORT $LN10@Autocorr

; 90   :         {
; 91   :             overfl_shft = add (overfl_shft, 4);

  00112	6a 04		 push	 4
  00114	0f b7 85 d0 fd
	ff ff		 movzx	 eax, WORD PTR _overfl_shft$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _add
  00121	83 c4 08	 add	 esp, 8
  00124	66 89 85 d0 fd
	ff ff		 mov	 WORD PTR _overfl_shft$[ebp], ax

; 92   :             overfl = 1;                move16 (); /* Set the overflow flag */

  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	66 89 85 dc fd
	ff ff		 mov	 WORD PTR _overfl$[ebp], ax
  00137	e8 00 00 00 00	 call	 _move16

; 93   : 
; 94   :             for (i = 0; i < L_WINDOW; i++)

  0013c	33 c0		 xor	 eax, eax
  0013e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00142	eb 0c		 jmp	 SHORT $LN9@Autocorr
$LN8@Autocorr:
  00144	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00148	66 83 c0 01	 add	 ax, 1
  0014c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN9@Autocorr:
  00150	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00154	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00159	7d 2a		 jge	 SHORT $LN10@Autocorr

; 95   :             {
; 96   :                 y[i] = shr (y[i], 2);  move16 (); 

  0015b	6a 02		 push	 2
  0015d	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00161	0f b7 8c 45 f4
	fd ff ff	 movzx	 ecx, WORD PTR _y$[ebp+eax*2]
  00169	51		 push	 ecx
  0016a	e8 00 00 00 00	 call	 _shr
  0016f	83 c4 08	 add	 esp, 8
  00172	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00176	66 89 84 55 f4
	fd ff ff	 mov	 WORD PTR _y$[ebp+edx*2], ax
  0017e	e8 00 00 00 00	 call	 _move16

; 97   :             }

  00183	eb bf		 jmp	 SHORT $LN8@Autocorr
$LN10@Autocorr:

; 98   :         }
; 99   :         test (); 

  00185	e8 00 00 00 00	 call	 _test

; 100  :     }
; 101  :     while (overfl != 0);

  0018a	0f bf 85 dc fd
	ff ff		 movsx	 eax, WORD PTR _overfl$[ebp]
  00191	85 c0		 test	 eax, eax
  00193	0f 85 ef fe ff
	ff		 jne	 $LN16@Autocorr

; 102  : 
; 103  :     sum = L_add (sum, 1L);             /* Avoid the case of all zeros */

  00199	6a 01		 push	 1
  0019b	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _sum$[ebp]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _L_add
  001a7	83 c4 08	 add	 esp, 8
  001aa	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 104  : 
; 105  :     /* Normalization of r[0] */
; 106  : 
; 107  :     norm = norm_l (sum);

  001b0	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _sum$[ebp]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _norm_l
  001bc	83 c4 04	 add	 esp, 4
  001bf	66 89 45 dc	 mov	 WORD PTR _norm$[ebp], ax

; 108  :     sum = L_shl (sum, norm);

  001c3	0f b7 45 dc	 movzx	 eax, WORD PTR _norm$[ebp]
  001c7	50		 push	 eax
  001c8	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _sum$[ebp]
  001ce	51		 push	 ecx
  001cf	e8 00 00 00 00	 call	 _L_shl
  001d4	83 c4 08	 add	 esp, 8
  001d7	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 109  :     L_Extract (sum, &r_h[0], &r_l[0]); /* Put in DPF format (see oper_32b) */

  001dd	b8 02 00 00 00	 mov	 eax, 2
  001e2	6b c8 00	 imul	 ecx, eax, 0
  001e5	03 4d 14	 add	 ecx, DWORD PTR _r_l$[ebp]
  001e8	51		 push	 ecx
  001e9	ba 02 00 00 00	 mov	 edx, 2
  001ee	6b c2 00	 imul	 eax, edx, 0
  001f1	03 45 10	 add	 eax, DWORD PTR _r_h$[ebp]
  001f4	50		 push	 eax
  001f5	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _sum$[ebp]
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 _L_Extract
  00201	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 
; 111  :     /* r[1] to r[m] */
; 112  : 
; 113  :     for (i = 1; i <= m; i++)

  00204	b8 01 00 00 00	 mov	 eax, 1
  00209	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0020d	eb 0c		 jmp	 SHORT $LN6@Autocorr
$LN5@Autocorr:
  0020f	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00213	66 83 c0 01	 add	 ax, 1
  00217	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN6@Autocorr:
  0021b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0021f	0f bf 4d 0c	 movsx	 ecx, WORD PTR _m$[ebp]
  00223	3b c1		 cmp	 eax, ecx
  00225	0f 8f b1 00 00
	00		 jg	 $LN4@Autocorr

; 114  :     {
; 115  :         sum = 0;                       move32 (); 

  0022b	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _sum$[ebp], 0
  00235	e8 00 00 00 00	 call	 _move32

; 116  : 
; 117  :         for (j = 0; j < L_WINDOW - i; j++)

  0023a	33 c0		 xor	 eax, eax
  0023c	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00240	eb 0c		 jmp	 SHORT $LN3@Autocorr
$LN2@Autocorr:
  00242	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00246	66 83 c0 01	 add	 ax, 1
  0024a	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN3@Autocorr:
  0024e	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00252	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00256	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  0025b	2b d1		 sub	 edx, ecx
  0025d	3b c2		 cmp	 eax, edx
  0025f	7d 37		 jge	 SHORT $LN1@Autocorr

; 118  :         {
; 119  :             sum = L_mac (sum, y[j], y[j + i]);

  00261	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00265	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00269	03 c1		 add	 eax, ecx
  0026b	0f b7 94 45 f4
	fd ff ff	 movzx	 edx, WORD PTR _y$[ebp+eax*2]
  00273	52		 push	 edx
  00274	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00278	0f b7 8c 45 f4
	fd ff ff	 movzx	 ecx, WORD PTR _y$[ebp+eax*2]
  00280	51		 push	 ecx
  00281	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _sum$[ebp]
  00287	52		 push	 edx
  00288	e8 00 00 00 00	 call	 _L_mac
  0028d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00290	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 120  :         }

  00296	eb aa		 jmp	 SHORT $LN2@Autocorr
$LN1@Autocorr:

; 121  : 
; 122  :         sum = L_shl (sum, norm);

  00298	0f b7 45 dc	 movzx	 eax, WORD PTR _norm$[ebp]
  0029c	50		 push	 eax
  0029d	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _sum$[ebp]
  002a3	51		 push	 ecx
  002a4	e8 00 00 00 00	 call	 _L_shl
  002a9	83 c4 08	 add	 esp, 8
  002ac	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 123  :         L_Extract (sum, &r_h[i], &r_l[i]);

  002b2	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  002b6	8b 4d 14	 mov	 ecx, DWORD PTR _r_l$[ebp]
  002b9	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002bc	52		 push	 edx
  002bd	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  002c1	8b 4d 10	 mov	 ecx, DWORD PTR _r_h$[ebp]
  002c4	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  002c7	52		 push	 edx
  002c8	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _sum$[ebp]
  002ce	50		 push	 eax
  002cf	e8 00 00 00 00	 call	 _L_Extract
  002d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  :     }

  002d7	e9 33 ff ff ff	 jmp	 $LN5@Autocorr
$LN4@Autocorr:

; 125  : 
; 126  :     norm = sub (norm, overfl_shft);

  002dc	0f b7 85 d0 fd
	ff ff		 movzx	 eax, WORD PTR _overfl_shft$[ebp]
  002e3	50		 push	 eax
  002e4	0f b7 4d dc	 movzx	 ecx, WORD PTR _norm$[ebp]
  002e8	51		 push	 ecx
  002e9	e8 00 00 00 00	 call	 _sub
  002ee	83 c4 08	 add	 esp, 8
  002f1	66 89 45 dc	 mov	 WORD PTR _norm$[ebp], ax

; 127  : 
; 128  :     return norm;

  002f5	66 8b 45 dc	 mov	 ax, WORD PTR _norm$[ebp]

; 129  : }

  002f9	52		 push	 edx
  002fa	8b cd		 mov	 ecx, ebp
  002fc	50		 push	 eax
  002fd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@Autocorr
  00303	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00308	58		 pop	 eax
  00309	5a		 pop	 edx
  0030a	5f		 pop	 edi
  0030b	5e		 pop	 esi
  0030c	5b		 pop	 ebx
  0030d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00310	33 cd		 xor	 ecx, ebp
  00312	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00317	81 c4 f4 02 00
	00		 add	 esp, 756		; 000002f4H
  0031d	3b ec		 cmp	 ebp, esp
  0031f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00324	8b e5		 mov	 esp, ebp
  00326	5d		 pop	 ebp
  00327	c3		 ret	 0
$LN24@Autocorr:
  00328	01 00 00 00	 DD	 1
  0032c	00 00 00 00	 DD	 $LN23@Autocorr
$LN23@Autocorr:
  00330	f4 fd ff ff	 DD	 -524			; fffffdf4H
  00334	e0 01 00 00	 DD	 480			; 000001e0H
  00338	00 00 00 00	 DD	 $LN22@Autocorr
$LN22@Autocorr:
  0033c	79		 DB	 121			; 00000079H
  0033d	00		 DB	 0
_Autocorr ENDP
_TEXT	ENDS
END
