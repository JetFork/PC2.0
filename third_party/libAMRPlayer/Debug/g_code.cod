; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\g_code.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_code_id
CONST	SEGMENT
_g_code_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_G_code
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_extract_h:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_shl:PROC
EXTRN	_div_s:PROC
EXTRN	_norm_l:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\g_code.c
;	COMDAT _G_code
_TEXT	SEGMENT
_s$ = -172						; size = 4
_scal_y2$ = -160					; size = 80
_gain$ = -72						; size = 2
_exp_yy$ = -60						; size = 2
_exp_xy$ = -48						; size = 2
_yy$ = -36						; size = 2
_xy$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_xn2$ = 8						; size = 4
_y2$ = 12						; size = 4
_G_code	PROC						; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 90 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-368]
  00012	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 64   :     Word16 i;
; 65   :     Word16 xy, yy, exp_xy, exp_yy, gain;
; 66   :     Word16 scal_y2[L_SUBFR];
; 67   :     Word32 s;
; 68   : 
; 69   :     /* Scale down Y[] by 2 to avoid overflow */
; 70   : 
; 71   :     for (i = 0; i < L_SUBFR; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN10@G_code
$LN9@G_code:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN10@G_code:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 28	 cmp	 eax, 40			; 00000028H
  00043	7d 29		 jge	 SHORT $LN8@G_code

; 72   :     {
; 73   :         scal_y2[i] = shr (y2[i], 1);  move16 (); 

  00045	6a 01		 push	 1
  00047	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _y2$[ebp]
  0004e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _shr
  00058	83 c4 08	 add	 esp, 8
  0005b	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0005f	66 89 84 4d 60
	ff ff ff	 mov	 WORD PTR _scal_y2$[ebp+ecx*2], ax
  00067	e8 00 00 00 00	 call	 _move16

; 74   :     }

  0006c	eb c2		 jmp	 SHORT $LN9@G_code
$LN8@G_code:

; 75   : 
; 76   :     /* Compute scalar product <X[],Y[]> */
; 77   : 
; 78   :     s = 1L;                           move32 (); /* Avoid case of all zeros */

  0006e	c7 85 54 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _s$[ebp], 1
  00078	e8 00 00 00 00	 call	 _move32

; 79   :     for (i = 0; i < L_SUBFR; i++)

  0007d	33 c0		 xor	 eax, eax
  0007f	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00083	eb 0c		 jmp	 SHORT $LN7@G_code
$LN6@G_code:
  00085	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00089	66 83 c0 01	 add	 ax, 1
  0008d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN7@G_code:
  00091	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00095	83 f8 28	 cmp	 eax, 40			; 00000028H
  00098	7d 30		 jge	 SHORT $LN5@G_code

; 80   :     {
; 81   :         s = L_mac (s, xn2[i], scal_y2[i]);

  0009a	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0009e	0f b7 8c 45 60
	ff ff ff	 movzx	 ecx, WORD PTR _scal_y2$[ebp+eax*2]
  000a6	51		 push	 ecx
  000a7	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  000ab	8b 45 08	 mov	 eax, DWORD PTR _xn2$[ebp]
  000ae	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  000b2	51		 push	 ecx
  000b3	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 _L_mac
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	89 85 54 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 82   :     }

  000c8	eb bb		 jmp	 SHORT $LN6@G_code
$LN5@G_code:

; 83   :     exp_xy = norm_l (s);

  000ca	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _norm_l
  000d6	83 c4 04	 add	 esp, 4
  000d9	66 89 45 d0	 mov	 WORD PTR _exp_xy$[ebp], ax

; 84   :     xy = extract_h (L_shl (s, exp_xy));

  000dd	0f b7 45 d0	 movzx	 eax, WORD PTR _exp_xy$[ebp]
  000e1	50		 push	 eax
  000e2	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _L_shl
  000ee	83 c4 08	 add	 esp, 8
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _extract_h
  000f7	83 c4 04	 add	 esp, 4
  000fa	66 89 45 e8	 mov	 WORD PTR _xy$[ebp], ax

; 85   : 
; 86   :     /* If (xy < 0) gain = 0  */
; 87   : 
; 88   :     test (); 

  000fe	e8 00 00 00 00	 call	 _test

; 89   :     if (xy <= 0)

  00103	0f bf 45 e8	 movsx	 eax, WORD PTR _xy$[ebp]
  00107	85 c0		 test	 eax, eax
  00109	7f 07		 jg	 SHORT $LN4@G_code

; 90   :         return ((Word16) 0);

  0010b	33 c0		 xor	 eax, eax
  0010d	e9 0b 01 00 00	 jmp	 $LN11@G_code
$LN4@G_code:

; 91   : 
; 92   :     /* Compute scalar product <Y[],Y[]> */
; 93   : 
; 94   :     s = 0L;                           move32 (); 

  00112	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  0011c	e8 00 00 00 00	 call	 _move32

; 95   :     for (i = 0; i < L_SUBFR; i++)

  00121	33 c0		 xor	 eax, eax
  00123	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00127	eb 0c		 jmp	 SHORT $LN3@G_code
$LN2@G_code:
  00129	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0012d	66 83 c0 01	 add	 ax, 1
  00131	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@G_code:
  00135	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00139	83 f8 28	 cmp	 eax, 40			; 00000028H
  0013c	7d 31		 jge	 SHORT $LN1@G_code

; 96   :     {
; 97   :         s = L_mac (s, scal_y2[i], scal_y2[i]);

  0013e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00142	0f b7 8c 45 60
	ff ff ff	 movzx	 ecx, WORD PTR _scal_y2$[ebp+eax*2]
  0014a	51		 push	 ecx
  0014b	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  0014f	0f b7 84 55 60
	ff ff ff	 movzx	 eax, WORD PTR _scal_y2$[ebp+edx*2]
  00157	50		 push	 eax
  00158	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0015e	51		 push	 ecx
  0015f	e8 00 00 00 00	 call	 _L_mac
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
  00167	89 85 54 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 98   :     }

  0016d	eb ba		 jmp	 SHORT $LN2@G_code
$LN1@G_code:

; 99   :     exp_yy = norm_l (s);

  0016f	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _norm_l
  0017b	83 c4 04	 add	 esp, 4
  0017e	66 89 45 c4	 mov	 WORD PTR _exp_yy$[ebp], ax

; 100  :     yy = extract_h (L_shl (s, exp_yy));

  00182	0f b7 45 c4	 movzx	 eax, WORD PTR _exp_yy$[ebp]
  00186	50		 push	 eax
  00187	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _L_shl
  00193	83 c4 08	 add	 esp, 8
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _extract_h
  0019c	83 c4 04	 add	 esp, 4
  0019f	66 89 45 dc	 mov	 WORD PTR _yy$[ebp], ax

; 101  : 
; 102  :     /* compute gain = xy/yy */
; 103  : 
; 104  :     xy = shr (xy, 1);                 /* Be sure xy < yy */

  001a3	6a 01		 push	 1
  001a5	0f b7 45 e8	 movzx	 eax, WORD PTR _xy$[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _shr
  001af	83 c4 08	 add	 esp, 8
  001b2	66 89 45 e8	 mov	 WORD PTR _xy$[ebp], ax

; 105  :     gain = div_s (xy, yy);

  001b6	0f b7 45 dc	 movzx	 eax, WORD PTR _yy$[ebp]
  001ba	50		 push	 eax
  001bb	0f b7 4d e8	 movzx	 ecx, WORD PTR _xy$[ebp]
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 _div_s
  001c5	83 c4 08	 add	 esp, 8
  001c8	66 89 45 b8	 mov	 WORD PTR _gain$[ebp], ax

; 106  : 
; 107  :     /* Denormalization of division */
; 108  :     i = add (exp_xy, 5);              /* 15-1+9-18 = 5 */

  001cc	6a 05		 push	 5
  001ce	0f b7 45 d0	 movzx	 eax, WORD PTR _exp_xy$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _add
  001d8	83 c4 08	 add	 esp, 8
  001db	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 109  :     i = sub (i, exp_yy);

  001df	0f b7 45 c4	 movzx	 eax, WORD PTR _exp_yy$[ebp]
  001e3	50		 push	 eax
  001e4	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 _sub
  001ee	83 c4 08	 add	 esp, 8
  001f1	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 110  : 
; 111  :     gain = shl (shr (gain, i), 1);    /* Q0 -> Q1 */

  001f5	6a 01		 push	 1
  001f7	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  001fb	50		 push	 eax
  001fc	0f b7 4d b8	 movzx	 ecx, WORD PTR _gain$[ebp]
  00200	51		 push	 ecx
  00201	e8 00 00 00 00	 call	 _shr
  00206	83 c4 08	 add	 esp, 8
  00209	0f b7 d0	 movzx	 edx, ax
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 _shl
  00212	83 c4 08	 add	 esp, 8
  00215	66 89 45 b8	 mov	 WORD PTR _gain$[ebp], ax

; 112  :     
; 113  :     return (gain);

  00219	66 8b 45 b8	 mov	 ax, WORD PTR _gain$[ebp]
$LN11@G_code:

; 114  : }

  0021d	52		 push	 edx
  0021e	8b cd		 mov	 ecx, ebp
  00220	50		 push	 eax
  00221	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@G_code
  00227	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022c	58		 pop	 eax
  0022d	5a		 pop	 edx
  0022e	5f		 pop	 edi
  0022f	5e		 pop	 esi
  00230	5b		 pop	 ebx
  00231	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00234	33 cd		 xor	 ecx, ebp
  00236	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023b	81 c4 70 01 00
	00		 add	 esp, 368		; 00000170H
  00241	3b ec		 cmp	 ebp, esp
  00243	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c3		 ret	 0
$LN15@G_code:
  0024c	01 00 00 00	 DD	 1
  00250	00 00 00 00	 DD	 $LN14@G_code
$LN14@G_code:
  00254	60 ff ff ff	 DD	 -160			; ffffff60H
  00258	50 00 00 00	 DD	 80			; 00000050H
  0025c	00 00 00 00	 DD	 $LN13@G_code
$LN13@G_code:
  00260	73		 DB	 115			; 00000073H
  00261	63		 DB	 99			; 00000063H
  00262	61		 DB	 97			; 00000061H
  00263	6c		 DB	 108			; 0000006cH
  00264	5f		 DB	 95			; 0000005fH
  00265	79		 DB	 121			; 00000079H
  00266	32		 DB	 50			; 00000032H
  00267	00		 DB	 0
_G_code	ENDP
_TEXT	ENDS
END
