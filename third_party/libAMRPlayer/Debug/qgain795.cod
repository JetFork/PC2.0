; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\qgain795.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_qgain795_id
CONST	SEGMENT
_qua_gain_pitch DW 00H
	DW	0ccdH
	DW	0199cH
	DW	02000H
	DW	02666H
	DW	02ccdH
	DW	03000H
	DW	03333H
	DW	03666H
	DW	0399aH
	DW	03ccdH
	DW	04000H
	DW	04333H
	DW	04666H
	DW	0499aH
	DW	04ccdH
_qua_gain_code DW 09fH
	DW	0f140H
	DW	0a735H
	DW	0ceH
	DW	0f2beH
	DW	0b034H
	DW	010cH
	DW	0f443H
	DW	0b958H
	DW	015dH
	DW	0f5c9H
	DW	0c285H
	DW	01a3H
	DW	0f6d7H
	DW	0c8dfH
	DW	01e2H
	DW	0f7a6H
	DW	0cdbdH
	DW	022aH
	DW	0f874H
	DW	0d293H
	DW	027dH
	DW	0f942H
	DW	0d76dH
	DW	02ddH
	DW	0fa12H
	DW	0dc4dH
	DW	034aH
	DW	0fadeH
	DW	0e11eH
	DW	03c9H
	DW	0fbaeH
	DW	0e600H
	DW	045aH
	DW	0fc7cH
	DW	0ead8H
	DW	0501H
	DW	0fd4aH
	DW	0efb3H
	DW	05c1H
	DW	0fe19H
	DW	0f48dH
	DW	069eH
	DW	0fee7H
	DW	0f968H
	DW	079cH
	DW	0ffb5H
	DW	0fe43H
	DW	08c1H
	DW	085H
	DW	0321H
	DW	0a11H
	DW	0153H
	DW	07fcH
	DW	0b93H
	DW	0221H
	DW	0cd5H
	DW	0d50H
	DW	02f0H
	DW	011b2H
	DW	0f4fH
	DW	03beH
	DW	0168cH
	DW	0119bH
	DW	048dH
	DW	01b68H
	DW	0143fH
	DW	055bH
	DW	02043H
	DW	01748H
	DW	0629H
	DW	0251dH
	DW	01ac7H
	DW	06f8H
	DW	029f9H
	DW	01ecbH
	DW	07c7H
	DW	02ed4H
	DW	02369H
	DW	0895H
	DW	033afH
	DW	028b9H
	DW	0964H
	DW	0388aH
	DW	030deH
	DW	0a71H
	DW	03ee0H
	DW	03f87H
	DW	0bf4H
	DW	047fdH
	DW	05296H
	DW	0d78H
	DW	0511bH
	DW	06b5dH
	DW	0efcH
	DW	05a39H
_qgain795_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_MR795_gain_quant
EXTRN	_gain_adapt:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_deposit_h:PROC
EXTRN	_L_Extract:PROC
EXTRN	_Mpy_32_16:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	_Pow2:PROC
EXTRN	_sqrt_l_exp:PROC
EXTRN	_calc_unfilt_energies:PROC
EXTRN	_q_gain_pitch:PROC
EXTRN	_Mac_32:PROC
EXTRN	_Mac_32_16:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\qgain795.c
;	COMDAT _MR795_gain_code_quant_mod
_TEXT	SEGMENT
_gain_code$ = -276					; size = 2
_dist_min$ = -264					; size = 4
_L_t1$ = -252						; size = 4
_L_t0$ = -240						; size = 4
_L_tmp$ = -228						; size = 4
_exp_coeff$ = -216					; size = 10
_coeff_lo$ = -196					; size = 10
_coeff$ = -176						; size = 10
_d2_code_l$ = -156					; size = 2
_d2_code_h$ = -144					; size = 2
_g2_code_l$ = -132					; size = 2
_g2_code_h$ = -120					; size = 2
_g_code$ = -108						; size = 2
_g2_pitch$ = -96					; size = 2
_e_max$ = -84						; size = 2
_exp$ = -72						; size = 2
_one_alpha$ = -60					; size = 2
_tmp$ = -48						; size = 2
_index$ = -36						; size = 2
_i$ = -24						; size = 2
_p$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_gain_pit$ = 8						; size = 2
_exp_gcode0$ = 12					; size = 2
_gcode0$ = 16						; size = 2
_frac_en$ = 20						; size = 4
_exp_en$ = 24						; size = 4
_alpha$ = 28						; size = 2
_gain_cod_unq$ = 32					; size = 2
_gain_cod$ = 36						; size = 4
_qua_ener_MR122$ = 40					; size = 4
_qua_ener$ = 44						; size = 4
_MR795_gain_code_quant_mod PROC				; COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-472]
  00012	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 271  :     const Word16 *p;
; 272  :     Word16 i, index, tmp;
; 273  :     Word16 one_alpha;
; 274  :     Word16 exp, e_max;
; 275  :     Word16 g2_pitch, g_code;
; 276  :     Word16 g2_code_h, g2_code_l;
; 277  :     Word16 d2_code_h, d2_code_l;
; 278  :     Word16 coeff[5], coeff_lo[5], exp_coeff[5];
; 279  :     Word32 L_tmp, L_t0, L_t1, dist_min;
; 280  :     Word16 gain_code;
; 281  : 
; 282  :     /*
; 283  :       Steps in calculation of the error criterion (dist):
; 284  :       ---------------------------------------------------
; 285  : 
; 286  :       underlined = constant; alp = FLP value of alpha, alpha = FIP
; 287  :       ----------
; 288  : 
; 289  : 
; 290  :         ExEn = gp^2 * LtpEn + 2.0*gp*gc[i] * XC + gc[i]^2 * InnEn;
; 291  :                ------------   ------         --             -----
; 292  : 
; 293  :         aExEn= alp * ExEn
; 294  :              = alp*gp^2*LtpEn + 2.0*alp*gp*XC* gc[i] + alp*InnEn* gc[i]^2
; 295  :                --------------   -------------          ---------
; 296  : 
; 297  :              =         t[1]   +              t[2]    +          t[3]
; 298  : 
; 299  :         dist = d1 + d2;
; 300  : 
; 301  :           d1 = (1.0 - alp) * InnEn * (gcu - gc[i])^2 = t[4]
; 302  :                -------------------    ---
; 303  : 
; 304  :           d2 =        alp  * (ResEn - 2.0 * sqrt(ResEn*ExEn) + ExEn);
; 305  :                       ---     -----   ---        -----
; 306  : 
; 307  :              =        alp  * (sqrt(ExEn) - sqrt(ResEn))^2
; 308  :                       ---                  -----------
; 309  : 
; 310  :              =               (sqrt(aExEn) - sqrt(alp*ResEn))^2
; 311  :                                             ---------------
; 312  : 
; 313  :              =               (sqrt(aExEn) -       t[0]     )^2
; 314  :                                                   ----
; 315  : 
; 316  :      */
; 317  : 
; 318  :     /*
; 319  :      * calculate scalings of the constant terms
; 320  :      */
; 321  :     gain_code = shl (*gain_cod, sub (10, exp_gcode0)); /* Q1  -> Q11 (-ec0) */

  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  0002c	50		 push	 eax
  0002d	6a 0a		 push	 10			; 0000000aH
  0002f	e8 00 00 00 00	 call	 _sub
  00034	83 c4 08	 add	 esp, 8
  00037	0f b7 c8	 movzx	 ecx, ax
  0003a	51		 push	 ecx
  0003b	8b 55 24	 mov	 edx, DWORD PTR _gain_cod$[ebp]
  0003e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _shl
  00047	83 c4 08	 add	 esp, 8
  0004a	66 89 85 ec fe
	ff ff		 mov	 WORD PTR _gain_code$[ebp], ax

; 322  :     g2_pitch = mult (gain_pit, gain_pit);              /* Q14 -> Q13        */

  00051	0f b7 45 08	 movzx	 eax, WORD PTR _gain_pit$[ebp]
  00055	50		 push	 eax
  00056	0f b7 4d 08	 movzx	 ecx, WORD PTR _gain_pit$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _mult
  00060	83 c4 08	 add	 esp, 8
  00063	66 89 45 a0	 mov	 WORD PTR _g2_pitch$[ebp], ax

; 323  :     /* 0 < alpha <= 0.5 => 0.5 <= 1-alpha < 1, i.e one_alpha is normalized  */
; 324  :     one_alpha = add (sub (32767, alpha), 1); /* 32768 - alpha */

  00067	6a 01		 push	 1
  00069	0f b7 45 1c	 movzx	 eax, WORD PTR _alpha$[ebp]
  0006d	50		 push	 eax
  0006e	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00073	e8 00 00 00 00	 call	 _sub
  00078	83 c4 08	 add	 esp, 8
  0007b	0f b7 c8	 movzx	 ecx, ax
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _add
  00084	83 c4 08	 add	 esp, 8
  00087	66 89 45 c4	 mov	 WORD PTR _one_alpha$[ebp], ax

; 325  : 
; 326  : 
; 327  :     /*  alpha <= 0.5 -> mult. by 2 to keep precision; compensate in exponent */
; 328  :     tmp = extract_h (L_shl (L_mult (alpha, frac_en[1]), 1));

  0008b	6a 01		 push	 1
  0008d	b8 02 00 00 00	 mov	 eax, 2
  00092	c1 e0 00	 shl	 eax, 0
  00095	8b 4d 14	 mov	 ecx, DWORD PTR _frac_en$[ebp]
  00098	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0009c	52		 push	 edx
  0009d	0f b7 45 1c	 movzx	 eax, WORD PTR _alpha$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _L_mult
  000a7	83 c4 08	 add	 esp, 8
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _L_shl
  000b0	83 c4 08	 add	 esp, 8
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _extract_h
  000b9	83 c4 04	 add	 esp, 4
  000bc	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 329  :     /* directly store in 32 bit variable because no further mult. required */
; 330  :     L_t1 = L_mult (tmp, g2_pitch);                    move16 ();

  000c0	0f b7 45 a0	 movzx	 eax, WORD PTR _g2_pitch$[ebp]
  000c4	50		 push	 eax
  000c5	0f b7 4d d0	 movzx	 ecx, WORD PTR _tmp$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _L_mult
  000cf	83 c4 08	 add	 esp, 8
  000d2	89 85 04 ff ff
	ff		 mov	 DWORD PTR _L_t1$[ebp], eax
  000d8	e8 00 00 00 00	 call	 _move16

; 331  :     exp_coeff[1] = sub (exp_en[1], 15);               move16 ();

  000dd	6a 0f		 push	 15			; 0000000fH
  000df	b8 02 00 00 00	 mov	 eax, 2
  000e4	c1 e0 00	 shl	 eax, 0
  000e7	8b 4d 18	 mov	 ecx, DWORD PTR _exp_en$[ebp]
  000ea	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _sub
  000f4	83 c4 08	 add	 esp, 8
  000f7	b9 02 00 00 00	 mov	 ecx, 2
  000fc	c1 e1 00	 shl	 ecx, 0
  000ff	66 89 84 0d 28
	ff ff ff	 mov	 WORD PTR _exp_coeff$[ebp+ecx], ax
  00107	e8 00 00 00 00	 call	 _move16

; 332  : 
; 333  : 
; 334  :     tmp = extract_h (L_shl (L_mult (alpha, frac_en[2]), 1));

  0010c	6a 01		 push	 1
  0010e	b8 02 00 00 00	 mov	 eax, 2
  00113	d1 e0		 shl	 eax, 1
  00115	8b 4d 14	 mov	 ecx, DWORD PTR _frac_en$[ebp]
  00118	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0011c	52		 push	 edx
  0011d	0f b7 45 1c	 movzx	 eax, WORD PTR _alpha$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _L_mult
  00127	83 c4 08	 add	 esp, 8
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _L_shl
  00130	83 c4 08	 add	 esp, 8
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _extract_h
  00139	83 c4 04	 add	 esp, 4
  0013c	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 335  :     coeff[2] = mult (tmp, gain_pit);                  move16 ();

  00140	0f b7 45 08	 movzx	 eax, WORD PTR _gain_pit$[ebp]
  00144	50		 push	 eax
  00145	0f b7 4d d0	 movzx	 ecx, WORD PTR _tmp$[ebp]
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 _mult
  0014f	83 c4 08	 add	 esp, 8
  00152	ba 02 00 00 00	 mov	 edx, 2
  00157	d1 e2		 shl	 edx, 1
  00159	66 89 84 15 50
	ff ff ff	 mov	 WORD PTR _coeff$[ebp+edx], ax
  00161	e8 00 00 00 00	 call	 _move16

; 336  :     exp = sub (exp_gcode0, 10);

  00166	6a 0a		 push	 10			; 0000000aH
  00168	0f b7 45 0c	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _sub
  00172	83 c4 08	 add	 esp, 8
  00175	66 89 45 b8	 mov	 WORD PTR _exp$[ebp], ax

; 337  :     exp_coeff[2] = add (exp_en[2], exp);              move16 ();

  00179	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  0017d	50		 push	 eax
  0017e	b9 02 00 00 00	 mov	 ecx, 2
  00183	d1 e1		 shl	 ecx, 1
  00185	8b 55 18	 mov	 edx, DWORD PTR _exp_en$[ebp]
  00188	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _add
  00192	83 c4 08	 add	 esp, 8
  00195	b9 02 00 00 00	 mov	 ecx, 2
  0019a	d1 e1		 shl	 ecx, 1
  0019c	66 89 84 0d 28
	ff ff ff	 mov	 WORD PTR _exp_coeff$[ebp+ecx], ax
  001a4	e8 00 00 00 00	 call	 _move16

; 338  : 
; 339  : 
; 340  :     /* alpha <= 0.5 -> mult. by 2 to keep precision; compensate in exponent */
; 341  :     coeff[3] = extract_h (L_shl (L_mult (alpha, frac_en[3]), 1));

  001a9	6a 01		 push	 1
  001ab	b8 02 00 00 00	 mov	 eax, 2
  001b0	6b c8 03	 imul	 ecx, eax, 3
  001b3	8b 55 14	 mov	 edx, DWORD PTR _frac_en$[ebp]
  001b6	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  001ba	50		 push	 eax
  001bb	0f b7 4d 1c	 movzx	 ecx, WORD PTR _alpha$[ebp]
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 _L_mult
  001c5	83 c4 08	 add	 esp, 8
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 _L_shl
  001ce	83 c4 08	 add	 esp, 8
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _extract_h
  001d7	83 c4 04	 add	 esp, 4
  001da	ba 02 00 00 00	 mov	 edx, 2
  001df	6b ca 03	 imul	 ecx, edx, 3
  001e2	66 89 84 0d 50
	ff ff ff	 mov	 WORD PTR _coeff$[ebp+ecx], ax

; 342  :     exp = sub (shl (exp_gcode0, 1), 7);

  001ea	6a 07		 push	 7
  001ec	6a 01		 push	 1
  001ee	0f b7 45 0c	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 _shl
  001f8	83 c4 08	 add	 esp, 8
  001fb	0f b7 c8	 movzx	 ecx, ax
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 _sub
  00204	83 c4 08	 add	 esp, 8
  00207	66 89 45 b8	 mov	 WORD PTR _exp$[ebp], ax

; 343  :     exp_coeff[3] = add (exp_en[3], exp);              move16 ();

  0020b	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  0020f	50		 push	 eax
  00210	b9 02 00 00 00	 mov	 ecx, 2
  00215	6b d1 03	 imul	 edx, ecx, 3
  00218	8b 45 18	 mov	 eax, DWORD PTR _exp_en$[ebp]
  0021b	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 _add
  00225	83 c4 08	 add	 esp, 8
  00228	ba 02 00 00 00	 mov	 edx, 2
  0022d	6b ca 03	 imul	 ecx, edx, 3
  00230	66 89 84 0d 28
	ff ff ff	 mov	 WORD PTR _exp_coeff$[ebp+ecx], ax
  00238	e8 00 00 00 00	 call	 _move16

; 344  : 
; 345  : 
; 346  :     coeff[4] = mult (one_alpha, frac_en[3]);          move16 ();

  0023d	b8 02 00 00 00	 mov	 eax, 2
  00242	6b c8 03	 imul	 ecx, eax, 3
  00245	8b 55 14	 mov	 edx, DWORD PTR _frac_en$[ebp]
  00248	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0024c	50		 push	 eax
  0024d	0f b7 4d c4	 movzx	 ecx, WORD PTR _one_alpha$[ebp]
  00251	51		 push	 ecx
  00252	e8 00 00 00 00	 call	 _mult
  00257	83 c4 08	 add	 esp, 8
  0025a	ba 02 00 00 00	 mov	 edx, 2
  0025f	c1 e2 02	 shl	 edx, 2
  00262	66 89 84 15 50
	ff ff ff	 mov	 WORD PTR _coeff$[ebp+edx], ax
  0026a	e8 00 00 00 00	 call	 _move16

; 347  :     exp_coeff[4] = add (exp_coeff[3], 1);             move16 ();

  0026f	6a 01		 push	 1
  00271	b8 02 00 00 00	 mov	 eax, 2
  00276	6b c8 03	 imul	 ecx, eax, 3
  00279	0f b7 94 0d 28
	ff ff ff	 movzx	 edx, WORD PTR _exp_coeff$[ebp+ecx]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 _add
  00287	83 c4 08	 add	 esp, 8
  0028a	b9 02 00 00 00	 mov	 ecx, 2
  0028f	c1 e1 02	 shl	 ecx, 2
  00292	66 89 84 0d 28
	ff ff ff	 mov	 WORD PTR _exp_coeff$[ebp+ecx], ax
  0029a	e8 00 00 00 00	 call	 _move16

; 348  : 
; 349  : 
; 350  :     L_tmp = L_mult (alpha, frac_en[0]);

  0029f	b8 02 00 00 00	 mov	 eax, 2
  002a4	6b c8 00	 imul	 ecx, eax, 0
  002a7	8b 55 14	 mov	 edx, DWORD PTR _frac_en$[ebp]
  002aa	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  002ae	50		 push	 eax
  002af	0f b7 4d 1c	 movzx	 ecx, WORD PTR _alpha$[ebp]
  002b3	51		 push	 ecx
  002b4	e8 00 00 00 00	 call	 _L_mult
  002b9	83 c4 08	 add	 esp, 8
  002bc	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 351  :     /* sqrt_l returns normalized value and 2*exponent
; 352  :        -> result = val >> (exp/2)
; 353  :        exp_coeff holds 2*exponent for c[0]            */
; 354  :     /* directly store in 32 bit variable because no further mult. required */
; 355  :     L_t0 = sqrt_l_exp (L_tmp, &exp); /* normalization included in sqrt_l_exp */

  002c2	8d 45 b8	 lea	 eax, DWORD PTR _exp$[ebp]
  002c5	50		 push	 eax
  002c6	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  002cc	51		 push	 ecx
  002cd	e8 00 00 00 00	 call	 _sqrt_l_exp
  002d2	83 c4 08	 add	 esp, 8
  002d5	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_t0$[ebp], eax

; 356  :                                      move32 (); /* function result */

  002db	e8 00 00 00 00	 call	 _move32

; 357  :     exp = add (exp, 47);

  002e0	6a 2f		 push	 47			; 0000002fH
  002e2	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _add
  002ec	83 c4 08	 add	 esp, 8
  002ef	66 89 45 b8	 mov	 WORD PTR _exp$[ebp], ax

; 358  :     exp_coeff[0] = sub (exp_en[0], exp);              move16 ();

  002f3	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  002f7	50		 push	 eax
  002f8	b9 02 00 00 00	 mov	 ecx, 2
  002fd	6b d1 00	 imul	 edx, ecx, 0
  00300	8b 45 18	 mov	 eax, DWORD PTR _exp_en$[ebp]
  00303	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00307	51		 push	 ecx
  00308	e8 00 00 00 00	 call	 _sub
  0030d	83 c4 08	 add	 esp, 8
  00310	ba 02 00 00 00	 mov	 edx, 2
  00315	6b ca 00	 imul	 ecx, edx, 0
  00318	66 89 84 0d 28
	ff ff ff	 mov	 WORD PTR _exp_coeff$[ebp+ecx], ax
  00320	e8 00 00 00 00	 call	 _move16

; 359  : 
; 360  :     /*
; 361  :      * Determine the maximum exponent occuring in the distance calculation
; 362  :      * and adjust all fractions accordingly (including a safety margin)
; 363  :      *
; 364  :      */
; 365  : 
; 366  :     /* find max(e[1..4],e[0]+31) */
; 367  :     e_max = add (exp_coeff[0], 31);

  00325	6a 1f		 push	 31			; 0000001fH
  00327	b8 02 00 00 00	 mov	 eax, 2
  0032c	6b c8 00	 imul	 ecx, eax, 0
  0032f	0f b7 94 0d 28
	ff ff ff	 movzx	 edx, WORD PTR _exp_coeff$[ebp+ecx]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 _add
  0033d	83 c4 08	 add	 esp, 8
  00340	66 89 45 ac	 mov	 WORD PTR _e_max$[ebp], ax

; 368  :     for (i = 1; i <= 4; i++)

  00344	b8 01 00 00 00	 mov	 eax, 1
  00349	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  0034d	eb 0c		 jmp	 SHORT $LN13@MR795_gain
$LN12@MR795_gain:
  0034f	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  00353	66 83 c0 01	 add	 ax, 1
  00357	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN13@MR795_gain:
  0035b	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  0035f	83 f8 04	 cmp	 eax, 4
  00362	7f 3b		 jg	 SHORT $LN11@MR795_gain

; 369  :     {
; 370  :         test ();

  00364	e8 00 00 00 00	 call	 _test

; 371  :         if (sub (exp_coeff[i], e_max) > 0)

  00369	0f b7 45 ac	 movzx	 eax, WORD PTR _e_max$[ebp]
  0036d	50		 push	 eax
  0036e	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  00372	0f b7 94 4d 28
	ff ff ff	 movzx	 edx, WORD PTR _exp_coeff$[ebp+ecx*2]
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 _sub
  00380	83 c4 08	 add	 esp, 8
  00383	98		 cwde
  00384	85 c0		 test	 eax, eax
  00386	7e 15		 jle	 SHORT $LN10@MR795_gain

; 372  :         {
; 373  :             e_max = exp_coeff[i];                     move16 ();

  00388	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  0038c	66 8b 8c 45 28
	ff ff ff	 mov	 cx, WORD PTR _exp_coeff$[ebp+eax*2]
  00394	66 89 4d ac	 mov	 WORD PTR _e_max$[ebp], cx
  00398	e8 00 00 00 00	 call	 _move16
$LN10@MR795_gain:

; 374  :         }
; 375  :     }

  0039d	eb b0		 jmp	 SHORT $LN12@MR795_gain
$LN11@MR795_gain:

; 376  : 
; 377  :     /* scale c[1]         (requires no further multiplication) */
; 378  :     tmp = sub (e_max, exp_coeff[1]);

  0039f	b8 02 00 00 00	 mov	 eax, 2
  003a4	c1 e0 00	 shl	 eax, 0
  003a7	0f b7 8c 05 28
	ff ff ff	 movzx	 ecx, WORD PTR _exp_coeff$[ebp+eax]
  003af	51		 push	 ecx
  003b0	0f b7 55 ac	 movzx	 edx, WORD PTR _e_max$[ebp]
  003b4	52		 push	 edx
  003b5	e8 00 00 00 00	 call	 _sub
  003ba	83 c4 08	 add	 esp, 8
  003bd	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 379  :     L_t1 = L_shr(L_t1, tmp);

  003c1	0f b7 45 d0	 movzx	 eax, WORD PTR _tmp$[ebp]
  003c5	50		 push	 eax
  003c6	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _L_t1$[ebp]
  003cc	51		 push	 ecx
  003cd	e8 00 00 00 00	 call	 _L_shr
  003d2	83 c4 08	 add	 esp, 8
  003d5	89 85 04 ff ff
	ff		 mov	 DWORD PTR _L_t1$[ebp], eax

; 380  : 
; 381  :     /* scale c[2..4] (used in Mpy_32_16 in the quantizer loop) */
; 382  :     for (i = 2; i <= 4; i++)

  003db	b8 02 00 00 00	 mov	 eax, 2
  003e0	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  003e4	eb 0c		 jmp	 SHORT $LN9@MR795_gain
$LN8@MR795_gain:
  003e6	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  003ea	66 83 c0 01	 add	 ax, 1
  003ee	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN9@MR795_gain:
  003f2	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  003f6	83 f8 04	 cmp	 eax, 4
  003f9	7f 7f		 jg	 SHORT $LN7@MR795_gain

; 383  :     {
; 384  :         tmp = sub (e_max, exp_coeff[i]);

  003fb	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  003ff	0f b7 8c 45 28
	ff ff ff	 movzx	 ecx, WORD PTR _exp_coeff$[ebp+eax*2]
  00407	51		 push	 ecx
  00408	0f b7 55 ac	 movzx	 edx, WORD PTR _e_max$[ebp]
  0040c	52		 push	 edx
  0040d	e8 00 00 00 00	 call	 _sub
  00412	83 c4 08	 add	 esp, 8
  00415	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 385  :         L_tmp = L_deposit_h(coeff[i]);

  00419	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  0041d	0f b7 8c 45 50
	ff ff ff	 movzx	 ecx, WORD PTR _coeff$[ebp+eax*2]
  00425	51		 push	 ecx
  00426	e8 00 00 00 00	 call	 _L_deposit_h
  0042b	83 c4 04	 add	 esp, 4
  0042e	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 386  :         L_tmp = L_shr(L_tmp, tmp);

  00434	0f b7 45 d0	 movzx	 eax, WORD PTR _tmp$[ebp]
  00438	50		 push	 eax
  00439	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  0043f	51		 push	 ecx
  00440	e8 00 00 00 00	 call	 _L_shr
  00445	83 c4 08	 add	 esp, 8
  00448	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 387  :         L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);

  0044e	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00452	8d 8c 45 3c ff
	ff ff		 lea	 ecx, DWORD PTR _coeff_lo$[ebp+eax*2]
  00459	51		 push	 ecx
  0045a	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  0045e	8d 84 55 50 ff
	ff ff		 lea	 eax, DWORD PTR _coeff$[ebp+edx*2]
  00465	50		 push	 eax
  00466	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  0046c	51		 push	 ecx
  0046d	e8 00 00 00 00	 call	 _L_Extract
  00472	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  :     }

  00475	e9 6c ff ff ff	 jmp	 $LN8@MR795_gain
$LN7@MR795_gain:

; 389  : 
; 390  :     /* scale c[0]         (requires no further multiplication) */
; 391  :     exp = sub (e_max, 31);             /* new exponent */

  0047a	6a 1f		 push	 31			; 0000001fH
  0047c	0f b7 45 ac	 movzx	 eax, WORD PTR _e_max$[ebp]
  00480	50		 push	 eax
  00481	e8 00 00 00 00	 call	 _sub
  00486	83 c4 08	 add	 esp, 8
  00489	66 89 45 b8	 mov	 WORD PTR _exp$[ebp], ax

; 392  :     tmp = sub (exp, exp_coeff[0]);

  0048d	b8 02 00 00 00	 mov	 eax, 2
  00492	6b c8 00	 imul	 ecx, eax, 0
  00495	0f b7 94 0d 28
	ff ff ff	 movzx	 edx, WORD PTR _exp_coeff$[ebp+ecx]
  0049d	52		 push	 edx
  0049e	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 _sub
  004a8	83 c4 08	 add	 esp, 8
  004ab	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 393  :     L_t0 = L_shr (L_t0, shr (tmp, 1));

  004af	6a 01		 push	 1
  004b1	0f b7 45 d0	 movzx	 eax, WORD PTR _tmp$[ebp]
  004b5	50		 push	 eax
  004b6	e8 00 00 00 00	 call	 _shr
  004bb	83 c4 08	 add	 esp, 8
  004be	0f b7 c8	 movzx	 ecx, ax
  004c1	51		 push	 ecx
  004c2	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _L_t0$[ebp]
  004c8	52		 push	 edx
  004c9	e8 00 00 00 00	 call	 _L_shr
  004ce	83 c4 08	 add	 esp, 8
  004d1	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_t0$[ebp], eax

; 394  :     /* perform correction by 1/sqrt(2) if exponent difference is odd */
; 395  :     test (); logic16 ();

  004d7	e8 00 00 00 00	 call	 _test
  004dc	e8 00 00 00 00	 call	 _logic16

; 396  :     if ((tmp & 0x1) != 0)

  004e1	0f bf 45 d0	 movsx	 eax, WORD PTR _tmp$[ebp]
  004e5	83 e0 01	 and	 eax, 1
  004e8	74 64		 je	 SHORT $LN6@MR795_gain

; 397  :     {
; 398  :         L_Extract(L_t0, &coeff[0], &coeff_lo[0]);

  004ea	b8 02 00 00 00	 mov	 eax, 2
  004ef	6b c8 00	 imul	 ecx, eax, 0
  004f2	8d 94 0d 3c ff
	ff ff		 lea	 edx, DWORD PTR _coeff_lo$[ebp+ecx]
  004f9	52		 push	 edx
  004fa	b8 02 00 00 00	 mov	 eax, 2
  004ff	6b c8 00	 imul	 ecx, eax, 0
  00502	8d 94 0d 50 ff
	ff ff		 lea	 edx, DWORD PTR _coeff$[ebp+ecx]
  00509	52		 push	 edx
  0050a	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _L_t0$[ebp]
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 _L_Extract
  00516	83 c4 0c	 add	 esp, 12			; 0000000cH

; 399  :         L_t0 = Mpy_32_16(coeff[0], coeff_lo[0],
; 400  :                          23170);                    /* 23170 Q15 = 1/sqrt(2)*/

  00519	68 82 5a 00 00	 push	 23170			; 00005a82H
  0051e	b8 02 00 00 00	 mov	 eax, 2
  00523	6b c8 00	 imul	 ecx, eax, 0
  00526	0f b7 94 0d 3c
	ff ff ff	 movzx	 edx, WORD PTR _coeff_lo$[ebp+ecx]
  0052e	52		 push	 edx
  0052f	b8 02 00 00 00	 mov	 eax, 2
  00534	6b c8 00	 imul	 ecx, eax, 0
  00537	0f b7 94 0d 50
	ff ff ff	 movzx	 edx, WORD PTR _coeff$[ebp+ecx]
  0053f	52		 push	 edx
  00540	e8 00 00 00 00	 call	 _Mpy_32_16
  00545	83 c4 0c	 add	 esp, 12			; 0000000cH
  00548	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_t0$[ebp], eax
$LN6@MR795_gain:

; 401  :     }
; 402  : 
; 403  :     /* search the quantizer table for the lowest value
; 404  :        of the search criterion                           */
; 405  :     dist_min = MAX_32; move32 ();

  0054e	c7 85 f8 fe ff
	ff ff ff ff 7f	 mov	 DWORD PTR _dist_min$[ebp], 2147483647 ; 7fffffffH
  00558	e8 00 00 00 00	 call	 _move32

; 406  :     index = 0;         move16 ();

  0055d	33 c0		 xor	 eax, eax
  0055f	66 89 45 dc	 mov	 WORD PTR _index$[ebp], ax
  00563	e8 00 00 00 00	 call	 _move16

; 407  :     p = &qua_gain_code[0]; move16 ();

  00568	b8 02 00 00 00	 mov	 eax, 2
  0056d	6b c8 00	 imul	 ecx, eax, 0
  00570	81 c1 00 00 00
	00		 add	 ecx, OFFSET _qua_gain_code
  00576	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx
  00579	e8 00 00 00 00	 call	 _move16

; 408  : 
; 409  :     for (i = 0; i < NB_QUA_CODE; i++)

  0057e	33 c0		 xor	 eax, eax
  00580	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  00584	eb 0c		 jmp	 SHORT $LN5@MR795_gain
$LN4@MR795_gain:
  00586	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  0058a	66 83 c0 01	 add	 ax, 1
  0058e	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN5@MR795_gain:
  00592	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00596	83 f8 20	 cmp	 eax, 32			; 00000020H
  00599	0f 8d 66 02 00
	00		 jge	 $LN3@MR795_gain

; 410  :     {
; 411  :         g_code = *p++;        move16 (); /* this is g_fac (Q11)  */

  0059f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005a2	66 8b 08	 mov	 cx, WORD PTR [eax]
  005a5	66 89 4d 94	 mov	 WORD PTR _g_code$[ebp], cx
  005a9	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  005ac	83 c2 02	 add	 edx, 2
  005af	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  005b2	e8 00 00 00 00	 call	 _move16

; 412  :         p++;                             /* skip log2(g_fac)     */

  005b7	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005ba	83 c0 02	 add	 eax, 2
  005bd	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 413  :         p++;                             /* skip 20*log10(g_fac) */

  005c0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005c3	83 c0 02	 add	 eax, 2
  005c6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 414  :         g_code = mult (g_code, gcode0);

  005c9	0f b7 45 10	 movzx	 eax, WORD PTR _gcode0$[ebp]
  005cd	50		 push	 eax
  005ce	0f b7 4d 94	 movzx	 ecx, WORD PTR _g_code$[ebp]
  005d2	51		 push	 ecx
  005d3	e8 00 00 00 00	 call	 _mult
  005d8	83 c4 08	 add	 esp, 8
  005db	66 89 45 94	 mov	 WORD PTR _g_code$[ebp], ax

; 415  : 
; 416  :         /* only continue if    gc[i]            < 2.0*gc
; 417  :            which is equiv. to  g_code (Q10-ec0) < gain_code (Q11-ec0) */
; 418  :         test ();

  005df	e8 00 00 00 00	 call	 _test

; 419  :         if (sub (g_code, gain_code) >= 0)

  005e4	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _gain_code$[ebp]
  005eb	50		 push	 eax
  005ec	0f b7 4d 94	 movzx	 ecx, WORD PTR _g_code$[ebp]
  005f0	51		 push	 ecx
  005f1	e8 00 00 00 00	 call	 _sub
  005f6	83 c4 08	 add	 esp, 8
  005f9	0f bf d0	 movsx	 edx, ax
  005fc	85 d2		 test	 edx, edx
  005fe	7c 05		 jl	 SHORT $LN2@MR795_gain

; 420  :             break;

  00600	e9 00 02 00 00	 jmp	 $LN3@MR795_gain
$LN2@MR795_gain:

; 421  : 
; 422  :         L_tmp = L_mult (g_code, g_code);

  00605	0f b7 45 94	 movzx	 eax, WORD PTR _g_code$[ebp]
  00609	50		 push	 eax
  0060a	0f b7 4d 94	 movzx	 ecx, WORD PTR _g_code$[ebp]
  0060e	51		 push	 ecx
  0060f	e8 00 00 00 00	 call	 _L_mult
  00614	83 c4 08	 add	 esp, 8
  00617	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 423  :         L_Extract (L_tmp, &g2_code_h, &g2_code_l);

  0061d	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _g2_code_l$[ebp]
  00623	50		 push	 eax
  00624	8d 4d 88	 lea	 ecx, DWORD PTR _g2_code_h$[ebp]
  00627	51		 push	 ecx
  00628	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  0062e	52		 push	 edx
  0062f	e8 00 00 00 00	 call	 _L_Extract
  00634	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  : 
; 425  :         tmp = sub (g_code, gain_cod_unq);

  00637	0f b7 45 20	 movzx	 eax, WORD PTR _gain_cod_unq$[ebp]
  0063b	50		 push	 eax
  0063c	0f b7 4d 94	 movzx	 ecx, WORD PTR _g_code$[ebp]
  00640	51		 push	 ecx
  00641	e8 00 00 00 00	 call	 _sub
  00646	83 c4 08	 add	 esp, 8
  00649	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 426  :         L_tmp = L_mult (tmp, tmp);

  0064d	0f b7 45 d0	 movzx	 eax, WORD PTR _tmp$[ebp]
  00651	50		 push	 eax
  00652	0f b7 4d d0	 movzx	 ecx, WORD PTR _tmp$[ebp]
  00656	51		 push	 ecx
  00657	e8 00 00 00 00	 call	 _L_mult
  0065c	83 c4 08	 add	 esp, 8
  0065f	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 427  :         L_Extract (L_tmp, &d2_code_h, &d2_code_l);

  00665	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _d2_code_l$[ebp]
  0066b	50		 push	 eax
  0066c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _d2_code_h$[ebp]
  00672	51		 push	 ecx
  00673	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  00679	52		 push	 edx
  0067a	e8 00 00 00 00	 call	 _L_Extract
  0067f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 
; 429  :         /* t2, t3, t4 */
; 430  :         L_tmp = Mac_32_16 (L_t1, coeff[2], coeff_lo[2], g_code);

  00682	0f b7 45 94	 movzx	 eax, WORD PTR _g_code$[ebp]
  00686	50		 push	 eax
  00687	b9 02 00 00 00	 mov	 ecx, 2
  0068c	d1 e1		 shl	 ecx, 1
  0068e	0f b7 94 0d 3c
	ff ff ff	 movzx	 edx, WORD PTR _coeff_lo$[ebp+ecx]
  00696	52		 push	 edx
  00697	b8 02 00 00 00	 mov	 eax, 2
  0069c	d1 e0		 shl	 eax, 1
  0069e	0f b7 8c 05 50
	ff ff ff	 movzx	 ecx, WORD PTR _coeff$[ebp+eax]
  006a6	51		 push	 ecx
  006a7	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _L_t1$[ebp]
  006ad	52		 push	 edx
  006ae	e8 00 00 00 00	 call	 _Mac_32_16
  006b3	83 c4 10	 add	 esp, 16			; 00000010H
  006b6	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 431  :         L_tmp = Mac_32(L_tmp,    coeff[3], coeff_lo[3], g2_code_h, g2_code_l);

  006bc	0f b7 85 7c ff
	ff ff		 movzx	 eax, WORD PTR _g2_code_l$[ebp]
  006c3	50		 push	 eax
  006c4	0f b7 4d 88	 movzx	 ecx, WORD PTR _g2_code_h$[ebp]
  006c8	51		 push	 ecx
  006c9	ba 02 00 00 00	 mov	 edx, 2
  006ce	6b c2 03	 imul	 eax, edx, 3
  006d1	0f b7 8c 05 3c
	ff ff ff	 movzx	 ecx, WORD PTR _coeff_lo$[ebp+eax]
  006d9	51		 push	 ecx
  006da	ba 02 00 00 00	 mov	 edx, 2
  006df	6b c2 03	 imul	 eax, edx, 3
  006e2	0f b7 8c 05 50
	ff ff ff	 movzx	 ecx, WORD PTR _coeff$[ebp+eax]
  006ea	51		 push	 ecx
  006eb	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  006f1	52		 push	 edx
  006f2	e8 00 00 00 00	 call	 _Mac_32
  006f7	83 c4 14	 add	 esp, 20			; 00000014H
  006fa	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 432  : 
; 433  :         L_tmp = sqrt_l_exp (L_tmp, &exp);

  00700	8d 45 b8	 lea	 eax, DWORD PTR _exp$[ebp]
  00703	50		 push	 eax
  00704	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  0070a	51		 push	 ecx
  0070b	e8 00 00 00 00	 call	 _sqrt_l_exp
  00710	83 c4 08	 add	 esp, 8
  00713	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 434  :         L_tmp = L_shr (L_tmp, shr (exp, 1));

  00719	6a 01		 push	 1
  0071b	0f b7 45 b8	 movzx	 eax, WORD PTR _exp$[ebp]
  0071f	50		 push	 eax
  00720	e8 00 00 00 00	 call	 _shr
  00725	83 c4 08	 add	 esp, 8
  00728	0f b7 c8	 movzx	 ecx, ax
  0072b	51		 push	 ecx
  0072c	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  00732	52		 push	 edx
  00733	e8 00 00 00 00	 call	 _L_shr
  00738	83 c4 08	 add	 esp, 8
  0073b	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 435  : 
; 436  :         /* d2 */
; 437  :         tmp = round (L_sub (L_tmp, L_t0));

  00741	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _L_t0$[ebp]
  00747	50		 push	 eax
  00748	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  0074e	51		 push	 ecx
  0074f	e8 00 00 00 00	 call	 _L_sub
  00754	83 c4 08	 add	 esp, 8
  00757	50		 push	 eax
  00758	e8 00 00 00 00	 call	 _round
  0075d	83 c4 04	 add	 esp, 4
  00760	66 89 45 d0	 mov	 WORD PTR _tmp$[ebp], ax

; 438  :         L_tmp = L_mult (tmp, tmp);

  00764	0f b7 45 d0	 movzx	 eax, WORD PTR _tmp$[ebp]
  00768	50		 push	 eax
  00769	0f b7 4d d0	 movzx	 ecx, WORD PTR _tmp$[ebp]
  0076d	51		 push	 ecx
  0076e	e8 00 00 00 00	 call	 _L_mult
  00773	83 c4 08	 add	 esp, 8
  00776	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 439  : 
; 440  :         /* dist */
; 441  :         L_tmp = Mac_32(L_tmp, coeff[4], coeff_lo[4], d2_code_h, d2_code_l);

  0077c	0f b7 85 64 ff
	ff ff		 movzx	 eax, WORD PTR _d2_code_l$[ebp]
  00783	50		 push	 eax
  00784	0f b7 8d 70 ff
	ff ff		 movzx	 ecx, WORD PTR _d2_code_h$[ebp]
  0078b	51		 push	 ecx
  0078c	ba 02 00 00 00	 mov	 edx, 2
  00791	c1 e2 02	 shl	 edx, 2
  00794	0f b7 84 15 3c
	ff ff ff	 movzx	 eax, WORD PTR _coeff_lo$[ebp+edx]
  0079c	50		 push	 eax
  0079d	b9 02 00 00 00	 mov	 ecx, 2
  007a2	c1 e1 02	 shl	 ecx, 2
  007a5	0f b7 94 0d 50
	ff ff ff	 movzx	 edx, WORD PTR _coeff$[ebp+ecx]
  007ad	52		 push	 edx
  007ae	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  007b4	50		 push	 eax
  007b5	e8 00 00 00 00	 call	 _Mac_32
  007ba	83 c4 14	 add	 esp, 20			; 00000014H
  007bd	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 442  : 
; 443  :         /* store table index if distance measure for this
; 444  :             index is lower than the minimum seen so far   */
; 445  :         test ();

  007c3	e8 00 00 00 00	 call	 _test

; 446  :         if (L_sub (L_tmp, dist_min) < (Word32) 0)

  007c8	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _dist_min$[ebp]
  007ce	50		 push	 eax
  007cf	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  007d5	51		 push	 ecx
  007d6	e8 00 00 00 00	 call	 _L_sub
  007db	83 c4 08	 add	 esp, 8
  007de	85 c0		 test	 eax, eax
  007e0	7d 1e		 jge	 SHORT $LN1@MR795_gain

; 447  :         {
; 448  :             dist_min = L_tmp;                move16 ();

  007e2	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  007e8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _dist_min$[ebp], eax
  007ee	e8 00 00 00 00	 call	 _move16

; 449  :             index = i;                       move16 ();

  007f3	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  007f7	66 89 45 dc	 mov	 WORD PTR _index$[ebp], ax
  007fb	e8 00 00 00 00	 call	 _move16
$LN1@MR795_gain:

; 450  :         }
; 451  :     }

  00800	e9 81 fd ff ff	 jmp	 $LN4@MR795_gain
$LN3@MR795_gain:

; 452  : 
; 453  :     /*------------------------------------------------------------------*
; 454  :      *  read quantized gains and new values for MA predictor memories   *
; 455  :      *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
; 456  :      *------------------------------------------------------------------*/
; 457  : 
; 458  :     /* Read the quantized gains */
; 459  :     p = &qua_gain_code[add (add (index, index), index)]; move16 ();

  00805	0f b7 45 dc	 movzx	 eax, WORD PTR _index$[ebp]
  00809	50		 push	 eax
  0080a	0f b7 4d dc	 movzx	 ecx, WORD PTR _index$[ebp]
  0080e	51		 push	 ecx
  0080f	0f b7 55 dc	 movzx	 edx, WORD PTR _index$[ebp]
  00813	52		 push	 edx
  00814	e8 00 00 00 00	 call	 _add
  00819	83 c4 08	 add	 esp, 8
  0081c	0f b7 c0	 movzx	 eax, ax
  0081f	50		 push	 eax
  00820	e8 00 00 00 00	 call	 _add
  00825	83 c4 08	 add	 esp, 8
  00828	0f bf c8	 movsx	 ecx, ax
  0082b	8d 14 4d 00 00
	00 00		 lea	 edx, DWORD PTR _qua_gain_code[ecx*2]
  00832	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00835	e8 00 00 00 00	 call	 _move16

; 460  :     g_code = *p++;            move16();

  0083a	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0083d	66 8b 08	 mov	 cx, WORD PTR [eax]
  00840	66 89 4d 94	 mov	 WORD PTR _g_code$[ebp], cx
  00844	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00847	83 c2 02	 add	 edx, 2
  0084a	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  0084d	e8 00 00 00 00	 call	 _move16

; 461  :     *qua_ener_MR122 = *p++;   move16();

  00852	8b 45 28	 mov	 eax, DWORD PTR _qua_ener_MR122$[ebp]
  00855	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00858	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0085b	66 89 10	 mov	 WORD PTR [eax], dx
  0085e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00861	83 c0 02	 add	 eax, 2
  00864	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00867	e8 00 00 00 00	 call	 _move16

; 462  :     *qua_ener = *p;           move16();

  0086c	8b 45 2c	 mov	 eax, DWORD PTR _qua_ener$[ebp]
  0086f	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  00872	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00875	66 89 10	 mov	 WORD PTR [eax], dx
  00878	e8 00 00 00 00	 call	 _move16

; 463  : 
; 464  :     /*------------------------------------------------------------------*
; 465  :      *  calculate final fixed codebook gain:                            *
; 466  :      *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
; 467  :      *                                                                  *
; 468  :      *   gc = gc0 * g                                                   *
; 469  :      *------------------------------------------------------------------*/
; 470  : 
; 471  :     L_tmp = L_mult(g_code, gcode0);

  0087d	0f b7 45 10	 movzx	 eax, WORD PTR _gcode0$[ebp]
  00881	50		 push	 eax
  00882	0f b7 4d 94	 movzx	 ecx, WORD PTR _g_code$[ebp]
  00886	51		 push	 ecx
  00887	e8 00 00 00 00	 call	 _L_mult
  0088c	83 c4 08	 add	 esp, 8
  0088f	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 472  :     L_tmp = L_shr(L_tmp, sub(9, exp_gcode0));

  00895	0f b7 45 0c	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  00899	50		 push	 eax
  0089a	6a 09		 push	 9
  0089c	e8 00 00 00 00	 call	 _sub
  008a1	83 c4 08	 add	 esp, 8
  008a4	0f b7 c8	 movzx	 ecx, ax
  008a7	51		 push	 ecx
  008a8	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  008ae	52		 push	 edx
  008af	e8 00 00 00 00	 call	 _L_shr
  008b4	83 c4 08	 add	 esp, 8
  008b7	89 85 1c ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 473  :     *gain_cod = extract_h(L_tmp);

  008bd	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  008c3	50		 push	 eax
  008c4	e8 00 00 00 00	 call	 _extract_h
  008c9	83 c4 04	 add	 esp, 4
  008cc	8b 4d 24	 mov	 ecx, DWORD PTR _gain_cod$[ebp]
  008cf	66 89 01	 mov	 WORD PTR [ecx], ax

; 474  : 
; 475  :     return index;

  008d2	66 8b 45 dc	 mov	 ax, WORD PTR _index$[ebp]

; 476  : }

  008d6	52		 push	 edx
  008d7	8b cd		 mov	 ecx, ebp
  008d9	50		 push	 eax
  008da	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@MR795_gain
  008e0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  008e5	58		 pop	 eax
  008e6	5a		 pop	 edx
  008e7	5f		 pop	 edi
  008e8	5e		 pop	 esi
  008e9	5b		 pop	 ebx
  008ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008ed	33 cd		 xor	 ecx, ebp
  008ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008f4	81 c4 d8 01 00
	00		 add	 esp, 472		; 000001d8H
  008fa	3b ec		 cmp	 ebp, esp
  008fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00901	8b e5		 mov	 esp, ebp
  00903	5d		 pop	 ebp
  00904	c3		 ret	 0
  00905	8d 49 00	 npad	 3
$LN25@MR795_gain:
  00908	08 00 00 00	 DD	 8
  0090c	00 00 00 00	 DD	 $LN24@MR795_gain
$LN24@MR795_gain:
  00910	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00914	02 00 00 00	 DD	 2
  00918	00 00 00 00	 DD	 $LN16@MR795_gain
  0091c	88 ff ff ff	 DD	 -120			; ffffff88H
  00920	02 00 00 00	 DD	 2
  00924	00 00 00 00	 DD	 $LN17@MR795_gain
  00928	7c ff ff ff	 DD	 -132			; ffffff7cH
  0092c	02 00 00 00	 DD	 2
  00930	00 00 00 00	 DD	 $LN18@MR795_gain
  00934	70 ff ff ff	 DD	 -144			; ffffff70H
  00938	02 00 00 00	 DD	 2
  0093c	00 00 00 00	 DD	 $LN19@MR795_gain
  00940	64 ff ff ff	 DD	 -156			; ffffff64H
  00944	02 00 00 00	 DD	 2
  00948	00 00 00 00	 DD	 $LN20@MR795_gain
  0094c	50 ff ff ff	 DD	 -176			; ffffff50H
  00950	0a 00 00 00	 DD	 10			; 0000000aH
  00954	00 00 00 00	 DD	 $LN21@MR795_gain
  00958	3c ff ff ff	 DD	 -196			; ffffff3cH
  0095c	0a 00 00 00	 DD	 10			; 0000000aH
  00960	00 00 00 00	 DD	 $LN22@MR795_gain
  00964	28 ff ff ff	 DD	 -216			; ffffff28H
  00968	0a 00 00 00	 DD	 10			; 0000000aH
  0096c	00 00 00 00	 DD	 $LN23@MR795_gain
$LN23@MR795_gain:
  00970	65		 DB	 101			; 00000065H
  00971	78		 DB	 120			; 00000078H
  00972	70		 DB	 112			; 00000070H
  00973	5f		 DB	 95			; 0000005fH
  00974	63		 DB	 99			; 00000063H
  00975	6f		 DB	 111			; 0000006fH
  00976	65		 DB	 101			; 00000065H
  00977	66		 DB	 102			; 00000066H
  00978	66		 DB	 102			; 00000066H
  00979	00		 DB	 0
$LN22@MR795_gain:
  0097a	63		 DB	 99			; 00000063H
  0097b	6f		 DB	 111			; 0000006fH
  0097c	65		 DB	 101			; 00000065H
  0097d	66		 DB	 102			; 00000066H
  0097e	66		 DB	 102			; 00000066H
  0097f	5f		 DB	 95			; 0000005fH
  00980	6c		 DB	 108			; 0000006cH
  00981	6f		 DB	 111			; 0000006fH
  00982	00		 DB	 0
$LN21@MR795_gain:
  00983	63		 DB	 99			; 00000063H
  00984	6f		 DB	 111			; 0000006fH
  00985	65		 DB	 101			; 00000065H
  00986	66		 DB	 102			; 00000066H
  00987	66		 DB	 102			; 00000066H
  00988	00		 DB	 0
$LN20@MR795_gain:
  00989	64		 DB	 100			; 00000064H
  0098a	32		 DB	 50			; 00000032H
  0098b	5f		 DB	 95			; 0000005fH
  0098c	63		 DB	 99			; 00000063H
  0098d	6f		 DB	 111			; 0000006fH
  0098e	64		 DB	 100			; 00000064H
  0098f	65		 DB	 101			; 00000065H
  00990	5f		 DB	 95			; 0000005fH
  00991	6c		 DB	 108			; 0000006cH
  00992	00		 DB	 0
$LN19@MR795_gain:
  00993	64		 DB	 100			; 00000064H
  00994	32		 DB	 50			; 00000032H
  00995	5f		 DB	 95			; 0000005fH
  00996	63		 DB	 99			; 00000063H
  00997	6f		 DB	 111			; 0000006fH
  00998	64		 DB	 100			; 00000064H
  00999	65		 DB	 101			; 00000065H
  0099a	5f		 DB	 95			; 0000005fH
  0099b	68		 DB	 104			; 00000068H
  0099c	00		 DB	 0
$LN18@MR795_gain:
  0099d	67		 DB	 103			; 00000067H
  0099e	32		 DB	 50			; 00000032H
  0099f	5f		 DB	 95			; 0000005fH
  009a0	63		 DB	 99			; 00000063H
  009a1	6f		 DB	 111			; 0000006fH
  009a2	64		 DB	 100			; 00000064H
  009a3	65		 DB	 101			; 00000065H
  009a4	5f		 DB	 95			; 0000005fH
  009a5	6c		 DB	 108			; 0000006cH
  009a6	00		 DB	 0
$LN17@MR795_gain:
  009a7	67		 DB	 103			; 00000067H
  009a8	32		 DB	 50			; 00000032H
  009a9	5f		 DB	 95			; 0000005fH
  009aa	63		 DB	 99			; 00000063H
  009ab	6f		 DB	 111			; 0000006fH
  009ac	64		 DB	 100			; 00000064H
  009ad	65		 DB	 101			; 00000065H
  009ae	5f		 DB	 95			; 0000005fH
  009af	68		 DB	 104			; 00000068H
  009b0	00		 DB	 0
$LN16@MR795_gain:
  009b1	65		 DB	 101			; 00000065H
  009b2	78		 DB	 120			; 00000078H
  009b3	70		 DB	 112			; 00000070H
  009b4	00		 DB	 0
_MR795_gain_code_quant_mod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\qgain795.c
;	COMDAT _MR795_gain_code_quant3
_TEXT	SEGMENT
_dist_min$ = -264					; size = 4
_L_tmp0$ = -252						; size = 4
_L_tmp$ = -240						; size = 4
_exp_max$ = -228					; size = 10
_coeff_lo$ = -208					; size = 10
_coeff$ = -188						; size = 10
_g_pit_cod_l$ = -168					; size = 2
_g_pit_cod_h$ = -156					; size = 2
_g2_code_l$ = -144					; size = 2
_g2_code_h$ = -132					; size = 2
_g_code$ = -120						; size = 2
_g2_pitch$ = -108					; size = 2
_g_pitch$ = -96						; size = 2
_exp_code$ = -84					; size = 2
_e_max$ = -72						; size = 2
_pit_ind$ = -60						; size = 2
_cod_ind$ = -48						; size = 2
_j$ = -36						; size = 2
_i$ = -24						; size = 2
_p$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_exp_gcode0$ = 8					; size = 2
_gcode0$ = 12						; size = 2
_g_pitch_cand$ = 16					; size = 4
_g_pitch_cind$ = 20					; size = 4
_frac_coeff$ = 24					; size = 4
_exp_coeff$ = 28					; size = 4
_gain_pit$ = 32						; size = 4
_gain_pit_ind$ = 36					; size = 4
_gain_cod$ = 40						; size = 4
_gain_cod_ind$ = 44					; size = 4
_qua_ener_MR122$ = 48					; size = 4
_qua_ener$ = 52						; size = 4
_MR795_gain_code_quant3 PROC				; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-460]
  00012	b9 73 00 00 00	 mov	 ecx, 115		; 00000073H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 85   :     const Word16 *p;
; 86   :     Word16 i, j, cod_ind, pit_ind;
; 87   :     Word16 e_max, exp_code;
; 88   :     Word16 g_pitch, g2_pitch, g_code, g2_code_h, g2_code_l;
; 89   :     Word16 g_pit_cod_h, g_pit_cod_l;
; 90   :     Word16 coeff[5], coeff_lo[5];
; 91   :     Word16 exp_max[5];
; 92   :     Word32 L_tmp, L_tmp0, dist_min;
; 93   : 
; 94   :     /*
; 95   :      * The error energy (sum) to be minimized consists of five terms, t[0..4].
; 96   :      *
; 97   :      *                      t[0] =    gp^2  * <y1 y1>
; 98   :      *                      t[1] = -2*gp    * <xn y1>
; 99   :      *                      t[2] =    gc^2  * <y2 y2>
; 100  :      *                      t[3] = -2*gc    * <xn y2>
; 101  :      *                      t[4] =  2*gp*gc * <y1 y2>
; 102  :      *
; 103  :      */
; 104  : 
; 105  :     /* determine the scaling exponent for g_code: ec = ec0 - 10 */
; 106  :     exp_code = sub(exp_gcode0, 10);

  00028	6a 0a		 push	 10			; 0000000aH
  0002a	0f b7 45 08	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _sub
  00034	83 c4 08	 add	 esp, 8
  00037	66 89 45 ac	 mov	 WORD PTR _exp_code$[ebp], ax

; 107  : 
; 108  :     /* calculate exp_max[i] = s[i]-1 */
; 109  :     exp_max[0] = sub(exp_coeff[0], 13);                        move16 ();

  0003b	6a 0d		 push	 13			; 0000000dH
  0003d	b8 02 00 00 00	 mov	 eax, 2
  00042	6b c8 00	 imul	 ecx, eax, 0
  00045	8b 55 1c	 mov	 edx, DWORD PTR _exp_coeff$[ebp]
  00048	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _sub
  00052	83 c4 08	 add	 esp, 8
  00055	b9 02 00 00 00	 mov	 ecx, 2
  0005a	6b d1 00	 imul	 edx, ecx, 0
  0005d	66 89 84 15 1c
	ff ff ff	 mov	 WORD PTR _exp_max$[ebp+edx], ax
  00065	e8 00 00 00 00	 call	 _move16

; 110  :     exp_max[1] = sub(exp_coeff[1], 14);                        move16 ();

  0006a	6a 0e		 push	 14			; 0000000eH
  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	c1 e0 00	 shl	 eax, 0
  00074	8b 4d 1c	 mov	 ecx, DWORD PTR _exp_coeff$[ebp]
  00077	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _sub
  00081	83 c4 08	 add	 esp, 8
  00084	b9 02 00 00 00	 mov	 ecx, 2
  00089	c1 e1 00	 shl	 ecx, 0
  0008c	66 89 84 0d 1c
	ff ff ff	 mov	 WORD PTR _exp_max$[ebp+ecx], ax
  00094	e8 00 00 00 00	 call	 _move16

; 111  :     exp_max[2] = add(exp_coeff[2], add(15, shl(exp_code, 1))); move16 ();

  00099	6a 01		 push	 1
  0009b	0f b7 45 ac	 movzx	 eax, WORD PTR _exp_code$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _shl
  000a5	83 c4 08	 add	 esp, 8
  000a8	0f b7 c8	 movzx	 ecx, ax
  000ab	51		 push	 ecx
  000ac	6a 0f		 push	 15			; 0000000fH
  000ae	e8 00 00 00 00	 call	 _add
  000b3	83 c4 08	 add	 esp, 8
  000b6	0f b7 d0	 movzx	 edx, ax
  000b9	52		 push	 edx
  000ba	b8 02 00 00 00	 mov	 eax, 2
  000bf	d1 e0		 shl	 eax, 1
  000c1	8b 4d 1c	 mov	 ecx, DWORD PTR _exp_coeff$[ebp]
  000c4	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _add
  000ce	83 c4 08	 add	 esp, 8
  000d1	b9 02 00 00 00	 mov	 ecx, 2
  000d6	d1 e1		 shl	 ecx, 1
  000d8	66 89 84 0d 1c
	ff ff ff	 mov	 WORD PTR _exp_max$[ebp+ecx], ax
  000e0	e8 00 00 00 00	 call	 _move16

; 112  :     exp_max[3] = add(exp_coeff[3], exp_code);                  move16 ();

  000e5	0f b7 45 ac	 movzx	 eax, WORD PTR _exp_code$[ebp]
  000e9	50		 push	 eax
  000ea	b9 02 00 00 00	 mov	 ecx, 2
  000ef	6b d1 03	 imul	 edx, ecx, 3
  000f2	8b 45 1c	 mov	 eax, DWORD PTR _exp_coeff$[ebp]
  000f5	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 _add
  000ff	83 c4 08	 add	 esp, 8
  00102	ba 02 00 00 00	 mov	 edx, 2
  00107	6b ca 03	 imul	 ecx, edx, 3
  0010a	66 89 84 0d 1c
	ff ff ff	 mov	 WORD PTR _exp_max$[ebp+ecx], ax
  00112	e8 00 00 00 00	 call	 _move16

; 113  :     exp_max[4] = add(exp_coeff[4], add(exp_code,1));           move16 ();

  00117	6a 01		 push	 1
  00119	0f b7 45 ac	 movzx	 eax, WORD PTR _exp_code$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _add
  00123	83 c4 08	 add	 esp, 8
  00126	0f b7 c8	 movzx	 ecx, ax
  00129	51		 push	 ecx
  0012a	ba 02 00 00 00	 mov	 edx, 2
  0012f	c1 e2 02	 shl	 edx, 2
  00132	8b 45 1c	 mov	 eax, DWORD PTR _exp_coeff$[ebp]
  00135	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _add
  0013f	83 c4 08	 add	 esp, 8
  00142	ba 02 00 00 00	 mov	 edx, 2
  00147	c1 e2 02	 shl	 edx, 2
  0014a	66 89 84 15 1c
	ff ff ff	 mov	 WORD PTR _exp_max$[ebp+edx], ax
  00152	e8 00 00 00 00	 call	 _move16

; 114  : 
; 115  : 
; 116  :     /*-------------------------------------------------------------------*
; 117  :      *  Find maximum exponent:                                           *
; 118  :      *  ~~~~~~~~~~~~~~~~~~~~~~                                           *
; 119  :      *                                                                   *
; 120  :      *  For the sum operation, all terms must have the same scaling;     *
; 121  :      *  that scaling should be low enough to prevent overflow. There-    *
; 122  :      *  fore, the maximum scale is determined and all coefficients are   *
; 123  :      *  re-scaled:                                                       *
; 124  :      *                                                                   *
; 125  :      *    e_max = max(exp_max[i]) + 1;                                   *
; 126  :      *    e = exp_max[i]-e_max;         e <= 0!                          *
; 127  :      *    c[i] = c[i]*2^e                                                *
; 128  :      *-------------------------------------------------------------------*/
; 129  : 
; 130  :     e_max = exp_max[0];                                        move16 ();

  00157	b8 02 00 00 00	 mov	 eax, 2
  0015c	6b c8 00	 imul	 ecx, eax, 0
  0015f	66 8b 94 0d 1c
	ff ff ff	 mov	 dx, WORD PTR _exp_max$[ebp+ecx]
  00167	66 89 55 b8	 mov	 WORD PTR _e_max$[ebp], dx
  0016b	e8 00 00 00 00	 call	 _move16

; 131  :     for (i = 1; i < 5; i++)     /* implemented flattened */

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  00179	eb 0c		 jmp	 SHORT $LN14@MR795_gain
$LN13@MR795_gain:
  0017b	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  0017f	66 83 c0 01	 add	 ax, 1
  00183	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN14@MR795_gain:
  00187	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  0018b	83 f8 05	 cmp	 eax, 5
  0018e	7d 40		 jge	 SHORT $LN12@MR795_gain

; 132  :     {
; 133  :         move16(); test();

  00190	e8 00 00 00 00	 call	 _move16
  00195	e8 00 00 00 00	 call	 _test

; 134  :         if (sub(exp_max[i], e_max) > 0)

  0019a	0f b7 45 b8	 movzx	 eax, WORD PTR _e_max$[ebp]
  0019e	50		 push	 eax
  0019f	0f bf 4d e8	 movsx	 ecx, WORD PTR _i$[ebp]
  001a3	0f b7 94 4d 1c
	ff ff ff	 movzx	 edx, WORD PTR _exp_max$[ebp+ecx*2]
  001ab	52		 push	 edx
  001ac	e8 00 00 00 00	 call	 _sub
  001b1	83 c4 08	 add	 esp, 8
  001b4	98		 cwde
  001b5	85 c0		 test	 eax, eax
  001b7	7e 15		 jle	 SHORT $LN11@MR795_gain

; 135  :         {
; 136  :             e_max = exp_max[i];                                move16 ();

  001b9	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  001bd	66 8b 8c 45 1c
	ff ff ff	 mov	 cx, WORD PTR _exp_max$[ebp+eax*2]
  001c5	66 89 4d b8	 mov	 WORD PTR _e_max$[ebp], cx
  001c9	e8 00 00 00 00	 call	 _move16
$LN11@MR795_gain:

; 137  :         }
; 138  :     }

  001ce	eb ab		 jmp	 SHORT $LN13@MR795_gain
$LN12@MR795_gain:

; 139  : 
; 140  :     e_max = add(e_max, 1);      /* To avoid overflow */

  001d0	6a 01		 push	 1
  001d2	0f b7 45 b8	 movzx	 eax, WORD PTR _e_max$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _add
  001dc	83 c4 08	 add	 esp, 8
  001df	66 89 45 b8	 mov	 WORD PTR _e_max$[ebp], ax

; 141  : 
; 142  :     for (i = 0; i < 5; i++) {

  001e3	33 c0		 xor	 eax, eax
  001e5	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  001e9	eb 0c		 jmp	 SHORT $LN10@MR795_gain
$LN9@MR795_gain:
  001eb	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  001ef	66 83 c0 01	 add	 ax, 1
  001f3	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN10@MR795_gain:
  001f7	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  001fb	83 f8 05	 cmp	 eax, 5
  001fe	7d 7e		 jge	 SHORT $LN8@MR795_gain

; 143  :         j = sub(e_max, exp_max[i]);

  00200	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00204	0f b7 8c 45 1c
	ff ff ff	 movzx	 ecx, WORD PTR _exp_max$[ebp+eax*2]
  0020c	51		 push	 ecx
  0020d	0f b7 55 b8	 movzx	 edx, WORD PTR _e_max$[ebp]
  00211	52		 push	 edx
  00212	e8 00 00 00 00	 call	 _sub
  00217	83 c4 08	 add	 esp, 8
  0021a	66 89 45 dc	 mov	 WORD PTR _j$[ebp], ax

; 144  :         L_tmp = L_deposit_h(frac_coeff[i]);

  0021e	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00222	8b 4d 18	 mov	 ecx, DWORD PTR _frac_coeff$[ebp]
  00225	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00229	52		 push	 edx
  0022a	e8 00 00 00 00	 call	 _L_deposit_h
  0022f	83 c4 04	 add	 esp, 4
  00232	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 145  :         L_tmp = L_shr(L_tmp, j);

  00238	0f b7 45 dc	 movzx	 eax, WORD PTR _j$[ebp]
  0023c	50		 push	 eax
  0023d	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  00243	51		 push	 ecx
  00244	e8 00 00 00 00	 call	 _L_shr
  00249	83 c4 08	 add	 esp, 8
  0024c	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 146  :         L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);

  00252	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00256	8d 8c 45 30 ff
	ff ff		 lea	 ecx, DWORD PTR _coeff_lo$[ebp+eax*2]
  0025d	51		 push	 ecx
  0025e	0f bf 55 e8	 movsx	 edx, WORD PTR _i$[ebp]
  00262	8d 84 55 44 ff
	ff ff		 lea	 eax, DWORD PTR _coeff$[ebp+edx*2]
  00269	50		 push	 eax
  0026a	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 _L_Extract
  00276	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  :     }

  00279	e9 6d ff ff ff	 jmp	 $LN9@MR795_gain
$LN8@MR795_gain:

; 148  : 
; 149  : 
; 150  :     /*-------------------------------------------------------------------*
; 151  :      *  Codebook search:                                                 *
; 152  :      *  ~~~~~~~~~~~~~~~~                                                 *
; 153  :      *                                                                   *
; 154  :      *  For each of the candiates LTP gains in g_pitch_cand[], the terms *
; 155  :      *  t[0..4] are calculated from the values in the table (and the     *
; 156  :      *  pitch gain candidate) and summed up; the result is the mean      *
; 157  :      *  squared error for the LPT/CB gain pair. The index for the mini-  *
; 158  :      *  mum MSE is stored and finally used to retrieve the quantized CB  *
; 159  :      *  gain                                                             *
; 160  :      *-------------------------------------------------------------------*/
; 161  : 
; 162  :     /* start with "infinite" MSE */
; 163  :     dist_min = MAX_32;        move16 ();

  0027e	c7 85 f8 fe ff
	ff ff ff ff 7f	 mov	 DWORD PTR _dist_min$[ebp], 2147483647 ; 7fffffffH
  00288	e8 00 00 00 00	 call	 _move16

; 164  :     cod_ind = 0;              move16 ();

  0028d	33 c0		 xor	 eax, eax
  0028f	66 89 45 d0	 mov	 WORD PTR _cod_ind$[ebp], ax
  00293	e8 00 00 00 00	 call	 _move16

; 165  :     pit_ind = 0;              move16 ();

  00298	33 c0		 xor	 eax, eax
  0029a	66 89 45 c4	 mov	 WORD PTR _pit_ind$[ebp], ax
  0029e	e8 00 00 00 00	 call	 _move16

; 166  : 
; 167  :     /* loop through LTP gain candidates */
; 168  :     for (j = 0; j < 3; j++)

  002a3	33 c0		 xor	 eax, eax
  002a5	66 89 45 dc	 mov	 WORD PTR _j$[ebp], ax
  002a9	eb 0c		 jmp	 SHORT $LN7@MR795_gain
$LN6@MR795_gain:
  002ab	66 8b 45 dc	 mov	 ax, WORD PTR _j$[ebp]
  002af	66 83 c0 01	 add	 ax, 1
  002b3	66 89 45 dc	 mov	 WORD PTR _j$[ebp], ax
$LN7@MR795_gain:
  002b7	0f bf 45 dc	 movsx	 eax, WORD PTR _j$[ebp]
  002bb	83 f8 03	 cmp	 eax, 3
  002be	0f 8d 93 02 00
	00		 jge	 $LN5@MR795_gain

; 169  :     {
; 170  :         /* pre-calculate terms only dependent on pitch gain */
; 171  :         g_pitch = g_pitch_cand[j];    move16 ();

  002c4	0f bf 45 dc	 movsx	 eax, WORD PTR _j$[ebp]
  002c8	8b 4d 10	 mov	 ecx, DWORD PTR _g_pitch_cand$[ebp]
  002cb	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  002cf	66 89 55 a0	 mov	 WORD PTR _g_pitch$[ebp], dx
  002d3	e8 00 00 00 00	 call	 _move16

; 172  :         g2_pitch = mult(g_pitch, g_pitch);

  002d8	0f b7 45 a0	 movzx	 eax, WORD PTR _g_pitch$[ebp]
  002dc	50		 push	 eax
  002dd	0f b7 4d a0	 movzx	 ecx, WORD PTR _g_pitch$[ebp]
  002e1	51		 push	 ecx
  002e2	e8 00 00 00 00	 call	 _mult
  002e7	83 c4 08	 add	 esp, 8
  002ea	66 89 45 94	 mov	 WORD PTR _g2_pitch$[ebp], ax

; 173  :         L_tmp0 = Mpy_32_16(        coeff[0], coeff_lo[0], g2_pitch);

  002ee	0f b7 45 94	 movzx	 eax, WORD PTR _g2_pitch$[ebp]
  002f2	50		 push	 eax
  002f3	b9 02 00 00 00	 mov	 ecx, 2
  002f8	6b d1 00	 imul	 edx, ecx, 0
  002fb	0f b7 84 15 30
	ff ff ff	 movzx	 eax, WORD PTR _coeff_lo$[ebp+edx]
  00303	50		 push	 eax
  00304	b9 02 00 00 00	 mov	 ecx, 2
  00309	6b d1 00	 imul	 edx, ecx, 0
  0030c	0f b7 84 15 44
	ff ff ff	 movzx	 eax, WORD PTR _coeff$[ebp+edx]
  00314	50		 push	 eax
  00315	e8 00 00 00 00	 call	 _Mpy_32_16
  0031a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031d	89 85 04 ff ff
	ff		 mov	 DWORD PTR _L_tmp0$[ebp], eax

; 174  :         L_tmp0 = Mac_32_16(L_tmp0, coeff[1], coeff_lo[1], g_pitch);

  00323	0f b7 45 a0	 movzx	 eax, WORD PTR _g_pitch$[ebp]
  00327	50		 push	 eax
  00328	b9 02 00 00 00	 mov	 ecx, 2
  0032d	c1 e1 00	 shl	 ecx, 0
  00330	0f b7 94 0d 30
	ff ff ff	 movzx	 edx, WORD PTR _coeff_lo$[ebp+ecx]
  00338	52		 push	 edx
  00339	b8 02 00 00 00	 mov	 eax, 2
  0033e	c1 e0 00	 shl	 eax, 0
  00341	0f b7 8c 05 44
	ff ff ff	 movzx	 ecx, WORD PTR _coeff$[ebp+eax]
  00349	51		 push	 ecx
  0034a	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp0$[ebp]
  00350	52		 push	 edx
  00351	e8 00 00 00 00	 call	 _Mac_32_16
  00356	83 c4 10	 add	 esp, 16			; 00000010H
  00359	89 85 04 ff ff
	ff		 mov	 DWORD PTR _L_tmp0$[ebp], eax

; 175  : 
; 176  :         p = &qua_gain_code[0];

  0035f	b8 02 00 00 00	 mov	 eax, 2
  00364	6b c8 00	 imul	 ecx, eax, 0
  00367	81 c1 00 00 00
	00		 add	 ecx, OFFSET _qua_gain_code
  0036d	89 4d f4	 mov	 DWORD PTR _p$[ebp], ecx

; 177  :         for (i = 0; i < NB_QUA_CODE; i++)

  00370	33 c0		 xor	 eax, eax
  00372	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
  00376	eb 0c		 jmp	 SHORT $LN4@MR795_gain
$LN3@MR795_gain:
  00378	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  0037c	66 83 c0 01	 add	 ax, 1
  00380	66 89 45 e8	 mov	 WORD PTR _i$[ebp], ax
$LN4@MR795_gain:
  00384	0f bf 45 e8	 movsx	 eax, WORD PTR _i$[ebp]
  00388	83 f8 20	 cmp	 eax, 32			; 00000020H
  0038b	0f 8d c1 01 00
	00		 jge	 $LN2@MR795_gain

; 178  :         {
; 179  :             g_code = *p++;        move16 (); /* this is g_fac        Q11 */

  00391	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00394	66 8b 08	 mov	 cx, WORD PTR [eax]
  00397	66 89 4d 88	 mov	 WORD PTR _g_code$[ebp], cx
  0039b	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0039e	83 c2 02	 add	 edx, 2
  003a1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  003a4	e8 00 00 00 00	 call	 _move16

; 180  :             p++;                             /* skip log2(g_fac)         */

  003a9	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003ac	83 c0 02	 add	 eax, 2
  003af	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 181  :             p++;                             /* skip 20*log10(g_fac)     */

  003b2	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  003b5	83 c0 02	 add	 eax, 2
  003b8	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 182  : 
; 183  :             g_code = mult(g_code, gcode0);

  003bb	0f b7 45 0c	 movzx	 eax, WORD PTR _gcode0$[ebp]
  003bf	50		 push	 eax
  003c0	0f b7 4d 88	 movzx	 ecx, WORD PTR _g_code$[ebp]
  003c4	51		 push	 ecx
  003c5	e8 00 00 00 00	 call	 _mult
  003ca	83 c4 08	 add	 esp, 8
  003cd	66 89 45 88	 mov	 WORD PTR _g_code$[ebp], ax

; 184  : 
; 185  :             L_tmp = L_mult (g_code, g_code);

  003d1	0f b7 45 88	 movzx	 eax, WORD PTR _g_code$[ebp]
  003d5	50		 push	 eax
  003d6	0f b7 4d 88	 movzx	 ecx, WORD PTR _g_code$[ebp]
  003da	51		 push	 ecx
  003db	e8 00 00 00 00	 call	 _L_mult
  003e0	83 c4 08	 add	 esp, 8
  003e3	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 186  :             L_Extract (L_tmp, &g2_code_h, &g2_code_l);

  003e9	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _g2_code_l$[ebp]
  003ef	50		 push	 eax
  003f0	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _g2_code_h$[ebp]
  003f6	51		 push	 ecx
  003f7	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  003fd	52		 push	 edx
  003fe	e8 00 00 00 00	 call	 _L_Extract
  00403	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  : 
; 188  :             L_tmp = L_mult(g_code, g_pitch);

  00406	0f b7 45 a0	 movzx	 eax, WORD PTR _g_pitch$[ebp]
  0040a	50		 push	 eax
  0040b	0f b7 4d 88	 movzx	 ecx, WORD PTR _g_code$[ebp]
  0040f	51		 push	 ecx
  00410	e8 00 00 00 00	 call	 _L_mult
  00415	83 c4 08	 add	 esp, 8
  00418	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 189  :             L_Extract (L_tmp, &g_pit_cod_h, &g_pit_cod_l);

  0041e	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _g_pit_cod_l$[ebp]
  00424	50		 push	 eax
  00425	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _g_pit_cod_h$[ebp]
  0042b	51		 push	 ecx
  0042c	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  00432	52		 push	 edx
  00433	e8 00 00 00 00	 call	 _L_Extract
  00438	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  : 
; 191  :             L_tmp = Mac_32  (L_tmp0, coeff[2], coeff_lo[2],
; 192  :                                      g2_code_h, g2_code_l);

  0043b	0f b7 85 70 ff
	ff ff		 movzx	 eax, WORD PTR _g2_code_l$[ebp]
  00442	50		 push	 eax
  00443	0f b7 8d 7c ff
	ff ff		 movzx	 ecx, WORD PTR _g2_code_h$[ebp]
  0044a	51		 push	 ecx
  0044b	ba 02 00 00 00	 mov	 edx, 2
  00450	d1 e2		 shl	 edx, 1
  00452	0f b7 84 15 30
	ff ff ff	 movzx	 eax, WORD PTR _coeff_lo$[ebp+edx]
  0045a	50		 push	 eax
  0045b	b9 02 00 00 00	 mov	 ecx, 2
  00460	d1 e1		 shl	 ecx, 1
  00462	0f b7 94 0d 44
	ff ff ff	 movzx	 edx, WORD PTR _coeff$[ebp+ecx]
  0046a	52		 push	 edx
  0046b	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp0$[ebp]
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 _Mac_32
  00477	83 c4 14	 add	 esp, 20			; 00000014H
  0047a	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 193  :             L_tmp = Mac_32_16(L_tmp, coeff[3], coeff_lo[3],
; 194  :                                      g_code);

  00480	0f b7 45 88	 movzx	 eax, WORD PTR _g_code$[ebp]
  00484	50		 push	 eax
  00485	b9 02 00 00 00	 mov	 ecx, 2
  0048a	6b d1 03	 imul	 edx, ecx, 3
  0048d	0f b7 84 15 30
	ff ff ff	 movzx	 eax, WORD PTR _coeff_lo$[ebp+edx]
  00495	50		 push	 eax
  00496	b9 02 00 00 00	 mov	 ecx, 2
  0049b	6b d1 03	 imul	 edx, ecx, 3
  0049e	0f b7 84 15 44
	ff ff ff	 movzx	 eax, WORD PTR _coeff$[ebp+edx]
  004a6	50		 push	 eax
  004a7	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  004ad	51		 push	 ecx
  004ae	e8 00 00 00 00	 call	 _Mac_32_16
  004b3	83 c4 10	 add	 esp, 16			; 00000010H
  004b6	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 195  :             L_tmp = Mac_32   (L_tmp, coeff[4], coeff_lo[4],
; 196  :                                      g_pit_cod_h, g_pit_cod_l);

  004bc	0f b7 85 58 ff
	ff ff		 movzx	 eax, WORD PTR _g_pit_cod_l$[ebp]
  004c3	50		 push	 eax
  004c4	0f b7 8d 64 ff
	ff ff		 movzx	 ecx, WORD PTR _g_pit_cod_h$[ebp]
  004cb	51		 push	 ecx
  004cc	ba 02 00 00 00	 mov	 edx, 2
  004d1	c1 e2 02	 shl	 edx, 2
  004d4	0f b7 84 15 30
	ff ff ff	 movzx	 eax, WORD PTR _coeff_lo$[ebp+edx]
  004dc	50		 push	 eax
  004dd	b9 02 00 00 00	 mov	 ecx, 2
  004e2	c1 e1 02	 shl	 ecx, 2
  004e5	0f b7 94 0d 44
	ff ff ff	 movzx	 edx, WORD PTR _coeff$[ebp+ecx]
  004ed	52		 push	 edx
  004ee	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  004f4	50		 push	 eax
  004f5	e8 00 00 00 00	 call	 _Mac_32
  004fa	83 c4 14	 add	 esp, 20			; 00000014H
  004fd	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 197  : 
; 198  :             /* store table index if MSE for this index is lower
; 199  :                than the minimum MSE seen so far; also store the
; 200  :                pitch gain for this (so far) lowest MSE          */
; 201  :             test ();

  00503	e8 00 00 00 00	 call	 _test

; 202  :             if (L_sub(L_tmp, dist_min) < (Word32) 0)

  00508	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _dist_min$[ebp]
  0050e	50		 push	 eax
  0050f	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _L_tmp$[ebp]
  00515	51		 push	 ecx
  00516	e8 00 00 00 00	 call	 _L_sub
  0051b	83 c4 08	 add	 esp, 8
  0051e	85 c0		 test	 eax, eax
  00520	7d 2b		 jge	 SHORT $LN1@MR795_gain

; 203  :             {
; 204  :                 dist_min = L_tmp;                move32 ();

  00522	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00528	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _dist_min$[ebp], eax
  0052e	e8 00 00 00 00	 call	 _move32

; 205  :                 cod_ind = i;                     move16 ();

  00533	66 8b 45 e8	 mov	 ax, WORD PTR _i$[ebp]
  00537	66 89 45 d0	 mov	 WORD PTR _cod_ind$[ebp], ax
  0053b	e8 00 00 00 00	 call	 _move16

; 206  :                 pit_ind = j;                     move16 ();

  00540	66 8b 45 dc	 mov	 ax, WORD PTR _j$[ebp]
  00544	66 89 45 c4	 mov	 WORD PTR _pit_ind$[ebp], ax
  00548	e8 00 00 00 00	 call	 _move16
$LN1@MR795_gain:

; 207  :             }
; 208  :         }

  0054d	e9 26 fe ff ff	 jmp	 $LN3@MR795_gain
$LN2@MR795_gain:

; 209  :     }

  00552	e9 54 fd ff ff	 jmp	 $LN6@MR795_gain
$LN5@MR795_gain:

; 210  : 
; 211  :     /*------------------------------------------------------------------*
; 212  :      *  read quantized gains and new values for MA predictor memories   *
; 213  :      *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
; 214  :      *------------------------------------------------------------------*/
; 215  : 
; 216  :     /* Read the quantized gains */
; 217  :     p = &qua_gain_code[add (add (cod_ind, cod_ind), cod_ind)]; move16 ();

  00557	0f b7 45 d0	 movzx	 eax, WORD PTR _cod_ind$[ebp]
  0055b	50		 push	 eax
  0055c	0f b7 4d d0	 movzx	 ecx, WORD PTR _cod_ind$[ebp]
  00560	51		 push	 ecx
  00561	0f b7 55 d0	 movzx	 edx, WORD PTR _cod_ind$[ebp]
  00565	52		 push	 edx
  00566	e8 00 00 00 00	 call	 _add
  0056b	83 c4 08	 add	 esp, 8
  0056e	0f b7 c0	 movzx	 eax, ax
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 _add
  00577	83 c4 08	 add	 esp, 8
  0057a	0f bf c8	 movsx	 ecx, ax
  0057d	8d 14 4d 00 00
	00 00		 lea	 edx, DWORD PTR _qua_gain_code[ecx*2]
  00584	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00587	e8 00 00 00 00	 call	 _move16

; 218  :     g_code = *p++;            move16();

  0058c	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0058f	66 8b 08	 mov	 cx, WORD PTR [eax]
  00592	66 89 4d 88	 mov	 WORD PTR _g_code$[ebp], cx
  00596	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00599	83 c2 02	 add	 edx, 2
  0059c	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  0059f	e8 00 00 00 00	 call	 _move16

; 219  :     *qua_ener_MR122 = *p++;   move16();

  005a4	8b 45 30	 mov	 eax, DWORD PTR _qua_ener_MR122$[ebp]
  005a7	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  005aa	66 8b 11	 mov	 dx, WORD PTR [ecx]
  005ad	66 89 10	 mov	 WORD PTR [eax], dx
  005b0	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  005b3	83 c0 02	 add	 eax, 2
  005b6	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  005b9	e8 00 00 00 00	 call	 _move16

; 220  :     *qua_ener = *p;           move16();

  005be	8b 45 34	 mov	 eax, DWORD PTR _qua_ener$[ebp]
  005c1	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  005c4	66 8b 11	 mov	 dx, WORD PTR [ecx]
  005c7	66 89 10	 mov	 WORD PTR [eax], dx
  005ca	e8 00 00 00 00	 call	 _move16

; 221  : 
; 222  :     /*------------------------------------------------------------------*
; 223  :      *  calculate final fixed codebook gain:                            *
; 224  :      *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
; 225  :      *                                                                  *
; 226  :      *   gc = gc0 * g                                                   *
; 227  :      *------------------------------------------------------------------*/
; 228  : 
; 229  :     L_tmp = L_mult(g_code, gcode0);

  005cf	0f b7 45 0c	 movzx	 eax, WORD PTR _gcode0$[ebp]
  005d3	50		 push	 eax
  005d4	0f b7 4d 88	 movzx	 ecx, WORD PTR _g_code$[ebp]
  005d8	51		 push	 ecx
  005d9	e8 00 00 00 00	 call	 _L_mult
  005de	83 c4 08	 add	 esp, 8
  005e1	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 230  :     L_tmp = L_shr(L_tmp, sub(9, exp_gcode0));

  005e7	0f b7 45 08	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  005eb	50		 push	 eax
  005ec	6a 09		 push	 9
  005ee	e8 00 00 00 00	 call	 _sub
  005f3	83 c4 08	 add	 esp, 8
  005f6	0f b7 c8	 movzx	 ecx, ax
  005f9	51		 push	 ecx
  005fa	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _L_tmp$[ebp]
  00600	52		 push	 edx
  00601	e8 00 00 00 00	 call	 _L_shr
  00606	83 c4 08	 add	 esp, 8
  00609	89 85 10 ff ff
	ff		 mov	 DWORD PTR _L_tmp$[ebp], eax

; 231  :     *gain_cod = extract_h(L_tmp);

  0060f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _L_tmp$[ebp]
  00615	50		 push	 eax
  00616	e8 00 00 00 00	 call	 _extract_h
  0061b	83 c4 04	 add	 esp, 4
  0061e	8b 4d 28	 mov	 ecx, DWORD PTR _gain_cod$[ebp]
  00621	66 89 01	 mov	 WORD PTR [ecx], ax

; 232  :     *gain_cod_ind = cod_ind;                move16 ();

  00624	8b 45 2c	 mov	 eax, DWORD PTR _gain_cod_ind$[ebp]
  00627	66 8b 4d d0	 mov	 cx, WORD PTR _cod_ind$[ebp]
  0062b	66 89 08	 mov	 WORD PTR [eax], cx
  0062e	e8 00 00 00 00	 call	 _move16

; 233  :     *gain_pit = g_pitch_cand[pit_ind];      move16 ();

  00633	0f bf 45 c4	 movsx	 eax, WORD PTR _pit_ind$[ebp]
  00637	8b 4d 20	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  0063a	8b 55 10	 mov	 edx, DWORD PTR _g_pitch_cand$[ebp]
  0063d	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  00641	66 89 01	 mov	 WORD PTR [ecx], ax
  00644	e8 00 00 00 00	 call	 _move16

; 234  :     *gain_pit_ind = g_pitch_cind[pit_ind];  move16 ();

  00649	0f bf 45 c4	 movsx	 eax, WORD PTR _pit_ind$[ebp]
  0064d	8b 4d 24	 mov	 ecx, DWORD PTR _gain_pit_ind$[ebp]
  00650	8b 55 14	 mov	 edx, DWORD PTR _g_pitch_cind$[ebp]
  00653	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  00657	66 89 01	 mov	 WORD PTR [ecx], ax
  0065a	e8 00 00 00 00	 call	 _move16

; 235  : }

  0065f	52		 push	 edx
  00660	8b cd		 mov	 ecx, ebp
  00662	50		 push	 eax
  00663	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@MR795_gain
  00669	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0066e	58		 pop	 eax
  0066f	5a		 pop	 edx
  00670	5f		 pop	 edi
  00671	5e		 pop	 esi
  00672	5b		 pop	 ebx
  00673	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00676	33 cd		 xor	 ecx, ebp
  00678	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0067d	81 c4 cc 01 00
	00		 add	 esp, 460		; 000001ccH
  00683	3b ec		 cmp	 ebp, esp
  00685	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0068a	8b e5		 mov	 esp, ebp
  0068c	5d		 pop	 ebp
  0068d	c3		 ret	 0
  0068e	8b ff		 npad	 2
$LN25@MR795_gain:
  00690	07 00 00 00	 DD	 7
  00694	00 00 00 00	 DD	 $LN24@MR795_gain
$LN24@MR795_gain:
  00698	7c ff ff ff	 DD	 -132			; ffffff7cH
  0069c	02 00 00 00	 DD	 2
  006a0	00 00 00 00	 DD	 $LN17@MR795_gain
  006a4	70 ff ff ff	 DD	 -144			; ffffff70H
  006a8	02 00 00 00	 DD	 2
  006ac	00 00 00 00	 DD	 $LN18@MR795_gain
  006b0	64 ff ff ff	 DD	 -156			; ffffff64H
  006b4	02 00 00 00	 DD	 2
  006b8	00 00 00 00	 DD	 $LN19@MR795_gain
  006bc	58 ff ff ff	 DD	 -168			; ffffff58H
  006c0	02 00 00 00	 DD	 2
  006c4	00 00 00 00	 DD	 $LN20@MR795_gain
  006c8	44 ff ff ff	 DD	 -188			; ffffff44H
  006cc	0a 00 00 00	 DD	 10			; 0000000aH
  006d0	00 00 00 00	 DD	 $LN21@MR795_gain
  006d4	30 ff ff ff	 DD	 -208			; ffffff30H
  006d8	0a 00 00 00	 DD	 10			; 0000000aH
  006dc	00 00 00 00	 DD	 $LN22@MR795_gain
  006e0	1c ff ff ff	 DD	 -228			; ffffff1cH
  006e4	0a 00 00 00	 DD	 10			; 0000000aH
  006e8	00 00 00 00	 DD	 $LN23@MR795_gain
$LN23@MR795_gain:
  006ec	65		 DB	 101			; 00000065H
  006ed	78		 DB	 120			; 00000078H
  006ee	70		 DB	 112			; 00000070H
  006ef	5f		 DB	 95			; 0000005fH
  006f0	6d		 DB	 109			; 0000006dH
  006f1	61		 DB	 97			; 00000061H
  006f2	78		 DB	 120			; 00000078H
  006f3	00		 DB	 0
$LN22@MR795_gain:
  006f4	63		 DB	 99			; 00000063H
  006f5	6f		 DB	 111			; 0000006fH
  006f6	65		 DB	 101			; 00000065H
  006f7	66		 DB	 102			; 00000066H
  006f8	66		 DB	 102			; 00000066H
  006f9	5f		 DB	 95			; 0000005fH
  006fa	6c		 DB	 108			; 0000006cH
  006fb	6f		 DB	 111			; 0000006fH
  006fc	00		 DB	 0
$LN21@MR795_gain:
  006fd	63		 DB	 99			; 00000063H
  006fe	6f		 DB	 111			; 0000006fH
  006ff	65		 DB	 101			; 00000065H
  00700	66		 DB	 102			; 00000066H
  00701	66		 DB	 102			; 00000066H
  00702	00		 DB	 0
$LN20@MR795_gain:
  00703	67		 DB	 103			; 00000067H
  00704	5f		 DB	 95			; 0000005fH
  00705	70		 DB	 112			; 00000070H
  00706	69		 DB	 105			; 00000069H
  00707	74		 DB	 116			; 00000074H
  00708	5f		 DB	 95			; 0000005fH
  00709	63		 DB	 99			; 00000063H
  0070a	6f		 DB	 111			; 0000006fH
  0070b	64		 DB	 100			; 00000064H
  0070c	5f		 DB	 95			; 0000005fH
  0070d	6c		 DB	 108			; 0000006cH
  0070e	00		 DB	 0
$LN19@MR795_gain:
  0070f	67		 DB	 103			; 00000067H
  00710	5f		 DB	 95			; 0000005fH
  00711	70		 DB	 112			; 00000070H
  00712	69		 DB	 105			; 00000069H
  00713	74		 DB	 116			; 00000074H
  00714	5f		 DB	 95			; 0000005fH
  00715	63		 DB	 99			; 00000063H
  00716	6f		 DB	 111			; 0000006fH
  00717	64		 DB	 100			; 00000064H
  00718	5f		 DB	 95			; 0000005fH
  00719	68		 DB	 104			; 00000068H
  0071a	00		 DB	 0
$LN18@MR795_gain:
  0071b	67		 DB	 103			; 00000067H
  0071c	32		 DB	 50			; 00000032H
  0071d	5f		 DB	 95			; 0000005fH
  0071e	63		 DB	 99			; 00000063H
  0071f	6f		 DB	 111			; 0000006fH
  00720	64		 DB	 100			; 00000064H
  00721	65		 DB	 101			; 00000065H
  00722	5f		 DB	 95			; 0000005fH
  00723	6c		 DB	 108			; 0000006cH
  00724	00		 DB	 0
$LN17@MR795_gain:
  00725	67		 DB	 103			; 00000067H
  00726	32		 DB	 50			; 00000032H
  00727	5f		 DB	 95			; 0000005fH
  00728	63		 DB	 99			; 00000063H
  00729	6f		 DB	 111			; 0000006fH
  0072a	64		 DB	 100			; 00000064H
  0072b	65		 DB	 101			; 00000065H
  0072c	5f		 DB	 95			; 0000005fH
  0072d	68		 DB	 104			; 00000068H
  0072e	00		 DB	 0
_MR795_gain_code_quant3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\qgain795.c
;	COMDAT _MR795_gain_quant
_TEXT	SEGMENT
_gain_cod_unq$ = -148					; size = 2
_exp$ = -136						; size = 2
_gain_cod_index$ = -124					; size = 2
_gain_pit_index$ = -112					; size = 2
_g_pitch_cind$ = -100					; size = 6
_g_pitch_cand$ = -84					; size = 6
_gcode0$ = -68						; size = 2
_alpha$ = -56						; size = 2
_ltpg$ = -44						; size = 2
_exp_en$ = -32						; size = 8
_frac_en$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_adapt_st$ = 8						; size = 4
_res$ = 12						; size = 4
_exc$ = 16						; size = 4
_code$ = 20						; size = 4
_frac_coeff$ = 24					; size = 4
_exp_coeff$ = 28					; size = 4
_exp_code_en$ = 32					; size = 2
_frac_code_en$ = 36					; size = 2
_exp_gcode0$ = 40					; size = 2
_frac_gcode0$ = 44					; size = 2
_L_subfr$ = 48						; size = 2
_cod_gain_frac$ = 52					; size = 2
_cod_gain_exp$ = 56					; size = 2
_gp_limit$ = 60						; size = 2
_gain_pit$ = 64						; size = 4
_gain_cod$ = 68						; size = 4
_qua_ener_MR122$ = 72					; size = 4
_qua_ener$ = 76						; size = 4
_anap$ = 80						; size = 4
_MR795_gain_quant PROC					; COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-344]
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 518  :     Word16 frac_en[4];
; 519  :     Word16 exp_en[4];
; 520  :     Word16 ltpg, alpha, gcode0;
; 521  :     Word16 g_pitch_cand[3];      /* pitch gain candidates   Q14 */
; 522  :     Word16 g_pitch_cind[3];      /* pitch gain indices      Q0  */
; 523  :     Word16 gain_pit_index;
; 524  :     Word16 gain_cod_index;
; 525  :     Word16 exp;
; 526  :     Word16 gain_cod_unq;         /* code gain (unq.) Q(10-exp_gcode0)  */
; 527  : 
; 528  : 
; 529  :     /* get list of candidate quantized pitch gain values
; 530  :      * and corresponding quantization indices
; 531  :      */
; 532  :     gain_pit_index = q_gain_pitch (MR795, gp_limit, gain_pit,
; 533  :                                    g_pitch_cand, g_pitch_cind); 

  00028	8d 45 9c	 lea	 eax, DWORD PTR _g_pitch_cind$[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d ac	 lea	 ecx, DWORD PTR _g_pitch_cand$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 40	 mov	 edx, DWORD PTR _gain_pit$[ebp]
  00033	52		 push	 edx
  00034	0f b7 45 3c	 movzx	 eax, WORD PTR _gp_limit$[ebp]
  00038	50		 push	 eax
  00039	6a 05		 push	 5
  0003b	e8 00 00 00 00	 call	 _q_gain_pitch
  00040	83 c4 14	 add	 esp, 20			; 00000014H
  00043	66 89 45 90	 mov	 WORD PTR _gain_pit_index$[ebp], ax

; 534  :                      move16 (); /* function result */

  00047	e8 00 00 00 00	 call	 _move16

; 535  : 
; 536  :     /*-------------------------------------------------------------------*
; 537  :      *  predicted codebook gain                                          *
; 538  :      *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
; 539  :      *  gc0     = 2^exp_gcode0 + 2^frac_gcode0                           *
; 540  :      *                                                                   *
; 541  :      *  gcode0 (Q14) = 2^14*2^frac_gcode0 = gc0 * 2^(14-exp_gcode0)      *
; 542  :      *-------------------------------------------------------------------*/
; 543  :     gcode0 = extract_l(Pow2(14, frac_gcode0));          /* Q14 */

  0004c	0f b7 45 2c	 movzx	 eax, WORD PTR _frac_gcode0$[ebp]
  00050	50		 push	 eax
  00051	6a 0e		 push	 14			; 0000000eH
  00053	e8 00 00 00 00	 call	 _Pow2
  00058	83 c4 08	 add	 esp, 8
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _extract_l
  00061	83 c4 04	 add	 esp, 4
  00064	66 89 45 bc	 mov	 WORD PTR _gcode0$[ebp], ax

; 544  : 
; 545  :     /* pre-quantization of codebook gain
; 546  :      * (using three pitch gain candidates);
; 547  :      * result: best guess of pitch gain and code gain
; 548  :      */
; 549  :     MR795_gain_code_quant3(
; 550  :         exp_gcode0, gcode0, g_pitch_cand, g_pitch_cind,
; 551  :         frac_coeff, exp_coeff,
; 552  :         gain_pit, &gain_pit_index, gain_cod, &gain_cod_index,
; 553  :         qua_ener_MR122, qua_ener);

  00068	8b 45 4c	 mov	 eax, DWORD PTR _qua_ener$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 48	 mov	 ecx, DWORD PTR _qua_ener_MR122$[ebp]
  0006f	51		 push	 ecx
  00070	8d 55 84	 lea	 edx, DWORD PTR _gain_cod_index$[ebp]
  00073	52		 push	 edx
  00074	8b 45 44	 mov	 eax, DWORD PTR _gain_cod$[ebp]
  00077	50		 push	 eax
  00078	8d 4d 90	 lea	 ecx, DWORD PTR _gain_pit_index$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 40	 mov	 edx, DWORD PTR _gain_pit$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 1c	 mov	 eax, DWORD PTR _exp_coeff$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 18	 mov	 ecx, DWORD PTR _frac_coeff$[ebp]
  00087	51		 push	 ecx
  00088	8d 55 9c	 lea	 edx, DWORD PTR _g_pitch_cind$[ebp]
  0008b	52		 push	 edx
  0008c	8d 45 ac	 lea	 eax, DWORD PTR _g_pitch_cand$[ebp]
  0008f	50		 push	 eax
  00090	0f b7 4d bc	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00094	51		 push	 ecx
  00095	0f b7 55 28	 movzx	 edx, WORD PTR _exp_gcode0$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 _MR795_gain_code_quant3
  0009f	83 c4 30	 add	 esp, 48			; 00000030H

; 554  : 
; 555  :     /* calculation of energy coefficients and LTP coding gain */
; 556  :     calc_unfilt_energies(res, exc, code, *gain_pit, L_subfr,
; 557  :                          frac_en, exp_en, &ltpg);

  000a2	8d 45 d4	 lea	 eax, DWORD PTR _ltpg$[ebp]
  000a5	50		 push	 eax
  000a6	8d 4d e0	 lea	 ecx, DWORD PTR _exp_en$[ebp]
  000a9	51		 push	 ecx
  000aa	8d 55 f0	 lea	 edx, DWORD PTR _frac_en$[ebp]
  000ad	52		 push	 edx
  000ae	0f b7 45 30	 movzx	 eax, WORD PTR _L_subfr$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d 40	 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  000b6	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000b9	52		 push	 edx
  000ba	8b 45 14	 mov	 eax, DWORD PTR _code$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR _exc$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 0c	 mov	 edx, DWORD PTR _res$[ebp]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 _calc_unfilt_energies
  000cb	83 c4 20	 add	 esp, 32			; 00000020H

; 558  : 
; 559  :     /* run gain adaptor, calculate alpha factor to balance LTP/CB gain
; 560  :      * (this includes the gain adaptor update)
; 561  :      * Note: ltpg = 0 if frac_en[0] == 0, so the update is OK in that case
; 562  :      */
; 563  :     gain_adapt(adapt_st, ltpg, *gain_cod, &alpha);

  000ce	8d 45 c8	 lea	 eax, DWORD PTR _alpha$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 44	 mov	 ecx, DWORD PTR _gain_cod$[ebp]
  000d5	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  000d8	52		 push	 edx
  000d9	0f b7 45 d4	 movzx	 eax, WORD PTR _ltpg$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _adapt_st$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _gain_adapt
  000e7	83 c4 10	 add	 esp, 16			; 00000010H

; 564  : 
; 565  :     /* if this is a very low energy signal (threshold: see
; 566  :      * calc_unfilt_energies) or alpha <= 0 then don't run the modified quantizer
; 567  :      */
; 568  :     test (); move16 (); test ();

  000ea	e8 00 00 00 00	 call	 _test
  000ef	e8 00 00 00 00	 call	 _move16
  000f4	e8 00 00 00 00	 call	 _test

; 569  :     if (frac_en[0] != 0 && alpha > 0)

  000f9	b8 02 00 00 00	 mov	 eax, 2
  000fe	6b c8 00	 imul	 ecx, eax, 0
  00101	0f bf 54 0d f0	 movsx	 edx, WORD PTR _frac_en$[ebp+ecx]
  00106	85 d2		 test	 edx, edx
  00108	0f 84 be 00 00
	00		 je	 $LN1@MR795_gain
  0010e	0f bf 45 c8	 movsx	 eax, WORD PTR _alpha$[ebp]
  00112	85 c0		 test	 eax, eax
  00114	0f 8e b2 00 00
	00		 jle	 $LN1@MR795_gain

; 570  :     {
; 571  :         /* innovation energy <cod cod> was already computed in gc_pred() */
; 572  :         /* (this overwrites the LtpResEn which is no longer needed)      */
; 573  :         frac_en[3] = frac_code_en;          move16 ();

  0011a	b8 02 00 00 00	 mov	 eax, 2
  0011f	6b c8 03	 imul	 ecx, eax, 3
  00122	66 8b 55 24	 mov	 dx, WORD PTR _frac_code_en$[ebp]
  00126	66 89 54 0d f0	 mov	 WORD PTR _frac_en$[ebp+ecx], dx
  0012b	e8 00 00 00 00	 call	 _move16

; 574  :         exp_en[3] = exp_code_en;            move16 ();

  00130	b8 02 00 00 00	 mov	 eax, 2
  00135	6b c8 03	 imul	 ecx, eax, 3
  00138	66 8b 55 20	 mov	 dx, WORD PTR _exp_code_en$[ebp]
  0013c	66 89 54 0d e0	 mov	 WORD PTR _exp_en$[ebp+ecx], dx
  00141	e8 00 00 00 00	 call	 _move16

; 575  :         
; 576  :         /* store optimum codebook gain in Q(10-exp_gcode0) */
; 577  :         exp = add (sub (cod_gain_exp, exp_gcode0), 10);

  00146	6a 0a		 push	 10			; 0000000aH
  00148	0f b7 45 28	 movzx	 eax, WORD PTR _exp_gcode0$[ebp]
  0014c	50		 push	 eax
  0014d	0f b7 4d 38	 movzx	 ecx, WORD PTR _cod_gain_exp$[ebp]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _sub
  00157	83 c4 08	 add	 esp, 8
  0015a	0f b7 d0	 movzx	 edx, ax
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _add
  00163	83 c4 08	 add	 esp, 8
  00166	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _exp$[ebp], ax

; 578  :         gain_cod_unq = shl (cod_gain_frac, exp);

  0016d	0f b7 85 78 ff
	ff ff		 movzx	 eax, WORD PTR _exp$[ebp]
  00174	50		 push	 eax
  00175	0f b7 4d 34	 movzx	 ecx, WORD PTR _cod_gain_frac$[ebp]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 _shl
  0017f	83 c4 08	 add	 esp, 8
  00182	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _gain_cod_unq$[ebp], ax

; 579  :         
; 580  :         /* run quantization with modified criterion */
; 581  :         gain_cod_index = MR795_gain_code_quant_mod(
; 582  :             *gain_pit, exp_gcode0, gcode0,
; 583  :             frac_en, exp_en, alpha, gain_cod_unq,
; 584  :             gain_cod, qua_ener_MR122, qua_ener); move16 (); /* function result */

  00189	8b 45 4c	 mov	 eax, DWORD PTR _qua_ener$[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d 48	 mov	 ecx, DWORD PTR _qua_ener_MR122$[ebp]
  00190	51		 push	 ecx
  00191	8b 55 44	 mov	 edx, DWORD PTR _gain_cod$[ebp]
  00194	52		 push	 edx
  00195	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _gain_cod_unq$[ebp]
  0019c	50		 push	 eax
  0019d	0f b7 4d c8	 movzx	 ecx, WORD PTR _alpha$[ebp]
  001a1	51		 push	 ecx
  001a2	8d 55 e0	 lea	 edx, DWORD PTR _exp_en$[ebp]
  001a5	52		 push	 edx
  001a6	8d 45 f0	 lea	 eax, DWORD PTR _frac_en$[ebp]
  001a9	50		 push	 eax
  001aa	0f b7 4d bc	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  001ae	51		 push	 ecx
  001af	0f b7 55 28	 movzx	 edx, WORD PTR _exp_gcode0$[ebp]
  001b3	52		 push	 edx
  001b4	8b 45 40	 mov	 eax, DWORD PTR _gain_pit$[ebp]
  001b7	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _MR795_gain_code_quant_mod
  001c0	83 c4 28	 add	 esp, 40			; 00000028H
  001c3	66 89 45 84	 mov	 WORD PTR _gain_cod_index$[ebp], ax
  001c7	e8 00 00 00 00	 call	 _move16
$LN1@MR795_gain:

; 585  :     }
; 586  : 
; 587  :     *(*anap)++ = gain_pit_index;        move16 ();

  001cc	8b 45 50	 mov	 eax, DWORD PTR _anap$[ebp]
  001cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d1	66 8b 55 90	 mov	 dx, WORD PTR _gain_pit_index$[ebp]
  001d5	66 89 11	 mov	 WORD PTR [ecx], dx
  001d8	8b 45 50	 mov	 eax, DWORD PTR _anap$[ebp]
  001db	8b 08		 mov	 ecx, DWORD PTR [eax]
  001dd	83 c1 02	 add	 ecx, 2
  001e0	8b 55 50	 mov	 edx, DWORD PTR _anap$[ebp]
  001e3	89 0a		 mov	 DWORD PTR [edx], ecx
  001e5	e8 00 00 00 00	 call	 _move16

; 588  :     *(*anap)++ = gain_cod_index;        move16 ();

  001ea	8b 45 50	 mov	 eax, DWORD PTR _anap$[ebp]
  001ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ef	66 8b 55 84	 mov	 dx, WORD PTR _gain_cod_index$[ebp]
  001f3	66 89 11	 mov	 WORD PTR [ecx], dx
  001f6	8b 45 50	 mov	 eax, DWORD PTR _anap$[ebp]
  001f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fb	83 c1 02	 add	 ecx, 2
  001fe	8b 55 50	 mov	 edx, DWORD PTR _anap$[ebp]
  00201	89 0a		 mov	 DWORD PTR [edx], ecx
  00203	e8 00 00 00 00	 call	 _move16

; 589  : }

  00208	52		 push	 edx
  00209	8b cd		 mov	 ecx, ebp
  0020b	50		 push	 eax
  0020c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@MR795_gain
  00212	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00217	58		 pop	 eax
  00218	5a		 pop	 edx
  00219	5f		 pop	 edi
  0021a	5e		 pop	 esi
  0021b	5b		 pop	 ebx
  0021c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021f	33 cd		 xor	 ecx, ebp
  00221	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00226	81 c4 58 01 00
	00		 add	 esp, 344		; 00000158H
  0022c	3b ec		 cmp	 ebp, esp
  0022e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c3		 ret	 0
  00237	90		 npad	 1
$LN13@MR795_gain:
  00238	08 00 00 00	 DD	 8
  0023c	00 00 00 00	 DD	 $LN12@MR795_gain
$LN12@MR795_gain:
  00240	f0 ff ff ff	 DD	 -16			; fffffff0H
  00244	08 00 00 00	 DD	 8
  00248	00 00 00 00	 DD	 $LN4@MR795_gain
  0024c	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00250	08 00 00 00	 DD	 8
  00254	00 00 00 00	 DD	 $LN5@MR795_gain
  00258	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0025c	02 00 00 00	 DD	 2
  00260	00 00 00 00	 DD	 $LN6@MR795_gain
  00264	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00268	02 00 00 00	 DD	 2
  0026c	00 00 00 00	 DD	 $LN7@MR795_gain
  00270	ac ff ff ff	 DD	 -84			; ffffffacH
  00274	06 00 00 00	 DD	 6
  00278	00 00 00 00	 DD	 $LN8@MR795_gain
  0027c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00280	06 00 00 00	 DD	 6
  00284	00 00 00 00	 DD	 $LN9@MR795_gain
  00288	90 ff ff ff	 DD	 -112			; ffffff90H
  0028c	02 00 00 00	 DD	 2
  00290	00 00 00 00	 DD	 $LN10@MR795_gain
  00294	84 ff ff ff	 DD	 -124			; ffffff84H
  00298	02 00 00 00	 DD	 2
  0029c	00 00 00 00	 DD	 $LN11@MR795_gain
$LN11@MR795_gain:
  002a0	67		 DB	 103			; 00000067H
  002a1	61		 DB	 97			; 00000061H
  002a2	69		 DB	 105			; 00000069H
  002a3	6e		 DB	 110			; 0000006eH
  002a4	5f		 DB	 95			; 0000005fH
  002a5	63		 DB	 99			; 00000063H
  002a6	6f		 DB	 111			; 0000006fH
  002a7	64		 DB	 100			; 00000064H
  002a8	5f		 DB	 95			; 0000005fH
  002a9	69		 DB	 105			; 00000069H
  002aa	6e		 DB	 110			; 0000006eH
  002ab	64		 DB	 100			; 00000064H
  002ac	65		 DB	 101			; 00000065H
  002ad	78		 DB	 120			; 00000078H
  002ae	00		 DB	 0
$LN10@MR795_gain:
  002af	67		 DB	 103			; 00000067H
  002b0	61		 DB	 97			; 00000061H
  002b1	69		 DB	 105			; 00000069H
  002b2	6e		 DB	 110			; 0000006eH
  002b3	5f		 DB	 95			; 0000005fH
  002b4	70		 DB	 112			; 00000070H
  002b5	69		 DB	 105			; 00000069H
  002b6	74		 DB	 116			; 00000074H
  002b7	5f		 DB	 95			; 0000005fH
  002b8	69		 DB	 105			; 00000069H
  002b9	6e		 DB	 110			; 0000006eH
  002ba	64		 DB	 100			; 00000064H
  002bb	65		 DB	 101			; 00000065H
  002bc	78		 DB	 120			; 00000078H
  002bd	00		 DB	 0
$LN9@MR795_gain:
  002be	67		 DB	 103			; 00000067H
  002bf	5f		 DB	 95			; 0000005fH
  002c0	70		 DB	 112			; 00000070H
  002c1	69		 DB	 105			; 00000069H
  002c2	74		 DB	 116			; 00000074H
  002c3	63		 DB	 99			; 00000063H
  002c4	68		 DB	 104			; 00000068H
  002c5	5f		 DB	 95			; 0000005fH
  002c6	63		 DB	 99			; 00000063H
  002c7	69		 DB	 105			; 00000069H
  002c8	6e		 DB	 110			; 0000006eH
  002c9	64		 DB	 100			; 00000064H
  002ca	00		 DB	 0
$LN8@MR795_gain:
  002cb	67		 DB	 103			; 00000067H
  002cc	5f		 DB	 95			; 0000005fH
  002cd	70		 DB	 112			; 00000070H
  002ce	69		 DB	 105			; 00000069H
  002cf	74		 DB	 116			; 00000074H
  002d0	63		 DB	 99			; 00000063H
  002d1	68		 DB	 104			; 00000068H
  002d2	5f		 DB	 95			; 0000005fH
  002d3	63		 DB	 99			; 00000063H
  002d4	61		 DB	 97			; 00000061H
  002d5	6e		 DB	 110			; 0000006eH
  002d6	64		 DB	 100			; 00000064H
  002d7	00		 DB	 0
$LN7@MR795_gain:
  002d8	61		 DB	 97			; 00000061H
  002d9	6c		 DB	 108			; 0000006cH
  002da	70		 DB	 112			; 00000070H
  002db	68		 DB	 104			; 00000068H
  002dc	61		 DB	 97			; 00000061H
  002dd	00		 DB	 0
$LN6@MR795_gain:
  002de	6c		 DB	 108			; 0000006cH
  002df	74		 DB	 116			; 00000074H
  002e0	70		 DB	 112			; 00000070H
  002e1	67		 DB	 103			; 00000067H
  002e2	00		 DB	 0
$LN5@MR795_gain:
  002e3	65		 DB	 101			; 00000065H
  002e4	78		 DB	 120			; 00000078H
  002e5	70		 DB	 112			; 00000070H
  002e6	5f		 DB	 95			; 0000005fH
  002e7	65		 DB	 101			; 00000065H
  002e8	6e		 DB	 110			; 0000006eH
  002e9	00		 DB	 0
$LN4@MR795_gain:
  002ea	66		 DB	 102			; 00000066H
  002eb	72		 DB	 114			; 00000072H
  002ec	61		 DB	 97			; 00000061H
  002ed	63		 DB	 99			; 00000063H
  002ee	5f		 DB	 95			; 0000005fH
  002ef	65		 DB	 101			; 00000065H
  002f0	6e		 DB	 110			; 0000006eH
  002f1	00		 DB	 0
_MR795_gain_quant ENDP
_TEXT	ENDS
END
