; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c3_14pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c3_14pf_id
CONST	SEGMENT
_c3_14pf_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_code_3i40_14bits
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_cor_h_x:PROC
EXTRN	_cor_h:PROC
EXTRN	_set_sign:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c3_14pf.c
;	COMDAT _build_code
_TEXT	SEGMENT
tv225 = -346						; size = 2
tv217 = -346						; size = 2
tv209 = -346						; size = 2
_s$ = -148						; size = 4
_p2$ = -136						; size = 4
_p1$ = -124						; size = 4
_p0$ = -112						; size = 4
_rsign$ = -100						; size = 2
_indx$ = -88						; size = 2
__sign$ = -76						; size = 6
_index$ = -60						; size = 2
_track$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_codvec$ = 8						; size = 4
_dn_sign$ = 12						; size = 4
_cod$ = 16						; size = 4
_h$ = 20						; size = 4
_y$ = 24						; size = 4
_sign$ = 28						; size = 4
_build_code PROC					; COMDAT

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00012	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 351  :     Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
; 352  :     Word16 *p0, *p1, *p2;
; 353  :     Word32 s;
; 354  : 
; 355  :     for (i = 0; i < L_CODE; i++) {

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN18@build_code
$LN17@build_code:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN18@build_code:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 28	 cmp	 eax, 40			; 00000028H
  00043	7d 14		 jge	 SHORT $LN16@build_code

; 356  :        cod[i] = 0;         move16 ();

  00045	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00049	33 c9		 xor	 ecx, ecx
  0004b	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  0004e	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00052	e8 00 00 00 00	 call	 _move16

; 357  :     }

  00057	eb d7		 jmp	 SHORT $LN17@build_code
$LN16@build_code:

; 358  :     
; 359  :     indx = 0;               move16 ();

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 a8	 mov	 WORD PTR _indx$[ebp], ax
  0005f	e8 00 00 00 00	 call	 _move16

; 360  :     rsign = 0;              move16 ();

  00064	33 c0		 xor	 eax, eax
  00066	66 89 45 9c	 mov	 WORD PTR _rsign$[ebp], ax
  0006a	e8 00 00 00 00	 call	 _move16

; 361  :     for (k = 0; k < NB_PULSE; k++)

  0006f	33 c0		 xor	 eax, eax
  00071	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  00075	eb 0c		 jmp	 SHORT $LN15@build_code
$LN14@build_code:
  00077	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  0007b	66 83 c0 01	 add	 ax, 1
  0007f	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
$LN15@build_code:
  00083	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00087	83 f8 03	 cmp	 eax, 3
  0008a	0f 8d 30 02 00
	00		 jge	 $LN13@build_code

; 362  :     {
; 363  :        i = codvec[k];      move16 ();  /* read pulse position */

  00090	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00097	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0009b	66 89 55 f4	 mov	 WORD PTR _i$[ebp], dx
  0009f	e8 00 00 00 00	 call	 _move16

; 364  :        j = dn_sign[i];     move16 ();  /* read sign           */

  000a4	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _dn_sign$[ebp]
  000ab	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000af	66 89 55 e8	 mov	 WORD PTR _j$[ebp], dx
  000b3	e8 00 00 00 00	 call	 _move16

; 365  :        
; 366  :        index = mult(i, 6554);    /* index = pos/5 */

  000b8	68 9a 19 00 00	 push	 6554			; 0000199aH
  000bd	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _mult
  000c7	83 c4 08	 add	 esp, 8
  000ca	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax

; 367  :                                  /* track = pos%5 */
; 368  :        track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));

  000ce	6a 01		 push	 1
  000d0	6a 05		 push	 5
  000d2	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _L_mult
  000dc	83 c4 08	 add	 esp, 8
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _L_shr
  000e5	83 c4 08	 add	 esp, 8
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _extract_l
  000ee	83 c4 04	 add	 esp, 4
  000f1	0f b7 c8	 movzx	 ecx, ax
  000f4	51		 push	 ecx
  000f5	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _sub
  000ff	83 c4 08	 add	 esp, 8
  00102	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax

; 369  :        
; 370  :        test ();

  00106	e8 00 00 00 00	 call	 _test

; 371  :        if (sub(track, 1) == 0)

  0010b	6a 01		 push	 1
  0010d	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _sub
  00117	83 c4 08	 add	 esp, 8
  0011a	0f bf c8	 movsx	 ecx, ax
  0011d	85 c9		 test	 ecx, ecx
  0011f	75 18		 jne	 SHORT $LN12@build_code

; 372  :           index = shl(index, 4);

  00121	6a 04		 push	 4
  00123	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _shl
  0012d	83 c4 08	 add	 esp, 8
  00130	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  00134	e9 e9 00 00 00	 jmp	 $LN11@build_code
$LN12@build_code:

; 373  :        else if (sub(track, 2) == 0)

  00139	6a 02		 push	 2
  0013b	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _sub
  00145	83 c4 08	 add	 esp, 8
  00148	0f bf c8	 movsx	 ecx, ax
  0014b	85 c9		 test	 ecx, ecx
  0014d	75 2b		 jne	 SHORT $LN10@build_code

; 374  :        {
; 375  :           test ();

  0014f	e8 00 00 00 00	 call	 _test

; 376  :           track = 2;                          move16 ();

  00154	b8 02 00 00 00	 mov	 eax, 2
  00159	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax
  0015d	e8 00 00 00 00	 call	 _move16

; 377  :           index = shl(index, 8);

  00162	6a 08		 push	 8
  00164	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 _shl
  0016e	83 c4 08	 add	 esp, 8
  00171	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  00175	e9 a8 00 00 00	 jmp	 $LN11@build_code
$LN10@build_code:

; 378  :        }
; 379  :        else if (sub(track, 3) == 0)

  0017a	6a 03		 push	 3
  0017c	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _sub
  00186	83 c4 08	 add	 esp, 8
  00189	0f bf c8	 movsx	 ecx, ax
  0018c	85 c9		 test	 ecx, ecx
  0018e	75 3b		 jne	 SHORT $LN8@build_code

; 380  :        {
; 381  :           test (); test ();

  00190	e8 00 00 00 00	 call	 _test
  00195	e8 00 00 00 00	 call	 _test

; 382  :           track = 1;                          move16 ();         

  0019a	b8 01 00 00 00	 mov	 eax, 1
  0019f	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax
  001a3	e8 00 00 00 00	 call	 _move16

; 383  :           index = add(shl(index, 4), 8);

  001a8	6a 08		 push	 8
  001aa	6a 04		 push	 4
  001ac	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 _shl
  001b6	83 c4 08	 add	 esp, 8
  001b9	0f b7 c8	 movzx	 ecx, ax
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 _add
  001c2	83 c4 08	 add	 esp, 8
  001c5	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  001c9	eb 57		 jmp	 SHORT $LN11@build_code
$LN8@build_code:

; 384  :        }
; 385  :        else if (sub(track, 4) == 0)

  001cb	6a 04		 push	 4
  001cd	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _sub
  001d7	83 c4 08	 add	 esp, 8
  001da	0f bf c8	 movsx	 ecx, ax
  001dd	85 c9		 test	 ecx, ecx
  001df	75 41		 jne	 SHORT $LN11@build_code

; 386  :        {
; 387  :           test (); test (); test ();

  001e1	e8 00 00 00 00	 call	 _test
  001e6	e8 00 00 00 00	 call	 _test
  001eb	e8 00 00 00 00	 call	 _test

; 388  :           track = 2;                          move16 ();

  001f0	b8 02 00 00 00	 mov	 eax, 2
  001f5	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax
  001f9	e8 00 00 00 00	 call	 _move16

; 389  :           index = add(shl(index, 8), 128);

  001fe	68 80 00 00 00	 push	 128			; 00000080H
  00203	6a 08		 push	 8
  00205	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 _shl
  0020f	83 c4 08	 add	 esp, 8
  00212	0f b7 c8	 movzx	 ecx, ax
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 _add
  0021b	83 c4 08	 add	 esp, 8
  0021e	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
$LN11@build_code:

; 390  :        }
; 391  :        
; 392  :        test ();

  00222	e8 00 00 00 00	 call	 _test

; 393  :        if (j > 0)

  00227	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0022b	85 c0		 test	 eax, eax
  0022d	7e 4e		 jle	 SHORT $LN5@build_code

; 394  :        {
; 395  :           cod[i] = 8191;                       move16 ();

  0022f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00233	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  00238	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  0023b	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0023f	e8 00 00 00 00	 call	 _move16

; 396  :           _sign[k] = 32767;                    move16 ();

  00244	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00248	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0024d	66 89 4c 45 b4	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  00252	e8 00 00 00 00	 call	 _move16

; 397  :           rsign = add(rsign, shl(1, track));

  00257	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  0025b	50		 push	 eax
  0025c	6a 01		 push	 1
  0025e	e8 00 00 00 00	 call	 _shl
  00263	83 c4 08	 add	 esp, 8
  00266	0f b7 c8	 movzx	 ecx, ax
  00269	51		 push	 ecx
  0026a	0f b7 55 9c	 movzx	 edx, WORD PTR _rsign$[ebp]
  0026e	52		 push	 edx
  0026f	e8 00 00 00 00	 call	 _add
  00274	83 c4 08	 add	 esp, 8
  00277	66 89 45 9c	 mov	 WORD PTR _rsign$[ebp], ax

; 398  :        } else {

  0027b	eb 28		 jmp	 SHORT $LN4@build_code
$LN5@build_code:

; 399  :           cod[i] = -8192;                      move16 ();

  0027d	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00281	b9 00 e0 ff ff	 mov	 ecx, -8192		; ffffe000H
  00286	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00289	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0028d	e8 00 00 00 00	 call	 _move16

; 400  :           _sign[k] = (Word16) - 32768L;        move16 ();

  00292	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00296	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  0029b	66 89 4c 45 b4	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  002a0	e8 00 00 00 00	 call	 _move16
$LN4@build_code:

; 401  :        }
; 402  :        
; 403  :        indx = add(indx, index);

  002a5	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  002a9	50		 push	 eax
  002aa	0f b7 4d a8	 movzx	 ecx, WORD PTR _indx$[ebp]
  002ae	51		 push	 ecx
  002af	e8 00 00 00 00	 call	 _add
  002b4	83 c4 08	 add	 esp, 8
  002b7	66 89 45 a8	 mov	 WORD PTR _indx$[ebp], ax

; 404  :     }

  002bb	e9 b7 fd ff ff	 jmp	 $LN14@build_code
$LN13@build_code:

; 405  :     *sign = rsign;                             move16 ();

  002c0	8b 45 1c	 mov	 eax, DWORD PTR _sign$[ebp]
  002c3	66 8b 4d 9c	 mov	 cx, WORD PTR _rsign$[ebp]
  002c7	66 89 08	 mov	 WORD PTR [eax], cx
  002ca	e8 00 00 00 00	 call	 _move16

; 406  : 
; 407  :     p0 = h - codvec[0];                        move16 ();

  002cf	b8 02 00 00 00	 mov	 eax, 2
  002d4	6b c8 00	 imul	 ecx, eax, 0
  002d7	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  002da	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  002de	d1 e0		 shl	 eax, 1
  002e0	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  002e3	2b c8		 sub	 ecx, eax
  002e5	89 4d 90	 mov	 DWORD PTR _p0$[ebp], ecx
  002e8	e8 00 00 00 00	 call	 _move16

; 408  :     p1 = h - codvec[1];                        move16 ();

  002ed	b8 02 00 00 00	 mov	 eax, 2
  002f2	c1 e0 00	 shl	 eax, 0
  002f5	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  002f8	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  002fc	d1 e2		 shl	 edx, 1
  002fe	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00301	2b c2		 sub	 eax, edx
  00303	89 45 84	 mov	 DWORD PTR _p1$[ebp], eax
  00306	e8 00 00 00 00	 call	 _move16

; 409  :     p2 = h - codvec[2];                        move16 ();

  0030b	b8 02 00 00 00	 mov	 eax, 2
  00310	d1 e0		 shl	 eax, 1
  00312	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00315	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00319	d1 e2		 shl	 edx, 1
  0031b	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  0031e	2b c2		 sub	 eax, edx
  00320	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], eax
  00326	e8 00 00 00 00	 call	 _move16

; 410  :     
; 411  :     for (i = 0; i < L_CODE; i++)

  0032b	33 c0		 xor	 eax, eax
  0032d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00331	eb 0c		 jmp	 SHORT $LN3@build_code
$LN2@build_code:
  00333	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00337	66 83 c0 01	 add	 ax, 1
  0033b	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@build_code:
  0033f	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00343	83 f8 28	 cmp	 eax, 40			; 00000028H
  00346	0f 8d fe 00 00
	00		 jge	 $LN1@build_code

; 412  :     {
; 413  :        s = 0;                                  move32 ();

  0034c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  00356	e8 00 00 00 00	 call	 _move32

; 414  :        s = L_mac(s, *p0++, _sign[0]);

  0035b	8b 45 90	 mov	 eax, DWORD PTR _p0$[ebp]
  0035e	66 8b 08	 mov	 cx, WORD PTR [eax]
  00361	66 89 8d a6 fe
	ff ff		 mov	 WORD PTR tv209[ebp], cx
  00368	8b 55 90	 mov	 edx, DWORD PTR _p0$[ebp]
  0036b	83 c2 02	 add	 edx, 2
  0036e	89 55 90	 mov	 DWORD PTR _p0$[ebp], edx
  00371	b8 02 00 00 00	 mov	 eax, 2
  00376	6b c8 00	 imul	 ecx, eax, 0
  00379	0f b7 54 0d b4	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  0037e	52		 push	 edx
  0037f	0f b7 85 a6 fe
	ff ff		 movzx	 eax, WORD PTR tv209[ebp]
  00386	50		 push	 eax
  00387	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0038d	51		 push	 ecx
  0038e	e8 00 00 00 00	 call	 _L_mac
  00393	83 c4 0c	 add	 esp, 12			; 0000000cH
  00396	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 415  :        s = L_mac(s, *p1++, _sign[1]);

  0039c	8b 45 84	 mov	 eax, DWORD PTR _p1$[ebp]
  0039f	66 8b 08	 mov	 cx, WORD PTR [eax]
  003a2	66 89 8d a6 fe
	ff ff		 mov	 WORD PTR tv217[ebp], cx
  003a9	8b 55 84	 mov	 edx, DWORD PTR _p1$[ebp]
  003ac	83 c2 02	 add	 edx, 2
  003af	89 55 84	 mov	 DWORD PTR _p1$[ebp], edx
  003b2	b8 02 00 00 00	 mov	 eax, 2
  003b7	c1 e0 00	 shl	 eax, 0
  003ba	0f b7 4c 05 b4	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  003bf	51		 push	 ecx
  003c0	0f b7 95 a6 fe
	ff ff		 movzx	 edx, WORD PTR tv217[ebp]
  003c7	52		 push	 edx
  003c8	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  003ce	50		 push	 eax
  003cf	e8 00 00 00 00	 call	 _L_mac
  003d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d7	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 416  :        s = L_mac(s, *p2++, _sign[2]);

  003dd	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p2$[ebp]
  003e3	66 8b 08	 mov	 cx, WORD PTR [eax]
  003e6	66 89 8d a6 fe
	ff ff		 mov	 WORD PTR tv225[ebp], cx
  003ed	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _p2$[ebp]
  003f3	83 c2 02	 add	 edx, 2
  003f6	89 95 78 ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], edx
  003fc	b8 02 00 00 00	 mov	 eax, 2
  00401	d1 e0		 shl	 eax, 1
  00403	0f b7 4c 05 b4	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00408	51		 push	 ecx
  00409	0f b7 95 a6 fe
	ff ff		 movzx	 edx, WORD PTR tv225[ebp]
  00410	52		 push	 edx
  00411	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00417	50		 push	 eax
  00418	e8 00 00 00 00	 call	 _L_mac
  0041d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00420	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 417  :        y[i] = round(s);                        move16 ();

  00426	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 _round
  00432	83 c4 04	 add	 esp, 4
  00435	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00439	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  0043c	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00440	e8 00 00 00 00	 call	 _move16

; 418  :     }

  00445	e9 e9 fe ff ff	 jmp	 $LN2@build_code
$LN1@build_code:

; 419  :     
; 420  :     return indx;

  0044a	66 8b 45 a8	 mov	 ax, WORD PTR _indx$[ebp]

; 421  : }

  0044e	52		 push	 edx
  0044f	8b cd		 mov	 ecx, ebp
  00451	50		 push	 eax
  00452	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@build_code
  00458	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0045d	58		 pop	 eax
  0045e	5a		 pop	 edx
  0045f	5f		 pop	 edi
  00460	5e		 pop	 esi
  00461	5b		 pop	 ebx
  00462	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00465	33 cd		 xor	 ecx, ebp
  00467	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046c	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  00472	3b ec		 cmp	 ebp, esp
  00474	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00479	8b e5		 mov	 esp, ebp
  0047b	5d		 pop	 ebp
  0047c	c3		 ret	 0
  0047d	8d 49 00	 npad	 3
$LN23@build_code:
  00480	01 00 00 00	 DD	 1
  00484	00 00 00 00	 DD	 $LN22@build_code
$LN22@build_code:
  00488	b4 ff ff ff	 DD	 -76			; ffffffb4H
  0048c	06 00 00 00	 DD	 6
  00490	00 00 00 00	 DD	 $LN21@build_code
$LN21@build_code:
  00494	5f		 DB	 95			; 0000005fH
  00495	73		 DB	 115			; 00000073H
  00496	69		 DB	 105			; 00000069H
  00497	67		 DB	 103			; 00000067H
  00498	6e		 DB	 110			; 0000006eH
  00499	00		 DB	 0
_build_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c3_14pf.c
;	COMDAT _search_3i40
_TEXT	SEGMENT
$T1 = -460						; size = 4
_alp1$ = -256						; size = 4
_alp0$ = -244						; size = 4
_s$ = -232						; size = 4
_alp_16$ = -220						; size = 2
_alp$ = -208						; size = 2
_alpk$ = -196						; size = 2
_sq1$ = -184						; size = 2
_sq$ = -172						; size = 2
_ps1$ = -160						; size = 2
_ps0$ = -148						; size = 2
_psk$ = -136						; size = 2
_ipos$ = -124						; size = 6
_track2$ = -108						; size = 2
_track1$ = -96						; size = 2
_pos$ = -84						; size = 2
_i$ = -72						; size = 2
_ps$ = -60						; size = 2
_ix$ = -48						; size = 2
_i2$ = -36						; size = 2
_i1$ = -24						; size = 2
_i0$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_dn$ = 8						; size = 4
_dn2$ = 12						; size = 4
_rr$ = 16						; size = 4
_codvec$ = 20						; size = 4
_search_3i40 PROC					; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-464]
  00012	b9 74 00 00 00	 mov	 ecx, 116		; 00000074H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 166  :     Word16 i0, i1, i2;
; 167  :     Word16 ix = 0; /* initialization only needed to keep gcc silent */

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 d0	 mov	 WORD PTR _ix$[ebp], ax

; 168  :     Word16 ps = 0; /* initialization only needed to keep gcc silent */

  0002e	33 c0		 xor	 eax, eax
  00030	66 89 45 c4	 mov	 WORD PTR _ps$[ebp], ax

; 169  :     Word16 i, pos, track1, track2, ipos[NB_PULSE];
; 170  :     Word16 psk, ps0, ps1, sq, sq1;
; 171  :     Word16 alpk, alp, alp_16;
; 172  :     Word32 s, alp0, alp1;
; 173  : 
; 174  :     psk = -1;     move16 ();

  00034	83 c8 ff	 or	 eax, -1
  00037	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _psk$[ebp], ax
  0003e	e8 00 00 00 00	 call	 _move16

; 175  :     alpk = 1;     move16 ();

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  0004f	e8 00 00 00 00	 call	 _move16

; 176  :     for (i = 0; i < NB_PULSE; i++)

  00054	33 c0		 xor	 eax, eax
  00056	66 89 45 b8	 mov	 WORD PTR _i$[ebp], ax
  0005a	eb 0c		 jmp	 SHORT $LN25@search_3i4
$LN24@search_3i4:
  0005c	66 8b 45 b8	 mov	 ax, WORD PTR _i$[ebp]
  00060	66 83 c0 01	 add	 ax, 1
  00064	66 89 45 b8	 mov	 WORD PTR _i$[ebp], ax
$LN25@search_3i4:
  00068	0f bf 45 b8	 movsx	 eax, WORD PTR _i$[ebp]
  0006c	83 f8 03	 cmp	 eax, 3
  0006f	7d 16		 jge	 SHORT $LN23@search_3i4

; 177  :     {
; 178  :        codvec[i] = i;    move16 ();

  00071	0f bf 45 b8	 movsx	 eax, WORD PTR _i$[ebp]
  00075	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00078	66 8b 55 b8	 mov	 dx, WORD PTR _i$[ebp]
  0007c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00080	e8 00 00 00 00	 call	 _move16

; 179  :     }

  00085	eb d5		 jmp	 SHORT $LN24@search_3i4
$LN23@search_3i4:

; 180  : 
; 181  :     for (track1 = 1; track1 < 4; track1 += 2)

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	66 89 45 a0	 mov	 WORD PTR _track1$[ebp], ax
  00090	eb 0b		 jmp	 SHORT $LN22@search_3i4
$LN21@search_3i4:
  00092	0f bf 45 a0	 movsx	 eax, WORD PTR _track1$[ebp]
  00096	83 c0 02	 add	 eax, 2
  00099	66 89 45 a0	 mov	 WORD PTR _track1$[ebp], ax
$LN22@search_3i4:
  0009d	0f bf 45 a0	 movsx	 eax, WORD PTR _track1$[ebp]
  000a1	83 f8 04	 cmp	 eax, 4
  000a4	0f 8d 3b 06 00
	00		 jge	 $LN27@search_3i4

; 182  :     {
; 183  :        for (track2 = 2; track2 < 5; track2 += 2)

  000aa	b8 02 00 00 00	 mov	 eax, 2
  000af	66 89 45 94	 mov	 WORD PTR _track2$[ebp], ax
  000b3	eb 0b		 jmp	 SHORT $LN19@search_3i4
$LN18@search_3i4:
  000b5	0f bf 45 94	 movsx	 eax, WORD PTR _track2$[ebp]
  000b9	83 c0 02	 add	 eax, 2
  000bc	66 89 45 94	 mov	 WORD PTR _track2$[ebp], ax
$LN19@search_3i4:
  000c0	0f bf 45 94	 movsx	 eax, WORD PTR _track2$[ebp]
  000c4	83 f8 05	 cmp	 eax, 5
  000c7	0f 8d 13 06 00
	00		 jge	 $LN17@search_3i4

; 184  :        {		
; 185  :           /* fix starting position */
; 186  : 
; 187  :           ipos[0] = 0;       move16 ();

  000cd	b8 02 00 00 00	 mov	 eax, 2
  000d2	6b c8 00	 imul	 ecx, eax, 0
  000d5	89 8d 34 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000db	83 bd 34 fe ff
	ff 06		 cmp	 DWORD PTR $T1[ebp], 6
  000e2	73 02		 jae	 SHORT $LN28@search_3i4
  000e4	eb 05		 jmp	 SHORT $LN29@search_3i4
$LN28@search_3i4:
  000e6	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN29@search_3i4:
  000eb	33 d2		 xor	 edx, edx
  000ed	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  000f3	66 89 54 05 84	 mov	 WORD PTR _ipos$[ebp+eax], dx
  000f8	e8 00 00 00 00	 call	 _move16

; 188  :           ipos[1] = track1;  move16 ();

  000fd	b8 02 00 00 00	 mov	 eax, 2
  00102	c1 e0 00	 shl	 eax, 0
  00105	66 8b 4d a0	 mov	 cx, WORD PTR _track1$[ebp]
  00109	66 89 4c 05 84	 mov	 WORD PTR _ipos$[ebp+eax], cx
  0010e	e8 00 00 00 00	 call	 _move16

; 189  :           ipos[2] = track2;  move16 ();

  00113	b8 02 00 00 00	 mov	 eax, 2
  00118	d1 e0		 shl	 eax, 1
  0011a	66 8b 4d 94	 mov	 cx, WORD PTR _track2$[ebp]
  0011e	66 89 4c 05 84	 mov	 WORD PTR _ipos$[ebp+eax], cx
  00123	e8 00 00 00 00	 call	 _move16

; 190  :           
; 191  :           /*------------------------------------------------------------------*
; 192  :            * main loop: try 3 tracks.                                         *
; 193  :            *------------------------------------------------------------------*/
; 194  :           
; 195  :           for (i = 0; i < NB_PULSE; i++)

  00128	33 c0		 xor	 eax, eax
  0012a	66 89 45 b8	 mov	 WORD PTR _i$[ebp], ax
  0012e	eb 0c		 jmp	 SHORT $LN16@search_3i4
$LN15@search_3i4:
  00130	66 8b 45 b8	 mov	 ax, WORD PTR _i$[ebp]
  00134	66 83 c0 01	 add	 ax, 1
  00138	66 89 45 b8	 mov	 WORD PTR _i$[ebp], ax
$LN16@search_3i4:
  0013c	0f bf 45 b8	 movsx	 eax, WORD PTR _i$[ebp]
  00140	83 f8 03	 cmp	 eax, 3
  00143	0f 8d 92 05 00
	00		 jge	 $LN14@search_3i4

; 196  :           {
; 197  :              /*----------------------------------------------------------------*
; 198  :               * i0 loop: try 8 positions.                                      *
; 199  :               *----------------------------------------------------------------*/
; 200  :              
; 201  :              move16 (); /* account for ptr. init. (rr[io]) */

  00149	e8 00 00 00 00	 call	 _move16

; 202  :              for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)

  0014e	b8 02 00 00 00	 mov	 eax, 2
  00153	6b c8 00	 imul	 ecx, eax, 0
  00156	66 8b 54 0d 84	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  0015b	66 89 55 f4	 mov	 WORD PTR _i0$[ebp], dx
  0015f	eb 0b		 jmp	 SHORT $LN13@search_3i4
$LN12@search_3i4:
  00161	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00165	83 c0 05	 add	 eax, 5
  00168	66 89 45 f4	 mov	 WORD PTR _i0$[ebp], ax
$LN13@search_3i4:
  0016c	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00170	83 f8 28	 cmp	 eax, 40			; 00000028H
  00173	0f 8d f5 04 00
	00		 jge	 $LN11@search_3i4

; 203  :              {
; 204  :                 test ();

  00179	e8 00 00 00 00	 call	 _test

; 205  :                 if (dn2[i0] >= 0)

  0017e	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00182	8b 4d 0c	 mov	 ecx, DWORD PTR _dn2$[ebp]
  00185	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00189	85 d2		 test	 edx, edx
  0018b	0f 8c d8 04 00
	00		 jl	 $LN10@search_3i4

; 206  :                 {
; 207  :                    ps0 = dn[i0];  move16 ();

  00191	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00198	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0019c	66 89 95 6c ff
	ff ff		 mov	 WORD PTR _ps0$[ebp], dx
  001a3	e8 00 00 00 00	 call	 _move16

; 208  :                    alp0 = L_mult(rr[i0][i0], _1_4);

  001a8	68 00 20 00 00	 push	 8192			; 00002000H
  001ad	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  001b1	6b c8 50	 imul	 ecx, eax, 80
  001b4	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  001b7	0f bf 55 f4	 movsx	 edx, WORD PTR _i0$[ebp]
  001bb	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 _L_mult
  001c5	83 c4 08	 add	 esp, 8
  001c8	89 85 0c ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 209  :                    
; 210  :                    /*----------------------------------------------------------------*
; 211  :                     * i1 loop: 8 positions.                                          *
; 212  :                     *----------------------------------------------------------------*/
; 213  :                    
; 214  :                    sq = -1;          move16 ();

  001ce	83 c8 ff	 or	 eax, -1
  001d1	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  001d8	e8 00 00 00 00	 call	 _move16

; 215  :                    alp = 1;          move16 ();

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  001e9	e8 00 00 00 00	 call	 _move16

; 216  :                    ps = 0;           move16 ();

  001ee	33 c0		 xor	 eax, eax
  001f0	66 89 45 c4	 mov	 WORD PTR _ps$[ebp], ax
  001f4	e8 00 00 00 00	 call	 _move16

; 217  :                    ix = ipos[1];     move16 ();

  001f9	b8 02 00 00 00	 mov	 eax, 2
  001fe	c1 e0 00	 shl	 eax, 0
  00201	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00206	66 89 4d d0	 mov	 WORD PTR _ix$[ebp], cx
  0020a	e8 00 00 00 00	 call	 _move16

; 218  :                 
; 219  :                    /* initialize 4 index for next loop. */
; 220  :                    /*-------------------------------------------------------------------*
; 221  :                     *  These index have low complexity address computation because      *
; 222  :                     *  they are, in fact, pointers with fixed increment.  For example,  *
; 223  :                     *  "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"      *
; 224  :                     *  and incremented by "STEP".                                       *
; 225  :                     *-------------------------------------------------------------------*/
; 226  :                    
; 227  :                    move16 (); /* account for ptr. init. (rr[i1]) */

  0020f	e8 00 00 00 00	 call	 _move16

; 228  :                    move16 (); /* account for ptr. init. (dn[i1]) */

  00214	e8 00 00 00 00	 call	 _move16

; 229  :                    move16 (); /* account for ptr. init. (rr[io]) */

  00219	e8 00 00 00 00	 call	 _move16

; 230  :                    for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP)

  0021e	b8 02 00 00 00	 mov	 eax, 2
  00223	c1 e0 00	 shl	 eax, 0
  00226	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  0022b	66 89 4d e8	 mov	 WORD PTR _i1$[ebp], cx
  0022f	eb 0b		 jmp	 SHORT $LN9@search_3i4
$LN8@search_3i4:
  00231	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00235	83 c0 05	 add	 eax, 5
  00238	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
$LN9@search_3i4:
  0023c	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00240	83 f8 28	 cmp	 eax, 40			; 00000028H
  00243	0f 8d 3f 01 00
	00		 jge	 $LN7@search_3i4

; 231  :                    {
; 232  :                       ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */

  00249	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  0024d	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00250	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00254	52		 push	 edx
  00255	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _ps0$[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 _add
  00262	83 c4 08	 add	 esp, 8
  00265	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _ps1$[ebp], ax

; 233  :                       
; 234  :                       /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
; 235  :                       
; 236  :                       alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */

  0026c	68 00 20 00 00	 push	 8192			; 00002000H
  00271	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00275	6b c8 50	 imul	 ecx, eax, 80
  00278	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  0027b	0f bf 55 e8	 movsx	 edx, WORD PTR _i1$[ebp]
  0027f	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00283	50		 push	 eax
  00284	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  0028a	51		 push	 ecx
  0028b	e8 00 00 00 00	 call	 _L_mac
  00290	83 c4 0c	 add	 esp, 12			; 0000000cH
  00293	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 237  :                       alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */

  00299	68 00 40 00 00	 push	 16384			; 00004000H
  0029e	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  002a2	6b c8 50	 imul	 ecx, eax, 80
  002a5	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  002a8	0f bf 55 e8	 movsx	 edx, WORD PTR _i1$[ebp]
  002ac	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  002b0	50		 push	 eax
  002b1	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  002b7	51		 push	 ecx
  002b8	e8 00 00 00 00	 call	 _L_mac
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c0	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 238  :                       
; 239  :                       sq1 = mult(ps1, ps1);

  002c6	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _ps1$[ebp]
  002cd	50		 push	 eax
  002ce	0f b7 8d 60 ff
	ff ff		 movzx	 ecx, WORD PTR _ps1$[ebp]
  002d5	51		 push	 ecx
  002d6	e8 00 00 00 00	 call	 _mult
  002db	83 c4 08	 add	 esp, 8
  002de	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _sq1$[ebp], ax

; 240  :                       
; 241  :                       alp_16 = round(alp1);

  002e5	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 _round
  002f1	83 c4 04	 add	 esp, 4
  002f4	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 242  :                       
; 243  :                       s = L_msu(L_mult(alp, sq1), sq, alp_16);

  002fb	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  00302	50		 push	 eax
  00303	0f b7 8d 54 ff
	ff ff		 movzx	 ecx, WORD PTR _sq$[ebp]
  0030a	51		 push	 ecx
  0030b	0f b7 95 48 ff
	ff ff		 movzx	 edx, WORD PTR _sq1$[ebp]
  00312	52		 push	 edx
  00313	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _L_mult
  00320	83 c4 08	 add	 esp, 8
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 _L_msu
  00329	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032c	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 244  :                       
; 245  :                       test ();

  00332	e8 00 00 00 00	 call	 _test

; 246  :                       if (s > 0)

  00337	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  0033e	7e 43		 jle	 SHORT $LN6@search_3i4

; 247  :                       {
; 248  :                          sq = sq1;      move16 ();

  00340	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _sq1$[ebp]
  00347	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  0034e	e8 00 00 00 00	 call	 _move16

; 249  :                          ps = ps1;      move16 ();

  00353	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _ps1$[ebp]
  0035a	66 89 45 c4	 mov	 WORD PTR _ps$[ebp], ax
  0035e	e8 00 00 00 00	 call	 _move16

; 250  :                          alp = alp_16;  move16 ();

  00363	66 8b 85 24 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  0036a	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  00371	e8 00 00 00 00	 call	 _move16

; 251  :                          ix = i1;       move16 ();

  00376	66 8b 45 e8	 mov	 ax, WORD PTR _i1$[ebp]
  0037a	66 89 45 d0	 mov	 WORD PTR _ix$[ebp], ax
  0037e	e8 00 00 00 00	 call	 _move16
$LN6@search_3i4:

; 252  :                       }
; 253  :                    }

  00383	e9 a9 fe ff ff	 jmp	 $LN8@search_3i4
$LN7@search_3i4:

; 254  :                    i1 = ix;             move16 ();

  00388	66 8b 45 d0	 mov	 ax, WORD PTR _ix$[ebp]
  0038c	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
  00390	e8 00 00 00 00	 call	 _move16

; 255  :                    
; 256  :                    /*----------------------------------------------------------------*
; 257  :                     * i2 loop: 8 positions.                                          *
; 258  :                     *----------------------------------------------------------------*/
; 259  :                    
; 260  :                    ps0 = ps;            move16 ();

  00395	66 8b 45 c4	 mov	 ax, WORD PTR _ps$[ebp]
  00399	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _ps0$[ebp], ax
  003a0	e8 00 00 00 00	 call	 _move16

; 261  :                    alp0 = L_mult(alp, _1_4);

  003a5	68 00 20 00 00	 push	 8192			; 00002000H
  003aa	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 _L_mult
  003b7	83 c4 08	 add	 esp, 8
  003ba	89 85 0c ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 262  :                    
; 263  :                    sq = -1;             move16 ();

  003c0	83 c8 ff	 or	 eax, -1
  003c3	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  003ca	e8 00 00 00 00	 call	 _move16

; 264  :                    alp = 1;             move16 ();

  003cf	b8 01 00 00 00	 mov	 eax, 1
  003d4	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  003db	e8 00 00 00 00	 call	 _move16

; 265  :                    ps = 0;              move16 ();

  003e0	33 c0		 xor	 eax, eax
  003e2	66 89 45 c4	 mov	 WORD PTR _ps$[ebp], ax
  003e6	e8 00 00 00 00	 call	 _move16

; 266  :                    ix = ipos[2];        move16 ();

  003eb	b8 02 00 00 00	 mov	 eax, 2
  003f0	d1 e0		 shl	 eax, 1
  003f2	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  003f7	66 89 4d d0	 mov	 WORD PTR _ix$[ebp], cx
  003fb	e8 00 00 00 00	 call	 _move16

; 267  :                    
; 268  :                    /* initialize 4 index for next loop (see i1 loop) */
; 269  :                    
; 270  :                    move16 (); /* account for ptr. init. (rr[i2]) */

  00400	e8 00 00 00 00	 call	 _move16

; 271  :                    move16 (); /* account for ptr. init. (rr[i1]) */

  00405	e8 00 00 00 00	 call	 _move16

; 272  :                    move16 (); /* account for ptr. init. (dn[i2]) */

  0040a	e8 00 00 00 00	 call	 _move16

; 273  :                    move16 (); /* account for ptr. init. (rr[io]) */

  0040f	e8 00 00 00 00	 call	 _move16

; 274  :                    for (i2 = ipos[2]; i2 < L_CODE; i2 += STEP)

  00414	b8 02 00 00 00	 mov	 eax, 2
  00419	d1 e0		 shl	 eax, 1
  0041b	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00420	66 89 4d dc	 mov	 WORD PTR _i2$[ebp], cx
  00424	eb 0b		 jmp	 SHORT $LN5@search_3i4
$LN4@search_3i4:
  00426	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  0042a	83 c0 05	 add	 eax, 5
  0042d	66 89 45 dc	 mov	 WORD PTR _i2$[ebp], ax
$LN5@search_3i4:
  00431	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  00435	83 f8 28	 cmp	 eax, 40			; 00000028H
  00438	0f 8d 6c 01 00
	00		 jge	 $LN3@search_3i4

; 275  :                    {
; 276  :                       ps1 = add(ps0, dn[i2]); /* index increment = STEP */

  0043e	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  00442	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00445	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00449	52		 push	 edx
  0044a	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _ps0$[ebp]
  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 _add
  00457	83 c4 08	 add	 esp, 8
  0045a	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _ps1$[ebp], ax

; 277  :                       
; 278  :                       /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
; 279  :                       
; 280  :                       alp1 = L_mac(alp0, rr[i2][i2], _1_16); /* idx incr = STEP */

  00461	68 00 08 00 00	 push	 2048			; 00000800H
  00466	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  0046a	6b c8 50	 imul	 ecx, eax, 80
  0046d	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00470	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  00474	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00478	50		 push	 eax
  00479	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  0047f	51		 push	 ecx
  00480	e8 00 00 00 00	 call	 _L_mac
  00485	83 c4 0c	 add	 esp, 12			; 0000000cH
  00488	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 281  :                       alp1 = L_mac(alp1, rr[i1][i2], _1_8);  /* idx incr = STEP */

  0048e	68 00 10 00 00	 push	 4096			; 00001000H
  00493	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00497	6b c8 50	 imul	 ecx, eax, 80
  0049a	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  0049d	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  004a1	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  004a5	50		 push	 eax
  004a6	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  004ac	51		 push	 ecx
  004ad	e8 00 00 00 00	 call	 _L_mac
  004b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b5	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 282  :                       alp1 = L_mac(alp1, rr[i0][i2], _1_8);  /* idx incr = STEP */

  004bb	68 00 10 00 00	 push	 4096			; 00001000H
  004c0	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  004c4	6b c8 50	 imul	 ecx, eax, 80
  004c7	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  004ca	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  004ce	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  004d2	50		 push	 eax
  004d3	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  004d9	51		 push	 ecx
  004da	e8 00 00 00 00	 call	 _L_mac
  004df	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e2	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 283  :                       
; 284  :                       sq1 = mult(ps1, ps1);

  004e8	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _ps1$[ebp]
  004ef	50		 push	 eax
  004f0	0f b7 8d 60 ff
	ff ff		 movzx	 ecx, WORD PTR _ps1$[ebp]
  004f7	51		 push	 ecx
  004f8	e8 00 00 00 00	 call	 _mult
  004fd	83 c4 08	 add	 esp, 8
  00500	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _sq1$[ebp], ax

; 285  :                       
; 286  :                       alp_16 = round(alp1);

  00507	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  0050d	50		 push	 eax
  0050e	e8 00 00 00 00	 call	 _round
  00513	83 c4 04	 add	 esp, 4
  00516	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 287  :                       
; 288  :                       s = L_msu(L_mult(alp, sq1), sq, alp_16);

  0051d	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  00524	50		 push	 eax
  00525	0f b7 8d 54 ff
	ff ff		 movzx	 ecx, WORD PTR _sq$[ebp]
  0052c	51		 push	 ecx
  0052d	0f b7 95 48 ff
	ff ff		 movzx	 edx, WORD PTR _sq1$[ebp]
  00534	52		 push	 edx
  00535	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 _L_mult
  00542	83 c4 08	 add	 esp, 8
  00545	50		 push	 eax
  00546	e8 00 00 00 00	 call	 _L_msu
  0054b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0054e	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 289  :                       
; 290  :                       test ();

  00554	e8 00 00 00 00	 call	 _test

; 291  :                       if (s > 0)

  00559	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  00560	7e 43		 jle	 SHORT $LN2@search_3i4

; 292  :                       {
; 293  :                          sq = sq1;      move16 ();

  00562	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _sq1$[ebp]
  00569	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  00570	e8 00 00 00 00	 call	 _move16

; 294  :                          ps = ps1;      move16 ();

  00575	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _ps1$[ebp]
  0057c	66 89 45 c4	 mov	 WORD PTR _ps$[ebp], ax
  00580	e8 00 00 00 00	 call	 _move16

; 295  :                          alp = alp_16;  move16 ();

  00585	66 8b 85 24 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  0058c	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  00593	e8 00 00 00 00	 call	 _move16

; 296  :                          ix = i2;       move16 ();

  00598	66 8b 45 dc	 mov	 ax, WORD PTR _i2$[ebp]
  0059c	66 89 45 d0	 mov	 WORD PTR _ix$[ebp], ax
  005a0	e8 00 00 00 00	 call	 _move16
$LN2@search_3i4:

; 297  :                       }
; 298  :                    }

  005a5	e9 7c fe ff ff	 jmp	 $LN4@search_3i4
$LN3@search_3i4:

; 299  :                    i2 = ix;             move16 ();

  005aa	66 8b 45 d0	 mov	 ax, WORD PTR _ix$[ebp]
  005ae	66 89 45 dc	 mov	 WORD PTR _i2$[ebp], ax
  005b2	e8 00 00 00 00	 call	 _move16

; 300  :                    
; 301  :                    /*----------------------------------------------------------------*
; 302  :                     * memorise codevector if this one is better than the last one.   *
; 303  :                     *----------------------------------------------------------------*/
; 304  :                    
; 305  :                    s = L_msu(L_mult(alpk, sq), psk, alp);

  005b7	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  005be	50		 push	 eax
  005bf	0f b7 8d 78 ff
	ff ff		 movzx	 ecx, WORD PTR _psk$[ebp]
  005c6	51		 push	 ecx
  005c7	0f b7 95 54 ff
	ff ff		 movzx	 edx, WORD PTR _sq$[ebp]
  005ce	52		 push	 edx
  005cf	0f b7 85 3c ff
	ff ff		 movzx	 eax, WORD PTR _alpk$[ebp]
  005d6	50		 push	 eax
  005d7	e8 00 00 00 00	 call	 _L_mult
  005dc	83 c4 08	 add	 esp, 8
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 _L_msu
  005e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e8	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 306  :                    
; 307  :                    test ();

  005ee	e8 00 00 00 00	 call	 _test

; 308  :                    if (s > 0)

  005f3	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  005fa	7e 6d		 jle	 SHORT $LN10@search_3i4

; 309  :                    {
; 310  :                       psk = sq;         move16 ();

  005fc	66 8b 85 54 ff
	ff ff		 mov	 ax, WORD PTR _sq$[ebp]
  00603	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _psk$[ebp], ax
  0060a	e8 00 00 00 00	 call	 _move16

; 311  :                       alpk = alp;       move16 ();

  0060f	66 8b 85 30 ff
	ff ff		 mov	 ax, WORD PTR _alp$[ebp]
  00616	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  0061d	e8 00 00 00 00	 call	 _move16

; 312  :                       codvec[0] = i0;   move16 ();

  00622	b8 02 00 00 00	 mov	 eax, 2
  00627	6b c8 00	 imul	 ecx, eax, 0
  0062a	8b 55 14	 mov	 edx, DWORD PTR _codvec$[ebp]
  0062d	66 8b 45 f4	 mov	 ax, WORD PTR _i0$[ebp]
  00631	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00635	e8 00 00 00 00	 call	 _move16

; 313  :                       codvec[1] = i1;   move16 ();

  0063a	b8 02 00 00 00	 mov	 eax, 2
  0063f	c1 e0 00	 shl	 eax, 0
  00642	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00645	66 8b 55 e8	 mov	 dx, WORD PTR _i1$[ebp]
  00649	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0064d	e8 00 00 00 00	 call	 _move16

; 314  :                       codvec[2] = i2;   move16 ();

  00652	b8 02 00 00 00	 mov	 eax, 2
  00657	d1 e0		 shl	 eax, 1
  00659	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0065c	66 8b 55 dc	 mov	 dx, WORD PTR _i2$[ebp]
  00660	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00664	e8 00 00 00 00	 call	 _move16
$LN10@search_3i4:

; 315  :                    }
; 316  :                 }
; 317  :              }

  00669	e9 f3 fa ff ff	 jmp	 $LN12@search_3i4
$LN11@search_3i4:

; 318  :              /*----------------------------------------------------------------*
; 319  :               * Cyclic permutation of i0, i1 and i2.                           *
; 320  :               *----------------------------------------------------------------*/
; 321  :              
; 322  :              pos = ipos[2];          move16 ();

  0066e	b8 02 00 00 00	 mov	 eax, 2
  00673	d1 e0		 shl	 eax, 1
  00675	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  0067a	66 89 4d ac	 mov	 WORD PTR _pos$[ebp], cx
  0067e	e8 00 00 00 00	 call	 _move16

; 323  :              ipos[2] = ipos[1];      move16 ();

  00683	b8 02 00 00 00	 mov	 eax, 2
  00688	c1 e0 00	 shl	 eax, 0
  0068b	b9 02 00 00 00	 mov	 ecx, 2
  00690	d1 e1		 shl	 ecx, 1
  00692	66 8b 54 05 84	 mov	 dx, WORD PTR _ipos$[ebp+eax]
  00697	66 89 54 0d 84	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  0069c	e8 00 00 00 00	 call	 _move16

; 324  :              ipos[1] = ipos[0];      move16 ();

  006a1	b8 02 00 00 00	 mov	 eax, 2
  006a6	6b c8 00	 imul	 ecx, eax, 0
  006a9	ba 02 00 00 00	 mov	 edx, 2
  006ae	c1 e2 00	 shl	 edx, 0
  006b1	66 8b 44 0d 84	 mov	 ax, WORD PTR _ipos$[ebp+ecx]
  006b6	66 89 44 15 84	 mov	 WORD PTR _ipos$[ebp+edx], ax
  006bb	e8 00 00 00 00	 call	 _move16

; 325  :              ipos[0] = pos;          move16 ();

  006c0	b8 02 00 00 00	 mov	 eax, 2
  006c5	6b c8 00	 imul	 ecx, eax, 0
  006c8	66 8b 55 ac	 mov	 dx, WORD PTR _pos$[ebp]
  006cc	66 89 54 0d 84	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  006d1	e8 00 00 00 00	 call	 _move16

; 326  :           }

  006d6	e9 55 fa ff ff	 jmp	 $LN15@search_3i4
$LN14@search_3i4:

; 327  :        }

  006db	e9 d5 f9 ff ff	 jmp	 $LN18@search_3i4
$LN17@search_3i4:

; 328  :     }    

  006e0	e9 ad f9 ff ff	 jmp	 $LN21@search_3i4
$LN27@search_3i4:

; 329  :     return;
; 330  : }

  006e5	52		 push	 edx
  006e6	8b cd		 mov	 ecx, ebp
  006e8	50		 push	 eax
  006e9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@search_3i4
  006ef	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006f4	58		 pop	 eax
  006f5	5a		 pop	 edx
  006f6	5f		 pop	 edi
  006f7	5e		 pop	 esi
  006f8	5b		 pop	 ebx
  006f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006fc	33 cd		 xor	 ecx, ebp
  006fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00703	81 c4 d0 01 00
	00		 add	 esp, 464		; 000001d0H
  00709	3b ec		 cmp	 ebp, esp
  0070b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00710	8b e5		 mov	 esp, ebp
  00712	5d		 pop	 ebp
  00713	c3		 ret	 0
$LN32@search_3i4:
  00714	01 00 00 00	 DD	 1
  00718	00 00 00 00	 DD	 $LN31@search_3i4
$LN31@search_3i4:
  0071c	84 ff ff ff	 DD	 -124			; ffffff84H
  00720	06 00 00 00	 DD	 6
  00724	00 00 00 00	 DD	 $LN30@search_3i4
$LN30@search_3i4:
  00728	69		 DB	 105			; 00000069H
  00729	70		 DB	 112			; 00000070H
  0072a	6f		 DB	 111			; 0000006fH
  0072b	73		 DB	 115			; 00000073H
  0072c	00		 DB	 0
_search_3i40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c3_14pf.c
;	COMDAT _code_3i40_14bits
_TEXT	SEGMENT
_sharp$ = -3524						; size = 2
_index$ = -3512						; size = 2
_i$ = -3500						; size = 2
_rr$ = -3488						; size = 3200
_dn_sign$ = -280					; size = 80
_dn2$ = -192						; size = 80
_dn$ = -104						; size = 80
_codvec$ = -16						; size = 6
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_h$ = 12						; size = 4
_T0$ = 16						; size = 2
_pitch_sharp$ = 20					; size = 2
_code$ = 24						; size = 4
_y$ = 28						; size = 4
_sign$ = 32						; size = 4
_code_3i40_14bits PROC					; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 0e 00
	00		 sub	 esp, 3720		; 00000e88H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 78 f1 ff
	ff		 lea	 edi, DWORD PTR [ebp-3720]
  00012	b9 a2 03 00 00	 mov	 ecx, 930		; 000003a2H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 103  :     Word16 codvec[NB_PULSE];
; 104  :     Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
; 105  :     Word16 rr[L_CODE][L_CODE];
; 106  :     Word16 i, index, sharp;
; 107  : 
; 108  :     sharp = shl(pitch_sharp, 1);

  00028	6a 01		 push	 1
  0002a	0f b7 45 14	 movzx	 eax, WORD PTR _pitch_sharp$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _shl
  00034	83 c4 08	 add	 esp, 8
  00037	66 89 85 3c f2
	ff ff		 mov	 WORD PTR _sharp$[ebp], ax

; 109  :     test ();

  0003e	e8 00 00 00 00	 call	 _test

; 110  :     if (sub(T0, L_CODE) < 0)

  00043	6a 28		 push	 40			; 00000028H
  00045	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _sub
  0004f	83 c4 08	 add	 esp, 8
  00052	0f bf c8	 movsx	 ecx, ax
  00055	85 c9		 test	 ecx, ecx
  00057	0f 8d 80 00 00
	00		 jge	 $LN8@code_3i40_

; 111  :     {
; 112  :        for (i = T0; i < L_CODE; i++) {

  0005d	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00061	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00068	eb 12		 jmp	 SHORT $LN7@code_3i40_
$LN6@code_3i40_:
  0006a	66 8b 85 54 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@code_3i40_:
  0007c	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00083	83 f8 28	 cmp	 eax, 40			; 00000028H
  00086	7d 55		 jge	 SHORT $LN8@code_3i40_

; 113  :           h[i] = add(h[i], mult(h[i - T0], sharp));      move16 ();

  00088	0f b7 85 3c f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  0008f	50		 push	 eax
  00090	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00097	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  0009b	2b ca		 sub	 ecx, edx
  0009d	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  000a0	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _mult
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b7 d0	 movzx	 edx, ax
  000b0	52		 push	 edx
  000b1	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  000bb	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _add
  000c5	83 c4 08	 add	 esp, 8
  000c8	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  000cf	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000d2	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  000d6	e8 00 00 00 00	 call	 _move16

; 114  :        }

  000db	eb 8d		 jmp	 SHORT $LN6@code_3i40_
$LN8@code_3i40_:

; 115  :     }
; 116  :     
; 117  :     cor_h_x(h, x, dn, 1);

  000dd	6a 01		 push	 1
  000df	8d 45 98	 lea	 eax, DWORD PTR _dn$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _cor_h_x
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 118  :     set_sign(dn, dn_sign, dn2, 6);

  000f3	6a 06		 push	 6
  000f5	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _dn2$[ebp]
  000fb	50		 push	 eax
  000fc	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00102	51		 push	 ecx
  00103	8d 55 98	 lea	 edx, DWORD PTR _dn$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _set_sign
  0010c	83 c4 10	 add	 esp, 16			; 00000010H

; 119  :     cor_h(h, dn_sign, rr);

  0010f	8d 85 60 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00115	50		 push	 eax
  00116	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _cor_h
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  :     search_3i40(dn, dn2, rr, codvec);

  00129	8d 45 f0	 lea	 eax, DWORD PTR _codvec$[ebp]
  0012c	50		 push	 eax
  0012d	8d 8d 60 f2 ff
	ff		 lea	 ecx, DWORD PTR _rr$[ebp]
  00133	51		 push	 ecx
  00134	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _dn2$[ebp]
  0013a	52		 push	 edx
  0013b	8d 45 98	 lea	 eax, DWORD PTR _dn$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _search_3i40
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 121  :                                     move16 (); /* function result */

  00147	e8 00 00 00 00	 call	 _move16

; 122  :     index = build_code(codvec, dn_sign, code, h, y, sign);

  0014c	8b 45 20	 mov	 eax, DWORD PTR _sign$[ebp]
  0014f	50		 push	 eax
  00150	8b 4d 1c	 mov	 ecx, DWORD PTR _y$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00157	52		 push	 edx
  00158	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  0015b	50		 push	 eax
  0015c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00162	51		 push	 ecx
  00163	8d 55 f0	 lea	 edx, DWORD PTR _codvec$[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 _build_code
  0016c	83 c4 18	 add	 esp, 24			; 00000018H
  0016f	66 89 85 48 f2
	ff ff		 mov	 WORD PTR _index$[ebp], ax

; 123  : 
; 124  :   /*-----------------------------------------------------------------*
; 125  :   * Compute innovation vector gain.                                 *
; 126  :   * Include fixed-gain pitch contribution into code[].              *
; 127  :   *-----------------------------------------------------------------*/
; 128  : 
; 129  :     test ();

  00176	e8 00 00 00 00	 call	 _test

; 130  :     if (sub(T0, L_CODE) < 0)

  0017b	6a 28		 push	 40			; 00000028H
  0017d	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _sub
  00187	83 c4 08	 add	 esp, 8
  0018a	0f bf c8	 movsx	 ecx, ax
  0018d	85 c9		 test	 ecx, ecx
  0018f	0f 8d 80 00 00
	00		 jge	 $LN4@code_3i40_

; 131  :     {
; 132  :        for (i = T0; i < L_CODE; i++) { 

  00195	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00199	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  001a0	eb 12		 jmp	 SHORT $LN3@code_3i40_
$LN2@code_3i40_:
  001a2	66 8b 85 54 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  001a9	66 83 c0 01	 add	 ax, 1
  001ad	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN3@code_3i40_:
  001b4	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001bb	83 f8 28	 cmp	 eax, 40			; 00000028H
  001be	7d 55		 jge	 SHORT $LN4@code_3i40_

; 133  :           code[i] = add(code[i], mult(code[i - T0], sharp));    move16 ();

  001c0	0f b7 85 3c f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  001c7	50		 push	 eax
  001c8	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  001cf	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  001d3	2b ca		 sub	 ecx, edx
  001d5	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  001d8	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  001dc	51		 push	 ecx
  001dd	e8 00 00 00 00	 call	 _mult
  001e2	83 c4 08	 add	 esp, 8
  001e5	0f b7 d0	 movzx	 edx, ax
  001e8	52		 push	 edx
  001e9	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001f0	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  001f3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001f7	52		 push	 edx
  001f8	e8 00 00 00 00	 call	 _add
  001fd	83 c4 08	 add	 esp, 8
  00200	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00207	8b 55 18	 mov	 edx, DWORD PTR _code$[ebp]
  0020a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0020e	e8 00 00 00 00	 call	 _move16

; 134  :        }

  00213	eb 8d		 jmp	 SHORT $LN2@code_3i40_
$LN4@code_3i40_:

; 135  :     }
; 136  :     return index;

  00215	66 8b 85 48 f2
	ff ff		 mov	 ax, WORD PTR _index$[ebp]

; 137  : }

  0021c	52		 push	 edx
  0021d	8b cd		 mov	 ecx, ebp
  0021f	50		 push	 eax
  00220	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@code_3i40_
  00226	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022b	58		 pop	 eax
  0022c	5a		 pop	 edx
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi
  0022f	5b		 pop	 ebx
  00230	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00233	33 cd		 xor	 ecx, ebp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	81 c4 88 0e 00
	00		 add	 esp, 3720		; 00000e88H
  00240	3b ec		 cmp	 ebp, esp
  00242	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
  0024b	90		 npad	 1
$LN17@code_3i40_:
  0024c	05 00 00 00	 DD	 5
  00250	00 00 00 00	 DD	 $LN16@code_3i40_
$LN16@code_3i40_:
  00254	f0 ff ff ff	 DD	 -16			; fffffff0H
  00258	06 00 00 00	 DD	 6
  0025c	00 00 00 00	 DD	 $LN11@code_3i40_
  00260	98 ff ff ff	 DD	 -104			; ffffff98H
  00264	50 00 00 00	 DD	 80			; 00000050H
  00268	00 00 00 00	 DD	 $LN12@code_3i40_
  0026c	40 ff ff ff	 DD	 -192			; ffffff40H
  00270	50 00 00 00	 DD	 80			; 00000050H
  00274	00 00 00 00	 DD	 $LN13@code_3i40_
  00278	e8 fe ff ff	 DD	 -280			; fffffee8H
  0027c	50 00 00 00	 DD	 80			; 00000050H
  00280	00 00 00 00	 DD	 $LN14@code_3i40_
  00284	60 f2 ff ff	 DD	 -3488			; fffff260H
  00288	80 0c 00 00	 DD	 3200			; 00000c80H
  0028c	00 00 00 00	 DD	 $LN15@code_3i40_
$LN15@code_3i40_:
  00290	72		 DB	 114			; 00000072H
  00291	72		 DB	 114			; 00000072H
  00292	00		 DB	 0
$LN14@code_3i40_:
  00293	64		 DB	 100			; 00000064H
  00294	6e		 DB	 110			; 0000006eH
  00295	5f		 DB	 95			; 0000005fH
  00296	73		 DB	 115			; 00000073H
  00297	69		 DB	 105			; 00000069H
  00298	67		 DB	 103			; 00000067H
  00299	6e		 DB	 110			; 0000006eH
  0029a	00		 DB	 0
$LN13@code_3i40_:
  0029b	64		 DB	 100			; 00000064H
  0029c	6e		 DB	 110			; 0000006eH
  0029d	32		 DB	 50			; 00000032H
  0029e	00		 DB	 0
$LN12@code_3i40_:
  0029f	64		 DB	 100			; 00000064H
  002a0	6e		 DB	 110			; 0000006eH
  002a1	00		 DB	 0
$LN11@code_3i40_:
  002a2	63		 DB	 99			; 00000063H
  002a3	6f		 DB	 111			; 0000006fH
  002a4	64		 DB	 100			; 00000064H
  002a5	76		 DB	 118			; 00000076H
  002a6	65		 DB	 101			; 00000065H
  002a7	63		 DB	 99			; 00000063H
  002a8	00		 DB	 0
_code_3i40_14bits ENDP
_TEXT	ENDS
END
