; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\cor_h.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cor_h_id
CONST	SEGMENT
_cor_h_id DB	'@(#)$Id $@(#)$Id $', 00H
CONST	ENDS
PUBLIC	_cor_h_x
PUBLIC	_cor_h_x2
PUBLIC	_cor_h
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_add:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_abs:PROC
EXTRN	_norm_l:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Inv_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cor_h.c
;	COMDAT _cor_h
_TEXT	SEGMENT
_s$ = -148						; size = 4
_h2$ = -136						; size = 80
_dec$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_h$ = 8							; size = 4
_sign$ = 12						; size = 4
_rr$ = 16						; size = 4
_cor_h	PROC						; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-344]
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 141  :     Word16 i, j, k, dec, h2[L_CODE];
; 142  :     Word32 s;
; 143  : 
; 144  :     /* Scaling for maximum precision */
; 145  : 
; 146  :     s = 2;                                       move32 (); 

  00028	c7 85 6c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _s$[ebp], 2
  00032	e8 00 00 00 00	 call	 _move32

; 147  :     for (i = 0; i < L_CODE; i++)

  00037	33 c0		 xor	 eax, eax
  00039	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0003d	eb 0c		 jmp	 SHORT $LN20@cor_h
$LN19@cor_h:
  0003f	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00043	66 83 c0 01	 add	 ax, 1
  00047	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN20@cor_h:
  0004b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0004f	83 f8 28	 cmp	 eax, 40			; 00000028H
  00052	7d 2f		 jge	 SHORT $LN18@cor_h

; 148  :         s = L_mac (s, h[i], h[i]);

  00054	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  0005b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0005f	52		 push	 edx
  00060	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  00067	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0006b	52		 push	 edx
  0006c	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _L_mac
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax
  00081	eb bc		 jmp	 SHORT $LN19@cor_h
$LN18@cor_h:

; 149  :     
; 150  :     j = sub (extract_h (s), 32767);

  00083	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00088	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _extract_h
  00094	83 c4 04	 add	 esp, 4
  00097	0f b7 c8	 movzx	 ecx, ax
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _sub
  000a0	83 c4 08	 add	 esp, 8
  000a3	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 151  :     test (); 

  000a7	e8 00 00 00 00	 call	 _test

; 152  :     if (j == 0)

  000ac	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000b0	85 c0		 test	 eax, eax
  000b2	75 4b		 jne	 SHORT $LN17@cor_h

; 153  :     {
; 154  :         for (i = 0; i < L_CODE; i++)

  000b4	33 c0		 xor	 eax, eax
  000b6	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  000ba	eb 0c		 jmp	 SHORT $LN16@cor_h
$LN15@cor_h:
  000bc	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  000c0	66 83 c0 01	 add	 ax, 1
  000c4	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN16@cor_h:
  000c8	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000cc	83 f8 28	 cmp	 eax, 40			; 00000028H
  000cf	7d 29		 jge	 SHORT $LN14@cor_h

; 155  :         {
; 156  :             h2[i] = shr (h[i], 1);               move16 (); 

  000d1	6a 01		 push	 1
  000d3	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _h$[ebp]
  000da	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _shr
  000e4	83 c4 08	 add	 esp, 8
  000e7	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  000eb	66 89 84 4d 78
	ff ff ff	 mov	 WORD PTR _h2$[ebp+ecx*2], ax
  000f3	e8 00 00 00 00	 call	 _move16

; 157  :         }

  000f8	eb c2		 jmp	 SHORT $LN15@cor_h
$LN14@cor_h:

; 158  :     }
; 159  :     else

  000fa	e9 b1 00 00 00	 jmp	 $LN13@cor_h
$LN17@cor_h:

; 160  :     {
; 161  :         s = L_shr (s, 1);

  000ff	6a 01		 push	 1
  00101	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _L_shr
  0010d	83 c4 08	 add	 esp, 8
  00110	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 162  :         k = extract_h (L_shl (Inv_sqrt (s), 7));

  00116	6a 07		 push	 7
  00118	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _Inv_sqrt
  00124	83 c4 04	 add	 esp, 4
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _L_shl
  0012d	83 c4 08	 add	 esp, 8
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _extract_h
  00136	83 c4 04	 add	 esp, 4
  00139	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax

; 163  :         k = mult (k, 32440);                     /* k = 0.99*k */

  0013d	68 b8 7e 00 00	 push	 32440			; 00007eb8H
  00142	0f b7 45 dc	 movzx	 eax, WORD PTR _k$[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _mult
  0014c	83 c4 08	 add	 esp, 8
  0014f	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax

; 164  :         
; 165  :         for (i = 0; i < L_CODE; i++)

  00153	33 c0		 xor	 eax, eax
  00155	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00159	eb 0c		 jmp	 SHORT $LN12@cor_h
$LN11@cor_h:
  0015b	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0015f	66 83 c0 01	 add	 ax, 1
  00163	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN12@cor_h:
  00167	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0016b	83 f8 28	 cmp	 eax, 40			; 00000028H
  0016e	7d 40		 jge	 SHORT $LN13@cor_h

; 166  :         {
; 167  :             h2[i] = round (L_shl (L_mult (h[i], k), 9));

  00170	6a 09		 push	 9
  00172	0f b7 45 dc	 movzx	 eax, WORD PTR _k$[ebp]
  00176	50		 push	 eax
  00177	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0017b	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  0017e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _L_mult
  00188	83 c4 08	 add	 esp, 8
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _L_shl
  00191	83 c4 08	 add	 esp, 8
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _round
  0019a	83 c4 04	 add	 esp, 4
  0019d	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  001a1	66 89 84 4d 78
	ff ff ff	 mov	 WORD PTR _h2$[ebp+ecx*2], ax

; 168  :                                                  move16 (); 

  001a9	e8 00 00 00 00	 call	 _move16

; 169  :         }

  001ae	eb ab		 jmp	 SHORT $LN11@cor_h
$LN13@cor_h:

; 170  :     }
; 171  :     
; 172  :     /* build matrix rr[] */
; 173  :     s = 0;                                       move32 (); 

  001b0	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  001ba	e8 00 00 00 00	 call	 _move32

; 174  :     i = L_CODE - 1;

  001bf	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  001c4	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 175  :     for (k = 0; k < L_CODE; k++, i--)

  001c8	33 c0		 xor	 eax, eax
  001ca	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  001ce	eb 18		 jmp	 SHORT $LN9@cor_h
$LN8@cor_h:
  001d0	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  001d4	66 83 c0 01	 add	 ax, 1
  001d8	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  001dc	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  001e0	66 83 e9 01	 sub	 cx, 1
  001e4	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
$LN9@cor_h:
  001e8	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  001ec	83 f8 28	 cmp	 eax, 40			; 00000028H
  001ef	7d 57		 jge	 SHORT $LN7@cor_h

; 176  :     {
; 177  :         s = L_mac (s, h2[k], h2[k]);

  001f1	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  001f5	0f b7 8c 45 78
	ff ff ff	 movzx	 ecx, WORD PTR _h2$[ebp+eax*2]
  001fd	51		 push	 ecx
  001fe	0f bf 55 dc	 movsx	 edx, WORD PTR _k$[ebp]
  00202	0f b7 84 55 78
	ff ff ff	 movzx	 eax, WORD PTR _h2$[ebp+edx*2]
  0020a	50		 push	 eax
  0020b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 _L_mac
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021a	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 178  :         rr[i][i] = round (s);                    move16 (); 

  00220	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 _round
  0022c	83 c4 04	 add	 esp, 4
  0022f	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00233	6b d1 50	 imul	 edx, ecx, 80
  00236	03 55 10	 add	 edx, DWORD PTR _rr$[ebp]
  00239	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0023d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00241	e8 00 00 00 00	 call	 _move16

; 179  :     }

  00246	eb 88		 jmp	 SHORT $LN8@cor_h
$LN7@cor_h:

; 180  :     
; 181  :     for (dec = 1; dec < L_CODE; dec++)

  00248	b8 01 00 00 00	 mov	 eax, 1
  0024d	66 89 45 d0	 mov	 WORD PTR _dec$[ebp], ax
  00251	eb 0c		 jmp	 SHORT $LN6@cor_h
$LN5@cor_h:
  00253	66 8b 45 d0	 mov	 ax, WORD PTR _dec$[ebp]
  00257	66 83 c0 01	 add	 ax, 1
  0025b	66 89 45 d0	 mov	 WORD PTR _dec$[ebp], ax
$LN6@cor_h:
  0025f	0f bf 45 d0	 movsx	 eax, WORD PTR _dec$[ebp]
  00263	83 f8 28	 cmp	 eax, 40			; 00000028H
  00266	0f 8d 2f 01 00
	00		 jge	 $LN21@cor_h

; 182  :     {
; 183  :         s = 0;                                   move32 (); 

  0026c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  00276	e8 00 00 00 00	 call	 _move32

; 184  :         j = L_CODE - 1;

  0027b	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  00280	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 185  :         i = sub (j, dec);

  00284	0f b7 45 d0	 movzx	 eax, WORD PTR _dec$[ebp]
  00288	50		 push	 eax
  00289	0f b7 4d e8	 movzx	 ecx, WORD PTR _j$[ebp]
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 _sub
  00293	83 c4 08	 add	 esp, 8
  00296	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 186  :         for (k = 0; k < (L_CODE - dec); k++, i--, j--)

  0029a	33 c0		 xor	 eax, eax
  0029c	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  002a0	eb 24		 jmp	 SHORT $LN3@cor_h
$LN2@cor_h:
  002a2	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  002a6	66 83 c0 01	 add	 ax, 1
  002aa	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  002ae	66 8b 4d f4	 mov	 cx, WORD PTR _i$[ebp]
  002b2	66 83 e9 01	 sub	 cx, 1
  002b6	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
  002ba	66 8b 55 e8	 mov	 dx, WORD PTR _j$[ebp]
  002be	66 83 ea 01	 sub	 dx, 1
  002c2	66 89 55 e8	 mov	 WORD PTR _j$[ebp], dx
$LN3@cor_h:
  002c6	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  002ca	0f bf 4d d0	 movsx	 ecx, WORD PTR _dec$[ebp]
  002ce	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  002d3	2b d1		 sub	 edx, ecx
  002d5	3b c2		 cmp	 eax, edx
  002d7	0f 8d b9 00 00
	00		 jge	 $LN1@cor_h

; 187  :         {
; 188  :             s = L_mac (s, h2[k], h2[k + dec]);

  002dd	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  002e1	0f bf 4d d0	 movsx	 ecx, WORD PTR _dec$[ebp]
  002e5	03 c1		 add	 eax, ecx
  002e7	0f b7 94 45 78
	ff ff ff	 movzx	 edx, WORD PTR _h2$[ebp+eax*2]
  002ef	52		 push	 edx
  002f0	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  002f4	0f b7 8c 45 78
	ff ff ff	 movzx	 ecx, WORD PTR _h2$[ebp+eax*2]
  002fc	51		 push	 ecx
  002fd	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _s$[ebp]
  00303	52		 push	 edx
  00304	e8 00 00 00 00	 call	 _L_mac
  00309	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 189  :             rr[j][i] = mult (round (s), mult (sign[i], sign[j]));

  00312	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00316	8b 4d 0c	 mov	 ecx, DWORD PTR _sign$[ebp]
  00319	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0031d	52		 push	 edx
  0031e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00322	8b 4d 0c	 mov	 ecx, DWORD PTR _sign$[ebp]
  00325	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00329	52		 push	 edx
  0032a	e8 00 00 00 00	 call	 _mult
  0032f	83 c4 08	 add	 esp, 8
  00332	0f b7 c0	 movzx	 eax, ax
  00335	50		 push	 eax
  00336	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0033c	51		 push	 ecx
  0033d	e8 00 00 00 00	 call	 _round
  00342	83 c4 04	 add	 esp, 4
  00345	0f b7 d0	 movzx	 edx, ax
  00348	52		 push	 edx
  00349	e8 00 00 00 00	 call	 _mult
  0034e	83 c4 08	 add	 esp, 8
  00351	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00355	6b d1 50	 imul	 edx, ecx, 80
  00358	03 55 10	 add	 edx, DWORD PTR _rr$[ebp]
  0035b	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0035f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 190  :                                                  move16 (); 

  00363	e8 00 00 00 00	 call	 _move16

; 191  :             rr[i][j] = rr[j][i];                 move16 (); 

  00368	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0036c	6b c8 50	 imul	 ecx, eax, 80
  0036f	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00372	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  00376	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0037a	6b c0 50	 imul	 eax, eax, 80
  0037d	03 45 10	 add	 eax, DWORD PTR _rr$[ebp]
  00380	0f bf 75 e8	 movsx	 esi, WORD PTR _j$[ebp]
  00384	66 8b 0c 51	 mov	 cx, WORD PTR [ecx+edx*2]
  00388	66 89 0c 70	 mov	 WORD PTR [eax+esi*2], cx
  0038c	e8 00 00 00 00	 call	 _move16

; 192  :         }

  00391	e9 0c ff ff ff	 jmp	 $LN2@cor_h
$LN1@cor_h:

; 193  :     }

  00396	e9 b8 fe ff ff	 jmp	 $LN5@cor_h
$LN21@cor_h:

; 194  : }

  0039b	52		 push	 edx
  0039c	8b cd		 mov	 ecx, ebp
  0039e	50		 push	 eax
  0039f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@cor_h
  003a5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003aa	58		 pop	 eax
  003ab	5a		 pop	 edx
  003ac	5f		 pop	 edi
  003ad	5e		 pop	 esi
  003ae	5b		 pop	 ebx
  003af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b2	33 cd		 xor	 ecx, ebp
  003b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b9	81 c4 58 01 00
	00		 add	 esp, 344		; 00000158H
  003bf	3b ec		 cmp	 ebp, esp
  003c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c6	8b e5		 mov	 esp, ebp
  003c8	5d		 pop	 ebp
  003c9	c3		 ret	 0
  003ca	8b ff		 npad	 2
$LN25@cor_h:
  003cc	01 00 00 00	 DD	 1
  003d0	00 00 00 00	 DD	 $LN24@cor_h
$LN24@cor_h:
  003d4	78 ff ff ff	 DD	 -136			; ffffff78H
  003d8	50 00 00 00	 DD	 80			; 00000050H
  003dc	00 00 00 00	 DD	 $LN23@cor_h
$LN23@cor_h:
  003e0	68		 DB	 104			; 00000068H
  003e1	32		 DB	 50			; 00000032H
  003e2	00		 DB	 0
_cor_h	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cor_h.c
;	COMDAT _cor_h_x2
_TEXT	SEGMENT
_tot$ = -240						; size = 4
_max$ = -228						; size = 4
_y32$ = -216						; size = 160
_s$ = -48						; size = 4
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_h$ = 8							; size = 4
_x$ = 12						; size = 4
_dn$ = 16						; size = 4
_sf$ = 20						; size = 2
_nb_track$ = 24						; size = 2
_step$ = 28						; size = 2
_cor_h_x2 PROC						; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 4c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-436]
  00012	b9 6d 00 00 00	 mov	 ecx, 109		; 0000006dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 85   :     Word16 i, j, k;
; 86   :     Word32 s, y32[L_CODE], max, tot;
; 87   : 
; 88   :     /* first keep the result on 32 bits and find absolute maximum */
; 89   : 
; 90   :     tot = 5;                                     move32 (); 

  00028	c7 85 10 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _tot$[ebp], 5
  00032	e8 00 00 00 00	 call	 _move32

; 91   : 
; 92   :     for (k = 0; k < nb_track; k++)

  00037	33 c0		 xor	 eax, eax
  00039	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  0003d	eb 0c		 jmp	 SHORT $LN13@cor_h_x2
$LN12@cor_h_x2:
  0003f	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  00043	66 83 c0 01	 add	 ax, 1
  00047	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
$LN13@cor_h_x2:
  0004b	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  0004f	0f bf 4d 18	 movsx	 ecx, WORD PTR _nb_track$[ebp]
  00053	3b c1		 cmp	 eax, ecx
  00055	0f 8d 0b 01 00
	00		 jge	 $LN11@cor_h_x2

; 93   :     {
; 94   :         max = 0;                                 move32 (); 

  0005b	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _max$[ebp], 0
  00065	e8 00 00 00 00	 call	 _move32

; 95   :         for (i = k; i < L_CODE; i += step)

  0006a	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  0006e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00072	eb 0e		 jmp	 SHORT $LN10@cor_h_x2
$LN9@cor_h_x2:
  00074	0f bf 45 1c	 movsx	 eax, WORD PTR _step$[ebp]
  00078	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0007c	03 c8		 add	 ecx, eax
  0007e	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx
$LN10@cor_h_x2:
  00082	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00086	83 f8 28	 cmp	 eax, 40			; 00000028H
  00089	0f 8d ab 00 00
	00		 jge	 $LN8@cor_h_x2

; 96   :         {
; 97   :             s = 0;                               move32 (); 

  0008f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _s$[ebp], 0
  00096	e8 00 00 00 00	 call	 _move32

; 98   :             for (j = i; j < L_CODE; j++)

  0009b	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0009f	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  000a3	eb 0c		 jmp	 SHORT $LN7@cor_h_x2
$LN6@cor_h_x2:
  000a5	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  000a9	66 83 c0 01	 add	 ax, 1
  000ad	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN7@cor_h_x2:
  000b1	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000b5	83 f8 28	 cmp	 eax, 40			; 00000028H
  000b8	7d 2f		 jge	 SHORT $LN5@cor_h_x2

; 99   :                 s = L_mac (s, x[j], h[j - i]);

  000ba	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000be	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  000c2	2b c1		 sub	 eax, ecx
  000c4	8b 55 08	 mov	 edx, DWORD PTR _h$[ebp]
  000c7	0f b7 04 42	 movzx	 eax, WORD PTR [edx+eax*2]
  000cb	50		 push	 eax
  000cc	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  000d3	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  000d7	50		 push	 eax
  000d8	8b 4d d0	 mov	 ecx, DWORD PTR _s$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _L_mac
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	89 45 d0	 mov	 DWORD PTR _s$[ebp], eax
  000e7	eb bc		 jmp	 SHORT $LN6@cor_h_x2
$LN5@cor_h_x2:

; 100  :             
; 101  :             y32[i] = s;                          move32 (); 

  000e9	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000ed	8b 4d d0	 mov	 ecx, DWORD PTR _s$[ebp]
  000f0	89 8c 85 28 ff
	ff ff		 mov	 DWORD PTR _y32$[ebp+eax*4], ecx
  000f7	e8 00 00 00 00	 call	 _move32

; 102  :             
; 103  :             s = L_abs (s);

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _s$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _L_abs
  00105	83 c4 04	 add	 esp, 4
  00108	89 45 d0	 mov	 DWORD PTR _s$[ebp], eax

; 104  :             test (); 

  0010b	e8 00 00 00 00	 call	 _test

; 105  :             if (L_sub (s, max) > (Word32) 0L)

  00110	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _max$[ebp]
  00116	50		 push	 eax
  00117	8b 4d d0	 mov	 ecx, DWORD PTR _s$[ebp]
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 _L_sub
  00120	83 c4 08	 add	 esp, 8
  00123	85 c0		 test	 eax, eax
  00125	7e 09		 jle	 SHORT $LN4@cor_h_x2

; 106  :                 max = s;                         move32 (); 

  00127	8b 45 d0	 mov	 eax, DWORD PTR _s$[ebp]
  0012a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _max$[ebp], eax
$LN4@cor_h_x2:
  00130	e8 00 00 00 00	 call	 _move32

; 107  :         }

  00135	e9 3a ff ff ff	 jmp	 $LN9@cor_h_x2
$LN8@cor_h_x2:

; 108  :         tot = L_add (tot, L_shr (max, 1));

  0013a	6a 01		 push	 1
  0013c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _max$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _L_shr
  00148	83 c4 08	 add	 esp, 8
  0014b	50		 push	 eax
  0014c	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _tot$[ebp]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _L_add
  00158	83 c4 08	 add	 esp, 8
  0015b	89 85 10 ff ff
	ff		 mov	 DWORD PTR _tot$[ebp], eax

; 109  :     }

  00161	e9 d9 fe ff ff	 jmp	 $LN12@cor_h_x2
$LN11@cor_h_x2:

; 110  :     
; 111  :     j = sub (norm_l (tot), sf);

  00166	0f b7 45 14	 movzx	 eax, WORD PTR _sf$[ebp]
  0016a	50		 push	 eax
  0016b	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _tot$[ebp]
  00171	51		 push	 ecx
  00172	e8 00 00 00 00	 call	 _norm_l
  00177	83 c4 04	 add	 esp, 4
  0017a	0f b7 d0	 movzx	 edx, ax
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 _sub
  00183	83 c4 08	 add	 esp, 8
  00186	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax

; 112  :     
; 113  :     for (i = 0; i < L_CODE; i++)

  0018a	33 c0		 xor	 eax, eax
  0018c	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00190	eb 0c		 jmp	 SHORT $LN3@cor_h_x2
$LN2@cor_h_x2:
  00192	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00196	66 83 c0 01	 add	 ax, 1
  0019a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@cor_h_x2:
  0019e	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001a2	83 f8 28	 cmp	 eax, 40			; 00000028H
  001a5	7d 34		 jge	 SHORT $LN14@cor_h_x2

; 114  :     {
; 115  :         dn[i] = round (L_shl (y32[i], j));       move16 (); 

  001a7	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  001ab	50		 push	 eax
  001ac	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  001b0	8b 94 8d 28 ff
	ff ff		 mov	 edx, DWORD PTR _y32$[ebp+ecx*4]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 _L_shl
  001bd	83 c4 08	 add	 esp, 8
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 _round
  001c6	83 c4 04	 add	 esp, 4
  001c9	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  001cd	8b 55 10	 mov	 edx, DWORD PTR _dn$[ebp]
  001d0	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  001d4	e8 00 00 00 00	 call	 _move16

; 116  :     }

  001d9	eb b7		 jmp	 SHORT $LN2@cor_h_x2
$LN14@cor_h_x2:

; 117  : }

  001db	52		 push	 edx
  001dc	8b cd		 mov	 ecx, ebp
  001de	50		 push	 eax
  001df	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@cor_h_x2
  001e5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ea	58		 pop	 eax
  001eb	5a		 pop	 edx
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx
  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	81 c4 b4 01 00
	00		 add	 esp, 436		; 000001b4H
  001ff	3b ec		 cmp	 ebp, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
  0020a	8b ff		 npad	 2
$LN18@cor_h_x2:
  0020c	01 00 00 00	 DD	 1
  00210	00 00 00 00	 DD	 $LN17@cor_h_x2
$LN17@cor_h_x2:
  00214	28 ff ff ff	 DD	 -216			; ffffff28H
  00218	a0 00 00 00	 DD	 160			; 000000a0H
  0021c	00 00 00 00	 DD	 $LN16@cor_h_x2
$LN16@cor_h_x2:
  00220	79		 DB	 121			; 00000079H
  00221	33		 DB	 51			; 00000033H
  00222	32		 DB	 50			; 00000032H
  00223	00		 DB	 0
_cor_h_x2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\cor_h.c
;	COMDAT _cor_h_x
_TEXT	SEGMENT
_h$ = 8							; size = 4
_x$ = 12						; size = 4
_dn$ = 16						; size = 4
_sf$ = 20						; size = 2
_cor_h_x PROC						; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 60   :     cor_h_x2(h, x, dn, sf, NB_TRACK, STEP);

  0001e	6a 05		 push	 5
  00020	6a 05		 push	 5
  00022	0f b7 45 14	 movzx	 eax, WORD PTR _sf$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _dn$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR _h$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _cor_h_x2
  00038	83 c4 18	 add	 esp, 24			; 00000018H

; 61   : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_cor_h_x ENDP
_TEXT	ENDS
END
