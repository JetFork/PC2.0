; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d2_9pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_d2_9pf_c_id
CONST	SEGMENT
_d2_9pf_c_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_startPos DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	04H
CONST	ENDS
PUBLIC	_decode_2i40_9bits
EXTRN	_add:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
;	COMDAT _decode_2i40_9bits
_TEXT	SEGMENT
_pos$ = -44						; size = 4
_k$ = -32						; size = 2
_j$ = -20						; size = 2
_i$ = -8						; size = 2
_subNr$ = 8						; size = 2
_sign$ = 12						; size = 2
_index$ = 16						; size = 2
_cod$ = 20						; size = 4
_decode_2i40_9bits PROC					; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   :     Word16 i, j, k;
; 65   :     Word16 pos[NB_PULSE];
; 66   : 
; 67   :     /* Decode the positions */
; 68   :     /* table bit  is the MSB */ 
; 69   :     j = shr((index & 64),6);                                 logic16 ();

  0001e	6a 06		 push	 6
  00020	0f bf 45 10	 movsx	 eax, WORD PTR _index$[ebp]
  00024	83 e0 40	 and	 eax, 64			; 00000040H
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _shr
  0002d	83 c4 08	 add	 esp, 8
  00030	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  00034	e8 00 00 00 00	 call	 _logic16

; 70   : 
; 71   :     i = index & 7;                                       logic16 ();

  00039	0f bf 45 10	 movsx	 eax, WORD PTR _index$[ebp]
  0003d	83 e0 07	 and	 eax, 7
  00040	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00044	e8 00 00 00 00	 call	 _logic16

; 72   : 
; 73   :     i = add(i, shl(i, 2));       /* pos0 =i*5+startPos[j*8+subNr*2] */

  00049	6a 02		 push	 2
  0004b	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _shl
  00055	83 c4 08	 add	 esp, 8
  00058	0f b7 c8	 movzx	 ecx, ax
  0005b	51		 push	 ecx
  0005c	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _add
  00066	83 c4 08	 add	 esp, 8
  00069	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 74   :     k = startPos[add(shl(j, 3), shl(subNr, 1))];

  0006d	6a 01		 push	 1
  0006f	0f b7 45 08	 movzx	 eax, WORD PTR _subNr$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _shl
  00079	83 c4 08	 add	 esp, 8
  0007c	0f b7 c8	 movzx	 ecx, ax
  0007f	51		 push	 ecx
  00080	6a 03		 push	 3
  00082	0f b7 55 ec	 movzx	 edx, WORD PTR _j$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _shl
  0008c	83 c4 08	 add	 esp, 8
  0008f	0f b7 c0	 movzx	 eax, ax
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _add
  00098	83 c4 08	 add	 esp, 8
  0009b	0f bf c8	 movsx	 ecx, ax
  0009e	66 8b 14 4d 00
	00 00 00	 mov	 dx, WORD PTR _startPos[ecx*2]
  000a6	66 89 55 e0	 mov	 WORD PTR _k$[ebp], dx

; 75   :     pos[0] = add(i, k);                                  move16 ();    

  000aa	0f b7 45 e0	 movzx	 eax, WORD PTR _k$[ebp]
  000ae	50		 push	 eax
  000af	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _add
  000b9	83 c4 08	 add	 esp, 8
  000bc	ba 02 00 00 00	 mov	 edx, 2
  000c1	6b ca 00	 imul	 ecx, edx, 0
  000c4	66 89 44 0d d4	 mov	 WORD PTR _pos$[ebp+ecx], ax
  000c9	e8 00 00 00 00	 call	 _move16

; 76   : 
; 77   :     index = shr(index, 3);

  000ce	6a 03		 push	 3
  000d0	0f b7 45 10	 movzx	 eax, WORD PTR _index$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _shr
  000da	83 c4 08	 add	 esp, 8
  000dd	66 89 45 10	 mov	 WORD PTR _index$[ebp], ax

; 78   :     i = index & 7;                                       logic16 ();

  000e1	0f bf 45 10	 movsx	 eax, WORD PTR _index$[ebp]
  000e5	83 e0 07	 and	 eax, 7
  000e8	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000ec	e8 00 00 00 00	 call	 _logic16

; 79   : 
; 80   :     i = add(i, shl(i, 2));       /* pos1 =i*5+startPos[j*8+subNr*2+1] */

  000f1	6a 02		 push	 2
  000f3	0f b7 45 f8	 movzx	 eax, WORD PTR _i$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 _shl
  000fd	83 c4 08	 add	 esp, 8
  00100	0f b7 c8	 movzx	 ecx, ax
  00103	51		 push	 ecx
  00104	0f b7 55 f8	 movzx	 edx, WORD PTR _i$[ebp]
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 _add
  0010e	83 c4 08	 add	 esp, 8
  00111	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax

; 81   :     k = startPos[add(add(shl(j, 3), shl(subNr, 1)), 1)];

  00115	6a 01		 push	 1
  00117	6a 01		 push	 1
  00119	0f b7 45 08	 movzx	 eax, WORD PTR _subNr$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 _shl
  00123	83 c4 08	 add	 esp, 8
  00126	0f b7 c8	 movzx	 ecx, ax
  00129	51		 push	 ecx
  0012a	6a 03		 push	 3
  0012c	0f b7 55 ec	 movzx	 edx, WORD PTR _j$[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 _shl
  00136	83 c4 08	 add	 esp, 8
  00139	0f b7 c0	 movzx	 eax, ax
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _add
  00142	83 c4 08	 add	 esp, 8
  00145	0f b7 c8	 movzx	 ecx, ax
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 _add
  0014e	83 c4 08	 add	 esp, 8
  00151	0f bf d0	 movsx	 edx, ax
  00154	66 8b 04 55 00
	00 00 00	 mov	 ax, WORD PTR _startPos[edx*2]
  0015c	66 89 45 e0	 mov	 WORD PTR _k$[ebp], ax

; 82   :     pos[1] = add(i, k);                                  move16 ();

  00160	0f b7 45 e0	 movzx	 eax, WORD PTR _k$[ebp]
  00164	50		 push	 eax
  00165	0f b7 4d f8	 movzx	 ecx, WORD PTR _i$[ebp]
  00169	51		 push	 ecx
  0016a	e8 00 00 00 00	 call	 _add
  0016f	83 c4 08	 add	 esp, 8
  00172	ba 02 00 00 00	 mov	 edx, 2
  00177	c1 e2 00	 shl	 edx, 0
  0017a	66 89 44 15 d4	 mov	 WORD PTR _pos$[ebp+edx], ax
  0017f	e8 00 00 00 00	 call	 _move16

; 83   : 
; 84   :     /* decode the signs  and build the codeword */
; 85   : 
; 86   :     for (i = 0; i < L_SUBFR; i++) {

  00184	33 c0		 xor	 eax, eax
  00186	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0018a	eb 0c		 jmp	 SHORT $LN8@decode_2i4
$LN7@decode_2i4:
  0018c	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00190	66 83 c0 01	 add	 ax, 1
  00194	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN8@decode_2i4:
  00198	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0019c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0019f	7d 14		 jge	 SHORT $LN6@decode_2i4

; 87   :         cod[i] = 0;                                      move16 ();

  001a1	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001a5	33 c9		 xor	 ecx, ecx
  001a7	8b 55 14	 mov	 edx, DWORD PTR _cod$[ebp]
  001aa	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  001ae	e8 00 00 00 00	 call	 _move16

; 88   :     }

  001b3	eb d7		 jmp	 SHORT $LN7@decode_2i4
$LN6@decode_2i4:

; 89   : 
; 90   :     for (j = 0; j < NB_PULSE; j++) {

  001b5	33 c0		 xor	 eax, eax
  001b7	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
  001bb	eb 0c		 jmp	 SHORT $LN5@decode_2i4
$LN4@decode_2i4:
  001bd	66 8b 45 ec	 mov	 ax, WORD PTR _j$[ebp]
  001c1	66 83 c0 01	 add	 ax, 1
  001c5	66 89 45 ec	 mov	 WORD PTR _j$[ebp], ax
$LN5@decode_2i4:
  001c9	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  001cd	83 f8 02	 cmp	 eax, 2
  001d0	7d 68		 jge	 SHORT $LN9@decode_2i4

; 91   :         i = sign & 1;                                    logic16 ();

  001d2	0f bf 45 0c	 movsx	 eax, WORD PTR _sign$[ebp]
  001d6	83 e0 01	 and	 eax, 1
  001d9	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  001dd	e8 00 00 00 00	 call	 _logic16

; 92   :         sign = shr(sign, 1);

  001e2	6a 01		 push	 1
  001e4	0f b7 45 0c	 movzx	 eax, WORD PTR _sign$[ebp]
  001e8	50		 push	 eax
  001e9	e8 00 00 00 00	 call	 _shr
  001ee	83 c4 08	 add	 esp, 8
  001f1	66 89 45 0c	 mov	 WORD PTR _sign$[ebp], ax

; 93   : 
; 94   :         test ();

  001f5	e8 00 00 00 00	 call	 _test

; 95   :         if (i != 0) {

  001fa	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  001fe	85 c0		 test	 eax, eax
  00200	74 1c		 je	 SHORT $LN2@decode_2i4

; 96   :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  00202	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00206	0f bf 4c 45 d4	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  0020b	ba ff 1f 00 00	 mov	 edx, 8191		; 00001fffH
  00210	8b 45 14	 mov	 eax, DWORD PTR _cod$[ebp]
  00213	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00217	e8 00 00 00 00	 call	 _move16

; 97   :         } else {

  0021c	eb 1a		 jmp	 SHORT $LN1@decode_2i4
$LN2@decode_2i4:

; 98   :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  0021e	0f bf 45 ec	 movsx	 eax, WORD PTR _j$[ebp]
  00222	0f bf 4c 45 d4	 movsx	 ecx, WORD PTR _pos$[ebp+eax*2]
  00227	ba 00 e0 ff ff	 mov	 edx, -8192		; ffffe000H
  0022c	8b 45 14	 mov	 eax, DWORD PTR _cod$[ebp]
  0022f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00233	e8 00 00 00 00	 call	 _move16
$LN1@decode_2i4:

; 99   :         }
; 100  :     }

  00238	eb 83		 jmp	 SHORT $LN4@decode_2i4
$LN9@decode_2i4:

; 101  : 
; 102  :     return;
; 103  : }

  0023a	52		 push	 edx
  0023b	8b cd		 mov	 ecx, ebp
  0023d	50		 push	 eax
  0023e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@decode_2i4
  00244	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00249	58		 pop	 eax
  0024a	5a		 pop	 edx
  0024b	5f		 pop	 edi
  0024c	5e		 pop	 esi
  0024d	5b		 pop	 ebx
  0024e	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00254	3b ec		 cmp	 ebp, esp
  00256	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c3		 ret	 0
  0025f	90		 npad	 1
$LN13@decode_2i4:
  00260	01 00 00 00	 DD	 1
  00264	00 00 00 00	 DD	 $LN12@decode_2i4
$LN12@decode_2i4:
  00268	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0026c	04 00 00 00	 DD	 4
  00270	00 00 00 00	 DD	 $LN11@decode_2i4
$LN11@decode_2i4:
  00274	70		 DB	 112			; 00000070H
  00275	6f		 DB	 111			; 0000006fH
  00276	73		 DB	 115			; 00000073H
  00277	00		 DB	 0
_decode_2i40_9bits ENDP
_TEXT	ENDS
END
