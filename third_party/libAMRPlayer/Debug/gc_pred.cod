; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\gc_pred.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_gc_pred_id
CONST	SEGMENT
_gc_pred_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_pred	DW	015c3H
	DW	0128fH
	DW	0ae1H
	DW	0614H
_pred_MR122 DW	02cH
	DW	025H
	DW	016H
	DW	0cH
CONST	ENDS
PUBLIC	_gc_pred_init
PUBLIC	_gc_pred_reset
PUBLIC	_gc_pred_exit
PUBLIC	_gc_pred_copy
PUBLIC	_gc_pred
PUBLIC	_gc_pred_update
PUBLIC	_gc_pred_average_limited
PUBLIC	??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@ ; `string'
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_h:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_norm_l:PROC
EXTRN	_L_Extract:PROC
EXTRN	_L_Comp:PROC
EXTRN	_Mpy_32_16:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_Log2:PROC
EXTRN	_Log2_norm:PROC
EXTRN	_Copy:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@ DB 'gc_pred_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@ DB 'gc_pred_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@ DB 'gc_pred_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_average_limited
_TEXT	SEGMENT
_i$ = -20						; size = 2
_av_pred_en$ = -8					; size = 2
_st$ = 8						; size = 4
_ener_avg_MR122$ = 12					; size = 4
_ener_avg$ = 16						; size = 4
_gc_pred_average_limited PROC				; COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 392  :     Word16 av_pred_en;
; 393  :     Word16 i;
; 394  : 
; 395  :     /* do average in MR122 mode (log2() domain) */
; 396  :     av_pred_en = 0;                                        move16 ();

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax
  00024	e8 00 00 00 00	 call	 _move16

; 397  :     for (i = 0; i < NPRED; i++)

  00029	33 c0		 xor	 eax, eax
  0002b	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  0002f	eb 0c		 jmp	 SHORT $LN8@gc_pred_av
$LN7@gc_pred_av:
  00031	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  00035	66 83 c0 01	 add	 ax, 1
  00039	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN8@gc_pred_av:
  0003d	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00041	83 f8 04	 cmp	 eax, 4
  00044	7d 20		 jge	 SHORT $LN6@gc_pred_av

; 398  :     {
; 399  :         av_pred_en = add (av_pred_en, st->past_qua_en_MR122[i]);

  00046	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0004d	0f b7 54 41 08	 movzx	 edx, WORD PTR [ecx+eax*2+8]
  00052	52		 push	 edx
  00053	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _add
  0005d	83 c4 08	 add	 esp, 8
  00060	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax

; 400  :     }

  00064	eb cb		 jmp	 SHORT $LN7@gc_pred_av
$LN6@gc_pred_av:

; 401  : 
; 402  :     /* av_pred_en = 0.25*av_pred_en */
; 403  :     av_pred_en = mult (av_pred_en, 8192);

  00066	68 00 20 00 00	 push	 8192			; 00002000H
  0006b	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _mult
  00075	83 c4 08	 add	 esp, 8
  00078	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax

; 404  : 
; 405  :     /* if (av_pred_en < -14/(20Log10(2))) av_pred_en = .. */
; 406  :     test ();

  0007c	e8 00 00 00 00	 call	 _test

; 407  :     if (sub (av_pred_en, MIN_ENERGY_MR122) < 0)

  00081	68 b3 f6 ff ff	 push	 -2381			; fffff6b3H
  00086	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _sub
  00090	83 c4 08	 add	 esp, 8
  00093	0f bf c8	 movsx	 ecx, ax
  00096	85 c9		 test	 ecx, ecx
  00098	7d 0e		 jge	 SHORT $LN5@gc_pred_av

; 408  :     {
; 409  :         av_pred_en = MIN_ENERGY_MR122;                     move16 ();

  0009a	b8 b3 f6 ff ff	 mov	 eax, -2381		; fffff6b3H
  0009f	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax
  000a3	e8 00 00 00 00	 call	 _move16
$LN5@gc_pred_av:

; 410  :     }
; 411  :     *ener_avg_MR122 = av_pred_en;                          move16 ();

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _ener_avg_MR122$[ebp]
  000ab	66 8b 4d f8	 mov	 cx, WORD PTR _av_pred_en$[ebp]
  000af	66 89 08	 mov	 WORD PTR [eax], cx
  000b2	e8 00 00 00 00	 call	 _move16

; 412  : 
; 413  :     /* do average for other modes (20*log10() domain) */
; 414  :     av_pred_en = 0;                                        move16 ();

  000b7	33 c0		 xor	 eax, eax
  000b9	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax
  000bd	e8 00 00 00 00	 call	 _move16

; 415  :     for (i = 0; i < NPRED; i++)

  000c2	33 c0		 xor	 eax, eax
  000c4	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  000c8	eb 0c		 jmp	 SHORT $LN4@gc_pred_av
$LN3@gc_pred_av:
  000ca	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  000ce	66 83 c0 01	 add	 ax, 1
  000d2	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN4@gc_pred_av:
  000d6	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  000da	83 f8 04	 cmp	 eax, 4
  000dd	7d 1f		 jge	 SHORT $LN2@gc_pred_av

; 416  :     {
; 417  :         av_pred_en = add (av_pred_en, st->past_qua_en[i]);

  000df	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000e6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000ea	52		 push	 edx
  000eb	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 _add
  000f5	83 c4 08	 add	 esp, 8
  000f8	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax

; 418  :     }

  000fc	eb cc		 jmp	 SHORT $LN3@gc_pred_av
$LN2@gc_pred_av:

; 419  : 
; 420  :     /* av_pred_en = 0.25*av_pred_en */
; 421  :     av_pred_en = mult (av_pred_en, 8192);

  000fe	68 00 20 00 00	 push	 8192			; 00002000H
  00103	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _mult
  0010d	83 c4 08	 add	 esp, 8
  00110	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax

; 422  : 
; 423  :     /* if (av_pred_en < -14) av_pred_en = .. */
; 424  :     test ();

  00114	e8 00 00 00 00	 call	 _test

; 425  :     if (sub (av_pred_en, MIN_ENERGY) < 0)

  00119	68 00 c8 ff ff	 push	 -14336			; ffffc800H
  0011e	0f b7 45 f8	 movzx	 eax, WORD PTR _av_pred_en$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _sub
  00128	83 c4 08	 add	 esp, 8
  0012b	0f bf c8	 movsx	 ecx, ax
  0012e	85 c9		 test	 ecx, ecx
  00130	7d 0e		 jge	 SHORT $LN1@gc_pred_av

; 426  :     {
; 427  :         av_pred_en = MIN_ENERGY;                           move16 ();

  00132	b8 00 c8 ff ff	 mov	 eax, -14336		; ffffc800H
  00137	66 89 45 f8	 mov	 WORD PTR _av_pred_en$[ebp], ax
  0013b	e8 00 00 00 00	 call	 _move16
$LN1@gc_pred_av:

; 428  :     }
; 429  :     *ener_avg = av_pred_en;                                move16 ();

  00140	8b 45 10	 mov	 eax, DWORD PTR _ener_avg$[ebp]
  00143	66 8b 4d f8	 mov	 cx, WORD PTR _av_pred_en$[ebp]
  00147	66 89 08	 mov	 WORD PTR [eax], cx
  0014a	e8 00 00 00 00	 call	 _move16

; 430  : }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00158	3b ec		 cmp	 ebp, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
_gc_pred_average_limited ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_update
_TEXT	SEGMENT
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_qua_ener_MR122$ = 12					; size = 2
_qua_ener$ = 16						; size = 2
_gc_pred_update PROC					; COMDAT

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 362  :     Word16 i;
; 363  : 
; 364  :     for (i = 3; i > 0; i--)

  0001e	b8 03 00 00 00	 mov	 eax, 3
  00023	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00027	eb 0c		 jmp	 SHORT $LN3@gc_pred_up
$LN2@gc_pred_up:
  00029	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002d	66 83 e8 01	 sub	 ax, 1
  00031	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@gc_pred_up:
  00035	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00039	85 c0		 test	 eax, eax
  0003b	7e 3b		 jle	 SHORT $LN1@gc_pred_up

; 365  :     {
; 366  :         st->past_qua_en[i] = st->past_qua_en[i - 1];             move16 ();

  0003d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00041	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00045	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00048	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  0004b	66 8b 44 46 fe	 mov	 ax, WORD PTR [esi+eax*2-2]
  00050	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00054	e8 00 00 00 00	 call	 _move16

; 367  :         st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1]; move16 ();

  00059	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0005d	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00061	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00064	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  00067	66 8b 44 46 06	 mov	 ax, WORD PTR [esi+eax*2+6]
  0006c	66 89 44 4a 08	 mov	 WORD PTR [edx+ecx*2+8], ax
  00071	e8 00 00 00 00	 call	 _move16

; 368  :     }

  00076	eb b1		 jmp	 SHORT $LN2@gc_pred_up
$LN1@gc_pred_up:

; 369  : 
; 370  :     st->past_qua_en_MR122[0] = qua_ener_MR122;  /*    log2 (qua_err), Q10 */

  00078	b8 02 00 00 00	 mov	 eax, 2
  0007d	6b c8 00	 imul	 ecx, eax, 0
  00080	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00083	66 8b 45 0c	 mov	 ax, WORD PTR _qua_ener_MR122$[ebp]
  00087	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 371  : 	                                                             move16 ();

  0008c	e8 00 00 00 00	 call	 _move16

; 372  :     st->past_qua_en[0] = qua_ener;              /* 20*log10(qua_err), Q10 */

  00091	b8 02 00 00 00	 mov	 eax, 2
  00096	6b c8 00	 imul	 ecx, eax, 0
  00099	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0009c	66 8b 45 10	 mov	 ax, WORD PTR _qua_ener$[ebp]
  000a0	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 373  : 	                                                             move16 ();

  000a4	e8 00 00 00 00	 call	 _move16

; 374  : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_gc_pred_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred
_TEXT	SEGMENT
_gcode0$1 = -92						; size = 2
_exp_code$2 = -80					; size = 2
_L_tmp$3 = -68						; size = 4
_ener$4 = -56						; size = 4
_frac$ = -44						; size = 2
_exp$ = -32						; size = 2
_ener_code$ = -20					; size = 4
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_code$ = 16						; size = 4
_exp_gcode0$ = 20					; size = 4
_frac_gcode0$ = 24					; size = 4
_exp_en$ = 28						; size = 4
_frac_en$ = 32						; size = 4
_gc_pred PROC						; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 174  :     Word16 i;
; 175  :     Word32 ener_code;
; 176  :     Word16 exp, frac;
; 177  : 
; 178  :     /*-------------------------------------------------------------------*
; 179  :      *  energy of code:                                                  *
; 180  :      *  ~~~~~~~~~~~~~~~                                                  *
; 181  :      *  ener_code = sum(code[i]^2)                                       *
; 182  :      *-------------------------------------------------------------------*/
; 183  :     ener_code = L_mac((Word32) 0, code[0], code[0]);

  0001e	b8 02 00 00 00	 mov	 eax, 2
  00023	6b c8 00	 imul	 ecx, eax, 0
  00026	8b 55 10	 mov	 edx, DWORD PTR _code$[ebp]
  00029	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0002d	50		 push	 eax
  0002e	b9 02 00 00 00	 mov	 ecx, 2
  00033	6b d1 00	 imul	 edx, ecx, 0
  00036	8b 45 10	 mov	 eax, DWORD PTR _code$[ebp]
  00039	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  0003d	51		 push	 ecx
  0003e	6a 00		 push	 0
  00040	e8 00 00 00 00	 call	 _L_mac
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	89 45 ec	 mov	 DWORD PTR _ener_code$[ebp], eax

; 184  :                                                  /* MR122:  Q12*Q12 -> Q25 */
; 185  :                                                  /* others: Q13*Q13 -> Q27 */
; 186  :     for (i = 1; i < L_SUBFR; i++)

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00054	eb 0c		 jmp	 SHORT $LN21@gc_pred
$LN20@gc_pred:
  00056	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0005a	66 83 c0 01	 add	 ax, 1
  0005e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN21@gc_pred:
  00062	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00066	83 f8 28	 cmp	 eax, 40			; 00000028H
  00069	7d 29		 jge	 SHORT $LN19@gc_pred

; 187  :         ener_code = L_mac(ener_code, code[i], code[i]);

  0006b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _code$[ebp]
  00072	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00076	52		 push	 edx
  00077	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _code$[ebp]
  0007e	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00082	52		 push	 edx
  00083	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _L_mac
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	89 45 ec	 mov	 DWORD PTR _ener_code$[ebp], eax
  00092	eb c2		 jmp	 SHORT $LN20@gc_pred
$LN19@gc_pred:

; 188  :     
; 189  :     test ();

  00094	e8 00 00 00 00	 call	 _test

; 190  :     if (sub (mode, MR122) == 0)

  00099	6a 07		 push	 7
  0009b	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _sub
  000a5	83 c4 08	 add	 esp, 8
  000a8	0f bf c8	 movsx	 ecx, ax
  000ab	85 c9		 test	 ecx, ecx
  000ad	0f 85 e2 00 00
	00		 jne	 $LN18@gc_pred

; 191  :     {
; 192  :         Word32 ener;
; 193  : 
; 194  :         /* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
; 195  :         ener_code = L_mult (round (ener_code), 26214);   /* Q9  * Q20 -> Q30 */

  000b3	68 66 66 00 00	 push	 26214			; 00006666H
  000b8	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _round
  000c1	83 c4 04	 add	 esp, 4
  000c4	0f b7 c8	 movzx	 ecx, ax
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _L_mult
  000cd	83 c4 08	 add	 esp, 8
  000d0	89 45 ec	 mov	 DWORD PTR _ener_code$[ebp], eax

; 196  : 
; 197  :         /*-------------------------------------------------------------------*
; 198  :          *  energy of code:                                                  *
; 199  :          *  ~~~~~~~~~~~~~~~                                                  *
; 200  :          *  ener_code(Q17) = 10 * Log10(energy) / constant                   *
; 201  :          *                 = 1/2 * Log2(energy)                              *
; 202  :          *                                           constant = 20*Log10(2)  *
; 203  :          *-------------------------------------------------------------------*/
; 204  :         /* ener_code = 1/2 * Log2(ener_code); Note: Log2=log2+30 */
; 205  :         Log2(ener_code, &exp, &frac);

  000d3	8d 45 d4	 lea	 eax, DWORD PTR _frac$[ebp]
  000d6	50		 push	 eax
  000d7	8d 4d e0	 lea	 ecx, DWORD PTR _exp$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 ec	 mov	 edx, DWORD PTR _ener_code$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _Log2
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  :         ener_code = L_Comp (sub (exp, 30), frac);     /* Q16 for log()    */

  000e7	0f b7 45 d4	 movzx	 eax, WORD PTR _frac$[ebp]
  000eb	50		 push	 eax
  000ec	6a 1e		 push	 30			; 0000001eH
  000ee	0f b7 4d e0	 movzx	 ecx, WORD PTR _exp$[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 _sub
  000f8	83 c4 08	 add	 esp, 8
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 _L_Comp
  00104	83 c4 08	 add	 esp, 8
  00107	89 45 ec	 mov	 DWORD PTR _ener_code$[ebp], eax

; 207  :                                                     /* ->Q17 for 1/2 log()*/
; 208  : 
; 209  :         /*-------------------------------------------------------------------*
; 210  :          *  predicted energy:                                                *
; 211  :          *  ~~~~~~~~~~~~~~~~~                                                *
; 212  :          *  ener(Q24) = (Emean + sum{pred[i]*past_en[i]})/constant           *
; 213  :          *            = MEAN_ENER + sum(pred[i]*past_qua_en[i])              *
; 214  :          *                                           constant = 20*Log10(2)  *
; 215  :          *-------------------------------------------------------------------*/
; 216  : 
; 217  :         ener = MEAN_ENER_MR122; move32 ();                  /* Q24 (Q17) */

  0010a	c7 45 c8 7d f5
	0b 00		 mov	 DWORD PTR _ener$4[ebp], 783741 ; 000bf57dH
  00111	e8 00 00 00 00	 call	 _move32

; 218  :         for (i = 0; i < NPRED; i++)

  00116	33 c0		 xor	 eax, eax
  00118	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0011c	eb 0c		 jmp	 SHORT $LN17@gc_pred
$LN16@gc_pred:
  0011e	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00122	66 83 c0 01	 add	 ax, 1
  00126	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN17@gc_pred:
  0012a	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0012e	83 f8 04	 cmp	 eax, 4
  00131	7d 2b		 jge	 SHORT $LN15@gc_pred

; 219  :         {
; 220  :             ener = L_mac (ener, st->past_qua_en_MR122[i], pred_MR122[i]);

  00133	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00137	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _pred_MR122[eax*2]
  0013f	51		 push	 ecx
  00140	0f bf 55 f8	 movsx	 edx, WORD PTR _i$[ebp]
  00144	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00147	0f b7 4c 50 08	 movzx	 ecx, WORD PTR [eax+edx*2+8]
  0014c	51		 push	 ecx
  0014d	8b 55 c8	 mov	 edx, DWORD PTR _ener$4[ebp]
  00150	52		 push	 edx
  00151	e8 00 00 00 00	 call	 _L_mac
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH
  00159	89 45 c8	 mov	 DWORD PTR _ener$4[ebp], eax

; 221  :                                                      /* Q10 * Q13 -> Q24 */
; 222  :                                                      /* Q10 * Q6  -> Q17 */
; 223  :         }

  0015c	eb c0		 jmp	 SHORT $LN16@gc_pred
$LN15@gc_pred:

; 224  : 
; 225  :         /*-------------------------------------------------------------------*
; 226  :          *  predicted codebook gain                                          *
; 227  :          *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
; 228  :          *  gc0     = Pow10( (ener*constant - ener_code*constant) / 20 )     *
; 229  :          *          = Pow2(ener-ener_code)                                   *
; 230  :          *          = Pow2(int(d)+frac(d))                                   *
; 231  :          *                                                                   *
; 232  :          *  (store exp and frac for pow2())                                  *
; 233  :          *-------------------------------------------------------------------*/
; 234  : 
; 235  :         ener = L_shr (L_sub (ener, ener_code), 1);                /* Q16 */

  0015e	6a 01		 push	 1
  00160	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  00163	50		 push	 eax
  00164	8b 4d c8	 mov	 ecx, DWORD PTR _ener$4[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _L_sub
  0016d	83 c4 08	 add	 esp, 8
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 _L_shr
  00176	83 c4 08	 add	 esp, 8
  00179	89 45 c8	 mov	 DWORD PTR _ener$4[ebp], eax

; 236  :         L_Extract(ener, exp_gcode0, frac_gcode0);

  0017c	8b 45 18	 mov	 eax, DWORD PTR _frac_gcode0$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d 14	 mov	 ecx, DWORD PTR _exp_gcode0$[ebp]
  00183	51		 push	 ecx
  00184	8b 55 c8	 mov	 edx, DWORD PTR _ener$4[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _L_Extract
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }
; 238  :     else /* all modes except 12.2 */

  00190	e9 41 02 00 00	 jmp	 $LN22@gc_pred
$LN18@gc_pred:

; 239  :     {
; 240  :         Word32 L_tmp;
; 241  :         Word16 exp_code, gcode0;
; 242  :         
; 243  :         /*-----------------------------------------------------------------*
; 244  :          *  Compute: means_ener - 10log10(ener_code/ L_sufr)               *
; 245  :          *-----------------------------------------------------------------*/
; 246  : 
; 247  :         exp_code = norm_l (ener_code);

  00195	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _norm_l
  0019e	83 c4 04	 add	 esp, 4
  001a1	66 89 45 b0	 mov	 WORD PTR _exp_code$2[ebp], ax

; 248  :         ener_code = L_shl (ener_code, exp_code);

  001a5	0f b7 45 b0	 movzx	 eax, WORD PTR _exp_code$2[ebp]
  001a9	50		 push	 eax
  001aa	8b 4d ec	 mov	 ecx, DWORD PTR _ener_code$[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _L_shl
  001b3	83 c4 08	 add	 esp, 8
  001b6	89 45 ec	 mov	 DWORD PTR _ener_code$[ebp], eax

; 249  :         
; 250  :         /* Log2 = log2 + 27 */
; 251  :         Log2_norm (ener_code, exp_code, &exp, &frac);

  001b9	8d 45 d4	 lea	 eax, DWORD PTR _frac$[ebp]
  001bc	50		 push	 eax
  001bd	8d 4d e0	 lea	 ecx, DWORD PTR _exp$[ebp]
  001c0	51		 push	 ecx
  001c1	0f b7 55 b0	 movzx	 edx, WORD PTR _exp_code$2[ebp]
  001c5	52		 push	 edx
  001c6	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 _Log2_norm
  001cf	83 c4 10	 add	 esp, 16			; 00000010H

; 252  :         
; 253  :         /* fact = 10/log2(10) = 3.01 = 24660 Q13 */
; 254  :         L_tmp = Mpy_32_16(exp, frac, -24660); /* Q0.Q15 * Q13 -> Q14 */

  001d2	68 ac 9f ff ff	 push	 -24660			; ffff9facH
  001d7	0f b7 45 d4	 movzx	 eax, WORD PTR _frac$[ebp]
  001db	50		 push	 eax
  001dc	0f b7 4d e0	 movzx	 ecx, WORD PTR _exp$[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 _Mpy_32_16
  001e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e9	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax

; 255  : 
; 256  :         /*   L_tmp = means_ener - 10log10(ener_code/L_SUBFR)
; 257  :          *         = means_ener - 10log10(ener_code) + 10log10(L_SUBFR)
; 258  :          *         = K - fact * Log2(ener_code)
; 259  :          *         = K - fact * log2(ener_code) - fact*27
; 260  :          *
; 261  :          *   ==> K = means_ener + fact*27 + 10log10(L_SUBFR)
; 262  :          *
; 263  :          *   means_ener =       33    =  540672    Q14  (MR475, MR515, MR59)
; 264  :          *   means_ener =       28.75 =  471040    Q14  (MR67)
; 265  :          *   means_ener =       30    =  491520    Q14  (MR74)
; 266  :          *   means_ener =       36    =  589824    Q14  (MR795)
; 267  :          *   means_ener =       33    =  540672    Q14  (MR102)         
; 268  :          *   10log10(L_SUBFR) = 16.02 =  262481.51 Q14
; 269  :          *   fact * 27                = 1331640    Q14
; 270  :          *   -----------------------------------------
; 271  :          *   (MR475, MR515, MR59)   K = 2134793.51 Q14 ~= 16678 * 64 * 2
; 272  :          *   (MR67)                 K = 2065161.51 Q14 ~= 32268 * 32 * 2
; 273  :          *   (MR74)                 K = 2085641.51 Q14 ~= 32588 * 32 * 2
; 274  :          *   (MR795)                K = 2183945.51 Q14 ~= 17062 * 64 * 2
; 275  :          *   (MR102)                K = 2134793.51 Q14 ~= 16678 * 64 * 2         
; 276  :          */
; 277  : 
; 278  :         if (test (), sub (mode, MR102) == 0)

  001ec	e8 00 00 00 00	 call	 _test
  001f1	6a 06		 push	 6
  001f3	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 _sub
  001fd	83 c4 08	 add	 esp, 8
  00200	0f bf c8	 movsx	 ecx, ax
  00203	85 c9		 test	 ecx, ecx
  00205	75 1b		 jne	 SHORT $LN13@gc_pred

; 279  :         {
; 280  :             /* mean = 33 dB */
; 281  :             L_tmp = L_mac(L_tmp, 16678, 64);     /* Q14 */

  00207	6a 40		 push	 64			; 00000040H
  00209	68 26 41 00 00	 push	 16678			; 00004126H
  0020e	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _L_mac
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021a	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
  0021d	e9 e0 00 00 00	 jmp	 $LN12@gc_pred
$LN13@gc_pred:

; 282  :         }
; 283  :         else if (test (), sub (mode, MR795) == 0)

  00222	e8 00 00 00 00	 call	 _test
  00227	6a 05		 push	 5
  00229	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _sub
  00233	83 c4 08	 add	 esp, 8
  00236	0f bf c8	 movsx	 ecx, ax
  00239	85 c9		 test	 ecx, ecx
  0023b	75 49		 jne	 SHORT $LN11@gc_pred

; 284  :         {
; 285  :             /* ener_code  = <xn xn> * 2^27*2^exp_code
; 286  :                frac_en    = ener_code / 2^16
; 287  :                           = <xn xn> * 2^11*2^exp_code
; 288  :                <xn xn>    = <xn xn>*2^11*2^exp * 2^exp_en
; 289  :                          := frac_en            * 2^exp_en
; 290  : 
; 291  :                ==> exp_en = -11-exp_code;
; 292  :              */
; 293  :             *frac_en = extract_h (ener_code); move16 ();

  0023d	8b 45 ec	 mov	 eax, DWORD PTR _ener_code$[ebp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 _extract_h
  00246	83 c4 04	 add	 esp, 4
  00249	8b 4d 20	 mov	 ecx, DWORD PTR _frac_en$[ebp]
  0024c	66 89 01	 mov	 WORD PTR [ecx], ax
  0024f	e8 00 00 00 00	 call	 _move16

; 294  :             *exp_en = sub (-11, exp_code);    move16 ();

  00254	0f b7 45 b0	 movzx	 eax, WORD PTR _exp_code$2[ebp]
  00258	50		 push	 eax
  00259	6a f5		 push	 -11			; fffffff5H
  0025b	e8 00 00 00 00	 call	 _sub
  00260	83 c4 08	 add	 esp, 8
  00263	8b 4d 1c	 mov	 ecx, DWORD PTR _exp_en$[ebp]
  00266	66 89 01	 mov	 WORD PTR [ecx], ax
  00269	e8 00 00 00 00	 call	 _move16

; 295  : 
; 296  :             /* mean = 36 dB */
; 297  :             L_tmp = L_mac(L_tmp, 17062, 64);     /* Q14 */

  0026e	6a 40		 push	 64			; 00000040H
  00270	68 a6 42 00 00	 push	 17062			; 000042a6H
  00275	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  00278	50		 push	 eax
  00279	e8 00 00 00 00	 call	 _L_mac
  0027e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00281	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
  00284	eb 7c		 jmp	 SHORT $LN12@gc_pred
$LN11@gc_pred:

; 298  :         }
; 299  :         else if (test (), sub (mode, MR74) == 0)

  00286	e8 00 00 00 00	 call	 _test
  0028b	6a 04		 push	 4
  0028d	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 _sub
  00297	83 c4 08	 add	 esp, 8
  0029a	0f bf c8	 movsx	 ecx, ax
  0029d	85 c9		 test	 ecx, ecx
  0029f	75 18		 jne	 SHORT $LN9@gc_pred

; 300  :         {
; 301  :             /* mean = 30 dB */
; 302  :             L_tmp = L_mac(L_tmp, 32588, 32);     /* Q14 */

  002a1	6a 20		 push	 32			; 00000020H
  002a3	68 4c 7f 00 00	 push	 32588			; 00007f4cH
  002a8	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 _L_mac
  002b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b4	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
  002b7	eb 49		 jmp	 SHORT $LN12@gc_pred
$LN9@gc_pred:

; 303  :         }
; 304  :         else if (test (), sub (mode, MR67) == 0)

  002b9	e8 00 00 00 00	 call	 _test
  002be	6a 03		 push	 3
  002c0	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _sub
  002ca	83 c4 08	 add	 esp, 8
  002cd	0f bf c8	 movsx	 ecx, ax
  002d0	85 c9		 test	 ecx, ecx
  002d2	75 18		 jne	 SHORT $LN7@gc_pred

; 305  :         {
; 306  :             /* mean = 28.75 dB */
; 307  :             L_tmp = L_mac(L_tmp, 32268, 32);     /* Q14 */

  002d4	6a 20		 push	 32			; 00000020H
  002d6	68 0c 7e 00 00	 push	 32268			; 00007e0cH
  002db	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 _L_mac
  002e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e7	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax

; 308  :         }
; 309  :         else /* MR59, MR515, MR475 */

  002ea	eb 16		 jmp	 SHORT $LN12@gc_pred
$LN7@gc_pred:

; 310  :         {
; 311  :             /* mean = 33 dB */
; 312  :             L_tmp = L_mac(L_tmp, 16678, 64);     /* Q14 */

  002ec	6a 40		 push	 64			; 00000040H
  002ee	68 26 41 00 00	 push	 16678			; 00004126H
  002f3	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 _L_mac
  002fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ff	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
$LN12@gc_pred:

; 313  :         }
; 314  :         
; 315  :         /*-----------------------------------------------------------------*
; 316  :          * Compute gcode0.                                                 *
; 317  :          *  = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + mean_ener    *
; 318  :          *-----------------------------------------------------------------*/
; 319  : 
; 320  :         L_tmp = L_shl(L_tmp, 10);                /* Q24 */

  00302	6a 0a		 push	 10			; 0000000aH
  00304	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  00307	50		 push	 eax
  00308	e8 00 00 00 00	 call	 _L_shl
  0030d	83 c4 08	 add	 esp, 8
  00310	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax

; 321  :         for (i = 0; i < 4; i++)

  00313	33 c0		 xor	 eax, eax
  00315	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00319	eb 0c		 jmp	 SHORT $LN5@gc_pred
$LN4@gc_pred:
  0031b	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0031f	66 83 c0 01	 add	 ax, 1
  00323	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN5@gc_pred:
  00327	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0032b	83 f8 04	 cmp	 eax, 4
  0032e	7d 2a		 jge	 SHORT $LN3@gc_pred

; 322  :             L_tmp = L_mac(L_tmp, pred[i], st->past_qua_en[i]);

  00330	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00334	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00337	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0033b	52		 push	 edx
  0033c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00340	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _pred[eax*2]
  00348	51		 push	 ecx
  00349	8b 55 bc	 mov	 edx, DWORD PTR _L_tmp$3[ebp]
  0034c	52		 push	 edx
  0034d	e8 00 00 00 00	 call	 _L_mac
  00352	83 c4 0c	 add	 esp, 12			; 0000000cH
  00355	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
  00358	eb c1		 jmp	 SHORT $LN4@gc_pred
$LN3@gc_pred:

; 323  :                                                  /* Q13 * Q10 -> Q24 */
; 324  : 
; 325  :         gcode0 = extract_h(L_tmp);               /* Q8  */

  0035a	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 _extract_h
  00363	83 c4 04	 add	 esp, 4
  00366	66 89 45 a4	 mov	 WORD PTR _gcode0$1[ebp], ax

; 326  : 
; 327  :         /*-----------------------------------------------------------------*
; 328  :          * gcode0 = pow(10.0, gcode0/20)                                   *
; 329  :          *        = pow(2, 3.3219*gcode0/20)                               *
; 330  :          *        = pow(2, 0.166*gcode0)                                   *
; 331  :          *-----------------------------------------------------------------*/
; 332  : 
; 333  :         /* 5439 Q15 = 0.165985                                        */
; 334  :         /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
; 335  :         test ();

  0036a	e8 00 00 00 00	 call	 _test

; 336  :         if (sub (mode, MR74) == 0) /* For IS641 bitexactness */

  0036f	6a 04		 push	 4
  00371	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00375	50		 push	 eax
  00376	e8 00 00 00 00	 call	 _sub
  0037b	83 c4 08	 add	 esp, 8
  0037e	0f bf c8	 movsx	 ecx, ax
  00381	85 c9		 test	 ecx, ecx
  00383	75 17		 jne	 SHORT $LN2@gc_pred

; 337  :             L_tmp = L_mult(gcode0, 5439);  /* Q8 * Q15 -> Q24 */

  00385	68 3f 15 00 00	 push	 5439			; 0000153fH
  0038a	0f b7 45 a4	 movzx	 eax, WORD PTR _gcode0$1[ebp]
  0038e	50		 push	 eax
  0038f	e8 00 00 00 00	 call	 _L_mult
  00394	83 c4 08	 add	 esp, 8
  00397	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax

; 338  :         else

  0039a	eb 15		 jmp	 SHORT $LN1@gc_pred
$LN2@gc_pred:

; 339  :             L_tmp = L_mult(gcode0, 5443);  /* Q8 * Q15 -> Q24 */

  0039c	68 43 15 00 00	 push	 5443			; 00001543H
  003a1	0f b7 45 a4	 movzx	 eax, WORD PTR _gcode0$1[ebp]
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 _L_mult
  003ab	83 c4 08	 add	 esp, 8
  003ae	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax
$LN1@gc_pred:

; 340  : 
; 341  :         L_tmp = L_shr(L_tmp, 8);                   /*          -> Q16 */

  003b1	6a 08		 push	 8
  003b3	8b 45 bc	 mov	 eax, DWORD PTR _L_tmp$3[ebp]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _L_shr
  003bc	83 c4 08	 add	 esp, 8
  003bf	89 45 bc	 mov	 DWORD PTR _L_tmp$3[ebp], eax

; 342  :         L_Extract(L_tmp, exp_gcode0, frac_gcode0); /*       -> Q0.Q15 */

  003c2	8b 45 18	 mov	 eax, DWORD PTR _frac_gcode0$[ebp]
  003c5	50		 push	 eax
  003c6	8b 4d 14	 mov	 ecx, DWORD PTR _exp_gcode0$[ebp]
  003c9	51		 push	 ecx
  003ca	8b 55 bc	 mov	 edx, DWORD PTR _L_tmp$3[ebp]
  003cd	52		 push	 edx
  003ce	e8 00 00 00 00	 call	 _L_Extract
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@gc_pred:

; 343  :     }
; 344  : }

  003d6	52		 push	 edx
  003d7	8b cd		 mov	 ecx, ebp
  003d9	50		 push	 eax
  003da	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@gc_pred
  003e0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003e5	58		 pop	 eax
  003e6	5a		 pop	 edx
  003e7	5f		 pop	 edi
  003e8	5e		 pop	 esi
  003e9	5b		 pop	 ebx
  003ea	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  003f0	3b ec		 cmp	 ebp, esp
  003f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f7	8b e5		 mov	 esp, ebp
  003f9	5d		 pop	 ebp
  003fa	c3		 ret	 0
  003fb	90		 npad	 1
$LN27@gc_pred:
  003fc	02 00 00 00	 DD	 2
  00400	00 00 00 00	 DD	 $LN26@gc_pred
$LN26@gc_pred:
  00404	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00408	02 00 00 00	 DD	 2
  0040c	00 00 00 00	 DD	 $LN24@gc_pred
  00410	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00414	02 00 00 00	 DD	 2
  00418	00 00 00 00	 DD	 $LN25@gc_pred
$LN25@gc_pred:
  0041c	66		 DB	 102			; 00000066H
  0041d	72		 DB	 114			; 00000072H
  0041e	61		 DB	 97			; 00000061H
  0041f	63		 DB	 99			; 00000063H
  00420	00		 DB	 0
$LN24@gc_pred:
  00421	65		 DB	 101			; 00000065H
  00422	78		 DB	 120			; 00000078H
  00423	70		 DB	 112			; 00000070H
  00424	00		 DB	 0
_gc_pred ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_copy
_TEXT	SEGMENT
_st_src$ = 8						; size = 4
_st_dest$ = 12						; size = 4
_gc_pred_copy PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 148  :     Copy (st_src->past_qua_en, st_dest->past_qua_en, NPRED);

  0001e	6a 04		 push	 4
  00020	8b 45 0c	 mov	 eax, DWORD PTR _st_dest$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _st_src$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _Copy
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  :     Copy (st_src->past_qua_en_MR122, st_dest->past_qua_en_MR122, NPRED);

  00030	6a 04		 push	 4
  00032	8b 45 0c	 mov	 eax, DWORD PTR _st_dest$[ebp]
  00035	83 c0 08	 add	 eax, 8
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _st_src$[ebp]
  0003c	83 c1 08	 add	 ecx, 8
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _Copy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_gc_pred_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gc_pred_exit PROC					; COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 125  :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@gc_pred_ex
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@gc_pred_ex
$LN1@gc_pred_ex:

; 126  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@gc_pred_ex
$LN2@gc_pred_ex:

; 127  : 
; 128  :   /* deallocate memory */
; 129  :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 130  :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@gc_pred_ex:

; 131  : 
; 132  :   return;
; 133  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_gc_pred_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_reset
_TEXT	SEGMENT
_i$ = -8						; size = 2
_state$ = 8						; size = 4
_gc_pred_reset PROC					; COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 101  :    Word16 i;
; 102  : 
; 103  :    if (state == (gc_predState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN4@gc_pred_re

; 104  :       fprintf(stderr, "gc_pred_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 42		 jmp	 SHORT $LN5@gc_pred_re
$LN4@gc_pred_re:

; 106  :    }
; 107  : 
; 108  :    for(i = 0; i < NPRED; i++)

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  0005f	eb 0c		 jmp	 SHORT $LN3@gc_pred_re
$LN2@gc_pred_re:
  00061	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  00065	66 83 c0 01	 add	 ax, 1
  00069	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN3@gc_pred_re:
  0006d	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00071	83 f8 04	 cmp	 eax, 4
  00074	7d 23		 jge	 SHORT $LN1@gc_pred_re

; 109  :    {
; 110  :       state->past_qua_en[i] = MIN_ENERGY;

  00076	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0007a	b9 00 c8 ff ff	 mov	 ecx, -14336		; ffffc800H
  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx

; 111  :       state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;

  00086	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0008a	b9 b3 f6 ff ff	 mov	 ecx, -2381		; fffff6b3H
  0008f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00092	66 89 4c 42 08	 mov	 WORD PTR [edx+eax*2+8], cx

; 112  :    }

  00097	eb c8		 jmp	 SHORT $LN2@gc_pred_re
$LN1@gc_pred_re:

; 113  :   return 0;

  00099	33 c0		 xor	 eax, eax
$LN5@gc_pred_re:

; 114  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_gc_pred_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_gc_pred_init PROC					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 74   :   gc_predState* s;
; 75   : 
; 76   :   if (state == (gc_predState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@gc_pred_in

; 77   :       fprintf(stderr, "gc_pred_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 78   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@gc_pred_in
$LN2@gc_pred_in:

; 79   :   }
; 80   :   *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 81   : 
; 82   :   /* allocate memory */
; 83   :   if ((s= (gc_predState *) malloc(sizeof(gc_predState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 10		 push	 16			; 00000010H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@gc_pred_in

; 84   :       fprintf(stderr, "gc_pred_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 85   :       return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@gc_pred_in
$LN1@gc_pred_in:

; 86   :   }
; 87   :   gc_pred_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _gc_pred_reset
  000bd	83 c4 04	 add	 esp, 4

; 88   :   *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 89   : 
; 90   :   return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@gc_pred_in:

; 91   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_gc_pred_init ENDP
_TEXT	ENDS
END
