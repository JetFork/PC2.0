; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\sqrt_l.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_sqrt_l_id
CONST	SEGMENT
_sqrt_l_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_table	DW	04000H
	DW	041f8H
	DW	043e2H
	DW	045beH
	DW	0478eH
	DW	04952H
	DW	04b0cH
	DW	04cbcH
	DW	04e62H
	DW	05000H
	DW	05196H
	DW	05323H
	DW	054aaH
	DW	0562aH
	DW	057a3H
	DW	05916H
	DW	05a82H
	DW	05beaH
	DW	05d4cH
	DW	05ea8H
	DW	06000H
	DW	06153H
	DW	062a1H
	DW	063ecH
	DW	06531H
	DW	06673H
	DW	067b1H
	DW	068ebH
	DW	06a22H
	DW	06b55H
	DW	06c84H
	DW	06db1H
	DW	06edaH
	DW	07000H
	DW	07123H
	DW	07243H
	DW	07361H
	DW	0747bH
	DW	07593H
	DW	076a9H
	DW	077bcH
	DW	078ccH
	DW	079daH
	DW	07ae6H
	DW	07befH
	DW	07cf7H
	DW	07dfcH
	DW	07effH
	DW	07fffH
CONST	ENDS
PUBLIC	_sqrt_l_exp
EXTRN	_sub:PROC
EXTRN	_extract_h:PROC
EXTRN	_extract_l:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_deposit_h:PROC
EXTRN	_norm_l:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
;	COMDAT _sqrt_l_exp
_TEXT	SEGMENT
_L_y$ = -56						; size = 4
_tmp$ = -44						; size = 2
_a$ = -32						; size = 2
_i$ = -20						; size = 2
_e$ = -8						; size = 2
_L_x$ = 8						; size = 4
_exp$ = 12						; size = 4
_sqrt_l_exp PROC					; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 63   :     /*
; 64   :           y = sqrt(x)
; 65   : 
; 66   :           x = f * 2^-e,   0.5 <= f < 1   (normalization)
; 67   : 
; 68   :           y = sqrt(f) * 2^(-e/2)  
; 69   : 
; 70   :           a) e = 2k   --> y = sqrt(f)   * 2^-k  (k = e div 2,
; 71   :                                                  0.707 <= sqrt(f) < 1)
; 72   :           b) e = 2k+1 --> y = sqrt(f/2) * 2^-k  (k = e div 2,
; 73   :                                                  0.5 <= sqrt(f/2) < 0.707)
; 74   :      */
; 75   :     
; 76   :     
; 77   :     Word16 e, i, a, tmp;
; 78   :     Word32 L_y;
; 79   : 
; 80   :     test (); 

  0001e	e8 00 00 00 00	 call	 _test

; 81   :     if (L_x <= (Word32) 0)

  00023	83 7d 08 00	 cmp	 DWORD PTR _L_x$[ebp], 0
  00027	7f 14		 jg	 SHORT $LN1@sqrt_l_exp

; 82   :     {
; 83   :         *exp = 0;               move16 ();

  00029	33 c0		 xor	 eax, eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _exp$[ebp]
  0002e	66 89 01	 mov	 WORD PTR [ecx], ax
  00031	e8 00 00 00 00	 call	 _move16

; 84   :         return (Word32) 0;

  00036	33 c0		 xor	 eax, eax
  00038	e9 02 01 00 00	 jmp	 $LN2@sqrt_l_exp
$LN1@sqrt_l_exp:

; 85   :     }
; 86   : 
; 87   :     e = norm_l (L_x) & 0xFFFE;  logic16 (); /* get next lower EVEN norm. exp  */

  0003d	8b 45 08	 mov	 eax, DWORD PTR _L_x$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _norm_l
  00046	83 c4 04	 add	 esp, 4
  00049	0f bf c8	 movsx	 ecx, ax
  0004c	81 e1 fe ff 00
	00		 and	 ecx, 65534		; 0000fffeH
  00052	66 89 4d f8	 mov	 WORD PTR _e$[ebp], cx
  00056	e8 00 00 00 00	 call	 _logic16

; 88   :     L_x = L_shl (L_x, e);                   /* L_x is normalized to [0.25..1) */

  0005b	0f b7 45 f8	 movzx	 eax, WORD PTR _e$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _L_x$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _L_shl
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 08	 mov	 DWORD PTR _L_x$[ebp], eax

; 89   :     *exp = e;                   move16 ();  /* return 2*exponent (or Q1)      */

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _exp$[ebp]
  00072	66 8b 4d f8	 mov	 cx, WORD PTR _e$[ebp]
  00076	66 89 08	 mov	 WORD PTR [eax], cx
  00079	e8 00 00 00 00	 call	 _move16

; 90   : 
; 91   :     L_x = L_shr (L_x, 9);

  0007e	6a 09		 push	 9
  00080	8b 45 08	 mov	 eax, DWORD PTR _L_x$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _L_shr
  00089	83 c4 08	 add	 esp, 8
  0008c	89 45 08	 mov	 DWORD PTR _L_x$[ebp], eax

; 92   :     i = extract_h (L_x);            /* Extract b25-b31, 16 <= i <= 63 because

  0008f	8b 45 08	 mov	 eax, DWORD PTR _L_x$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _extract_h
  00098	83 c4 04	 add	 esp, 4
  0009b	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax

; 93   :                                        of normalization                       */
; 94   :     L_x = L_shr (L_x, 1);   

  0009f	6a 01		 push	 1
  000a1	8b 45 08	 mov	 eax, DWORD PTR _L_x$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _L_shr
  000aa	83 c4 08	 add	 esp, 8
  000ad	89 45 08	 mov	 DWORD PTR _L_x$[ebp], eax

; 95   :     a = extract_l (L_x);            /* Extract b10-b24                        */

  000b0	8b 45 08	 mov	 eax, DWORD PTR _L_x$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _extract_l
  000b9	83 c4 04	 add	 esp, 4
  000bc	66 89 45 e0	 mov	 WORD PTR _a$[ebp], ax

; 96   :     a = a & (Word16) 0x7fff;    logic16 (); 

  000c0	0f bf 45 e0	 movsx	 eax, WORD PTR _a$[ebp]
  000c4	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  000c9	66 89 45 e0	 mov	 WORD PTR _a$[ebp], ax
  000cd	e8 00 00 00 00	 call	 _logic16

; 97   : 
; 98   :     i = sub (i, 16);                /* 0 <= i <= 47                           */

  000d2	6a 10		 push	 16			; 00000010H
  000d4	0f b7 45 ec	 movzx	 eax, WORD PTR _i$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _sub
  000de	83 c4 08	 add	 esp, 8
  000e1	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax

; 99   : 
; 100  :     L_y = L_deposit_h (table[i]);           /* table[i] << 16                 */

  000e5	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  000e9	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR _table[eax*2]
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 _L_deposit_h
  000f7	83 c4 04	 add	 esp, 4
  000fa	89 45 c8	 mov	 DWORD PTR _L_y$[ebp], eax

; 101  :     tmp = sub (table[i], table[i + 1]);     /* table[i] - table[i+1])         */

  000fd	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  00101	0f b7 0c 45 02
	00 00 00	 movzx	 ecx, WORD PTR _table[eax*2+2]
  00109	51		 push	 ecx
  0010a	0f bf 55 ec	 movsx	 edx, WORD PTR _i$[ebp]
  0010e	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _table[edx*2]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 _sub
  0011c	83 c4 08	 add	 esp, 8
  0011f	66 89 45 d4	 mov	 WORD PTR _tmp$[ebp], ax

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  00123	0f b7 45 e0	 movzx	 eax, WORD PTR _a$[ebp]
  00127	50		 push	 eax
  00128	0f b7 4d d4	 movzx	 ecx, WORD PTR _tmp$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 c8	 mov	 edx, DWORD PTR _L_y$[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 _L_msu
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
  00139	89 45 c8	 mov	 DWORD PTR _L_y$[ebp], eax

; 103  :        
; 104  :     /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
; 105  : 
; 106  :     return (L_y);

  0013c	8b 45 c8	 mov	 eax, DWORD PTR _L_y$[ebp]
$LN2@sqrt_l_exp:

; 107  : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00148	3b ec		 cmp	 ebp, esp
  0014a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_sqrt_l_exp ENDP
_TEXT	ENDS
END
