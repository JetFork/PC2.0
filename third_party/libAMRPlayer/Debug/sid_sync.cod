; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\sid_sync.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_sid_sync_id
CONST	SEGMENT
_sid_sync_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_sid_sync_init
PUBLIC	_sid_sync_reset
PUBLIC	_sid_sync_exit
PUBLIC	_sid_sync_set_handover_debt
PUBLIC	_sid_sync
PUBLIC	??_C@_0CH@EOOIHEDL@sid_sync_init?3invalid?5state?5para@ ; `string'
PUBLIC	??_C@_0CP@CFMAAEBJ@sid_sync_init?3?5can?5not?5malloc?5st@ ; `string'
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CP@CFMAAEBJ@sid_sync_init?3?5can?5not?5malloc?5st@
CONST	SEGMENT
??_C@_0CP@CFMAAEBJ@sid_sync_init?3?5can?5not?5malloc?5st@ DB 'sid_sync_in'
	DB	'it: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EOOIHEDL@sid_sync_init?3invalid?5state?5para@
CONST	SEGMENT
??_C@_0CH@EOOIHEDL@sid_sync_init?3invalid?5state?5para@ DB 'sid_sync_init'
	DB	':invalid state parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sid_sync.c
;	COMDAT _sid_sync
_TEXT	SEGMENT
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_tx_frame_type$ = 16					; size = 4
_sid_sync PROC						; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 102  :  
; 103  :     if ( mode == MRDTX){

  0001e	83 7d 0c 08	 cmp	 DWORD PTR _mode$[ebp], 8
  00022	0f 85 94 00 00
	00		 jne	 $LN8@sid_sync

; 104  : 
; 105  :        st->sid_update_counter--;

  00028	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0002b	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0002f	66 83 e9 01	 sub	 cx, 1
  00033	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00036	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 106  :        
; 107  :         if (st->prev_ft == TX_SPEECH_GOOD) 

  0003a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0003d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00041	75 17		 jne	 SHORT $LN7@sid_sync

; 108  :         {
; 109  :            *tx_frame_type = TX_SID_FIRST;

  00043	8b 45 10	 mov	 eax, DWORD PTR _tx_frame_type$[ebp]
  00046	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 110  :            st->sid_update_counter = 3;

  0004c	b8 03 00 00 00	 mov	 eax, 3
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00054	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 111  :         } 
; 112  :         else 

  00058	eb 60		 jmp	 SHORT $LN6@sid_sync
$LN7@sid_sync:

; 113  :         {
; 114  :            /* TX_SID_UPDATE or TX_NO_DATA */
; 115  :            if( (st->sid_handover_debt > 0) &&
; 116  :                (st->sid_update_counter > 2) )

  0005a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005d	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00061	85 c9		 test	 ecx, ecx
  00063	7e 29		 jle	 SHORT $LN5@sid_sync
  00065	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00068	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  0006c	83 f9 02	 cmp	 ecx, 2
  0006f	7e 1d		 jle	 SHORT $LN5@sid_sync

; 117  :            {
; 118  :               /* ensure extra updates are  properly delayed after 
; 119  :                  a possible SID_FIRST */
; 120  :               *tx_frame_type = TX_SID_UPDATE;

  00071	8b 45 10	 mov	 eax, DWORD PTR _tx_frame_type$[ebp]
  00074	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 121  :               st->sid_handover_debt--;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0007d	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00081	66 83 e9 01	 sub	 cx, 1
  00085	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00088	66 89 4a 04	 mov	 WORD PTR [edx+4], cx

; 122  :            }
; 123  :            else 

  0008c	eb 2c		 jmp	 SHORT $LN6@sid_sync
$LN5@sid_sync:

; 124  :            {
; 125  :               if (st->sid_update_counter == 0)

  0008e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00091	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00095	85 c9		 test	 ecx, ecx
  00097	75 18		 jne	 SHORT $LN3@sid_sync

; 126  :               {
; 127  :                  *tx_frame_type = TX_SID_UPDATE;

  00099	8b 45 10	 mov	 eax, DWORD PTR _tx_frame_type$[ebp]
  0009c	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 128  :                  st->sid_update_counter = st->sid_update_rate;

  000a2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000a8	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000ab	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 129  :               } else {

  000af	eb 09		 jmp	 SHORT $LN6@sid_sync
$LN3@sid_sync:

; 130  :                  *tx_frame_type = TX_NO_DATA;

  000b1	8b 45 10	 mov	 eax, DWORD PTR _tx_frame_type$[ebp]
  000b4	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
$LN6@sid_sync:

; 131  :               }
; 132  :            }
; 133  :         }
; 134  :     }
; 135  :     else

  000ba	eb 16		 jmp	 SHORT $LN1@sid_sync
$LN8@sid_sync:

; 136  :     {
; 137  :        st->sid_update_counter = st->sid_update_rate ;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  000c2	66 8b 11	 mov	 dx, WORD PTR [ecx]
  000c5	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 138  :        *tx_frame_type = TX_SPEECH_GOOD;

  000c9	8b 45 10	 mov	 eax, DWORD PTR _tx_frame_type$[ebp]
  000cc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@sid_sync:

; 139  :     }
; 140  :     st->prev_ft = *tx_frame_type;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _tx_frame_type$[ebp]
  000d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000da	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 141  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_sid_sync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sid_sync.c
;	COMDAT _sid_sync_set_handover_debt
_TEXT	SEGMENT
_st$ = 8						; size = 4
_debtFrames$ = 12					; size = 2
_sid_sync_set_handover_debt PROC			; COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 93   :    /* debtFrames >= 0 */ 
; 94   :    st->sid_handover_debt = debtFrames;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00021	66 8b 4d 0c	 mov	 cx, WORD PTR _debtFrames$[ebp]
  00025	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 95   :    return 0;

  00029	33 c0		 xor	 eax, eax

; 96   : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_sid_sync_set_handover_debt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sid_sync.c
;	COMDAT _sid_sync_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_sid_sync_exit PROC					; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 79   :   if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@sid_sync_e
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@sid_sync_e
$LN1@sid_sync_e:

; 80   :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@sid_sync_e
$LN2@sid_sync_e:

; 81   :  
; 82   :   /* deallocate memory */
; 83   :   free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 84   :   *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@sid_sync_e:

; 85   :   
; 86   :   return;
; 87   : 
; 88   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_sid_sync_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sid_sync.c
;	COMDAT _sid_sync_reset
_TEXT	SEGMENT
_st$ = 8						; size = 4
_sid_sync_reset PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 70   :     st->sid_update_counter = 3;

  0001e	b8 03 00 00 00	 mov	 eax, 3
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00026	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 71   :     st->sid_handover_debt = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0002f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 72   :     st->prev_ft = TX_SPEECH_GOOD;

  00033	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00036	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 73   :     return 0;

  0003d	33 c0		 xor	 eax, eax

; 74   : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_sid_sync_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sid_sync.c
;	COMDAT _sid_sync_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_sid_sync_init PROC					; COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 47   :     sid_syncState* s;
; 48   :     if (state == (sid_syncState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@sid_sync_i

; 49   :         fprintf(stderr, "sid_sync_init:invalid state parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EOOIHEDL@sid_sync_init?3invalid?5state?5para@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 50   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 7a		 jmp	 SHORT $LN3@sid_sync_i
$LN2@sid_sync_i:

; 51   :     }
; 52   : 
; 53   :     *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 54   : 
; 55   :     /* allocate memory */
; 56   :     if ((s= (sid_syncState *)
; 57   :          malloc(sizeof(sid_syncState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 0c		 push	 12			; 0000000cH
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@sid_sync_i

; 58   :         fprintf(stderr,
; 59   :                 "sid_sync_init: "
; 60   :                 "can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@CFMAAEBJ@sid_sync_init?3?5can?5not?5malloc?5st@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 61   :         return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 1f		 jmp	 SHORT $LN3@sid_sync_i
$LN1@sid_sync_i:

; 62   :     }
; 63   :     s->sid_update_rate = 8;

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000bc	66 89 01	 mov	 WORD PTR [ecx], ax

; 64   :     *state = s;

  000bf	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 65   :     return sid_sync_reset(s);

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _sid_sync_reset
  000d0	83 c4 04	 add	 esp, 4
$LN3@sid_sync_i:

; 66   : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000dc	3b ec		 cmp	 ebp, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_sid_sync_init ENDP
_TEXT	ENDS
END
