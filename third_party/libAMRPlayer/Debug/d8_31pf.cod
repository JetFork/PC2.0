; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d8_31pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_d8_31pf_id
CONST	SEGMENT
_d8_31pf_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_dec_8i40_31bits
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_negate:PROC
EXTRN	_extract_l:PROC
EXTRN	_L_shr:PROC
EXTRN	_move16:PROC
EXTRN	_logic16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _decompress_code
_TEXT	SEGMENT
_MSBs0_24$ = -68					; size = 2
_LSBs$ = -56						; size = 2
_MSBs$ = -44						; size = 2
_ib$ = -32						; size = 2
_ia$ = -20						; size = 2
_i$ = -8						; size = 2
_indx$ = 8						; size = 4
_sign_indx$ = 12					; size = 4
_pos_indx$ = 16						; size = 4
_decompress_code PROC					; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 102  :     Word16 i, ia, ib, MSBs, LSBs, MSBs0_24;
; 103  : 
; 104  :     for (i = 0; i < NB_TRACK_MR102; i++)

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00024	eb 0c		 jmp	 SHORT $LN4@decompress
$LN3@decompress:
  00026	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0002a	66 83 c0 01	 add	 ax, 1
  0002e	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN4@decompress:
  00032	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00036	83 f8 04	 cmp	 eax, 4
  00039	7d 1d		 jge	 SHORT $LN2@decompress

; 105  :     {
; 106  :        sign_indx[i] = indx[i];                                  move16 (); 

  0003b	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0003f	0f bf 4d f8	 movsx	 ecx, WORD PTR _i$[ebp]
  00043	8b 55 0c	 mov	 edx, DWORD PTR _sign_indx$[ebp]
  00046	8b 75 08	 mov	 esi, DWORD PTR _indx$[ebp]
  00049	66 8b 04 46	 mov	 ax, WORD PTR [esi+eax*2]
  0004d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00051	e8 00 00 00 00	 call	 _move16

; 107  :     }

  00056	eb ce		 jmp	 SHORT $LN3@decompress
$LN2@decompress:

; 108  :     
; 109  :     /*
; 110  :       First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits 
; 111  :       MSBs = indx[NB_TRACK]/8;
; 112  :       LSBs = indx[NB_TRACK]%8;
; 113  :       */
; 114  :     MSBs = shr(indx[NB_TRACK_MR102], 3);

  00058	6a 03		 push	 3
  0005a	b8 02 00 00 00	 mov	 eax, 2
  0005f	c1 e0 02	 shl	 eax, 2
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _indx$[ebp]
  00065	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _shr
  0006f	83 c4 08	 add	 esp, 8
  00072	66 89 45 d4	 mov	 WORD PTR _MSBs$[ebp], ax

; 115  :     LSBs = indx[NB_TRACK_MR102] & 7;                            logic16 ();

  00076	b8 02 00 00 00	 mov	 eax, 2
  0007b	c1 e0 02	 shl	 eax, 2
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _indx$[ebp]
  00081	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00085	83 e2 07	 and	 edx, 7
  00088	66 89 55 c8	 mov	 WORD PTR _LSBs$[ebp], dx
  0008c	e8 00 00 00 00	 call	 _logic16

; 116  :     decompress10 (MSBs, LSBs, 0, 4, 1, pos_indx);               

  00091	8b 45 10	 mov	 eax, DWORD PTR _pos_indx$[ebp]
  00094	50		 push	 eax
  00095	6a 01		 push	 1
  00097	6a 04		 push	 4
  00099	6a 00		 push	 0
  0009b	0f b7 4d c8	 movzx	 ecx, WORD PTR _LSBs$[ebp]
  0009f	51		 push	 ecx
  000a0	0f b7 55 d4	 movzx	 edx, WORD PTR _MSBs$[ebp]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _decompress10
  000aa	83 c4 18	 add	 esp, 24			; 00000018H

; 117  :     
; 118  :     /*
; 119  :       Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits       
; 120  :       MSBs = indx[NB_TRACK+1]/8;
; 121  :       LSBs = indx[NB_TRACK+1]%8;
; 122  :       */
; 123  :     MSBs = shr(indx[NB_TRACK_MR102+1], 3);

  000ad	6a 03		 push	 3
  000af	b8 02 00 00 00	 mov	 eax, 2
  000b4	6b c8 05	 imul	 ecx, eax, 5
  000b7	8b 55 08	 mov	 edx, DWORD PTR _indx$[ebp]
  000ba	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _shr
  000c4	83 c4 08	 add	 esp, 8
  000c7	66 89 45 d4	 mov	 WORD PTR _MSBs$[ebp], ax

; 124  :     LSBs = indx[NB_TRACK_MR102+1] & 7;                          logic16 ();

  000cb	b8 02 00 00 00	 mov	 eax, 2
  000d0	6b c8 05	 imul	 ecx, eax, 5
  000d3	8b 55 08	 mov	 edx, DWORD PTR _indx$[ebp]
  000d6	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  000da	83 e0 07	 and	 eax, 7
  000dd	66 89 45 c8	 mov	 WORD PTR _LSBs$[ebp], ax
  000e1	e8 00 00 00 00	 call	 _logic16

; 125  :     decompress10 (MSBs, LSBs, 2, 6, 5, pos_indx);               

  000e6	8b 45 10	 mov	 eax, DWORD PTR _pos_indx$[ebp]
  000e9	50		 push	 eax
  000ea	6a 05		 push	 5
  000ec	6a 06		 push	 6
  000ee	6a 02		 push	 2
  000f0	0f b7 4d c8	 movzx	 ecx, WORD PTR _LSBs$[ebp]
  000f4	51		 push	 ecx
  000f5	0f b7 55 d4	 movzx	 edx, WORD PTR _MSBs$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _decompress10
  000ff	83 c4 18	 add	 esp, 24			; 00000018H

; 126  :     
; 127  :     /*
; 128  :       Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits    
; 129  :       MSBs = indx[NB_TRACK+2]/4;
; 130  :       LSBs = indx[NB_TRACK+2]%4;
; 131  :       MSBs0_24 = (MSBs*25+12)/32;
; 132  :       if ((MSBs0_24/5)%2==1)
; 133  :          pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
; 134  :       else
; 135  :          pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
; 136  :       pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
; 137  :       */
; 138  :     MSBs = shr(indx[NB_TRACK_MR102+2], 2);

  00102	6a 02		 push	 2
  00104	b8 02 00 00 00	 mov	 eax, 2
  00109	6b c8 06	 imul	 ecx, eax, 6
  0010c	8b 55 08	 mov	 edx, DWORD PTR _indx$[ebp]
  0010f	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _shr
  00119	83 c4 08	 add	 esp, 8
  0011c	66 89 45 d4	 mov	 WORD PTR _MSBs$[ebp], ax

; 139  :     LSBs = indx[NB_TRACK_MR102+2] & 3;                          logic16 ();

  00120	b8 02 00 00 00	 mov	 eax, 2
  00125	6b c8 06	 imul	 ecx, eax, 6
  00128	8b 55 08	 mov	 edx, DWORD PTR _indx$[ebp]
  0012b	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  0012f	83 e0 03	 and	 eax, 3
  00132	66 89 45 c8	 mov	 WORD PTR _LSBs$[ebp], ax
  00136	e8 00 00 00 00	 call	 _logic16

; 140  : 
; 141  :     MSBs0_24 = shr(add(extract_l(L_shr(L_mult(MSBs, 25), 1)), 12), 5);

  0013b	6a 05		 push	 5
  0013d	6a 0c		 push	 12			; 0000000cH
  0013f	6a 01		 push	 1
  00141	6a 19		 push	 25			; 00000019H
  00143	0f b7 45 d4	 movzx	 eax, WORD PTR _MSBs$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _L_mult
  0014d	83 c4 08	 add	 esp, 8
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _L_shr
  00156	83 c4 08	 add	 esp, 8
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _extract_l
  0015f	83 c4 04	 add	 esp, 4
  00162	0f b7 c8	 movzx	 ecx, ax
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _add
  0016b	83 c4 08	 add	 esp, 8
  0016e	0f b7 d0	 movzx	 edx, ax
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 _shr
  00177	83 c4 08	 add	 esp, 8
  0017a	66 89 45 bc	 mov	 WORD PTR _MSBs0_24$[ebp], ax

; 142  :     
; 143  :     ia = mult(MSBs0_24, 6554) & 1;

  0017e	68 9a 19 00 00	 push	 6554			; 0000199aH
  00183	0f b7 45 bc	 movzx	 eax, WORD PTR _MSBs0_24$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _mult
  0018d	83 c4 08	 add	 esp, 8
  00190	0f bf c8	 movsx	 ecx, ax
  00193	83 e1 01	 and	 ecx, 1
  00196	66 89 4d ec	 mov	 WORD PTR _ia$[ebp], cx

; 144  :     ib = sub(MSBs0_24, extract_l(L_shr(L_mult(mult(MSBs0_24, 6554), 5), 1)));

  0019a	6a 01		 push	 1
  0019c	6a 05		 push	 5
  0019e	68 9a 19 00 00	 push	 6554			; 0000199aH
  001a3	0f b7 45 bc	 movzx	 eax, WORD PTR _MSBs0_24$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _mult
  001ad	83 c4 08	 add	 esp, 8
  001b0	0f b7 c8	 movzx	 ecx, ax
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 _L_mult
  001b9	83 c4 08	 add	 esp, 8
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _L_shr
  001c2	83 c4 08	 add	 esp, 8
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 _extract_l
  001cb	83 c4 04	 add	 esp, 4
  001ce	0f b7 d0	 movzx	 edx, ax
  001d1	52		 push	 edx
  001d2	0f b7 45 bc	 movzx	 eax, WORD PTR _MSBs0_24$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _sub
  001dc	83 c4 08	 add	 esp, 8
  001df	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax

; 145  : 
; 146  :     test ();

  001e3	e8 00 00 00 00	 call	 _test

; 147  :     if (sub(ia, 1) == 0)

  001e8	6a 01		 push	 1
  001ea	0f b7 45 ec	 movzx	 eax, WORD PTR _ia$[ebp]
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _sub
  001f4	83 c4 08	 add	 esp, 8
  001f7	0f bf c8	 movsx	 ecx, ax
  001fa	85 c9		 test	 ecx, ecx
  001fc	75 13		 jne	 SHORT $LN1@decompress

; 148  :     {
; 149  :        ib = sub(4, ib);

  001fe	0f b7 45 e0	 movzx	 eax, WORD PTR _ib$[ebp]
  00202	50		 push	 eax
  00203	6a 04		 push	 4
  00205	e8 00 00 00 00	 call	 _sub
  0020a	83 c4 08	 add	 esp, 8
  0020d	66 89 45 e0	 mov	 WORD PTR _ib$[ebp], ax
$LN1@decompress:

; 150  :     }
; 151  :     pos_indx[3] = add(shl(ib, 1), (LSBs & 1));               logic16 ();           

  00211	0f bf 45 c8	 movsx	 eax, WORD PTR _LSBs$[ebp]
  00215	83 e0 01	 and	 eax, 1
  00218	50		 push	 eax
  00219	6a 01		 push	 1
  0021b	0f b7 4d e0	 movzx	 ecx, WORD PTR _ib$[ebp]
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 _shl
  00225	83 c4 08	 add	 esp, 8
  00228	0f b7 d0	 movzx	 edx, ax
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 _add
  00231	83 c4 08	 add	 esp, 8
  00234	b9 02 00 00 00	 mov	 ecx, 2
  00239	6b d1 03	 imul	 edx, ecx, 3
  0023c	8b 4d 10	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  0023f	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  00243	e8 00 00 00 00	 call	 _logic16

; 152  :     
; 153  :     ia = shl(mult(MSBs0_24, 6554), 1);

  00248	6a 01		 push	 1
  0024a	68 9a 19 00 00	 push	 6554			; 0000199aH
  0024f	0f b7 45 bc	 movzx	 eax, WORD PTR _MSBs0_24$[ebp]
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 _mult
  00259	83 c4 08	 add	 esp, 8
  0025c	0f b7 c8	 movzx	 ecx, ax
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 _shl
  00265	83 c4 08	 add	 esp, 8
  00268	66 89 45 ec	 mov	 WORD PTR _ia$[ebp], ax

; 154  :     pos_indx[7] = add(ia, shr(LSBs, 1));

  0026c	6a 01		 push	 1
  0026e	0f b7 45 c8	 movzx	 eax, WORD PTR _LSBs$[ebp]
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _shr
  00278	83 c4 08	 add	 esp, 8
  0027b	0f b7 c8	 movzx	 ecx, ax
  0027e	51		 push	 ecx
  0027f	0f b7 55 ec	 movzx	 edx, WORD PTR _ia$[ebp]
  00283	52		 push	 edx
  00284	e8 00 00 00 00	 call	 _add
  00289	83 c4 08	 add	 esp, 8
  0028c	b9 02 00 00 00	 mov	 ecx, 2
  00291	6b d1 07	 imul	 edx, ecx, 7
  00294	8b 4d 10	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  00297	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 155  : }

  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi
  0029d	5b		 pop	 ebx
  0029e	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  002a4	3b ec		 cmp	 ebp, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
_decompress_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _decompress10
_TEXT	SEGMENT
_ic$ = -32						; size = 2
_ib$ = -20						; size = 2
_ia$ = -8						; size = 2
_MSBs$ = 8						; size = 2
_LSBs$ = 12						; size = 2
_index1$ = 16						; size = 2
_index2$ = 20						; size = 2
_index3$ = 24						; size = 2
_pos_indx$ = 28						; size = 4
_decompress10 PROC					; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 53   :    Word16 ia, ib, ic;
; 54   : 
; 55   :    /*
; 56   :      pos_indx[index1] = ((MSBs-25*(MSBs/25))%5)*2 + (LSBs-4*(LSBs/4))%2;
; 57   :      pos_indx[index2] = ((MSBs-25*(MSBs/25))/5)*2 + (LSBs-4*(LSBs/4))/2;
; 58   :      pos_indx[index3] = (MSBs/25)*2 + LSBs/4;
; 59   :      */
; 60   : 
; 61   :    test ();

  0001e	e8 00 00 00 00	 call	 _test

; 62   :    if (sub(MSBs, 124) > 0)

  00023	6a 7c		 push	 124			; 0000007cH
  00025	0f b7 45 08	 movzx	 eax, WORD PTR _MSBs$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sub
  0002f	83 c4 08	 add	 esp, 8
  00032	0f bf c8	 movsx	 ecx, ax
  00035	85 c9		 test	 ecx, ecx
  00037	7e 0e		 jle	 SHORT $LN1@decompress

; 63   :    {
; 64   :       MSBs = 124;                                              move16 (); 

  00039	b8 7c 00 00 00	 mov	 eax, 124		; 0000007cH
  0003e	66 89 45 08	 mov	 WORD PTR _MSBs$[ebp], ax
  00042	e8 00 00 00 00	 call	 _move16
$LN1@decompress:

; 65   :    }
; 66   :    
; 67   :    ia = mult(MSBs, 1311);

  00047	68 1f 05 00 00	 push	 1311			; 0000051fH
  0004c	0f b7 45 08	 movzx	 eax, WORD PTR _MSBs$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _mult
  00056	83 c4 08	 add	 esp, 8
  00059	66 89 45 f8	 mov	 WORD PTR _ia$[ebp], ax

; 68   :    ia = sub(MSBs, extract_l(L_shr(L_mult(ia, 25), 1)));    

  0005d	6a 01		 push	 1
  0005f	6a 19		 push	 25			; 00000019H
  00061	0f b7 45 f8	 movzx	 eax, WORD PTR _ia$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _L_mult
  0006b	83 c4 08	 add	 esp, 8
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _L_shr
  00074	83 c4 08	 add	 esp, 8
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _extract_l
  0007d	83 c4 04	 add	 esp, 4
  00080	0f b7 c8	 movzx	 ecx, ax
  00083	51		 push	 ecx
  00084	0f b7 55 08	 movzx	 edx, WORD PTR _MSBs$[ebp]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 _sub
  0008e	83 c4 08	 add	 esp, 8
  00091	66 89 45 f8	 mov	 WORD PTR _ia$[ebp], ax

; 69   :    ib = shl(sub(ia, extract_l(L_shr(L_mult(mult(ia, 6554), 5), 1))), 1);

  00095	6a 01		 push	 1
  00097	6a 01		 push	 1
  00099	6a 05		 push	 5
  0009b	68 9a 19 00 00	 push	 6554			; 0000199aH
  000a0	0f b7 45 f8	 movzx	 eax, WORD PTR _ia$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _mult
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b7 c8	 movzx	 ecx, ax
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _L_mult
  000b6	83 c4 08	 add	 esp, 8
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _L_shr
  000bf	83 c4 08	 add	 esp, 8
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _extract_l
  000c8	83 c4 04	 add	 esp, 4
  000cb	0f b7 d0	 movzx	 edx, ax
  000ce	52		 push	 edx
  000cf	0f b7 45 f8	 movzx	 eax, WORD PTR _ia$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _sub
  000d9	83 c4 08	 add	 esp, 8
  000dc	0f b7 c8	 movzx	 ecx, ax
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _shl
  000e5	83 c4 08	 add	 esp, 8
  000e8	66 89 45 ec	 mov	 WORD PTR _ib$[ebp], ax

; 70   :    
; 71   :    ic = shl(shr(LSBs, 2), 2);

  000ec	6a 02		 push	 2
  000ee	6a 02		 push	 2
  000f0	0f b7 45 0c	 movzx	 eax, WORD PTR _LSBs$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _shr
  000fa	83 c4 08	 add	 esp, 8
  000fd	0f b7 c8	 movzx	 ecx, ax
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 _shl
  00106	83 c4 08	 add	 esp, 8
  00109	66 89 45 e0	 mov	 WORD PTR _ic$[ebp], ax

; 72   :    ic = sub(LSBs, ic);

  0010d	0f b7 45 e0	 movzx	 eax, WORD PTR _ic$[ebp]
  00111	50		 push	 eax
  00112	0f b7 4d 0c	 movzx	 ecx, WORD PTR _LSBs$[ebp]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 _sub
  0011c	83 c4 08	 add	 esp, 8
  0011f	66 89 45 e0	 mov	 WORD PTR _ic$[ebp], ax

; 73   :    pos_indx[index1] = add(ib, (ic & 1));                        logic16 ();

  00123	0f bf 45 e0	 movsx	 eax, WORD PTR _ic$[ebp]
  00127	83 e0 01	 and	 eax, 1
  0012a	50		 push	 eax
  0012b	0f b7 4d ec	 movzx	 ecx, WORD PTR _ib$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 _add
  00135	83 c4 08	 add	 esp, 8
  00138	0f bf 55 10	 movsx	 edx, WORD PTR _index1$[ebp]
  0013c	8b 4d 1c	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  0013f	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00143	e8 00 00 00 00	 call	 _logic16

; 74   :    
; 75   :    ib = shl(mult(ia, 6554), 1);

  00148	6a 01		 push	 1
  0014a	68 9a 19 00 00	 push	 6554			; 0000199aH
  0014f	0f b7 45 f8	 movzx	 eax, WORD PTR _ia$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _mult
  00159	83 c4 08	 add	 esp, 8
  0015c	0f b7 c8	 movzx	 ecx, ax
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 _shl
  00165	83 c4 08	 add	 esp, 8
  00168	66 89 45 ec	 mov	 WORD PTR _ib$[ebp], ax

; 76   :    pos_indx[index2] = add(ib, shr(ic, 1));

  0016c	6a 01		 push	 1
  0016e	0f b7 45 e0	 movzx	 eax, WORD PTR _ic$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _shr
  00178	83 c4 08	 add	 esp, 8
  0017b	0f b7 c8	 movzx	 ecx, ax
  0017e	51		 push	 ecx
  0017f	0f b7 55 ec	 movzx	 edx, WORD PTR _ib$[ebp]
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 _add
  00189	83 c4 08	 add	 esp, 8
  0018c	0f bf 4d 14	 movsx	 ecx, WORD PTR _index2$[ebp]
  00190	8b 55 1c	 mov	 edx, DWORD PTR _pos_indx$[ebp]
  00193	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 77   :    
; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  00197	6a 02		 push	 2
  00199	0f b7 45 0c	 movzx	 eax, WORD PTR _LSBs$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _shr
  001a3	83 c4 08	 add	 esp, 8
  001a6	0f b7 c8	 movzx	 ecx, ax
  001a9	51		 push	 ecx
  001aa	6a 01		 push	 1
  001ac	68 1f 05 00 00	 push	 1311			; 0000051fH
  001b1	0f b7 55 08	 movzx	 edx, WORD PTR _MSBs$[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 _mult
  001bb	83 c4 08	 add	 esp, 8
  001be	0f b7 c0	 movzx	 eax, ax
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _shl
  001c7	83 c4 08	 add	 esp, 8
  001ca	0f b7 c8	 movzx	 ecx, ax
  001cd	51		 push	 ecx
  001ce	e8 00 00 00 00	 call	 _add
  001d3	83 c4 08	 add	 esp, 8
  001d6	0f bf 55 18	 movsx	 edx, WORD PTR _index3$[ebp]
  001da	8b 4d 1c	 mov	 ecx, DWORD PTR _pos_indx$[ebp]
  001dd	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 79   : 
; 80   :    return;
; 81   : }    

  001e1	5f		 pop	 edi
  001e2	5e		 pop	 esi
  001e3	5b		 pop	 ebx
  001e4	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  001ea	3b ec		 cmp	 ebp, esp
  001ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f1	8b e5		 mov	 esp, ebp
  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
_decompress10 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _dec_8i40_31bits
_TEXT	SEGMENT
_linear_codewords$ = -100				; size = 16
_linear_signs$ = -76					; size = 8
_sign$ = -60						; size = 2
_pos2$ = -48						; size = 2
_pos1$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_index$ = 8						; size = 4
_cod$ = 12						; size = 4
_dec_8i40_31bits PROC					; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 178  :     Word16 i, j, pos1, pos2, sign;
; 179  :     Word16 linear_signs[NB_TRACK_MR102];
; 180  :     Word16 linear_codewords[NB_PULSE];
; 181  :     
; 182  :     for (i = 0; i < L_CODE; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN9@dec_8i40_3
$LN8@dec_8i40_3:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN9@dec_8i40_3:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 28	 cmp	 eax, 40			; 00000028H
  00043	7d 14		 jge	 SHORT $LN7@dec_8i40_3

; 183  :     {
; 184  :         cod[i] = 0;                                    move16 (); 

  00045	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00049	33 c9		 xor	 ecx, ecx
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  0004e	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00052	e8 00 00 00 00	 call	 _move16

; 185  :     }

  00057	eb d7		 jmp	 SHORT $LN8@dec_8i40_3
$LN7@dec_8i40_3:

; 186  :     
; 187  :     decompress_code (index, linear_signs, linear_codewords);

  00059	8d 45 9c	 lea	 eax, DWORD PTR _linear_codewords$[ebp]
  0005c	50		 push	 eax
  0005d	8d 4d b4	 lea	 ecx, DWORD PTR _linear_signs$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _decompress_code
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  :     
; 189  :     /* decode the positions and signs of pulses and build the codeword */
; 190  : 
; 191  :     for (j = 0; j < NB_TRACK_MR102; j++)

  0006d	33 c0		 xor	 eax, eax
  0006f	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00073	eb 0c		 jmp	 SHORT $LN6@dec_8i40_3
$LN5@dec_8i40_3:
  00075	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00079	66 83 c0 01	 add	 ax, 1
  0007d	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN6@dec_8i40_3:
  00081	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00085	83 f8 04	 cmp	 eax, 4
  00088	0f 8d 43 01 00
	00		 jge	 $LN10@dec_8i40_3

; 192  :     {
; 193  :        /* compute index i */
; 194  :        
; 195  :        i = linear_codewords[j];

  0008e	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00092	66 8b 4c 45 9c	 mov	 cx, WORD PTR _linear_codewords$[ebp+eax*2]
  00097	66 89 4d f4	 mov	 WORD PTR _i$[ebp], cx

; 196  :        i = extract_l (L_shr (L_mult (i, 4), 1));

  0009b	6a 01		 push	 1
  0009d	6a 04		 push	 4
  0009f	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _L_mult
  000a9	83 c4 08	 add	 esp, 8
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _L_shr
  000b2	83 c4 08	 add	 esp, 8
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _extract_l
  000bb	83 c4 04	 add	 esp, 4
  000be	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 197  :        pos1 = add (i, j);   /* position of pulse "j" */

  000c2	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  000c6	50		 push	 eax
  000c7	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 _add
  000d1	83 c4 08	 add	 esp, 8
  000d4	66 89 45 dc	 mov	 WORD PTR _pos1$[ebp], ax

; 198  :        
; 199  :        test (); 

  000d8	e8 00 00 00 00	 call	 _test

; 200  :        if (linear_signs[j] == 0)

  000dd	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  000e1	0f bf 4c 45 b4	 movsx	 ecx, WORD PTR _linear_signs$[ebp+eax*2]
  000e6	85 c9		 test	 ecx, ecx
  000e8	75 10		 jne	 SHORT $LN3@dec_8i40_3

; 201  :        {
; 202  :           sign = POS_CODE;                             move16 (); /* +1.0 */

  000ea	b8 ff 1f 00 00	 mov	 eax, 8191		; 00001fffH
  000ef	66 89 45 c4	 mov	 WORD PTR _sign$[ebp], ax
  000f3	e8 00 00 00 00	 call	 _move16

; 203  :        }
; 204  :        else

  000f8	eb 0e		 jmp	 SHORT $LN2@dec_8i40_3
$LN3@dec_8i40_3:

; 205  :        {
; 206  :           sign = -NEG_CODE;                            move16 (); /* -1.0 */

  000fa	b8 01 e0 ff ff	 mov	 eax, -8191		; ffffe001H
  000ff	66 89 45 c4	 mov	 WORD PTR _sign$[ebp], ax
  00103	e8 00 00 00 00	 call	 _move16
$LN2@dec_8i40_3:

; 207  :        }
; 208  :        
; 209  :        cod[pos1] = sign;                               move16 (); 

  00108	0f bf 45 dc	 movsx	 eax, WORD PTR _pos1$[ebp]
  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _cod$[ebp]
  0010f	66 8b 55 c4	 mov	 dx, WORD PTR _sign$[ebp]
  00113	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00117	e8 00 00 00 00	 call	 _move16

; 210  :        
; 211  :        /* compute index i */
; 212  :        
; 213  :        i = linear_codewords[add (j, 4)];        

  0011c	6a 04		 push	 4
  0011e	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _add
  00128	83 c4 08	 add	 esp, 8
  0012b	0f bf c8	 movsx	 ecx, ax
  0012e	66 8b 54 4d 9c	 mov	 dx, WORD PTR _linear_codewords$[ebp+ecx*2]
  00133	66 89 55 f4	 mov	 WORD PTR _i$[ebp], dx

; 214  :        i = extract_l (L_shr (L_mult (i, 4), 1));

  00137	6a 01		 push	 1
  00139	6a 04		 push	 4
  0013b	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _L_mult
  00145	83 c4 08	 add	 esp, 8
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _L_shr
  0014e	83 c4 08	 add	 esp, 8
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 _extract_l
  00157	83 c4 04	 add	 esp, 4
  0015a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax

; 215  :        pos2 = add (i, j);      /* position of pulse "j+4" */

  0015e	0f b7 45 e8	 movzx	 eax, WORD PTR _j$[ebp]
  00162	50		 push	 eax
  00163	0f b7 4d f4	 movzx	 ecx, WORD PTR _i$[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _add
  0016d	83 c4 08	 add	 esp, 8
  00170	66 89 45 d0	 mov	 WORD PTR _pos2$[ebp], ax

; 216  :        
; 217  :        test (); 

  00174	e8 00 00 00 00	 call	 _test

; 218  :        if (sub (pos2, pos1) < 0)

  00179	0f b7 45 dc	 movzx	 eax, WORD PTR _pos1$[ebp]
  0017d	50		 push	 eax
  0017e	0f b7 4d d0	 movzx	 ecx, WORD PTR _pos2$[ebp]
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 _sub
  00188	83 c4 08	 add	 esp, 8
  0018b	0f bf d0	 movsx	 edx, ax
  0018e	85 d2		 test	 edx, edx
  00190	7d 11		 jge	 SHORT $LN1@dec_8i40_3

; 219  :        {
; 220  :           sign = negate (sign);

  00192	0f b7 45 c4	 movzx	 eax, WORD PTR _sign$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _negate
  0019c	83 c4 04	 add	 esp, 4
  0019f	66 89 45 c4	 mov	 WORD PTR _sign$[ebp], ax
$LN1@dec_8i40_3:

; 221  :        }
; 222  :        cod[pos2] = add (cod[pos2], sign);              move16 (); 

  001a3	0f b7 45 c4	 movzx	 eax, WORD PTR _sign$[ebp]
  001a7	50		 push	 eax
  001a8	0f bf 4d d0	 movsx	 ecx, WORD PTR _pos2$[ebp]
  001ac	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  001af	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _add
  001b9	83 c4 08	 add	 esp, 8
  001bc	0f bf 4d d0	 movsx	 ecx, WORD PTR _pos2$[ebp]
  001c0	8b 55 0c	 mov	 edx, DWORD PTR _cod$[ebp]
  001c3	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  001c7	e8 00 00 00 00	 call	 _move16

; 223  :     }

  001cc	e9 a4 fe ff ff	 jmp	 $LN5@dec_8i40_3
$LN10@dec_8i40_3:

; 224  :     
; 225  :     return;
; 226  : }

  001d1	52		 push	 edx
  001d2	8b cd		 mov	 ecx, ebp
  001d4	50		 push	 eax
  001d5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@dec_8i40_3
  001db	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e0	58		 pop	 eax
  001e1	5a		 pop	 edx
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e8	33 cd		 xor	 ecx, ebp
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  001f5	3b ec		 cmp	 ebp, esp
  001f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c3		 ret	 0
$LN15@dec_8i40_3:
  00200	02 00 00 00	 DD	 2
  00204	00 00 00 00	 DD	 $LN14@dec_8i40_3
$LN14@dec_8i40_3:
  00208	b4 ff ff ff	 DD	 -76			; ffffffb4H
  0020c	08 00 00 00	 DD	 8
  00210	00 00 00 00	 DD	 $LN12@dec_8i40_3
  00214	9c ff ff ff	 DD	 -100			; ffffff9cH
  00218	10 00 00 00	 DD	 16			; 00000010H
  0021c	00 00 00 00	 DD	 $LN13@dec_8i40_3
$LN13@dec_8i40_3:
  00220	6c		 DB	 108			; 0000006cH
  00221	69		 DB	 105			; 00000069H
  00222	6e		 DB	 110			; 0000006eH
  00223	65		 DB	 101			; 00000065H
  00224	61		 DB	 97			; 00000061H
  00225	72		 DB	 114			; 00000072H
  00226	5f		 DB	 95			; 0000005fH
  00227	63		 DB	 99			; 00000063H
  00228	6f		 DB	 111			; 0000006fH
  00229	64		 DB	 100			; 00000064H
  0022a	65		 DB	 101			; 00000065H
  0022b	77		 DB	 119			; 00000077H
  0022c	6f		 DB	 111			; 0000006fH
  0022d	72		 DB	 114			; 00000072H
  0022e	64		 DB	 100			; 00000064H
  0022f	73		 DB	 115			; 00000073H
  00230	00		 DB	 0
$LN12@dec_8i40_3:
  00231	6c		 DB	 108			; 0000006cH
  00232	69		 DB	 105			; 00000069H
  00233	6e		 DB	 110			; 0000006eH
  00234	65		 DB	 101			; 00000065H
  00235	61		 DB	 97			; 00000061H
  00236	72		 DB	 114			; 00000072H
  00237	5f		 DB	 95			; 0000005fH
  00238	73		 DB	 115			; 00000073H
  00239	69		 DB	 105			; 00000069H
  0023a	67		 DB	 103			; 00000067H
  0023b	6e		 DB	 110			; 0000006eH
  0023c	73		 DB	 115			; 00000073H
  0023d	00		 DB	 0
_dec_8i40_31bits ENDP
_TEXT	ENDS
END
