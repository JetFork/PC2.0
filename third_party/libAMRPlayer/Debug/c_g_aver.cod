; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c_g_aver.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c_g_aver_id
CONST	SEGMENT
_c_g_aver_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_Cb_gain_average_init
PUBLIC	_Cb_gain_average_reset
PUBLIC	_Cb_gain_average_exit
PUBLIC	_Cb_gain_average
PUBLIC	??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@ ; `string'
PUBLIC	??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@ ; `string'
PUBLIC	??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_L_mult:PROC
EXTRN	_negate:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shl:PROC
EXTRN	_norm_s:PROC
EXTRN	_div_s:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Set_zero:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@
CONST	SEGMENT
??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@ DB 'Cb_gain_avera'
	DB	'ge_reset: invalid parameter', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@
CONST	SEGMENT
??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@ DB 'Cb_gain_aver'
	DB	'age_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@
CONST	SEGMENT
??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@ DB 'Cb_gain_avera'
	DB	'ge_init: invalid parameter', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average
_TEXT	SEGMENT
_shift$ = -172						; size = 2
_shift2$ = -160						; size = 2
_shift1$ = -148						; size = 2
_tmp2$ = -136						; size = 2
_tmp1$ = -124						; size = 2
_tmp$ = -112						; size = 20
_L_sum$ = -84						; size = 4
_cbGainMean$ = -72					; size = 2
_bgMix$ = -60						; size = 2
_tmp_diff$ = -48					; size = 2
_diff$ = -36						; size = 2
_cbGainMix$ = -24					; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_mode$ = 12						; size = 4
_gain_code$ = 16					; size = 2
_lsp$ = 20						; size = 4
_lspAver$ = 24						; size = 4
_bfi$ = 28						; size = 2
_prev_bf$ = 32						; size = 2
_pdfi$ = 36						; size = 2
_prev_pdf$ = 40						; size = 2
_inBackgroundNoise$ = 44				; size = 2
_voicedHangover$ = 48					; size = 2
_Cb_gain_average PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 90 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-368]
  00012	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 147  :    /*---------------------------------------------------------*
; 148  :     * Compute mixed cb gain, used to make cb gain more        *
; 149  :     * smooth in background noise for modes 5.15, 5.9 and 6.7  *
; 150  :     * states that needs to be updated by all                  *
; 151  :     *---------------------------------------------------------*/
; 152  :    Word16 i;
; 153  :    Word16 cbGainMix, diff, tmp_diff, bgMix, cbGainMean;
; 154  :    Word32 L_sum;
; 155  :    Word16 tmp[M], tmp1, tmp2, shift1, shift2, shift;
; 156  : 
; 157  :    /* set correct cbGainMix for MR74, MR795, MR122 */
; 158  :    cbGainMix = gain_code;             move16 (); 

  00028	66 8b 45 10	 mov	 ax, WORD PTR _gain_code$[ebp]
  0002c	66 89 45 e8	 mov	 WORD PTR _cbGainMix$[ebp], ax
  00030	e8 00 00 00 00	 call	 _move16

; 159  :    
; 160  :    /*-------------------------------------------------------*
; 161  :     *   Store list of CB gain needed in the CB gain         *
; 162  :     *   averaging                                           *
; 163  :     *-------------------------------------------------------*/
; 164  :    for (i = 0; i < (L_CBGAINHIST-1); i++)

  00035	33 c0		 xor	 eax, eax
  00037	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0003b	eb 0c		 jmp	 SHORT $LN40@Cb_gain_av
$LN39@Cb_gain_av:
  0003d	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00041	66 83 c0 01	 add	 ax, 1
  00045	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN40@Cb_gain_av:
  00049	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0004d	83 f8 06	 cmp	 eax, 6
  00050	7d 1e		 jge	 SHORT $LN38@Cb_gain_av

; 165  :    {
; 166  :       st->cbGainHistory[i] = st->cbGainHistory[i+1];    move16 ();

  00052	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00056	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0005d	8b 75 08	 mov	 esi, DWORD PTR _st$[ebp]
  00060	66 8b 44 46 02	 mov	 ax, WORD PTR [esi+eax*2+2]
  00065	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00069	e8 00 00 00 00	 call	 _move16

; 167  :    }

  0006e	eb cd		 jmp	 SHORT $LN39@Cb_gain_av
$LN38@Cb_gain_av:

; 168  :    st->cbGainHistory[L_CBGAINHIST-1] = gain_code;       move16 ();

  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	6b c8 06	 imul	 ecx, eax, 6
  00078	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0007b	66 8b 45 10	 mov	 ax, WORD PTR _gain_code$[ebp]
  0007f	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00083	e8 00 00 00 00	 call	 _move16

; 169  :    
; 170  :    /* compute lsp difference */
; 171  :    for (i = 0; i < M; i++) {

  00088	33 c0		 xor	 eax, eax
  0008a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0008e	eb 0c		 jmp	 SHORT $LN37@Cb_gain_av
$LN36@Cb_gain_av:
  00090	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00094	66 83 c0 01	 add	 ax, 1
  00098	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN37@Cb_gain_av:
  0009c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000a0	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000a3	0f 8d 6c 01 00
	00		 jge	 $LN35@Cb_gain_av

; 172  :       tmp1 = abs_s(sub(lspAver[i], lsp[i]));  /* Q15       */

  000a9	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000ad	8b 4d 14	 mov	 ecx, DWORD PTR _lsp$[ebp]
  000b0	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000b4	52		 push	 edx
  000b5	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000b9	8b 4d 18	 mov	 ecx, DWORD PTR _lspAver$[ebp]
  000bc	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _sub
  000c6	83 c4 08	 add	 esp, 8
  000c9	0f b7 c0	 movzx	 eax, ax
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _abs_s
  000d2	83 c4 04	 add	 esp, 4
  000d5	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax

; 173  :       shift1 = sub(norm_s(tmp1), 1);          /* Qn        */

  000d9	6a 01		 push	 1
  000db	0f b7 45 84	 movzx	 eax, WORD PTR _tmp1$[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _norm_s
  000e5	83 c4 04	 add	 esp, 4
  000e8	0f b7 c8	 movzx	 ecx, ax
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _sub
  000f1	83 c4 08	 add	 esp, 8
  000f4	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _shift1$[ebp], ax

; 174  :       tmp1 = shl(tmp1, shift1);               /* Q15+Qn    */

  000fb	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _shift1$[ebp]
  00102	50		 push	 eax
  00103	0f b7 4d 84	 movzx	 ecx, WORD PTR _tmp1$[ebp]
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 _shl
  0010d	83 c4 08	 add	 esp, 8
  00110	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax

; 175  :       shift2 = norm_s(lspAver[i]);            /* Qm        */

  00114	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00118	8b 4d 18	 mov	 ecx, DWORD PTR _lspAver$[ebp]
  0011b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 _norm_s
  00125	83 c4 04	 add	 esp, 4
  00128	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _shift2$[ebp], ax

; 176  :       tmp2 = shl(lspAver[i], shift2);         /* Q15+Qm    */

  0012f	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _shift2$[ebp]
  00136	50		 push	 eax
  00137	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0013b	8b 55 18	 mov	 edx, DWORD PTR _lspAver$[ebp]
  0013e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _shl
  00148	83 c4 08	 add	 esp, 8
  0014b	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _tmp2$[ebp], ax

; 177  :       tmp[i] = div_s(tmp1, tmp2);             /* Q15+(Q15+Qn)-(Q15+Qm) */

  00152	0f b7 85 78 ff
	ff ff		 movzx	 eax, WORD PTR _tmp2$[ebp]
  00159	50		 push	 eax
  0015a	0f b7 4d 84	 movzx	 ecx, WORD PTR _tmp1$[ebp]
  0015e	51		 push	 ecx
  0015f	e8 00 00 00 00	 call	 _div_s
  00164	83 c4 08	 add	 esp, 8
  00167	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  0016b	66 89 44 55 90	 mov	 WORD PTR _tmp$[ebp+edx*2], ax

; 178  :                                               move16 ();

  00170	e8 00 00 00 00	 call	 _move16

; 179  :       shift = sub(add(2, shift1), shift2);

  00175	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _shift2$[ebp]
  0017c	50		 push	 eax
  0017d	0f b7 8d 6c ff
	ff ff		 movzx	 ecx, WORD PTR _shift1$[ebp]
  00184	51		 push	 ecx
  00185	6a 02		 push	 2
  00187	e8 00 00 00 00	 call	 _add
  0018c	83 c4 08	 add	 esp, 8
  0018f	0f b7 d0	 movzx	 edx, ax
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _sub
  00198	83 c4 08	 add	 esp, 8
  0019b	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _shift$[ebp], ax

; 180  :       test ();

  001a2	e8 00 00 00 00	 call	 _test

; 181  :       if (shift >= 0)

  001a7	0f bf 85 54 ff
	ff ff		 movsx	 eax, WORD PTR _shift$[ebp]
  001ae	85 c0		 test	 eax, eax
  001b0	7c 2a		 jl	 SHORT $LN34@Cb_gain_av

; 182  :       {
; 183  :          tmp[i] = shr(tmp[i], shift); move16 ();          /* Q15+Qn-Qm-Qx=Q13 */

  001b2	0f b7 85 54 ff
	ff ff		 movzx	 eax, WORD PTR _shift$[ebp]
  001b9	50		 push	 eax
  001ba	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  001be	0f b7 54 4d 90	 movzx	 edx, WORD PTR _tmp$[ebp+ecx*2]
  001c3	52		 push	 edx
  001c4	e8 00 00 00 00	 call	 _shr
  001c9	83 c4 08	 add	 esp, 8
  001cc	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  001d0	66 89 44 4d 90	 mov	 WORD PTR _tmp$[ebp+ecx*2], ax
  001d5	e8 00 00 00 00	 call	 _move16

; 184  :       }
; 185  :       else

  001da	eb 34		 jmp	 SHORT $LN33@Cb_gain_av
$LN34@Cb_gain_av:

; 186  :       {
; 187  :          tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */

  001dc	0f b7 85 54 ff
	ff ff		 movzx	 eax, WORD PTR _shift$[ebp]
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _negate
  001e9	83 c4 04	 add	 esp, 4
  001ec	0f b7 c8	 movzx	 ecx, ax
  001ef	51		 push	 ecx
  001f0	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  001f4	0f b7 44 55 90	 movzx	 eax, WORD PTR _tmp$[ebp+edx*2]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 _shl
  001ff	83 c4 08	 add	 esp, 8
  00202	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00206	66 89 44 4d 90	 mov	 WORD PTR _tmp$[ebp+ecx*2], ax
  0020b	e8 00 00 00 00	 call	 _move16
$LN33@Cb_gain_av:

; 188  :       }
; 189  :    }

  00210	e9 7b fe ff ff	 jmp	 $LN36@Cb_gain_av
$LN35@Cb_gain_av:

; 190  :    
; 191  :    diff = tmp[0];                                   move16 ();

  00215	b8 02 00 00 00	 mov	 eax, 2
  0021a	6b c8 00	 imul	 ecx, eax, 0
  0021d	66 8b 54 0d 90	 mov	 dx, WORD PTR _tmp$[ebp+ecx]
  00222	66 89 55 dc	 mov	 WORD PTR _diff$[ebp], dx
  00226	e8 00 00 00 00	 call	 _move16

; 192  :    for (i = 1; i < M; i++) { 

  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00234	eb 0c		 jmp	 SHORT $LN32@Cb_gain_av
$LN31@Cb_gain_av:
  00236	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0023a	66 83 c0 01	 add	 ax, 1
  0023e	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN32@Cb_gain_av:
  00242	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00246	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00249	7d 1d		 jge	 SHORT $LN30@Cb_gain_av

; 193  :       diff = add(diff, tmp[i]);       /* Q13 */

  0024b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0024f	0f b7 4c 45 90	 movzx	 ecx, WORD PTR _tmp$[ebp+eax*2]
  00254	51		 push	 ecx
  00255	0f b7 55 dc	 movzx	 edx, WORD PTR _diff$[ebp]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 _add
  0025f	83 c4 08	 add	 esp, 8
  00262	66 89 45 dc	 mov	 WORD PTR _diff$[ebp], ax

; 194  :    }   

  00266	eb ce		 jmp	 SHORT $LN31@Cb_gain_av
$LN30@Cb_gain_av:

; 195  : 
; 196  :    /* Compute hangover */
; 197  :    test ();

  00268	e8 00 00 00 00	 call	 _test

; 198  :    if (sub(diff, 5325) > 0)  /* 0.65 in Q11 */

  0026d	68 cd 14 00 00	 push	 5325			; 000014cdH
  00272	0f b7 45 dc	 movzx	 eax, WORD PTR _diff$[ebp]
  00276	50		 push	 eax
  00277	e8 00 00 00 00	 call	 _sub
  0027c	83 c4 08	 add	 esp, 8
  0027f	0f bf c8	 movsx	 ecx, ax
  00282	85 c9		 test	 ecx, ecx
  00284	7e 1b		 jle	 SHORT $LN29@Cb_gain_av

; 199  :    {
; 200  :       st->hangVar = add(st->hangVar, 1);

  00286	6a 01		 push	 1
  00288	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0028b	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 _add
  00295	83 c4 08	 add	 esp, 8
  00298	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0029b	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 201  :    }
; 202  :    else

  0029f	eb 0e		 jmp	 SHORT $LN28@Cb_gain_av
$LN29@Cb_gain_av:

; 203  :    {
; 204  :       st->hangVar = 0;     move16 ();

  002a1	33 c0		 xor	 eax, eax
  002a3	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002a6	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax
  002aa	e8 00 00 00 00	 call	 _move16
$LN28@Cb_gain_av:

; 205  :    }
; 206  : 
; 207  :    test (); 

  002af	e8 00 00 00 00	 call	 _test

; 208  :    if (sub(st->hangVar, 10) > 0)

  002b4	6a 0a		 push	 10			; 0000000aH
  002b6	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  002b9	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  002bd	51		 push	 ecx
  002be	e8 00 00 00 00	 call	 _sub
  002c3	83 c4 08	 add	 esp, 8
  002c6	0f bf d0	 movsx	 edx, ax
  002c9	85 d2		 test	 edx, edx
  002cb	7e 0e		 jle	 SHORT $LN27@Cb_gain_av

; 209  :    {
; 210  :       st->hangCount = 0;  /* Speech period, reset hangover variable */ move16 ();

  002cd	33 c0		 xor	 eax, eax
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  002d2	66 89 41 10	 mov	 WORD PTR [ecx+16], ax
  002d6	e8 00 00 00 00	 call	 _move16
$LN27@Cb_gain_av:

; 211  :    }
; 212  : 
; 213  :    /* Compute mix constant (bgMix) */   
; 214  :    bgMix = 8192;    /* 1 in Q13 */     move16 ();

  002db	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  002e0	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
  002e4	e8 00 00 00 00	 call	 _move16

; 215  :    test (); 

  002e9	e8 00 00 00 00	 call	 _test

; 216  :    if ((sub(mode, MR67) <= 0) || (sub(mode, MR102) == 0))  

  002ee	6a 03		 push	 3
  002f0	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 _sub
  002fa	83 c4 08	 add	 esp, 8
  002fd	0f bf c8	 movsx	 ecx, ax
  00300	85 c9		 test	 ecx, ecx
  00302	7e 1a		 jle	 SHORT $LN25@Cb_gain_av
  00304	6a 06		 push	 6
  00306	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _sub
  00310	83 c4 08	 add	 esp, 8
  00313	0f bf c8	 movsx	 ecx, ax
  00316	85 c9		 test	 ecx, ecx
  00318	0f 85 ca 03 00
	00		 jne	 $LN26@Cb_gain_av
$LN25@Cb_gain_av:

; 217  :       /* MR475, MR515, MR59, MR67, MR102 */
; 218  :    {
; 219  :       /* if errors and presumed noise make smoothing probability stronger */
; 220  :       test (); test (); test (); test (); test (); test(); test (); test (); test ();

  0031e	e8 00 00 00 00	 call	 _test
  00323	e8 00 00 00 00	 call	 _test
  00328	e8 00 00 00 00	 call	 _test
  0032d	e8 00 00 00 00	 call	 _test
  00332	e8 00 00 00 00	 call	 _test
  00337	e8 00 00 00 00	 call	 _test
  0033c	e8 00 00 00 00	 call	 _test
  00341	e8 00 00 00 00	 call	 _test
  00346	e8 00 00 00 00	 call	 _test

; 221  :       if (((((pdfi != 0) && (prev_pdf != 0)) || (bfi != 0) || (prev_bf != 0)) &&
; 222  :           (sub(voicedHangover, 1) > 0) && (inBackgroundNoise != 0) && 
; 223  :           ((sub(mode, MR475) == 0) ||
; 224  :            (sub(mode, MR515) == 0) ||
; 225  :            (sub(mode, MR59) == 0)) ))

  0034b	0f bf 45 24	 movsx	 eax, WORD PTR _pdfi$[ebp]
  0034f	85 c0		 test	 eax, eax
  00351	74 08		 je	 SHORT $LN22@Cb_gain_av
  00353	0f bf 45 28	 movsx	 eax, WORD PTR _prev_pdf$[ebp]
  00357	85 c0		 test	 eax, eax
  00359	75 14		 jne	 SHORT $LN23@Cb_gain_av
$LN22@Cb_gain_av:
  0035b	0f bf 45 1c	 movsx	 eax, WORD PTR _bfi$[ebp]
  0035f	85 c0		 test	 eax, eax
  00361	75 0c		 jne	 SHORT $LN23@Cb_gain_av
  00363	0f bf 45 20	 movsx	 eax, WORD PTR _prev_bf$[ebp]
  00367	85 c0		 test	 eax, eax
  00369	0f 84 ec 00 00
	00		 je	 $LN24@Cb_gain_av
$LN23@Cb_gain_av:
  0036f	6a 01		 push	 1
  00371	0f b7 45 30	 movzx	 eax, WORD PTR _voicedHangover$[ebp]
  00375	50		 push	 eax
  00376	e8 00 00 00 00	 call	 _sub
  0037b	83 c4 08	 add	 esp, 8
  0037e	0f bf c8	 movsx	 ecx, ax
  00381	85 c9		 test	 ecx, ecx
  00383	0f 8e d2 00 00
	00		 jle	 $LN24@Cb_gain_av
  00389	0f bf 45 2c	 movsx	 eax, WORD PTR _inBackgroundNoise$[ebp]
  0038d	85 c0		 test	 eax, eax
  0038f	0f 84 c6 00 00
	00		 je	 $LN24@Cb_gain_av
  00395	6a 00		 push	 0
  00397	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 _sub
  003a1	83 c4 08	 add	 esp, 8
  003a4	0f bf c8	 movsx	 ecx, ax
  003a7	85 c9		 test	 ecx, ecx
  003a9	74 30		 je	 SHORT $LN21@Cb_gain_av
  003ab	6a 01		 push	 1
  003ad	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 _sub
  003b7	83 c4 08	 add	 esp, 8
  003ba	0f bf c8	 movsx	 ecx, ax
  003bd	85 c9		 test	 ecx, ecx
  003bf	74 1a		 je	 SHORT $LN21@Cb_gain_av
  003c1	6a 02		 push	 2
  003c3	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 _sub
  003cd	83 c4 08	 add	 esp, 8
  003d0	0f bf c8	 movsx	 ecx, ax
  003d3	85 c9		 test	 ecx, ecx
  003d5	0f 85 80 00 00
	00		 jne	 $LN24@Cb_gain_av
$LN21@Cb_gain_av:

; 226  :       {
; 227  :          /* bgMix = min(0.25, max(0.0, diff-0.55)) / 0.25; */
; 228  :          tmp_diff = sub(diff, 4506);   /* 0.55 in Q13 */

  003db	68 9a 11 00 00	 push	 4506			; 0000119aH
  003e0	0f b7 45 dc	 movzx	 eax, WORD PTR _diff$[ebp]
  003e4	50		 push	 eax
  003e5	e8 00 00 00 00	 call	 _sub
  003ea	83 c4 08	 add	 esp, 8
  003ed	66 89 45 d0	 mov	 WORD PTR _tmp_diff$[ebp], ax

; 229  : 
; 230  :          /* max(0.0, diff-0.55) */
; 231  :          test ();

  003f1	e8 00 00 00 00	 call	 _test

; 232  :          if (tmp_diff > 0)

  003f6	0f bf 45 d0	 movsx	 eax, WORD PTR _tmp_diff$[ebp]
  003fa	85 c0		 test	 eax, eax
  003fc	7e 0f		 jle	 SHORT $LN20@Cb_gain_av

; 233  :          {
; 234  :             tmp1 = tmp_diff;       move16 ();

  003fe	66 8b 45 d0	 mov	 ax, WORD PTR _tmp_diff$[ebp]
  00402	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax
  00406	e8 00 00 00 00	 call	 _move16

; 235  :          }
; 236  :          else

  0040b	eb 0b		 jmp	 SHORT $LN19@Cb_gain_av
$LN20@Cb_gain_av:

; 237  :          {
; 238  :             tmp1 = 0;              move16 ();

  0040d	33 c0		 xor	 eax, eax
  0040f	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax
  00413	e8 00 00 00 00	 call	 _move16
$LN19@Cb_gain_av:

; 239  :          }
; 240  : 
; 241  :          /* min(0.25, tmp1) */
; 242  :          test ();

  00418	e8 00 00 00 00	 call	 _test

; 243  :          if (sub(2048, tmp1) < 0)

  0041d	0f b7 45 84	 movzx	 eax, WORD PTR _tmp1$[ebp]
  00421	50		 push	 eax
  00422	68 00 08 00 00	 push	 2048			; 00000800H
  00427	e8 00 00 00 00	 call	 _sub
  0042c	83 c4 08	 add	 esp, 8
  0042f	0f bf c8	 movsx	 ecx, ax
  00432	85 c9		 test	 ecx, ecx
  00434	7d 10		 jge	 SHORT $LN18@Cb_gain_av

; 244  :          {
; 245  :             bgMix = 8192;              move16 ();

  00436	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  0043b	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
  0043f	e8 00 00 00 00	 call	 _move16

; 246  :          }
; 247  :          else

  00444	eb 13		 jmp	 SHORT $LN17@Cb_gain_av
$LN18@Cb_gain_av:

; 248  :          {
; 249  :             bgMix = shl(tmp1, 2);

  00446	6a 02		 push	 2
  00448	0f b7 45 84	 movzx	 eax, WORD PTR _tmp1$[ebp]
  0044c	50		 push	 eax
  0044d	e8 00 00 00 00	 call	 _shl
  00452	83 c4 08	 add	 esp, 8
  00455	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
$LN17@Cb_gain_av:

; 250  :          }
; 251  :       }
; 252  :       else

  00459	eb 7e		 jmp	 SHORT $LN16@Cb_gain_av
$LN24@Cb_gain_av:

; 253  :       {
; 254  :          /* bgMix = min(0.25, max(0.0, diff-0.40)) / 0.25; */        
; 255  :          tmp_diff = sub(diff, 3277); /* 0.4 in Q13 */

  0045b	68 cd 0c 00 00	 push	 3277			; 00000ccdH
  00460	0f b7 45 dc	 movzx	 eax, WORD PTR _diff$[ebp]
  00464	50		 push	 eax
  00465	e8 00 00 00 00	 call	 _sub
  0046a	83 c4 08	 add	 esp, 8
  0046d	66 89 45 d0	 mov	 WORD PTR _tmp_diff$[ebp], ax

; 256  : 
; 257  :          /* max(0.0, diff-0.40) */
; 258  :          test ();

  00471	e8 00 00 00 00	 call	 _test

; 259  :          if (tmp_diff > 0)

  00476	0f bf 45 d0	 movsx	 eax, WORD PTR _tmp_diff$[ebp]
  0047a	85 c0		 test	 eax, eax
  0047c	7e 0f		 jle	 SHORT $LN15@Cb_gain_av

; 260  :          {
; 261  :             tmp1 = tmp_diff;        move16 ();

  0047e	66 8b 45 d0	 mov	 ax, WORD PTR _tmp_diff$[ebp]
  00482	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax
  00486	e8 00 00 00 00	 call	 _move16

; 262  :          }
; 263  :          else

  0048b	eb 0b		 jmp	 SHORT $LN14@Cb_gain_av
$LN15@Cb_gain_av:

; 264  :          {
; 265  :             tmp1 = 0;               move16 ();

  0048d	33 c0		 xor	 eax, eax
  0048f	66 89 45 84	 mov	 WORD PTR _tmp1$[ebp], ax
  00493	e8 00 00 00 00	 call	 _move16
$LN14@Cb_gain_av:

; 266  :          }
; 267  : 
; 268  :          /* min(0.25, tmp1) */
; 269  :          test ();

  00498	e8 00 00 00 00	 call	 _test

; 270  :          if (sub(2048, tmp1) < 0)

  0049d	0f b7 45 84	 movzx	 eax, WORD PTR _tmp1$[ebp]
  004a1	50		 push	 eax
  004a2	68 00 08 00 00	 push	 2048			; 00000800H
  004a7	e8 00 00 00 00	 call	 _sub
  004ac	83 c4 08	 add	 esp, 8
  004af	0f bf c8	 movsx	 ecx, ax
  004b2	85 c9		 test	 ecx, ecx
  004b4	7d 10		 jge	 SHORT $LN13@Cb_gain_av

; 271  :          {
; 272  :             bgMix = 8192;           move16 ();

  004b6	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  004bb	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
  004bf	e8 00 00 00 00	 call	 _move16

; 273  :          }
; 274  :          else

  004c4	eb 13		 jmp	 SHORT $LN16@Cb_gain_av
$LN13@Cb_gain_av:

; 275  :          {
; 276  :             bgMix = shl(tmp1, 2);

  004c6	6a 02		 push	 2
  004c8	0f b7 45 84	 movzx	 eax, WORD PTR _tmp1$[ebp]
  004cc	50		 push	 eax
  004cd	e8 00 00 00 00	 call	 _shl
  004d2	83 c4 08	 add	 esp, 8
  004d5	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
$LN16@Cb_gain_av:

; 277  :          }
; 278  :       }
; 279  : 
; 280  :       test (); test ();

  004d9	e8 00 00 00 00	 call	 _test
  004de	e8 00 00 00 00	 call	 _test

; 281  :       if ((sub(st->hangCount, 40) < 0) || (sub(diff, 5325) > 0)) /* 0.65 in Q13 */

  004e3	6a 28		 push	 40			; 00000028H
  004e5	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  004e8	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  004ec	51		 push	 ecx
  004ed	e8 00 00 00 00	 call	 _sub
  004f2	83 c4 08	 add	 esp, 8
  004f5	0f bf d0	 movsx	 edx, ax
  004f8	85 d2		 test	 edx, edx
  004fa	7c 19		 jl	 SHORT $LN10@Cb_gain_av
  004fc	68 cd 14 00 00	 push	 5325			; 000014cdH
  00501	0f b7 45 dc	 movzx	 eax, WORD PTR _diff$[ebp]
  00505	50		 push	 eax
  00506	e8 00 00 00 00	 call	 _sub
  0050b	83 c4 08	 add	 esp, 8
  0050e	0f bf c8	 movsx	 ecx, ax
  00511	85 c9		 test	 ecx, ecx
  00513	7e 0e		 jle	 SHORT $LN11@Cb_gain_av
$LN10@Cb_gain_av:

; 282  :       {
; 283  :          bgMix = 8192;  /* disable mix if too short time since */ move16 ();

  00515	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  0051a	66 89 45 c4	 mov	 WORD PTR _bgMix$[ebp], ax
  0051e	e8 00 00 00 00	 call	 _move16
$LN11@Cb_gain_av:

; 284  :       }
; 285  : 
; 286  :       /* Smoothen the cb gain trajectory  */
; 287  :       /* smoothing depends on mix constant bgMix */
; 288  :       L_sum = L_mult(6554, st->cbGainHistory[2]);     /* 0.2 in Q15; L_sum in Q17 */   

  00523	b8 02 00 00 00	 mov	 eax, 2
  00528	d1 e0		 shl	 eax, 1
  0052a	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0052d	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00531	52		 push	 edx
  00532	68 9a 19 00 00	 push	 6554			; 0000199aH
  00537	e8 00 00 00 00	 call	 _L_mult
  0053c	83 c4 08	 add	 esp, 8
  0053f	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 289  :       for (i = 3; i < L_CBGAINHIST; i++)

  00542	b8 03 00 00 00	 mov	 eax, 3
  00547	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0054b	eb 0c		 jmp	 SHORT $LN9@Cb_gain_av
$LN8@Cb_gain_av:
  0054d	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00551	66 83 c0 01	 add	 ax, 1
  00555	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN9@Cb_gain_av:
  00559	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0055d	83 f8 07	 cmp	 eax, 7
  00560	7d 22		 jge	 SHORT $LN7@Cb_gain_av

; 290  :       {
; 291  :          L_sum = L_mac(L_sum, 6554, st->cbGainHistory[i]);

  00562	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00566	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00569	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0056d	52		 push	 edx
  0056e	68 9a 19 00 00	 push	 6554			; 0000199aH
  00573	8b 45 ac	 mov	 eax, DWORD PTR _L_sum$[ebp]
  00576	50		 push	 eax
  00577	e8 00 00 00 00	 call	 _L_mac
  0057c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0057f	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 292  :       }

  00582	eb c9		 jmp	 SHORT $LN8@Cb_gain_av
$LN7@Cb_gain_av:

; 293  :       cbGainMean = round(L_sum);                      /* Q1 */

  00584	8b 45 ac	 mov	 eax, DWORD PTR _L_sum$[ebp]
  00587	50		 push	 eax
  00588	e8 00 00 00 00	 call	 _round
  0058d	83 c4 04	 add	 esp, 4
  00590	66 89 45 b8	 mov	 WORD PTR _cbGainMean$[ebp], ax

; 294  :       
; 295  :       /* more smoothing in error and bg noise (NB no DFI used  here) */
; 296  :       test (); test (); test (); test (); test(); test();

  00594	e8 00 00 00 00	 call	 _test
  00599	e8 00 00 00 00	 call	 _test
  0059e	e8 00 00 00 00	 call	 _test
  005a3	e8 00 00 00 00	 call	 _test
  005a8	e8 00 00 00 00	 call	 _test
  005ad	e8 00 00 00 00	 call	 _test

; 297  :       if (((bfi != 0) || (prev_bf != 0)) && (inBackgroundNoise != 0) &&
; 298  :           ((sub(mode, MR475) == 0) ||
; 299  :            (sub(mode, MR515) == 0) ||
; 300  :            (sub(mode, MR59) == 0)) )

  005b2	0f bf 45 1c	 movsx	 eax, WORD PTR _bfi$[ebp]
  005b6	85 c0		 test	 eax, eax
  005b8	75 0c		 jne	 SHORT $LN5@Cb_gain_av
  005ba	0f bf 45 20	 movsx	 eax, WORD PTR _prev_bf$[ebp]
  005be	85 c0		 test	 eax, eax
  005c0	0f 84 c0 00 00
	00		 je	 $LN6@Cb_gain_av
$LN5@Cb_gain_av:
  005c6	0f bf 45 2c	 movsx	 eax, WORD PTR _inBackgroundNoise$[ebp]
  005ca	85 c0		 test	 eax, eax
  005cc	0f 84 b4 00 00
	00		 je	 $LN6@Cb_gain_av
  005d2	6a 00		 push	 0
  005d4	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  005d8	50		 push	 eax
  005d9	e8 00 00 00 00	 call	 _sub
  005de	83 c4 08	 add	 esp, 8
  005e1	0f bf c8	 movsx	 ecx, ax
  005e4	85 c9		 test	 ecx, ecx
  005e6	74 2c		 je	 SHORT $LN4@Cb_gain_av
  005e8	6a 01		 push	 1
  005ea	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  005ee	50		 push	 eax
  005ef	e8 00 00 00 00	 call	 _sub
  005f4	83 c4 08	 add	 esp, 8
  005f7	0f bf c8	 movsx	 ecx, ax
  005fa	85 c9		 test	 ecx, ecx
  005fc	74 16		 je	 SHORT $LN4@Cb_gain_av
  005fe	6a 02		 push	 2
  00600	0f b7 45 0c	 movzx	 eax, WORD PTR _mode$[ebp]
  00604	50		 push	 eax
  00605	e8 00 00 00 00	 call	 _sub
  0060a	83 c4 08	 add	 esp, 8
  0060d	0f bf c8	 movsx	 ecx, ax
  00610	85 c9		 test	 ecx, ecx
  00612	75 72		 jne	 SHORT $LN6@Cb_gain_av
$LN4@Cb_gain_av:

; 301  :       {
; 302  :          L_sum = L_mult(4681, st->cbGainHistory[0]);  /* 0.143 in Q15; L_sum in Q17 */     

  00614	b8 02 00 00 00	 mov	 eax, 2
  00619	6b c8 00	 imul	 ecx, eax, 0
  0061c	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0061f	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00623	50		 push	 eax
  00624	68 49 12 00 00	 push	 4681			; 00001249H
  00629	e8 00 00 00 00	 call	 _L_mult
  0062e	83 c4 08	 add	 esp, 8
  00631	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 303  :          for (i = 1; i < L_CBGAINHIST; i++)

  00634	b8 01 00 00 00	 mov	 eax, 1
  00639	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0063d	eb 0c		 jmp	 SHORT $LN3@Cb_gain_av
$LN2@Cb_gain_av:
  0063f	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00643	66 83 c0 01	 add	 ax, 1
  00647	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@Cb_gain_av:
  0064b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0064f	83 f8 07	 cmp	 eax, 7
  00652	7d 22		 jge	 SHORT $LN1@Cb_gain_av

; 304  :          {
; 305  :             L_sum = L_mac(L_sum, 4681, st->cbGainHistory[i]);

  00654	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00658	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0065b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0065f	52		 push	 edx
  00660	68 49 12 00 00	 push	 4681			; 00001249H
  00665	8b 45 ac	 mov	 eax, DWORD PTR _L_sum$[ebp]
  00668	50		 push	 eax
  00669	e8 00 00 00 00	 call	 _L_mac
  0066e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00671	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 306  :          }

  00674	eb c9		 jmp	 SHORT $LN2@Cb_gain_av
$LN1@Cb_gain_av:

; 307  :          cbGainMean = round(L_sum);                   /* Q1 */

  00676	8b 45 ac	 mov	 eax, DWORD PTR _L_sum$[ebp]
  00679	50		 push	 eax
  0067a	e8 00 00 00 00	 call	 _round
  0067f	83 c4 04	 add	 esp, 4
  00682	66 89 45 b8	 mov	 WORD PTR _cbGainMean$[ebp], ax
$LN6@Cb_gain_av:

; 308  :       }
; 309  :       
; 310  :       /* cbGainMix = bgMix*cbGainMix + (1-bgMix)*cbGainMean; */
; 311  :       L_sum = L_mult(bgMix, cbGainMix);               /* L_sum in Q15 */

  00686	0f b7 45 e8	 movzx	 eax, WORD PTR _cbGainMix$[ebp]
  0068a	50		 push	 eax
  0068b	0f b7 4d c4	 movzx	 ecx, WORD PTR _bgMix$[ebp]
  0068f	51		 push	 ecx
  00690	e8 00 00 00 00	 call	 _L_mult
  00695	83 c4 08	 add	 esp, 8
  00698	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 312  :       L_sum = L_mac(L_sum, 8192, cbGainMean);         

  0069b	0f b7 45 b8	 movzx	 eax, WORD PTR _cbGainMean$[ebp]
  0069f	50		 push	 eax
  006a0	68 00 20 00 00	 push	 8192			; 00002000H
  006a5	8b 4d ac	 mov	 ecx, DWORD PTR _L_sum$[ebp]
  006a8	51		 push	 ecx
  006a9	e8 00 00 00 00	 call	 _L_mac
  006ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  006b1	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 313  :       L_sum = L_msu(L_sum, bgMix, cbGainMean);

  006b4	0f b7 45 b8	 movzx	 eax, WORD PTR _cbGainMean$[ebp]
  006b8	50		 push	 eax
  006b9	0f b7 4d c4	 movzx	 ecx, WORD PTR _bgMix$[ebp]
  006bd	51		 push	 ecx
  006be	8b 55 ac	 mov	 edx, DWORD PTR _L_sum$[ebp]
  006c1	52		 push	 edx
  006c2	e8 00 00 00 00	 call	 _L_msu
  006c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  006ca	89 45 ac	 mov	 DWORD PTR _L_sum$[ebp], eax

; 314  :       cbGainMix = round(L_shl(L_sum, 2));             /* Q1 */

  006cd	6a 02		 push	 2
  006cf	8b 45 ac	 mov	 eax, DWORD PTR _L_sum$[ebp]
  006d2	50		 push	 eax
  006d3	e8 00 00 00 00	 call	 _L_shl
  006d8	83 c4 08	 add	 esp, 8
  006db	50		 push	 eax
  006dc	e8 00 00 00 00	 call	 _round
  006e1	83 c4 04	 add	 esp, 4
  006e4	66 89 45 e8	 mov	 WORD PTR _cbGainMix$[ebp], ax
$LN26@Cb_gain_av:

; 315  :    }
; 316  :    
; 317  :    st->hangCount = add(st->hangCount, 1);

  006e8	6a 01		 push	 1
  006ea	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  006ed	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  006f1	51		 push	 ecx
  006f2	e8 00 00 00 00	 call	 _add
  006f7	83 c4 08	 add	 esp, 8
  006fa	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  006fd	66 89 42 10	 mov	 WORD PTR [edx+16], ax

; 318  :    return cbGainMix;

  00701	66 8b 45 e8	 mov	 ax, WORD PTR _cbGainMix$[ebp]

; 319  : }

  00705	52		 push	 edx
  00706	8b cd		 mov	 ecx, ebp
  00708	50		 push	 eax
  00709	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN45@Cb_gain_av
  0070f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00714	58		 pop	 eax
  00715	5a		 pop	 edx
  00716	5f		 pop	 edi
  00717	5e		 pop	 esi
  00718	5b		 pop	 ebx
  00719	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0071c	33 cd		 xor	 ecx, ebp
  0071e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00723	81 c4 70 01 00
	00		 add	 esp, 368		; 00000170H
  00729	3b ec		 cmp	 ebp, esp
  0072b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00730	8b e5		 mov	 esp, ebp
  00732	5d		 pop	 ebp
  00733	c3		 ret	 0
$LN45@Cb_gain_av:
  00734	01 00 00 00	 DD	 1
  00738	00 00 00 00	 DD	 $LN44@Cb_gain_av
$LN44@Cb_gain_av:
  0073c	90 ff ff ff	 DD	 -112			; ffffff90H
  00740	14 00 00 00	 DD	 20			; 00000014H
  00744	00 00 00 00	 DD	 $LN43@Cb_gain_av
$LN43@Cb_gain_av:
  00748	74		 DB	 116			; 00000074H
  00749	6d		 DB	 109			; 0000006dH
  0074a	70		 DB	 112			; 00000070H
  0074b	00		 DB	 0
_Cb_gain_average ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Cb_gain_average_exit PROC				; COMDAT

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 114  :    if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@Cb_gain_av
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@Cb_gain_av
$LN1@Cb_gain_av:

; 115  :       return;

  0002c	eb 21		 jmp	 SHORT $LN3@Cb_gain_av
$LN2@Cb_gain_av:

; 116  : 
; 117  :    /* deallocate memory */
; 118  :    free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 119  :    *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Cb_gain_av:

; 120  :    
; 121  :    return;
; 122  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_Cb_gain_average_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_Cb_gain_average_reset PROC				; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 89   :    if (state == (Cb_gain_averageState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@Cb_gain_av

; 90   :       fprintf(stderr, "Cb_gain_average_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 91   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 22		 jmp	 SHORT $LN2@Cb_gain_av
$LN1@Cb_gain_av:

; 92   :    }
; 93   : 
; 94   :    /* Static vectors to zero */
; 95   :    Set_zero (state->cbGainHistory, L_CBGAINHIST);

  00059	6a 07		 push	 7
  0005b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _Set_zero
  00064	83 c4 08	 add	 esp, 8

; 96   : 
; 97   :    /* Initialize hangover handling */
; 98   :    state->hangVar = 0;

  00067	33 c0		 xor	 eax, eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 99   :    state->hangCount= 0;

  00070	33 c0		 xor	 eax, eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00075	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 100  :    
; 101  :    return 0;

  00079	33 c0		 xor	 eax, eax
$LN2@Cb_gain_av:

; 102  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_Cb_gain_average_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_Cb_gain_average_init PROC				; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 59   :    Cb_gain_averageState* s;
; 60   :    
; 61   :    if (state == (Cb_gain_averageState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@Cb_gain_av

; 62   :       fprintf(stderr, "Cb_gain_average_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 63   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@Cb_gain_av
$LN2@Cb_gain_av:

; 64   :    }
; 65   :    *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 66   :    
; 67   :    /* allocate memory */
; 68   :    if ((s= (Cb_gain_averageState *) malloc(sizeof(Cb_gain_averageState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 12		 push	 18			; 00000012H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@Cb_gain_av

; 69   :      fprintf(stderr, "Cb_gain_average_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   :      return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@Cb_gain_av
$LN1@Cb_gain_av:

; 71   :    }
; 72   :    
; 73   :    Cb_gain_average_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _Cb_gain_average_reset
  000bd	83 c4 04	 add	 esp, 4

; 74   :    *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 75   :    
; 76   :    return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@Cb_gain_av:

; 77   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_Cb_gain_average_init ENDP
_TEXT	ENDS
END
