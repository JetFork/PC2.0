; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\a_refl.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_a_refl_id
CONST	SEGMENT
_a_refl_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_A_Refl
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_shl:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_sub:PROC
EXTRN	_L_shl:PROC
EXTRN	_L_deposit_h:PROC
EXTRN	_L_shr_r:PROC
EXTRN	_L_abs:PROC
EXTRN	_div_s:PROC
EXTRN	_norm_l:PROC
EXTRN	_move16:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
;	COMDAT _A_Refl
_TEXT	SEGMENT
_mult$ = -164						; size = 2
_temp$ = -152						; size = 2
_L_temp$ = -140						; size = 4
_scale$ = -128						; size = 2
_L_acc$ = -116						; size = 4
_normProd$ = -104					; size = 2
_normShift$ = -92					; size = 2
_bState$ = -80						; size = 20
_aState$ = -52						; size = 20
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_refl$ = 12						; size = 4
_A_Refl	PROC						; COMDAT

; 58   : {				       

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00012	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 59   :    /* local variables */
; 60   :    Word16 i,j;
; 61   :    Word16 aState[M];
; 62   :    Word16 bState[M];
; 63   :    Word16 normShift;
; 64   :    Word16 normProd;
; 65   :    Word32 L_acc;
; 66   :    Word16 scale;
; 67   :    Word32 L_temp;
; 68   :    Word16 temp;
; 69   :    Word16 mult;
; 70   : 
; 71   :    /* initialize states */
; 72   :    for (i = 0; i < M; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN17@A_Refl
$LN16@A_Refl:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN17@A_Refl:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00043	7d 1b		 jge	 SHORT $LN15@A_Refl

; 73   :    {
; 74   :       aState[i] = a[i];                         move16 ();

  00045	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00049	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00050	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  00054	66 89 44 4d cc	 mov	 WORD PTR _aState$[ebp+ecx*2], ax
  00059	e8 00 00 00 00	 call	 _move16

; 75   :    }

  0005e	eb d0		 jmp	 SHORT $LN16@A_Refl
$LN15@A_Refl:

; 76   :    
; 77   :    /* backward Levinson recursion */
; 78   :    for (i = M-1; i >= 0; i--)

  00060	b8 09 00 00 00	 mov	 eax, 9
  00065	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  00069	eb 0c		 jmp	 SHORT $LN14@A_Refl
$LN13@A_Refl:
  0006b	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  0006f	66 83 e8 01	 sub	 ax, 1
  00073	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN14@A_Refl:
  00077	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0007b	85 c0		 test	 eax, eax
  0007d	0f 8c 16 02 00
	00		 jl	 $LN12@A_Refl

; 79   :    {
; 80   :       if (sub(abs_s(aState[i]), 4096) >= 0)

  00083	68 00 10 00 00	 push	 4096			; 00001000H
  00088	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0008c	0f b7 4c 45 cc	 movzx	 ecx, WORD PTR _aState$[ebp+eax*2]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _abs_s
  00097	83 c4 04	 add	 esp, 4
  0009a	0f b7 d0	 movzx	 edx, ax
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _sub
  000a3	83 c4 08	 add	 esp, 8
  000a6	98		 cwde
  000a7	85 c0		 test	 eax, eax
  000a9	7c 05		 jl	 SHORT $LN11@A_Refl

; 81   :       {
; 82   :          goto ExitRefl;

  000ab	e9 eb 01 00 00	 jmp	 $ExitRefl$24
$LN11@A_Refl:

; 83   :       }
; 84   :       
; 85   :       refl[i] = shl(aState[i], 3);

  000b0	6a 03		 push	 3
  000b2	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000b6	0f b7 4c 45 cc	 movzx	 ecx, WORD PTR _aState$[ebp+eax*2]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _shl
  000c1	83 c4 08	 add	 esp, 8
  000c4	0f bf 55 f4	 movsx	 edx, WORD PTR _i$[ebp]
  000c8	8b 4d 0c	 mov	 ecx, DWORD PTR _refl$[ebp]
  000cb	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 86   : 
; 87   :       L_temp = L_mult(refl[i], refl[i]);

  000cf	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000d3	8b 4d 0c	 mov	 ecx, DWORD PTR _refl$[ebp]
  000d6	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000da	52		 push	 edx
  000db	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _refl$[ebp]
  000e2	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 _L_mult
  000ec	83 c4 08	 add	 esp, 8
  000ef	89 85 74 ff ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 88   :       L_acc = L_sub(MAX_32, L_temp);

  000f5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  000fb	50		 push	 eax
  000fc	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00101	e8 00 00 00 00	 call	 _L_sub
  00106	83 c4 08	 add	 esp, 8
  00109	89 45 8c	 mov	 DWORD PTR _L_acc$[ebp], eax

; 89   :       
; 90   :       normShift = norm_l(L_acc);

  0010c	8b 45 8c	 mov	 eax, DWORD PTR _L_acc$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _norm_l
  00115	83 c4 04	 add	 esp, 4
  00118	66 89 45 a4	 mov	 WORD PTR _normShift$[ebp], ax

; 91   :       scale = sub(15, normShift);

  0011c	0f b7 45 a4	 movzx	 eax, WORD PTR _normShift$[ebp]
  00120	50		 push	 eax
  00121	6a 0f		 push	 15			; 0000000fH
  00123	e8 00 00 00 00	 call	 _sub
  00128	83 c4 08	 add	 esp, 8
  0012b	66 89 45 80	 mov	 WORD PTR _scale$[ebp], ax

; 92   :       
; 93   :       L_acc = L_shl(L_acc, normShift);

  0012f	0f b7 45 a4	 movzx	 eax, WORD PTR _normShift$[ebp]
  00133	50		 push	 eax
  00134	8b 4d 8c	 mov	 ecx, DWORD PTR _L_acc$[ebp]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _L_shl
  0013d	83 c4 08	 add	 esp, 8
  00140	89 45 8c	 mov	 DWORD PTR _L_acc$[ebp], eax

; 94   :       normProd = round(L_acc);

  00143	8b 45 8c	 mov	 eax, DWORD PTR _L_acc$[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 _round
  0014c	83 c4 04	 add	 esp, 4
  0014f	66 89 45 98	 mov	 WORD PTR _normProd$[ebp], ax

; 95   : 
; 96   :       mult = div_s(16384, normProd);

  00153	0f b7 45 98	 movzx	 eax, WORD PTR _normProd$[ebp]
  00157	50		 push	 eax
  00158	68 00 40 00 00	 push	 16384			; 00004000H
  0015d	e8 00 00 00 00	 call	 _div_s
  00162	83 c4 08	 add	 esp, 8
  00165	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _mult$[ebp], ax

; 97   :       
; 98   :       for (j = 0; j < i; j++)

  0016c	33 c0		 xor	 eax, eax
  0016e	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00172	eb 0c		 jmp	 SHORT $LN10@A_Refl
$LN9@A_Refl:
  00174	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00178	66 83 c0 01	 add	 ax, 1
  0017c	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN10@A_Refl:
  00180	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00184	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00188	3b c1		 cmp	 eax, ecx
  0018a	0f 8d cb 00 00
	00		 jge	 $LN8@A_Refl

; 99   :       {
; 100  :          L_acc = L_deposit_h(aState[j]);

  00190	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00194	0f b7 4c 45 cc	 movzx	 ecx, WORD PTR _aState$[ebp+eax*2]
  00199	51		 push	 ecx
  0019a	e8 00 00 00 00	 call	 _L_deposit_h
  0019f	83 c4 04	 add	 esp, 4
  001a2	89 45 8c	 mov	 DWORD PTR _L_acc$[ebp], eax

; 101  :          L_acc = L_msu(L_acc, refl[i], aState[i-j-1]);

  001a5	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001a9	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  001ad	2b c1		 sub	 eax, ecx
  001af	0f b7 54 45 ca	 movzx	 edx, WORD PTR _aState$[ebp+eax*2-2]
  001b4	52		 push	 edx
  001b5	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  001b9	8b 4d 0c	 mov	 ecx, DWORD PTR _refl$[ebp]
  001bc	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001c0	52		 push	 edx
  001c1	8b 45 8c	 mov	 eax, DWORD PTR _L_acc$[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _L_msu
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cd	89 45 8c	 mov	 DWORD PTR _L_acc$[ebp], eax

; 102  :          
; 103  :          temp = round(L_acc);

  001d0	8b 45 8c	 mov	 eax, DWORD PTR _L_acc$[ebp]
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 _round
  001d9	83 c4 04	 add	 esp, 4
  001dc	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _temp$[ebp], ax

; 104  :          L_temp = L_mult(mult, temp);

  001e3	0f b7 85 68 ff
	ff ff		 movzx	 eax, WORD PTR _temp$[ebp]
  001ea	50		 push	 eax
  001eb	0f b7 8d 5c ff
	ff ff		 movzx	 ecx, WORD PTR _mult$[ebp]
  001f2	51		 push	 ecx
  001f3	e8 00 00 00 00	 call	 _L_mult
  001f8	83 c4 08	 add	 esp, 8
  001fb	89 85 74 ff ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 105  :          L_temp = L_shr_r(L_temp, scale);

  00201	0f b7 45 80	 movzx	 eax, WORD PTR _scale$[ebp]
  00205	50		 push	 eax
  00206	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _L_temp$[ebp]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 _L_shr_r
  00212	83 c4 08	 add	 esp, 8
  00215	89 85 74 ff ff
	ff		 mov	 DWORD PTR _L_temp$[ebp], eax

; 106  :          
; 107  :          if (L_sub(L_abs(L_temp), 32767) > 0)

  0021b	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00220	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 _L_abs
  0022c	83 c4 04	 add	 esp, 4
  0022f	50		 push	 eax
  00230	e8 00 00 00 00	 call	 _L_sub
  00235	83 c4 08	 add	 esp, 8
  00238	85 c0		 test	 eax, eax
  0023a	7e 02		 jle	 SHORT $LN7@A_Refl

; 108  :          {
; 109  :             goto ExitRefl;

  0023c	eb 5d		 jmp	 SHORT $ExitRefl$24
$LN7@A_Refl:

; 110  :          }
; 111  :          
; 112  :          bState[j] = extract_l(L_temp);

  0023e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _L_temp$[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _extract_l
  0024a	83 c4 04	 add	 esp, 4
  0024d	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00251	66 89 44 4d b0	 mov	 WORD PTR _bState$[ebp+ecx*2], ax

; 113  :       }

  00256	e9 19 ff ff ff	 jmp	 $LN9@A_Refl
$LN8@A_Refl:

; 114  :       
; 115  :       for (j = 0; j < i; j++)

  0025b	33 c0		 xor	 eax, eax
  0025d	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
  00261	eb 0c		 jmp	 SHORT $LN6@A_Refl
$LN5@A_Refl:
  00263	66 8b 45 e8	 mov	 ax, WORD PTR _j$[ebp]
  00267	66 83 c0 01	 add	 ax, 1
  0026b	66 89 45 e8	 mov	 WORD PTR _j$[ebp], ax
$LN6@A_Refl:
  0026f	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00273	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  00277	3b c1		 cmp	 eax, ecx
  00279	7d 19		 jge	 SHORT $LN4@A_Refl

; 116  :       {
; 117  :          aState[j] = bState[j];              move16 ();

  0027b	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  0027f	0f bf 4d e8	 movsx	 ecx, WORD PTR _j$[ebp]
  00283	66 8b 54 45 b0	 mov	 dx, WORD PTR _bState$[ebp+eax*2]
  00288	66 89 54 4d cc	 mov	 WORD PTR _aState$[ebp+ecx*2], dx
  0028d	e8 00 00 00 00	 call	 _move16

; 118  :       }

  00292	eb cf		 jmp	 SHORT $LN5@A_Refl
$LN4@A_Refl:

; 119  :    }

  00294	e9 d2 fd ff ff	 jmp	 $LN13@A_Refl
$LN12@A_Refl:

; 120  :    return;

  00299	eb 31		 jmp	 SHORT $LN18@A_Refl
$ExitRefl$24:

; 121  : 
; 122  : ExitRefl:
; 123  :    for (i = 0; i < M; i++)

  0029b	33 c0		 xor	 eax, eax
  0029d	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  002a1	eb 0c		 jmp	 SHORT $LN3@A_Refl
$LN2@A_Refl:
  002a3	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  002a7	66 83 c0 01	 add	 ax, 1
  002ab	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@A_Refl:
  002af	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  002b3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002b6	7d 14		 jge	 SHORT $LN18@A_Refl

; 124  :    {
; 125  :       refl[i] = 0;                           move16 ();

  002b8	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  002bc	33 c9		 xor	 ecx, ecx
  002be	8b 55 0c	 mov	 edx, DWORD PTR _refl$[ebp]
  002c1	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  002c5	e8 00 00 00 00	 call	 _move16

; 126  :    }

  002ca	eb d7		 jmp	 SHORT $LN2@A_Refl
$LN18@A_Refl:

; 127  : }

  002cc	52		 push	 edx
  002cd	8b cd		 mov	 ecx, ebp
  002cf	50		 push	 eax
  002d0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@A_Refl
  002d6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002db	58		 pop	 eax
  002dc	5a		 pop	 edx
  002dd	5f		 pop	 edi
  002de	5e		 pop	 esi
  002df	5b		 pop	 ebx
  002e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e3	33 cd		 xor	 ecx, ebp
  002e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ea	81 c4 68 01 00
	00		 add	 esp, 360		; 00000168H
  002f0	3b ec		 cmp	 ebp, esp
  002f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c3		 ret	 0
  002fb	90		 npad	 1
$LN23@A_Refl:
  002fc	02 00 00 00	 DD	 2
  00300	00 00 00 00	 DD	 $LN22@A_Refl
$LN22@A_Refl:
  00304	cc ff ff ff	 DD	 -52			; ffffffccH
  00308	14 00 00 00	 DD	 20			; 00000014H
  0030c	00 00 00 00	 DD	 $LN20@A_Refl
  00310	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00314	14 00 00 00	 DD	 20			; 00000014H
  00318	00 00 00 00	 DD	 $LN21@A_Refl
$LN21@A_Refl:
  0031c	62		 DB	 98			; 00000062H
  0031d	53		 DB	 83			; 00000053H
  0031e	74		 DB	 116			; 00000074H
  0031f	61		 DB	 97			; 00000061H
  00320	74		 DB	 116			; 00000074H
  00321	65		 DB	 101			; 00000065H
  00322	00		 DB	 0
$LN20@A_Refl:
  00323	61		 DB	 97			; 00000061H
  00324	53		 DB	 83			; 00000053H
  00325	74		 DB	 116			; 00000074H
  00326	61		 DB	 97			; 00000061H
  00327	74		 DB	 116			; 00000074H
  00328	65		 DB	 101			; 00000065H
  00329	00		 DB	 0
_A_Refl	ENDP
_TEXT	ENDS
END
