; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\q_gain_c.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_q_gain_c_id
CONST	SEGMENT
_q_gain_c_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_qua_gain_pitch DW 00H
	DW	0ccdH
	DW	0199cH
	DW	02000H
	DW	02666H
	DW	02ccdH
	DW	03000H
	DW	03333H
	DW	03666H
	DW	0399aH
	DW	03ccdH
	DW	04000H
	DW	04333H
	DW	04666H
	DW	0499aH
	DW	04ccdH
_qua_gain_code DW 09fH
	DW	0f140H
	DW	0a735H
	DW	0ceH
	DW	0f2beH
	DW	0b034H
	DW	010cH
	DW	0f443H
	DW	0b958H
	DW	015dH
	DW	0f5c9H
	DW	0c285H
	DW	01a3H
	DW	0f6d7H
	DW	0c8dfH
	DW	01e2H
	DW	0f7a6H
	DW	0cdbdH
	DW	022aH
	DW	0f874H
	DW	0d293H
	DW	027dH
	DW	0f942H
	DW	0d76dH
	DW	02ddH
	DW	0fa12H
	DW	0dc4dH
	DW	034aH
	DW	0fadeH
	DW	0e11eH
	DW	03c9H
	DW	0fbaeH
	DW	0e600H
	DW	045aH
	DW	0fc7cH
	DW	0ead8H
	DW	0501H
	DW	0fd4aH
	DW	0efb3H
	DW	05c1H
	DW	0fe19H
	DW	0f48dH
	DW	069eH
	DW	0fee7H
	DW	0f968H
	DW	079cH
	DW	0ffb5H
	DW	0fe43H
	DW	08c1H
	DW	085H
	DW	0321H
	DW	0a11H
	DW	0153H
	DW	07fcH
	DW	0b93H
	DW	0221H
	DW	0cd5H
	DW	0d50H
	DW	02f0H
	DW	011b2H
	DW	0f4fH
	DW	03beH
	DW	0168cH
	DW	0119bH
	DW	048dH
	DW	01b68H
	DW	0143fH
	DW	055bH
	DW	02043H
	DW	01748H
	DW	0629H
	DW	0251dH
	DW	01ac7H
	DW	06f8H
	DW	029f9H
	DW	01ecbH
	DW	07c7H
	DW	02ed4H
	DW	02369H
	DW	0895H
	DW	033afH
	DW	028b9H
	DW	0964H
	DW	0388aH
	DW	030deH
	DW	0a71H
	DW	03ee0H
	DW	03f87H
	DW	0bf4H
	DW	047fdH
	DW	05296H
	DW	0d78H
	DW	0511bH
	DW	06b5dH
	DW	0efcH
	DW	05a39H
CONST	ENDS
PUBLIC	_q_gain_code
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_abs_s:PROC
EXTRN	_shl:PROC
EXTRN	_shr:PROC
EXTRN	_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Pow2:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\q_gain_c.c
;	COMDAT _q_gain_code
_TEXT	SEGMENT
tv206 = -278						; size = 2
tv200 = -278						; size = 2
tv170 = -278						; size = 2
tv160 = -278						; size = 2
tv141 = -278						; size = 2
tv131 = -278						; size = 2
_g_q0$ = -80						; size = 2
_err_min$ = -68						; size = 2
_err$ = -56						; size = 2
_gcode0$ = -44						; size = 2
_index$ = -32						; size = 2
_i$ = -20						; size = 2
_p$ = -8						; size = 4
_mode$ = 8						; size = 4
_exp_gcode0$ = 12					; size = 2
_frac_gcode0$ = 16					; size = 2
_gain$ = 20						; size = 4
_qua_ener_MR122$ = 24					; size = 4
_qua_ener$ = 28						; size = 4
_q_gain_code PROC					; COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 71   :     const Word16 *p;
; 72   :     Word16 i, index;
; 73   :     Word16 gcode0, err, err_min;
; 74   :     Word16 g_q0;
; 75   : 
; 76   :     test ();

  0001e	e8 00 00 00 00	 call	 _test

; 77   :     g_q0 = 0;    move16 ();

  00023	33 c0		 xor	 eax, eax
  00025	66 89 45 b0	 mov	 WORD PTR _g_q0$[ebp], ax
  00029	e8 00 00 00 00	 call	 _move16

; 78   :     test ();

  0002e	e8 00 00 00 00	 call	 _test

; 79   :     if (sub(mode, MR122) == 0)

  00033	6a 07		 push	 7
  00035	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sub
  0003f	83 c4 08	 add	 esp, 8
  00042	0f bf c8	 movsx	 ecx, ax
  00045	85 c9		 test	 ecx, ecx
  00047	75 15		 jne	 SHORT $LN13@q_gain_cod

; 80   :     {
; 81   :        g_q0 = shr (*gain, 1); /* Q1 -> Q0 */

  00049	6a 01		 push	 1
  0004b	8b 45 14	 mov	 eax, DWORD PTR _gain$[ebp]
  0004e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _shr
  00057	83 c4 08	 add	 esp, 8
  0005a	66 89 45 b0	 mov	 WORD PTR _g_q0$[ebp], ax
$LN13@q_gain_cod:

; 82   :     }
; 83   : 
; 84   :     /*-------------------------------------------------------------------*
; 85   :      *  predicted codebook gain                                          *
; 86   :      *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
; 87   :      *  gc0     = Pow2(int(d)+frac(d))                                   *
; 88   :      *          = 2^exp + 2^frac                                         *
; 89   :      *                                                                   *
; 90   :      *-------------------------------------------------------------------*/
; 91   : 
; 92   :     gcode0 = extract_l (Pow2 (exp_gcode0, frac_gcode0));  /* predicted gain */

  0005e	0f b7 45 10	 movzx	 eax, WORD PTR _frac_gcode0$[ebp]
  00062	50		 push	 eax
  00063	0f b7 4d 0c	 movzx	 ecx, WORD PTR _exp_gcode0$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _Pow2
  0006d	83 c4 08	 add	 esp, 8
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _extract_l
  00076	83 c4 04	 add	 esp, 4
  00079	66 89 45 d4	 mov	 WORD PTR _gcode0$[ebp], ax

; 93   : 
; 94   :     test ();

  0007d	e8 00 00 00 00	 call	 _test

; 95   :     if (sub(mode, MR122) == 0)

  00082	6a 07		 push	 7
  00084	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _sub
  0008e	83 c4 08	 add	 esp, 8
  00091	0f bf c8	 movsx	 ecx, ax
  00094	85 c9		 test	 ecx, ecx
  00096	75 15		 jne	 SHORT $LN12@q_gain_cod

; 96   :     {
; 97   :        gcode0 = shl (gcode0, 4);

  00098	6a 04		 push	 4
  0009a	0f b7 45 d4	 movzx	 eax, WORD PTR _gcode0$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _shl
  000a4	83 c4 08	 add	 esp, 8
  000a7	66 89 45 d4	 mov	 WORD PTR _gcode0$[ebp], ax

; 98   :     }
; 99   :     else

  000ab	eb 13		 jmp	 SHORT $LN11@q_gain_cod
$LN12@q_gain_cod:

; 100  :     {
; 101  :        gcode0 = shl (gcode0, 5);

  000ad	6a 05		 push	 5
  000af	0f b7 45 d4	 movzx	 eax, WORD PTR _gcode0$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _shl
  000b9	83 c4 08	 add	 esp, 8
  000bc	66 89 45 d4	 mov	 WORD PTR _gcode0$[ebp], ax
$LN11@q_gain_cod:

; 102  :     }
; 103  :     
; 104  :     /*-------------------------------------------------------------------*
; 105  :      *                   Search for best quantizer                        *
; 106  :      *-------------------------------------------------------------------*/
; 107  : 
; 108  :     p = &qua_gain_code[0]; move16 ();

  000c0	b8 02 00 00 00	 mov	 eax, 2
  000c5	6b c8 00	 imul	 ecx, eax, 0
  000c8	81 c1 00 00 00
	00		 add	 ecx, OFFSET _qua_gain_code
  000ce	89 4d f8	 mov	 DWORD PTR _p$[ebp], ecx
  000d1	e8 00 00 00 00	 call	 _move16

; 109  :     test ();

  000d6	e8 00 00 00 00	 call	 _test

; 110  :     if (sub(mode, MR122) == 0)

  000db	6a 07		 push	 7
  000dd	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 _sub
  000e7	83 c4 08	 add	 esp, 8
  000ea	0f bf c8	 movsx	 ecx, ax
  000ed	85 c9		 test	 ecx, ecx
  000ef	75 4e		 jne	 SHORT $LN10@q_gain_cod

; 111  :     {
; 112  :        err_min = abs_s (sub (g_q0, mult (gcode0, *p++)));

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000f4	66 8b 08	 mov	 cx, WORD PTR [eax]
  000f7	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv131[ebp], cx
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  00101	83 c2 02	 add	 edx, 2
  00104	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  00107	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv131[ebp]
  0010e	50		 push	 eax
  0010f	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 _mult
  00119	83 c4 08	 add	 esp, 8
  0011c	0f b7 d0	 movzx	 edx, ax
  0011f	52		 push	 edx
  00120	0f b7 45 b0	 movzx	 eax, WORD PTR _g_q0$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _sub
  0012a	83 c4 08	 add	 esp, 8
  0012d	0f b7 c8	 movzx	 ecx, ax
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 _abs_s
  00136	83 c4 04	 add	 esp, 4
  00139	66 89 45 bc	 mov	 WORD PTR _err_min$[ebp], ax

; 113  :     }
; 114  :     else

  0013d	eb 4e		 jmp	 SHORT $LN9@q_gain_cod
$LN10@q_gain_cod:

; 115  :     {
; 116  :        err_min = abs_s (sub (*gain, mult (gcode0, *p++)));

  0013f	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00142	66 8b 08	 mov	 cx, WORD PTR [eax]
  00145	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv141[ebp], cx
  0014c	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  0014f	83 c2 02	 add	 edx, 2
  00152	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  00155	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv141[ebp]
  0015c	50		 push	 eax
  0015d	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _mult
  00167	83 c4 08	 add	 esp, 8
  0016a	0f b7 d0	 movzx	 edx, ax
  0016d	52		 push	 edx
  0016e	8b 45 14	 mov	 eax, DWORD PTR _gain$[ebp]
  00171	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _sub
  0017a	83 c4 08	 add	 esp, 8
  0017d	0f b7 d0	 movzx	 edx, ax
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 _abs_s
  00186	83 c4 04	 add	 esp, 4
  00189	66 89 45 bc	 mov	 WORD PTR _err_min$[ebp], ax
$LN9@q_gain_cod:

; 117  :     }
; 118  :     p += 2;                                  /* skip quantized energy errors */

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 119  :     index = 0;              move16 (); 

  00196	33 c0		 xor	 eax, eax
  00198	66 89 45 e0	 mov	 WORD PTR _index$[ebp], ax
  0019c	e8 00 00 00 00	 call	 _move16

; 120  : 
; 121  :     for (i = 1; i < NB_QUA_CODE; i++)

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
  001aa	eb 0c		 jmp	 SHORT $LN8@q_gain_cod
$LN7@q_gain_cod:
  001ac	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  001b0	66 83 c0 01	 add	 ax, 1
  001b4	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax
$LN8@q_gain_cod:
  001b8	0f bf 45 ec	 movsx	 eax, WORD PTR _i$[ebp]
  001bc	83 f8 20	 cmp	 eax, 32			; 00000020H
  001bf	0f 8d fd 00 00
	00		 jge	 $LN6@q_gain_cod

; 122  :     {
; 123  :        test ();

  001c5	e8 00 00 00 00	 call	 _test

; 124  :        if (sub(mode, MR122) == 0)

  001ca	6a 07		 push	 7
  001cc	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 _sub
  001d6	83 c4 08	 add	 esp, 8
  001d9	0f bf c8	 movsx	 ecx, ax
  001dc	85 c9		 test	 ecx, ecx
  001de	75 4e		 jne	 SHORT $LN5@q_gain_cod

; 125  :        {
; 126  :           err = abs_s (sub (g_q0,  mult (gcode0, *p++)));

  001e0	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  001e3	66 8b 08	 mov	 cx, WORD PTR [eax]
  001e6	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv160[ebp], cx
  001ed	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  001f0	83 c2 02	 add	 edx, 2
  001f3	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  001f6	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv160[ebp]
  001fd	50		 push	 eax
  001fe	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _mult
  00208	83 c4 08	 add	 esp, 8
  0020b	0f b7 d0	 movzx	 edx, ax
  0020e	52		 push	 edx
  0020f	0f b7 45 b0	 movzx	 eax, WORD PTR _g_q0$[ebp]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _sub
  00219	83 c4 08	 add	 esp, 8
  0021c	0f b7 c8	 movzx	 ecx, ax
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 _abs_s
  00225	83 c4 04	 add	 esp, 4
  00228	66 89 45 c8	 mov	 WORD PTR _err$[ebp], ax

; 127  :        }
; 128  :        else

  0022c	eb 4e		 jmp	 SHORT $LN4@q_gain_cod
$LN5@q_gain_cod:

; 129  :        {
; 130  :           err = abs_s (sub (*gain, mult (gcode0, *p++)));

  0022e	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00231	66 8b 08	 mov	 cx, WORD PTR [eax]
  00234	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv170[ebp], cx
  0023b	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  0023e	83 c2 02	 add	 edx, 2
  00241	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  00244	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv170[ebp]
  0024b	50		 push	 eax
  0024c	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00250	51		 push	 ecx
  00251	e8 00 00 00 00	 call	 _mult
  00256	83 c4 08	 add	 esp, 8
  00259	0f b7 d0	 movzx	 edx, ax
  0025c	52		 push	 edx
  0025d	8b 45 14	 mov	 eax, DWORD PTR _gain$[ebp]
  00260	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 _sub
  00269	83 c4 08	 add	 esp, 8
  0026c	0f b7 d0	 movzx	 edx, ax
  0026f	52		 push	 edx
  00270	e8 00 00 00 00	 call	 _abs_s
  00275	83 c4 04	 add	 esp, 4
  00278	66 89 45 c8	 mov	 WORD PTR _err$[ebp], ax
$LN4@q_gain_cod:

; 131  :        }
; 132  :        
; 133  :        p += 2;                              /* skip quantized energy error */

  0027c	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0027f	83 c0 04	 add	 eax, 4
  00282	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 134  : 
; 135  :        test (); 

  00285	e8 00 00 00 00	 call	 _test

; 136  :        if (sub (err, err_min) < 0)

  0028a	0f b7 45 bc	 movzx	 eax, WORD PTR _err_min$[ebp]
  0028e	50		 push	 eax
  0028f	0f b7 4d c8	 movzx	 ecx, WORD PTR _err$[ebp]
  00293	51		 push	 ecx
  00294	e8 00 00 00 00	 call	 _sub
  00299	83 c4 08	 add	 esp, 8
  0029c	0f bf d0	 movsx	 edx, ax
  0029f	85 d2		 test	 edx, edx
  002a1	7d 1a		 jge	 SHORT $LN3@q_gain_cod

; 137  :        {
; 138  :           err_min = err;                  move16 (); 

  002a3	66 8b 45 c8	 mov	 ax, WORD PTR _err$[ebp]
  002a7	66 89 45 bc	 mov	 WORD PTR _err_min$[ebp], ax
  002ab	e8 00 00 00 00	 call	 _move16

; 139  :           index = i;                      move16 (); 

  002b0	66 8b 45 ec	 mov	 ax, WORD PTR _i$[ebp]
  002b4	66 89 45 e0	 mov	 WORD PTR _index$[ebp], ax
  002b8	e8 00 00 00 00	 call	 _move16
$LN3@q_gain_cod:

; 140  :        }
; 141  :     }

  002bd	e9 ea fe ff ff	 jmp	 $LN7@q_gain_cod
$LN6@q_gain_cod:

; 142  : 
; 143  :     p = &qua_gain_code[add (add (index,index), index)]; move16 ();

  002c2	0f b7 45 e0	 movzx	 eax, WORD PTR _index$[ebp]
  002c6	50		 push	 eax
  002c7	0f b7 4d e0	 movzx	 ecx, WORD PTR _index$[ebp]
  002cb	51		 push	 ecx
  002cc	0f b7 55 e0	 movzx	 edx, WORD PTR _index$[ebp]
  002d0	52		 push	 edx
  002d1	e8 00 00 00 00	 call	 _add
  002d6	83 c4 08	 add	 esp, 8
  002d9	0f b7 c0	 movzx	 eax, ax
  002dc	50		 push	 eax
  002dd	e8 00 00 00 00	 call	 _add
  002e2	83 c4 08	 add	 esp, 8
  002e5	0f bf c8	 movsx	 ecx, ax
  002e8	8d 14 4d 00 00
	00 00		 lea	 edx, DWORD PTR _qua_gain_code[ecx*2]
  002ef	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  002f2	e8 00 00 00 00	 call	 _move16

; 144  :     test ();

  002f7	e8 00 00 00 00	 call	 _test

; 145  :     if (sub(mode, MR122) == 0)

  002fc	6a 07		 push	 7
  002fe	0f b7 45 08	 movzx	 eax, WORD PTR _mode$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 _sub
  00308	83 c4 08	 add	 esp, 8
  0030b	0f bf c8	 movsx	 ecx, ax
  0030e	85 c9		 test	 ecx, ecx
  00310	75 41		 jne	 SHORT $LN2@q_gain_cod

; 146  :     {
; 147  :        *gain = shl (mult (gcode0, *p++), 1); 

  00312	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00315	66 8b 08	 mov	 cx, WORD PTR [eax]
  00318	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv200[ebp], cx
  0031f	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  00322	83 c2 02	 add	 edx, 2
  00325	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  00328	6a 01		 push	 1
  0032a	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv200[ebp]
  00331	50		 push	 eax
  00332	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00336	51		 push	 ecx
  00337	e8 00 00 00 00	 call	 _mult
  0033c	83 c4 08	 add	 esp, 8
  0033f	0f b7 d0	 movzx	 edx, ax
  00342	52		 push	 edx
  00343	e8 00 00 00 00	 call	 _shl
  00348	83 c4 08	 add	 esp, 8
  0034b	8b 4d 14	 mov	 ecx, DWORD PTR _gain$[ebp]
  0034e	66 89 01	 mov	 WORD PTR [ecx], ax

; 148  :     }
; 149  :     else

  00351	eb 31		 jmp	 SHORT $LN1@q_gain_cod
$LN2@q_gain_cod:

; 150  :     {
; 151  :        *gain = mult (gcode0, *p++);

  00353	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00356	66 8b 08	 mov	 cx, WORD PTR [eax]
  00359	66 89 8d ea fe
	ff ff		 mov	 WORD PTR tv206[ebp], cx
  00360	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  00363	83 c2 02	 add	 edx, 2
  00366	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx
  00369	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv206[ebp]
  00370	50		 push	 eax
  00371	0f b7 4d d4	 movzx	 ecx, WORD PTR _gcode0$[ebp]
  00375	51		 push	 ecx
  00376	e8 00 00 00 00	 call	 _mult
  0037b	83 c4 08	 add	 esp, 8
  0037e	8b 55 14	 mov	 edx, DWORD PTR _gain$[ebp]
  00381	66 89 02	 mov	 WORD PTR [edx], ax
$LN1@q_gain_cod:

; 152  :     }
; 153  :                                             move16 ();

  00384	e8 00 00 00 00	 call	 _move16

; 154  :     
; 155  :     /* quantized error energies (for MA predictor update) */
; 156  :     *qua_ener_MR122 = *p++;                 move16 (); 

  00389	8b 45 18	 mov	 eax, DWORD PTR _qua_ener_MR122$[ebp]
  0038c	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0038f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00392	66 89 10	 mov	 WORD PTR [eax], dx
  00395	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00398	83 c0 02	 add	 eax, 2
  0039b	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
  0039e	e8 00 00 00 00	 call	 _move16

; 157  :     *qua_ener = *p;                         move16 (); 

  003a3	8b 45 1c	 mov	 eax, DWORD PTR _qua_ener$[ebp]
  003a6	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  003a9	66 8b 11	 mov	 dx, WORD PTR [ecx]
  003ac	66 89 10	 mov	 WORD PTR [eax], dx
  003af	e8 00 00 00 00	 call	 _move16

; 158  : 
; 159  :     return index;

  003b4	66 8b 45 e0	 mov	 ax, WORD PTR _index$[ebp]

; 160  : }

  003b8	5f		 pop	 edi
  003b9	5e		 pop	 esi
  003ba	5b		 pop	 ebx
  003bb	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  003c1	3b ec		 cmp	 ebp, esp
  003c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c8	8b e5		 mov	 esp, ebp
  003ca	5d		 pop	 ebp
  003cb	c3		 ret	 0
_q_gain_code ENDP
_TEXT	ENDS
END
