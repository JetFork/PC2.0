; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c4_17pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_c4_17pf_id
CONST	SEGMENT
_c4_17pf_id DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_gray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	06H
	DW	04H
	DW	05H
	DW	07H
_dgray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	06H
	DW	04H
	DW	07H
CONST	ENDS
PUBLIC	_code_4i40_17bits
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shl:PROC
EXTRN	_mult:PROC
EXTRN	_L_mult:PROC
EXTRN	_extract_l:PROC
EXTRN	_round:PROC
EXTRN	_L_mac:PROC
EXTRN	_L_msu:PROC
EXTRN	_L_shr:PROC
EXTRN	_L_deposit_h:PROC
EXTRN	_move16:PROC
EXTRN	_move32:PROC
EXTRN	_test:PROC
EXTRN	_cor_h_x:PROC
EXTRN	_cor_h:PROC
EXTRN	_set_sign:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c4_17pf.c
;	COMDAT _build_code
_TEXT	SEGMENT
tv238 = -358						; size = 2
tv230 = -358						; size = 2
tv222 = -358						; size = 2
tv214 = -358						; size = 2
_s$ = -160						; size = 4
_p3$ = -148						; size = 4
_p2$ = -136						; size = 4
_p1$ = -124						; size = 4
_p0$ = -112						; size = 4
_rsign$ = -100						; size = 2
_indx$ = -88						; size = 2
__sign$ = -76						; size = 8
_index$ = -60						; size = 2
_track$ = -48						; size = 2
_k$ = -36						; size = 2
_j$ = -24						; size = 2
_i$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_codvec$ = 8						; size = 4
_dn_sign$ = 12						; size = 4
_cod$ = 16						; size = 4
_h$ = 20						; size = 4
_y$ = 24						; size = 4
_sign$ = 28						; size = 4
_build_code PROC					; COMDAT

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00012	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 403  :     Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
; 404  :     Word16 *p0, *p1, *p2, *p3;
; 405  :     Word32 s;
; 406  : 
; 407  :     for (i = 0; i < L_CODE; i++)

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0002e	eb 0c		 jmp	 SHORT $LN18@build_code
$LN17@build_code:
  00030	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00034	66 83 c0 01	 add	 ax, 1
  00038	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN18@build_code:
  0003c	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00040	83 f8 28	 cmp	 eax, 40			; 00000028H
  00043	7d 14		 jge	 SHORT $LN16@build_code

; 408  :     {
; 409  :         cod[i] = 0;                         move16 ();

  00045	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  00049	33 c9		 xor	 ecx, ecx
  0004b	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  0004e	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00052	e8 00 00 00 00	 call	 _move16

; 410  :     }          

  00057	eb d7		 jmp	 SHORT $LN17@build_code
$LN16@build_code:

; 411  : 
; 412  :     indx = 0;                               move16 ();

  00059	33 c0		 xor	 eax, eax
  0005b	66 89 45 a8	 mov	 WORD PTR _indx$[ebp], ax
  0005f	e8 00 00 00 00	 call	 _move16

; 413  :     rsign = 0;                              move16 ();

  00064	33 c0		 xor	 eax, eax
  00066	66 89 45 9c	 mov	 WORD PTR _rsign$[ebp], ax
  0006a	e8 00 00 00 00	 call	 _move16

; 414  :     for (k = 0; k < NB_PULSE; k++)

  0006f	33 c0		 xor	 eax, eax
  00071	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
  00075	eb 0c		 jmp	 SHORT $LN15@build_code
$LN14@build_code:
  00077	66 8b 45 dc	 mov	 ax, WORD PTR _k$[ebp]
  0007b	66 83 c0 01	 add	 ax, 1
  0007f	66 89 45 dc	 mov	 WORD PTR _k$[ebp], ax
$LN15@build_code:
  00083	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00087	83 f8 04	 cmp	 eax, 4
  0008a	0f 8d 1b 02 00
	00		 jge	 $LN13@build_code

; 415  :     {
; 416  :        i = codvec[k];            move16 (); /* read pulse position */

  00090	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00097	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0009b	66 89 55 f4	 mov	 WORD PTR _i$[ebp], dx
  0009f	e8 00 00 00 00	 call	 _move16

; 417  :        j = dn_sign[i];           move16 (); /* read sign          */

  000a4	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _dn_sign$[ebp]
  000ab	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000af	66 89 55 e8	 mov	 WORD PTR _j$[ebp], dx
  000b3	e8 00 00 00 00	 call	 _move16

; 418  :        
; 419  :        index = mult(i, 6554);    /* index = pos/5 */

  000b8	68 9a 19 00 00	 push	 6554			; 0000199aH
  000bd	0f b7 45 f4	 movzx	 eax, WORD PTR _i$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _mult
  000c7	83 c4 08	 add	 esp, 8
  000ca	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax

; 420  :        /* track = pos%5 */
; 421  :        track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));

  000ce	6a 01		 push	 1
  000d0	6a 05		 push	 5
  000d2	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _L_mult
  000dc	83 c4 08	 add	 esp, 8
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _L_shr
  000e5	83 c4 08	 add	 esp, 8
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _extract_l
  000ee	83 c4 04	 add	 esp, 4
  000f1	0f b7 c8	 movzx	 ecx, ax
  000f4	51		 push	 ecx
  000f5	0f b7 55 f4	 movzx	 edx, WORD PTR _i$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _sub
  000ff	83 c4 08	 add	 esp, 8
  00102	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax

; 422  :        
; 423  :        
; 424  :        index = gray[index];                 move16 ();

  00106	0f bf 45 c4	 movsx	 eax, WORD PTR _index$[ebp]
  0010a	66 8b 0c 45 00
	00 00 00	 mov	 cx, WORD PTR _gray[eax*2]
  00112	66 89 4d c4	 mov	 WORD PTR _index$[ebp], cx
  00116	e8 00 00 00 00	 call	 _move16

; 425  :        
; 426  :        test ();

  0011b	e8 00 00 00 00	 call	 _test

; 427  :        if (sub(track, 1) == 0)

  00120	6a 01		 push	 1
  00122	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _sub
  0012c	83 c4 08	 add	 esp, 8
  0012f	0f bf c8	 movsx	 ecx, ax
  00132	85 c9		 test	 ecx, ecx
  00134	75 18		 jne	 SHORT $LN12@build_code

; 428  :           index = shl(index, 3);

  00136	6a 03		 push	 3
  00138	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _shl
  00142	83 c4 08	 add	 esp, 8
  00145	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  00149	e9 bf 00 00 00	 jmp	 $LN11@build_code
$LN12@build_code:

; 429  :        else if (sub(track, 2) == 0)

  0014e	6a 02		 push	 2
  00150	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _sub
  0015a	83 c4 08	 add	 esp, 8
  0015d	0f bf c8	 movsx	 ecx, ax
  00160	85 c9		 test	 ecx, ecx
  00162	75 1d		 jne	 SHORT $LN10@build_code

; 430  :        {
; 431  :           test ();

  00164	e8 00 00 00 00	 call	 _test

; 432  :           index = shl(index, 6);

  00169	6a 06		 push	 6
  0016b	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 _shl
  00175	83 c4 08	 add	 esp, 8
  00178	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  0017c	e9 8c 00 00 00	 jmp	 $LN11@build_code
$LN10@build_code:

; 433  :        }
; 434  :        else if (sub(track, 3) == 0)

  00181	6a 03		 push	 3
  00183	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 _sub
  0018d	83 c4 08	 add	 esp, 8
  00190	0f bf c8	 movsx	 ecx, ax
  00193	85 c9		 test	 ecx, ecx
  00195	75 1f		 jne	 SHORT $LN8@build_code

; 435  :        {
; 436  :           test ();test ();			

  00197	e8 00 00 00 00	 call	 _test
  0019c	e8 00 00 00 00	 call	 _test

; 437  :           index = shl(index, 10);

  001a1	6a 0a		 push	 10			; 0000000aH
  001a3	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _shl
  001ad	83 c4 08	 add	 esp, 8
  001b0	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
  001b4	eb 57		 jmp	 SHORT $LN11@build_code
$LN8@build_code:

; 438  :        }
; 439  :        else if (sub(track, 4) == 0)

  001b6	6a 04		 push	 4
  001b8	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _sub
  001c2	83 c4 08	 add	 esp, 8
  001c5	0f bf c8	 movsx	 ecx, ax
  001c8	85 c9		 test	 ecx, ecx
  001ca	75 41		 jne	 SHORT $LN11@build_code

; 440  :        {
; 441  :           test ();test ();test ();			

  001cc	e8 00 00 00 00	 call	 _test
  001d1	e8 00 00 00 00	 call	 _test
  001d6	e8 00 00 00 00	 call	 _test

; 442  :           track = 3;                        move16 ();

  001db	b8 03 00 00 00	 mov	 eax, 3
  001e0	66 89 45 d0	 mov	 WORD PTR _track$[ebp], ax
  001e4	e8 00 00 00 00	 call	 _move16

; 443  :           index = add(shl(index, 10), 512);

  001e9	68 00 02 00 00	 push	 512			; 00000200H
  001ee	6a 0a		 push	 10			; 0000000aH
  001f0	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 _shl
  001fa	83 c4 08	 add	 esp, 8
  001fd	0f b7 c8	 movzx	 ecx, ax
  00200	51		 push	 ecx
  00201	e8 00 00 00 00	 call	 _add
  00206	83 c4 08	 add	 esp, 8
  00209	66 89 45 c4	 mov	 WORD PTR _index$[ebp], ax
$LN11@build_code:

; 444  :        }
; 445  :        
; 446  :        test ();

  0020d	e8 00 00 00 00	 call	 _test

; 447  :        if (j > 0)

  00212	0f bf 45 e8	 movsx	 eax, WORD PTR _j$[ebp]
  00216	85 c0		 test	 eax, eax
  00218	7e 4e		 jle	 SHORT $LN5@build_code

; 448  :        {
; 449  :           cod[i] = 8191;                    move16 ();

  0021a	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0021e	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  00223	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00226	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  0022a	e8 00 00 00 00	 call	 _move16

; 450  :           _sign[k] = 32767;                 move16 ();

  0022f	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00233	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00238	66 89 4c 45 b4	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  0023d	e8 00 00 00 00	 call	 _move16

; 451  :           rsign = add(rsign, shl(1, track));

  00242	0f b7 45 d0	 movzx	 eax, WORD PTR _track$[ebp]
  00246	50		 push	 eax
  00247	6a 01		 push	 1
  00249	e8 00 00 00 00	 call	 _shl
  0024e	83 c4 08	 add	 esp, 8
  00251	0f b7 c8	 movzx	 ecx, ax
  00254	51		 push	 ecx
  00255	0f b7 55 9c	 movzx	 edx, WORD PTR _rsign$[ebp]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 _add
  0025f	83 c4 08	 add	 esp, 8
  00262	66 89 45 9c	 mov	 WORD PTR _rsign$[ebp], ax

; 452  :        } else {

  00266	eb 28		 jmp	 SHORT $LN4@build_code
$LN5@build_code:

; 453  :           cod[i] = -8192;                   move16 ();

  00268	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0026c	b9 00 e0 ff ff	 mov	 ecx, -8192		; ffffe000H
  00271	8b 55 10	 mov	 edx, DWORD PTR _cod$[ebp]
  00274	66 89 0c 42	 mov	 WORD PTR [edx+eax*2], cx
  00278	e8 00 00 00 00	 call	 _move16

; 454  :           _sign[k] = (Word16) - 32768L;     move16 ();

  0027d	0f bf 45 dc	 movsx	 eax, WORD PTR _k$[ebp]
  00281	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00286	66 89 4c 45 b4	 mov	 WORD PTR __sign$[ebp+eax*2], cx
  0028b	e8 00 00 00 00	 call	 _move16
$LN4@build_code:

; 455  :        }
; 456  :        
; 457  :        indx = add(indx, index);

  00290	0f b7 45 c4	 movzx	 eax, WORD PTR _index$[ebp]
  00294	50		 push	 eax
  00295	0f b7 4d a8	 movzx	 ecx, WORD PTR _indx$[ebp]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 _add
  0029f	83 c4 08	 add	 esp, 8
  002a2	66 89 45 a8	 mov	 WORD PTR _indx$[ebp], ax

; 458  :     }

  002a6	e9 cc fd ff ff	 jmp	 $LN14@build_code
$LN13@build_code:

; 459  :     *sign = rsign;                          move16 ();

  002ab	8b 45 1c	 mov	 eax, DWORD PTR _sign$[ebp]
  002ae	66 8b 4d 9c	 mov	 cx, WORD PTR _rsign$[ebp]
  002b2	66 89 08	 mov	 WORD PTR [eax], cx
  002b5	e8 00 00 00 00	 call	 _move16

; 460  :     
; 461  :     p0 = h - codvec[0];                     move16 ();

  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	6b c8 00	 imul	 ecx, eax, 0
  002c2	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  002c5	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  002c9	d1 e0		 shl	 eax, 1
  002cb	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  002ce	2b c8		 sub	 ecx, eax
  002d0	89 4d 90	 mov	 DWORD PTR _p0$[ebp], ecx
  002d3	e8 00 00 00 00	 call	 _move16

; 462  :     p1 = h - codvec[1];                     move16 ();

  002d8	b8 02 00 00 00	 mov	 eax, 2
  002dd	c1 e0 00	 shl	 eax, 0
  002e0	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  002e3	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  002e7	d1 e2		 shl	 edx, 1
  002e9	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  002ec	2b c2		 sub	 eax, edx
  002ee	89 45 84	 mov	 DWORD PTR _p1$[ebp], eax
  002f1	e8 00 00 00 00	 call	 _move16

; 463  :     p2 = h - codvec[2];                     move16 ();

  002f6	b8 02 00 00 00	 mov	 eax, 2
  002fb	d1 e0		 shl	 eax, 1
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00300	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00304	d1 e2		 shl	 edx, 1
  00306	8b 45 14	 mov	 eax, DWORD PTR _h$[ebp]
  00309	2b c2		 sub	 eax, edx
  0030b	89 85 78 ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], eax
  00311	e8 00 00 00 00	 call	 _move16

; 464  :     p3 = h - codvec[3];                     move16 ();

  00316	b8 02 00 00 00	 mov	 eax, 2
  0031b	6b c8 03	 imul	 ecx, eax, 3
  0031e	8b 55 08	 mov	 edx, DWORD PTR _codvec$[ebp]
  00321	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00325	d1 e0		 shl	 eax, 1
  00327	8b 4d 14	 mov	 ecx, DWORD PTR _h$[ebp]
  0032a	2b c8		 sub	 ecx, eax
  0032c	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _p3$[ebp], ecx
  00332	e8 00 00 00 00	 call	 _move16

; 465  :     
; 466  :     for (i = 0; i < L_CODE; i++)

  00337	33 c0		 xor	 eax, eax
  00339	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
  0033d	eb 0c		 jmp	 SHORT $LN3@build_code
$LN2@build_code:
  0033f	66 8b 45 f4	 mov	 ax, WORD PTR _i$[ebp]
  00343	66 83 c0 01	 add	 ax, 1
  00347	66 89 45 f4	 mov	 WORD PTR _i$[ebp], ax
$LN3@build_code:
  0034b	0f bf 45 f4	 movsx	 eax, WORD PTR _i$[ebp]
  0034f	83 f8 28	 cmp	 eax, 40			; 00000028H
  00352	0f 8d 48 01 00
	00		 jge	 $LN1@build_code

; 467  :     {
; 468  :        s = 0;                               move32 ();

  00358	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], 0
  00362	e8 00 00 00 00	 call	 _move32

; 469  :        s = L_mac(s, *p0++, _sign[0]);

  00367	8b 45 90	 mov	 eax, DWORD PTR _p0$[ebp]
  0036a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0036d	66 89 8d 9a fe
	ff ff		 mov	 WORD PTR tv214[ebp], cx
  00374	8b 55 90	 mov	 edx, DWORD PTR _p0$[ebp]
  00377	83 c2 02	 add	 edx, 2
  0037a	89 55 90	 mov	 DWORD PTR _p0$[ebp], edx
  0037d	b8 02 00 00 00	 mov	 eax, 2
  00382	6b c8 00	 imul	 ecx, eax, 0
  00385	0f b7 54 0d b4	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  0038a	52		 push	 edx
  0038b	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR tv214[ebp]
  00392	50		 push	 eax
  00393	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  00399	51		 push	 ecx
  0039a	e8 00 00 00 00	 call	 _L_mac
  0039f	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a2	89 85 60 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 470  :        s = L_mac(s, *p1++, _sign[1]);

  003a8	8b 45 84	 mov	 eax, DWORD PTR _p1$[ebp]
  003ab	66 8b 08	 mov	 cx, WORD PTR [eax]
  003ae	66 89 8d 9a fe
	ff ff		 mov	 WORD PTR tv222[ebp], cx
  003b5	8b 55 84	 mov	 edx, DWORD PTR _p1$[ebp]
  003b8	83 c2 02	 add	 edx, 2
  003bb	89 55 84	 mov	 DWORD PTR _p1$[ebp], edx
  003be	b8 02 00 00 00	 mov	 eax, 2
  003c3	c1 e0 00	 shl	 eax, 0
  003c6	0f b7 4c 05 b4	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  003cb	51		 push	 ecx
  003cc	0f b7 95 9a fe
	ff ff		 movzx	 edx, WORD PTR tv222[ebp]
  003d3	52		 push	 edx
  003d4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 _L_mac
  003e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e3	89 85 60 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 471  :        s = L_mac(s, *p2++, _sign[2]);

  003e9	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _p2$[ebp]
  003ef	66 8b 08	 mov	 cx, WORD PTR [eax]
  003f2	66 89 8d 9a fe
	ff ff		 mov	 WORD PTR tv230[ebp], cx
  003f9	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _p2$[ebp]
  003ff	83 c2 02	 add	 edx, 2
  00402	89 95 78 ff ff
	ff		 mov	 DWORD PTR _p2$[ebp], edx
  00408	b8 02 00 00 00	 mov	 eax, 2
  0040d	d1 e0		 shl	 eax, 1
  0040f	0f b7 4c 05 b4	 movzx	 ecx, WORD PTR __sign$[ebp+eax]
  00414	51		 push	 ecx
  00415	0f b7 95 9a fe
	ff ff		 movzx	 edx, WORD PTR tv230[ebp]
  0041c	52		 push	 edx
  0041d	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 _L_mac
  00429	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042c	89 85 60 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 472  :        s = L_mac(s, *p3++, _sign[3]);

  00432	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _p3$[ebp]
  00438	66 8b 08	 mov	 cx, WORD PTR [eax]
  0043b	66 89 8d 9a fe
	ff ff		 mov	 WORD PTR tv238[ebp], cx
  00442	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _p3$[ebp]
  00448	83 c2 02	 add	 edx, 2
  0044b	89 95 6c ff ff
	ff		 mov	 DWORD PTR _p3$[ebp], edx
  00451	b8 02 00 00 00	 mov	 eax, 2
  00456	6b c8 03	 imul	 ecx, eax, 3
  00459	0f b7 54 0d b4	 movzx	 edx, WORD PTR __sign$[ebp+ecx]
  0045e	52		 push	 edx
  0045f	0f b7 85 9a fe
	ff ff		 movzx	 eax, WORD PTR tv238[ebp]
  00466	50		 push	 eax
  00467	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _s$[ebp]
  0046d	51		 push	 ecx
  0046e	e8 00 00 00 00	 call	 _L_mac
  00473	83 c4 0c	 add	 esp, 12			; 0000000cH
  00476	89 85 60 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 473  :        y[i] = round(s);                     move16 ();

  0047c	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00482	50		 push	 eax
  00483	e8 00 00 00 00	 call	 _round
  00488	83 c4 04	 add	 esp, 4
  0048b	0f bf 4d f4	 movsx	 ecx, WORD PTR _i$[ebp]
  0048f	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  00492	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00496	e8 00 00 00 00	 call	 _move16

; 474  :     }

  0049b	e9 9f fe ff ff	 jmp	 $LN2@build_code
$LN1@build_code:

; 475  :     
; 476  :     return indx;

  004a0	66 8b 45 a8	 mov	 ax, WORD PTR _indx$[ebp]

; 477  : }

  004a4	52		 push	 edx
  004a5	8b cd		 mov	 ecx, ebp
  004a7	50		 push	 eax
  004a8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@build_code
  004ae	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004b3	58		 pop	 eax
  004b4	5a		 pop	 edx
  004b5	5f		 pop	 edi
  004b6	5e		 pop	 esi
  004b7	5b		 pop	 ebx
  004b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bb	33 cd		 xor	 ecx, ebp
  004bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c2	81 c4 68 01 00
	00		 add	 esp, 360		; 00000168H
  004c8	3b ec		 cmp	 ebp, esp
  004ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004cf	8b e5		 mov	 esp, ebp
  004d1	5d		 pop	 ebp
  004d2	c3		 ret	 0
  004d3	90		 npad	 1
$LN23@build_code:
  004d4	01 00 00 00	 DD	 1
  004d8	00 00 00 00	 DD	 $LN22@build_code
$LN22@build_code:
  004dc	b4 ff ff ff	 DD	 -76			; ffffffb4H
  004e0	08 00 00 00	 DD	 8
  004e4	00 00 00 00	 DD	 $LN21@build_code
$LN21@build_code:
  004e8	5f		 DB	 95			; 0000005fH
  004e9	73		 DB	 115			; 00000073H
  004ea	69		 DB	 105			; 00000069H
  004eb	67		 DB	 103			; 00000067H
  004ec	6e		 DB	 110			; 0000006eH
  004ed	00		 DB	 0
_build_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c4_17pf.c
;	COMDAT _search_4i40
_TEXT	SEGMENT
$T1 = -460						; size = 4
_alp1$ = -256						; size = 4
_alp0$ = -244						; size = 4
_s$ = -232						; size = 4
_alp_16$ = -220						; size = 2
_alp$ = -208						; size = 2
_alpk$ = -196						; size = 2
_sq1$ = -184						; size = 2
_sq$ = -172						; size = 2
_ps1$ = -160						; size = 2
_ps0$ = -148						; size = 2
_psk$ = -136						; size = 2
_ipos$ = -124						; size = 8
_track$ = -108						; size = 2
_pos$ = -96						; size = 2
_i$ = -84						; size = 2
_ps$ = -72						; size = 2
_ix$ = -60						; size = 2
_i3$ = -48						; size = 2
_i2$ = -36						; size = 2
_i1$ = -24						; size = 2
_i0$ = -12						; size = 2
__$ArrayPad$ = -4					; size = 4
_dn$ = 8						; size = 4
_dn2$ = 12						; size = 4
_rr$ = 16						; size = 4
_codvec$ = 20						; size = 4
_search_4i40 PROC					; COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-464]
  00012	b9 74 00 00 00	 mov	 ecx, 116		; 00000074H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 169  :     Word16 i0, i1, i2, i3;
; 170  :     Word16 ix = 0; /* initialization only needed to keep gcc silent */

  00028	33 c0		 xor	 eax, eax
  0002a	66 89 45 c4	 mov	 WORD PTR _ix$[ebp], ax

; 171  :     Word16 ps = 0; /* initialization only needed to keep gcc silent */

  0002e	33 c0		 xor	 eax, eax
  00030	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax

; 172  :     Word16 i, pos, track, ipos[NB_PULSE];
; 173  :     Word16 psk, ps0, ps1, sq, sq1;
; 174  :     Word16 alpk, alp, alp_16;
; 175  :     Word32 s, alp0, alp1;
; 176  :     
; 177  :     /* Default value */
; 178  :     psk = -1;            move16 ();

  00034	83 c8 ff	 or	 eax, -1
  00037	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _psk$[ebp], ax
  0003e	e8 00 00 00 00	 call	 _move16

; 179  :     alpk = 1;            move16 ();

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  0004f	e8 00 00 00 00	 call	 _move16

; 180  :     for (i = 0; i < NB_PULSE; i++)

  00054	33 c0		 xor	 eax, eax
  00056	66 89 45 ac	 mov	 WORD PTR _i$[ebp], ax
  0005a	eb 0c		 jmp	 SHORT $LN26@search_4i4
$LN25@search_4i4:
  0005c	66 8b 45 ac	 mov	 ax, WORD PTR _i$[ebp]
  00060	66 83 c0 01	 add	 ax, 1
  00064	66 89 45 ac	 mov	 WORD PTR _i$[ebp], ax
$LN26@search_4i4:
  00068	0f bf 45 ac	 movsx	 eax, WORD PTR _i$[ebp]
  0006c	83 f8 04	 cmp	 eax, 4
  0006f	7d 16		 jge	 SHORT $LN24@search_4i4

; 181  :     {
; 182  :        codvec[i] = i;    move16 ();

  00071	0f bf 45 ac	 movsx	 eax, WORD PTR _i$[ebp]
  00075	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00078	66 8b 55 ac	 mov	 dx, WORD PTR _i$[ebp]
  0007c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00080	e8 00 00 00 00	 call	 _move16

; 183  :     }

  00085	eb d5		 jmp	 SHORT $LN25@search_4i4
$LN24@search_4i4:

; 184  : 
; 185  :     for (track = 3; track < 5; track++) {

  00087	b8 03 00 00 00	 mov	 eax, 3
  0008c	66 89 45 94	 mov	 WORD PTR _track$[ebp], ax
  00090	eb 0c		 jmp	 SHORT $LN23@search_4i4
$LN22@search_4i4:
  00092	66 8b 45 94	 mov	 ax, WORD PTR _track$[ebp]
  00096	66 83 c0 01	 add	 ax, 1
  0009a	66 89 45 94	 mov	 WORD PTR _track$[ebp], ax
$LN23@search_4i4:
  0009e	0f bf 45 94	 movsx	 eax, WORD PTR _track$[ebp]
  000a2	83 f8 05	 cmp	 eax, 5
  000a5	0f 8d af 08 00
	00		 jge	 $LN28@search_4i4

; 186  :     /* fix starting position */
; 187  : 
; 188  :        ipos[0] = 0;     move16 ();

  000ab	b8 02 00 00 00	 mov	 eax, 2
  000b0	6b c8 00	 imul	 ecx, eax, 0
  000b3	89 8d 34 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000b9	83 bd 34 fe ff
	ff 08		 cmp	 DWORD PTR $T1[ebp], 8
  000c0	73 02		 jae	 SHORT $LN29@search_4i4
  000c2	eb 05		 jmp	 SHORT $LN30@search_4i4
$LN29@search_4i4:
  000c4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN30@search_4i4:
  000c9	33 d2		 xor	 edx, edx
  000cb	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  000d1	66 89 54 05 84	 mov	 WORD PTR _ipos$[ebp+eax], dx
  000d6	e8 00 00 00 00	 call	 _move16

; 189  :        ipos[1] = 1;     move16 ();

  000db	b8 02 00 00 00	 mov	 eax, 2
  000e0	c1 e0 00	 shl	 eax, 0
  000e3	b9 01 00 00 00	 mov	 ecx, 1
  000e8	66 89 4c 05 84	 mov	 WORD PTR _ipos$[ebp+eax], cx
  000ed	e8 00 00 00 00	 call	 _move16

; 190  :        ipos[2] = 2;     move16 ();

  000f2	b8 02 00 00 00	 mov	 eax, 2
  000f7	d1 e0		 shl	 eax, 1
  000f9	b9 02 00 00 00	 mov	 ecx, 2
  000fe	66 89 4c 05 84	 mov	 WORD PTR _ipos$[ebp+eax], cx
  00103	e8 00 00 00 00	 call	 _move16

; 191  :        ipos[3] = track; move16 ();

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	6b c8 03	 imul	 ecx, eax, 3
  00110	66 8b 55 94	 mov	 dx, WORD PTR _track$[ebp]
  00114	66 89 54 0d 84	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  00119	e8 00 00 00 00	 call	 _move16

; 192  :        
; 193  :        /*------------------------------------------------------------------*
; 194  :         * main loop: try 4 tracks.                                         *
; 195  :         *------------------------------------------------------------------*/
; 196  :        
; 197  :        for (i = 0; i < NB_PULSE; i++)

  0011e	33 c0		 xor	 eax, eax
  00120	66 89 45 ac	 mov	 WORD PTR _i$[ebp], ax
  00124	eb 0c		 jmp	 SHORT $LN20@search_4i4
$LN19@search_4i4:
  00126	66 8b 45 ac	 mov	 ax, WORD PTR _i$[ebp]
  0012a	66 83 c0 01	 add	 ax, 1
  0012e	66 89 45 ac	 mov	 WORD PTR _i$[ebp], ax
$LN20@search_4i4:
  00132	0f bf 45 ac	 movsx	 eax, WORD PTR _i$[ebp]
  00136	83 f8 04	 cmp	 eax, 4
  00139	0f 8d 16 08 00
	00		 jge	 $LN18@search_4i4

; 198  :        {
; 199  :           /*----------------------------------------------------------------*
; 200  :            * i0 loop: try 4 positions (use position with max of corr.).     *
; 201  :            *----------------------------------------------------------------*/
; 202  :           
; 203  :           move16 (); /* account for ptr. init. (rr[io]) */

  0013f	e8 00 00 00 00	 call	 _move16

; 204  :           for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)

  00144	b8 02 00 00 00	 mov	 eax, 2
  00149	6b c8 00	 imul	 ecx, eax, 0
  0014c	66 8b 54 0d 84	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  00151	66 89 55 f4	 mov	 WORD PTR _i0$[ebp], dx
  00155	eb 0b		 jmp	 SHORT $LN17@search_4i4
$LN16@search_4i4:
  00157	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  0015b	83 c0 05	 add	 eax, 5
  0015e	66 89 45 f4	 mov	 WORD PTR _i0$[ebp], ax
$LN17@search_4i4:
  00162	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00166	83 f8 28	 cmp	 eax, 40			; 00000028H
  00169	0f 8d 5a 07 00
	00		 jge	 $LN15@search_4i4

; 205  :           {
; 206  :              test (); move16 ();

  0016f	e8 00 00 00 00	 call	 _test
  00174	e8 00 00 00 00	 call	 _move16

; 207  :              if (dn2[i0] >= 0)

  00179	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _dn2$[ebp]
  00180	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00184	85 d2		 test	 edx, edx
  00186	0f 8c 38 07 00
	00		 jl	 $LN14@search_4i4

; 208  :              {
; 209  :                 ps0 = dn[i0];     move16 ();

  0018c	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00193	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00197	66 89 95 6c ff
	ff ff		 mov	 WORD PTR _ps0$[ebp], dx
  0019e	e8 00 00 00 00	 call	 _move16

; 210  :                 alp0 = L_mult(rr[i0][i0], _1_4);

  001a3	68 00 20 00 00	 push	 8192			; 00002000H
  001a8	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  001ac	6b c8 50	 imul	 ecx, eax, 80
  001af	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  001b2	0f bf 55 f4	 movsx	 edx, WORD PTR _i0$[ebp]
  001b6	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 _L_mult
  001c0	83 c4 08	 add	 esp, 8
  001c3	89 85 0c ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 211  :                 
; 212  :                 /*----------------------------------------------------------------*
; 213  :                  * i1 loop: 8 positions.                                          *
; 214  :                  *----------------------------------------------------------------*/
; 215  :                 
; 216  :                 sq = -1;          move16 ();

  001c9	83 c8 ff	 or	 eax, -1
  001cc	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  001d3	e8 00 00 00 00	 call	 _move16

; 217  :                 alp = 1;          move16 ();

  001d8	b8 01 00 00 00	 mov	 eax, 1
  001dd	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  001e4	e8 00 00 00 00	 call	 _move16

; 218  :                 ps = 0;           move16 ();

  001e9	33 c0		 xor	 eax, eax
  001eb	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  001ef	e8 00 00 00 00	 call	 _move16

; 219  :                 ix = ipos[1];     move16 ();

  001f4	b8 02 00 00 00	 mov	 eax, 2
  001f9	c1 e0 00	 shl	 eax, 0
  001fc	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00201	66 89 4d c4	 mov	 WORD PTR _ix$[ebp], cx
  00205	e8 00 00 00 00	 call	 _move16

; 220  :                     
; 221  :                 /* initialize 4 index for next loop. */
; 222  :                 /*-------------------------------------------------------------------*
; 223  :                  *  These index have low complexity address computation because      *
; 224  :                  *  they are, in fact, pointers with fixed increment.  For example,  *
; 225  :                  *  "rr[i0][i3]" is a pointer initialized to "&rr[i0][ipos[3]]"      *
; 226  :                  *  and incremented by "STEP".                                       *
; 227  :                  *-------------------------------------------------------------------*/
; 228  :                 
; 229  :                 move16 (); /* account for ptr. init. (rr[i1]) */

  0020a	e8 00 00 00 00	 call	 _move16

; 230  :                 move16 (); /* account for ptr. init. (dn[i1]) */

  0020f	e8 00 00 00 00	 call	 _move16

; 231  :                 move16 (); /* account for ptr. init. (rr[io]) */

  00214	e8 00 00 00 00	 call	 _move16

; 232  :                 for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP)

  00219	b8 02 00 00 00	 mov	 eax, 2
  0021e	c1 e0 00	 shl	 eax, 0
  00221	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  00226	66 89 4d e8	 mov	 WORD PTR _i1$[ebp], cx
  0022a	eb 0b		 jmp	 SHORT $LN13@search_4i4
$LN12@search_4i4:
  0022c	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00230	83 c0 05	 add	 eax, 5
  00233	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
$LN13@search_4i4:
  00237	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  0023b	83 f8 28	 cmp	 eax, 40			; 00000028H
  0023e	0f 8d 3f 01 00
	00		 jge	 $LN11@search_4i4

; 233  :                 {
; 234  :                    ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */

  00244	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00248	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  0024b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0024f	52		 push	 edx
  00250	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _ps0$[ebp]
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 _add
  0025d	83 c4 08	 add	 esp, 8
  00260	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _ps1$[ebp], ax

; 235  :                    
; 236  :                    /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
; 237  :                    
; 238  :                    alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */

  00267	68 00 20 00 00	 push	 8192			; 00002000H
  0026c	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00270	6b c8 50	 imul	 ecx, eax, 80
  00273	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00276	0f bf 55 e8	 movsx	 edx, WORD PTR _i1$[ebp]
  0027a	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0027e	50		 push	 eax
  0027f	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 _L_mac
  0028b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028e	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 239  :                    alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */

  00294	68 00 40 00 00	 push	 16384			; 00004000H
  00299	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  0029d	6b c8 50	 imul	 ecx, eax, 80
  002a0	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  002a3	0f bf 55 e8	 movsx	 edx, WORD PTR _i1$[ebp]
  002a7	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  002ab	50		 push	 eax
  002ac	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 _L_mac
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bb	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 240  :                    
; 241  :                    sq1 = mult(ps1, ps1);

  002c1	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _ps1$[ebp]
  002c8	50		 push	 eax
  002c9	0f b7 8d 60 ff
	ff ff		 movzx	 ecx, WORD PTR _ps1$[ebp]
  002d0	51		 push	 ecx
  002d1	e8 00 00 00 00	 call	 _mult
  002d6	83 c4 08	 add	 esp, 8
  002d9	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _sq1$[ebp], ax

; 242  :                    
; 243  :                    alp_16 = round(alp1);

  002e0	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _round
  002ec	83 c4 04	 add	 esp, 4
  002ef	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 244  :                    
; 245  :                    s = L_msu(L_mult(alp, sq1), sq, alp_16);

  002f6	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  002fd	50		 push	 eax
  002fe	0f b7 8d 54 ff
	ff ff		 movzx	 ecx, WORD PTR _sq$[ebp]
  00305	51		 push	 ecx
  00306	0f b7 95 48 ff
	ff ff		 movzx	 edx, WORD PTR _sq1$[ebp]
  0030d	52		 push	 edx
  0030e	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  00315	50		 push	 eax
  00316	e8 00 00 00 00	 call	 _L_mult
  0031b	83 c4 08	 add	 esp, 8
  0031e	50		 push	 eax
  0031f	e8 00 00 00 00	 call	 _L_msu
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
  00327	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 246  :                    
; 247  :                    test ();

  0032d	e8 00 00 00 00	 call	 _test

; 248  :                    if (s > 0)

  00332	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  00339	7e 43		 jle	 SHORT $LN10@search_4i4

; 249  :                    {
; 250  :                       sq = sq1;         move16 ();

  0033b	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _sq1$[ebp]
  00342	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  00349	e8 00 00 00 00	 call	 _move16

; 251  :                       ps = ps1;         move16 ();

  0034e	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _ps1$[ebp]
  00355	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  00359	e8 00 00 00 00	 call	 _move16

; 252  :                       alp = alp_16;     move16 ();

  0035e	66 8b 85 24 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  00365	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  0036c	e8 00 00 00 00	 call	 _move16

; 253  :                       ix = i1;          move16 ();

  00371	66 8b 45 e8	 mov	 ax, WORD PTR _i1$[ebp]
  00375	66 89 45 c4	 mov	 WORD PTR _ix$[ebp], ax
  00379	e8 00 00 00 00	 call	 _move16
$LN10@search_4i4:

; 254  :                    }
; 255  :                 }

  0037e	e9 a9 fe ff ff	 jmp	 $LN12@search_4i4
$LN11@search_4i4:

; 256  :                 i1 = ix;                  move16 ();

  00383	66 8b 45 c4	 mov	 ax, WORD PTR _ix$[ebp]
  00387	66 89 45 e8	 mov	 WORD PTR _i1$[ebp], ax
  0038b	e8 00 00 00 00	 call	 _move16

; 257  :                 
; 258  :                 /*----------------------------------------------------------------*
; 259  :                  * i2 loop: 8 positions.                                          *
; 260  :                  *----------------------------------------------------------------*/
; 261  :                 
; 262  :                 ps0 = ps;                 move16 ();

  00390	66 8b 45 b8	 mov	 ax, WORD PTR _ps$[ebp]
  00394	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _ps0$[ebp], ax
  0039b	e8 00 00 00 00	 call	 _move16

; 263  :                 alp0 = L_mult(alp, _1_4);

  003a0	68 00 20 00 00	 push	 8192			; 00002000H
  003a5	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 _L_mult
  003b2	83 c4 08	 add	 esp, 8
  003b5	89 85 0c ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 264  :                 
; 265  :                 sq = -1;                  move16 ();

  003bb	83 c8 ff	 or	 eax, -1
  003be	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  003c5	e8 00 00 00 00	 call	 _move16

; 266  :                 alp = 1;                  move16 ();

  003ca	b8 01 00 00 00	 mov	 eax, 1
  003cf	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  003d6	e8 00 00 00 00	 call	 _move16

; 267  :                 ps = 0;                   move16 ();

  003db	33 c0		 xor	 eax, eax
  003dd	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  003e1	e8 00 00 00 00	 call	 _move16

; 268  :                 ix = ipos[2];             move16 ();

  003e6	b8 02 00 00 00	 mov	 eax, 2
  003eb	d1 e0		 shl	 eax, 1
  003ed	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  003f2	66 89 4d c4	 mov	 WORD PTR _ix$[ebp], cx
  003f6	e8 00 00 00 00	 call	 _move16

; 269  :                                     
; 270  :                 /* initialize 4 index for next loop (see i1 loop) */
; 271  :                 
; 272  :                 move16 (); /* account for ptr. init. (rr[i2]) */

  003fb	e8 00 00 00 00	 call	 _move16

; 273  :                 move16 (); /* account for ptr. init. (rr[i1]) */

  00400	e8 00 00 00 00	 call	 _move16

; 274  :                 move16 (); /* account for ptr. init. (dn[i2]) */

  00405	e8 00 00 00 00	 call	 _move16

; 275  :                 move16 (); /* account for ptr. init. (rr[io]) */

  0040a	e8 00 00 00 00	 call	 _move16

; 276  :                 for (i2 = ipos[2]; i2 < L_CODE; i2 += STEP)

  0040f	b8 02 00 00 00	 mov	 eax, 2
  00414	d1 e0		 shl	 eax, 1
  00416	66 8b 4c 05 84	 mov	 cx, WORD PTR _ipos$[ebp+eax]
  0041b	66 89 4d dc	 mov	 WORD PTR _i2$[ebp], cx
  0041f	eb 0b		 jmp	 SHORT $LN9@search_4i4
$LN8@search_4i4:
  00421	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  00425	83 c0 05	 add	 eax, 5
  00428	66 89 45 dc	 mov	 WORD PTR _i2$[ebp], ax
$LN9@search_4i4:
  0042c	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  00430	83 f8 28	 cmp	 eax, 40			; 00000028H
  00433	0f 8d 6c 01 00
	00		 jge	 $LN7@search_4i4

; 277  :                 {
; 278  :                    ps1 = add(ps0, dn[i2]); /* index increment = STEP */

  00439	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  0043d	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00440	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00444	52		 push	 edx
  00445	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _ps0$[ebp]
  0044c	50		 push	 eax
  0044d	e8 00 00 00 00	 call	 _add
  00452	83 c4 08	 add	 esp, 8
  00455	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _ps1$[ebp], ax

; 279  :                    
; 280  :                    /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
; 281  :                    
; 282  :                    alp1 = L_mac(alp0, rr[i2][i2], _1_16); /* idx incr = STEP */

  0045c	68 00 08 00 00	 push	 2048			; 00000800H
  00461	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  00465	6b c8 50	 imul	 ecx, eax, 80
  00468	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  0046b	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  0046f	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00473	50		 push	 eax
  00474	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  0047a	51		 push	 ecx
  0047b	e8 00 00 00 00	 call	 _L_mac
  00480	83 c4 0c	 add	 esp, 12			; 0000000cH
  00483	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 283  :                    alp1 = L_mac(alp1, rr[i1][i2], _1_8);  /* idx incr = STEP */

  00489	68 00 10 00 00	 push	 4096			; 00001000H
  0048e	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  00492	6b c8 50	 imul	 ecx, eax, 80
  00495	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00498	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  0049c	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  004a0	50		 push	 eax
  004a1	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  004a7	51		 push	 ecx
  004a8	e8 00 00 00 00	 call	 _L_mac
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b0	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 284  :                    alp1 = L_mac(alp1, rr[i0][i2], _1_8);  /* idx incr = STEP */

  004b6	68 00 10 00 00	 push	 4096			; 00001000H
  004bb	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  004bf	6b c8 50	 imul	 ecx, eax, 80
  004c2	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  004c5	0f bf 55 dc	 movsx	 edx, WORD PTR _i2$[ebp]
  004c9	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  004cd	50		 push	 eax
  004ce	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  004d4	51		 push	 ecx
  004d5	e8 00 00 00 00	 call	 _L_mac
  004da	83 c4 0c	 add	 esp, 12			; 0000000cH
  004dd	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 285  :                    
; 286  :                    sq1 = mult(ps1, ps1);

  004e3	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _ps1$[ebp]
  004ea	50		 push	 eax
  004eb	0f b7 8d 60 ff
	ff ff		 movzx	 ecx, WORD PTR _ps1$[ebp]
  004f2	51		 push	 ecx
  004f3	e8 00 00 00 00	 call	 _mult
  004f8	83 c4 08	 add	 esp, 8
  004fb	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _sq1$[ebp], ax

; 287  :                    
; 288  :                    alp_16 = round(alp1);

  00502	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  00508	50		 push	 eax
  00509	e8 00 00 00 00	 call	 _round
  0050e	83 c4 04	 add	 esp, 4
  00511	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 289  :                    
; 290  :                    s = L_msu(L_mult(alp, sq1), sq, alp_16);

  00518	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  0051f	50		 push	 eax
  00520	0f b7 8d 54 ff
	ff ff		 movzx	 ecx, WORD PTR _sq$[ebp]
  00527	51		 push	 ecx
  00528	0f b7 95 48 ff
	ff ff		 movzx	 edx, WORD PTR _sq1$[ebp]
  0052f	52		 push	 edx
  00530	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  00537	50		 push	 eax
  00538	e8 00 00 00 00	 call	 _L_mult
  0053d	83 c4 08	 add	 esp, 8
  00540	50		 push	 eax
  00541	e8 00 00 00 00	 call	 _L_msu
  00546	83 c4 0c	 add	 esp, 12			; 0000000cH
  00549	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 291  :                    
; 292  :                    test ();

  0054f	e8 00 00 00 00	 call	 _test

; 293  :                    if (s > 0)

  00554	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  0055b	7e 43		 jle	 SHORT $LN6@search_4i4

; 294  :                    {
; 295  :                       sq = sq1;         move16 ();

  0055d	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _sq1$[ebp]
  00564	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  0056b	e8 00 00 00 00	 call	 _move16

; 296  :                       ps = ps1;         move16 ();

  00570	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _ps1$[ebp]
  00577	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  0057b	e8 00 00 00 00	 call	 _move16

; 297  :                       alp = alp_16;     move16 ();

  00580	66 8b 85 24 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  00587	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  0058e	e8 00 00 00 00	 call	 _move16

; 298  :                       ix = i2;          move16 ();

  00593	66 8b 45 dc	 mov	 ax, WORD PTR _i2$[ebp]
  00597	66 89 45 c4	 mov	 WORD PTR _ix$[ebp], ax
  0059b	e8 00 00 00 00	 call	 _move16
$LN6@search_4i4:

; 299  :                    }
; 300  :                 }

  005a0	e9 7c fe ff ff	 jmp	 $LN8@search_4i4
$LN7@search_4i4:

; 301  :                 i2 = ix;                  move16 ();

  005a5	66 8b 45 c4	 mov	 ax, WORD PTR _ix$[ebp]
  005a9	66 89 45 dc	 mov	 WORD PTR _i2$[ebp], ax
  005ad	e8 00 00 00 00	 call	 _move16

; 302  :                 
; 303  :                 /*----------------------------------------------------------------*
; 304  :                  * i3 loop: 8 positions.                                          *
; 305  :                  *----------------------------------------------------------------*/
; 306  :                 
; 307  :                 ps0 = ps;                 move16 ();

  005b2	66 8b 45 b8	 mov	 ax, WORD PTR _ps$[ebp]
  005b6	66 89 85 6c ff
	ff ff		 mov	 WORD PTR _ps0$[ebp], ax
  005bd	e8 00 00 00 00	 call	 _move16

; 308  :                 alp0 = L_deposit_h(alp);

  005c2	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  005c9	50		 push	 eax
  005ca	e8 00 00 00 00	 call	 _L_deposit_h
  005cf	83 c4 04	 add	 esp, 4
  005d2	89 85 0c ff ff
	ff		 mov	 DWORD PTR _alp0$[ebp], eax

; 309  :                 
; 310  :                 sq = -1;                  move16 ();

  005d8	83 c8 ff	 or	 eax, -1
  005db	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  005e2	e8 00 00 00 00	 call	 _move16

; 311  :                 alp = 1;                  move16 ();

  005e7	b8 01 00 00 00	 mov	 eax, 1
  005ec	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  005f3	e8 00 00 00 00	 call	 _move16

; 312  :                 ps = 0;                   move16 ();

  005f8	33 c0		 xor	 eax, eax
  005fa	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  005fe	e8 00 00 00 00	 call	 _move16

; 313  :                 ix = ipos[3];             move16 ();

  00603	b8 02 00 00 00	 mov	 eax, 2
  00608	6b c8 03	 imul	 ecx, eax, 3
  0060b	66 8b 54 0d 84	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  00610	66 89 55 c4	 mov	 WORD PTR _ix$[ebp], dx
  00614	e8 00 00 00 00	 call	 _move16

; 314  :                                     
; 315  :                 /* initialize 5 index for next loop (see i1 loop) */
; 316  :                 
; 317  :                 move16 (); /* account for ptr. init. (rr[i3]) */

  00619	e8 00 00 00 00	 call	 _move16

; 318  :                 move16 (); /* account for ptr. init. (rr[i2]) */

  0061e	e8 00 00 00 00	 call	 _move16

; 319  :                 move16 (); /* account for ptr. init. (rr[i1]) */

  00623	e8 00 00 00 00	 call	 _move16

; 320  :                 move16 (); /* account for ptr. init. (dn[i3]) */

  00628	e8 00 00 00 00	 call	 _move16

; 321  :                 move16 (); /* account for ptr. init. (rr[io]) */

  0062d	e8 00 00 00 00	 call	 _move16

; 322  :                 for (i3 = ipos[3]; i3 < L_CODE; i3 += STEP)

  00632	b8 02 00 00 00	 mov	 eax, 2
  00637	6b c8 03	 imul	 ecx, eax, 3
  0063a	66 8b 54 0d 84	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  0063f	66 89 55 d0	 mov	 WORD PTR _i3$[ebp], dx
  00643	eb 0b		 jmp	 SHORT $LN5@search_4i4
$LN4@search_4i4:
  00645	0f bf 45 d0	 movsx	 eax, WORD PTR _i3$[ebp]
  00649	83 c0 05	 add	 eax, 5
  0064c	66 89 45 d0	 mov	 WORD PTR _i3$[ebp], ax
$LN5@search_4i4:
  00650	0f bf 45 d0	 movsx	 eax, WORD PTR _i3$[ebp]
  00654	83 f8 28	 cmp	 eax, 40			; 00000028H
  00657	0f 8d 99 01 00
	00		 jge	 $LN3@search_4i4

; 323  :                 {
; 324  :                    ps1 = add(ps0, dn[i3]); /* index increment = STEP */

  0065d	0f bf 45 d0	 movsx	 eax, WORD PTR _i3$[ebp]
  00661	8b 4d 08	 mov	 ecx, DWORD PTR _dn$[ebp]
  00664	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00668	52		 push	 edx
  00669	0f b7 85 6c ff
	ff ff		 movzx	 eax, WORD PTR _ps0$[ebp]
  00670	50		 push	 eax
  00671	e8 00 00 00 00	 call	 _add
  00676	83 c4 08	 add	 esp, 8
  00679	66 89 85 60 ff
	ff ff		 mov	 WORD PTR _ps1$[ebp], ax

; 325  :                    
; 326  :                    /* alp1 = alp0 + rr[i0][i3] + rr[i1][i3] + rr[i2][i3] + 1/2*rr[i3][i3]; */
; 327  :                    
; 328  :                    alp1 = L_mac(alp0, rr[i3][i3], _1_16); /* idx incr = STEP */

  00680	68 00 08 00 00	 push	 2048			; 00000800H
  00685	0f bf 45 d0	 movsx	 eax, WORD PTR _i3$[ebp]
  00689	6b c8 50	 imul	 ecx, eax, 80
  0068c	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  0068f	0f bf 55 d0	 movsx	 edx, WORD PTR _i3$[ebp]
  00693	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  00697	50		 push	 eax
  00698	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _alp0$[ebp]
  0069e	51		 push	 ecx
  0069f	e8 00 00 00 00	 call	 _L_mac
  006a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a7	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 329  :                    alp1 = L_mac(alp1, rr[i2][i3], _1_8);  /* idx incr = STEP */

  006ad	68 00 10 00 00	 push	 4096			; 00001000H
  006b2	0f bf 45 dc	 movsx	 eax, WORD PTR _i2$[ebp]
  006b6	6b c8 50	 imul	 ecx, eax, 80
  006b9	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  006bc	0f bf 55 d0	 movsx	 edx, WORD PTR _i3$[ebp]
  006c0	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  006c4	50		 push	 eax
  006c5	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  006cb	51		 push	 ecx
  006cc	e8 00 00 00 00	 call	 _L_mac
  006d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d4	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 330  :                    alp1 = L_mac(alp1, rr[i1][i3], _1_8);  /* idx incr = STEP */

  006da	68 00 10 00 00	 push	 4096			; 00001000H
  006df	0f bf 45 e8	 movsx	 eax, WORD PTR _i1$[ebp]
  006e3	6b c8 50	 imul	 ecx, eax, 80
  006e6	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  006e9	0f bf 55 d0	 movsx	 edx, WORD PTR _i3$[ebp]
  006ed	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  006f1	50		 push	 eax
  006f2	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  006f8	51		 push	 ecx
  006f9	e8 00 00 00 00	 call	 _L_mac
  006fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00701	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 331  :                    alp1 = L_mac(alp1, rr[i0][i3], _1_8);  /* idx incr = STEP */

  00707	68 00 10 00 00	 push	 4096			; 00001000H
  0070c	0f bf 45 f4	 movsx	 eax, WORD PTR _i0$[ebp]
  00710	6b c8 50	 imul	 ecx, eax, 80
  00713	03 4d 10	 add	 ecx, DWORD PTR _rr$[ebp]
  00716	0f bf 55 d0	 movsx	 edx, WORD PTR _i3$[ebp]
  0071a	0f b7 04 51	 movzx	 eax, WORD PTR [ecx+edx*2]
  0071e	50		 push	 eax
  0071f	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _alp1$[ebp]
  00725	51		 push	 ecx
  00726	e8 00 00 00 00	 call	 _L_mac
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072e	89 85 00 ff ff
	ff		 mov	 DWORD PTR _alp1$[ebp], eax

; 332  :                    
; 333  :                    sq1 = mult(ps1, ps1);

  00734	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR _ps1$[ebp]
  0073b	50		 push	 eax
  0073c	0f b7 8d 60 ff
	ff ff		 movzx	 ecx, WORD PTR _ps1$[ebp]
  00743	51		 push	 ecx
  00744	e8 00 00 00 00	 call	 _mult
  00749	83 c4 08	 add	 esp, 8
  0074c	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _sq1$[ebp], ax

; 334  :                    
; 335  :                    alp_16 = round(alp1);

  00753	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _alp1$[ebp]
  00759	50		 push	 eax
  0075a	e8 00 00 00 00	 call	 _round
  0075f	83 c4 04	 add	 esp, 4
  00762	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _alp_16$[ebp], ax

; 336  :                    
; 337  :                    s = L_msu(L_mult(alp, sq1), sq, alp_16);

  00769	0f b7 85 24 ff
	ff ff		 movzx	 eax, WORD PTR _alp_16$[ebp]
  00770	50		 push	 eax
  00771	0f b7 8d 54 ff
	ff ff		 movzx	 ecx, WORD PTR _sq$[ebp]
  00778	51		 push	 ecx
  00779	0f b7 95 48 ff
	ff ff		 movzx	 edx, WORD PTR _sq1$[ebp]
  00780	52		 push	 edx
  00781	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  00788	50		 push	 eax
  00789	e8 00 00 00 00	 call	 _L_mult
  0078e	83 c4 08	 add	 esp, 8
  00791	50		 push	 eax
  00792	e8 00 00 00 00	 call	 _L_msu
  00797	83 c4 0c	 add	 esp, 12			; 0000000cH
  0079a	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 338  :                    
; 339  :                    test ();

  007a0	e8 00 00 00 00	 call	 _test

; 340  :                    if (s > 0)

  007a5	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  007ac	7e 43		 jle	 SHORT $LN2@search_4i4

; 341  :                    {
; 342  :                       sq = sq1;         move16 ();

  007ae	66 8b 85 48 ff
	ff ff		 mov	 ax, WORD PTR _sq1$[ebp]
  007b5	66 89 85 54 ff
	ff ff		 mov	 WORD PTR _sq$[ebp], ax
  007bc	e8 00 00 00 00	 call	 _move16

; 343  :                       ps = ps1;         move16 ();

  007c1	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _ps1$[ebp]
  007c8	66 89 45 b8	 mov	 WORD PTR _ps$[ebp], ax
  007cc	e8 00 00 00 00	 call	 _move16

; 344  :                       alp = alp_16;     move16 ();

  007d1	66 8b 85 24 ff
	ff ff		 mov	 ax, WORD PTR _alp_16$[ebp]
  007d8	66 89 85 30 ff
	ff ff		 mov	 WORD PTR _alp$[ebp], ax
  007df	e8 00 00 00 00	 call	 _move16

; 345  :                       ix = i3;          move16 ();

  007e4	66 8b 45 d0	 mov	 ax, WORD PTR _i3$[ebp]
  007e8	66 89 45 c4	 mov	 WORD PTR _ix$[ebp], ax
  007ec	e8 00 00 00 00	 call	 _move16
$LN2@search_4i4:

; 346  :                    }
; 347  :                 }

  007f1	e9 4f fe ff ff	 jmp	 $LN4@search_4i4
$LN3@search_4i4:

; 348  :                 
; 349  :                 
; 350  :                 /*----------------------------------------------------------------*
; 351  :                  * memorise codevector if this one is better than the last one.   *
; 352  :                  *----------------------------------------------------------------*/
; 353  :                 
; 354  :                 s = L_msu(L_mult(alpk, sq), psk, alp);

  007f6	0f b7 85 30 ff
	ff ff		 movzx	 eax, WORD PTR _alp$[ebp]
  007fd	50		 push	 eax
  007fe	0f b7 8d 78 ff
	ff ff		 movzx	 ecx, WORD PTR _psk$[ebp]
  00805	51		 push	 ecx
  00806	0f b7 95 54 ff
	ff ff		 movzx	 edx, WORD PTR _sq$[ebp]
  0080d	52		 push	 edx
  0080e	0f b7 85 3c ff
	ff ff		 movzx	 eax, WORD PTR _alpk$[ebp]
  00815	50		 push	 eax
  00816	e8 00 00 00 00	 call	 _L_mult
  0081b	83 c4 08	 add	 esp, 8
  0081e	50		 push	 eax
  0081f	e8 00 00 00 00	 call	 _L_msu
  00824	83 c4 0c	 add	 esp, 12			; 0000000cH
  00827	89 85 18 ff ff
	ff		 mov	 DWORD PTR _s$[ebp], eax

; 355  :                 
; 356  :                 test ();

  0082d	e8 00 00 00 00	 call	 _test

; 357  :                 if (s > 0)

  00832	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR _s$[ebp], 0
  00839	0f 8e 85 00 00
	00		 jle	 $LN14@search_4i4

; 358  :                 {
; 359  :                    psk = sq;            move16 ();

  0083f	66 8b 85 54 ff
	ff ff		 mov	 ax, WORD PTR _sq$[ebp]
  00846	66 89 85 78 ff
	ff ff		 mov	 WORD PTR _psk$[ebp], ax
  0084d	e8 00 00 00 00	 call	 _move16

; 360  :                    alpk = alp;          move16 ();

  00852	66 8b 85 30 ff
	ff ff		 mov	 ax, WORD PTR _alp$[ebp]
  00859	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _alpk$[ebp], ax
  00860	e8 00 00 00 00	 call	 _move16

; 361  :                    codvec[0] = i0;      move16 ();

  00865	b8 02 00 00 00	 mov	 eax, 2
  0086a	6b c8 00	 imul	 ecx, eax, 0
  0086d	8b 55 14	 mov	 edx, DWORD PTR _codvec$[ebp]
  00870	66 8b 45 f4	 mov	 ax, WORD PTR _i0$[ebp]
  00874	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00878	e8 00 00 00 00	 call	 _move16

; 362  :                    codvec[1] = i1;      move16 ();

  0087d	b8 02 00 00 00	 mov	 eax, 2
  00882	c1 e0 00	 shl	 eax, 0
  00885	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  00888	66 8b 55 e8	 mov	 dx, WORD PTR _i1$[ebp]
  0088c	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00890	e8 00 00 00 00	 call	 _move16

; 363  :                    codvec[2] = i2;      move16 ();

  00895	b8 02 00 00 00	 mov	 eax, 2
  0089a	d1 e0		 shl	 eax, 1
  0089c	8b 4d 14	 mov	 ecx, DWORD PTR _codvec$[ebp]
  0089f	66 8b 55 dc	 mov	 dx, WORD PTR _i2$[ebp]
  008a3	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  008a7	e8 00 00 00 00	 call	 _move16

; 364  :                    codvec[3] = ix;      move16 ();

  008ac	b8 02 00 00 00	 mov	 eax, 2
  008b1	6b c8 03	 imul	 ecx, eax, 3
  008b4	8b 55 14	 mov	 edx, DWORD PTR _codvec$[ebp]
  008b7	66 8b 45 c4	 mov	 ax, WORD PTR _ix$[ebp]
  008bb	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  008bf	e8 00 00 00 00	 call	 _move16
$LN14@search_4i4:

; 365  :                 }
; 366  :              }
; 367  :           }

  008c4	e9 8e f8 ff ff	 jmp	 $LN16@search_4i4
$LN15@search_4i4:

; 368  :           
; 369  :           /*----------------------------------------------------------------*
; 370  :            * Cyclic permutation of i0,i1,i2 and i3.                         *
; 371  :            *----------------------------------------------------------------*/
; 372  :           
; 373  :           pos = ipos[3];                   move16 ();

  008c9	b8 02 00 00 00	 mov	 eax, 2
  008ce	6b c8 03	 imul	 ecx, eax, 3
  008d1	66 8b 54 0d 84	 mov	 dx, WORD PTR _ipos$[ebp+ecx]
  008d6	66 89 55 a0	 mov	 WORD PTR _pos$[ebp], dx
  008da	e8 00 00 00 00	 call	 _move16

; 374  :           ipos[3] = ipos[2];               move16 ();

  008df	b8 02 00 00 00	 mov	 eax, 2
  008e4	d1 e0		 shl	 eax, 1
  008e6	b9 02 00 00 00	 mov	 ecx, 2
  008eb	6b d1 03	 imul	 edx, ecx, 3
  008ee	66 8b 44 05 84	 mov	 ax, WORD PTR _ipos$[ebp+eax]
  008f3	66 89 44 15 84	 mov	 WORD PTR _ipos$[ebp+edx], ax
  008f8	e8 00 00 00 00	 call	 _move16

; 375  :           ipos[2] = ipos[1];               move16 ();

  008fd	b8 02 00 00 00	 mov	 eax, 2
  00902	c1 e0 00	 shl	 eax, 0
  00905	b9 02 00 00 00	 mov	 ecx, 2
  0090a	d1 e1		 shl	 ecx, 1
  0090c	66 8b 54 05 84	 mov	 dx, WORD PTR _ipos$[ebp+eax]
  00911	66 89 54 0d 84	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  00916	e8 00 00 00 00	 call	 _move16

; 376  :           ipos[1] = ipos[0];               move16 ();

  0091b	b8 02 00 00 00	 mov	 eax, 2
  00920	6b c8 00	 imul	 ecx, eax, 0
  00923	ba 02 00 00 00	 mov	 edx, 2
  00928	c1 e2 00	 shl	 edx, 0
  0092b	66 8b 44 0d 84	 mov	 ax, WORD PTR _ipos$[ebp+ecx]
  00930	66 89 44 15 84	 mov	 WORD PTR _ipos$[ebp+edx], ax
  00935	e8 00 00 00 00	 call	 _move16

; 377  :           ipos[0] = pos;                   move16 ();

  0093a	b8 02 00 00 00	 mov	 eax, 2
  0093f	6b c8 00	 imul	 ecx, eax, 0
  00942	66 8b 55 a0	 mov	 dx, WORD PTR _pos$[ebp]
  00946	66 89 54 0d 84	 mov	 WORD PTR _ipos$[ebp+ecx], dx
  0094b	e8 00 00 00 00	 call	 _move16

; 378  :        }

  00950	e9 d1 f7 ff ff	 jmp	 $LN19@search_4i4
$LN18@search_4i4:

; 379  :     }

  00955	e9 38 f7 ff ff	 jmp	 $LN22@search_4i4
$LN28@search_4i4:

; 380  :     
; 381  :     return;
; 382  : }

  0095a	52		 push	 edx
  0095b	8b cd		 mov	 ecx, ebp
  0095d	50		 push	 eax
  0095e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN33@search_4i4
  00964	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00969	58		 pop	 eax
  0096a	5a		 pop	 edx
  0096b	5f		 pop	 edi
  0096c	5e		 pop	 esi
  0096d	5b		 pop	 ebx
  0096e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00971	33 cd		 xor	 ecx, ebp
  00973	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00978	81 c4 d0 01 00
	00		 add	 esp, 464		; 000001d0H
  0097e	3b ec		 cmp	 ebp, esp
  00980	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00985	8b e5		 mov	 esp, ebp
  00987	5d		 pop	 ebp
  00988	c3		 ret	 0
  00989	8d 49 00	 npad	 3
$LN33@search_4i4:
  0098c	01 00 00 00	 DD	 1
  00990	00 00 00 00	 DD	 $LN32@search_4i4
$LN32@search_4i4:
  00994	84 ff ff ff	 DD	 -124			; ffffff84H
  00998	08 00 00 00	 DD	 8
  0099c	00 00 00 00	 DD	 $LN31@search_4i4
$LN31@search_4i4:
  009a0	69		 DB	 105			; 00000069H
  009a1	70		 DB	 112			; 00000070H
  009a2	6f		 DB	 111			; 0000006fH
  009a3	73		 DB	 115			; 00000073H
  009a4	00		 DB	 0
_search_4i40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c4_17pf.c
;	COMDAT _code_4i40_17bits
_TEXT	SEGMENT
_sharp$ = -3524						; size = 2
_index$ = -3512						; size = 2
_i$ = -3500						; size = 2
_rr$ = -3488						; size = 3200
_dn_sign$ = -280					; size = 80
_dn2$ = -192						; size = 80
_dn$ = -104						; size = 80
_codvec$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_h$ = 12						; size = 4
_T0$ = 16						; size = 2
_pitch_sharp$ = 20					; size = 2
_code$ = 24						; size = 4
_y$ = 28						; size = 4
_sign$ = 32						; size = 4
_code_4i40_17bits PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 0e 00
	00		 sub	 esp, 3720		; 00000e88H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 78 f1 ff
	ff		 lea	 edi, DWORD PTR [ebp-3720]
  00012	b9 a2 03 00 00	 mov	 ecx, 930		; 000003a2H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 106  :     Word16 codvec[NB_PULSE];
; 107  :     Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
; 108  :     Word16 rr[L_CODE][L_CODE];
; 109  :     Word16 i, index, sharp;
; 110  : 
; 111  :     sharp = shl(pitch_sharp, 1);

  00028	6a 01		 push	 1
  0002a	0f b7 45 14	 movzx	 eax, WORD PTR _pitch_sharp$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _shl
  00034	83 c4 08	 add	 esp, 8
  00037	66 89 85 3c f2
	ff ff		 mov	 WORD PTR _sharp$[ebp], ax

; 112  :     test ();

  0003e	e8 00 00 00 00	 call	 _test

; 113  :     if (sub(T0, L_CODE) < 0)

  00043	6a 28		 push	 40			; 00000028H
  00045	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _sub
  0004f	83 c4 08	 add	 esp, 8
  00052	0f bf c8	 movsx	 ecx, ax
  00055	85 c9		 test	 ecx, ecx
  00057	0f 8d 80 00 00
	00		 jge	 $LN8@code_4i40_

; 114  :     {
; 115  :        for (i = T0; i < L_CODE; i++) {

  0005d	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00061	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  00068	eb 12		 jmp	 SHORT $LN7@code_4i40_
$LN6@code_4i40_:
  0006a	66 8b 85 54 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN7@code_4i40_:
  0007c	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  00083	83 f8 28	 cmp	 eax, 40			; 00000028H
  00086	7d 55		 jge	 SHORT $LN8@code_4i40_

; 116  :           h[i] = add(h[i], mult(h[i - T0], sharp));   move16 ();

  00088	0f b7 85 3c f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  0008f	50		 push	 eax
  00090	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00097	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  0009b	2b ca		 sub	 ecx, edx
  0009d	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  000a0	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _mult
  000aa	83 c4 08	 add	 esp, 8
  000ad	0f b7 d0	 movzx	 edx, ax
  000b0	52		 push	 edx
  000b1	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  000bb	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _add
  000c5	83 c4 08	 add	 esp, 8
  000c8	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  000cf	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000d2	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  000d6	e8 00 00 00 00	 call	 _move16

; 117  :        }

  000db	eb 8d		 jmp	 SHORT $LN6@code_4i40_
$LN8@code_4i40_:

; 118  :     }
; 119  :     
; 120  :     cor_h_x(h, x, dn, 1);

  000dd	6a 01		 push	 1
  000df	8d 45 98	 lea	 eax, DWORD PTR _dn$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 _cor_h_x
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 121  :     set_sign(dn, dn_sign, dn2, 4);

  000f3	6a 04		 push	 4
  000f5	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _dn2$[ebp]
  000fb	50		 push	 eax
  000fc	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00102	51		 push	 ecx
  00103	8d 55 98	 lea	 edx, DWORD PTR _dn$[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 _set_sign
  0010c	83 c4 10	 add	 esp, 16			; 00000010H

; 122  :     cor_h(h, dn_sign, rr);

  0010f	8d 85 60 f2 ff
	ff		 lea	 eax, DWORD PTR _rr$[ebp]
  00115	50		 push	 eax
  00116	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _cor_h
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  :     search_4i40(dn, dn2, rr, codvec);

  00129	8d 45 f0	 lea	 eax, DWORD PTR _codvec$[ebp]
  0012c	50		 push	 eax
  0012d	8d 8d 60 f2 ff
	ff		 lea	 ecx, DWORD PTR _rr$[ebp]
  00133	51		 push	 ecx
  00134	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _dn2$[ebp]
  0013a	52		 push	 edx
  0013b	8d 45 98	 lea	 eax, DWORD PTR _dn$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _search_4i40
  00144	83 c4 10	 add	 esp, 16			; 00000010H

; 124  :                                     move16 (); /* function result */

  00147	e8 00 00 00 00	 call	 _move16

; 125  :     index = build_code(codvec, dn_sign, code, h, y, sign);

  0014c	8b 45 20	 mov	 eax, DWORD PTR _sign$[ebp]
  0014f	50		 push	 eax
  00150	8b 4d 1c	 mov	 ecx, DWORD PTR _y$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 0c	 mov	 edx, DWORD PTR _h$[ebp]
  00157	52		 push	 edx
  00158	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  0015b	50		 push	 eax
  0015c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _dn_sign$[ebp]
  00162	51		 push	 ecx
  00163	8d 55 f0	 lea	 edx, DWORD PTR _codvec$[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 _build_code
  0016c	83 c4 18	 add	 esp, 24			; 00000018H
  0016f	66 89 85 48 f2
	ff ff		 mov	 WORD PTR _index$[ebp], ax

; 126  : 
; 127  :   /*-----------------------------------------------------------------*
; 128  :   * Compute innovation vector gain.                                 *
; 129  :   * Include fixed-gain pitch contribution into code[].              *
; 130  :   *-----------------------------------------------------------------*/
; 131  : 
; 132  :     test ();

  00176	e8 00 00 00 00	 call	 _test

; 133  :     if (sub(T0, L_CODE) < 0)

  0017b	6a 28		 push	 40			; 00000028H
  0017d	0f b7 45 10	 movzx	 eax, WORD PTR _T0$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _sub
  00187	83 c4 08	 add	 esp, 8
  0018a	0f bf c8	 movsx	 ecx, ax
  0018d	85 c9		 test	 ecx, ecx
  0018f	0f 8d 80 00 00
	00		 jge	 $LN4@code_4i40_

; 134  :     {
; 135  :        for (i = T0; i < L_CODE; i++) {

  00195	66 8b 45 10	 mov	 ax, WORD PTR _T0$[ebp]
  00199	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
  001a0	eb 12		 jmp	 SHORT $LN3@code_4i40_
$LN2@code_4i40_:
  001a2	66 8b 85 54 f2
	ff ff		 mov	 ax, WORD PTR _i$[ebp]
  001a9	66 83 c0 01	 add	 ax, 1
  001ad	66 89 85 54 f2
	ff ff		 mov	 WORD PTR _i$[ebp], ax
$LN3@code_4i40_:
  001b4	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001bb	83 f8 28	 cmp	 eax, 40			; 00000028H
  001be	7d 55		 jge	 SHORT $LN4@code_4i40_

; 136  :           code[i] = add(code[i], mult(code[i - T0], sharp));  move16 ();

  001c0	0f b7 85 3c f2
	ff ff		 movzx	 eax, WORD PTR _sharp$[ebp]
  001c7	50		 push	 eax
  001c8	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  001cf	0f bf 55 10	 movsx	 edx, WORD PTR _T0$[ebp]
  001d3	2b ca		 sub	 ecx, edx
  001d5	8b 45 18	 mov	 eax, DWORD PTR _code$[ebp]
  001d8	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  001dc	51		 push	 ecx
  001dd	e8 00 00 00 00	 call	 _mult
  001e2	83 c4 08	 add	 esp, 8
  001e5	0f b7 d0	 movzx	 edx, ax
  001e8	52		 push	 edx
  001e9	0f bf 85 54 f2
	ff ff		 movsx	 eax, WORD PTR _i$[ebp]
  001f0	8b 4d 18	 mov	 ecx, DWORD PTR _code$[ebp]
  001f3	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  001f7	52		 push	 edx
  001f8	e8 00 00 00 00	 call	 _add
  001fd	83 c4 08	 add	 esp, 8
  00200	0f bf 8d 54 f2
	ff ff		 movsx	 ecx, WORD PTR _i$[ebp]
  00207	8b 55 18	 mov	 edx, DWORD PTR _code$[ebp]
  0020a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0020e	e8 00 00 00 00	 call	 _move16

; 137  :        }

  00213	eb 8d		 jmp	 SHORT $LN2@code_4i40_
$LN4@code_4i40_:

; 138  :     }
; 139  :     return index;

  00215	66 8b 85 48 f2
	ff ff		 mov	 ax, WORD PTR _index$[ebp]

; 140  : }

  0021c	52		 push	 edx
  0021d	8b cd		 mov	 ecx, ebp
  0021f	50		 push	 eax
  00220	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@code_4i40_
  00226	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022b	58		 pop	 eax
  0022c	5a		 pop	 edx
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi
  0022f	5b		 pop	 ebx
  00230	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00233	33 cd		 xor	 ecx, ebp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	81 c4 88 0e 00
	00		 add	 esp, 3720		; 00000e88H
  00240	3b ec		 cmp	 ebp, esp
  00242	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
  0024b	90		 npad	 1
$LN17@code_4i40_:
  0024c	05 00 00 00	 DD	 5
  00250	00 00 00 00	 DD	 $LN16@code_4i40_
$LN16@code_4i40_:
  00254	f0 ff ff ff	 DD	 -16			; fffffff0H
  00258	08 00 00 00	 DD	 8
  0025c	00 00 00 00	 DD	 $LN11@code_4i40_
  00260	98 ff ff ff	 DD	 -104			; ffffff98H
  00264	50 00 00 00	 DD	 80			; 00000050H
  00268	00 00 00 00	 DD	 $LN12@code_4i40_
  0026c	40 ff ff ff	 DD	 -192			; ffffff40H
  00270	50 00 00 00	 DD	 80			; 00000050H
  00274	00 00 00 00	 DD	 $LN13@code_4i40_
  00278	e8 fe ff ff	 DD	 -280			; fffffee8H
  0027c	50 00 00 00	 DD	 80			; 00000050H
  00280	00 00 00 00	 DD	 $LN14@code_4i40_
  00284	60 f2 ff ff	 DD	 -3488			; fffff260H
  00288	80 0c 00 00	 DD	 3200			; 00000c80H
  0028c	00 00 00 00	 DD	 $LN15@code_4i40_
$LN15@code_4i40_:
  00290	72		 DB	 114			; 00000072H
  00291	72		 DB	 114			; 00000072H
  00292	00		 DB	 0
$LN14@code_4i40_:
  00293	64		 DB	 100			; 00000064H
  00294	6e		 DB	 110			; 0000006eH
  00295	5f		 DB	 95			; 0000005fH
  00296	73		 DB	 115			; 00000073H
  00297	69		 DB	 105			; 00000069H
  00298	67		 DB	 103			; 00000067H
  00299	6e		 DB	 110			; 0000006eH
  0029a	00		 DB	 0
$LN13@code_4i40_:
  0029b	64		 DB	 100			; 00000064H
  0029c	6e		 DB	 110			; 0000006eH
  0029d	32		 DB	 50			; 00000032H
  0029e	00		 DB	 0
$LN12@code_4i40_:
  0029f	64		 DB	 100			; 00000064H
  002a0	6e		 DB	 110			; 0000006eH
  002a1	00		 DB	 0
$LN11@code_4i40_:
  002a2	63		 DB	 99			; 00000063H
  002a3	6f		 DB	 111			; 0000006fH
  002a4	64		 DB	 100			; 00000064H
  002a5	76		 DB	 118			; 00000076H
  002a6	65		 DB	 101			; 00000065H
  002a7	63		 DB	 99			; 00000063H
  002a8	00		 DB	 0
_code_4i40_17bits ENDP
_TEXT	ENDS
END
