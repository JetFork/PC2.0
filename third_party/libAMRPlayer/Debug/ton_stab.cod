; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ton_stab.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ton_stab_id
CONST	SEGMENT
_ton_stab_id DB	'@(#)$Id $$Id $', 00H
CONST	ENDS
PUBLIC	_ton_stab_init
PUBLIC	_ton_stab_reset
PUBLIC	_ton_stab_exit
PUBLIC	_check_lsp
PUBLIC	_check_gp_clipping
PUBLIC	_update_gp_clipping
PUBLIC	??_C@_0CC@PJONLNHF@ton_stab_init?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CP@INLPDEPL@ton_stab_init?3?5can?5not?5malloc?5st@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_shr:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	_Set_zero:PROC
EXTRN	_Copy:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CP@INLPDEPL@ton_stab_init?3?5can?5not?5malloc?5st@
CONST	SEGMENT
??_C@_0CP@INLPDEPL@ton_stab_init?3?5can?5not?5malloc?5st@ DB 'ton_stab_in'
	DB	'it: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PJONLNHF@ton_stab_init?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@PJONLNHF@ton_stab_init?3?5invalid?5parameter@ DB 'ton_stab_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _update_gp_clipping
_TEXT	SEGMENT
_st$ = 8						; size = 4
_g_pitch$ = 12						; size = 2
_update_gp_clipping PROC				; COMDAT

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 238  :    Copy(&st->gp[1], &st->gp[0], N_FRAME-1);

  0001e	6a 06		 push	 6
  00020	b8 02 00 00 00	 mov	 eax, 2
  00025	6b c8 00	 imul	 ecx, eax, 0
  00028	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0002b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0002f	50		 push	 eax
  00030	b9 02 00 00 00	 mov	 ecx, 2
  00035	c1 e1 00	 shl	 ecx, 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0003b	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _Copy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 239  :    st->gp[N_FRAME-1] = shr(g_pitch, 3);

  00048	6a 03		 push	 3
  0004a	0f b7 45 0c	 movzx	 eax, WORD PTR _g_pitch$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _shr
  00054	83 c4 08	 add	 esp, 8
  00057	b9 02 00 00 00	 mov	 ecx, 2
  0005c	6b d1 06	 imul	 edx, ecx, 6
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00062	66 89 44 11 02	 mov	 WORD PTR [ecx+edx+2], ax

; 240  : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_update_gp_clipping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _check_gp_clipping
_TEXT	SEGMENT
_sum$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_g_pitch$ = 12						; size = 2
_check_gp_clipping PROC					; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 208  :    Word16 i, sum;
; 209  :    
; 210  :    sum = shr(g_pitch, 3);          /* Division by 8 */

  0001e	6a 03		 push	 3
  00020	0f b7 45 0c	 movzx	 eax, WORD PTR _g_pitch$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _shr
  0002a	83 c4 08	 add	 esp, 8
  0002d	66 89 45 ec	 mov	 WORD PTR _sum$[ebp], ax

; 211  :    for (i = 0; i < N_FRAME; i++)

  00031	33 c0		 xor	 eax, eax
  00033	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00037	eb 0c		 jmp	 SHORT $LN5@check_gp_c
$LN4@check_gp_c:
  00039	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0003d	66 83 c0 01	 add	 ax, 1
  00041	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN5@check_gp_c:
  00045	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00049	83 f8 07	 cmp	 eax, 7
  0004c	7d 20		 jge	 SHORT $LN3@check_gp_c

; 212  :    {
; 213  :       sum = add(sum, st->gp[i]);

  0004e	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00055	0f b7 54 41 02	 movzx	 edx, WORD PTR [ecx+eax*2+2]
  0005a	52		 push	 edx
  0005b	0f b7 45 ec	 movzx	 eax, WORD PTR _sum$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _add
  00065	83 c4 08	 add	 esp, 8
  00068	66 89 45 ec	 mov	 WORD PTR _sum$[ebp], ax

; 214  :    }

  0006c	eb cb		 jmp	 SHORT $LN4@check_gp_c
$LN3@check_gp_c:

; 215  : 
; 216  :    test ();

  0006e	e8 00 00 00 00	 call	 _test

; 217  :    if (sub(sum, GP_CLIP) > 0)

  00073	68 cd 3c 00 00	 push	 15565			; 00003ccdH
  00078	0f b7 45 ec	 movzx	 eax, WORD PTR _sum$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _sub
  00082	83 c4 08	 add	 esp, 8
  00085	0f bf c8	 movsx	 ecx, ax
  00088	85 c9		 test	 ecx, ecx
  0008a	7e 09		 jle	 SHORT $LN2@check_gp_c

; 218  :    {
; 219  :       return 1;

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	eb 04		 jmp	 SHORT $LN6@check_gp_c

; 220  :    }
; 221  :    else

  00093	eb 02		 jmp	 SHORT $LN6@check_gp_c
$LN2@check_gp_c:

; 222  :    {
; 223  :       return 0;

  00095	33 c0		 xor	 eax, eax
$LN6@check_gp_c:

; 224  :    }
; 225  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_check_gp_clipping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _check_lsp
_TEXT	SEGMENT
_dist_th$ = -56						; size = 2
_dist_min2$ = -44					; size = 2
_dist_min1$ = -32					; size = 2
_dist$ = -20						; size = 2
_i$ = -8						; size = 2
_st$ = 8						; size = 4
_lsp$ = 12						; size = 4
_check_lsp PROC						; COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 130  :    Word16 i, dist, dist_min1, dist_min2, dist_th;
; 131  :  
; 132  :    /* Check for a resonance:                             */
; 133  :    /* Find minimum distance between lsp[i] and lsp[i+1]  */
; 134  :  
; 135  :    dist_min1 = MAX_16;                       move16 ();

  0001e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00023	66 89 45 e0	 mov	 WORD PTR _dist_min1$[ebp], ax
  00027	e8 00 00 00 00	 call	 _move16

; 136  :    for (i = 3; i < M-2; i++)

  0002c	b8 03 00 00 00	 mov	 eax, 3
  00031	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  00035	eb 0c		 jmp	 SHORT $LN17@check_lsp
$LN16@check_lsp:
  00037	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  0003b	66 83 c0 01	 add	 ax, 1
  0003f	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN17@check_lsp:
  00043	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00047	83 f8 08	 cmp	 eax, 8
  0004a	7d 52		 jge	 SHORT $LN15@check_lsp

; 137  :    {
; 138  :       dist = sub(lsp[i], lsp[i+1]);

  0004c	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  00053	0f b7 54 41 02	 movzx	 edx, WORD PTR [ecx+eax*2+2]
  00058	52		 push	 edx
  00059	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  00060	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _sub
  0006a	83 c4 08	 add	 esp, 8
  0006d	66 89 45 ec	 mov	 WORD PTR _dist$[ebp], ax

; 139  : 
; 140  :       test ();

  00071	e8 00 00 00 00	 call	 _test

; 141  :       if (sub(dist, dist_min1) < 0)

  00076	0f b7 45 e0	 movzx	 eax, WORD PTR _dist_min1$[ebp]
  0007a	50		 push	 eax
  0007b	0f b7 4d ec	 movzx	 ecx, WORD PTR _dist$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _sub
  00085	83 c4 08	 add	 esp, 8
  00088	0f bf d0	 movsx	 edx, ax
  0008b	85 d2		 test	 edx, edx
  0008d	7d 0d		 jge	 SHORT $LN14@check_lsp

; 142  :       {
; 143  :          dist_min1 = dist;                   move16 ();

  0008f	66 8b 45 ec	 mov	 ax, WORD PTR _dist$[ebp]
  00093	66 89 45 e0	 mov	 WORD PTR _dist_min1$[ebp], ax
  00097	e8 00 00 00 00	 call	 _move16
$LN14@check_lsp:

; 144  :       }
; 145  :    }

  0009c	eb 99		 jmp	 SHORT $LN16@check_lsp
$LN15@check_lsp:

; 146  : 
; 147  :    dist_min2 = MAX_16;                       move16 ();

  0009e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000a3	66 89 45 d4	 mov	 WORD PTR _dist_min2$[ebp], ax
  000a7	e8 00 00 00 00	 call	 _move16

; 148  :    for (i = 1; i < 3; i++)

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
  000b5	eb 0c		 jmp	 SHORT $LN13@check_lsp
$LN12@check_lsp:
  000b7	66 8b 45 f8	 mov	 ax, WORD PTR _i$[ebp]
  000bb	66 83 c0 01	 add	 ax, 1
  000bf	66 89 45 f8	 mov	 WORD PTR _i$[ebp], ax
$LN13@check_lsp:
  000c3	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000c7	83 f8 03	 cmp	 eax, 3
  000ca	7d 52		 jge	 SHORT $LN11@check_lsp

; 149  :    {
; 150  :       dist = sub(lsp[i], lsp[i+1]);

  000cc	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  000d3	0f b7 54 41 02	 movzx	 edx, WORD PTR [ecx+eax*2+2]
  000d8	52		 push	 edx
  000d9	0f bf 45 f8	 movsx	 eax, WORD PTR _i$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  000e0	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _sub
  000ea	83 c4 08	 add	 esp, 8
  000ed	66 89 45 ec	 mov	 WORD PTR _dist$[ebp], ax

; 151  : 
; 152  :       test ();

  000f1	e8 00 00 00 00	 call	 _test

; 153  :       if (sub(dist, dist_min2) < 0)

  000f6	0f b7 45 d4	 movzx	 eax, WORD PTR _dist_min2$[ebp]
  000fa	50		 push	 eax
  000fb	0f b7 4d ec	 movzx	 ecx, WORD PTR _dist$[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 _sub
  00105	83 c4 08	 add	 esp, 8
  00108	0f bf d0	 movsx	 edx, ax
  0010b	85 d2		 test	 edx, edx
  0010d	7d 0d		 jge	 SHORT $LN10@check_lsp

; 154  :       {
; 155  :          dist_min2 = dist;                   move16 ();

  0010f	66 8b 45 ec	 mov	 ax, WORD PTR _dist$[ebp]
  00113	66 89 45 d4	 mov	 WORD PTR _dist_min2$[ebp], ax
  00117	e8 00 00 00 00	 call	 _move16
$LN10@check_lsp:

; 156  :       }
; 157  :    }

  0011c	eb 99		 jmp	 SHORT $LN12@check_lsp
$LN11@check_lsp:

; 158  : 
; 159  :    if (test (), sub(lsp[1], 32000) > 0)

  0011e	e8 00 00 00 00	 call	 _test
  00123	68 00 7d 00 00	 push	 32000			; 00007d00H
  00128	b8 02 00 00 00	 mov	 eax, 2
  0012d	c1 e0 00	 shl	 eax, 0
  00130	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  00133	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 _sub
  0013d	83 c4 08	 add	 esp, 8
  00140	98		 cwde
  00141	85 c0		 test	 eax, eax
  00143	7e 10		 jle	 SHORT $LN9@check_lsp

; 160  :    {
; 161  :       dist_th = 600;                         move16 ();

  00145	b8 58 02 00 00	 mov	 eax, 600		; 00000258H
  0014a	66 89 45 c8	 mov	 WORD PTR _dist_th$[ebp], ax
  0014e	e8 00 00 00 00	 call	 _move16
  00153	eb 45		 jmp	 SHORT $LN8@check_lsp
$LN9@check_lsp:

; 162  :    }
; 163  :    else if (test (), sub(lsp[1], 30500) > 0)

  00155	e8 00 00 00 00	 call	 _test
  0015a	68 24 77 00 00	 push	 30500			; 00007724H
  0015f	b8 02 00 00 00	 mov	 eax, 2
  00164	c1 e0 00	 shl	 eax, 0
  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _lsp$[ebp]
  0016a	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0016e	52		 push	 edx
  0016f	e8 00 00 00 00	 call	 _sub
  00174	83 c4 08	 add	 esp, 8
  00177	98		 cwde
  00178	85 c0		 test	 eax, eax
  0017a	7e 10		 jle	 SHORT $LN7@check_lsp

; 164  :    {
; 165  :       dist_th = 800;                         move16 ();

  0017c	b8 20 03 00 00	 mov	 eax, 800		; 00000320H
  00181	66 89 45 c8	 mov	 WORD PTR _dist_th$[ebp], ax
  00185	e8 00 00 00 00	 call	 _move16

; 166  :    }
; 167  :    else

  0018a	eb 0e		 jmp	 SHORT $LN8@check_lsp
$LN7@check_lsp:

; 168  :    {
; 169  :       dist_th = 1100;                        move16 ();

  0018c	b8 4c 04 00 00	 mov	 eax, 1100		; 0000044cH
  00191	66 89 45 c8	 mov	 WORD PTR _dist_th$[ebp], ax
  00195	e8 00 00 00 00	 call	 _move16
$LN8@check_lsp:

; 170  :    }
; 171  : 
; 172  :    test (); test ();

  0019a	e8 00 00 00 00	 call	 _test
  0019f	e8 00 00 00 00	 call	 _test

; 173  :    if (sub(dist_min1, 1500) < 0 ||
; 174  :        sub(dist_min2, dist_th) < 0)

  001a4	68 dc 05 00 00	 push	 1500			; 000005dcH
  001a9	0f b7 45 e0	 movzx	 eax, WORD PTR _dist_min1$[ebp]
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 _sub
  001b3	83 c4 08	 add	 esp, 8
  001b6	0f bf c8	 movsx	 ecx, ax
  001b9	85 c9		 test	 ecx, ecx
  001bb	7c 19		 jl	 SHORT $LN4@check_lsp
  001bd	0f b7 45 c8	 movzx	 eax, WORD PTR _dist_th$[ebp]
  001c1	50		 push	 eax
  001c2	0f b7 4d d4	 movzx	 ecx, WORD PTR _dist_min2$[ebp]
  001c6	51		 push	 ecx
  001c7	e8 00 00 00 00	 call	 _sub
  001cc	83 c4 08	 add	 esp, 8
  001cf	0f bf d0	 movsx	 edx, ax
  001d2	85 d2		 test	 edx, edx
  001d4	7d 19		 jge	 SHORT $LN5@check_lsp
$LN4@check_lsp:

; 175  :    {
; 176  :       st->count = add(st->count, 1);

  001d6	6a 01		 push	 1
  001d8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001db	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 _add
  001e4	83 c4 08	 add	 esp, 8
  001e7	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  001ea	66 89 02	 mov	 WORD PTR [edx], ax

; 177  :    }
; 178  :    else

  001ed	eb 0d		 jmp	 SHORT $LN3@check_lsp
$LN5@check_lsp:

; 179  :    {
; 180  :       st->count = 0;                         move16 ();

  001ef	33 c0		 xor	 eax, eax
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  001f4	66 89 01	 mov	 WORD PTR [ecx], ax
  001f7	e8 00 00 00 00	 call	 _move16
$LN3@check_lsp:

; 181  :    }
; 182  :    
; 183  :    /* Need 12 consecutive frames to set the flag */
; 184  :    test ();

  001fc	e8 00 00 00 00	 call	 _test

; 185  :    if (sub(st->count, 12) >= 0)

  00201	6a 0c		 push	 12			; 0000000cH
  00203	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00206	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 _sub
  0020f	83 c4 08	 add	 esp, 8
  00212	0f bf d0	 movsx	 edx, ax
  00215	85 d2		 test	 edx, edx
  00217	7c 19		 jl	 SHORT $LN2@check_lsp

; 186  :    {
; 187  :       st->count = 12;                        move16 ();

  00219	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0021e	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00221	66 89 01	 mov	 WORD PTR [ecx], ax
  00224	e8 00 00 00 00	 call	 _move16

; 188  :       return 1;

  00229	b8 01 00 00 00	 mov	 eax, 1
  0022e	eb 04		 jmp	 SHORT $LN18@check_lsp

; 189  :    }
; 190  :    else

  00230	eb 02		 jmp	 SHORT $LN18@check_lsp
$LN2@check_lsp:

; 191  :    {
; 192  :       return 0;

  00232	33 c0		 xor	 eax, eax
$LN18@check_lsp:

; 193  :    }
; 194  : }

  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0023d	3b ec		 cmp	 ebp, esp
  0023f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
_check_lsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _ton_stab_exit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ton_stab_exit PROC					; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 109  :     if (state == NULL || *state == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@ton_stab_e
  00024	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@ton_stab_e
$LN1@ton_stab_e:

; 110  :         return;

  0002c	eb 21		 jmp	 SHORT $LN3@ton_stab_e
$LN2@ton_stab_e:

; 111  : 
; 112  :     /* deallocate memory */
; 113  :     free(*state);

  0002e	8b f4		 mov	 esi, esp
  00030	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 114  :     *state = NULL;

  00046	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@ton_stab_e:

; 115  :     
; 116  :     return;
; 117  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_ton_stab_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _ton_stab_reset
_TEXT	SEGMENT
_st$ = 8						; size = 4
_ton_stab_reset PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 88   :     if (st == (tonStabState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@ton_stab_r

; 89   :         fprintf(stderr, "ton_stab_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PJONLNHF@ton_stab_init?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 1b		 jmp	 SHORT $LN2@ton_stab_r
$LN1@ton_stab_r:

; 91   :     }
; 92   : 
; 93   :     /* initialize tone stabilizer state */ 
; 94   :     st->count = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax

; 95   :     Set_zero(st->gp, N_FRAME);    /* Init Gp_Clipping */

  00061	6a 07		 push	 7
  00063	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00066	83 c0 02	 add	 eax, 2
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _Set_zero
  0006f	83 c4 08	 add	 esp, 8

; 96   :     
; 97   :     return 0;

  00072	33 c0		 xor	 eax, eax
$LN2@ton_stab_r:

; 98   : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_ton_stab_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ton_stab.c
;	COMDAT _ton_stab_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_state$ = 8						; size = 4
_ton_stab_init PROC					; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 58   :     tonStabState* s;
; 59   :     
; 60   :     if (state == (tonStabState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _state$[ebp], 0
  00022	75 35		 jne	 SHORT $LN2@ton_stab_i

; 61   :         fprintf(stderr, "ton_stab_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PJONLNHF@ton_stab_init?3?5invalid?5parameter@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 71		 jmp	 SHORT $LN3@ton_stab_i
$LN2@ton_stab_i:

; 63   :     }
; 64   :     *state = NULL;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 65   :     
; 66   :     /* allocate memory */
; 67   :     if ((s= (tonStabState *) malloc(sizeof(tonStabState))) == NULL){

  00062	8b f4		 mov	 esi, esp
  00064	6a 10		 push	 16			; 00000010H
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006c	83 c4 04	 add	 esp, 4
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  00079	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007d	75 35		 jne	 SHORT $LN1@ton_stab_i

; 68   :         fprintf(stderr, "ton_stab_init: can not malloc state structure\n");

  0007f	8b f4		 mov	 esi, esp
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@INLPDEPL@ton_stab_init?3?5can?5not?5malloc?5st@
  00086	8b fc		 mov	 edi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0008e	3b fc		 cmp	 edi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009a	d1 e1		 shl	 ecx, 1
  0009c	03 c1		 add	 eax, ecx
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :         return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 16		 jmp	 SHORT $LN3@ton_stab_i
$LN1@ton_stab_i:

; 70   :     }
; 71   :     
; 72   :     ton_stab_reset(s);

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _ton_stab_reset
  000bd	83 c4 04	 add	 esp, 4

; 73   :     
; 74   :     *state = s;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 08		 mov	 DWORD PTR [eax], ecx

; 75   :     
; 76   :     return 0;

  000c8	33 c0		 xor	 eax, eax
$LN3@ton_stab_i:

; 77   : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
_ton_stab_init ENDP
_TEXT	ENDS
END
