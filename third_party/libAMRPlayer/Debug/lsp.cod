; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\lsp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_lsp_id
CONST	SEGMENT
_lsp_id	DB	'@(#)$Id $$Id $', 00H
	ORG $+1
_lsp_init_data DW 07530H
	DW	06590H
	DW	05208H
	DW	03a98H
	DW	01f40H
	DW	00H
	DW	0e0c0H
	DW	0c568H
	DW	0adf8H
	DW	09a70H
CONST	ENDS
PUBLIC	_lsp_init
PUBLIC	_lsp_reset
PUBLIC	_lsp_exit
PUBLIC	_lsp
PUBLIC	??_C@_0BN@KJKICJBK@lsp_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@NFOOLBBG@lsp_init?3?5can?5not?5malloc?5state?5s@ ; `string'
PUBLIC	??_C@_0BO@GDGFGADI@lsp_reset?3?5invalid?5parameter?6?$AA@ ; `string'
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	_Q_plsf_init:PROC
EXTRN	_Q_plsf_reset:PROC
EXTRN	_Q_plsf_exit:PROC
EXTRN	_Q_plsf_3:PROC
EXTRN	_Q_plsf_5:PROC
EXTRN	_add:PROC
EXTRN	_sub:PROC
EXTRN	_Copy:PROC
EXTRN	_Az_lsp:PROC
EXTRN	_Int_lpc_1and3:PROC
EXTRN	_Int_lpc_1and3_2:PROC
EXTRN	_Int_lpc_1to3:PROC
EXTRN	_Int_lpc_1to3_2:PROC
EXTRN	_move16:PROC
EXTRN	_test:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BO@GDGFGADI@lsp_reset?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BO@GDGFGADI@lsp_reset?3?5invalid?5parameter?6?$AA@ DB 'lsp_reset: '
	DB	'invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NFOOLBBG@lsp_init?3?5can?5not?5malloc?5state?5s@
CONST	SEGMENT
??_C@_0CK@NFOOLBBG@lsp_init?3?5can?5not?5malloc?5state?5s@ DB 'lsp_init: '
	DB	'can not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KJKICJBK@lsp_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BN@KJKICJBK@lsp_init?3?5invalid?5parameter?6?$AA@ DB 'lsp_init: in'
	DB	'valid parameter', 0aH, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp.c
;	COMDAT _lsp
_TEXT	SEGMENT
_pred_init_i$ = -96					; size = 2
_lsp_mid_q$ = -84					; size = 20
_lsp_mid$ = -56						; size = 20
_lsp_new_q$ = -28					; size = 20
__$ArrayPad$ = -4					; size = 4
_st$ = 8						; size = 4
_req_mode$ = 12						; size = 4
_used_mode$ = 16					; size = 4
_az$ = 20						; size = 4
_azQ$ = 24						; size = 4
_lsp_new$ = 28						; size = 4
_anap$ = 32						; size = 4
_lsp	PROC						; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 142  :    Word16 lsp_new_q[M];    /* LSPs at 4th subframe           */
; 143  :    Word16 lsp_mid[M], lsp_mid_q[M];    /* LSPs at 2nd subframe           */
; 144  :   
; 145  :    Word16 pred_init_i; /* init index for MA prediction in DTX mode */
; 146  : 
; 147  :    test ();

  00028	e8 00 00 00 00	 call	 _test

; 148  :    if ( sub (req_mode, MR122) == 0)

  0002d	6a 07		 push	 7
  0002f	0f b7 45 0c	 movzx	 eax, WORD PTR _req_mode$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _sub
  00039	83 c4 08	 add	 esp, 8
  0003c	0f bf c8	 movsx	 ecx, ax
  0003f	85 c9		 test	 ecx, ecx
  00041	0f 85 cf 00 00
	00		 jne	 $LN4@lsp

; 149  :    {
; 150  :        Az_lsp (&az[MP1], lsp_mid, st->lsp_old);

  00047	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0004a	50		 push	 eax
  0004b	8d 4d c8	 lea	 ecx, DWORD PTR _lsp_mid$[ebp]
  0004e	51		 push	 ecx
  0004f	ba 02 00 00 00	 mov	 edx, 2
  00054	6b c2 0b	 imul	 eax, edx, 11
  00057	03 45 14	 add	 eax, DWORD PTR _az$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _Az_lsp
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 151  :        Az_lsp (&az[MP1 * 3], lsp_new, lsp_mid);

  00063	8d 45 c8	 lea	 eax, DWORD PTR _lsp_mid$[ebp]
  00066	50		 push	 eax
  00067	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  0006a	51		 push	 ecx
  0006b	ba 02 00 00 00	 mov	 edx, 2
  00070	6b c2 21	 imul	 eax, edx, 33
  00073	03 45 14	 add	 eax, DWORD PTR _az$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _Az_lsp
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  : 
; 153  :        /*--------------------------------------------------------------------*
; 154  :         * Find interpolated LPC parameters in all subframes (both quantized  *
; 155  :         * and unquantized).                                                  *
; 156  :         * The interpolated parameters are in array A_t[] of size (M+1)*4     *
; 157  :         * and the quantized interpolated parameters are in array Aq_t[]      *
; 158  :         *--------------------------------------------------------------------*/
; 159  :        Int_lpc_1and3_2 (st->lsp_old, lsp_mid, lsp_new, az);

  0007f	8b 45 14	 mov	 eax, DWORD PTR _az$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  00086	51		 push	 ecx
  00087	8d 55 c8	 lea	 edx, DWORD PTR _lsp_mid$[ebp]
  0008a	52		 push	 edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _Int_lpc_1and3_2
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 160  : 
; 161  :        test ();

  00097	e8 00 00 00 00	 call	 _test

; 162  :        if ( sub (used_mode, MRDTX) != 0)

  0009c	6a 08		 push	 8
  0009e	0f b7 45 10	 movzx	 eax, WORD PTR _used_mode$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _sub
  000a8	83 c4 08	 add	 esp, 8
  000ab	0f bf c8	 movsx	 ecx, ax
  000ae	85 c9		 test	 ecx, ecx
  000b0	74 5f		 je	 SHORT $LN3@lsp

; 163  :        {
; 164  :           /* LSP quantization (lsp_mid[] and lsp_new[] jointly quantized) */
; 165  :           Q_plsf_5 (st->qSt, lsp_mid, lsp_new, lsp_mid_q, lsp_new_q, *anap);

  000b2	8b 45 20	 mov	 eax, DWORD PTR _anap$[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	51		 push	 ecx
  000b8	8d 55 e4	 lea	 edx, DWORD PTR _lsp_new_q$[ebp]
  000bb	52		 push	 edx
  000bc	8d 45 ac	 lea	 eax, DWORD PTR _lsp_mid_q$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  000c3	51		 push	 ecx
  000c4	8d 55 c8	 lea	 edx, DWORD PTR _lsp_mid$[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000cb	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _Q_plsf_5
  000d4	83 c4 18	 add	 esp, 24			; 00000018H

; 166  :        
; 167  :           Int_lpc_1and3 (st->lsp_old_q, lsp_mid_q, lsp_new_q, azQ);

  000d7	8b 45 18	 mov	 eax, DWORD PTR _azQ$[ebp]
  000da	50		 push	 eax
  000db	8d 4d e4	 lea	 ecx, DWORD PTR _lsp_new_q$[ebp]
  000de	51		 push	 ecx
  000df	8d 55 ac	 lea	 edx, DWORD PTR _lsp_mid_q$[ebp]
  000e2	52		 push	 edx
  000e3	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000e6	83 c0 14	 add	 eax, 20			; 00000014H
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _Int_lpc_1and3
  000ef	83 c4 10	 add	 esp, 16			; 00000010H

; 168  :           
; 169  :           /* Advance analysis parameters pointer */
; 170  :           (*anap) += add(0,5); move16 ();

  000f2	6a 05		 push	 5
  000f4	6a 00		 push	 0
  000f6	e8 00 00 00 00	 call	 _add
  000fb	83 c4 08	 add	 esp, 8
  000fe	98		 cwde
  000ff	8b 4d 20	 mov	 ecx, DWORD PTR _anap$[ebp]
  00102	8b 11		 mov	 edx, DWORD PTR [ecx]
  00104	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00107	8b 4d 20	 mov	 ecx, DWORD PTR _anap$[ebp]
  0010a	89 01		 mov	 DWORD PTR [ecx], eax
  0010c	e8 00 00 00 00	 call	 _move16
$LN3@lsp:

; 171  :        }	 
; 172  :    }
; 173  :    else

  00111	e9 a6 00 00 00	 jmp	 $LN2@lsp
$LN4@lsp:

; 174  :    {
; 175  :        Az_lsp(&az[MP1 * 3], lsp_new, st->lsp_old);  /* From A(z) to lsp  */

  00116	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00119	50		 push	 eax
  0011a	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  0011d	51		 push	 ecx
  0011e	ba 02 00 00 00	 mov	 edx, 2
  00123	6b c2 21	 imul	 eax, edx, 33
  00126	03 45 14	 add	 eax, DWORD PTR _az$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _Az_lsp
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 176  :        
; 177  :        /*--------------------------------------------------------------------*
; 178  :         * Find interpolated LPC parameters in all subframes (both quantized  *
; 179  :         * and unquantized).                                                  *
; 180  :         * The interpolated parameters are in array A_t[] of size (M+1)*4     *
; 181  :         * and the quantized interpolated parameters are in array Aq_t[]      *
; 182  :         *--------------------------------------------------------------------*/
; 183  :        
; 184  :        Int_lpc_1to3_2(st->lsp_old, lsp_new, az);

  00132	8b 45 14	 mov	 eax, DWORD PTR _az$[ebp]
  00135	50		 push	 eax
  00136	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  00139	51		 push	 ecx
  0013a	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 _Int_lpc_1to3_2
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  :        
; 186  :        test ();

  00146	e8 00 00 00 00	 call	 _test

; 187  :        if ( sub (used_mode, MRDTX) != 0)

  0014b	6a 08		 push	 8
  0014d	0f b7 45 10	 movzx	 eax, WORD PTR _used_mode$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 _sub
  00157	83 c4 08	 add	 esp, 8
  0015a	0f bf c8	 movsx	 ecx, ax
  0015d	85 c9		 test	 ecx, ecx
  0015f	74 5b		 je	 SHORT $LN2@lsp

; 188  :        {
; 189  :           /* LSP quantization */
; 190  :           Q_plsf_3(st->qSt, req_mode, lsp_new, lsp_new_q, *anap, &pred_init_i);

  00161	8d 45 a0	 lea	 eax, DWORD PTR _pred_init_i$[ebp]
  00164	50		 push	 eax
  00165	8b 4d 20	 mov	 ecx, DWORD PTR _anap$[ebp]
  00168	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016a	52		 push	 edx
  0016b	8d 45 e4	 lea	 eax, DWORD PTR _lsp_new_q$[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  00172	51		 push	 ecx
  00173	8b 55 0c	 mov	 edx, DWORD PTR _req_mode$[ebp]
  00176	52		 push	 edx
  00177	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0017a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0017d	51		 push	 ecx
  0017e	e8 00 00 00 00	 call	 _Q_plsf_3
  00183	83 c4 18	 add	 esp, 24			; 00000018H

; 191  :           
; 192  :           Int_lpc_1to3(st->lsp_old_q, lsp_new_q, azQ);

  00186	8b 45 18	 mov	 eax, DWORD PTR _azQ$[ebp]
  00189	50		 push	 eax
  0018a	8d 4d e4	 lea	 ecx, DWORD PTR _lsp_new_q$[ebp]
  0018d	51		 push	 ecx
  0018e	8b 55 08	 mov	 edx, DWORD PTR _st$[ebp]
  00191	83 c2 14	 add	 edx, 20			; 00000014H
  00194	52		 push	 edx
  00195	e8 00 00 00 00	 call	 _Int_lpc_1to3
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 193  :           
; 194  :           /* Advance analysis parameters pointer */
; 195  :           (*anap) += add (0, 3); move16 ();

  0019d	6a 03		 push	 3
  0019f	6a 00		 push	 0
  001a1	e8 00 00 00 00	 call	 _add
  001a6	83 c4 08	 add	 esp, 8
  001a9	98		 cwde
  001aa	8b 4d 20	 mov	 ecx, DWORD PTR _anap$[ebp]
  001ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  001af	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  001b2	8b 4d 20	 mov	 ecx, DWORD PTR _anap$[ebp]
  001b5	89 01		 mov	 DWORD PTR [ecx], eax
  001b7	e8 00 00 00 00	 call	 _move16
$LN2@lsp:

; 196  :        }
; 197  :    }
; 198  :        
; 199  :    /* update the LSPs for the next frame */   
; 200  :    Copy (lsp_new, st->lsp_old, M);

  001bc	6a 0a		 push	 10			; 0000000aH
  001be	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001c1	50		 push	 eax
  001c2	8b 4d 1c	 mov	 ecx, DWORD PTR _lsp_new$[ebp]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 _Copy
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  :    Copy (lsp_new_q, st->lsp_old_q, M);

  001ce	6a 0a		 push	 10			; 0000000aH
  001d0	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  001d3	83 c0 14	 add	 eax, 20			; 00000014H
  001d6	50		 push	 eax
  001d7	8d 4d e4	 lea	 ecx, DWORD PTR _lsp_new_q$[ebp]
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _Copy
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 
; 203  :    return 0;

  001e3	33 c0		 xor	 eax, eax

; 204  : }

  001e5	52		 push	 edx
  001e6	8b cd		 mov	 ecx, ebp
  001e8	50		 push	 eax
  001e9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@lsp
  001ef	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f4	58		 pop	 eax
  001f5	5a		 pop	 edx
  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx
  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	33 cd		 xor	 ecx, ebp
  001fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00203	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00209	3b ec		 cmp	 ebp, esp
  0020b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
$LN12@lsp:
  00214	04 00 00 00	 DD	 4
  00218	00 00 00 00	 DD	 $LN11@lsp
$LN11@lsp:
  0021c	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00220	14 00 00 00	 DD	 20			; 00000014H
  00224	00 00 00 00	 DD	 $LN7@lsp
  00228	c8 ff ff ff	 DD	 -56			; ffffffc8H
  0022c	14 00 00 00	 DD	 20			; 00000014H
  00230	00 00 00 00	 DD	 $LN8@lsp
  00234	ac ff ff ff	 DD	 -84			; ffffffacH
  00238	14 00 00 00	 DD	 20			; 00000014H
  0023c	00 00 00 00	 DD	 $LN9@lsp
  00240	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00244	02 00 00 00	 DD	 2
  00248	00 00 00 00	 DD	 $LN10@lsp
$LN10@lsp:
  0024c	70		 DB	 112			; 00000070H
  0024d	72		 DB	 114			; 00000072H
  0024e	65		 DB	 101			; 00000065H
  0024f	64		 DB	 100			; 00000064H
  00250	5f		 DB	 95			; 0000005fH
  00251	69		 DB	 105			; 00000069H
  00252	6e		 DB	 110			; 0000006eH
  00253	69		 DB	 105			; 00000069H
  00254	74		 DB	 116			; 00000074H
  00255	5f		 DB	 95			; 0000005fH
  00256	69		 DB	 105			; 00000069H
  00257	00		 DB	 0
$LN9@lsp:
  00258	6c		 DB	 108			; 0000006cH
  00259	73		 DB	 115			; 00000073H
  0025a	70		 DB	 112			; 00000070H
  0025b	5f		 DB	 95			; 0000005fH
  0025c	6d		 DB	 109			; 0000006dH
  0025d	69		 DB	 105			; 00000069H
  0025e	64		 DB	 100			; 00000064H
  0025f	5f		 DB	 95			; 0000005fH
  00260	71		 DB	 113			; 00000071H
  00261	00		 DB	 0
$LN8@lsp:
  00262	6c		 DB	 108			; 0000006cH
  00263	73		 DB	 115			; 00000073H
  00264	70		 DB	 112			; 00000070H
  00265	5f		 DB	 95			; 0000005fH
  00266	6d		 DB	 109			; 0000006dH
  00267	69		 DB	 105			; 00000069H
  00268	64		 DB	 100			; 00000064H
  00269	00		 DB	 0
$LN7@lsp:
  0026a	6c		 DB	 108			; 0000006cH
  0026b	73		 DB	 115			; 00000073H
  0026c	70		 DB	 112			; 00000070H
  0026d	5f		 DB	 95			; 0000005fH
  0026e	6e		 DB	 110			; 0000006eH
  0026f	65		 DB	 101			; 00000065H
  00270	77		 DB	 119			; 00000077H
  00271	5f		 DB	 95			; 0000005fH
  00272	71		 DB	 113			; 00000071H
  00273	00		 DB	 0
_lsp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp.c
;	COMDAT _lsp_exit
_TEXT	SEGMENT
_st$ = 8						; size = 4
_lsp_exit PROC						; COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 116  :   if (st == NULL || *st == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	74 08		 je	 SHORT $LN1@lsp_exit
  00024	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00027	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002a	75 02		 jne	 SHORT $LN2@lsp_exit
$LN1@lsp_exit:

; 117  :       return;

  0002c	eb 32		 jmp	 SHORT $LN3@lsp_exit
$LN2@lsp_exit:

; 118  : 
; 119  :   /* Deallocate members */
; 120  :   Q_plsf_exit(&(*st)->qSt);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	83 c1 28	 add	 ecx, 40			; 00000028H
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _Q_plsf_exit
  0003c	83 c4 04	 add	 esp, 4

; 121  : 
; 122  :   /* deallocate memory */
; 123  :   free(*st);

  0003f	8b f4		 mov	 esi, esp
  00041	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004d	83 c4 04	 add	 esp, 4
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 124  :   *st = NULL;

  00057	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@lsp_exit:

; 125  :   
; 126  :   return;
; 127  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_lsp_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp.c
;	COMDAT _lsp_reset
_TEXT	SEGMENT
_st$ = 8						; size = 4
_lsp_reset PROC						; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 89   :   
; 90   :   if (st == (lspState *) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 35		 jne	 SHORT $LN1@lsp_reset

; 91   :       fprintf(stderr, "lsp_reset: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GDGFGADI@lsp_reset?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 92   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 41		 jmp	 SHORT $LN2@lsp_reset
$LN1@lsp_reset:

; 93   :   }
; 94   :   
; 95   :   /* Init lsp_old[] */
; 96   :   Copy(lsp_init_data, &st->lsp_old[0], M);

  00059	6a 0a		 push	 10			; 0000000aH
  0005b	b8 02 00 00 00	 mov	 eax, 2
  00060	6b c8 00	 imul	 ecx, eax, 0
  00063	03 4d 08	 add	 ecx, DWORD PTR _st$[ebp]
  00066	51		 push	 ecx
  00067	68 00 00 00 00	 push	 OFFSET _lsp_init_data
  0006c	e8 00 00 00 00	 call	 _Copy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   : 
; 98   :   /* Initialize lsp_old_q[] */
; 99   :   Copy(st->lsp_old, st->lsp_old_q, M);

  00074	6a 0a		 push	 10			; 0000000aH
  00076	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  00079	83 c0 14	 add	 eax, 20			; 00000014H
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _st$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _Copy
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :   
; 101  :   /* Reset quantization state */
; 102  :    Q_plsf_reset(st->qSt);

  00089	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0008c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 _Q_plsf_reset
  00095	83 c4 04	 add	 esp, 4

; 103  : 
; 104  :   return 0;

  00098	33 c0		 xor	 eax, eax
$LN2@lsp_reset:

; 105  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_lsp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp.c
;	COMDAT _lsp_init
_TEXT	SEGMENT
_s$ = -8						; size = 4
_st$ = 8						; size = 4
_lsp_init PROC						; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 56   :   lspState* s;
; 57   : 
; 58   :   if (st == (lspState **) NULL){

  0001e	83 7d 08 00	 cmp	 DWORD PTR _st$[ebp], 0
  00022	75 38		 jne	 SHORT $LN2@lsp_init

; 59   :       fprintf(stderr, "lsp_init: invalid parameter\n");

  00024	8b f4		 mov	 esi, esp
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@KJKICJBK@lsp_init?3?5invalid?5parameter?6?$AA@
  0002b	8b fc		 mov	 edi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00033	3b fc		 cmp	 edi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003f	d1 e1		 shl	 ecx, 1
  00041	03 c1		 add	 eax, ecx
  00043	50		 push	 eax
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 60   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 80 00 00 00	 jmp	 $LN3@lsp_init
$LN2@lsp_init:

; 61   :   }
; 62   :   
; 63   :   *st = NULL;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 64   :  
; 65   :   /* allocate memory */
; 66   :   if ((s= (lspState *) malloc(sizeof(lspState))) == NULL){

  00065	8b f4		 mov	 esi, esp
  00067	6a 2c		 push	 44			; 0000002cH
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
  0007c	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00080	75 35		 jne	 SHORT $LN1@lsp_init

; 67   :       fprintf(stderr, "lsp_init: can not malloc state structure\n");

  00082	8b f4		 mov	 esi, esp
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NFOOLBBG@lsp_init?3?5can?5not?5malloc?5state?5s@
  00089	8b fc		 mov	 edi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00091	3b fc		 cmp	 edi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0009d	d1 e1		 shl	 ecx, 1
  0009f	03 c1		 add	 eax, ecx
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  000a8	83 c4 08	 add	 esp, 8
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :       return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb 25		 jmp	 SHORT $LN3@lsp_init
$LN1@lsp_init:

; 69   :   }
; 70   : 
; 71   :   /* Initialize quantization state */
; 72   :    Q_plsf_init(&s->qSt);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ba	83 c0 28	 add	 eax, 40			; 00000028H
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _Q_plsf_init
  000c3	83 c4 04	 add	 esp, 4

; 73   : 
; 74   :   lsp_reset(s);

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _lsp_reset
  000cf	83 c4 04	 add	 esp, 4

; 75   :   *st = s;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _st$[ebp]
  000d5	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000d8	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :   
; 77   :   return 0;

  000da	33 c0		 xor	 eax, eax
$LN3@lsp_init:

; 78   : }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000e5	3b ec		 cmp	 ebp, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
_lsp_init ENDP
_TEXT	ENDS
END
