webpackJsonp([2],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Util, $, jQuery, gkClientInterface) {
	//入口页面
	__webpack_require__(306);
	
	//css文件
	__webpack_require__(98);
	__webpack_require__(106);
	__webpack_require__(307);
	__webpack_require__(308);
	
	__webpack_require__(63);
	__webpack_require__(5);
	
	//第三方依赖模块
	__webpack_require__(189);
	__webpack_require__(208);
	__webpack_require__(297);
	__webpack_require__(336);
	__webpack_require__(337);
	__webpack_require__(338);
	__webpack_require__(187);
	__webpack_require__(183);
	__webpack_require__(185);
	__webpack_require__(339);
	__webpack_require__(340);
	__webpack_require__(341);
	var io = __webpack_require__(95);
	
	angular.module('goukuai', [
	    'ui.router',
	    'LocalStorageModule',
	    'infinite-scroll',
	    'ngDialog',
	    'gettext',
	    'ui.bootstrap.datetimepicker',
	    'ngSanitize',
	    'ui.bootstrap',
	    'ng-context-menu',
	    'goukuai.common',
	    'ngDragDrop'
	])
	
	    .config(__webpack_require__(25))
	
	    .run(['gkMount','$timeout','localStorageService', '$rootScope', 'gkApi', '$q','$location','$stateParams','$state',function(gkMount,$timeout,localStorageService, $rootScope, gkApi, $q, $location,$stateParams,$state) {
	
	        moment.locale('zh-cn');
	
	        $rootScope.$on('$stateChangeStart', function (event,toState,toParam){
	            if(toParam && toParam.mountid){
	                var mount = gkMount.getMountById(toParam.mountid);
	                Util.Log.log('$stateChangeStart:mount',mount);
	                if(!mount){
	                    event.preventDefault();
	                    $state.go('index');
	                }
	            }
	        });
	
	        //文件列表默认排序
	        var fileOrder = localStorageService.get('fileOrder');
	        if (!fileOrder) localStorageService.set('fileOrder', ['-dir', '+filename']);
	
	        //初始化库
	        $rootScope.PAGE_CONFIG = {
	            view: '', //页面视图
	            listView: 'list' //文件列表视图
	        };
	
	        gkApi.entInfo().then(function(data) {
	            var ents = data && data.list;
	            if (ents && ents.length >= 0) {
	                $rootScope.PAGE_CONFIG.ents = ents;
	            }
	        });
	
	        //窗口拖拽
	        $(document).on('dragover', function(event) {
	            event.preventDefault();
	        });
	
	        $(document).on('drop', function(event) {
	            event.preventDefault();
	        });
	
	        //socket处理
	        var user,
	            socketdate,
	            cacheKey,
	            server,
	            socketUrl,
	            contactsUrl,
	            lastdate;
	
	        initSocket();
	
	        function initSocket() {
	            $q.all([gkApi.getUserInfo(), gkApi.getSocketDate(), gkApi.getSocketServer()]).then(function(data) {
	                Util.Log.log('initSocket',data);
	                user = data[0];
	                socketdate = data[1] && data[1].dateline;
	                cacheKey = user.uuid + '_socketdate';
	                server = data[2][0];
	                socketUrl = 'http://' + server.host + ':' + server.port + '/dialog';
	                contactsUrl = 'http://' + server.host + ':' + server.port + '/contacts';
	
	                gkApi.getCache({
	                    key: cacheKey
	                }).then(function(data) {
	                    getSocketData(contactsUrl, data).then(function() {
	                        lastdate = lastdate ? lastdate : data;
	                        gkApi.addCache({
	                            key: cacheKey,
	                            value: JSON.stringify(lastdate)
	                        });
	                        connectSocket();
	                    });
	                }, function() {
	                    getSocketData(contactsUrl, socketdate).then(function() {
	                        lastdate = lastdate ? lastdate : socketdate;
	                        gkApi.addCache({
	                            key: cacheKey,
	                            value: JSON.stringify(lastdate)
	                        });
	                        connectSocket();
	                    });
	                });
	            });
	        }
	
	        //socket.io出错后重新尝试的次数
	        var reconnectCount = 0;
	
	        //如果网络重新连接上将重试次数置为0
	        $rootScope.$on('LinkStatus',function(event,data){
	            if(data.link == 1 && reconnectCount > 0){
	                reconnectCount = 0;
	            }
	        });
	
	        function connectSocket(forceNew) {
	            var params = {
	                dateline: lastdate
	            };
	            gkApi.ajaxHelper().then(function(data) {
	
	                params.token = data[0];
	
	                gkApi.getApiAuthorization(params).then(function(sign) {
	                    params.sign = sign;
	
	                    Util.Log.log('socket:connect:prepare:params',params);
	
	                    gkApi.checkAuthProxy().then(function(isSet){
	                        var opts = {
	                            query: $.param(params),
	                            forceNew: angular.isDefined(forceNew) ? forceNew : false,
	                            reconnectionDelay:2000,
	                            reconnectionDelayMax:10000,
	                            timeout:30000
	                        };
	
	                        //如果设置了代理,socket.io 的 transport 优先 xhr-polling
	                        if(typeof isSet === 'undefined'|| isSet == 1){
	                            opts.transports = [
	                                'xhr-polling',
	                                'jsonp-polling',
	                                'polling'
	                            ];
	                        }
	
	                        Util.Log.log('socket:connect:init:opts',opts);
	
	                        $rootScope.PAGE_CONFIG.socket = io.connect(socketUrl, opts);
	                        $rootScope.PAGE_CONFIG.socket.on('connected', function(data) {
	                            reconnectCount = 0;
	                            Util.Log.log('socket:connected',data);
	                        });
	
	                        $rootScope.PAGE_CONFIG.socket.on('connect_error', function(err) {
	                            Util.Log.log('socket:connect:error',err);
	                        });
	                        $rootScope.PAGE_CONFIG.socket.on('connect_timeout',function(errr) {
	                            Util.Log.log('socket:connect:timeout',errr);
	                        });
	
	                        $rootScope.PAGE_CONFIG.socket.on('reconnect_error', function(errr) {
	                            Util.Log.log('socket:reconnect:error',errr);
	                        });
	
	                        $rootScope.PAGE_CONFIG.socket.on('contact', function(ret) {
	                            Util.Log.log('socket:contact:received',ret);
	                            lastdate = ret.dateline;
	                            if(ret.act){
	                                gkClient.gSocketAction(JSON.stringify(ret),function(){
	                                    if(['add_ent_role','modify_ent_role','del_ent_role'].indexOf(ret.act) >= 0){
	                                        Util.Log.log(ret.act + ' broadcast');
	                                        $rootScope.$broadcast(ret.act,ret.metadata||{});
	                                    }
	                                    if(['join_org','quit_org'].indexOf(ret.act) >= 0){
	                                        if(ret.metadata && $stateParams.mountid){
	                                            var currentMount = gkMount.getMountById($stateParams.mountid);
	                                            if(currentMount && currentMount.orgid == ret.metadata.org_id){
	                                                $rootScope.$broadcast('refreshMemberCount');
	                                            }
	                                        }
	                                    }
	                                });
	                            }
	
	                            gkApi.addCache({
	                                key: cacheKey,
	                                value: JSON.stringify(ret.dateline)
	                            });
	                        });
	
	                        $rootScope.PAGE_CONFIG.socket.on('err', function(ret) {
	                            Util.Log.log('socket:err',ret);
	                            if(forceNew){
	                                reconnectCount++;
	                            }
	                            //重新尝试连接的间隔按1秒递增
	                            $timeout(function(){
	                                Util.Log.log('socket:reconnectinng',reconnectCount);
	                                connectSocket(true);
	                            },1000 + 1000 * reconnectCount);
	                        });
	                    });
	
	                });
	            });
	        }
	
	        function getSocketData(url, dateline, deferred) {
	            var defaultSize = 1000;
	            var params = {
	                dateline: dateline || Date.now(),
	                size: defaultSize
	            };
	            deferred = deferred || $q.defer();
	            gkApi.ajaxHelper().then(function(data) {
	                params.token = data[0];
	                gkApi.getApiAuthorization(params).then(function(sign) {
	                    params.sign = sign;
	                    jQuery.ajax({
	                        type: 'GET',
	                        url: url,
	                        dataType: 'json',
	                        data: params,
	                        success: function(data) {
	                            data = data && data.list || [];
	                            gkClient.gSocketAction(JSON.stringify({
	                                list: data
	                            }), 'list');
	                            if (data.length) {
	                                lastdate = data[data.length - 1].dateline;
	                                getSocketData(url, lastdate, deferred);
	                            } else {
	                                deferred.resolve();
	                            }
	                        },
	                        error: function(err) {
	
	                        }
	                    });
	                });
	            });
	            return deferred.promise;
	        }
	    }])
	    .controller('initCtrl', ['ngDialog','gkApi','$scope', '$rootScope', '$state', 'gkFile', 'gkMount','$window','$timeout','gkModal', function(ngDialog,gkApi, $scope, $rootScope, $state, gkFile, gkMount,$window,$timeout,gkModal) {
	
	
	        $scope.bodyClick = function(e){
	            $rootScope.$broadcast('bodyClicked',e);
	            if(!$(e.target).closest('.context-menu-item').size()){
	               $rootScope.$broadcast('closeCloudCommentPanel');
	            }
	        };
	
	        $scope.$on('closeCloudCommentPanel', function() {
	            if(typeof top.window.uc.modules.cloud.CloudManager.OnCloudHideComment === 'function'){
	                top.window.uc.modules.cloud.CloudManager.OnCloudHideComment();
	            }
	        });
	
	        //文件变更，客户端通知
	        $scope.$on('UpdateFileList', function() {
	            $state.reload('index.file');
	        });
	
	        $scope.$on('$stateChangeStart', function() {
	            gkFile.clearSelectedFile();
	        });
	
	        var OpenMountPathCallback = function(data,mount){
	            $rootScope.$broadcast('clearMountSearch');
	            $timeout(function() {
	                var $mountItems = $('.mount-list-wrapper li');
	                var $wrapper = $('.mount-wrapper');
	                var wrapperHeight = $wrapper.outerHeight();
	                var pos;
	                var offsetTop;
	                var scrollItem;
	
	                $wrapper.scrollTop(0);
	                angular.forEach($mountItems, function(item, index) {
	                    var id= $(item).data('id');
	                    if (id == data.mountid) {
	                        pos = index;
	                    }
	                });
	                scrollItem = $mountItems.eq(pos);
	                if (scrollItem) {
	                    offsetTop = scrollItem.offset().top;
	                    if (offsetTop > wrapperHeight) {
	                        $wrapper.scrollTop(offsetTop - 50);
	                    }
	                }
	
	                if(data.create){
	                    ngDialog.closeAll();
	                    gkModal.addLibMember(mount);
	                }
	
	            }, 100);
	
	            gkFile.getFileInfo({
	                mountid: data.mountid,
	                fullpath: Util.String.rtrim(data.webpath,'/')
	            }).then(function(ret) {
	                var isDir = Util.String.lastChar(data.webpath) === '/';
	                var goToPath = '',
	                    selectedhash = '';
	                if(isDir){
	                    goToPath = Util.String.rtrim(data.webpath,'/');
	                }else{
	                    goToPath = gkFile.getDirName(ret.path) || '';
	                    selectedhash = ret.uuidhash || ''
	                }
	
	                $state.go('index.file', {
	                    mountid: data.mountid,
	                    fullpath: encodeURIComponent(goToPath),
	                    view: 'mount',
	                    from: 1,
	                    selectedhash: encodeURIComponent(selectedhash)
	                });
	
	            });
	        };
	
	        $scope.$on('OpenMountPath', function($event, data) {
	            Util.Log.log('OpenMountPath:received',data);
	            $('.mount-name').removeClass('open');
	            var mount = gkMount.getMountById(data.mountid);
	            if (!mount) {
	                if(data.create == 0){
	                    return;
	                }else{
	                    gkApi.notice({type: 'getMount', 'mount_id': Number(data.mountid)}).then(function(){
	                        OpenMountPathCallback(data,mount);
	                    },function(re){
	                        Util.Log.log('gkApi:notice:reject',re);
	                    });
	                }
	            }else{
	                OpenMountPathCallback(data,mount);
	            }
	        });
	
	
	        //top.window.uc.IUIService.bindCrossWindowEvent('goukuaiPreview', function(eventData) {
	        //    console.log(eventData);
	        //});
	    }])
	
	    .controller('fileCtrl', __webpack_require__(38))
	    .controller('fileHeaderCtrl', __webpack_require__(39))
	    .controller('fileBreadCtrl', __webpack_require__(37))
	    .controller('fileToolbarCtrl', __webpack_require__(41))
	    .controller('fileListCtrl', __webpack_require__(40))
	    .controller('memberCtrl', __webpack_require__(42))
	
	    .directive('fileSelect', __webpack_require__(54))
	    .directive('gkContextmenu', __webpack_require__(55))
	    .directive('dropUpload', __webpack_require__(52))
	    .directive('memberAvatar', __webpack_require__(57))
	    .factory('gkI18N', __webpack_require__(305))
	    .factory('gkMount', __webpack_require__(90))
	    .factory('gkFile', __webpack_require__(66))
	    .factory('gkImage', __webpack_require__(70))
	    .factory('gkMenu', __webpack_require__(72))
	    .factory('gkFileTpl', __webpack_require__(69))
	    .factory('gkClipboard', __webpack_require__(64))
	    .factory('gkModal', __webpack_require__(73))
	    .factory('gkQs', __webpack_require__(94))
	    .factory('gkMountMenu', __webpack_require__(91))
	    .factory('gkDialog', __webpack_require__(65))
	    .factory('gkFileCmd', __webpack_require__(68))
	    .factory('gkNoteEditor',__webpack_require__(92))
	    .directive('errorSrc', [function() {
	        Util.Log.log('errorSrc');
	        return {
	            scope: {},
	            link: function(scope, elem) {
	                var hasLoaded = false;
	                elem.on('error', function() {
	                    if (hasLoaded) {
	                        return;
	                    }
	                    hasLoaded = true;
	                    elem.attr('src', __webpack_require__(342));
	                });
	            }
	        };
	    }])
	    .directive('keyboardShortcut', __webpack_require__(56))
	    .directive('fileColResizer', __webpack_require__(53))
	;
	//手动启动angular
	Util.Log.log('document','registEvent');
	angular.element(document).ready(function() {
	    Util.Log.log('document','ready');
	    gkClient.gSetLaunchpad();
	    var onLoadComplete = function(){
	        angular.bootstrap(document, ['goukuai']);
	        top.window.uc.modules.cloud.CloudManager.OnGKLoadComplete();
	        Util.Log.log('goukuai:app','bootstrap');
	    };
	
	    //判断客户端数据加载完毕
	    gkClientInterface.needLoading(function(re) {
	        Util.Log.log('needLoading:re',re);
	        if (re == 0) {
	            onLoadComplete();
	        }else{
	            angular.element(window.top.document).on('LoadComplete',function(){
	                Util.Log.log('LoadComplete','received');
	                onLoadComplete();
	            });
	        }
	    });
	
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2), __webpack_require__(2), __webpack_require__(15)))

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["_"] = __webpack_require__(184);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function() {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;
	
	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.8.3';
	
	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };
	
	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };
	
	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };
	
	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };
	
	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };
	
	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };
	
	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };
	
	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }
	
	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);
	
	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };
	
	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };
	
	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };
	
	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };
	
	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };
	
	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });
	
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };
	
	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };
	
	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);
	
	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }
	
	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };
	
	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }
	
	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);
	
	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }
	
	    return range;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };
	
	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	
	    var later = function() {
	      var last = _.now() - timestamp;
	
	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };
	
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }
	
	      return result;
	    };
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };
	
	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };
	
	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);
	
	  // Object Functions
	  // ----------------
	
	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
	
	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
	
	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
	
	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }
	
	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);
	
	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);
	
	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };
	
	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };
	
	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);
	
	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };
	
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }
	
	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;
	
	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	
	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }
	
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	
	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }
	
	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };
	
	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };
	
	  _.noop = function(){};
	
	  _.property = property;
	
	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };
	
	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };
	
	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };
	
	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);
	
	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	
	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';
	
	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    var template = function(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };
	
	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
	
	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };
	
	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(186);
	module.exports = 'ui.bootstrap';


/***/ },
/* 186 */
/***/ function(module, exports) {

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/
	
	 * Version: 0.14.3 - 2015-10-23
	 * License: MIT
	 */
	angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-html.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.collapse', [])
	
	  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {
	    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
	    return {
	      link: function(scope, element, attrs) {
	        function expand() {
	          element.removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', true)
	            .attr('aria-hidden', false);
	
	          if ($animateCss) {
	            $animateCss(element, {
	              addClass: 'in',
	              easing: 'ease',
	              to: { height: element[0].scrollHeight + 'px' }
	            }).start().finally(expandDone);
	          } else {
	            $animate.addClass(element, 'in', {
	              to: { height: element[0].scrollHeight + 'px' }
	            }).then(expandDone);
	          }
	        }
	
	        function expandDone() {
	          element.removeClass('collapsing')
	            .addClass('collapse')
	            .css({height: 'auto'});
	        }
	
	        function collapse() {
	          if (!element.hasClass('collapse') && !element.hasClass('in')) {
	            return collapseDone();
	          }
	
	          element
	            // IMPORTANT: The height must be set before adding "collapsing" class.
	            // Otherwise, the browser attempts to animate from height 0 (in
	            // collapsing class) to the given height here.
	            .css({height: element[0].scrollHeight + 'px'})
	            // initially all panel collapse have the collapse class, this removal
	            // prevents the animation from jumping to collapsed state
	            .removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', false)
	            .attr('aria-hidden', true);
	
	          if ($animateCss) {
	            $animateCss(element, {
	              removeClass: 'in',
	              to: {height: '0'}
	            }).start().finally(collapseDone);
	          } else {
	            $animate.removeClass(element, 'in', {
	              to: {height: '0'}
	            }).then(collapseDone);
	          }
	        }
	
	        function collapseDone() {
	          element.css({height: '0'}); // Required so that collapse works when animation is disabled
	          element.removeClass('collapsing')
	            .addClass('collapse');
	        }
	
	        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);
	
	/* Deprecated collapse below */
	
	angular.module('ui.bootstrap.collapse')
	
	  .value('$collapseSuppressWarning', false)
	
	  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {
	    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
	    return {
	      link: function(scope, element, attrs) {
	        if (!$collapseSuppressWarning) {
	          $log.warn('collapse is now deprecated. Use uib-collapse instead.');
	        }
	
	        function expand() {
	          element.removeClass('collapse')
	            .addClass('collapsing')
	            .attr('aria-expanded', true)
	            .attr('aria-hidden', false);
	
	          if ($animateCss) {
	            $animateCss(element, {
	              easing: 'ease',
	              to: { height: element[0].scrollHeight + 'px' }
	            }).start().done(expandDone);
	          } else {
	            $animate.animate(element, {}, {
	              height: element[0].scrollHeight + 'px'
	            }).then(expandDone);
	          }
	        }
	
	        function expandDone() {
	          element.removeClass('collapsing')
	            .addClass('collapse in')
	            .css({height: 'auto'});
	        }
	
	        function collapse() {
	          if (!element.hasClass('collapse') && !element.hasClass('in')) {
	            return collapseDone();
	          }
	
	          element
	            // IMPORTANT: The height must be set before adding "collapsing" class.
	            // Otherwise, the browser attempts to animate from height 0 (in
	            // collapsing class) to the given height here.
	            .css({height: element[0].scrollHeight + 'px'})
	            // initially all panel collapse have the collapse class, this removal
	            // prevents the animation from jumping to collapsed state
	            .removeClass('collapse in')
	            .addClass('collapsing')
	            .attr('aria-expanded', false)
	            .attr('aria-hidden', true);
	
	          if ($animateCss) {
	            $animateCss(element, {
	              to: {height: '0'}
	            }).start().done(collapseDone);
	          } else {
	            $animate.animate(element, {}, {
	              height: '0'
	            }).then(collapseDone);
	          }
	        }
	
	        function collapseDone() {
	          element.css({height: '0'}); // Required so that collapse works when animation is disabled
	          element.removeClass('collapsing')
	            .addClass('collapse');
	        }
	
	        scope.$watch(attrs.collapse, function(shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])
	
	.constant('uibAccordionConfig', {
	  closeOthers: true
	})
	
	.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
	  // This array keeps track of the accordion groups
	  this.groups = [];
	
	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function(openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ?
	      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if (closeOthers) {
	      angular.forEach(this.groups, function(group) {
	        if (group !== openGroup) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };
	
	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function(groupScope) {
	    var that = this;
	    this.groups.push(groupScope);
	
	    groupScope.$on('$destroy', function(event) {
	      that.removeGroup(groupScope);
	    });
	  };
	
	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function(group) {
	    var index = this.groups.indexOf(group);
	    if (index !== -1) {
	      this.groups.splice(index, 1);
	    }
	  };
	
	}])
	
	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('uibAccordion', function() {
	  return {
	    controller: 'UibAccordionController',
	    controllerAs: 'accordion',
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion.html';
	    }
	  };
	})
	
	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('uibAccordionGroup', function() {
	  return {
	    require: '^uibAccordion',         // We need this directive to be inside an accordion
	    transclude: true,              // It transcludes the contents of the directive into the template
	    replace: true,                // The element containing the directive will be replaced with the template
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/accordion/accordion-group.html';
	    },
	    scope: {
	      heading: '@',               // Interpolate the heading attribute onto this scope
	      isOpen: '=?',
	      isDisabled: '=?'
	    },
	    controller: function() {
	      this.setHeading = function(element) {
	        this.heading = element;
	      };
	    },
	    link: function(scope, element, attrs, accordionCtrl) {
	      accordionCtrl.addGroup(scope);
	
	      scope.openClass = attrs.openClass || 'panel-open';
	      scope.panelClass = attrs.panelClass;
	      scope.$watch('isOpen', function(value) {
	        element.toggleClass(scope.openClass, !!value);
	        if (value) {
	          accordionCtrl.closeOthers(scope);
	        }
	      });
	
	      scope.toggleOpen = function($event) {
	        if (!scope.isDisabled) {
	          if (!$event || $event.which === 32) {
	            scope.isOpen = !scope.isOpen;
	          }
	        }
	      };
	    }
	  };
	})
	
	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	.directive('uibAccordionHeading', function() {
	  return {
	    transclude: true,   // Grab the contents to be used as the heading
	    template: '',       // In effect remove this element!
	    replace: true,
	    require: '^uibAccordionGroup',
	    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
	      // Pass the heading to the accordion-group controller
	      // so that it can be transcluded into the right place in the template
	      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	    }
	  };
	})
	
	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	.directive('uibAccordionTransclude', function() {
	  return {
	    require: ['?^uibAccordionGroup', '?^accordionGroup'],
	    link: function(scope, element, attrs, controller) {
	      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation
	      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
	        if (heading) {
	          element.find('span').html('');
	          element.find('span').append(heading);
	        }
	      });
	    }
	  };
	});
	
	/* Deprecated accordion below */
	
	angular.module('ui.bootstrap.accordion')
	
	  .value('$accordionSuppressWarning', false)
	
	  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {
	    if (!$accordionSuppressWarning) {
	      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');
	    }
	
	    angular.extend(this, $controller('UibAccordionController', {
	      $scope: $scope,
	      $attrs: $attrs
	    }));
	  }])
	
	  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
	    return {
	      restrict: 'EA',
	      controller: 'AccordionController',
	      controllerAs: 'accordion',
	      transclude: true,
	      replace: false,
	      templateUrl: function(element, attrs) {
	        return attrs.templateUrl || 'template/accordion/accordion.html';
	      },
	      link: function() {
	        if (!$accordionSuppressWarning) {
	          $log.warn('accordion is now deprecated. Use uib-accordion instead.');
	        }
	      }
	    };
	  }])
	
	  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
	    return {
	      require: '^accordion',         // We need this directive to be inside an accordion
	      restrict: 'EA',
	      transclude: true,              // It transcludes the contents of the directive into the template
	      replace: true,                // The element containing the directive will be replaced with the template
	      templateUrl: function(element, attrs) {
	        return attrs.templateUrl || 'template/accordion/accordion-group.html';
	      },
	      scope: {
	        heading: '@',               // Interpolate the heading attribute onto this scope
	        isOpen: '=?',
	        isDisabled: '=?'
	      },
	      controller: function() {
	        this.setHeading = function(element) {
	          this.heading = element;
	        };
	      },
	      link: function(scope, element, attrs, accordionCtrl) {
	        if (!$accordionSuppressWarning) {
	          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');
	        }
	
	        accordionCtrl.addGroup(scope);
	
	        scope.openClass = attrs.openClass || 'panel-open';
	        scope.panelClass = attrs.panelClass;
	        scope.$watch('isOpen', function(value) {
	          element.toggleClass(scope.openClass, !!value);
	          if (value) {
	            accordionCtrl.closeOthers(scope);
	          }
	        });
	
	        scope.toggleOpen = function($event) {
	          if (!scope.isDisabled) {
	            if (!$event || $event.which === 32) {
	              scope.isOpen = !scope.isOpen;
	            }
	          }
	        };
	      }
	    };
	  }])
	
	  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
	    return {
	      restrict: 'EA',
	      transclude: true,   // Grab the contents to be used as the heading
	      template: '',       // In effect remove this element!
	      replace: true,
	      require: '^accordionGroup',
	      link: function(scope, element, attr, accordionGroupCtrl, transclude) {
	        if (!$accordionSuppressWarning) {
	          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');
	        }
	        // Pass the heading to the accordion-group controller
	        // so that it can be transcluded into the right place in the template
	        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
	      }
	    };
	  }])
	
	  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
	    return {
	      require: '^accordionGroup',
	      link: function(scope, element, attr, controller) {
	        if (!$accordionSuppressWarning) {
	          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');
	        }
	
	        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
	          if (heading) {
	            element.find('span').html('');
	            element.find('span').append(heading);
	          }
	        });
	      }
	    };
	  }]);
	
	
	angular.module('ui.bootstrap.alert', [])
	
	.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
	  $scope.closeable = !!$attrs.close;
	
	  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
	    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
	
	  if (dismissOnTimeout) {
	    $timeout(function() {
	      $scope.close();
	    }, parseInt(dismissOnTimeout, 10));
	  }
	}])
	
	.directive('uibAlert', function() {
	  return {
	    controller: 'UibAlertController',
	    controllerAs: 'alert',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/alert/alert.html';
	    },
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@',
	      close: '&'
	    }
	  };
	});
	
	/* Deprecated alert below */
	
	angular.module('ui.bootstrap.alert')
	
	  .value('$alertSuppressWarning', false)
	
	  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {
	    if (!$alertSuppressWarning) {
	      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');
	    }
	
	    angular.extend(this, $controller('UibAlertController', {
	      $scope: $scope,
	      $attrs: $attrs
	    }));
	  }])
	
	  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {
	    return {
	      controller: 'AlertController',
	      controllerAs: 'alert',
	      templateUrl: function(element, attrs) {
	        return attrs.templateUrl || 'template/alert/alert.html';
	      },
	      transclude: true,
	      replace: true,
	      scope: {
	        type: '@',
	        close: '&'
	      },
	      link: function() {
	        if (!$alertSuppressWarning) {
	          $log.warn('alert is now deprecated. Use uib-alert instead.');
	        }
	      }
	    };
	  }]);
	
	angular.module('ui.bootstrap.buttons', [])
	
	.constant('uibButtonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	})
	
	.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}])
	
	.directive('uibBtnRadio', function() {
	  return {
	    require: ['uibBtnRadio', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'buttons',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
	      };
	
	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        var isActive = element.hasClass(buttonsCtrl.activeClass);
	
	        if (!isActive || angular.isDefined(attrs.uncheckable)) {
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });
	    }
	  };
	})
	
	.directive('uibBtnCheckbox', function() {
	  return {
	    require: ['uibBtnCheckbox', 'ngModel'],
	    controller: 'UibButtonsController',
	    controllerAs: 'button',
	    link: function(scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      element.find('input').css({display: 'none'});
	
	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }
	
	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }
	
	      function getCheckboxValue(attribute, defaultValue) {
	        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
	      }
	
	      //model -> UI
	      ngModelCtrl.$render = function() {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };
	
	      //ui->model
	      element.on(buttonsCtrl.toggleEvent, function() {
	        if (attrs.disabled) {
	          return;
	        }
	
	        scope.$apply(function() {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	});
	
	/* Deprecated buttons below */
	
	angular.module('ui.bootstrap.buttons')
	
	  .value('$buttonsSuppressWarning', false)
	
	  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {
	    if (!$buttonsSuppressWarning) {
	      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');
	    }
	
	    angular.extend(this, $controller('UibButtonsController'));
	  }])
	
	  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {
	    return {
	      require: ['btnRadio', 'ngModel'],
	      controller: 'ButtonsController',
	      controllerAs: 'buttons',
	      link: function(scope, element, attrs, ctrls) {
	        if (!$buttonsSuppressWarning) {
	          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');
	        }
	
	        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	        element.find('input').css({display: 'none'});
	
	        //model -> UI
	        ngModelCtrl.$render = function() {
	          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
	        };
	
	        //ui->model
	        element.bind(buttonsCtrl.toggleEvent, function() {
	          if (attrs.disabled) {
	            return;
	          }
	
	          var isActive = element.hasClass(buttonsCtrl.activeClass);
	
	          if (!isActive || angular.isDefined(attrs.uncheckable)) {
	            scope.$apply(function() {
	              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
	              ngModelCtrl.$render();
	            });
	          }
	        });
	      }
	    };
	  }])
	
	  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {
	    return {
	      require: ['btnCheckbox', 'ngModel'],
	      controller: 'ButtonsController',
	      controllerAs: 'button',
	      link: function(scope, element, attrs, ctrls) {
	        if (!$buttonsSuppressWarning) {
	          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');
	        }
	
	        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	        element.find('input').css({display: 'none'});
	
	        function getTrueValue() {
	          return getCheckboxValue(attrs.btnCheckboxTrue, true);
	        }
	
	        function getFalseValue() {
	          return getCheckboxValue(attrs.btnCheckboxFalse, false);
	        }
	
	        function getCheckboxValue(attributeValue, defaultValue) {
	          var val = scope.$eval(attributeValue);
	          return angular.isDefined(val) ? val : defaultValue;
	        }
	
	        //model -> UI
	        ngModelCtrl.$render = function() {
	          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	        };
	
	        //ui->model
	        element.bind(buttonsCtrl.toggleEvent, function() {
	          if (attrs.disabled) {
	            return;
	          }
	
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	            ngModelCtrl.$render();
	          });
	        });
	
	        //accessibility
	        element.on('keypress', function(e) {
	          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
	            return;
	          }
	
	          scope.$apply(function() {
	            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	            ngModelCtrl.$render();
	          });
	        });
	      }
	    };
	  }]);
	
	
	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.carousel
	 *
	 * @description
	 * AngularJS version of an image carousel.
	 *
	 */
	angular.module('ui.bootstrap.carousel', [])
	
	.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {
	  var self = this,
	    slides = self.slides = $scope.slides = [],
	    NEW_ANIMATE = angular.version.minor >= 4,
	    NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    currentIndex = -1,
	    currentInterval, isPlaying;
	  self.currentSlide = null;
	
	  var destroyed = false;
	  /* direction: "prev" or "next" */
	  self.select = $scope.select = function(nextSlide, direction) {
	    var nextIndex = $scope.indexOfSlide(nextSlide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
	    }
	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
	      goNext(nextSlide, nextIndex, direction);
	    }
	  };
	
	  function goNext(slide, index, direction) {
	    // Scope has been destroyed, stop here.
	    if (destroyed) { return; }
	
	    angular.extend(slide, {direction: direction, active: true});
	    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
	    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&
	      slide.$element && self.slides.length > 1) {
	      slide.$element.data(SLIDE_DIRECTION, slide.direction);
	      if (self.currentSlide && self.currentSlide.$element) {
	        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
	      }
	
	      $scope.$currentTransition = true;
	      if (NEW_ANIMATE) {
	        $animate.on('addClass', slide.$element, function(element, phase) {
	          if (phase === 'close') {
	            $scope.$currentTransition = null;
	            $animate.off('addClass', element);
	          }
	        });
	      } else {
	        slide.$element.one('$animate:close', function closeFn() {
	          $scope.$currentTransition = null;
	        });
	      }
	    }
	
	    self.currentSlide = slide;
	    currentIndex = index;
	
	    //every time you change slides, reset the timer
	    restartTimer();
	  }
	
	  $scope.$on('$destroy', function() {
	    destroyed = true;
	  });
	
	  function getSlideByIndex(index) {
	    if (angular.isUndefined(slides[index].index)) {
	      return slides[index];
	    }
	    var i, len = slides.length;
	    for (i = 0; i < slides.length; ++i) {
	      if (slides[i].index == index) {
	        return slides[i];
	      }
	    }
	  }
	
	  self.getCurrentIndex = function() {
	    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
	      return +self.currentSlide.index;
	    }
	    return currentIndex;
	  };
	
	  /* Allow outside people to call indexOf on slides array */
	  $scope.indexOfSlide = function(slide) {
	    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
	  };
	
	  $scope.next = function() {
	    var newIndex = (self.getCurrentIndex() + 1) % slides.length;
	
	    if (newIndex === 0 && $scope.noWrap()) {
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'next');
	  };
	
	  $scope.prev = function() {
	    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
	
	    if ($scope.noWrap() && newIndex === slides.length - 1) {
	      $scope.pause();
	      return;
	    }
	
	    return self.select(getSlideByIndex(newIndex), 'prev');
	  };
	
	  $scope.isActive = function(slide) {
	     return self.currentSlide === slide;
	  };
	
	  $scope.$watch('interval', restartTimer);
	  $scope.$watchCollection('slides', resetTransition);
	  $scope.$on('$destroy', resetTimer);
	
	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval > 0) {
	      currentInterval = $interval(timerFn, interval);
	    }
	  }
	
	  function resetTimer() {
	    if (currentInterval) {
	      $interval.cancel(currentInterval);
	      currentInterval = null;
	    }
	  }
	
	  function timerFn() {
	    var interval = +$scope.interval;
	    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
	      $scope.next();
	    } else {
	      $scope.pause();
	    }
	  }
	
	  function resetTransition(slides) {
	    if (!slides.length) {
	      $scope.$currentTransition = null;
	    }
	  }
	
	  $scope.play = function() {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };
	  $scope.pause = function() {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };
	
	  self.addSlide = function(slide, element) {
	    slide.$element = element;
	    slides.push(slide);
	    //if this is the first slide or the slide is set to active, select it
	    if (slides.length === 1 || slide.active) {
	      self.select(slides[slides.length - 1]);
	      if (slides.length === 1) {
	        $scope.play();
	      }
	    } else {
	      slide.active = false;
	    }
	  };
	
	  self.removeSlide = function(slide) {
	    if (angular.isDefined(slide.index)) {
	      slides.sort(function(a, b) {
	        return +a.index > +b.index;
	      });
	    }
	    //get the index of the slide inside the carousel
	    var index = slides.indexOf(slide);
	    slides.splice(index, 1);
	    if (slides.length > 0 && slide.active) {
	      if (index >= slides.length) {
	        self.select(slides[index - 1]);
	      } else {
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	    }
	
	    //clean the currentSlide when no more slide
	    if (slides.length === 0) {
	      self.currentSlide = null;
	    }
	  };
	
	  $scope.$watch('noTransition', function(noTransition) {
	    $element.data(NO_TRANSITION, noTransition);
	  });
	
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:carousel
	 * @restrict EA
	 *
	 * @description
	 * Carousel is the outer container for a set of image 'slides' to showcase.
	 *
	 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
	 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
	 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <uib-carousel>
	      <uib-slide>
	        <img src="http://placekitten.com/150/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>Beautiful!</p>
	        </div>
	      </uib-slide>
	      <uib-slide>
	        <img src="http://placekitten.com/100/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>D'aww!</p>
	        </div>
	      </uib-slide>
	    </uib-carousel>
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	 */
	.directive('uibCarousel', [function() {
	  return {
	    transclude: true,
	    replace: true,
	    controller: 'UibCarouselController',
	    controllerAs: 'carousel',
	    require: 'carousel',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/carousel.html';
	    },
	    scope: {
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    }
	  };
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:slide
	 * @restrict EA
	 *
	 * @description
	 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
	 *
	 * @param {boolean=} active Model binding, whether or not this slide is currently active.
	 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	<div ng-controller="CarouselDemoCtrl">
	  <uib-carousel>
	    <uib-slide ng-repeat="slide in slides" active="slide.active" index="$index">
	      <img ng-src="{{slide.image}}" style="margin:auto;">
	      <div class="carousel-caption">
	        <h4>Slide {{$index}}</h4>
	        <p>{{slide.text}}</p>
	      </div>
	    </uib-slide>
	  </uib-carousel>
	  Interval, in milliseconds: <input type="number" ng-model="myInterval">
	  <br />Enter a negative number to stop the interval.
	</div>
	  </file>
	  <file name="script.js">
	function CarouselDemoCtrl($scope) {
	  $scope.myInterval = 5000;
	}
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	*/
	
	.directive('uibSlide', function() {
	  return {
	    require: '^uibCarousel',
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/slide.html';
	    },
	    scope: {
	      active: '=?',
	      actual: '=?',
	      index: '=?'
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });
	
	      scope.$watch('active', function(active) {
	        if (active) {
	          carouselCtrl.select(scope);
	        }
	      });
	    }
	  };
	})
	
	.animation('.item', [
	         '$injector', '$animate',
	function ($injector, $animate) {
	  var NO_TRANSITION = 'uib-noTransition',
	    SLIDE_DIRECTION = 'uib-slideDirection',
	    $animateCss = null;
	
	  if ($injector.has('$animateCss')) {
	    $animateCss = $injector.get('$animateCss');
	  }
	
	  function removeClass(element, className, callback) {
	    element.removeClass(className);
	    if (callback) {
	      callback();
	    }
	  }
	
	  return {
	    beforeAddClass: function(element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className == 'active' && element.parent() && element.parent().parent() &&
	          !element.parent().parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element,
	          directionClass + ' ' + direction, done);
	        element.addClass(direction);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function () {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	
	        return function () {
	          stopped = true;
	        };
	      }
	      done();
	    },
	    beforeRemoveClass: function (element, className, done) {
	      // Due to transclusion, noTransition property is on parent's scope
	      if (className === 'active' && element.parent() && element.parent().parent() &&
	          !element.parent().parent().data(NO_TRANSITION)) {
	        var stopped = false;
	        var direction = element.data(SLIDE_DIRECTION);
	        var directionClass = direction == 'next' ? 'left' : 'right';
	        var removeClassFn = removeClass.bind(this, element, directionClass, done);
	
	        if ($animateCss) {
	          $animateCss(element, {addClass: directionClass})
	            .start()
	            .done(removeClassFn);
	        } else {
	          $animate.addClass(element, directionClass).then(function() {
	            if (!stopped) {
	              removeClassFn();
	            }
	            done();
	          });
	        }
	        return function() {
	          stopped = true;
	        };
	      }
	      done();
	    }
	  };
	}]);
	
	/* deprecated carousel below */
	
	angular.module('ui.bootstrap.carousel')
	
	.value('$carouselSuppressWarning', false)
	
	.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {
	  if (!$carouselSuppressWarning) {
	    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');
	  }
	
	  angular.extend(this, $controller('UibCarouselController', {
	    $scope: $scope,
	    $element: $element
	  }));
	}])
	
	.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
	  return {
	    transclude: true,
	    replace: true,
	    controller: 'CarouselController',
	    controllerAs: 'carousel',
	    require: 'carousel',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/carousel.html';
	    },
	    scope: {
	      interval: '=',
	      noTransition: '=',
	      noPause: '=',
	      noWrap: '&'
	    },
	    link: function() {
	      if (!$carouselSuppressWarning) {
	        $log.warn('carousel is now deprecated. Use uib-carousel instead.');
	      }
	    }
	  };
	}])
	
	.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
	  return {
	    require: '^carousel',
	    transclude: true,
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/carousel/slide.html';
	    },
	    scope: {
	      active: '=?',
	      actual: '=?',
	      index: '=?'
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      if (!$carouselSuppressWarning) {
	        $log.warn('slide is now deprecated. Use uib-slide instead.');
	      }
	
	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });
	
	      scope.$watch('active', function(active) {
	        if (active) {
	          carouselCtrl.select(scope);
	        }
	      });
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.dateparser', [])
	
	.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
	  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
	  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	
	  var localeId;
	  var formatCodeToRegex;
	
	  this.init = function() {
	    localeId = $locale.id;
	
	    this.parsers = {};
	
	    formatCodeToRegex = {
	      'yyyy': {
	        regex: '\\d{4}',
	        apply: function(value) { this.year = +value; }
	      },
	      'yy': {
	        regex: '\\d{2}',
	        apply: function(value) { this.year = +value + 2000; }
	      },
	      'y': {
	        regex: '\\d{1,4}',
	        apply: function(value) { this.year = +value; }
	      },
	      'MMMM': {
	        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
	        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
	      },
	      'MMM': {
	        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
	        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
	      },
	      'MM': {
	        regex: '0[1-9]|1[0-2]',
	        apply: function(value) { this.month = value - 1; }
	      },
	      'M': {
	        regex: '[1-9]|1[0-2]',
	        apply: function(value) { this.month = value - 1; }
	      },
	      'dd': {
	        regex: '[0-2][0-9]{1}|3[0-1]{1}',
	        apply: function(value) { this.date = +value; }
	      },
	      'd': {
	        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
	        apply: function(value) { this.date = +value; }
	      },
	      'EEEE': {
	        regex: $locale.DATETIME_FORMATS.DAY.join('|')
	      },
	      'EEE': {
	        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
	      },
	      'HH': {
	        regex: '(?:0|1)[0-9]|2[0-3]',
	        apply: function(value) { this.hours = +value; }
	      },
	      'hh': {
	        regex: '0[0-9]|1[0-2]',
	        apply: function(value) { this.hours = +value; }
	      },
	      'H': {
	        regex: '1?[0-9]|2[0-3]',
	        apply: function(value) { this.hours = +value; }
	      },
	      'h': {
	        regex: '[0-9]|1[0-2]',
	        apply: function(value) { this.hours = +value; }
	      },
	      'mm': {
	        regex: '[0-5][0-9]',
	        apply: function(value) { this.minutes = +value; }
	      },
	      'm': {
	        regex: '[0-9]|[1-5][0-9]',
	        apply: function(value) { this.minutes = +value; }
	      },
	      'sss': {
	        regex: '[0-9][0-9][0-9]',
	        apply: function(value) { this.milliseconds = +value; }
	      },
	      'ss': {
	        regex: '[0-5][0-9]',
	        apply: function(value) { this.seconds = +value; }
	      },
	      's': {
	        regex: '[0-9]|[1-5][0-9]',
	        apply: function(value) { this.seconds = +value; }
	      },
	      'a': {
	        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
	        apply: function(value) {
	          if (this.hours === 12) {
	            this.hours = 0;
	          }
	
	          if (value === 'PM') {
	            this.hours += 12;
	          }
	        }
	      }
	    };
	  };
	
	  this.init();
	
	  function createParser(format) {
	    var map = [], regex = format.split('');
	
	    angular.forEach(formatCodeToRegex, function(data, code) {
	      var index = format.indexOf(code);
	
	      if (index > -1) {
	        format = format.split('');
	
	        regex[index] = '(' + data.regex + ')';
	        format[index] = '$'; // Custom symbol to define consumed part of format
	        for (var i = index + 1, n = index + code.length; i < n; i++) {
	          regex[i] = '';
	          format[i] = '$';
	        }
	        format = format.join('');
	
	        map.push({ index: index, apply: data.apply });
	      }
	    });
	
	    return {
	      regex: new RegExp('^' + regex.join('') + '$'),
	      map: orderByFilter(map, 'index')
	    };
	  }
	
	  this.parse = function(input, format, baseDate) {
	    if (!angular.isString(input) || !format) {
	      return input;
	    }
	
	    format = $locale.DATETIME_FORMATS[format] || format;
	    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
	
	    if ($locale.id !== localeId) {
	      this.init();
	    }
	
	    if (!this.parsers[format]) {
	      this.parsers[format] = createParser(format);
	    }
	
	    var parser = this.parsers[format],
	        regex = parser.regex,
	        map = parser.map,
	        results = input.match(regex);
	
	    if (results && results.length) {
	      var fields, dt;
	      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	        fields = {
	          year: baseDate.getFullYear(),
	          month: baseDate.getMonth(),
	          date: baseDate.getDate(),
	          hours: baseDate.getHours(),
	          minutes: baseDate.getMinutes(),
	          seconds: baseDate.getSeconds(),
	          milliseconds: baseDate.getMilliseconds()
	        };
	      } else {
	        if (baseDate) {
	          $log.warn('dateparser:', 'baseDate is not a valid date');
	        }
	        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
	      }
	
	      for (var i = 1, n = results.length; i < n; i++) {
	        var mapper = map[i-1];
	        if (mapper.apply) {
	          mapper.apply.call(fields, results[i]);
	        }
	      }
	
	      if (isValid(fields.year, fields.month, fields.date)) {
	        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
	          dt = new Date(baseDate);
	          dt.setFullYear(fields.year, fields.month, fields.date,
	            fields.hours, fields.minutes, fields.seconds,
	            fields.milliseconds || 0);
	        } else {
	          dt = new Date(fields.year, fields.month, fields.date,
	            fields.hours, fields.minutes, fields.seconds,
	            fields.milliseconds || 0);
	        }
	      }
	
	      return dt;
	    }
	  };
	
	  // Check if date is valid for specific month (and year for February).
	  // Month: 0 = Jan, 1 = Feb, etc
	  function isValid(year, month, date) {
	    if (date < 1) {
	      return false;
	    }
	
	    if (month === 1 && date > 28) {
	      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
	    }
	
	    if (month === 3 || month === 5 || month === 8 || month === 10) {
	      return date < 31;
	    }
	
	    return true;
	  }
	}]);
	
	/* Deprecated dateparser below */
	
	angular.module('ui.bootstrap.dateparser')
	
	.value('$dateParserSuppressWarning', false)
	
	.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {
	  if (!$dateParserSuppressWarning) {
	    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');
	  }
	
	  angular.extend(this, uibDateParser);
	}]);
	
	angular.module('ui.bootstrap.position', [])
	
	/**
	 * A set of utility methods that can be use to retrieve position of DOM elements.
	 * It is meant to be used where we need to absolute-position DOM elements in
	 * relation to other, existing elements (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
	    function getStyle(el, cssprop) {
	      if (el.currentStyle) { //IE
	        return el.currentStyle[cssprop];
	      } else if ($window.getComputedStyle) {
	        return $window.getComputedStyle(el)[cssprop];
	      }
	      // finally try and get inline style
	      return el.style[cssprop];
	    }
	
	    /**
	     * Checks if a given element is statically positioned
	     * @param element - raw DOM element
	     */
	    function isStaticPositioned(element) {
	      return (getStyle(element, 'position') || 'static' ) === 'static';
	    }
	
	    /**
	     * returns the closest, non-statically positioned parentOffset of a given element
	     * @param element
	     */
	    var parentOffsetEl = function(element) {
	      var docDomEl = $document[0];
	      var offsetParent = element.offsetParent || docDomEl;
	      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
	        offsetParent = offsetParent.offsetParent;
	      }
	      return offsetParent || docDomEl;
	    };
	
	    return {
	      /**
	       * Provides read-only equivalent of jQuery's position function:
	       * http://api.jquery.com/position/
	       */
	      position: function(element) {
	        var elBCR = this.offset(element);
	        var offsetParentBCR = { top: 0, left: 0 };
	        var offsetParentEl = parentOffsetEl(element[0]);
	        if (offsetParentEl != $document[0]) {
	          offsetParentBCR = this.offset(angular.element(offsetParentEl));
	          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
	          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
	        }
	
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: elBCR.top - offsetParentBCR.top,
	          left: elBCR.left - offsetParentBCR.left
	        };
	      },
	
	      /**
	       * Provides read-only equivalent of jQuery's offset function:
	       * http://api.jquery.com/offset/
	       */
	      offset: function(element) {
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	        };
	      },
	
	      /**
	       * Provides coordinates for the targetEl in relation to hostEl
	       */
	      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
	        var positionStrParts = positionStr.split('-');
	        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';
	
	        var hostElPos,
	          targetElWidth,
	          targetElHeight,
	          targetElPos;
	
	        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
	
	        targetElWidth = targetEl.prop('offsetWidth');
	        targetElHeight = targetEl.prop('offsetHeight');
	
	        var shiftWidth = {
	          center: function() {
	            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
	          },
	          left: function() {
	            return hostElPos.left;
	          },
	          right: function() {
	            return hostElPos.left + hostElPos.width;
	          }
	        };
	
	        var shiftHeight = {
	          center: function() {
	            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
	          },
	          top: function() {
	            return hostElPos.top;
	          },
	          bottom: function() {
	            return hostElPos.top + hostElPos.height;
	          }
	        };
	
	        switch (pos0) {
	          case 'right':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: shiftWidth[pos0]()
	            };
	            break;
	          case 'left':
	            targetElPos = {
	              top: shiftHeight[pos1](),
	              left: hostElPos.left - targetElWidth
	            };
	            break;
	          case 'bottom':
	            targetElPos = {
	              top: shiftHeight[pos0](),
	              left: shiftWidth[pos1]()
	            };
	            break;
	          default:
	            targetElPos = {
	              top: hostElPos.top - targetElHeight,
	              left: shiftWidth[pos1]()
	            };
	            break;
	        }
	
	        return targetElPos;
	      }
	    };
	  }]);
	
	/* Deprecated position below */
	
	angular.module('ui.bootstrap.position')
	
	.value('$positionSuppressWarning', false)
	
	.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {
	  if (!$positionSuppressWarning) {
	    $log.warn('$position is now deprecated. Use $uibPosition instead.');
	  }
	
	  angular.extend(this, $uibPosition);
	}]);
	
	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])
	
	.value('$datepickerSuppressError', false)
	
	.constant('uibDatepickerConfig', {
	  formatDay: 'dd',
	  formatMonth: 'MMMM',
	  formatYear: 'yyyy',
	  formatDayHeader: 'EEE',
	  formatDayTitle: 'MMMM yyyy',
	  formatMonthTitle: 'yyyy',
	  datepickerMode: 'day',
	  minMode: 'day',
	  maxMode: 'year',
	  showWeeks: true,
	  startingDay: 0,
	  yearRange: 20,
	  minDate: null,
	  maxDate: null,
	  shortcutPropagation: false
	})
	
	.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;
	
	  // Modes chain
	  this.modes = ['day', 'month', 'year'];
	
	  // Configuration attributes
	  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
	                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
	    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
	  });
	
	  // Watchable date attributes
	  angular.forEach(['minDate', 'maxDate'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = value ? new Date(value) : null;
	        self.refreshView();
	      });
	    } else {
	      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
	    }
	  });
	
	  angular.forEach(['minMode', 'maxMode'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = angular.isDefined(value) ? value : $attrs[key];
	        $scope[key] = self[key];
	        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
	          $scope.datepickerMode = self[key];
	        }
	      });
	    } else {
	      self[key] = datepickerConfig[key] || null;
	      $scope[key] = self[key];
	    }
	  });
	
	  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
	
	  if (angular.isDefined($attrs.initDate)) {
	    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
	    $scope.$parent.$watch($attrs.initDate, function(initDate) {
	      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	        self.activeDate = initDate;
	        self.refreshView();
	      }
	    });
	  } else {
	    this.activeDate = new Date();
	  }
	
	  $scope.isActive = function(dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	  };
	
	  this.render = function() {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	          isValid = !isNaN(date);
	
	      if (isValid) {
	        this.activeDate = date;
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	      }
	    }
	    this.refreshView();
	  };
	
	  this.refreshView = function() {
	    if (this.element) {
	      this._refreshView();
	
	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
	    }
	  };
	
	  this.createDateObject = function(date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    return {
	      date: date,
	      label: dateFilter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      current: this.compare(date, new Date()) === 0,
	      customClass: this.customClass(date)
	    };
	  };
	
	  this.isDisabled = function(date) {
	    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
	  };
	
	  this.customClass = function(date) {
	    return $scope.customClass({date: date, mode: $scope.datepickerMode});
	  };
	
	  // Split array into smaller arrays
	  this.split = function(arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };
	
	  $scope.select = function(date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
	    }
	  };
	
	  $scope.move = function(direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };
	
	  $scope.toggleMode = function(direction) {
	    direction = direction || 1;
	
	    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
	      return;
	    }
	
	    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
	  };
	
	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
	
	  var focusElement = function() {
	    self.element[0].focus();
	  };
	
	  // Listen for focus requests from popup directive
	  $scope.$on('uib:datepicker.focus', focusElement);
	
	  $scope.keydown = function(evt) {
	    var key = $scope.keys[evt.which];
	
	    if (!key || evt.shiftKey || evt.altKey) {
	      return;
	    }
	
	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }
	
	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };
	}])
	
	.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	
	  this.step = { months: 1 };
	  this.element = $element;
	  function getDaysInMonth(year, month) {
	    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
	  }
	
	  this.init = function(ctrl) {
	    angular.extend(ctrl, this);
	    scope.showWeeks = ctrl.showWeeks;
	    ctrl.refreshView();
	  };
	
	  this.getDates = function(startDate, n) {
	    var dates = new Array(n), current = new Date(startDate), i = 0, date;
	    while (i < n) {
	      date = new Date(current);
	      dates[i++] = date;
	      current.setDate(current.getDate() + 1);
	    }
	    return dates;
	  };
	
	  this._refreshView = function() {
	    var year = this.activeDate.getFullYear(),
	      month = this.activeDate.getMonth(),
	      firstDayOfMonth = new Date(this.activeDate);
	
	    firstDayOfMonth.setFullYear(year, month, 1);
	
	    var difference = this.startingDay - firstDayOfMonth.getDay(),
	      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
	      firstDate = new Date(firstDayOfMonth);
	
	    if (numDisplayedFromPreviousMonth > 0) {
	      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
	    }
	
	    // 42 is the number of days on a six-month calendar
	    var days = this.getDates(firstDate, 42);
	    for (var i = 0; i < 42; i ++) {
	      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
	        secondary: days[i].getMonth() !== month,
	        uid: scope.uniqueId + '-' + i
	      });
	    }
	
	    scope.labels = new Array(7);
	    for (var j = 0; j < 7; j++) {
	      scope.labels[j] = {
	        abbr: dateFilter(days[j].date, this.formatDayHeader),
	        full: dateFilter(days[j].date, 'EEEE')
	      };
	    }
	
	    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
	    scope.rows = this.split(days, 7);
	
	    if (scope.showWeeks) {
	      scope.weekNumbers = [];
	      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
	          numWeeks = scope.rows.length;
	      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
	        scope.weekNumbers.push(
	          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
	      }
	    }
	  };
	
	  this.compare = function(date1, date2) {
	    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	  };
	
	  function getISO8601WeekNumber(date) {
	    var checkDate = new Date(date);
	    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	    var time = checkDate.getTime();
	    checkDate.setMonth(0); // Compare with Jan 1
	    checkDate.setDate(1);
	    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	  }
	
	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getDate();
	
	    if (key === 'left') {
	      date = date - 1;   // up
	    } else if (key === 'up') {
	      date = date - 7;   // down
	    } else if (key === 'right') {
	      date = date + 1;   // down
	    } else if (key === 'down') {
	      date = date + 7;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
	      this.activeDate.setMonth(month, 1);
	      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
	    } else if (key === 'home') {
	      date = 1;
	    } else if (key === 'end') {
	      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
	    }
	    this.activeDate.setDate(date);
	  };
	}])
	
	.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  this.step = { years: 1 };
	  this.element = $element;
	
	  this.init = function(ctrl) {
	    angular.extend(ctrl, this);
	    ctrl.refreshView();
	  };
	
	  this._refreshView = function() {
	    var months = new Array(12),
	        year = this.activeDate.getFullYear(),
	        date;
	
	    for (var i = 0; i < 12; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(year, i, 1);
	      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }
	
	    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
	    scope.rows = this.split(months, 3);
	  };
	
	  this.compare = function(date1, date2) {
	    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
	  };
	
	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getMonth();
	
	    if (key === 'left') {
	      date = date - 1;   // up
	    } else if (key === 'up') {
	      date = date - 3;   // down
	    } else if (key === 'right') {
	      date = date + 1;   // down
	    } else if (key === 'down') {
	      date = date + 3;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
	      this.activeDate.setFullYear(year);
	    } else if (key === 'home') {
	      date = 0;
	    } else if (key === 'end') {
	      date = 11;
	    }
	    this.activeDate.setMonth(date);
	  };
	}])
	
	.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
	  var range;
	  this.element = $element;
	
	  function getStartingYear(year) {
	    return parseInt((year - 1) / range, 10) * range + 1;
	  }
	
	  this.yearpickerInit = function() {
	    range = this.yearRange;
	    this.step = { years: range };
	  };
	
	  this._refreshView = function() {
	    var years = new Array(range), date;
	
	    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
	      date = new Date(this.activeDate);
	      date.setFullYear(start + i, 0, 1);
	      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
	        uid: scope.uniqueId + '-' + i
	      });
	    }
	
	    scope.title = [years[0].label, years[range - 1].label].join(' - ');
	    scope.rows = this.split(years, 5);
	  };
	
	  this.compare = function(date1, date2) {
	    return date1.getFullYear() - date2.getFullYear();
	  };
	
	  this.handleKeyDown = function(key, evt) {
	    var date = this.activeDate.getFullYear();
	
	    if (key === 'left') {
	      date = date - 1;   // up
	    } else if (key === 'up') {
	      date = date - 5;   // down
	    } else if (key === 'right') {
	      date = date + 1;   // down
	    } else if (key === 'down') {
	      date = date + 5;
	    } else if (key === 'pageup' || key === 'pagedown') {
	      date += (key === 'pageup' ? - 1 : 1) * this.step.years;
	    } else if (key === 'home') {
	      date = getStartingYear(this.activeDate.getFullYear());
	    } else if (key === 'end') {
	      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
	    }
	    this.activeDate.setFullYear(date);
	  };
	}])
	
	.directive('uibDatepicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerMode: '=?',
	      dateDisabled: '&',
	      customClass: '&',
	      shortcutPropagation: '&?'
	    },
	    require: ['uibDatepicker', '^ngModel'],
	    controller: 'UibDatepickerController',
	    controllerAs: 'datepicker',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	})
	
	.directive('uibDaypicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/day.html';
	    },
	    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],
	    controller: 'UibDaypickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0] || ctrls[2],
	        daypickerCtrl = ctrls[1];
	
	      daypickerCtrl.init(datepickerCtrl);
	    }
	  };
	})
	
	.directive('uibMonthpicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/month.html';
	    },
	    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],
	    controller: 'UibMonthpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0] || ctrls[2],
	        monthpickerCtrl = ctrls[1];
	
	      monthpickerCtrl.init(datepickerCtrl);
	    }
	  };
	})
	
	.directive('uibYearpicker', function() {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/year.html';
	    },
	    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],
	    controller: 'UibYearpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var ctrl = ctrls[0] || ctrls[2];
	      angular.extend(ctrl, ctrls[1]);
	      ctrl.yearpickerInit();
	
	      ctrl.refreshView();
	    }
	  };
	})
	
	.constant('uibDatepickerPopupConfig', {
	  datepickerPopup: 'yyyy-MM-dd',
	  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
	  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
	  html5Types: {
	    date: 'yyyy-MM-dd',
	    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
	    'month': 'yyyy-MM'
	  },
	  currentText: 'Today',
	  clearText: 'Clear',
	  closeText: 'Done',
	  closeOnDateSelection: true,
	  appendToBody: false,
	  showButtonBar: true,
	  onOpenFocus: true
	})
	
	.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',
	function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
	  var self = this;
	  var cache = {},
	    isHtml5DateInput = false;
	  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
	    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
	    ngModel, $popup;
	
	  scope.watchData = {};
	
	  this.init = function(_ngModel_) {
	    ngModel = _ngModel_;
	    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
	    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
	    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
	    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
	    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
	
	    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
	
	    if (datepickerPopupConfig.html5Types[attrs.type]) {
	      dateFormat = datepickerPopupConfig.html5Types[attrs.type];
	      isHtml5DateInput = true;
	    } else {
	      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
	      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
	          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
	          // Invalidate the $modelValue to ensure that formatters re-run
	          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
	          if (newDateFormat !== dateFormat) {
	            dateFormat = newDateFormat;
	            ngModel.$modelValue = null;
	
	            if (!dateFormat) {
	              throw new Error('uibDatepickerPopup must have a date format specified.');
	            }
	          }
	      });
	    }
	
	    if (!dateFormat) {
	      throw new Error('uibDatepickerPopup must have a date format specified.');
	    }
	
	    if (isHtml5DateInput && attrs.datepickerPopup) {
	      throw new Error('HTML5 date input types do not support custom formats.');
	    }
	
	    // popup element used to display calendar
	    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
	    popupEl.attr({
	      'ng-model': 'date',
	      'ng-change': 'dateSelection(date)',
	      'template-url': datepickerPopupTemplateUrl
	    });
	
	    // datepicker element
	    datepickerEl = angular.element(popupEl.children()[0]);
	    datepickerEl.attr('template-url', datepickerTemplateUrl);
	
	    if (isHtml5DateInput) {
	      if (attrs.type === 'month') {
	        datepickerEl.attr('datepicker-mode', '"month"');
	        datepickerEl.attr('min-mode', 'month');
	      }
	    }
	
	    if (attrs.datepickerOptions) {
	      var options = scope.$parent.$eval(attrs.datepickerOptions);
	      if (options && options.initDate) {
	        scope.initDate = options.initDate;
	        datepickerEl.attr('init-date', 'initDate');
	        delete options.initDate;
	      }
	      angular.forEach(options, function(value, option) {
	        datepickerEl.attr(cameltoDash(option), value);
	      });
	    }
	
	    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
	      if (attrs[key]) {
	        var getAttribute = $parse(attrs[key]);
	        scope.$parent.$watch(getAttribute, function(value) {
	          scope.watchData[key] = value;
	          if (key === 'minDate' || key === 'maxDate') {
	            cache[key] = new Date(value);
	          }
	        });
	        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
	
	        // Propagate changes from datepicker to outside
	        if (key === 'datepickerMode') {
	          var setAttribute = getAttribute.assign;
	          scope.$watch('watchData.' + key, function(value, oldvalue) {
	            if (angular.isFunction(setAttribute) && value !== oldvalue) {
	              setAttribute(scope.$parent, value);
	            }
	          });
	        }
	      }
	    });
	    if (attrs.dateDisabled) {
	      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
	    }
	
	    if (attrs.showWeeks) {
	      datepickerEl.attr('show-weeks', attrs.showWeeks);
	    }
	
	    if (attrs.customClass) {
	      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
	    }
	
	    if (!isHtml5DateInput) {
	      // Internal API to maintain the correct ng-invalid-[key] class
	      ngModel.$$parserName = 'date';
	      ngModel.$validators.date = validator;
	      ngModel.$parsers.unshift(parseDate);
	      ngModel.$formatters.push(function(value) {
	        scope.date = value;
	        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
	      });
	    } else {
	      ngModel.$formatters.push(function(value) {
	        scope.date = value;
	        return value;
	      });
	    }
	
	    // Detect changes in the view from the text box
	    ngModel.$viewChangeListeners.push(function() {
	      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
	    });
	
	    element.bind('keydown', inputKeydownBind);
	
	    $popup = $compile(popupEl)(scope);
	    // Prevent jQuery cache memory leak (template is now redundant after linking)
	    popupEl.remove();
	
	    if (appendToBody) {
	      $document.find('body').append($popup);
	    } else {
	      element.after($popup);
	    }
	
	    scope.$on('$destroy', function() {
	      if (scope.isOpen === true) {
	        if (!$rootScope.$$phase) {
	          scope.$apply(function() {
	            scope.isOpen = false;
	          });
	        }
	      }
	
	      $popup.remove();
	      element.unbind('keydown', inputKeydownBind);
	      $document.unbind('click', documentClickBind);
	    });
	  };
	
	  scope.getText = function(key) {
	    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
	  };
	
	  scope.isDisabled = function(date) {
	    if (date === 'today') {
	      date = new Date();
	    }
	
	    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
	      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
	  };
	
	  scope.compare = function(date1, date2) {
	    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
	  };
	
	  // Inner change
	  scope.dateSelection = function(dt) {
	    if (angular.isDefined(dt)) {
	      scope.date = dt;
	    }
	    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
	    element.val(date);
	    ngModel.$setViewValue(date);
	
	    if (closeOnDateSelection) {
	      scope.isOpen = false;
	      element[0].focus();
	    }
	  };
	
	  scope.keydown = function(evt) {
	    if (evt.which === 27) {
	      scope.isOpen = false;
	      element[0].focus();
	    }
	  };
	
	  scope.select = function(date) {
	    if (date === 'today') {
	      var today = new Date();
	      if (angular.isDate(scope.date)) {
	        date = new Date(scope.date);
	        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
	      } else {
	        date = new Date(today.setHours(0, 0, 0, 0));
	      }
	    }
	    scope.dateSelection(date);
	  };
	
	  scope.close = function() {
	    scope.isOpen = false;
	    element[0].focus();
	  };
	
	  scope.$watch('isOpen', function(value) {
	    if (value) {
	      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	      scope.position.top = scope.position.top + element.prop('offsetHeight');
	
	      $timeout(function() {
	        if (onOpenFocus) {
	          scope.$broadcast('uib:datepicker.focus');
	        }
	        $document.bind('click', documentClickBind);
	      }, 0, false);
	    } else {
	      $document.unbind('click', documentClickBind);
	    }
	  });
	
	  function cameltoDash(string) {
	    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
	  }
	
	  function parseDate(viewValue) {
	    if (angular.isNumber(viewValue)) {
	      // presumably timestamp to date object
	      viewValue = new Date(viewValue);
	    }
	
	    if (!viewValue) {
	      return null;
	    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
	      return viewValue;
	    } else if (angular.isString(viewValue)) {
	      var date = dateParser.parse(viewValue, dateFormat, scope.date);
	      if (isNaN(date)) {
	        return undefined;
	      } else {
	        return date;
	      }
	    } else {
	      return undefined;
	    }
	  }
	
	  function validator(modelValue, viewValue) {
	    var value = modelValue || viewValue;
	
	    if (!attrs.ngRequired && !value) {
	      return true;
	    }
	
	    if (angular.isNumber(value)) {
	      value = new Date(value);
	    }
	    if (!value) {
	      return true;
	    } else if (angular.isDate(value) && !isNaN(value)) {
	      return true;
	    } else if (angular.isString(value)) {
	      var date = dateParser.parse(value, dateFormat);
	      return !isNaN(date);
	    } else {
	      return false;
	    }
	  }
	
	  function documentClickBind(event) {
	    var popup = $popup[0];
	    var dpContainsTarget = element[0].contains(event.target);
	    // The popup node may not be an element node
	    // In some browsers (IE) only element nodes have the 'contains' function
	    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
	    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
	      scope.$apply(function() {
	        scope.isOpen = false;
	      });
	    }
	  }
	
	  function inputKeydownBind(evt) {
	    if (evt.which === 27 && scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      scope.$apply(function() {
	        scope.isOpen = false;
	      });
	      element[0].focus();
	    } else if (evt.which === 40 && !scope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      scope.$apply(function() {
	        scope.isOpen = true;
	      });
	    }
	  }
	}])
	
	.directive('uibDatepickerPopup', function() {
	  return {
	    require: ['ngModel', 'uibDatepickerPopup'],
	    controller: 'UibDatepickerPopupController',
	    scope: {
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&',
	      customClass: '&'
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var ngModel = ctrls[0],
	        ctrl = ctrls[1];
	
	      ctrl.init(ngModel);
	    }
	  };
	})
	
	.directive('uibDatepickerPopupWrap', function() {
	  return {
	    replace: true,
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/popup.html';
	    }
	  };
	});
	
	/* Deprecated datepicker below */
	
	angular.module('ui.bootstrap.datepicker')
	
	.value('$datepickerSuppressWarning', false)
	
	.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {
	  if (!$datepickerSuppressWarning) {
	    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');
	  }
	
	  var self = this,
	    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;
	
	  this.modes = ['day', 'month', 'year'];
	
	  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
	    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
	    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
	  });
	
	  angular.forEach(['minDate', 'maxDate'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = value ? new Date(value) : null;
	        self.refreshView();
	      });
	    } else {
	      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
	    }
	  });
	
	  angular.forEach(['minMode', 'maxMode'], function(key) {
	    if ($attrs[key]) {
	      $scope.$parent.$watch($parse($attrs[key]), function(value) {
	        self[key] = angular.isDefined(value) ? value : $attrs[key];
	        $scope[key] = self[key];
	        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
	          $scope.datepickerMode = self[key];
	        }
	      });
	    } else {
	      self[key] = datepickerConfig[key] || null;
	      $scope[key] = self[key];
	    }
	  });
	
	  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
	  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
	
	  if (angular.isDefined($attrs.initDate)) {
	    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
	    $scope.$parent.$watch($attrs.initDate, function(initDate) {
	      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
	        self.activeDate = initDate;
	        self.refreshView();
	      }
	    });
	  } else {
	    this.activeDate = new Date();
	  }
	
	  $scope.isActive = function(dateObject) {
	    if (self.compare(dateObject.date, self.activeDate) === 0) {
	      $scope.activeDateId = dateObject.uid;
	      return true;
	    }
	    return false;
	  };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	  };
	
	  this.render = function() {
	    if (ngModelCtrl.$viewValue) {
	      var date = new Date(ngModelCtrl.$viewValue),
	        isValid = !isNaN(date);
	
	      if (isValid) {
	        this.activeDate = date;
	      } else if (!$datepickerSuppressError) {
	        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	      }
	    }
	    this.refreshView();
	  };
	
	  this.refreshView = function() {
	    if (this.element) {
	      this._refreshView();
	
	      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
	    }
	  };
	
	  this.createDateObject = function(date, format) {
	    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
	    return {
	      date: date,
	      label: dateFilter(date, format),
	      selected: model && this.compare(date, model) === 0,
	      disabled: this.isDisabled(date),
	      current: this.compare(date, new Date()) === 0,
	      customClass: this.customClass(date)
	    };
	  };
	
	  this.isDisabled = function(date) {
	    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
	  };
	
	  this.customClass = function(date) {
	    return $scope.customClass({date: date, mode: $scope.datepickerMode});
	  };
	
	  // Split array into smaller arrays
	  this.split = function(arr, size) {
	    var arrays = [];
	    while (arr.length > 0) {
	      arrays.push(arr.splice(0, size));
	    }
	    return arrays;
	  };
	
	  this.fixTimeZone = function(date) {
	    var hours = date.getHours();
	    date.setHours(hours === 23 ? hours + 2 : 0);
	  };
	
	  $scope.select = function(date) {
	    if ($scope.datepickerMode === self.minMode) {
	      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
	      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	      ngModelCtrl.$setViewValue(dt);
	      ngModelCtrl.$render();
	    } else {
	      self.activeDate = date;
	      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
	    }
	  };
	
	  $scope.move = function(direction) {
	    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
	      month = self.activeDate.getMonth() + direction * (self.step.months || 0);
	    self.activeDate.setFullYear(year, month, 1);
	    self.refreshView();
	  };
	
	  $scope.toggleMode = function(direction) {
	    direction = direction || 1;
	
	    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
	      return;
	    }
	
	    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
	  };
	
	  // Key event mapper
	  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
	
	  var focusElement = function() {
	    self.element[0].focus();
	  };
	
	  $scope.$on('uib:datepicker.focus', focusElement);
	
	  $scope.keydown = function(evt) {
	    var key = $scope.keys[evt.which];
	
	    if (!key || evt.shiftKey || evt.altKey) {
	      return;
	    }
	
	    evt.preventDefault();
	    if (!self.shortcutPropagation) {
	      evt.stopPropagation();
	    }
	
	    if (key === 'enter' || key === 'space') {
	      if (self.isDisabled(self.activeDate)) {
	        return; // do nothing
	      }
	      $scope.select(self.activeDate);
	    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
	      $scope.toggleMode(key === 'up' ? 1 : -1);
	    } else {
	      self.handleKeyDown(key, evt);
	      self.refreshView();
	    }
	  };
	}])
	
	.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    replace: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/datepicker.html';
	    },
	    scope: {
	      datepickerMode: '=?',
	      dateDisabled: '&',
	      customClass: '&',
	      shortcutPropagation: '&?'
	    },
	    require: ['datepicker', '^ngModel'],
	    controller: 'DatepickerController',
	    controllerAs: 'datepicker',
	    link: function(scope, element, attrs, ctrls) {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');
	      }
	
	      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      datepickerCtrl.init(ngModelCtrl);
	    }
	  };
	}])
	
	.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    replace: true,
	    templateUrl: 'template/datepicker/day.html',
	    require: ['^datepicker', 'daypicker'],
	    controller: 'UibDaypickerController',
	    link: function(scope, element, attrs, ctrls) {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');
	      }
	
	      var datepickerCtrl = ctrls[0],
	        daypickerCtrl = ctrls[1];
	
	      daypickerCtrl.init(datepickerCtrl);
	    }
	  };
	}])
	
	.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    replace: true,
	    templateUrl: 'template/datepicker/month.html',
	    require: ['^datepicker', 'monthpicker'],
	    controller: 'UibMonthpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');
	      }
	
	      var datepickerCtrl = ctrls[0],
	        monthpickerCtrl = ctrls[1];
	
	      monthpickerCtrl.init(datepickerCtrl);
	    }
	  };
	}])
	
	.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    replace: true,
	    templateUrl: 'template/datepicker/year.html',
	    require: ['^datepicker', 'yearpicker'],
	    controller: 'UibYearpickerController',
	    link: function(scope, element, attrs, ctrls) {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');
	      }
	
	      var ctrl = ctrls[0];
	      angular.extend(ctrl, ctrls[1]);
	      ctrl.yearpickerInit();
	
	      ctrl.refreshView();
	    }
	  };
	}])
	
	.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    require: ['ngModel', 'datepickerPopup'],
	    controller: 'UibDatepickerPopupController',
	    scope: {
	      isOpen: '=?',
	      currentText: '@',
	      clearText: '@',
	      closeText: '@',
	      dateDisabled: '&',
	      customClass: '&'
	    },
	    link: function(scope, element, attrs, ctrls) {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');
	      }
	
	      var ngModel = ctrls[0],
	        ctrl = ctrls[1];
	
	      ctrl.init(ngModel);
	    }
	  };
	}])
	
	.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
	  return {
	    replace: true,
	    transclude: true,
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/datepicker/popup.html';
	    },
	    link: function() {
	      if (!$datepickerSuppressWarning) {
	        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');
	      }
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])
	
	.constant('uibDropdownConfig', {
	  openClass: 'open'
	})
	
	.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
	  var openScope = null;
	
	  this.open = function(dropdownScope) {
	    if (!openScope) {
	      $document.bind('click', closeDropdown);
	      $document.bind('keydown', keybindFilter);
	    }
	
	    if (openScope && openScope !== dropdownScope) {
	      openScope.isOpen = false;
	    }
	
	    openScope = dropdownScope;
	  };
	
	  this.close = function(dropdownScope) {
	    if (openScope === dropdownScope) {
	      openScope = null;
	      $document.unbind('click', closeDropdown);
	      $document.unbind('keydown', keybindFilter);
	    }
	  };
	
	  var closeDropdown = function(evt) {
	    // This method may still be called during the same mouse event that
	    // unbound this event handler. So check openScope before proceeding.
	    if (!openScope) { return; }
	
	    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }
	
	    var toggleElement = openScope.getToggleElement();
	    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
	      return;
	    }
	
	    var dropdownElement = openScope.getDropdownElement();
	    if (evt && openScope.getAutoClose() === 'outsideClick' &&
	      dropdownElement && dropdownElement[0].contains(evt.target)) {
	      return;
	    }
	
	    openScope.isOpen = false;
	
	    if (!$rootScope.$$phase) {
	      openScope.$apply();
	    }
	  };
	
	  var keybindFilter = function(evt) {
	    if (evt.which === 27) {
	      openScope.focusToggleElement();
	      closeDropdown();
	    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      openScope.focusDropdownEntry(evt.which);
	    }
	  };
	}])
	
	.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
	  var self = this,
	    scope = $scope.$new(), // create a child scope so we are not polluting original one
	    templateScope,
	    openClass = dropdownConfig.openClass,
	    getIsOpen,
	    setIsOpen = angular.noop,
	    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	    appendToBody = false,
	    keynavEnabled =false,
	    selectedOption = null;
	
	
	  $element.addClass('dropdown');
	
	  this.init = function() {
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;
	
	      $scope.$watch(getIsOpen, function(value) {
	        scope.isOpen = !!value;
	      });
	    }
	
	    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);
	
	    if (appendToBody && self.dropdownMenu) {
	      $document.find('body').append(self.dropdownMenu);
	      $element.on('$destroy', function handleDestroyEvent() {
	        self.dropdownMenu.remove();
	      });
	    }
	  };
	
	  this.toggle = function(open) {
	    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	  };
	
	  // Allow other directives to watch status
	  this.isOpen = function() {
	    return scope.isOpen;
	  };
	
	  scope.getToggleElement = function() {
	    return self.toggleElement;
	  };
	
	  scope.getAutoClose = function() {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };
	
	  scope.getElement = function() {
	    return $element;
	  };
	
	  scope.isKeynavEnabled = function() {
	    return keynavEnabled;
	  };
	
	  scope.focusDropdownEntry = function(keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	      (angular.element(self.dropdownMenu).find('a')) :
	      (angular.element($element).find('ul').eq(0).find('a'));
	
	    switch (keyCode) {
	      case (40): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = 0;
	        } else {
	          self.selectedOption = (self.selectedOption === elems.length - 1 ?
	            self.selectedOption :
	            self.selectedOption + 1);
	        }
	        break;
	      }
	      case (38): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = elems.length - 1;
	        } else {
	          self.selectedOption = self.selectedOption === 0 ?
	            0 : self.selectedOption - 1;
	        }
	        break;
	      }
	    }
	    elems[self.selectedOption].focus();
	  };
	
	  scope.getDropdownElement = function() {
	    return self.dropdownMenu;
	  };
	
	  scope.focusToggleElement = function() {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };
	
	  scope.$watch('isOpen', function(isOpen, wasOpen) {
	    if (appendToBody && self.dropdownMenu) {
	      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
	      var css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };
	
	      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
	      }
	
	      self.dropdownMenu.css(css);
	    }
	
	    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
	      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	        toggleInvoker($scope, { open: !!isOpen });
	      }
	    });
	
	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	          });
	        });
	      }
	
	      scope.focusToggleElement();
	      uibDropdownService.open(scope);
	    } else {
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }
	
	      uibDropdownService.close(scope);
	      self.selectedOption = null;
	    }
	
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });
	
	  $scope.$on('$locationChangeSuccess', function() {
	    if (scope.getAutoClose() !== 'disabled') {
	      scope.isOpen = false;
	    }
	  });
	
	  var offDestroy = $scope.$on('$destroy', function() {
	    scope.$destroy();
	  });
	  scope.$on('$destroy', offDestroy);
	}])
	
	.directive('uibDropdown', function() {
	  return {
	    controller: 'UibDropdownController',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      dropdownCtrl.init();
	    }
	  };
	})
	
	.directive('uibDropdownMenu', function() {
	  return {
	    restrict: 'AC',
	    require: '?^uibDropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
	        return;
	      }
	
	      element.addClass('dropdown-menu');
	
	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }
	
	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	})
	
	.directive('uibKeyboardNav', function() {
	  return {
	    restrict: 'A',
	    require: '?^uibDropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      element.bind('keydown', function(e) {
	        if ([38, 40].indexOf(e.which) !== -1) {
	          e.preventDefault();
	          e.stopPropagation();
	
	          var elems = dropdownCtrl.dropdownMenu.find('a');
	
	          switch (e.which) {
	            case (40): { // Down
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = 0;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
	                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
	              }
	              break;
	            }
	            case (38): { // Up
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = elems.length - 1;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
	                  0 : dropdownCtrl.selectedOption - 1;
	              }
	              break;
	            }
	          }
	          elems[dropdownCtrl.selectedOption].focus();
	        }
	      });
	    }
	  };
	})
	
	.directive('uibDropdownToggle', function() {
	  return {
	    require: '?^uibDropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl) {
	        return;
	      }
	
	      element.addClass('dropdown-toggle');
	
	      dropdownCtrl.toggleElement = element;
	
	      var toggleDropdown = function(event) {
	        event.preventDefault();
	
	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function() {
	            dropdownCtrl.toggle();
	          });
	        }
	      };
	
	      element.bind('click', toggleDropdown);
	
	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
	        element.attr('aria-expanded', !!isOpen);
	      });
	
	      scope.$on('$destroy', function() {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	});
	
	/* Deprecated dropdown below */
	
	angular.module('ui.bootstrap.dropdown')
	
	.value('$dropdownSuppressWarning', false)
	
	.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {
	  if (!$dropdownSuppressWarning) {
	    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');
	  }
	
	  angular.extend(this, uibDropdownService);
	}])
	
	.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {
	  if (!$dropdownSuppressWarning) {
	    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');
	  }
	
	  var self = this,
	    scope = $scope.$new(), // create a child scope so we are not polluting original one
	    templateScope,
	    openClass = dropdownConfig.openClass,
	    getIsOpen,
	    setIsOpen = angular.noop,
	    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
	    appendToBody = false,
	    keynavEnabled =false,
	    selectedOption = null;
	
	
	  $element.addClass('dropdown');
	
	  this.init = function() {
	    if ($attrs.isOpen) {
	      getIsOpen = $parse($attrs.isOpen);
	      setIsOpen = getIsOpen.assign;
	
	      $scope.$watch(getIsOpen, function(value) {
	        scope.isOpen = !!value;
	      });
	    }
	
	    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
	    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);
	
	    if (appendToBody && self.dropdownMenu) {
	      $document.find('body').append(self.dropdownMenu);
	      $element.on('$destroy', function handleDestroyEvent() {
	        self.dropdownMenu.remove();
	      });
	    }
	  };
	
	  this.toggle = function(open) {
	    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
	  };
	
	  // Allow other directives to watch status
	  this.isOpen = function() {
	    return scope.isOpen;
	  };
	
	  scope.getToggleElement = function() {
	    return self.toggleElement;
	  };
	
	  scope.getAutoClose = function() {
	    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
	  };
	
	  scope.getElement = function() {
	    return $element;
	  };
	
	  scope.isKeynavEnabled = function() {
	    return keynavEnabled;
	  };
	
	  scope.focusDropdownEntry = function(keyCode) {
	    var elems = self.dropdownMenu ? //If append to body is used.
	      (angular.element(self.dropdownMenu).find('a')) :
	      (angular.element($element).find('ul').eq(0).find('a'));
	
	    switch (keyCode) {
	      case (40): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = 0;
	        } else {
	          self.selectedOption = (self.selectedOption === elems.length -1 ?
	            self.selectedOption :
	          self.selectedOption + 1);
	        }
	        break;
	      }
	      case (38): {
	        if (!angular.isNumber(self.selectedOption)) {
	          self.selectedOption = elems.length - 1;
	        } else {
	          self.selectedOption = self.selectedOption === 0 ?
	            0 : self.selectedOption - 1;
	        }
	        break;
	      }
	    }
	    elems[self.selectedOption].focus();
	  };
	
	  scope.getDropdownElement = function() {
	    return self.dropdownMenu;
	  };
	
	  scope.focusToggleElement = function() {
	    if (self.toggleElement) {
	      self.toggleElement[0].focus();
	    }
	  };
	
	  scope.$watch('isOpen', function(isOpen, wasOpen) {
	    if (appendToBody && self.dropdownMenu) {
	      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
	      var css = {
	        top: pos.top + 'px',
	        display: isOpen ? 'block' : 'none'
	      };
	
	      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
	      if (!rightalign) {
	        css.left = pos.left + 'px';
	        css.right = 'auto';
	      } else {
	        css.left = 'auto';
	        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
	      }
	
	      self.dropdownMenu.css(css);
	    }
	
	    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
	      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
	        toggleInvoker($scope, { open: !!isOpen });
	      }
	    });
	
	    if (isOpen) {
	      if (self.dropdownMenuTemplateUrl) {
	        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
	          templateScope = scope.$new();
	          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
	            var newEl = dropdownElement;
	            self.dropdownMenu.replaceWith(newEl);
	            self.dropdownMenu = newEl;
	          });
	        });
	      }
	
	      scope.focusToggleElement();
	      uibDropdownService.open(scope);
	    } else {
	      if (self.dropdownMenuTemplateUrl) {
	        if (templateScope) {
	          templateScope.$destroy();
	        }
	        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
	        self.dropdownMenu.replaceWith(newEl);
	        self.dropdownMenu = newEl;
	      }
	
	      uibDropdownService.close(scope);
	      self.selectedOption = null;
	    }
	
	    if (angular.isFunction(setIsOpen)) {
	      setIsOpen($scope, isOpen);
	    }
	  });
	
	  $scope.$on('$locationChangeSuccess', function() {
	    if (scope.getAutoClose() !== 'disabled') {
	      scope.isOpen = false;
	    }
	  });
	
	  var offDestroy = $scope.$on('$destroy', function() {
	    scope.$destroy();
	  });
	  scope.$on('$destroy', offDestroy);
	}])
	
	.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
	  return {
	    controller: 'DropdownController',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!$dropdownSuppressWarning) {
	        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');
	      }
	
	      dropdownCtrl.init();
	    }
	  };
	}])
	
	.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
	  return {
	    restrict: 'AC',
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
	        return;
	      }
	
	      if (!$dropdownSuppressWarning) {
	        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');
	      }
	
	      element.addClass('dropdown-menu');
	
	      var tplUrl = attrs.templateUrl;
	      if (tplUrl) {
	        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
	      }
	
	      if (!dropdownCtrl.dropdownMenu) {
	        dropdownCtrl.dropdownMenu = element;
	      }
	    }
	  };
	}])
	
	.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
	  return {
	    restrict: 'A',
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!$dropdownSuppressWarning) {
	        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');
	      }
	
	      element.bind('keydown', function(e) {
	        if ([38, 40].indexOf(e.which) !== -1) {
	          e.preventDefault();
	          e.stopPropagation();
	
	          var elems = dropdownCtrl.dropdownMenu.find('a');
	
	          switch (e.which) {
	            case (40): { // Down
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = 0;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
	                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
	              }
	              break;
	            }
	            case (38): { // Up
	              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
	                dropdownCtrl.selectedOption = elems.length - 1;
	              } else {
	                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
	                  0 : dropdownCtrl.selectedOption - 1;
	              }
	              break;
	            }
	          }
	          elems[dropdownCtrl.selectedOption].focus();
	        }
	      });
	    }
	  };
	}])
	
	.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
	  return {
	    require: '?^dropdown',
	    link: function(scope, element, attrs, dropdownCtrl) {
	      if (!$dropdownSuppressWarning) {
	        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');
	      }
	
	      if (!dropdownCtrl) {
	        return;
	      }
	
	      element.addClass('dropdown-toggle');
	
	      dropdownCtrl.toggleElement = element;
	
	      var toggleDropdown = function(event) {
	        event.preventDefault();
	
	        if (!element.hasClass('disabled') && !attrs.disabled) {
	          scope.$apply(function() {
	            dropdownCtrl.toggle();
	          });
	        }
	      };
	
	      element.bind('click', toggleDropdown);
	
	      // WAI-ARIA
	      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
	      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
	        element.attr('aria-expanded', !!isOpen);
	      });
	
	      scope.$on('$destroy', function() {
	        element.unbind('click', toggleDropdown);
	      });
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.stackedMap', [])
	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	  .factory('$$stackedMap', function() {
	    return {
	      createNew: function() {
	        var stack = [];
	
	        return {
	          add: function(key, value) {
	            stack.push({
	              key: key,
	              value: value
	            });
	          },
	          get: function(key) {
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                return stack[i];
	              }
	            }
	          },
	          keys: function() {
	            var keys = [];
	            for (var i = 0; i < stack.length; i++) {
	              keys.push(stack[i].key);
	            }
	            return keys;
	          },
	          top: function() {
	            return stack[stack.length - 1];
	          },
	          remove: function(key) {
	            var idx = -1;
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                idx = i;
	                break;
	              }
	            }
	            return stack.splice(idx, 1)[0];
	          },
	          removeTop: function() {
	            return stack.splice(stack.length - 1, 1)[0];
	          },
	          length: function() {
	            return stack.length;
	          }
	        };
	      }
	    };
	  });
	angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
	/**
	 * A helper, internal data structure that stores all references attached to key
	 */
	  .factory('$$multiMap', function() {
	    return {
	      createNew: function() {
	        var map = {};
	
	        return {
	          entries: function() {
	            return Object.keys(map).map(function(key) {
	              return {
	                key: key,
	                value: map[key]
	              };
	            });
	          },
	          get: function(key) {
	            return map[key];
	          },
	          hasKey: function(key) {
	            return !!map[key];
	          },
	          keys: function() {
	            return Object.keys(map);
	          },
	          put: function(key, value) {
	            if (!map[key]) {
	              map[key] = [];
	            }
	
	            map[key].push(value);
	          },
	          remove: function(key, value) {
	            var values = map[key];
	
	            if (!values) {
	              return;
	            }
	
	            var idx = values.indexOf(value);
	
	            if (idx !== -1) {
	              values.splice(idx, 1);
	            }
	
	            if (!values.length) {
	              delete map[key];
	            }
	          }
	        };
	      }
	    };
	  })
	
	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	  .directive('uibModalBackdrop', [
	           '$animate', '$injector', '$uibModalStack',
	  function($animate ,  $injector,   $modalStack) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      replace: true,
	      templateUrl: 'template/modal/backdrop.html',
	      compile: function(tElement, tAttrs) {
	        tElement.addClass(tAttrs.backdropClass);
	        return linkFn;
	      }
	    };
	
	    function linkFn(scope, element, attrs) {
	      // Temporary fix for prefixing
	      element.addClass('modal-backdrop');
	
	      if (attrs.modalInClass) {
	        if ($animateCss) {
	          $animateCss(element, {
	            addClass: attrs.modalInClass
	          }).start();
	        } else {
	          $animate.addClass(element, attrs.modalInClass);
	        }
	
	        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	          var done = setIsAsync();
	          if ($animateCss) {
	            $animateCss(element, {
	              removeClass: attrs.modalInClass
	            }).start().then(done);
	          } else {
	            $animate.removeClass(element, attrs.modalInClass).then(done);
	          }
	        });
	      }
	    }
	  }])
	
	  .directive('uibModalWindow', [
	           '$uibModalStack', '$q', '$animate', '$injector',
	  function($modalStack ,  $q ,  $animate,   $injector) {
	    var $animateCss = null;
	
	    if ($injector.has('$animateCss')) {
	      $animateCss = $injector.get('$animateCss');
	    }
	
	    return {
	      scope: {
	        index: '@'
	      },
	      replace: true,
	      transclude: true,
	      templateUrl: function(tElement, tAttrs) {
	        return tAttrs.templateUrl || 'template/modal/window.html';
	      },
	      link: function(scope, element, attrs) {
	        element.addClass(attrs.windowClass || '');
	        element.addClass(attrs.windowTopClass || '');
	        scope.size = attrs.size;
	
	        scope.close = function(evt) {
	          var modal = $modalStack.getTop();
	          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
	            evt.preventDefault();
	            evt.stopPropagation();
	            $modalStack.dismiss(modal.key, 'backdrop click');
	          }
	        };
	
	        // moved from template to fix issue #2280
	        element.on('click', scope.close);
	
	        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	        // We can detect that by using this property in the template associated with this directive and then use
	        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	        scope.$isRendered = true;
	
	        // Deferred object that will be resolved when this modal is render.
	        var modalRenderDeferObj = $q.defer();
	        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
	        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
	        attrs.$observe('modalRender', function(value) {
	          if (value == 'true') {
	            modalRenderDeferObj.resolve();
	          }
	        });
	
	        modalRenderDeferObj.promise.then(function() {
	          var animationPromise = null;
	
	          if (attrs.modalInClass) {
	            if ($animateCss) {
	              animationPromise = $animateCss(element, {
	                addClass: attrs.modalInClass
	              }).start();
	            } else {
	              animationPromise = $animate.addClass(element, attrs.modalInClass);
	            }
	
	            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	              var done = setIsAsync();
	              if ($animateCss) {
	                $animateCss(element, {
	                  removeClass: attrs.modalInClass
	                }).start().then(done);
	              } else {
	                $animate.removeClass(element, attrs.modalInClass).then(done);
	              }
	            });
	          }
	
	
	          $q.when(animationPromise).then(function() {
	            var inputWithAutofocus = element[0].querySelector('[autofocus]');
	            /**
	             * Auto-focusing of a freshly-opened modal element causes any child elements
	             * with the autofocus attribute to lose focus. This is an issue on touch
	             * based devices which will show and then hide the onscreen keyboard.
	             * Attempts to refocus the autofocus element via JavaScript will not reopen
	             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	             * the modal element if the modal does not contain an autofocus element.
	             */
	            if (inputWithAutofocus) {
	              inputWithAutofocus.focus();
	            } else {
	              element[0].focus();
	            }
	          });
	
	          // Notify {@link $modalStack} that modal is rendered.
	          var modal = $modalStack.getTop();
	          if (modal) {
	            $modalStack.modalRendered(modal.key);
	          }
	        });
	      }
	    };
	  }])
	
	  .directive('uibModalAnimationClass', function() {
	    return {
	      compile: function(tElement, tAttrs) {
	        if (tAttrs.modalAnimation) {
	          tElement.addClass(tAttrs.uibModalAnimationClass);
	        }
	      }
	    };
	  })
	
	  .directive('uibModalTransclude', function() {
	    return {
	      link: function($scope, $element, $attrs, controller, $transclude) {
	        $transclude($scope.$parent, function(clone) {
	          $element.empty();
	          $element.append(clone);
	        });
	      }
	    };
	  })
	
	  .factory('$uibModalStack', [
	             '$animate', '$timeout', '$document', '$compile', '$rootScope',
	             '$q',
	             '$injector',
	             '$$multiMap',
	             '$$stackedMap',
	    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
	              $q,
	              $injector,
	              $$multiMap,
	              $$stackedMap) {
	      var $animateCss = null;
	
	      if ($injector.has('$animateCss')) {
	        $animateCss = $injector.get('$animateCss');
	      }
	
	      var OPENED_MODAL_CLASS = 'modal-open';
	
	      var backdropDomEl, backdropScope;
	      var openedWindows = $$stackedMap.createNew();
	      var openedClasses = $$multiMap.createNew();
	      var $modalStack = {
	        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
	      };
	
	      //Modal focus behavior
	      var focusableElementList;
	      var focusIndex = 0;
	      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
	        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
	        'iframe, object, embed, *[tabindex], *[contenteditable=true]';
	
	      function backdropIndex() {
	        var topBackdropIndex = -1;
	        var opened = openedWindows.keys();
	        for (var i = 0; i < opened.length; i++) {
	          if (openedWindows.get(opened[i]).value.backdrop) {
	            topBackdropIndex = i;
	          }
	        }
	        return topBackdropIndex;
	      }
	
	      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
	        if (backdropScope) {
	          backdropScope.index = newBackdropIndex;
	        }
	      });
	
	      function removeModalWindow(modalInstance, elementToReceiveFocus) {
	        var body = $document.find('body').eq(0);
	        var modalWindow = openedWindows.get(modalInstance).value;
	
	        //clean up the stack
	        openedWindows.remove(modalInstance);
	
	        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
	          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
	          openedClasses.remove(modalBodyClass, modalInstance);
	          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
	          toggleTopWindowClass(true);
	        });
	        checkRemoveBackdrop();
	
	        //move focus to specified element if available, or else to body
	        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
	          elementToReceiveFocus.focus();
	        } else {
	          body.focus();
	        }
	      }
	
	      // Add or remove "windowTopClass" from the top window in the stack
	      function toggleTopWindowClass(toggleSwitch) {
	        var modalWindow;
	
	        if (openedWindows.length() > 0) {
	          modalWindow = openedWindows.top().value;
	          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
	        }
	      }
	
	      function checkRemoveBackdrop() {
	        //remove backdrop if no longer needed
	        if (backdropDomEl && backdropIndex() == -1) {
	          var backdropScopeRef = backdropScope;
	          removeAfterAnimate(backdropDomEl, backdropScope, function() {
	            backdropScopeRef = null;
	          });
	          backdropDomEl = undefined;
	          backdropScope = undefined;
	        }
	      }
	
	      function removeAfterAnimate(domEl, scope, done) {
	        var asyncDeferred;
	        var asyncPromise = null;
	        var setIsAsync = function() {
	          if (!asyncDeferred) {
	            asyncDeferred = $q.defer();
	            asyncPromise = asyncDeferred.promise;
	          }
	
	          return function asyncDone() {
	            asyncDeferred.resolve();
	          };
	        };
	        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
	
	        // Note that it's intentional that asyncPromise might be null.
	        // That's when setIsAsync has not been called during the
	        // NOW_CLOSING_EVENT broadcast.
	        return $q.when(asyncPromise).then(afterAnimating);
	
	        function afterAnimating() {
	          if (afterAnimating.done) {
	            return;
	          }
	          afterAnimating.done = true;
	
	          if ($animateCss) {
	            $animateCss(domEl, {
	              event: 'leave'
	            }).start().then(function() {
	              domEl.remove();
	            });
	          } else {
	            $animate.leave(domEl);
	          }
	          scope.$destroy();
	          if (done) {
	            done();
	          }
	        }
	      }
	
	      $document.bind('keydown', function(evt) {
	        if (evt.isDefaultPrevented()) {
	          return evt;
	        }
	
	        var modal = openedWindows.top();
	        if (modal && modal.value.keyboard) {
	          switch (evt.which) {
	            case 27: {
	              evt.preventDefault();
	              $rootScope.$apply(function() {
	                $modalStack.dismiss(modal.key, 'escape key press');
	              });
	              break;
	            }
	            case 9: {
	              $modalStack.loadFocusElementList(modal);
	              var focusChanged = false;
	              if (evt.shiftKey) {
	                if ($modalStack.isFocusInFirstItem(evt)) {
	                  focusChanged = $modalStack.focusLastFocusableElement();
	                }
	              } else {
	                if ($modalStack.isFocusInLastItem(evt)) {
	                  focusChanged = $modalStack.focusFirstFocusableElement();
	                }
	              }
	
	              if (focusChanged) {
	                evt.preventDefault();
	                evt.stopPropagation();
	              }
	              break;
	            }
	          }
	        }
	      });
	
	      $modalStack.open = function(modalInstance, modal) {
	        var modalOpener = $document[0].activeElement,
	          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
	
	        toggleTopWindowClass(false);
	
	        openedWindows.add(modalInstance, {
	          deferred: modal.deferred,
	          renderDeferred: modal.renderDeferred,
	          modalScope: modal.scope,
	          backdrop: modal.backdrop,
	          keyboard: modal.keyboard,
	          openedClass: modal.openedClass,
	          windowTopClass: modal.windowTopClass
	        });
	
	        openedClasses.put(modalBodyClass, modalInstance);
	
	        var body = $document.find('body').eq(0),
	            currBackdropIndex = backdropIndex();
	
	        if (currBackdropIndex >= 0 && !backdropDomEl) {
	          backdropScope = $rootScope.$new(true);
	          backdropScope.index = currBackdropIndex;
	          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
	          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
	          if (modal.animation) {
	            angularBackgroundDomEl.attr('modal-animation', 'true');
	          }
	          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
	          body.append(backdropDomEl);
	        }
	
	        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
	        angularDomEl.attr({
	          'template-url': modal.windowTemplateUrl,
	          'window-class': modal.windowClass,
	          'window-top-class': modal.windowTopClass,
	          'size': modal.size,
	          'index': openedWindows.length() - 1,
	          'animate': 'animate'
	        }).html(modal.content);
	        if (modal.animation) {
	          angularDomEl.attr('modal-animation', 'true');
	        }
	
	        var modalDomEl = $compile(angularDomEl)(modal.scope);
	        openedWindows.top().value.modalDomEl = modalDomEl;
	        openedWindows.top().value.modalOpener = modalOpener;
	        body.append(modalDomEl);
	        body.addClass(modalBodyClass);
	
	        $modalStack.clearFocusListCache();
	      };
	
	      function broadcastClosing(modalWindow, resultOrReason, closing) {
	        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
	      }
	
	      $modalStack.close = function(modalInstance, result) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.resolve(result);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismiss = function(modalInstance, reason) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
	          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
	          modalWindow.value.deferred.reject(reason);
	          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
	          return true;
	        }
	        return !modalWindow;
	      };
	
	      $modalStack.dismissAll = function(reason) {
	        var topModal = this.getTop();
	        while (topModal && this.dismiss(topModal.key, reason)) {
	          topModal = this.getTop();
	        }
	      };
	
	      $modalStack.getTop = function() {
	        return openedWindows.top();
	      };
	
	      $modalStack.modalRendered = function(modalInstance) {
	        var modalWindow = openedWindows.get(modalInstance);
	        if (modalWindow) {
	          modalWindow.value.renderDeferred.resolve();
	        }
	      };
	
	      $modalStack.focusFirstFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[0].focus();
	          return true;
	        }
	        return false;
	      };
	      $modalStack.focusLastFocusableElement = function() {
	        if (focusableElementList.length > 0) {
	          focusableElementList[focusableElementList.length - 1].focus();
	          return true;
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInFirstItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[0];
	        }
	        return false;
	      };
	
	      $modalStack.isFocusInLastItem = function(evt) {
	        if (focusableElementList.length > 0) {
	          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
	        }
	        return false;
	      };
	
	      $modalStack.clearFocusListCache = function() {
	        focusableElementList = [];
	        focusIndex = 0;
	      };
	
	      $modalStack.loadFocusElementList = function(modalWindow) {
	        if (focusableElementList === undefined || !focusableElementList.length) {
	          if (modalWindow) {
	            var modalDomE1 = modalWindow.value.modalDomEl;
	            if (modalDomE1 && modalDomE1.length) {
	              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
	            }
	          }
	        }
	      };
	
	      return $modalStack;
	    }])
	
	  .provider('$uibModal', function() {
	    var $modalProvider = {
	      options: {
	        animation: true,
	        backdrop: true, //can also be false or 'static'
	        keyboard: true
	      },
	      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',
	        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {
	          var $modal = {};
	
	          function getTemplatePromise(options) {
	            return options.template ? $q.when(options.template) :
	              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
	          }
	
	          function getResolvePromises(resolves) {
	            var promisesArr = [];
	            angular.forEach(resolves, function(value) {
	              if (angular.isFunction(value) || angular.isArray(value)) {
	                promisesArr.push($q.when($injector.invoke(value)));
	              } else if (angular.isString(value)) {
	                promisesArr.push($q.when($injector.get(value)));
	              } else {
	                promisesArr.push($q.when(value));
	              }
	            });
	            return promisesArr;
	          }
	
	          var promiseChain = null;
	          $modal.getPromiseChain = function() {
	            return promiseChain;
	          };
	
	          $modal.open = function(modalOptions) {
	            var modalResultDeferred = $q.defer();
	            var modalOpenedDeferred = $q.defer();
	            var modalRenderDeferred = $q.defer();
	
	            //prepare an instance of a modal to be injected into controllers and returned to a caller
	            var modalInstance = {
	              result: modalResultDeferred.promise,
	              opened: modalOpenedDeferred.promise,
	              rendered: modalRenderDeferred.promise,
	              close: function (result) {
	                return $modalStack.close(modalInstance, result);
	              },
	              dismiss: function (reason) {
	                return $modalStack.dismiss(modalInstance, reason);
	              }
	            };
	
	            //merge and clean up options
	            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	            modalOptions.resolve = modalOptions.resolve || {};
	
	            //verify options
	            if (!modalOptions.template && !modalOptions.templateUrl) {
	              throw new Error('One of template or templateUrl options is required.');
	            }
	
	            var templateAndResolvePromise =
	              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
	
	            function resolveWithTemplate() {
	              return templateAndResolvePromise;
	            }
	
	            // Wait for the resolution of the existing promise chain.
	            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
	            // Then add to $modalStack and resolve opened.
	            // Finally clean up the chain variable if no subsequent modal has overwritten it.
	            var samePromise;
	            samePromise = promiseChain = $q.all([promiseChain])
	              .then(resolveWithTemplate, resolveWithTemplate)
	              .then(function resolveSuccess(tplAndVars) {
	
	                var modalScope = (modalOptions.scope || $rootScope).$new();
	                modalScope.$close = modalInstance.close;
	                modalScope.$dismiss = modalInstance.dismiss;
	
	                modalScope.$on('$destroy', function() {
	                  if (!modalScope.$$uibDestructionScheduled) {
	                    modalScope.$dismiss('$uibUnscheduledDestruction');
	                  }
	                });
	
	                var ctrlInstance, ctrlLocals = {};
	                var resolveIter = 1;
	
	                //controllers
	                if (modalOptions.controller) {
	                  ctrlLocals.$scope = modalScope;
	                  ctrlLocals.$uibModalInstance = modalInstance;
	                  Object.defineProperty(ctrlLocals, '$modalInstance', {
	                    get: function() {
	                      if (!$modalSuppressWarning) {
	                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');
	                      }
	
	                      return modalInstance;
	                    }
	                  });
	                  angular.forEach(modalOptions.resolve, function(value, key) {
	                    ctrlLocals[key] = tplAndVars[resolveIter++];
	                  });
	
	                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
	                  if (modalOptions.controllerAs) {
	                    if (modalOptions.bindToController) {
	                      angular.extend(ctrlInstance, modalScope);
	                    }
	
	                    modalScope[modalOptions.controllerAs] = ctrlInstance;
	                  }
	                }
	
	                $modalStack.open(modalInstance, {
	                  scope: modalScope,
	                  deferred: modalResultDeferred,
	                  renderDeferred: modalRenderDeferred,
	                  content: tplAndVars[0],
	                  animation: modalOptions.animation,
	                  backdrop: modalOptions.backdrop,
	                  keyboard: modalOptions.keyboard,
	                  backdropClass: modalOptions.backdropClass,
	                  windowTopClass: modalOptions.windowTopClass,
	                  windowClass: modalOptions.windowClass,
	                  windowTemplateUrl: modalOptions.windowTemplateUrl,
	                  size: modalOptions.size,
	                  openedClass: modalOptions.openedClass
	                });
	                modalOpenedDeferred.resolve(true);
	
	            }, function resolveError(reason) {
	              modalOpenedDeferred.reject(reason);
	              modalResultDeferred.reject(reason);
	            })
	            .finally(function() {
	              if (promiseChain === samePromise) {
	                promiseChain = null;
	              }
	            });
	
	            return modalInstance;
	          };
	
	          return $modal;
	        }
	      ]
	    };
	
	    return $modalProvider;
	  });
	
	/* deprecated modal below */
	
	angular.module('ui.bootstrap.modal')
	
	  .value('$modalSuppressWarning', false)
	
	  /**
	   * A helper directive for the $modal service. It creates a backdrop element.
	   */
	  .directive('modalBackdrop', [
	    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',
	    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {
	      var $animateCss = null;
	
	      if ($injector.has('$animateCss')) {
	        $animateCss = $injector.get('$animateCss');
	      }
	
	      return {
	        replace: true,
	        templateUrl: 'template/modal/backdrop.html',
	        compile: function(tElement, tAttrs) {
	          tElement.addClass(tAttrs.backdropClass);
	          return linkFn;
	        }
	      };
	
	      function linkFn(scope, element, attrs) {
	        if (!$modalSuppressWarning) {
	          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');
	        }
	        element.addClass('modal-backdrop');
	
	        if (attrs.modalInClass) {
	          if ($animateCss) {
	            $animateCss(element, {
	              addClass: attrs.modalInClass
	            }).start();
	          } else {
	            $animate.addClass(element, attrs.modalInClass);
	          }
	
	          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	            var done = setIsAsync();
	            if ($animateCss) {
	              $animateCss(element, {
	                removeClass: attrs.modalInClass
	              }).start().then(done);
	            } else {
	              $animate.removeClass(element, attrs.modalInClass).then(done);
	            }
	          });
	        }
	      }
	    }])
	
	  .directive('modalWindow', [
	    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',
	    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {
	      var $animateCss = null;
	
	      if ($injector.has('$animateCss')) {
	        $animateCss = $injector.get('$animateCss');
	      }
	
	      return {
	        scope: {
	          index: '@'
	        },
	        replace: true,
	        transclude: true,
	        templateUrl: function(tElement, tAttrs) {
	          return tAttrs.templateUrl || 'template/modal/window.html';
	        },
	        link: function(scope, element, attrs) {
	          if (!$modalSuppressWarning) {
	            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');
	          }
	          element.addClass(attrs.windowClass || '');
	          element.addClass(attrs.windowTopClass || '');
	          scope.size = attrs.size;
	
	          scope.close = function(evt) {
	            var modal = $modalStack.getTop();
	            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
	              evt.preventDefault();
	              evt.stopPropagation();
	              $modalStack.dismiss(modal.key, 'backdrop click');
	            }
	          };
	
	          // moved from template to fix issue #2280
	          element.on('click', scope.close);
	
	          // This property is only added to the scope for the purpose of detecting when this directive is rendered.
	          // We can detect that by using this property in the template associated with this directive and then use
	          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
	          scope.$isRendered = true;
	
	          // Deferred object that will be resolved when this modal is render.
	          var modalRenderDeferObj = $q.defer();
	          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
	          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
	          attrs.$observe('modalRender', function(value) {
	            if (value == 'true') {
	              modalRenderDeferObj.resolve();
	            }
	          });
	
	          modalRenderDeferObj.promise.then(function() {
	            var animationPromise = null;
	
	            if (attrs.modalInClass) {
	              if ($animateCss) {
	                animationPromise = $animateCss(element, {
	                  addClass: attrs.modalInClass
	                }).start();
	              } else {
	                animationPromise = $animate.addClass(element, attrs.modalInClass);
	              }
	
	              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
	                var done = setIsAsync();
	                if ($animateCss) {
	                  $animateCss(element, {
	                    removeClass: attrs.modalInClass
	                  }).start().then(done);
	                } else {
	                  $animate.removeClass(element, attrs.modalInClass).then(done);
	                }
	              });
	            }
	
	
	            $q.when(animationPromise).then(function() {
	              var inputWithAutofocus = element[0].querySelector('[autofocus]');
	              /**
	               * Auto-focusing of a freshly-opened modal element causes any child elements
	               * with the autofocus attribute to lose focus. This is an issue on touch
	               * based devices which will show and then hide the onscreen keyboard.
	               * Attempts to refocus the autofocus element via JavaScript will not reopen
	               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
	               * the modal element if the modal does not contain an autofocus element.
	               */
	              if (inputWithAutofocus) {
	                inputWithAutofocus.focus();
	              } else {
	                element[0].focus();
	              }
	            });
	
	            // Notify {@link $modalStack} that modal is rendered.
	            var modal = $modalStack.getTop();
	            if (modal) {
	              $modalStack.modalRendered(modal.key);
	            }
	          });
	        }
	      };
	    }])
	
	  .directive('modalAnimationClass', [
	    '$log', '$modalSuppressWarning',
	    function ($log, $modalSuppressWarning) {
	      return {
	        compile: function(tElement, tAttrs) {
	          if (!$modalSuppressWarning) {
	            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');
	          }
	          if (tAttrs.modalAnimation) {
	            tElement.addClass(tAttrs.modalAnimationClass);
	          }
	        }
	      };
	    }])
	
	  .directive('modalTransclude', [
	    '$log', '$modalSuppressWarning',
	    function ($log, $modalSuppressWarning) {
	    return {
	      link: function($scope, $element, $attrs, controller, $transclude) {
	        if (!$modalSuppressWarning) {
	          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');
	        }
	        $transclude($scope.$parent, function(clone) {
	          $element.empty();
	          $element.append(clone);
	        });
	      }
	    };
	  }])
	
	  .service('$modalStack', [
	    '$animate', '$timeout', '$document', '$compile', '$rootScope',
	    '$q',
	    '$injector',
	    '$$multiMap',
	    '$$stackedMap',
	    '$uibModalStack',
	    '$log',
	    '$modalSuppressWarning',
	    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
	             $q,
	             $injector,
	             $$multiMap,
	             $$stackedMap,
	             $uibModalStack,
	             $log,
	             $modalSuppressWarning) {
	      if (!$modalSuppressWarning) {
	        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');
	      }
	
	      angular.extend(this, $uibModalStack);
	    }])
	
	  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {
	    angular.extend(this, $uibModalProvider);
	
	    this.$get = ['$injector', '$log', '$modalSuppressWarning',
	      function ($injector, $log, $modalSuppressWarning) {
	        if (!$modalSuppressWarning) {
	          $log.warn('$modal is now deprecated. Use $uibModal instead.');
	        }
	
	        return $injector.invoke($uibModalProvider.$get);
	      }];
	  }]);
	
	angular.module('ui.bootstrap.pagination', [])
	.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
	  var self = this,
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	
	  this.init = function(ngModelCtrl_, config) {
	    ngModelCtrl = ngModelCtrl_;
	    this.config = config;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = config.itemsPerPage;
	    }
	
	    $scope.$watch('totalItems', function() {
	      $scope.totalPages = self.calculateTotalPages();
	    });
	
	    $scope.$watch('totalPages', function(value) {
	      setNumPages($scope.$parent, value); // Readonly variable
	
	      if ( $scope.page > value ) {
	        $scope.selectPage(value);
	      } else {
	        ngModelCtrl.$render();
	      }
	    });
	  };
	
	  this.calculateTotalPages = function() {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };
	
	  this.render = function() {
	    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
	  };
	
	  $scope.selectPage = function(page, evt) {
	    if (evt) {
	      evt.preventDefault();
	    }
	
	    var clickAllowed = !$scope.ngDisabled || !evt;
	    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	      if (evt && evt.target) {
	        evt.target.blur();
	      }
	      ngModelCtrl.$setViewValue(page);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.getText = function(key) {
	    return $scope[key + 'Text'] || self.config[key + 'Text'];
	  };
	
	  $scope.noPrevious = function() {
	    return $scope.page === 1;
	  };
	
	  $scope.noNext = function() {
	    return $scope.page === $scope.totalPages;
	  };
	}])
	
	.constant('uibPaginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true
	})
	
	.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled:'='
	    },
	    require: ['uibPagination', '?ngModel'],
	    controller: 'UibPaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pagination.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      // Setup configuration parameters
	      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
	          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
	      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
	      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
	
	      paginationCtrl.init(ngModelCtrl, paginationConfig);
	
	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }
	
	      // Create page object used in template
	      function makePage(number, text, isActive) {
	        return {
	          number: number,
	          text: text,
	          active: isActive
	        };
	      }
	
	      function getPages(currentPage, totalPages) {
	        var pages = [];
	
	        // Default page limits
	        var startPage = 1, endPage = totalPages;
	        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
	
	        // recompute if maxSize
	        if (isMaxSized) {
	          if (rotate) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
	            endPage   = startPage + maxSize - 1;
	
	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage   = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
	
	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }
	
	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, number === currentPage);
	          pages.push(page);
	        }
	
	        // Add links to move between page sets
	        if (isMaxSized && ! rotate) {
	          if (startPage > 1) {
	            var previousPageSet = makePage(startPage - 1, '...', false);
	            pages.unshift(previousPageSet);
	          }
	
	          if (endPage < totalPages) {
	            var nextPageSet = makePage(endPage + 1, '...', false);
	            pages.push(nextPageSet);
	          }
	        }
	
	        return pages;
	      }
	
	      var originalRender = paginationCtrl.render;
	      paginationCtrl.render = function() {
	        originalRender();
	        if (scope.page > 0 && scope.page <= scope.totalPages) {
	          scope.pages = getPages(scope.page, scope.totalPages);
	        }
	      };
	    }
	  };
	}])
	
	.constant('uibPagerConfig', {
	  itemsPerPage: 10,
	  previousText: '« Previous',
	  nextText: 'Next »',
	  align: true
	})
	
	.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['uibPager', '?ngModel'],
	    controller: 'UibPaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pager.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
	      paginationCtrl.init(ngModelCtrl, pagerConfig);
	    }
	  };
	}]);
	
	/* Deprecated Pagination Below */
	
	angular.module('ui.bootstrap.pagination')
	.value('$paginationSuppressWarning', false)
	.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {
	  if (!$paginationSuppressWarning) {
	    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');
	  }
	
	  var self = this,
	    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
	
	  this.init = function(ngModelCtrl_, config) {
	    ngModelCtrl = ngModelCtrl_;
	    this.config = config;
	
	    ngModelCtrl.$render = function() {
	      self.render();
	    };
	
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = config.itemsPerPage;
	    }
	
	    $scope.$watch('totalItems', function() {
	      $scope.totalPages = self.calculateTotalPages();
	    });
	
	    $scope.$watch('totalPages', function(value) {
	      setNumPages($scope.$parent, value); // Readonly variable
	
	      if ( $scope.page > value ) {
	        $scope.selectPage(value);
	      } else {
	        ngModelCtrl.$render();
	      }
	    });
	  };
	
	  this.calculateTotalPages = function() {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };
	
	  this.render = function() {
	    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
	  };
	
	  $scope.selectPage = function(page, evt) {
	    if (evt) {
	      evt.preventDefault();
	    }
	
	    var clickAllowed = !$scope.ngDisabled || !evt;
	    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
	      if (evt && evt.target) {
	        evt.target.blur();
	      }
	      ngModelCtrl.$setViewValue(page);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.getText = function(key) {
	    return $scope[key + 'Text'] || self.config[key + 'Text'];
	  };
	
	  $scope.noPrevious = function() {
	    return $scope.page === 1;
	  };
	
	  $scope.noNext = function() {
	    return $scope.page === $scope.totalPages;
	  };
	}])
	.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      firstText: '@',
	      previousText: '@',
	      nextText: '@',
	      lastText: '@',
	      ngDisabled:'='
	    },
	    require: ['pagination', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pagination.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      if (!$paginationSuppressWarning) {
	        $log.warn('pagination is now deprecated. Use uib-pagination instead.');
	      }
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      // Setup configuration parameters
	      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
	          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
	      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
	      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
	
	      paginationCtrl.init(ngModelCtrl, paginationConfig);
	
	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }
	
	      // Create page object used in template
	      function makePage(number, text, isActive) {
	        return {
	          number: number,
	          text: text,
	          active: isActive
	        };
	      }
	
	      function getPages(currentPage, totalPages) {
	        var pages = [];
	
	        // Default page limits
	        var startPage = 1, endPage = totalPages;
	        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
	
	        // recompute if maxSize
	        if (isMaxSized) {
	          if (rotate) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
	            endPage   = startPage + maxSize - 1;
	
	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage   = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
	
	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }
	
	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, number === currentPage);
	          pages.push(page);
	        }
	
	        // Add links to move between page sets
	        if (isMaxSized && ! rotate) {
	          if (startPage > 1) {
	            var previousPageSet = makePage(startPage - 1, '...', false);
	            pages.unshift(previousPageSet);
	          }
	
	          if (endPage < totalPages) {
	            var nextPageSet = makePage(endPage + 1, '...', false);
	            pages.push(nextPageSet);
	          }
	        }
	
	        return pages;
	      }
	
	      var originalRender = paginationCtrl.render;
	      paginationCtrl.render = function() {
	        originalRender();
	        if (scope.page > 0 && scope.page <= scope.totalPages) {
	          scope.pages = getPages(scope.page, scope.totalPages);
	        }
	      };
	    }
	  };
	}])
	
	.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {
	  return {
	    restrict: 'EA',
	    scope: {
	      totalItems: '=',
	      previousText: '@',
	      nextText: '@',
	      ngDisabled: '='
	    },
	    require: ['pager', '?ngModel'],
	    controller: 'PaginationController',
	    controllerAs: 'pagination',
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/pagination/pager.html';
	    },
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      if (!$paginationSuppressWarning) {
	        $log.warn('pager is now deprecated. Use uib-pager instead.');
	      }
	      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (!ngModelCtrl) {
	         return; // do nothing if no ng-model
	      }
	
	      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
	      paginationCtrl.init(ngModelCtrl, pagerConfig);
	    }
	  };
	}]);
	
	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])
	
	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider('$uibTooltip', function() {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    animation: true,
	    popupDelay: 0,
	    popupCloseDelay: 0,
	    useContentExp: false
	  };
	
	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'focus': 'blur',
	    'none': ''
	  };
	
	  // The options specified to the provider globally.
	  var globalOptions = {};
	
	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
		this.options = function(value) {
			angular.extend(globalOptions, value);
		};
	
	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers(triggers) {
	    angular.extend(triggerMap, triggers);
	  };
	
	  /**
	   * This is a helper function for translating camel-case to snake-case.
	   */
	  function snake_case(name) {
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function(letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }
	
	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
	    var openedTooltips = $$stackedMap.createNew();
	    $document.on('keypress', function(e) {
	      if (e.which === 27) {
	        var last = openedTooltips.top();
	        if (last) {
	          last.value.close();
	          openedTooltips.removeTop();
	          last = null;
	        }
	      }
	    });
	
	    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
	      options = angular.extend({}, defaultOptions, globalOptions, options);
	
	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers(trigger) {
	        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
	        var hide = show.map(function(trigger) {
	          return triggerMap[trigger] || trigger;
	        });
	        return {
	          show: show,
	          hide: hide
	        };
	      }
	
	      var directiveName = snake_case(ttType);
	
	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template =
	        '<div '+ directiveName + '-popup '+
	          'title="' + startSym + 'title' + endSym + '" '+
	          (options.useContentExp ?
	            'content-exp="contentExp()" ' :
	            'content="' + startSym + 'content' + endSym + '" ') +
	          'placement="' + startSym + 'placement' + endSym + '" '+
	          'popup-class="' + startSym + 'popupClass' + endSym + '" '+
	          'animation="animation" ' +
	          'is-open="isOpen"' +
	          'origin-scope="origScope" ' +
	          'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
	          '>' +
	        '</div>';
	
	      return {
	        compile: function(tElem, tAttrs) {
	          var tooltipLinker = $compile(template);
	
	          return function link(scope, element, attrs, tooltipCtrl) {
	            var tooltip;
	            var tooltipLinkedScope;
	            var transitionTimeout;
	            var showTimeout;
	            var hideTimeout;
	            var positionTimeout;
	            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
	            var triggers = getTriggers(undefined);
	            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
	            var ttScope = scope.$new(true);
	            var repositionScheduled = false;
	            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
	            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
	            var observers = [];
	
	            var positionTooltip = function() {
	              // check if tooltip exists and is not empty
	              if (!tooltip || !tooltip.html()) { return; }
	
	              if (!positionTimeout) {
	                positionTimeout = $timeout(function() {
	                  // Reset the positioning.
	                  tooltip.css({ top: 0, left: 0 });
	
	                  // Now set the calculated positioning.
	                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
	                  ttCss.top += 'px';
	                  ttCss.left += 'px';
	                  ttCss.visibility = 'visible';
	                  tooltip.css(ttCss);
	
	                  positionTimeout = null;
	                }, 0, false);
	              }
	            };
	
	            // Set up the correct scope to allow transclusion later
	            ttScope.origScope = scope;
	
	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            ttScope.isOpen = false;
	            openedTooltips.add(ttScope, {
	              close: hide
	            });
	
	            function toggleTooltipBind() {
	              if (!ttScope.isOpen) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }
	
	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
	                return;
	              }
	
	              cancelHide();
	              prepareTooltip();
	
	              if (ttScope.popupDelay) {
	                // Do nothing if the tooltip was already scheduled to pop-up.
	                // This happens if show is triggered multiple times before any hide is triggered.
	                if (!showTimeout) {
	                  showTimeout = $timeout(show, ttScope.popupDelay, false);
	                }
	              } else {
	                show();
	              }
	            }
	
	            function hideTooltipBind() {
	              cancelShow();
	
	              if (ttScope.popupCloseDelay) {
	                if (!hideTimeout) {
	                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
	                }
	              } else {
	                hide();
	              }
	            }
	
	            // Show the tooltip popup element.
	            function show() {
	              cancelShow();
	              cancelHide();
	
	              // Don't show empty tooltips.
	              if (!ttScope.content) {
	                return angular.noop;
	              }
	
	              createTooltip();
	
	              // And show the tooltip.
	              ttScope.$evalAsync(function() {
	                ttScope.isOpen = true;
	                assignIsOpen(true);
	                positionTooltip();
	              });
	            }
	
	            function cancelShow() {
	              if (showTimeout) {
	                $timeout.cancel(showTimeout);
	                showTimeout = null;
	              }
	
	              if (positionTimeout) {
	                $timeout.cancel(positionTimeout);
	                positionTimeout = null;
	              }
	            }
	
	            // Hide the tooltip popup element.
	            function hide() {
	              cancelShow();
	              cancelHide();
	
	              if (!ttScope) {
	                return;
	              }
	
	              // First things first: we don't show it anymore.
	              ttScope.$evalAsync(function() {
	                ttScope.isOpen = false;
	                assignIsOpen(false);
	                // And now we remove it from the DOM. However, if we have animation, we
	                // need to wait for it to expire beforehand.
	                // FIXME: this is a placeholder for a port of the transitions library.
	                // The fade transition in TWBS is 150ms.
	                if (ttScope.animation) {
	                  if (!transitionTimeout) {
	                    transitionTimeout = $timeout(removeTooltip, 150, false);
	                  }
	                } else {
	                  removeTooltip();
	                }
	              });
	            }
	
	            function cancelHide() {
	              if (hideTimeout) {
	                $timeout.cancel(hideTimeout);
	                hideTimeout = null;
	              }
	              if (transitionTimeout) {
	                $timeout.cancel(transitionTimeout);
	                transitionTimeout = null;
	              }
	            }
	
	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                return;
	              }
	
	              tooltipLinkedScope = ttScope.$new();
	              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
	                if (appendToBody) {
	                  $document.find('body').append(tooltip);
	                } else {
	                  element.after(tooltip);
	                }
	              });
	
	              prepObservers();
	            }
	
	            function removeTooltip() {
	              unregisterObservers();
	
	              transitionTimeout = null;
	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	              if (tooltipLinkedScope) {
	                tooltipLinkedScope.$destroy();
	                tooltipLinkedScope = null;
	              }
	            }
	
	            /**
	             * Set the inital scope values. Once
	             * the tooltip is created, the observers
	             * will be added to keep things in synch.
	             */
	            function prepareTooltip() {
	              ttScope.title = attrs[prefix + 'Title'];
	              if (contentParse) {
	                ttScope.content = contentParse(scope);
	              } else {
	                ttScope.content = attrs[ttType];
	              }
	
	              ttScope.popupClass = attrs[prefix + 'Class'];
	              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
	
	              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
	              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
	              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
	              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
	            }
	
	            function assignIsOpen(isOpen) {
	              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
	                isOpenParse.assign(scope, isOpen);
	              }
	            }
	
	            ttScope.contentExp = function() {
	              return ttScope.content;
	            };
	
	            /**
	             * Observe the relevant attributes.
	             */
	            attrs.$observe('disabled', function(val) {
	              if (val) {
	                cancelShow();
	              }
	
	              if (val && ttScope.isOpen) {
	                hide();
	              }
	            });
	
	            if (isOpenParse) {
	              scope.$watch(isOpenParse, function(val) {
	                /*jshint -W018 */
	                if (ttScope && !val === ttScope.isOpen) {
	                  toggleTooltipBind();
	                }
	                /*jshint +W018 */
	              });
	            }
	
	            function prepObservers() {
	              observers.length = 0;
	
	              if (contentParse) {
	                observers.push(
	                  scope.$watch(contentParse, function(val) {
	                    ttScope.content = val;
	                    if (!val && ttScope.isOpen) {
	                      hide();
	                    }
	                  })
	                );
	
	                observers.push(
	                  tooltipLinkedScope.$watch(function() {
	                    if (!repositionScheduled) {
	                      repositionScheduled = true;
	                      tooltipLinkedScope.$$postDigest(function() {
	                        repositionScheduled = false;
	                        if (ttScope && ttScope.isOpen) {
	                          positionTooltip();
	                        }
	                      });
	                    }
	                  })
	                );
	              } else {
	                observers.push(
	                  attrs.$observe(ttType, function(val) {
	                    ttScope.content = val;
	                    if (!val && ttScope.isOpen) {
	                      hide();
	                    } else {
	                      positionTooltip();
	                    }
	                  })
	                );
	              }
	
	              observers.push(
	                attrs.$observe(prefix + 'Title', function(val) {
	                  ttScope.title = val;
	                  if (ttScope.isOpen) {
	                    positionTooltip();
	                  }
	                })
	              );
	
	              observers.push(
	                attrs.$observe(prefix + 'Placement', function(val) {
	                  ttScope.placement = val ? val : options.placement;
	                  if (ttScope.isOpen) {
	                    positionTooltip();
	                  }
	                })
	              );
	            }
	
	            function unregisterObservers() {
	              if (observers.length) {
	                angular.forEach(observers, function(observer) {
	                  observer();
	                });
	                observers.length = 0;
	              }
	            }
	
	            var unregisterTriggers = function() {
	              triggers.show.forEach(function(trigger) {
	                element.unbind(trigger, showTooltipBind);
	              });
	              triggers.hide.forEach(function(trigger) {
	                trigger.split(' ').forEach(function(hideTrigger) {
	                  element[0].removeEventListener(hideTrigger, hideTooltipBind);
	                });
	              });
	            };
	
	            function prepTriggers() {
	              var val = attrs[prefix + 'Trigger'];
	              unregisterTriggers();
	
	              triggers = getTriggers(val);
	
	              if (triggers.show !== 'none') {
	                triggers.show.forEach(function(trigger, idx) {
	                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
	                  if (trigger === triggers.hide[idx]) {
	                    element[0].addEventListener(trigger, toggleTooltipBind);
	                  } else if (trigger) {
	                    element[0].addEventListener(trigger, showTooltipBind);
	                    triggers.hide[idx].split(' ').forEach(function(trigger) {
	                      element[0].addEventListener(trigger, hideTooltipBind);
	                    });
	                  }
	
	                  element.on('keypress', function(e) {
	                    if (e.which === 27) {
	                      hideTooltipBind();
	                    }
	                  });
	                });
	              }
	            }
	
	            prepTriggers();
	
	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
	
	            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
	            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
	
	            // if a tooltip is attached to <body> we need to remove it on
	            // location change as its parent scope will probably not be destroyed
	            // by the change.
	            if (appendToBody) {
	              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
	                if (ttScope.isOpen) {
	                  hide();
	                }
	              });
	            }
	
	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              cancelShow();
	              cancelHide();
	              unregisterTriggers();
	              removeTooltip();
	              openedTooltips.remove(ttScope);
	              ttScope = null;
	            });
	          };
	        }
	      };
	    };
	  }];
	})
	
	// This is mostly ngInclude code but with a custom scope
	.directive('uibTooltipTemplateTransclude', [
	         '$animate', '$sce', '$compile', '$templateRequest',
	function ($animate ,  $sce ,  $compile ,  $templateRequest) {
	  return {
	    link: function(scope, elem, attrs) {
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
	
	      var changeCounter = 0,
	        currentScope,
	        previousElement,
	        currentElement;
	
	      var cleanupLastIncludeContent = function() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }
	
	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }
	
	        if (currentElement) {
	          $animate.leave(currentElement).then(function() {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };
	
	      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
	        var thisChangeId = ++changeCounter;
	
	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function(response) {
	            if (thisChangeId !== changeCounter) { return; }
	            var newScope = origScope.$new();
	            var template = response;
	
	            var clone = $compile(template)(newScope, function(clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });
	
	            currentScope = newScope;
	            currentElement = clone;
	
	            currentScope.$emit('$includeContentLoaded', src);
	          }, function() {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });
	
	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])
	
	/**
	 * Note that it's intentional that these classes are *not* applied through $animate.
	 * They must not be animated as they're expected to be present on the tooltip on
	 * initialization.
	 */
	.directive('uibTooltipClasses', function() {
	  return {
	    restrict: 'A',
	    link: function(scope, element, attrs) {
	      if (scope.placement) {
	        element.addClass(scope.placement);
	      }
	
	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }
	
	      if (scope.animation()) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	})
	
	.directive('uibTooltipPopup', function() {
	  return {
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html',
	    link: function(scope, element) {
	      element.addClass('tooltip');
	    }
	  };
	})
	
	.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
	}])
	
	.directive('uibTooltipTemplatePopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/tooltip/tooltip-template-popup.html',
	    link: function(scope, element) {
	      element.addClass('tooltip');
	    }
	  };
	})
	
	.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	.directive('uibTooltipHtmlPopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-popup.html',
	    link: function(scope, element) {
	      element.addClass('tooltip');
	    }
	  };
	})
	
	.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}]);
	
	/* Deprecated tooltip below */
	
	angular.module('ui.bootstrap.tooltip')
	
	.value('$tooltipSuppressWarning', false)
	
	.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {
	  angular.extend(this, $uibTooltipProvider);
	
	  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {
	    if (!$tooltipSuppressWarning) {
	      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');
	    }
	
	    return $injector.invoke($uibTooltipProvider.$get);
	  }];
	}])
	
	// This is mostly ngInclude code but with a custom scope
	.directive('tooltipTemplateTransclude', [
	         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',
	function ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {
	  return {
	    link: function(scope, elem, attrs) {
	      if (!$tooltipSuppressWarning) {
	        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');
	      }
	
	      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
	
	      var changeCounter = 0,
	        currentScope,
	        previousElement,
	        currentElement;
	
	      var cleanupLastIncludeContent = function() {
	        if (previousElement) {
	          previousElement.remove();
	          previousElement = null;
	        }
	        if (currentScope) {
	          currentScope.$destroy();
	          currentScope = null;
	        }
	        if (currentElement) {
	          $animate.leave(currentElement).then(function() {
	            previousElement = null;
	          });
	          previousElement = currentElement;
	          currentElement = null;
	        }
	      };
	
	      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
	        var thisChangeId = ++changeCounter;
	
	        if (src) {
	          //set the 2nd param to true to ignore the template request error so that the inner
	          //contents and scope can be cleaned up.
	          $templateRequest(src, true).then(function(response) {
	            if (thisChangeId !== changeCounter) { return; }
	            var newScope = origScope.$new();
	            var template = response;
	
	            var clone = $compile(template)(newScope, function(clone) {
	              cleanupLastIncludeContent();
	              $animate.enter(clone, elem);
	            });
	
	            currentScope = newScope;
	            currentElement = clone;
	
	            currentScope.$emit('$includeContentLoaded', src);
	          }, function() {
	            if (thisChangeId === changeCounter) {
	              cleanupLastIncludeContent();
	              scope.$emit('$includeContentError', src);
	            }
	          });
	          scope.$emit('$includeContentRequested', src);
	        } else {
	          cleanupLastIncludeContent();
	        }
	      });
	
	      scope.$on('$destroy', cleanupLastIncludeContent);
	    }
	  };
	}])
	
	.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
	  return {
	    restrict: 'A',
	    link: function(scope, element, attrs) {
	      if (!$tooltipSuppressWarning) {
	        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');
	      }
	
	      if (scope.placement) {
	        element.addClass(scope.placement);
	      }
	      if (scope.popupClass) {
	        element.addClass(scope.popupClass);
	      }
	      if (scope.animation()) {
	        element.addClass(attrs.tooltipAnimationClass);
	      }
	    }
	  };
	}])
	
	.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
	  return {
	    replace: true,
	    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html',
	    link: function(scope, element) {
	      if (!$tooltipSuppressWarning) {
	        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');
	      }
	
	      element.addClass('tooltip');
	    }
	  };
	}])
	
	.directive('tooltip', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltip', 'tooltip', 'mouseenter');
	}])
	
	.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/tooltip/tooltip-template-popup.html',
	    link: function(scope, element) {
	      if (!$tooltipSuppressWarning) {
	        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');
	      }
	
	      element.addClass('tooltip');
	    }
	  };
	}])
	
	.directive('tooltipTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}])
	
	.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
	  return {
	    replace: true,
	    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-popup.html',
	    link: function(scope, element) {
	      if (!$tooltipSuppressWarning) {
	        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');
	      }
	
	      element.addClass('tooltip');
	    }
	  };
	}])
	
	.directive('tooltipHtml', ['$tooltip', function($tooltip) {
	  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
	    useContentExp: true
	  });
	}]);
	
	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, and selector delegatation.
	 */
	angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
	
	.directive('uibPopoverTemplatePopup', function() {
	  return {
	    replace: true,
	    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/popover/popover-template.html',
	    link: function(scope, element) {
	      element.addClass('popover');
	    }
	  };
	})
	
	.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('uibPopoverHtmlPopup', function() {
	  return {
	    replace: true,
	    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover-html.html',
	    link: function(scope, element) {
	      element.addClass('popover');
	    }
	  };
	})
	
	.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('uibPopoverPopup', function() {
	  return {
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html',
	    link: function(scope, element) {
	      element.addClass('popover');
	    }
	  };
	})
	
	.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
	  return $uibTooltip('uibPopover', 'popover', 'click');
	}]);
	
	/* Deprecated popover below */
	
	angular.module('ui.bootstrap.popover')
	
	.value('$popoverSuppressWarning', false)
	
	.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
	  return {
	    replace: true,
	    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
	      originScope: '&' },
	    templateUrl: 'template/popover/popover-template.html',
	    link: function(scope, element) {
	      if (!$popoverSuppressWarning) {
	        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');
	      }
	
	      element.addClass('popover');
	    }
	  };
	}])
	
	.directive('popoverTemplate', ['$tooltip', function($tooltip) {
	  return $tooltip('popoverTemplate', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
	  return {
	    replace: true,
	    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover-html.html',
	    link: function(scope, element) {
	      if (!$popoverSuppressWarning) {
	        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');
	      }
	
	      element.addClass('popover');
	    }
	  };
	}])
	
	.directive('popoverHtml', ['$tooltip', function($tooltip) {
	  return $tooltip('popoverHtml', 'popover', 'click', {
	    useContentExp: true
	  });
	}])
	
	.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
	  return {
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html',
	    link: function(scope, element) {
	      if (!$popoverSuppressWarning) {
	        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');
	      }
	
	      element.addClass('popover');
	    }
	  };
	}])
	
	.directive('popover', ['$tooltip', function($tooltip) {
	
	  return $tooltip('popover', 'popover', 'click');
	}]);
	
	angular.module('ui.bootstrap.progressbar', [])
	
	.constant('uibProgressConfig', {
	  animate: true,
	  max: 100
	})
	
	.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
	  var self = this,
	      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
	
	  this.bars = [];
	  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
	
	  this.addBar = function(bar, element, attrs) {
	    if (!animate) {
	      element.css({'transition': 'none'});
	    }
	
	    this.bars.push(bar);
	
	    bar.max = $scope.max;
	    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
	
	    bar.$watch('value', function(value) {
	      bar.recalculatePercentage();
	    });
	
	    bar.recalculatePercentage = function() {
	      var totalPercentage = self.bars.reduce(function(total, bar) {
	        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	        return total + bar.percent;
	      }, 0);
	
	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };
	
	    bar.$on('$destroy', function() {
	      element = null;
	      self.removeBar(bar);
	    });
	  };
	
	  this.removeBar = function(bar) {
	    this.bars.splice(this.bars.indexOf(bar), 1);
	    this.bars.forEach(function (bar) {
	      bar.recalculatePercentage();
	    });
	  };
	
	  $scope.$watch('max', function(max) {
	    self.bars.forEach(function(bar) {
	      bar.max = $scope.max;
	      bar.recalculatePercentage();
	    });
	  });
	}])
	
	.directive('uibProgress', function() {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    require: 'uibProgress',
	    scope: {
	      max: '=?'
	    },
	    templateUrl: 'template/progressbar/progress.html'
	  };
	})
	
	.directive('uibBar', function() {
	  return {
	    replace: true,
	    transclude: true,
	    require: '^uibProgress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, element, attrs);
	    }
	  };
	})
	
	.directive('uibProgressbar', function() {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'UibProgressController',
	    scope: {
	      value: '=',
	      max: '=?',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/progressbar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
	    }
	  };
	});
	
	/* Deprecated progressbar below */
	
	angular.module('ui.bootstrap.progressbar')
	
	.value('$progressSuppressWarning', false)
	
	.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {
	  if (!$progressSuppressWarning) {
	    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');
	  }
	
	  var self = this,
	    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
	
	  this.bars = [];
	  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
	
	  this.addBar = function(bar, element, attrs) {
	    if (!animate) {
	      element.css({'transition': 'none'});
	    }
	
	    this.bars.push(bar);
	
	    bar.max = $scope.max;
	    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
	
	    bar.$watch('value', function(value) {
	      bar.recalculatePercentage();
	    });
	
	    bar.recalculatePercentage = function() {
	      bar.percent = +(100 * bar.value / bar.max).toFixed(2);
	
	      var totalPercentage = self.bars.reduce(function(total, bar) {
	        return total + bar.percent;
	      }, 0);
	
	      if (totalPercentage > 100) {
	        bar.percent -= totalPercentage - 100;
	      }
	    };
	
	    bar.$on('$destroy', function() {
	      element = null;
	      self.removeBar(bar);
	    });
	  };
	
	  this.removeBar = function(bar) {
	    this.bars.splice(this.bars.indexOf(bar), 1);
	  };
	
	  $scope.$watch('max', function(max) {
	    self.bars.forEach(function(bar) {
	      bar.max = $scope.max;
	      bar.recalculatePercentage();
	    });
	  });
	}])
	
	.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    require: 'progress',
	    scope: {
	      max: '=?',
	      title: '@?'
	    },
	    templateUrl: 'template/progressbar/progress.html',
	    link: function() {
	      if (!$progressSuppressWarning) {
	        $log.warn('progress is now deprecated. Use uib-progress instead.');
	      }
	    }
	  };
	}])
	
	.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    replace: true,
	    transclude: true,
	    require: '^progress',
	    scope: {
	      value: '=',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/bar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      if (!$progressSuppressWarning) {
	        $log.warn('bar is now deprecated. Use uib-bar instead.');
	      }
	      progressCtrl.addBar(scope, element);
	    }
	  };
	}])
	
	.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
	  return {
	    replace: true,
	    transclude: true,
	    controller: 'ProgressController',
	    scope: {
	      value: '=',
	      max: '=?',
	      type: '@'
	    },
	    templateUrl: 'template/progressbar/progressbar.html',
	    link: function(scope, element, attrs, progressCtrl) {
	      if (!$progressSuppressWarning) {
	        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');
	      }
	      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.rating', [])
	
	.constant('uibRatingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null,
	  titles : ['one', 'two', 'three', 'four', 'five']
	})
	
	.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
	  var ngModelCtrl  = { $setViewValue: angular.noop };
	
	  this.init = function(ngModelCtrl_) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.push(function(value) {
	      if (angular.isNumber(value) && value << 0 !== value) {
	        value = Math.round(value);
	      }
	      return value;
	    });
	
	    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
	    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;
	    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
	      tmpTitles : ratingConfig.titles;
	
	    var ratingStates = angular.isDefined($attrs.ratingStates) ?
	      $scope.$parent.$eval($attrs.ratingStates) :
	      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
	    $scope.range = this.buildTemplateObjects(ratingStates);
	  };
	
	  this.buildTemplateObjects = function(states) {
	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
	    }
	    return states;
	  };
	
	  this.getTitle = function(index) {
	    if (index >= this.titles.length) {
	      return index + 1;
	    } else {
	      return this.titles[index];
	    }
	  };
	
	  $scope.rate = function(value) {
	    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
	      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
	      ngModelCtrl.$render();
	    }
	  };
	
	  $scope.enter = function(value) {
	    if (!$scope.readonly) {
	      $scope.value = value;
	    }
	    $scope.onHover({value: value});
	  };
	
	  $scope.reset = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	    $scope.onLeave();
	  };
	
	  $scope.onKeydown = function(evt) {
	    if (/(37|38|39|40)/.test(evt.which)) {
	      evt.preventDefault();
	      evt.stopPropagation();
	      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
	    }
	  };
	
	  this.render = function() {
	    $scope.value = ngModelCtrl.$viewValue;
	  };
	}])
	
	.directive('uibRating', function() {
	  return {
	    require: ['uibRating', 'ngModel'],
	    scope: {
	      readonly: '=?',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'UibRatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      ratingCtrl.init(ngModelCtrl);
	    }
	  };
	});
	
	/* Deprecated rating below */
	
	angular.module('ui.bootstrap.rating')
	
	.value('$ratingSuppressWarning', false)
	
	.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {
	  if (!$ratingSuppressWarning) {
	    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');
	  }
	
	  angular.extend(this, $controller('UibRatingController', {
	    $scope: $scope,
	    $attrs: $attrs
	  }));
	}])
	
	.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {
	  return {
	    require: ['rating', 'ngModel'],
	    scope: {
	      readonly: '=?',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'RatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true,
	    link: function(scope, element, attrs, ctrls) {
	      if (!$ratingSuppressWarning) {
	        $log.warn('rating is now deprecated. Use uib-rating instead.');
	      }
	      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	      ratingCtrl.init(ngModelCtrl);
	    }
	  };
	}]);
	
	
	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.tabs
	 *
	 * @description
	 * AngularJS version of the tabs directive.
	 */
	
	angular.module('ui.bootstrap.tabs', [])
	
	.controller('UibTabsetController', ['$scope', function ($scope) {
	  var ctrl = this,
	      tabs = ctrl.tabs = $scope.tabs = [];
	
	  ctrl.select = function(selectedTab) {
	    angular.forEach(tabs, function(tab) {
	      if (tab.active && tab !== selectedTab) {
	        tab.active = false;
	        tab.onDeselect();
	        selectedTab.selectCalled = false;
	      }
	    });
	    selectedTab.active = true;
	    // only call select if it has not already been called
	    if (!selectedTab.selectCalled) {
	      selectedTab.onSelect();
	      selectedTab.selectCalled = true;
	    }
	  };
	
	  ctrl.addTab = function addTab(tab) {
	    tabs.push(tab);
	    // we can't run the select function on the first tab
	    // since that would select it twice
	    if (tabs.length === 1 && tab.active !== false) {
	      tab.active = true;
	    } else if (tab.active) {
	      ctrl.select(tab);
	    } else {
	      tab.active = false;
	    }
	  };
	
	  ctrl.removeTab = function removeTab(tab) {
	    var index = tabs.indexOf(tab);
	    //Select a new tab if the tab to be removed is selected and not destroyed
	    if (tab.active && tabs.length > 1 && !destroyed) {
	      //If this is the last tab, select the previous tab. else, the next tab.
	      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
	      ctrl.select(tabs[newActiveIndex]);
	    }
	    tabs.splice(index, 1);
	  };
	
	  var destroyed;
	  $scope.$on('$destroy', function() {
	    destroyed = true;
	  });
	}])
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabset
	 * @restrict EA
	 *
	 * @description
	 * Tabset is the outer container for the tabs directive
	 *
	 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
	 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <uib-tabset>
	      <uib-tab heading="Tab 1"><b>First</b> Content!</uib-tab>
	      <uib-tab heading="Tab 2"><i>Second</i> Content!</uib-tab>
	    </uib-tabset>
	    <hr />
	    <uib-tabset vertical="true">
	      <uib-tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</uib-tab>
	      <uib-tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</uib-tab>
	    </uib-tabset>
	    <uib-tabset justified="true">
	      <uib-tab heading="Justified Tab 1"><b>First</b> Justified Content!</uib-tab>
	      <uib-tab heading="Justified Tab 2"><i>Second</i> Justified Content!</uib-tab>
	    </uib-tabset>
	  </file>
	</example>
	 */
	.directive('uibTabset', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    scope: {
	      type: '@'
	    },
	    controller: 'UibTabsetController',
	    templateUrl: 'template/tabs/tabset.html',
	    link: function(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	    }
	  };
	})
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tab
	 * @restrict EA
	 *
	 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
	 * @param {string=} select An expression to evaluate when the tab is selected.
	 * @param {boolean=} active A binding, telling whether or not this tab is selected.
	 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
	 *
	 * @description
	 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <div ng-controller="TabsDemoCtrl">
	      <button class="btn btn-small" ng-click="items[0].active = true">
	        Select item 1, using active binding
	      </button>
	      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
	        Enable/disable item 2, using disabled binding
	      </button>
	      <br />
	      <uib-tabset>
	        <uib-tab heading="Tab 1">First Tab</uib-tab>
	        <uib-tab select="alertMe()">
	          <uib-tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
	          Second Tab, with alert callback and html heading!
	        </uib-tab>
	        <uib-tab ng-repeat="item in items"
	          heading="{{item.title}}"
	          disabled="item.disabled"
	          active="item.active">
	          {{item.content}}
	        </uib-tab>
	      </uib-tabset>
	    </div>
	  </file>
	  <file name="script.js">
	    function TabsDemoCtrl($scope) {
	      $scope.items = [
	        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
	        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
	      ];
	
	      $scope.alertMe = function() {
	        setTimeout(function() {
	          alert("You've selected the alert tab!");
	        });
	      };
	    };
	  </file>
	</example>
	 */
	
	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabHeading
	 * @restrict EA
	 *
	 * @description
	 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <uib-tabset>
	      <uib-tab>
	        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>
	        And some content, too!
	      </uib-tab>
	      <uib-tab>
	        <uib-tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
	        That's right.
	      </uib-tab>
	    </uib-tabset>
	  </file>
	</example>
	 */
	.directive('uibTab', ['$parse', function($parse) {
	  return {
	    require: '^uibTabset',
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/tabs/tab.html',
	    transclude: true,
	    scope: {
	      active: '=?',
	      heading: '@',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	                          //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	      scope.$watch('active', function(active) {
	        if (active) {
	          tabsetCtrl.select(scope);
	        }
	      });
	
	      scope.disabled = false;
	      if (attrs.disable) {
	        scope.$parent.$watch($parse(attrs.disable), function(value) {
	          scope.disabled = !! value;
	        });
	      }
	
	      scope.select = function() {
	        if (!scope.disabled) {
	          scope.active = true;
	        }
	      };
	
	      tabsetCtrl.addTab(scope);
	      scope.$on('$destroy', function() {
	        tabsetCtrl.removeTab(scope);
	      });
	
	      //We need to transclude later, once the content container is ready.
	      //when this link happens, we're inside a tab heading.
	      scope.$transcludeFn = transclude;
	    }
	  };
	}])
	
	.directive('uibTabHeadingTransclude', function() {
	  return {
	    restrict: 'A',
	    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal
	    link: function(scope, elm) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	})
	
	.directive('uibTabContentTransclude', function() {
	  return {
	    restrict: 'A',
	    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal
	    link: function(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.uibTabContentTransclude);
	
	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function(contents) {
	        angular.forEach(contents, function(node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };
	
	  function isTabHeading(node) {
	    return node.tagName && (
	      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal
	      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal
	      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal
	      node.hasAttribute('uib-tab-heading') ||
	      node.hasAttribute('data-uib-tab-heading') ||
	      node.hasAttribute('x-uib-tab-heading') ||
	      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal
	      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal
	      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal
	      node.tagName.toLowerCase() === 'uib-tab-heading' ||
	      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
	      node.tagName.toLowerCase() === 'x-uib-tab-heading'
	    );
	  }
	});
	
	/* deprecated tabs below */
	
	angular.module('ui.bootstrap.tabs')
	
	  .value('$tabsSuppressWarning', false)
	
	  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {
	    if (!$tabsSuppressWarning) {
	      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');
	    }
	
	    angular.extend(this, $controller('UibTabsetController', {
	      $scope: $scope
	    }));
	  }])
	
	  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
	    return {
	      restrict: 'EA',
	      transclude: true,
	      replace: true,
	      scope: {
	        type: '@'
	      },
	      controller: 'TabsetController',
	      templateUrl: 'template/tabs/tabset.html',
	      link: function(scope, element, attrs) {
	
	        if (!$tabsSuppressWarning) {
	          $log.warn('tabset is now deprecated. Use uib-tabset instead.');
	        }
	        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	      }
	    };
	  }])
	
	  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {
	    return {
	      require: '^tabset',
	      restrict: 'EA',
	      replace: true,
	      templateUrl: 'template/tabs/tab.html',
	      transclude: true,
	      scope: {
	        active: '=?',
	        heading: '@',
	        onSelect: '&select', //This callback is called in contentHeadingTransclude
	        //once it inserts the tab's content into the dom
	        onDeselect: '&deselect'
	      },
	      controller: function() {
	        //Empty controller so other directives can require being 'under' a tab
	      },
	      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
	        if (!$tabsSuppressWarning) {
	          $log.warn('tab is now deprecated. Use uib-tab instead.');
	        }
	
	        scope.$watch('active', function(active) {
	          if (active) {
	            tabsetCtrl.select(scope);
	          }
	        });
	
	        scope.disabled = false;
	        if (attrs.disable) {
	          scope.$parent.$watch($parse(attrs.disable), function(value) {
	            scope.disabled = !!value;
	          });
	        }
	
	        scope.select = function() {
	          if (!scope.disabled) {
	            scope.active = true;
	          }
	        };
	
	        tabsetCtrl.addTab(scope);
	        scope.$on('$destroy', function() {
	          tabsetCtrl.removeTab(scope);
	        });
	
	        //We need to transclude later, once the content container is ready.
	        //when this link happens, we're inside a tab heading.
	        scope.$transcludeFn = transclude;
	      }
	    };
	  }])
	
	  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
	    return {
	      restrict: 'A',
	      require: '^tab',
	      link: function(scope, elm) {
	        if (!$tabsSuppressWarning) {
	          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');
	        }
	
	        scope.$watch('headingElement', function updateHeadingElement(heading) {
	          if (heading) {
	            elm.html('');
	            elm.append(heading);
	          }
	        });
	      }
	    };
	  }])
	
	  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
	    return {
	      restrict: 'A',
	      require: '^tabset',
	      link: function(scope, elm, attrs) {
	        if (!$tabsSuppressWarning) {
	          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');
	        }
	
	        var tab = scope.$eval(attrs.tabContentTransclude);
	
	        //Now our tab is ready to be transcluded: both the tab heading area
	        //and the tab content area are loaded.  Transclude 'em both.
	        tab.$transcludeFn(tab.$parent, function(contents) {
	          angular.forEach(contents, function(node) {
	            if (isTabHeading(node)) {
	              //Let tabHeadingTransclude know.
	              tab.headingElement = node;
	            }
	            else {
	              elm.append(node);
	            }
	          });
	        });
	      }
	    };
	
	    function isTabHeading(node) {
	      return node.tagName && (
	          node.hasAttribute('tab-heading') ||
	          node.hasAttribute('data-tab-heading') ||
	          node.hasAttribute('x-tab-heading') ||
	          node.tagName.toLowerCase() === 'tab-heading' ||
	          node.tagName.toLowerCase() === 'data-tab-heading' ||
	          node.tagName.toLowerCase() === 'x-tab-heading'
	        );
	    }
	  }]);
	
	angular.module('ui.bootstrap.timepicker', [])
	
	.constant('uibTimepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  showMeridian: true,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true,
	  arrowkeys: true,
	  showSpinners: true
	})
	
	.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
	  var selected = new Date(),
	      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
	      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
	
	  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
	  $element.removeAttr('tabindex');
	
	  this.init = function(ngModelCtrl_, inputs) {
	    ngModelCtrl = ngModelCtrl_;
	    ngModelCtrl.$render = this.render;
	
	    ngModelCtrl.$formatters.unshift(function(modelValue) {
	      return modelValue ? new Date(modelValue) : null;
	    });
	
	    var hoursInputEl = inputs.eq(0),
	        minutesInputEl = inputs.eq(1);
	
	    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
	    if (mousewheel) {
	      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
	    }
	
	    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
	    if (arrowkeys) {
	      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
	    }
	
	    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
	    this.setupInputEvents(hoursInputEl, minutesInputEl);
	  };
	
	  var hourStep = timepickerConfig.hourStep;
	  if ($attrs.hourStep) {
	    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
	      hourStep = parseInt(value, 10);
	    });
	  }
	
	  var minuteStep = timepickerConfig.minuteStep;
	  if ($attrs.minuteStep) {
	    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
	      minuteStep = parseInt(value, 10);
	    });
	  }
	
	  var min;
	  $scope.$parent.$watch($parse($attrs.min), function(value) {
	    var dt = new Date(value);
	    min = isNaN(dt) ? undefined : dt;
	  });
	
	  var max;
	  $scope.$parent.$watch($parse($attrs.max), function(value) {
	    var dt = new Date(value);
	    max = isNaN(dt) ? undefined : dt;
	  });
	
	  $scope.noIncrementHours = function() {
	    var incrementedSelected = addMinutes(selected, hourStep * 60);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementHours = function() {
	    var decrementedSelected = addMinutes(selected, -hourStep * 60);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noIncrementMinutes = function() {
	    var incrementedSelected = addMinutes(selected, minuteStep);
	    return incrementedSelected > max ||
	      (incrementedSelected < selected && incrementedSelected < min);
	  };
	
	  $scope.noDecrementMinutes = function() {
	    var decrementedSelected = addMinutes(selected, -minuteStep);
	    return decrementedSelected < min ||
	      (decrementedSelected > selected && decrementedSelected > max);
	  };
	
	  $scope.noToggleMeridian = function() {
	    if (selected.getHours() < 13) {
	      return addMinutes(selected, 12 * 60) > max;
	    } else {
	      return addMinutes(selected, -12 * 60) < min;
	    }
	  };
	
	  // 12H / 24H mode
	  $scope.showMeridian = timepickerConfig.showMeridian;
	  if ($attrs.showMeridian) {
	    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
	      $scope.showMeridian = !!value;
	
	      if (ngModelCtrl.$error.time) {
	        // Evaluate from template
	        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
	        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	          selected.setHours(hours);
	          refresh();
	        }
	      } else {
	        updateTemplate();
	      }
	    });
	  }
	
	  // Get $scope.hours in 24H mode if valid
	  function getHoursFromTemplate() {
	    var hours = parseInt($scope.hours, 10);
	    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
	    if (!valid) {
	      return undefined;
	    }
	
	    if ($scope.showMeridian) {
	      if (hours === 12) {
	        hours = 0;
	      }
	      if ($scope.meridian === meridians[1]) {
	        hours = hours + 12;
	      }
	    }
	    return hours;
	  }
	
	  function getMinutesFromTemplate() {
	    var minutes = parseInt($scope.minutes, 10);
	    return (minutes >= 0 && minutes < 60) ? minutes : undefined;
	  }
	
	  function pad(value) {
	    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
	  }
	
	  // Respond on mousewheel spin
	  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
	    var isScrollingUp = function(e) {
	      if (e.originalEvent) {
	        e = e.originalEvent;
	      }
	      //pick correct delta variable depending on event
	      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
	      return (e.detail || delta > 0);
	    };
	
	    hoursInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
	      e.preventDefault();
	    });
	
	    minutesInputEl.bind('mousewheel wheel', function(e) {
	      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
	      e.preventDefault();
	    });
	
	  };
	
	  // Respond on up/down arrowkeys
	  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
	    hoursInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementHours();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementHours();
	        $scope.$apply();
	      }
	    });
	
	    minutesInputEl.bind('keydown', function(e) {
	      if (e.which === 38) { // up
	        e.preventDefault();
	        $scope.incrementMinutes();
	        $scope.$apply();
	      } else if (e.which === 40) { // down
	        e.preventDefault();
	        $scope.decrementMinutes();
	        $scope.$apply();
	      }
	    });
	  };
	
	  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
	    if ($scope.readonlyInput) {
	      $scope.updateHours = angular.noop;
	      $scope.updateMinutes = angular.noop;
	      return;
	    }
	
	    var invalidate = function(invalidHours, invalidMinutes) {
	      ngModelCtrl.$setViewValue(null);
	      ngModelCtrl.$setValidity('time', false);
	      if (angular.isDefined(invalidHours)) {
	        $scope.invalidHours = invalidHours;
	      }
	      if (angular.isDefined(invalidMinutes)) {
	        $scope.invalidMinutes = invalidMinutes;
	      }
	    };
	
	    $scope.updateHours = function() {
	      var hours = getHoursFromTemplate(),
	        minutes = getMinutesFromTemplate();
	
	      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
	        selected.setHours(hours);
	        if (selected < min || selected > max) {
	          invalidate(true);
	        } else {
	          refresh('h');
	        }
	      } else {
	        invalidate(true);
	      }
	    };
	
	    hoursInputEl.bind('blur', function(e) {
	      if (!$scope.invalidHours && $scope.hours < 10) {
	        $scope.$apply(function() {
	          $scope.hours = pad($scope.hours);
	        });
	      }
	    });
	
	    $scope.updateMinutes = function() {
	      var minutes = getMinutesFromTemplate(),
	        hours = getHoursFromTemplate();
	
	      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
	        selected.setMinutes(minutes);
	        if (selected < min || selected > max) {
	          invalidate(undefined, true);
	        } else {
	          refresh('m');
	        }
	      } else {
	        invalidate(undefined, true);
	      }
	    };
	
	    minutesInputEl.bind('blur', function(e) {
	      if (!$scope.invalidMinutes && $scope.minutes < 10) {
	        $scope.$apply(function() {
	          $scope.minutes = pad($scope.minutes);
	        });
	      }
	    });
	
	  };
	
	  this.render = function() {
	    var date = ngModelCtrl.$viewValue;
	
	    if (isNaN(date)) {
	      ngModelCtrl.$setValidity('time', false);
	      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	    } else {
	      if (date) {
	        selected = date;
	      }
	
	      if (selected < min || selected > max) {
	        ngModelCtrl.$setValidity('time', false);
	        $scope.invalidHours = true;
	        $scope.invalidMinutes = true;
	      } else {
	        makeValid();
	      }
	      updateTemplate();
	    }
	  };
	
	  // Call internally when we know that model is valid.
	  function refresh(keyboardChange) {
	    makeValid();
	    ngModelCtrl.$setViewValue(new Date(selected));
	    updateTemplate(keyboardChange);
	  }
	
	  function makeValid() {
	    ngModelCtrl.$setValidity('time', true);
	    $scope.invalidHours = false;
	    $scope.invalidMinutes = false;
	  }
	
	  function updateTemplate(keyboardChange) {
	    var hours = selected.getHours(), minutes = selected.getMinutes();
	
	    if ($scope.showMeridian) {
	      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
	    }
	
	    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
	    if (keyboardChange !== 'm') {
	      $scope.minutes = pad(minutes);
	    }
	    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	  }
	
	  function addMinutes(date, minutes) {
	    var dt = new Date(date.getTime() + minutes * 60000);
	    var newDate = new Date(date);
	    newDate.setHours(dt.getHours(), dt.getMinutes());
	    return newDate;
	  }
	
	  function addMinutesToSelected(minutes) {
	    selected = addMinutes(selected, minutes);
	    refresh();
	  }
	
	  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
	    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
	
	  $scope.incrementHours = function() {
	    if (!$scope.noIncrementHours()) {
	      addMinutesToSelected(hourStep * 60);
	    }
	  };
	
	  $scope.decrementHours = function() {
	    if (!$scope.noDecrementHours()) {
	      addMinutesToSelected(-hourStep * 60);
	    }
	  };
	
	  $scope.incrementMinutes = function() {
	    if (!$scope.noIncrementMinutes()) {
	      addMinutesToSelected(minuteStep);
	    }
	  };
	
	  $scope.decrementMinutes = function() {
	    if (!$scope.noDecrementMinutes()) {
	      addMinutesToSelected(-minuteStep);
	    }
	  };
	
	  $scope.toggleMeridian = function() {
	    if (!$scope.noToggleMeridian()) {
	      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
	    }
	  };
	}])
	
	.directive('uibTimepicker', function() {
	  return {
	    restrict: 'EA',
	    require: ['uibTimepicker', '?^ngModel'],
	    controller: 'UibTimepickerController',
	    controllerAs: 'timepicker',
	    replace: true,
	    scope: {},
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/timepicker/timepicker.html';
	    },
	    link: function(scope, element, attrs, ctrls) {
	      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	});
	
	/* Deprecated timepicker below */
	
	angular.module('ui.bootstrap.timepicker')
	
	.value('$timepickerSuppressWarning', false)
	
	.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {
	  if (!$timepickerSuppressWarning) {
	    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');
	  }
	
	  angular.extend(this, $controller('UibTimepickerController', {
	    $scope: $scope,
	    $element: $element,
	    $attrs: $attrs
	  }));
	}])
	
	.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {
	  return {
	    restrict: 'EA',
	    require: ['timepicker', '?^ngModel'],
	    controller: 'TimepickerController',
	    controllerAs: 'timepicker',
	    replace: true,
	    scope: {},
	    templateUrl: function(element, attrs) {
	      return attrs.templateUrl || 'template/timepicker/timepicker.html';
	    },
	    link: function(scope, element, attrs, ctrls) {
	      if (!$timepickerSuppressWarning) {
	        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');
	      }
	      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
	
	      if (ngModelCtrl) {
	        timepickerCtrl.init(ngModelCtrl, element.find('input'));
	      }
	    }
	  };
	}]);
	
	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])
	
	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	  .factory('uibTypeaheadParser', ['$parse', function($parse) {
	    //                      00000111000000000000022200000000000000003333333333333330000000000044000
	    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
	    return {
	      parse: function(input) {
	        var match = input.match(TYPEAHEAD_REGEXP);
	        if (!match) {
	          throw new Error(
	            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
	              ' but got "' + input + '".');
	        }
	
	        return {
	          itemName: match[3],
	          source: $parse(match[4]),
	          viewMapper: $parse(match[2] || match[1]),
	          modelMapper: $parse(match[1])
	        };
	      }
	    };
	  }])
	
	  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',
	    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
	    var HOT_KEYS = [9, 13, 27, 38, 40];
	    var eventDebounceTime = 200;
	    var modelCtrl, ngModelOptions;
	    //SUPPORTED ATTRIBUTES (OPTIONS)
	
	    //minimal no of characters that needs to be entered before typeahead kicks-in
	    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	    if (!minLength && minLength !== 0) {
	      minLength = 1;
	    }
	
	    //minimal wait time after last character typed before typeahead kicks-in
	    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
	
	    //should it restrict model values to the ones selected from the popup only?
	    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	
	    //binding to a variable that indicates if matches are being retrieved asynchronously
	    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
	
	    //a callback executed when a match is selected
	    var onSelectCallback = $parse(attrs.typeaheadOnSelect);
	
	    //should it select highlighted popup value when losing focus?
	    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
	
	    //binding to a variable that indicates if there were no results after the query is completed
	    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
	
	    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
	
	    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
	
	    var appendToElementId =  attrs.typeaheadAppendToElementId || false;
	
	    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
	
	    //If input matches an item of the list exactly, select it automatically
	    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
	
	    //INTERNAL VARIABLES
	
	    //model setter executed upon match selection
	    var parsedModel = $parse(attrs.ngModel);
	    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	    var $setModelValue = function(scope, newValue) {
	      if (angular.isFunction(parsedModel(originalScope)) &&
	        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
	        return invokeModelSetter(scope, {$$$p: newValue});
	      } else {
	        return parsedModel.assign(scope, newValue);
	      }
	    };
	
	    //expressions used by typeahead
	    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
	
	    var hasFocus;
	
	    //Used to avoid bug in iOS webview where iOS keyboard does not fire
	    //mousedown & mouseup events
	    //Issue #3699
	    var selected;
	
	    //create a child scope for the typeahead directive so we are not polluting original scope
	    //with typeahead-specific data (matches, query etc.)
	    var scope = originalScope.$new();
	    var offDestroy = originalScope.$on('$destroy', function() {
	      scope.$destroy();
	    });
	    scope.$on('$destroy', offDestroy);
	
	    // WAI-ARIA
	    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	    element.attr({
	      'aria-autocomplete': 'list',
	      'aria-expanded': false,
	      'aria-owns': popupId
	    });
	
	    //pop-up element used to display matches
	    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
	    popUpEl.attr({
	      id: popupId,
	      matches: 'matches',
	      active: 'activeIdx',
	      select: 'select(activeIdx)',
	      'move-in-progress': 'moveInProgress',
	      query: 'query',
	      position: 'position'
	    });
	    //custom item template
	    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	    }
	
	    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	    }
	
	    var resetMatches = function() {
	      scope.matches = [];
	      scope.activeIdx = -1;
	      element.attr('aria-expanded', false);
	    };
	
	    var getMatchId = function(index) {
	      return popupId + '-option-' + index;
	    };
	
	    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	    // This attribute is added or removed automatically when the `activeIdx` changes.
	    scope.$watch('activeIdx', function(index) {
	      if (index < 0) {
	        element.removeAttr('aria-activedescendant');
	      } else {
	        element.attr('aria-activedescendant', getMatchId(index));
	      }
	    });
	
	    var inputIsExactMatch = function(inputValue, index) {
	      if (scope.matches.length > index && inputValue) {
	        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	      }
	
	      return false;
	    };
	
	    var getMatchesAsync = function(inputValue) {
	      var locals = {$viewValue: inputValue};
	      isLoadingSetter(originalScope, true);
	      isNoResultsSetter(originalScope, false);
	      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
	        //it might happen that several async queries were in progress if a user were typing fast
	        //but we are interested only in responses that correspond to the current view value
	        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
	        if (onCurrentRequest && hasFocus) {
	          if (matches && matches.length > 0) {
	            scope.activeIdx = focusFirst ? 0 : -1;
	            isNoResultsSetter(originalScope, false);
	            scope.matches.length = 0;
	
	            //transform labels
	            for (var i = 0; i < matches.length; i++) {
	              locals[parserResult.itemName] = matches[i];
	              scope.matches.push({
	                id: getMatchId(i),
	                label: parserResult.viewMapper(scope, locals),
	                model: matches[i]
	              });
	            }
	
	            scope.query = inputValue;
	            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	            //due to other elements being rendered
	            recalculatePosition();
	
	            element.attr('aria-expanded', true);
	
	            //Select the single remaining option if user input matches
	            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	              scope.select(0);
	            }
	          } else {
	            resetMatches();
	            isNoResultsSetter(originalScope, true);
	          }
	        }
	        if (onCurrentRequest) {
	          isLoadingSetter(originalScope, false);
	        }
	      }, function() {
	        resetMatches();
	        isLoadingSetter(originalScope, false);
	        isNoResultsSetter(originalScope, true);
	      });
	    };
	
	    // bind events only if appendToBody params exist - performance feature
	    if (appendToBody) {
	      angular.element($window).bind('resize', fireRecalculating);
	      $document.find('body').bind('scroll', fireRecalculating);
	    }
	
	    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	    var timeoutEventPromise;
	
	    // Default progress type
	    scope.moveInProgress = false;
	
	    function fireRecalculating() {
	      if (!scope.moveInProgress) {
	        scope.moveInProgress = true;
	        scope.$digest();
	      }
	
	      // Cancel previous timeout
	      if (timeoutEventPromise) {
	        $timeout.cancel(timeoutEventPromise);
	      }
	
	      // Debounced executing recalculate after events fired
	      timeoutEventPromise = $timeout(function() {
	        // if popup is visible
	        if (scope.matches.length) {
	          recalculatePosition();
	        }
	
	        scope.moveInProgress = false;
	      }, eventDebounceTime);
	    }
	
	    // recalculate actual position and set new values to scope
	    // after digest loop is popup in right position
	    function recalculatePosition() {
	      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	      scope.position.top += element.prop('offsetHeight');
	    }
	
	    //we need to propagate user's query so we can higlight matches
	    scope.query = undefined;
	
	    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	    var timeoutPromise;
	
	    var scheduleSearchWithTimeout = function(inputValue) {
	      timeoutPromise = $timeout(function() {
	        getMatchesAsync(inputValue);
	      }, waitTime);
	    };
	
	    var cancelPreviousTimeout = function() {
	      if (timeoutPromise) {
	        $timeout.cancel(timeoutPromise);
	      }
	    };
	
	    resetMatches();
	
	    scope.select = function(activeIdx) {
	      //called from within the $digest() cycle
	      var locals = {};
	      var model, item;
	
	      selected = true;
	      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	      model = parserResult.modelMapper(originalScope, locals);
	      $setModelValue(originalScope, model);
	      modelCtrl.$setValidity('editable', true);
	      modelCtrl.$setValidity('parse', true);
	
	      onSelectCallback(originalScope, {
	        $item: item,
	        $model: model,
	        $label: parserResult.viewMapper(originalScope, locals)
	      });
	
	      resetMatches();
	
	      //return focus to the input element if a match was selected via a mouse click event
	      // use timeout to avoid $rootScope:inprog error
	      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	        $timeout(function() { element[0].focus(); }, 0, false);
	      }
	    };
	
	    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	    element.bind('keydown', function(evt) {
	      //typeahead is open and an "interesting" key was pressed
	      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	        return;
	      }
	
	      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
	      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
	        resetMatches();
	        scope.$digest();
	        return;
	      }
	
	      evt.preventDefault();
	
	      if (evt.which === 40) {
	        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	        scope.$digest();
	      } else if (evt.which === 38) {
	        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	        scope.$digest();
	      } else if (evt.which === 13 || evt.which === 9) {
	        scope.$apply(function () {
	          scope.select(scope.activeIdx);
	        });
	      } else if (evt.which === 27) {
	        evt.stopPropagation();
	
	        resetMatches();
	        scope.$digest();
	      }
	    });
	
	    element.bind('blur', function() {
	      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	        selected = true;
	        scope.$apply(function() {
	          scope.select(scope.activeIdx);
	        });
	      }
	      hasFocus = false;
	      selected = false;
	    });
	
	    // Keep reference to click handler to unbind it.
	    var dismissClickHandler = function(evt) {
	      // Issue #3973
	      // Firefox treats right click as a click on document
	      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	        resetMatches();
	        if (!$rootScope.$$phase) {
	          scope.$digest();
	        }
	      }
	    };
	
	    $document.bind('click', dismissClickHandler);
	
	    originalScope.$on('$destroy', function() {
	      $document.unbind('click', dismissClickHandler);
	      if (appendToBody || appendToElementId) {
	        $popup.remove();
	      }
	
	      if (appendToBody) {
	        angular.element($window).unbind('resize', fireRecalculating);
	        $document.find('body').unbind('scroll', fireRecalculating);
	      }
	      // Prevent jQuery cache memory leak
	      popUpEl.remove();
	    });
	
	    var $popup = $compile(popUpEl)(scope);
	
	    if (appendToBody) {
	      $document.find('body').append($popup);
	    } else if (appendToElementId !== false) {
	      angular.element($document[0].getElementById(appendToElementId)).append($popup);
	    } else {
	      element.after($popup);
	    }
	
	    this.init = function(_modelCtrl, _ngModelOptions) {
	      modelCtrl = _modelCtrl;
	      ngModelOptions = _ngModelOptions;
	
	      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	      modelCtrl.$parsers.unshift(function(inputValue) {
	        hasFocus = true;
	
	        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	          if (waitTime > 0) {
	            cancelPreviousTimeout();
	            scheduleSearchWithTimeout(inputValue);
	          } else {
	            getMatchesAsync(inputValue);
	          }
	        } else {
	          isLoadingSetter(originalScope, false);
	          cancelPreviousTimeout();
	          resetMatches();
	        }
	
	        if (isEditable) {
	          return inputValue;
	        } else {
	          if (!inputValue) {
	            // Reset in case user had typed something previously.
	            modelCtrl.$setValidity('editable', true);
	            return null;
	          } else {
	            modelCtrl.$setValidity('editable', false);
	            return undefined;
	          }
	        }
	      });
	
	      modelCtrl.$formatters.push(function(modelValue) {
	        var candidateViewValue, emptyViewValue;
	        var locals = {};
	
	        // The validity may be set to false via $parsers (see above) if
	        // the model is restricted to selected values. If the model
	        // is set manually it is considered to be valid.
	        if (!isEditable) {
	          modelCtrl.$setValidity('editable', true);
	        }
	
	        if (inputFormatter) {
	          locals.$model = modelValue;
	          return inputFormatter(originalScope, locals);
	        } else {
	          //it might happen that we don't have enough info to properly render input value
	          //we need to check for this situation and simply return model value if we can't apply custom formatting
	          locals[parserResult.itemName] = modelValue;
	          candidateViewValue = parserResult.viewMapper(originalScope, locals);
	          locals[parserResult.itemName] = undefined;
	          emptyViewValue = parserResult.viewMapper(originalScope, locals);
	
	          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	        }
	      });
	    };
	  }])
	
	  .directive('uibTypeahead', function() {
	    return {
	      controller: 'UibTypeaheadController',
	      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
	      link: function(originalScope, element, attrs, ctrls) {
	        ctrls[2].init(ctrls[0], ctrls[1]);
	      }
	    };
	  })
	
	  .directive('uibTypeaheadPopup', function() {
	    return {
	      scope: {
	        matches: '=',
	        query: '=',
	        active: '=',
	        position: '&',
	        moveInProgress: '=',
	        select: '&'
	      },
	      replace: true,
	      templateUrl: function(element, attrs) {
	        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
	      },
	      link: function(scope, element, attrs) {
	        scope.templateUrl = attrs.templateUrl;
	
	        scope.isOpen = function() {
	          return scope.matches.length > 0;
	        };
	
	        scope.isActive = function(matchIdx) {
	          return scope.active == matchIdx;
	        };
	
	        scope.selectActive = function(matchIdx) {
	          scope.active = matchIdx;
	        };
	
	        scope.selectMatch = function(activeIdx) {
	          scope.select({activeIdx:activeIdx});
	        };
	      }
	    };
	  })
	
	  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
	    return {
	      scope: {
	        index: '=',
	        match: '=',
	        query: '='
	      },
	      link:function(scope, element, attrs) {
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	        $templateRequest(tplUrl).then(function(tplContent) {
	          $compile(tplContent.trim())(scope, function(clonedElement) {
	            element.replaceWith(clonedElement);
	          });
	        });
	      }
	    };
	  }])
	
	  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
	    var isSanitizePresent;
	    isSanitizePresent = $injector.has('$sanitize');
	
	    function escapeRegexp(queryToEscape) {
	      // Regex: capture the whole query string and replace it with the string that will be used to match
	      // the results, for example if the capture is "a" the result will be \a
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	    }
	
	    function containsHtml(matchItem) {
	      return /<.*>/g.test(matchItem);
	    }
	
	    return function(matchItem, query) {
	      if (!isSanitizePresent && containsHtml(matchItem)) {
	        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	      }
	      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	      if (!isSanitizePresent) {
	        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	      }
	      return matchItem;
	    };
	  }]);
	
	/* Deprecated typeahead below */
	  
	angular.module('ui.bootstrap.typeahead')
	  .value('$typeaheadSuppressWarning', false)
	  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {
	    if (!$typeaheadSuppressWarning) {
	      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');
	    }
	
	    return uibTypeaheadParser;
	  }])
	
	  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',
	    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {
	    var HOT_KEYS = [9, 13, 27, 38, 40];
	    var eventDebounceTime = 200;
	    return {
	      require: ['ngModel', '^?ngModelOptions'],
	      link: function(originalScope, element, attrs, ctrls) {
	        if (!$typeaheadSuppressWarning) {
	          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');
	        }
	        var modelCtrl = ctrls[0];
	        var ngModelOptions = ctrls[1];
	        //SUPPORTED ATTRIBUTES (OPTIONS)
	
	        //minimal no of characters that needs to be entered before typeahead kicks-in
	        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
	        if (!minLength && minLength !== 0) {
	          minLength = 1;
	        }
	
	        //minimal wait time after last character typed before typeahead kicks-in
	        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
	
	        //should it restrict model values to the ones selected from the popup only?
	        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
	
	        //binding to a variable that indicates if matches are being retrieved asynchronously
	        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
	
	        //a callback executed when a match is selected
	        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
	
	        //should it select highlighted popup value when losing focus?
	        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
	
	        //binding to a variable that indicates if there were no results after the query is completed
	        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
	
	        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
	
	        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
	
	        var appendToElementId =  attrs.typeaheadAppendToElementId || false;
	
	        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
	
	        //If input matches an item of the list exactly, select it automatically
	        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
	
	        //INTERNAL VARIABLES
	
	        //model setter executed upon match selection
	        var parsedModel = $parse(attrs.ngModel);
	        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
	        var $setModelValue = function(scope, newValue) {
	          if (angular.isFunction(parsedModel(originalScope)) &&
	            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
	            return invokeModelSetter(scope, {$$$p: newValue});
	          } else {
	            return parsedModel.assign(scope, newValue);
	          }
	        };
	
	        //expressions used by typeahead
	        var parserResult = typeaheadParser.parse(attrs.typeahead);
	
	        var hasFocus;
	
	        //Used to avoid bug in iOS webview where iOS keyboard does not fire
	        //mousedown & mouseup events
	        //Issue #3699
	        var selected;
	
	        //create a child scope for the typeahead directive so we are not polluting original scope
	        //with typeahead-specific data (matches, query etc.)
	        var scope = originalScope.$new();
	        var offDestroy = originalScope.$on('$destroy', function() {
				    scope.$destroy();
	        });
	        scope.$on('$destroy', offDestroy);
	
	        // WAI-ARIA
	        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
	        element.attr({
	          'aria-autocomplete': 'list',
	          'aria-expanded': false,
	          'aria-owns': popupId
	        });
	
	        //pop-up element used to display matches
	        var popUpEl = angular.element('<div typeahead-popup></div>');
	        popUpEl.attr({
	          id: popupId,
	          matches: 'matches',
	          active: 'activeIdx',
	          select: 'select(activeIdx)',
	          'move-in-progress': 'moveInProgress',
	          query: 'query',
	          position: 'position'
	        });
	        //custom item template
	        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	        }
	
	        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
	          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
	        }
	
	        var resetMatches = function() {
	          scope.matches = [];
	          scope.activeIdx = -1;
	          element.attr('aria-expanded', false);
	        };
	
	        var getMatchId = function(index) {
	          return popupId + '-option-' + index;
	        };
	
	        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
	        // This attribute is added or removed automatically when the `activeIdx` changes.
	        scope.$watch('activeIdx', function(index) {
	          if (index < 0) {
	            element.removeAttr('aria-activedescendant');
	          } else {
	            element.attr('aria-activedescendant', getMatchId(index));
	          }
	        });
	
	        var inputIsExactMatch = function(inputValue, index) {
	          if (scope.matches.length > index && inputValue) {
	            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
	          }
	
	          return false;
	        };
	
	        var getMatchesAsync = function(inputValue) {
	          var locals = {$viewValue: inputValue};
	          isLoadingSetter(originalScope, true);
	          isNoResultsSetter(originalScope, false);
	          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
	            //it might happen that several async queries were in progress if a user were typing fast
	            //but we are interested only in responses that correspond to the current view value
	            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
	            if (onCurrentRequest && hasFocus) {
	              if (matches && matches.length > 0) {
	                scope.activeIdx = focusFirst ? 0 : -1;
	                isNoResultsSetter(originalScope, false);
	                scope.matches.length = 0;
	
	                //transform labels
	                for (var i = 0; i < matches.length; i++) {
	                  locals[parserResult.itemName] = matches[i];
	                  scope.matches.push({
	                    id: getMatchId(i),
	                    label: parserResult.viewMapper(scope, locals),
	                    model: matches[i]
	                  });
	                }
	
	                scope.query = inputValue;
	                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	                //due to other elements being rendered
	                recalculatePosition();
	
	                element.attr('aria-expanded', true);
	
	                //Select the single remaining option if user input matches
	                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
	                  scope.select(0);
	                }
	              } else {
	                resetMatches();
	                isNoResultsSetter(originalScope, true);
	              }
	            }
	            if (onCurrentRequest) {
	              isLoadingSetter(originalScope, false);
	            }
	          }, function() {
	            resetMatches();
	            isLoadingSetter(originalScope, false);
	            isNoResultsSetter(originalScope, true);
	          });
	        };
	
	        // bind events only if appendToBody params exist - performance feature
	        if (appendToBody) {
	          angular.element($window).bind('resize', fireRecalculating);
	          $document.find('body').bind('scroll', fireRecalculating);
	        }
	
	        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutEventPromise;
	
	        // Default progress type
	        scope.moveInProgress = false;
	
	        function fireRecalculating() {
	          if (!scope.moveInProgress) {
	            scope.moveInProgress = true;
	            scope.$digest();
	          }
	
	          // Cancel previous timeout
	          if (timeoutEventPromise) {
	            $timeout.cancel(timeoutEventPromise);
	          }
	
	          // Debounced executing recalculate after events fired
	          timeoutEventPromise = $timeout(function() {
	            // if popup is visible
	            if (scope.matches.length) {
	              recalculatePosition();
	            }
	
	            scope.moveInProgress = false;
	          }, eventDebounceTime);
	        }
	
	        // recalculate actual position and set new values to scope
	        // after digest loop is popup in right position
	        function recalculatePosition() {
	          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	          scope.position.top += element.prop('offsetHeight');
	        }
	
	        resetMatches();
	
	        //we need to propagate user's query so we can higlight matches
	        scope.query = undefined;
	
	        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
	        var timeoutPromise;
	
	        var scheduleSearchWithTimeout = function(inputValue) {
	          timeoutPromise = $timeout(function() {
	            getMatchesAsync(inputValue);
	          }, waitTime);
	        };
	
	        var cancelPreviousTimeout = function() {
	          if (timeoutPromise) {
	            $timeout.cancel(timeoutPromise);
	          }
	        };
	
	        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	        modelCtrl.$parsers.unshift(function(inputValue) {
	          hasFocus = true;
	
	          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
	            if (waitTime > 0) {
	              cancelPreviousTimeout();
	              scheduleSearchWithTimeout(inputValue);
	            } else {
	              getMatchesAsync(inputValue);
	            }
	          } else {
	            isLoadingSetter(originalScope, false);
	            cancelPreviousTimeout();
	            resetMatches();
	          }
	
	          if (isEditable) {
	            return inputValue;
	          } else {
	            if (!inputValue) {
	              // Reset in case user had typed something previously.
	              modelCtrl.$setValidity('editable', true);
	              return null;
	            } else {
	              modelCtrl.$setValidity('editable', false);
	              return undefined;
	            }
	          }
	        });
	
	        modelCtrl.$formatters.push(function(modelValue) {
	          var candidateViewValue, emptyViewValue;
	          var locals = {};
	
	          // The validity may be set to false via $parsers (see above) if
	          // the model is restricted to selected values. If the model
	          // is set manually it is considered to be valid.
	          if (!isEditable) {
	            modelCtrl.$setValidity('editable', true);
	          }
	
	          if (inputFormatter) {
	            locals.$model = modelValue;
	            return inputFormatter(originalScope, locals);
	          } else {
	            //it might happen that we don't have enough info to properly render input value
	            //we need to check for this situation and simply return model value if we can't apply custom formatting
	            locals[parserResult.itemName] = modelValue;
	            candidateViewValue = parserResult.viewMapper(originalScope, locals);
	            locals[parserResult.itemName] = undefined;
	            emptyViewValue = parserResult.viewMapper(originalScope, locals);
	
	            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
	          }
	        });
	
	        scope.select = function(activeIdx) {
	          //called from within the $digest() cycle
	          var locals = {};
	          var model, item;
	
	          selected = true;
	          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	          model = parserResult.modelMapper(originalScope, locals);
	          $setModelValue(originalScope, model);
	          modelCtrl.$setValidity('editable', true);
	          modelCtrl.$setValidity('parse', true);
	
	          onSelectCallback(originalScope, {
	            $item: item,
	            $model: model,
	            $label: parserResult.viewMapper(originalScope, locals)
	          });
	
	          resetMatches();
	
	          //return focus to the input element if a match was selected via a mouse click event
	          // use timeout to avoid $rootScope:inprog error
	          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
	            $timeout(function() { element[0].focus(); }, 0, false);
	          }
	        };
	
	        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	        element.bind('keydown', function(evt) {
	          //typeahead is open and an "interesting" key was pressed
	          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	            return;
	          }
	
	          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
	          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
	            resetMatches();
	            scope.$digest();
	            return;
	          }
	
	          evt.preventDefault();
	
	          if (evt.which === 40) {
	            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	            scope.$digest();
	          } else if (evt.which === 38) {
	            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
	            scope.$digest();
	          } else if (evt.which === 13 || evt.which === 9) {
	            scope.$apply(function () {
	              scope.select(scope.activeIdx);
	            });
	          } else if (evt.which === 27) {
	            evt.stopPropagation();
	
	            resetMatches();
	            scope.$digest();
	          }
	        });
	
	        element.bind('blur', function() {
	          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
	            selected = true;
	            scope.$apply(function() {
	              scope.select(scope.activeIdx);
	            });
	          }
	          hasFocus = false;
	          selected = false;
	        });
	
	        // Keep reference to click handler to unbind it.
	        var dismissClickHandler = function(evt) {
	          // Issue #3973
	          // Firefox treats right click as a click on document
	          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
	            resetMatches();
	            if (!$rootScope.$$phase) {
	              scope.$digest();
	            }
	          }
	        };
	
	        $document.bind('click', dismissClickHandler);
	
	        originalScope.$on('$destroy', function() {
	          $document.unbind('click', dismissClickHandler);
	          if (appendToBody || appendToElementId) {
	            $popup.remove();
	          }
	
	          if (appendToBody) {
	            angular.element($window).unbind('resize', fireRecalculating);
	            $document.find('body').unbind('scroll', fireRecalculating);
	          }
	          // Prevent jQuery cache memory leak
	          popUpEl.remove();
	        });
	
	        var $popup = $compile(popUpEl)(scope);
	
	        if (appendToBody) {
	          $document.find('body').append($popup);
	        } else if (appendToElementId !== false) {
	          angular.element($document[0].getElementById(appendToElementId)).append($popup);
	        } else {
	          element.after($popup);
	        }
	      }
	    };
	  }])
	  
	  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {
	    return {
	      scope: {
	        matches: '=',
	        query: '=',
	        active: '=',
	        position: '&',
	        moveInProgress: '=',
	        select: '&'
	      },
	      replace: true,
	      templateUrl: function(element, attrs) {
	        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
	      },
	      link: function(scope, element, attrs) {
	        
	        if (!$typeaheadSuppressWarning) {
	          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');
	        }
	        scope.templateUrl = attrs.templateUrl;
	
	        scope.isOpen = function() {
	          return scope.matches.length > 0;
	        };
	
	        scope.isActive = function(matchIdx) {
	          return scope.active == matchIdx;
	        };
	
	        scope.selectActive = function(matchIdx) {
	          scope.active = matchIdx;
	        };
	
	        scope.selectMatch = function(activeIdx) {
	          scope.select({activeIdx:activeIdx});
	        };
	      }
	    };
	  }])
	  
	  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '=',
	        match: '=',
	        query: '='
	      },
	      link:function(scope, element, attrs) {
	        if (!$typeaheadSuppressWarning) {
	          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');
	        }
	
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	        $templateRequest(tplUrl).then(function(tplContent) {
	          $compile(tplContent.trim())(scope, function(clonedElement) {
	            element.replaceWith(clonedElement);
	          });
	        });
	      }
	    };
	  }])
	  
	  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {
	    var isSanitizePresent;
	    isSanitizePresent = $injector.has('$sanitize');
	
	    function escapeRegexp(queryToEscape) {
	      // Regex: capture the whole query string and replace it with the string that will be used to match
	      // the results, for example if the capture is "a" the result will be \a
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	    }
	
	    function containsHtml(matchItem) {
	      return /<.*>/g.test(matchItem);
	    }
	
	    return function(matchItem, query) {
	      if (!$typeaheadSuppressWarning) {
	        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');
	      }
	
	      if (!isSanitizePresent && containsHtml(matchItem)) {
	        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
	      }
	
	      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
	      if (!isSanitizePresent) {
	        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
	      }
	
	      return matchItem;
	    };
	  }]);
	
	angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion-group.html",
	    "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" +
	    "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
	    "    <h4 class=\"panel-title\">\n" +
	    "      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
	    "    </h4>\n" +
	    "  </div>\n" +
	    "  <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
	    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion.html",
	    "<div class=\"panel-group\" ng-transclude></div>");
	}]);
	
	angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/alert/alert.html",
	    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
	    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
	    "        <span aria-hidden=\"true\">&times;</span>\n" +
	    "        <span class=\"sr-only\">Close</span>\n" +
	    "    </button>\n" +
	    "    <div ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/carousel.html",
	    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
	    "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
	    "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
	    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
	    "    <span class=\"sr-only\">previous</span>\n" +
	    "  </a>\n" +
	    "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
	    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
	    "    <span class=\"sr-only\">next</span>\n" +
	    "  </a>\n" +
	    "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
	    "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
	    "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
	    "    </li>\n" +
	    "  </ol>\n" +
	    "</div>");
	}]);
	
	angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/slide.html",
	    "<div ng-class=\"{\n" +
	    "    'active': active\n" +
	    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/datepicker.html",
	    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
	    "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
	    "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
	    "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
	    "</div>");
	}]);
	
	angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/day.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
	    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/month.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/popup.html",
	    "<ul class=\"dropdown-menu\" dropdown-nested ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
	    "	<li ng-transclude></li>\n" +
	    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
	    "		<span class=\"btn-group pull-left\">\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
	    "		</span>\n" +
	    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
	    "	</li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/year.html",
	    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
	    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
	    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/backdrop.html",
	    "<div uib-modal-animation-class=\"fade\"\n" +
	    "     modal-in-class=\"in\"\n" +
	    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
	    "></div>\n" +
	    "");
	}]);
	
	angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/window.html",
	    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
	    "    uib-modal-animation-class=\"fade\"\n" +
	    "    modal-in-class=\"in\"\n" +
	    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
	    "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pagination.html",
	    "<ul class=\"pagination\">\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
	    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
	    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
	    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-popup.html",
	    "<div\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-popup.html",
	    "<div\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-template-popup.html",
	    "<div\n" +
	    "  tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\"\n" +
	    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
	    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-html.html",
	    "<div tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover-template.html",
	    "<div tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\"\n" +
	    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
	    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover.html",
	    "<div tooltip-animation-class=\"fade\"\n" +
	    "  uib-tooltip-classes\n" +
	    "  ng-class=\"{ in: isOpen() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/bar.html",
	    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "");
	}]);
	
	angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progress.html",
	    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
	}]);
	
	angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progressbar.html",
	    "<div class=\"progress\">\n" +
	    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/rating/rating.html",
	    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
	    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
	    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\n" +
	    "</span>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tab.html",
	    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
	    "  <a href ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\n" +
	    "</li>\n" +
	    "");
	}]);
	
	angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tabset.html",
	    "<div>\n" +
	    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	    "  <div class=\"tab-content\">\n" +
	    "    <div class=\"tab-pane\" \n" +
	    "         ng-repeat=\"tab in tabs\" \n" +
	    "         ng-class=\"{active: tab.active}\"\n" +
	    "         uib-tab-content-transclude=\"tab\">\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);
	
	angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/timepicker/timepicker.html",
	    "<table>\n" +
	    "  <tbody>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "    <tr>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" +
	    "      </td>\n" +
	    "      <td>:</td>\n" +
	    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" +
	    "      </td>\n" +
	    "      <td ng-show=\"showMeridian\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
	    "    </tr>\n" +
	    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
	    "      <td><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td>&nbsp;</td>\n" +
	    "      <td><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "      <td ng-show=\"showMeridian\"></td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-match.html",
	    "<a href tabindex=\"-1\" ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"></a>\n" +
	    "");
	}]);
	
	angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-popup.html",
	    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
	    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" +
	    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	    "    </li>\n" +
	    "</ul>\n" +
	    "");
	}]);
	!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(188);
	module.exports = 'ngSanitize';


/***/ },
/* 188 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.5.3
	 * (c) 2010-2016 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 *     Any commits to this file should be reviewed with security in mind.  *
	 *   Changes to this file can potentially create security vulnerabilities. *
	 *          An approval from 2 Core members with history of modifying      *
	 *                         this file is required.                          *
	 *                                                                         *
	 *  Does the change somehow allow for arbitrary javascript to be executed? *
	 *    Or allows for someone to change the prototype of built-in objects?   *
	 *     Or gives undesired access to variables likes document or window?    *
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	var $sanitizeMinErr = angular.$$minErr('$sanitize');
	
	/**
	 * @ngdoc module
	 * @name ngSanitize
	 * @description
	 *
	 * # ngSanitize
	 *
	 * The `ngSanitize` module provides functionality to sanitize HTML.
	 *
	 *
	 * <div doc-module-components="ngSanitize"></div>
	 *
	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
	 */
	
	/**
	 * @ngdoc service
	 * @name $sanitize
	 * @kind function
	 *
	 * @description
	 *   Sanitizes an html string by stripping all potentially dangerous tokens.
	 *
	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
	 *   it into the returned string.
	 *
	 *   The whitelist for URL sanitization of attribute values is configured using the functions
	 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
	 *   `$compileProvider`}.
	 *
	 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
	 *
	 * @param {string} html HTML input.
	 * @returns {string} Sanitized HTML.
	 *
	 * @example
	   <example module="sanitizeExample" deps="angular-sanitize.js">
	   <file name="index.html">
	     <script>
	         angular.module('sanitizeExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
	             $scope.snippet =
	               '<p style="color:blue">an html\n' +
	               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
	               'snippet</p>';
	             $scope.deliberatelyTrustDangerousSnippet = function() {
	               return $sce.trustAsHtml($scope.snippet);
	             };
	           }]);
	     </script>
	     <div ng-controller="ExampleController">
	        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Directive</td>
	           <td>How</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="bind-html-with-sanitize">
	           <td>ng-bind-html</td>
	           <td>Automatically uses $sanitize</td>
	           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind-html="snippet"></div></td>
	         </tr>
	         <tr id="bind-html-with-trust">
	           <td>ng-bind-html</td>
	           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
	           <td>
	           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
	&lt;/div&gt;</pre>
	           </td>
	           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
	         </tr>
	         <tr id="bind-default">
	           <td>ng-bind</td>
	           <td>Automatically escapes</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	       </div>
	   </file>
	   <file name="protractor.js" type="protractor">
	     it('should sanitize the html snippet by default', function() {
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
	     });
	
	     it('should inline raw snippet if bound to a trusted value', function() {
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
	         toBe("<p style=\"color:blue\">an html\n" +
	              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
	              "snippet</p>");
	     });
	
	     it('should escape snippet without any filter', function() {
	       expect(element(by.css('#bind-default div')).getInnerHtml()).
	         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
	              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
	              "snippet&lt;/p&gt;");
	     });
	
	     it('should update', function() {
	       element(by.model('snippet')).clear();
	       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('new <b>text</b>');
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
	         'new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
	         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
	     });
	   </file>
	   </example>
	 */
	
	
	/**
	 * @ngdoc provider
	 * @name $sanitizeProvider
	 *
	 * @description
	 * Creates and configures {@link $sanitize} instance.
	 */
	function $SanitizeProvider() {
	  var svgEnabled = false;
	
	  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
	    if (svgEnabled) {
	      angular.extend(validElements, svgElements);
	    }
	    return function(html) {
	      var buf = [];
	      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
	        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
	      }));
	      return buf.join('');
	    };
	  }];
	
	
	  /**
	   * @ngdoc method
	   * @name $sanitizeProvider#enableSvg
	   * @kind function
	   *
	   * @description
	   * Enables a subset of svg to be supported by the sanitizer.
	   *
	   * <div class="alert alert-warning">
	   *   <p>By enabling this setting without taking other precautions, you might expose your
	   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
	   *   outside of the containing element and be rendered over other elements on the page (e.g. a login
	   *   link). Such behavior can then result in phishing incidents.</p>
	   *
	   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
	   *   tags within the sanitized content:</p>
	   *
	   *   <br>
	   *
	   *   <pre><code>
	   *   .rootOfTheIncludedContent svg {
	   *     overflow: hidden !important;
	   *   }
	   *   </code></pre>
	   * </div>
	   *
	   * @param {boolean=} regexp New regexp to whitelist urls with.
	   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
	   *    without an argument or self for chaining otherwise.
	   */
	  this.enableSvg = function(enableSvg) {
	    if (angular.isDefined(enableSvg)) {
	      svgEnabled = enableSvg;
	      return this;
	    } else {
	      return svgEnabled;
	    }
	  };
	}
	
	function sanitizeText(chars) {
	  var buf = [];
	  var writer = htmlSanitizeWriter(buf, angular.noop);
	  writer.chars(chars);
	  return buf.join('');
	}
	
	
	// Regular Expressions for parsing tags and attributes
	var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	  // Match everything outside of normal chars and " (quote character)
	  NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	
	
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var voidElements = toMap("area,br,col,hr,img,wbr");
	
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
	    optionalEndTagInlineElements = toMap("rp,rt"),
	    optionalEndTagElements = angular.extend({},
	                                            optionalEndTagInlineElements,
	                                            optionalEndTagBlockElements);
	
	// Safe Block Elements - HTML5
	var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," +
	        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
	        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
	
	// Inline Elements - HTML5
	var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
	        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
	        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
	
	// SVG Elements
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
	// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
	// They can potentially allow for arbitrary javascript to be executed. See #11290
	var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
	        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
	        "radialGradient,rect,stop,svg,switch,text,title,tspan");
	
	// Blocked Elements (will be stripped)
	var blockedElements = toMap("script,style");
	
	var validElements = angular.extend({},
	                                   voidElements,
	                                   blockElements,
	                                   inlineElements,
	                                   optionalEndTagElements);
	
	//Attributes that have href and hence need to be sanitized
	var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
	
	var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
	    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
	    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
	    'valign,value,vspace,width');
	
	// SVG attributes (without "id" and "name" attributes)
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
	var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
	    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
	    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
	    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
	    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
	    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
	    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
	    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
	    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
	    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
	    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
	    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
	    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
	    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
	    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
	
	var validAttrs = angular.extend({},
	                                uriAttrs,
	                                svgAttrs,
	                                htmlAttrs);
	
	function toMap(str, lowercaseKeys) {
	  var obj = {}, items = str.split(','), i;
	  for (i = 0; i < items.length; i++) {
	    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
	  }
	  return obj;
	}
	
	var inertBodyElement;
	(function(window) {
	  var doc;
	  if (window.document && window.document.implementation) {
	    doc = window.document.implementation.createHTMLDocument("inert");
	  } else {
	    throw $sanitizeMinErr('noinert', "Can't create an inert html document");
	  }
	  var docElement = doc.documentElement || doc.getDocumentElement();
	  var bodyElements = docElement.getElementsByTagName('body');
	
	  // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one
	  if (bodyElements.length === 1) {
	    inertBodyElement = bodyElements[0];
	  } else {
	    var html = doc.createElement('html');
	    inertBodyElement = doc.createElement('body');
	    html.appendChild(inertBodyElement);
	    doc.appendChild(html);
	  }
	})(window);
	
	/**
	 * @example
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 * @param {string} html string
	 * @param {object} handler
	 */
	function htmlParser(html, handler) {
	  if (html === null || html === undefined) {
	    html = '';
	  } else if (typeof html !== 'string') {
	    html = '' + html;
	  }
	  inertBodyElement.innerHTML = html;
	
	  //mXSS protection
	  var mXSSAttempts = 5;
	  do {
	    if (mXSSAttempts === 0) {
	      throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
	    }
	    mXSSAttempts--;
	
	    // strip custom-namespaced attributes on IE<=11
	    if (document.documentMode <= 11) {
	      stripCustomNsAttrs(inertBodyElement);
	    }
	    html = inertBodyElement.innerHTML; //trigger mXSS
	    inertBodyElement.innerHTML = html;
	  } while (html !== inertBodyElement.innerHTML);
	
	  var node = inertBodyElement.firstChild;
	  while (node) {
	    switch (node.nodeType) {
	      case 1: // ELEMENT_NODE
	        handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
	        break;
	      case 3: // TEXT NODE
	        handler.chars(node.textContent);
	        break;
	    }
	
	    var nextNode;
	    if (!(nextNode = node.firstChild)) {
	      if (node.nodeType == 1) {
	        handler.end(node.nodeName.toLowerCase());
	      }
	      nextNode = node.nextSibling;
	      if (!nextNode) {
	        while (nextNode == null) {
	          node = node.parentNode;
	          if (node === inertBodyElement) break;
	          nextNode = node.nextSibling;
	          if (node.nodeType == 1) {
	            handler.end(node.nodeName.toLowerCase());
	          }
	        }
	      }
	    }
	    node = nextNode;
	  }
	
	  while (node = inertBodyElement.firstChild) {
	    inertBodyElement.removeChild(node);
	  }
	}
	
	function attrToMap(attrs) {
	  var map = {};
	  for (var i = 0, ii = attrs.length; i < ii; i++) {
	    var attr = attrs[i];
	    map[attr.name] = attr.value;
	  }
	  return map;
	}
	
	
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	  return value.
	    replace(/&/g, '&amp;').
	    replace(SURROGATE_PAIR_REGEXP, function(value) {
	      var hi = value.charCodeAt(0);
	      var low = value.charCodeAt(1);
	      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    }).
	    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
	      return '&#' + value.charCodeAt(0) + ';';
	    }).
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;');
	}
	
	/**
	 * create an HTML/XML writer which writes to buffer
	 * @param {Array} buf use buf.join('') to get out sanitized html string
	 * @returns {object} in the form of {
	 *     start: function(tag, attrs) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * }
	 */
	function htmlSanitizeWriter(buf, uriValidator) {
	  var ignoreCurrentElement = false;
	  var out = angular.bind(buf, buf.push);
	  return {
	    start: function(tag, attrs) {
	      tag = angular.lowercase(tag);
	      if (!ignoreCurrentElement && blockedElements[tag]) {
	        ignoreCurrentElement = tag;
	      }
	      if (!ignoreCurrentElement && validElements[tag] === true) {
	        out('<');
	        out(tag);
	        angular.forEach(attrs, function(value, key) {
	          var lkey=angular.lowercase(key);
	          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
	          if (validAttrs[lkey] === true &&
	            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
	            out(' ');
	            out(key);
	            out('="');
	            out(encodeEntities(value));
	            out('"');
	          }
	        });
	        out('>');
	      }
	    },
	    end: function(tag) {
	      tag = angular.lowercase(tag);
	      if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
	        out('</');
	        out(tag);
	        out('>');
	      }
	      if (tag == ignoreCurrentElement) {
	        ignoreCurrentElement = false;
	      }
	    },
	    chars: function(chars) {
	      if (!ignoreCurrentElement) {
	        out(encodeEntities(chars));
	      }
	    }
	  };
	}
	
	
	/**
	 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
	 * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
	 * to allow any of these custom attributes. This method strips them all.
	 *
	 * @param node Root element to process
	 */
	function stripCustomNsAttrs(node) {
	  if (node.nodeType === Node.ELEMENT_NODE) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var attrNode = attrs[i];
	      var attrName = attrNode.name.toLowerCase();
	      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	        node.removeAttributeNode(attrNode);
	        i--;
	        l--;
	      }
	    }
	  }
	
	  var nextNode = node.firstChild;
	  if (nextNode) {
	    stripCustomNsAttrs(nextNode);
	  }
	
	  nextNode = node.nextSibling;
	  if (nextNode) {
	    stripCustomNsAttrs(nextNode);
	  }
	}
	
	
	
	// define ngSanitize module and register $sanitize service
	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
	
	/* global sanitizeText: false */
	
	/**
	 * @ngdoc filter
	 * @name linky
	 * @kind function
	 *
	 * @description
	 * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and
	 * plain email address links.
	 *
	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
	 *
	 * @param {string} text Input text.
	 * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.
	 * @param {object|function(url)} [attributes] Add custom attributes to the link element.
	 *
	 *    Can be one of:
	 *
	 *    - `object`: A map of attributes
	 *    - `function`: Takes the url as a parameter and returns a map of attributes
	 *
	 *    If the map of attributes contains a value for `target`, it overrides the value of
	 *    the target parameter.
	 *
	 *
	 * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
	 *
	 * @usage
	   <span ng-bind-html="linky_expression | linky"></span>
	 *
	 * @example
	   <example module="linkyExample" deps="angular-sanitize.js">
	     <file name="index.html">
	       <div ng-controller="ExampleController">
	       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <th>Filter</th>
	           <th>Source</th>
	           <th>Rendered</th>
	         </tr>
	         <tr id="linky-filter">
	           <td>linky filter</td>
	           <td>
	             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
	           </td>
	           <td>
	             <div ng-bind-html="snippet | linky"></div>
	           </td>
	         </tr>
	         <tr id="linky-target">
	          <td>linky target</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
	          </td>
	         </tr>
	         <tr id="linky-custom-attributes">
	          <td>linky custom attributes</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
	          </td>
	         </tr>
	         <tr id="escaped-html">
	           <td>no filter</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	     </file>
	     <file name="script.js">
	       angular.module('linkyExample', ['ngSanitize'])
	         .controller('ExampleController', ['$scope', function($scope) {
	           $scope.snippet =
	             'Pretty text with some links:\n'+
	             'http://angularjs.org/,\n'+
	             'mailto:us@somewhere.org,\n'+
	             'another@somewhere.org,\n'+
	             'and one more: ftp://127.0.0.1/.';
	           $scope.snippetWithSingleURL = 'http://angularjs.org/';
	         }]);
	     </file>
	     <file name="protractor.js" type="protractor">
	       it('should linkify the snippet with urls', function() {
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
	       });
	
	       it('should not linkify snippet without the linky filter', function() {
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
	       });
	
	       it('should update', function() {
	         element(by.model('snippet')).clear();
	         element(by.model('snippet')).sendKeys('new http://link.');
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('new http://link.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
	             .toBe('new http://link.');
	       });
	
	       it('should work with the target property', function() {
	        expect(element(by.id('linky-target')).
	            element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
	       });
	
	       it('should optionally add custom attributes', function() {
	        expect(element(by.id('linky-custom-attributes')).
	            element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
	       });
	     </file>
	   </example>
	 */
	angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
	  var LINKY_URL_REGEXP =
	        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
	      MAILTO_REGEXP = /^mailto:/i;
	
	  var linkyMinErr = angular.$$minErr('linky');
	  var isString = angular.isString;
	
	  return function(text, target, attributes) {
	    if (text == null || text === '') return text;
	    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
	
	    var match;
	    var raw = text;
	    var html = [];
	    var url;
	    var i;
	    while ((match = raw.match(LINKY_URL_REGEXP))) {
	      // We can not end in these as they are sometimes found at the end of the sentence
	      url = match[0];
	      // if we did not match ftp/http/www/mailto then assume mailto
	      if (!match[2] && !match[4]) {
	        url = (match[3] ? 'http://' : 'mailto:') + url;
	      }
	      i = match.index;
	      addText(raw.substr(0, i));
	      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
	      raw = raw.substring(i + match[0].length);
	    }
	    addText(raw);
	    return $sanitize(html.join(''));
	
	    function addText(text) {
	      if (!text) {
	        return;
	      }
	      html.push(sanitizeText(text));
	    }
	
	    function addLink(url, text) {
	      var key;
	      html.push('<a ');
	      if (angular.isFunction(attributes)) {
	        attributes = attributes(url);
	      }
	      if (angular.isObject(attributes)) {
	        for (key in attributes) {
	          html.push(key + '="' + attributes[key] + '" ');
	        }
	      } else {
	        attributes = {};
	      }
	      if (angular.isDefined(target) && !('target' in attributes)) {
	        html.push('target="',
	                  target,
	                  '" ');
	      }
	      html.push('href="',
	                url.replace(/"/g, '&quot;'),
	                '">');
	      addText(text);
	      html.push('</a>');
	    }
	  };
	}]);
	
	
	})(window, window.angular);


/***/ },
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["moment"] = __webpack_require__(209);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.10.6
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';
	
	    var hookCallback;
	
	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }
	
	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }
	
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }
	
	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }
	
	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }
	
	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }
	
	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }
	
	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }
	
	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }
	
	        return a;
	    }
	
	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }
	
	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false
	        };
	    }
	
	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }
	
	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            m._isValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated;
	
	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }
	
	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }
	
	        return m;
	    }
	
	    var momentProperties = utils_hooks__hooks.momentProperties = [];
	
	    function copyConfig(to, from) {
	        var i, prop, val;
	
	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = getParsingFlags(from);
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }
	
	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }
	
	        return to;
	    }
	
	    var updateInProgress = false;
	
	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }
	
	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }
	
	    function absFloor (number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }
	
	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;
	
	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }
	
	        return value;
	    }
	
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }
	
	    function Locale() {
	    }
	
	    var locales = {};
	    var globalLocale;
	
	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }
	
	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;
	
	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }
	
	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && typeof module !== 'undefined' &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(211)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }
	
	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (typeof values === 'undefined') {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }
	
	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }
	
	        return globalLocale._abbr;
	    }
	
	    function defineLocale (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            locales[name] = locales[name] || new Locale();
	            locales[name].set(values);
	
	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	
	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }
	
	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;
	
	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }
	
	        if (!key) {
	            return globalLocale;
	        }
	
	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }
	
	        return chooseLocale(key);
	    }
	
	    var aliases = {};
	
	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }
	
	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }
	
	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;
	
	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }
	
	        return normalizedInput;
	    }
	
	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }
	
	    function get_set__get (mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }
	
	    function get_set__set (mom, unit, value) {
	        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }
	
	    // MOMENTS
	
	    function getSet (units, value) {
	        var unit;
	        if (typeof units === 'object') {
	            for (unit in units) {
	                this.set(unit, units[unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (typeof this[units] === 'function') {
	                return this[units](value);
	            }
	        }
	        return this;
	    }
	
	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }
	
	    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	    var formatFunctions = {};
	
	    var formatTokenFunctions = {};
	
	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }
	
	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }
	
	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;
	
	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }
	
	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }
	
	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }
	
	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	        return formatFunctions[format](m);
	    }
	
	    function expandFormat(format, locale) {
	        var i = 5;
	
	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }
	
	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }
	
	        return format;
	    }
	
	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	
	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	    // any word (or two) characters or numbers including two/three word month in arabic.
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	    var regexes = {};
	
	    function isFunction (sth) {
	        // https://github.com/moment/moment/issues/2325
	        return typeof sth === 'function' &&
	            Object.prototype.toString.call(sth) === '[object Function]';
	    }
	
	
	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }
	
	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }
	
	        return regexes[token](config._strict, config._locale);
	    }
	
	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }
	
	    var tokens = {};
	
	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }
	
	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }
	
	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }
	
	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	
	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }
	
	    // FORMATTING
	
	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });
	
	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });
	
	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });
	
	    // ALIASES
	
	    addUnitAlias('month', 'M');
	
	    // PARSING
	
	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  matchWord);
	    addRegexToken('MMMM', matchWord);
	
	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });
	
	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });
	
	    // LOCALES
	
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m) {
	        return this._months[m.month()];
	    }
	
	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m) {
	        return this._monthsShort[m.month()];
	    }
	
	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;
	
	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }
	
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function setMonth (mom, value) {
	        var dayOfMonth;
	
	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }
	
	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }
	
	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }
	
	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }
	
	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;
	
	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;
	
	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	
	            getParsingFlags(m).overflow = overflow;
	        }
	
	        return m;
	    }
	
	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }
	
	    function deprecate(msg, fn) {
	        var firstTime = true;
	
	        return extend(function () {
	            if (firstTime) {
	                warn(msg + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }
	
	    var deprecations = {};
	
	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }
	
	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	
	    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	
	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	        ['YYYY-DDD', /\d{4}-\d{3}/]
	    ];
	
	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	        ['HH:mm', /(T| )\d\d:\d\d/],
	        ['HH', /(T| )\d\d/]
	    ];
	
	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = from_string__isoRegex.exec(string);
	
	        if (match) {
	            getParsingFlags(config).iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    config._f = isoDates[i][0];
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    // match[6] should be 'T' or space
	                    config._f += (match[6] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(matchOffset)) {
	                config._f += 'Z';
	            }
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }
	
	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }
	
	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );
	
	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);
	
	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }
	
	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }
	
	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });
	
	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	    // ALIASES
	
	    addUnitAlias('year', 'y');
	
	    // PARSING
	
	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);
	
	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	
	    // HELPERS
	
	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }
	
	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }
	
	    // HOOKS
	
	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };
	
	    // MOMENTS
	
	    var getSetYear = makeGetSet('FullYear', false);
	
	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }
	
	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	    // ALIASES
	
	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');
	
	    // PARSING
	
	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);
	
	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });
	
	    // HELPERS
	
	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;
	
	
	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }
	
	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }
	
	        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }
	
	    // LOCALES
	
	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }
	
	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };
	
	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }
	
	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }
	
	    // MOMENTS
	
	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }
	
	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	    // ALIASES
	
	    addUnitAlias('dayOfYear', 'DDD');
	
	    // PARSING
	
	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });
	
	    // HELPERS
	
	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
	        if (d < firstDayOfWeek) {
	            d += 7;
	        }
	
	        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;
	
	        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;
	
	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }
	
	    // MOMENTS
	
	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }
	
	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }
	
	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
	        }
	        return [now.getFullYear(), now.getMonth(), now.getDate()];
	    }
	
	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;
	
	        if (config._d) {
	            return;
	        }
	
	        currentDate = currentDateArray(config);
	
	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }
	
	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }
	
	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }
	
	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }
	
	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }
	
	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }
	
	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }
	
	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }
	
	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;
	
	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;
	
	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;
	
	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);
	
	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
	
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	
	    utils_hooks__hooks.ISO_8601 = function () {};
	
	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	
	        config._a = [];
	        getParsingFlags(config).empty = true;
	
	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;
	
	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }
	
	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }
	
	        // clear _12h flag if hour is <= 12
	        if (getParsingFlags(config).bigHour === true &&
	                config._a[HOUR] <= 12 &&
	                config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	        configFromArray(config);
	        checkOverflow(config);
	    }
	
	
	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;
	
	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }
	
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	
	            scoreToBeat,
	            i,
	            currentScore;
	
	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }
	
	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);
	
	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }
	
	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	            getParsingFlags(tempConfig).score = currentScore;
	
	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }
	
	        extend(config, bestMoment || tempConfig);
	    }
	
	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }
	
	        var i = normalizeObjectUnits(config._i);
	        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];
	
	        configFromArray(config);
	    }
	
	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }
	
	        return res;
	    }
	
	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;
	
	        config._locale = config._locale || locale_locales__getLocale(config._l);
	
	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }
	
	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }
	
	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else {
	            configFromInput(config);
	        }
	
	        return config;
	    }
	
	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }
	
	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};
	
	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	
	        return createFromConfig(c);
	    }
	
	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }
	
	    var prototypeMin = deprecate(
	         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	         function () {
	             var other = local__createLocal.apply(null, arguments);
	             return other < this ? this : other;
	         }
	     );
	
	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            return other > this ? this : other;
	        }
	    );
	
	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }
	
	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isBefore', args);
	    }
	
	    function max () {
	        var args = [].slice.call(arguments, 0);
	
	        return pickBy('isAfter', args);
	    }
	
	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;
	
	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;
	
	        this._data = {};
	
	        this._locale = locale_locales__getLocale();
	
	        this._bubble();
	    }
	
	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }
	
	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }
	
	    offset('Z', ':');
	    offset('ZZ', '');
	
	    // PARSING
	
	    addRegexToken('Z',  matchOffset);
	    addRegexToken('ZZ', matchOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(input);
	    });
	
	    // HELPERS
	
	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;
	
	    function offsetFromString(string) {
	        var matches = ((string || '').match(matchOffset) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	        return parts[0] === '+' ? minutes : -minutes;
	    }
	
	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }
	
	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }
	
	    // HOOKS
	
	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};
	
	    // MOMENTS
	
	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(input);
	            }
	            if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }
	
	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }
	
	            this.utcOffset(input, keepLocalTime);
	
	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }
	
	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }
	
	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;
	
	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }
	
	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            this.utcOffset(offsetFromString(this._i));
	        }
	        return this;
	    }
	
	    function hasAlignedHourOffset (input) {
	        input = input ? local__createLocal(input).utcOffset() : 0;
	
	        return (this.utcOffset() - input) % 60 === 0;
	    }
	
	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }
	
	    function isDaylightSavingTimeShifted () {
	        if (typeof this._isDSTShifted !== 'undefined') {
	            return this._isDSTShifted;
	        }
	
	        var c = {};
	
	        copyConfig(c, this);
	        c = prepareConfig(c);
	
	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }
	
	        return this._isDSTShifted;
	    }
	
	    function isLocal () {
	        return !this._isUTC;
	    }
	
	    function isUtcOffset () {
	        return this._isUTC;
	    }
	
	    function isUtc () {
	        return this._isUTC && this._offset === 0;
	    }
	
	    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
	
	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
	
	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;
	
	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])        * sign,
	                h  : toInt(match[HOUR])        * sign,
	                m  : toInt(match[MINUTE])      * sign,
	                s  : toInt(match[SECOND])      * sign,
	                ms : toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = create__isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                d : parseIso(match[4], sign),
	                h : parseIso(match[5], sign),
	                m : parseIso(match[6], sign),
	                s : parseIso(match[7], sign),
	                w : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
	
	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }
	
	        ret = new Duration(duration);
	
	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }
	
	        return ret;
	    }
	
	    create__createDuration.fn = Duration.prototype;
	
	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }
	
	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};
	
	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }
	
	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	        return res;
	    }
	
	    function momentsDifference(base, other) {
	        var res;
	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }
	
	        return res;
	    }
	
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }
	
	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }
	
	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;
	
	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }
	
	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');
	
	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            diff = this.diff(sod, 'days', true),
	            format = diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
	    }
	
	    function clone () {
	        return new Moment(this);
	    }
	
	    function isAfter (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this > +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return inputMs < +this.clone().startOf(units);
	        }
	    }
	
	    function isBefore (input, units) {
	        var inputMs;
	        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this < +input;
	        } else {
	            inputMs = isMoment(input) ? +input : +local__createLocal(input);
	            return +this.clone().endOf(units) < inputMs;
	        }
	    }
	
	    function isBetween (from, to, units) {
	        return this.isAfter(from, units) && this.isBefore(to, units);
	    }
	
	    function isSame (input, units) {
	        var inputMs;
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            input = isMoment(input) ? input : local__createLocal(input);
	            return +this === +input;
	        } else {
	            inputMs = +local__createLocal(input);
	            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	        }
	    }
	
	    function diff (input, units, asFloat) {
	        var that = cloneWithOffset(input, this),
	            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
	            delta, output;
	
	        units = normalizeUnits(units);
	
	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }
	
	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;
	
	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }
	
	        return -(wholeMonthDiff + adjust);
	    }
	
	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	
	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }
	
	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if ('function' === typeof Date.prototype.toISOString) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }
	
	    function format (inputString) {
	        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
	        return this.localeData().postformat(output);
	    }
	
	    function from (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }
	
	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }
	
	    function to (time, withoutSuffix) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }
	        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    }
	
	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }
	
	    function locale (key) {
	        var newLocaleData;
	
	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }
	
	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );
	
	    function localeData () {
	        return this._locale;
	    }
	
	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	        }
	
	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }
	
	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }
	
	        return this;
	    }
	
	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }
	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }
	
	    function to_type__valueOf () {
	        return +this._d - ((this._offset || 0) * 60000);
	    }
	
	    function unix () {
	        return Math.floor(+this / 1000);
	    }
	
	    function toDate () {
	        return this._offset ? new Date(+this) : this._d;
	    }
	
	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }
	
	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }
	
	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }
	
	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }
	
	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }
	
	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });
	
	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });
	
	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }
	
	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	    // ALIASES
	
	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');
	
	    // PARSING
	
	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);
	
	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });
	
	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	
	    // HELPERS
	
	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
	    }
	
	    // MOMENTS
	
	    function getSetWeekYear (input) {
	        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }
	
	    function getSetISOWeekYear (input) {
	        var year = weekOfYear(this, 1, 4).year;
	        return input == null ? year : this.add((input - year), 'y');
	    }
	
	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }
	
	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }
	
	    addFormatToken('Q', 0, 0, 'quarter');
	
	    // ALIASES
	
	    addUnitAlias('quarter', 'Q');
	
	    // PARSING
	
	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });
	
	    // MOMENTS
	
	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }
	
	    addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	    // ALIASES
	
	    addUnitAlias('date', 'D');
	
	    // PARSING
	
	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });
	
	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });
	
	    // MOMENTS
	
	    var getSetDayOfMonth = makeGetSet('Date', true);
	
	    addFormatToken('d', 0, 'do', 'day');
	
	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });
	
	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });
	
	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });
	
	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');
	
	    // ALIASES
	
	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');
	
	    // PARSING
	
	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   matchWord);
	    addRegexToken('ddd',  matchWord);
	    addRegexToken('dddd', matchWord);
	
	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
	        var weekday = config._locale.weekdaysParse(input);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });
	
	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });
	
	    // HELPERS
	
	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }
	
	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }
	
	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }
	
	        return null;
	    }
	
	    // LOCALES
	
	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m) {
	        return this._weekdays[m.day()];
	    }
	
	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return this._weekdaysShort[m.day()];
	    }
	
	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return this._weekdaysMin[m.day()];
	    }
	
	    function localeWeekdaysParse (weekdayName) {
	        var i, mom, regex;
	
	        this._weekdaysParse = this._weekdaysParse || [];
	
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            if (!this._weekdaysParse[i]) {
	                mom = local__createLocal([2000, 1]).day(i);
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }
	
	    // MOMENTS
	
	    function getSetDayOfWeek (input) {
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }
	
	    function getSetLocaleDayOfWeek (input) {
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }
	
	    function getSetISODayOfWeek (input) {
	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.
	        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	    }
	
	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, function () {
	        return this.hours() % 12 || 12;
	    });
	
	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }
	
	    meridiem('a', true);
	    meridiem('A', false);
	
	    // ALIASES
	
	    addUnitAlias('hour', 'h');
	
	    // PARSING
	
	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }
	
	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	
	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	
	    // LOCALES
	
	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }
	
	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }
	
	
	    // MOMENTS
	
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);
	
	    addFormatToken('m', ['mm', 2], 0, 'minute');
	
	    // ALIASES
	
	    addUnitAlias('minute', 'm');
	
	    // PARSING
	
	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);
	
	    // MOMENTS
	
	    var getSetMinute = makeGetSet('Minutes', false);
	
	    addFormatToken('s', ['ss', 2], 0, 'second');
	
	    // ALIASES
	
	    addUnitAlias('second', 's');
	
	    // PARSING
	
	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);
	
	    // MOMENTS
	
	    var getSetSecond = makeGetSet('Seconds', false);
	
	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });
	
	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });
	
	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });
	
	
	    // ALIASES
	
	    addUnitAlias('millisecond', 'ms');
	
	    // PARSING
	
	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);
	
	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }
	
	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }
	
	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS
	
	    var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');
	
	    // MOMENTS
	
	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }
	
	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }
	
	    var momentPrototype__proto = Moment.prototype;
	
	    momentPrototype__proto.add          = add_subtract__add;
	    momentPrototype__proto.calendar     = moment_calendar__calendar;
	    momentPrototype__proto.clone        = clone;
	    momentPrototype__proto.diff         = diff;
	    momentPrototype__proto.endOf        = endOf;
	    momentPrototype__proto.format       = format;
	    momentPrototype__proto.from         = from;
	    momentPrototype__proto.fromNow      = fromNow;
	    momentPrototype__proto.to           = to;
	    momentPrototype__proto.toNow        = toNow;
	    momentPrototype__proto.get          = getSet;
	    momentPrototype__proto.invalidAt    = invalidAt;
	    momentPrototype__proto.isAfter      = isAfter;
	    momentPrototype__proto.isBefore     = isBefore;
	    momentPrototype__proto.isBetween    = isBetween;
	    momentPrototype__proto.isSame       = isSame;
	    momentPrototype__proto.isValid      = moment_valid__isValid;
	    momentPrototype__proto.lang         = lang;
	    momentPrototype__proto.locale       = locale;
	    momentPrototype__proto.localeData   = localeData;
	    momentPrototype__proto.max          = prototypeMax;
	    momentPrototype__proto.min          = prototypeMin;
	    momentPrototype__proto.parsingFlags = parsingFlags;
	    momentPrototype__proto.set          = getSet;
	    momentPrototype__proto.startOf      = startOf;
	    momentPrototype__proto.subtract     = add_subtract__subtract;
	    momentPrototype__proto.toArray      = toArray;
	    momentPrototype__proto.toObject     = toObject;
	    momentPrototype__proto.toDate       = toDate;
	    momentPrototype__proto.toISOString  = moment_format__toISOString;
	    momentPrototype__proto.toJSON       = moment_format__toISOString;
	    momentPrototype__proto.toString     = toString;
	    momentPrototype__proto.unix         = unix;
	    momentPrototype__proto.valueOf      = to_type__valueOf;
	
	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;
	
	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
	
	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
	
	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;
	
	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
	
	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;
	
	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
	
	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
	
	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
	
	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
	
	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;
	
	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;
	
	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
	
	    var momentPrototype = momentPrototype__proto;
	
	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }
	
	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }
	
	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };
	
	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key];
	        return typeof output === 'function' ? output.call(mom, now) : output;
	    }
	
	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };
	
	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];
	
	        if (format || !formatUpper) {
	            return format;
	        }
	
	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });
	
	        return this._longDateFormat[key];
	    }
	
	    var defaultInvalidDate = 'Invalid date';
	
	    function invalidDate () {
	        return this._invalidDate;
	    }
	
	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;
	
	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }
	
	    function preParsePostFormat (string) {
	        return string;
	    }
	
	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };
	
	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (typeof output === 'function') ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }
	
	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	    }
	
	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (typeof prop === 'function') {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }
	
	    var prototype__proto = Locale.prototype;
	
	    prototype__proto._calendar       = defaultCalendar;
	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto._longDateFormat = defaultLongDateFormat;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto._invalidDate    = defaultInvalidDate;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto._ordinal        = defaultOrdinal;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto._ordinalParse   = defaultOrdinalParse;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto._relativeTime   = defaultRelativeTime;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;
	
	    // Month
	    prototype__proto.months       =        localeMonths;
	    prototype__proto._months      = defaultLocaleMonths;
	    prototype__proto.monthsShort  =        localeMonthsShort;
	    prototype__proto._monthsShort = defaultLocaleMonthsShort;
	    prototype__proto.monthsParse  =        localeMonthsParse;
	
	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto._week = defaultLocaleWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
	
	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto._weekdays      = defaultLocaleWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;
	
	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
	    prototype__proto.meridiem = localeMeridiem;
	
	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }
	
	    function list (format, index, field, count, setter) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	
	        if (index != null) {
	            return lists__get(format, index, field, setter);
	        }
	
	        var i;
	        var out = [];
	        for (i = 0; i < count; i++) {
	            out[i] = lists__get(format, i, field, setter);
	        }
	        return out;
	    }
	
	    function lists__listMonths (format, index) {
	        return list(format, index, 'months', 12, 'month');
	    }
	
	    function lists__listMonthsShort (format, index) {
	        return list(format, index, 'monthsShort', 12, 'month');
	    }
	
	    function lists__listWeekdays (format, index) {
	        return list(format, index, 'weekdays', 7, 'day');
	    }
	
	    function lists__listWeekdaysShort (format, index) {
	        return list(format, index, 'weekdaysShort', 7, 'day');
	    }
	
	    function lists__listWeekdaysMin (format, index) {
	        return list(format, index, 'weekdaysMin', 7, 'day');
	    }
	
	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
	
	    var mathAbs = Math.abs;
	
	    function duration_abs__abs () {
	        var data           = this._data;
	
	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);
	
	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);
	
	        return this;
	    }
	
	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);
	
	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;
	
	        return duration._bubble();
	    }
	
	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }
	
	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }
	
	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }
	
	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;
	
	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }
	
	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;
	
	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;
	
	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;
	
	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;
	
	        days += absFloor(hours / 24);
	
	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));
	
	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;
	
	        data.days   = days;
	        data.months = months;
	        data.years  = years;
	
	        return this;
	    }
	
	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }
	
	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }
	
	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;
	
	        units = normalizeUnits(units);
	
	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }
	
	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }
	
	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }
	
	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');
	
	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }
	
	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }
	
	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');
	
	    function weeks () {
	        return absFloor(this.days() / 7);
	    }
	
	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };
	
	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }
	
	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));
	
	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes === 1          && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   === 1          && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    === 1          && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  === 1          && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   === 1          && ['y']           || ['yy', years];
	
	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }
	
	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }
	
	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
	
	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }
	
	        return locale.postformat(output);
	    }
	
	    var iso_string__abs = Math.abs;
	
	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;
	
	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;
	
	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;
	
	
	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();
	
	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }
	
	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }
	
	    var duration_prototype__proto = Duration.prototype;
	
	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;
	
	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;
	
	    // Side effect imports
	
	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');
	
	    // PARSING
	
	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });
	
	    // Side effect imports
	
	
	    utils_hooks__hooks.version = '2.10.6';
	
	    setHookCallback(local__createLocal);
	
	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	
	    var _moment = utils_hooks__hooks;
	
	    return _moment;
	
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(210)(module)))

/***/ },
/* 210 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 212,
		"./af.js": 212,
		"./ar": 213,
		"./ar-ma": 214,
		"./ar-ma.js": 214,
		"./ar-sa": 215,
		"./ar-sa.js": 215,
		"./ar-tn": 216,
		"./ar-tn.js": 216,
		"./ar.js": 213,
		"./az": 217,
		"./az.js": 217,
		"./be": 218,
		"./be.js": 218,
		"./bg": 219,
		"./bg.js": 219,
		"./bn": 220,
		"./bn.js": 220,
		"./bo": 221,
		"./bo.js": 221,
		"./br": 222,
		"./br.js": 222,
		"./bs": 223,
		"./bs.js": 223,
		"./ca": 224,
		"./ca.js": 224,
		"./cs": 225,
		"./cs.js": 225,
		"./cv": 226,
		"./cv.js": 226,
		"./cy": 227,
		"./cy.js": 227,
		"./da": 228,
		"./da.js": 228,
		"./de": 229,
		"./de-at": 230,
		"./de-at.js": 230,
		"./de.js": 229,
		"./el": 231,
		"./el.js": 231,
		"./en-au": 232,
		"./en-au.js": 232,
		"./en-ca": 233,
		"./en-ca.js": 233,
		"./en-gb": 234,
		"./en-gb.js": 234,
		"./eo": 235,
		"./eo.js": 235,
		"./es": 236,
		"./es.js": 236,
		"./et": 237,
		"./et.js": 237,
		"./eu": 238,
		"./eu.js": 238,
		"./fa": 239,
		"./fa.js": 239,
		"./fi": 240,
		"./fi.js": 240,
		"./fo": 241,
		"./fo.js": 241,
		"./fr": 242,
		"./fr-ca": 243,
		"./fr-ca.js": 243,
		"./fr.js": 242,
		"./fy": 244,
		"./fy.js": 244,
		"./gl": 245,
		"./gl.js": 245,
		"./he": 246,
		"./he.js": 246,
		"./hi": 247,
		"./hi.js": 247,
		"./hr": 248,
		"./hr.js": 248,
		"./hu": 249,
		"./hu.js": 249,
		"./hy-am": 250,
		"./hy-am.js": 250,
		"./id": 251,
		"./id.js": 251,
		"./is": 252,
		"./is.js": 252,
		"./it": 253,
		"./it.js": 253,
		"./ja": 254,
		"./ja.js": 254,
		"./jv": 255,
		"./jv.js": 255,
		"./ka": 256,
		"./ka.js": 256,
		"./km": 257,
		"./km.js": 257,
		"./ko": 258,
		"./ko.js": 258,
		"./lb": 259,
		"./lb.js": 259,
		"./lt": 260,
		"./lt.js": 260,
		"./lv": 261,
		"./lv.js": 261,
		"./me": 262,
		"./me.js": 262,
		"./mk": 263,
		"./mk.js": 263,
		"./ml": 264,
		"./ml.js": 264,
		"./mr": 265,
		"./mr.js": 265,
		"./ms": 266,
		"./ms-my": 267,
		"./ms-my.js": 267,
		"./ms.js": 266,
		"./my": 268,
		"./my.js": 268,
		"./nb": 269,
		"./nb.js": 269,
		"./ne": 270,
		"./ne.js": 270,
		"./nl": 271,
		"./nl.js": 271,
		"./nn": 272,
		"./nn.js": 272,
		"./pl": 273,
		"./pl.js": 273,
		"./pt": 274,
		"./pt-br": 275,
		"./pt-br.js": 275,
		"./pt.js": 274,
		"./ro": 276,
		"./ro.js": 276,
		"./ru": 277,
		"./ru.js": 277,
		"./si": 278,
		"./si.js": 278,
		"./sk": 279,
		"./sk.js": 279,
		"./sl": 280,
		"./sl.js": 280,
		"./sq": 281,
		"./sq.js": 281,
		"./sr": 282,
		"./sr-cyrl": 283,
		"./sr-cyrl.js": 283,
		"./sr.js": 282,
		"./sv": 284,
		"./sv.js": 284,
		"./ta": 285,
		"./ta.js": 285,
		"./th": 286,
		"./th.js": 286,
		"./tl-ph": 287,
		"./tl-ph.js": 287,
		"./tr": 288,
		"./tr.js": 288,
		"./tzl": 289,
		"./tzl.js": 289,
		"./tzm": 290,
		"./tzm-latn": 291,
		"./tzm-latn.js": 291,
		"./tzm.js": 290,
		"./uk": 292,
		"./uk.js": 292,
		"./uz": 293,
		"./uz.js": 293,
		"./vi": 294,
		"./vi.js": 294,
		"./zh-cn": 295,
		"./zh-cn.js": 295,
		"./zh-tw": 296,
		"./zh-tw.js": 296
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 211;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : afrikaans (af)
	//! author : Werner Mollentze : https://github.com/wernerm
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Môre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });
	
	    return af;
	
	}));

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! Locale: Arabic (ar)
	//! Author: Abdel Said: https://github.com/abdelsaid
	//! Changes in months, weekdays: Ahmed Elkhatib
	//! Native plural forms: forabi https://github.com/forabi
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'كانون الثاني يناير',
	        'شباط فبراير',
	        'آذار مارس',
	        'نيسان أبريل',
	        'أيار مايو',
	        'حزيران يونيو',
	        'تموز يوليو',
	        'آب أغسطس',
	        'أيلول سبتمبر',
	        'تشرين الأول أكتوبر',
	        'تشرين الثاني نوفمبر',
	        'كانون الأول ديسمبر'
	    ];
	
	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar;
	
	}));

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Moroccan Arabic (ar-ma)
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_ma;
	
	}));

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic Saudi Arabia (ar-sa)
	//! author : Suhail Alkowaileet : https://github.com/xsoh
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    };
	
	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ar_sa;
	
	}));

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  : Tunisian Arabic (ar-tn)
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'في %s',
	            past: 'منذ %s',
	            s: 'ثوان',
	            m: 'دقيقة',
	            mm: '%d دقائق',
	            h: 'ساعة',
	            hh: '%d ساعات',
	            d: 'يوم',
	            dd: '%d أيام',
	            M: 'شهر',
	            MM: '%d أشهر',
	            y: 'سنة',
	            yy: '%d سنوات'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ar_tn;
	
	}));

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : azerbaijani (az)
	//! author : topchiyev : https://github.com/topchiyev
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-üncü',
	        4: '-üncü',
	        100: '-üncü',
	        6: '-ncı',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-ıncı',
	        90: '-ıncı'
	    };
	
	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gələn həftə] dddd [saat] LT',
	            lastDay : '[dünən] LT',
	            lastWeek : '[keçən həftə] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s əvvəl',
	            s : 'birneçə saniyyə',
	            m : 'bir dəqiqə',
	            mm : '%d dəqiqə',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gecə|səhər|gündüz|axşam/,
	        isPM : function (input) {
	            return /^(gündüz|axşam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gecə';
	            } else if (hour < 12) {
	                return 'səhər';
	            } else if (hour < 17) {
	                return 'gündüz';
	            } else {
	                return 'axşam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return az;
	
	}));

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : belarusian (be)
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	            'dd': 'дзень_дні_дзён',
	            'MM': 'месяц_месяцы_месяцаў',
	            'yy': 'год_гады_гадоў'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвіліна' : 'хвіліну';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'гадзіна' : 'гадзіну';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_'),
	            'accusative': 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	            'accusative': 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_')
	        },
	        nounCase = (/\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }
	
	    var be = moment.defineLocale('be', {
	        months : monthsCaseReplace,
	        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сёння ў] LT',
	            nextDay: '[Заўтра ў] LT',
	            lastDay: '[Учора ў] LT',
	            nextWeek: function () {
	                return '[У] dddd [ў] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[У мінулую] dddd [ў] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[У мінулы] dddd [ў] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'праз %s',
	            past : '%s таму',
	            s : 'некалькі секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : 'дзень',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночы|раніцы|дня|вечара/,
	        isPM : function (input) {
	            return /^(дня|вечара)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночы';
	            } else if (hour < 12) {
	                return 'раніцы';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечара';
	            }
	        },
	        ordinalParse: /\d{1,2}-(і|ы|га)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	            case 'D':
	                return number + '-га';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return be;
	
	}));

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bulgarian (bg)
	//! author : Krasen Borisov : https://github.com/kraz
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var bg = moment.defineLocale('bg', {
	        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Днес в] LT',
	            nextDay : '[Утре в] LT',
	            nextWeek : 'dddd [в] LT',
	            lastDay : '[Вчера в] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[В изминалата] dddd [в] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[В изминалия] dddd [в] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'след %s',
	            past : 'преди %s',
	            s : 'няколко секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дни',
	            M : 'месец',
	            MM : '%d месеца',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bg;
	
	}));

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali (bn)
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '১',
	        '2': '২',
	        '3': '৩',
	        '4': '৪',
	        '5': '৫',
	        '6': '৬',
	        '7': '৭',
	        '8': '৮',
	        '9': '৯',
	        '0': '০'
	    },
	    numberMap = {
	        '১': '1',
	        '২': '2',
	        '৩': '3',
	        '৪': '4',
	        '৫': '5',
	        '৬': '6',
	        '৭': '7',
	        '৮': '8',
	        '৯': '9',
	        '০': '0'
	    };
	
	    var bn = moment.defineLocale('bn', {
	        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
	        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রুবার_শনিবার'.split('_'),
	        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্রু_শনি'.split('_'),
	        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm সময়',
	            LTS : 'A h:mm:ss সময়',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm সময়',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	        },
	        calendar : {
	            sameDay : '[আজ] LT',
	            nextDay : '[আগামীকাল] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[গতকাল] LT',
	            lastWeek : '[গত] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s পরে',
	            past : '%s আগে',
	            s : 'কএক সেকেন্ড',
	            m : 'এক মিনিট',
	            mm : '%d মিনিট',
	            h : 'এক ঘন্টা',
	            hh : '%d ঘন্টা',
	            d : 'এক দিন',
	            dd : '%d দিন',
	            M : 'এক মাস',
	            MM : '%d মাস',
	            y : 'এক বছর',
	            yy : '%d বছর'
	        },
	        preparse: function (string) {
	            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /রাত|সকাল|দুপুর|বিকেল|রাত/,
	        isPM: function (input) {
	            return /^(দুপুর|বিকেল|রাত)$/.test(input);
	        },
	        //Bengali is a vast language its spoken
	        //in different forms in various parts of the world.
	        //I have just generalized with most common one used
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'রাত';
	            } else if (hour < 10) {
	                return 'সকাল';
	            } else if (hour < 17) {
	                return 'দুপুর';
	            } else if (hour < 20) {
	                return 'বিকেল';
	            } else {
	                return 'রাত';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bn;
	
	}));

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tibetan (bo)
	//! author : Thupten N. Chakrishar : https://github.com/vajradog
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '༡',
	        '2': '༢',
	        '3': '༣',
	        '4': '༤',
	        '5': '༥',
	        '6': '༦',
	        '7': '༧',
	        '8': '༨',
	        '9': '༩',
	        '0': '༠'
	    },
	    numberMap = {
	        '༡': '1',
	        '༢': '2',
	        '༣': '3',
	        '༤': '4',
	        '༥': '5',
	        '༦': '6',
	        '༧': '7',
	        '༨': '8',
	        '༩': '9',
	        '༠': '0'
	    };
	
	    var bo = moment.defineLocale('bo', {
	        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[དི་རིང] LT',
	            nextDay : '[སང་ཉིན] LT',
	            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	            lastDay : '[ཁ་སང] LT',
	            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ལ་',
	            past : '%s སྔན་ལ',
	            s : 'ལམ་སང',
	            m : 'སྐར་མ་གཅིག',
	            mm : '%d སྐར་མ',
	            h : 'ཆུ་ཚོད་གཅིག',
	            hh : '%d ཆུ་ཚོད',
	            d : 'ཉིན་གཅིག',
	            dd : '%d ཉིན་',
	            M : 'ཟླ་བ་གཅིག',
	            MM : '%d ཟླ་བ',
	            y : 'ལོ་གཅིག',
	            yy : '%d ལོ'
	        },
	        preparse: function (string) {
	            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	        isPM: function (input) {
	            return /^(ཉིན་གུང|དགོང་དག|མཚན་མོ)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'མཚན་མོ';
	            } else if (hour < 10) {
	                return 'ཞོགས་ཀས';
	            } else if (hour < 17) {
	                return 'ཉིན་གུང';
	            } else if (hour < 20) {
	                return 'དགོང་དག';
	            } else {
	                return 'མཚན་མོ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bo;
	
	}));

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : breton (br)
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }
	
	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondennoù',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(añ|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'añ' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return br;
	
	}));

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : bosnian (bs)
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return bs;
	
	}));

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : catalan (ca)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : 'è';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return ca;
	
	}));

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : czech (cs)
	//! author : petrbela : https://github.com/petrbela
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dní');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'měsíce' : 'měsíců');
	            } else {
	                return result + 'měsíci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	        }
	    }
	
	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[zítra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v neděli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve středu v] LT';
	                case 4:
	                    return '[ve čtvrtek v] LT';
	                case 5:
	                    return '[v pátek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[včera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulou neděli v] LT';
	                case 1:
	                case 2:
	                    return '[minulé] dddd [v] LT';
	                case 3:
	                    return '[minulou středu v] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'před %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cs;
	
	}));

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chuvash (cv)
	//! author : Anatoly Mironov : https://github.com/mirontoli
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cv = moment.defineLocale('cv', {
	        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	        },
	        calendar : {
	            sameDay: '[Паян] LT [сехетре]',
	            nextDay: '[Ыран] LT [сехетре]',
	            lastDay: '[Ӗнер] LT [сехетре]',
	            nextWeek: '[Ҫитес] dddd LT [сехетре]',
	            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	                return output + affix;
	            },
	            past : '%s каялла',
	            s : 'пӗр-ик ҫеккунт',
	            m : 'пӗр минут',
	            mm : '%d минут',
	            h : 'пӗр сехет',
	            hh : '%d сехет',
	            d : 'пӗр кун',
	            dd : '%d кун',
	            M : 'пӗр уйӑх',
	            MM : '%d уйӑх',
	            y : 'пӗр ҫул',
	            yy : '%d ҫул'
	        },
	        ordinalParse: /\d{1,2}-мӗш/,
	        ordinal : '%d-мӗш',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return cv;
	
	}));

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh (cy)
	//! author : Robert Allen
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn ôl',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return cy;
	
	}));

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : danish (da)
	//! author : Ulrik Nielsen : https://github.com/mrbase
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I går kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'få sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'et år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return da;
	
	}));

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : german (de)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de;
	
	}));

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : austrian german (de-at)
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	
	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return de_at;
	
	}));

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : modern greek (el)
	//! author : Aggelos Karalias : https://github.com/mehiel
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'μμ' : 'ΜΜ';
	            } else {
	                return isLower ? 'πμ' : 'ΠΜ';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === 'μ');
	        },
	        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[Σήμερα {}] LT',
	            nextDay : '[Αύριο {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[Χθες {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[το προηγούμενο] dddd [{}] LT';
	                    default:
	                        return '[την προηγούμενη] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (typeof output === 'function') {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	        },
	        relativeTime : {
	            future : 'σε %s',
	            past : '%s πριν',
	            s : 'λίγα δευτερόλεπτα',
	            m : 'ένα λεπτό',
	            mm : '%d λεπτά',
	            h : 'μία ώρα',
	            hh : '%d ώρες',
	            d : 'μία μέρα',
	            dd : '%d μέρες',
	            M : 'ένας μήνας',
	            MM : '%d μήνες',
	            y : 'ένας χρόνος',
	            yy : '%d χρόνια'
	        },
	        ordinalParse: /\d{1,2}η/,
	        ordinal: '%dη',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });
	
	    return el;
	
	}));

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : australian english (en-au)
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_au;
	
	}));

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian english (en-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM, YYYY',
	            LLL : 'D MMMM, YYYY h:mm A',
	            LLLL : 'dddd, D MMMM, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	
	    return en_ca;
	
	}));

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : great britain english (en-gb)
	//! author : Chris Gedrim : https://github.com/chrisgedrim
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return en_gb;
	
	}));

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : esperanto (eo)
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodiaŭ je] LT',
	            nextDay : '[Morgaŭ je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hieraŭ je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'antaŭ %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eo;
	
	}));

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : spanish (es)
	//! author : Julio Napurí : https://github.com/julionc
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortDot = 'Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.'.split('_'),
	        monthsShort = 'Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic'.split('_');
	
	    var es = moment.defineLocale('es', {
	        months : 'Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        weekdays : 'Domingo_Lunes_Martes_Miércoles_Jueves_Viernes_Sábado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mié._Jue._Vie._Sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return es;
	
	}));

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : estonian (et)
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	            'm' : ['ühe minuti', 'üks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['ühe päeva', 'üks päev'],
	            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }
	
	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Täna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Järgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pärast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d päeva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return et;
	
	}));

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : euskara (eu)
	//! author : Eneko Illarramendi : https://github.com/eillarra
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return eu;
	
	}));

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian (fa)
	//! author : Ebrahim Byagowi : https://github.com/ebraminio
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '۱',
	        '2': '۲',
	        '3': '۳',
	        '4': '۴',
	        '5': '۵',
	        '6': '۶',
	        '7': '۷',
	        '8': '۸',
	        '9': '۹',
	        '0': '۰'
	    }, numberMap = {
	        '۱': '1',
	        '۲': '2',
	        '۳': '3',
	        '۴': '4',
	        '۵': '5',
	        '۶': '6',
	        '۷': '7',
	        '۸': '8',
	        '۹': '9',
	        '۰': '0'
	    };
	
	    var fa = moment.defineLocale('fa', {
	        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /قبل از ظهر|بعد از ظهر/,
	        isPM: function (input) {
	            return /بعد از ظهر/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'قبل از ظهر';
	            } else {
	                return 'بعد از ظهر';
	            }
	        },
	        calendar : {
	            sameDay : '[امروز ساعت] LT',
	            nextDay : '[فردا ساعت] LT',
	            nextWeek : 'dddd [ساعت] LT',
	            lastDay : '[دیروز ساعت] LT',
	            lastWeek : 'dddd [پیش] [ساعت] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'در %s',
	            past : '%s پیش',
	            s : 'چندین ثانیه',
	            m : 'یک دقیقه',
	            mm : '%d دقیقه',
	            h : 'یک ساعت',
	            hh : '%d ساعت',
	            d : 'یک روز',
	            dd : '%d روز',
	            M : 'یک ماه',
	            MM : '%d ماه',
	            y : 'یک سال',
	            yy : '%d سال'
	        },
	        preparse: function (string) {
	            return string.replace(/[۰-۹]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        ordinalParse: /\d{1,2}م/,
	        ordinal : '%dم',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return fa;
	
	}));

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : finnish (fi)
	//! author : Tarmo Aidantausta : https://github.com/bleadof
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'päivän' : 'päivä';
	        case 'dd':
	            result = isFuture ? 'päivän' : 'päivää';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }
	
	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tänään] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s päästä',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fi;
	
	}));

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : faroese (fo)
	//! author : Ragnar Johannesen : https://github.com/ragnar123
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Í dag kl.] LT',
	            nextDay : '[Í morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[Í gjár kl.] LT',
	            lastWeek : '[síðstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s síðani',
	            s : 'fá sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tími',
	            hh : '%d tímar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mánaði',
	            MM : '%d mánaðir',
	            y : 'eitt ár',
	            yy : '%d ár'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fo;
	
	}));

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : french (fr)
	//! author : John Fischer : https://github.com/jfroffice
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fr;
	
	}));

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : canadian french (fr-ca)
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });
	
	    return fr_ca;
	
	}));

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : frisian (fy)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
	
	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[ôfrûne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien minút',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return fy;
	
	}));

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : galician (gl)
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var gl = moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return gl;
	
	}));

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew (he)
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var he = moment.defineLocale('he', {
	        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [ב]MMMM YYYY',
	            LLL : 'D [ב]MMMM YYYY HH:mm',
	            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[היום ב־]LT',
	            nextDay : '[מחר ב־]LT',
	            nextWeek : 'dddd [בשעה] LT',
	            lastDay : '[אתמול ב־]LT',
	            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'בעוד %s',
	            past : 'לפני %s',
	            s : 'מספר שניות',
	            m : 'דקה',
	            mm : '%d דקות',
	            h : 'שעה',
	            hh : function (number) {
	                if (number === 2) {
	                    return 'שעתיים';
	                }
	                return number + ' שעות';
	            },
	            d : 'יום',
	            dd : function (number) {
	                if (number === 2) {
	                    return 'יומיים';
	                }
	                return number + ' ימים';
	            },
	            M : 'חודש',
	            MM : function (number) {
	                if (number === 2) {
	                    return 'חודשיים';
	                }
	                return number + ' חודשים';
	            },
	            y : 'שנה',
	            yy : function (number) {
	                if (number === 2) {
	                    return 'שנתיים';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' שנה';
	                }
	                return number + ' שנים';
	            }
	        }
	    });
	
	    return he;
	
	}));

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hindi (hi)
	//! author : Mayank Singhal : https://github.com/mayanksinghal
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var hi = moment.defineLocale('hi', {
	        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm बजे',
	            LTS : 'A h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[कल] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[कल] LT',
	            lastWeek : '[पिछले] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s में',
	            past : '%s पहले',
	            s : 'कुछ ही क्षण',
	            m : 'एक मिनट',
	            mm : '%d मिनट',
	            h : 'एक घंटा',
	            hh : '%d घंटे',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महीने',
	            MM : '%d महीने',
	            y : 'एक वर्ष',
	            yy : '%d वर्ष'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /रात|सुबह|दोपहर|शाम/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सुबह') {
	                return hour;
	            } else if (meridiem === 'दोपहर') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'शाम') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात';
	            } else if (hour < 10) {
	                return 'सुबह';
	            } else if (hour < 17) {
	                return 'दोपहर';
	            } else if (hour < 20) {
	                return 'शाम';
	            } else {
	                return 'रात';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hi;
	
	}));

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hrvatski (hr)
	//! author : Bojan Marković : https://github.com/bmarkovic
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }
	
	    var hr = moment.defineLocale('hr', {
	        months : 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
	        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hr;
	
	}));

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : hungarian (hu)
	//! author : Adam Brunner : https://github.com/adambrunner
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }
	
	    var hu = moment.defineLocale('hu', {
	        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s múlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hu;
	
	}));

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian (hy-am)
	//! author : Armendarabyan : https://github.com/armendarabyan
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_'),
	            'accusative': 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_');
	        return monthsShort[m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_');
	        return weekdays[m.day()];
	    }
	
	    var hy_am = moment.defineLocale('hy-am', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY թ.',
	            LLL : 'D MMMM YYYY թ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[այսօր] LT',
	            nextDay: '[վաղը] LT',
	            lastDay: '[երեկ] LT',
	            nextWeek: function () {
	                return 'dddd [օրը ժամը] LT';
	            },
	            lastWeek: function () {
	                return '[անցած] dddd [օրը ժամը] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s հետո',
	            past : '%s առաջ',
	            s : 'մի քանի վայրկյան',
	            m : 'րոպե',
	            mm : '%d րոպե',
	            h : 'ժամ',
	            hh : '%d ժամ',
	            d : 'օր',
	            dd : '%d օր',
	            M : 'ամիս',
	            MM : '%d ամիս',
	            y : 'տարի',
	            yy : '%d տարի'
	        },
	        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	        isPM: function (input) {
	            return /^(ցերեկվա|երեկոյան)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return 'գիշերվա';
	            } else if (hour < 12) {
	                return 'առավոտվա';
	            } else if (hour < 17) {
	                return 'ցերեկվա';
	            } else {
	                return 'երեկոյան';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-ին';
	                }
	                return number + '-րդ';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return hy_am;
	
	}));

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Indonesia (id)
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return id;
	
	}));

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : icelandic (is)
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	        case 'm':
	            return withoutSuffix ? 'mínúta' : 'mínútu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	            } else if (withoutSuffix) {
	                return result + 'mínúta';
	            }
	            return result + 'mínútu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dögum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mánuður';
	            }
	            return isFuture ? 'mánuð' : 'mánuði';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mánuðir';
	                }
	                return result + (isFuture ? 'mánuði' : 'mánuðum');
	            } else if (withoutSuffix) {
	                return result + 'mánuður';
	            }
	            return result + (isFuture ? 'mánuð' : 'mánuði');
	        case 'y':
	            return withoutSuffix || isFuture ? 'ár' : 'ári';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	            }
	            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	        }
	    }
	
	    var is = moment.defineLocale('is', {
	        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[í dag kl.] LT',
	            nextDay : '[á morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[í gær kl.] LT',
	            lastWeek : '[síðasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s síðan',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return is;
	
	}));

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : italian (it)
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return it;
	
	}));

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : japanese (ja)
	//! author : LI Long : https://github.com/baryon
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ja = moment.defineLocale('ja', {
	        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	        longDateFormat : {
	            LT : 'Ah時m分',
	            LTS : 'Ah時m分s秒',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY年M月D日',
	            LLL : 'YYYY年M月D日Ah時m分',
	            LLLL : 'YYYY年M月D日Ah時m分 dddd'
	        },
	        meridiemParse: /午前|午後/i,
	        isPM : function (input) {
	            return input === '午後';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '午前';
	            } else {
	                return '午後';
	            }
	        },
	        calendar : {
	            sameDay : '[今日] LT',
	            nextDay : '[明日] LT',
	            nextWeek : '[来週]dddd LT',
	            lastDay : '[昨日] LT',
	            lastWeek : '[前週]dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s後',
	            past : '%s前',
	            s : '数秒',
	            m : '1分',
	            mm : '%d分',
	            h : '1時間',
	            hh : '%d時間',
	            d : '1日',
	            dd : '%d日',
	            M : '1ヶ月',
	            MM : '%dヶ月',
	            y : '1年',
	            yy : '%d年'
	        }
	    });
	
	    return ja;
	
	}));

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Boso Jowo (jv)
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return jv;
	
	}));

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian (ka)
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	            'accusative': 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	        },
	        nounCase = (/D[oD] *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	            'accusative': 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_')
	        },
	        nounCase = (/(წინა|შემდეგ)/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }
	
	    var ka = moment.defineLocale('ka', {
	        months : monthsCaseReplace,
	        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[დღეს] LT[-ზე]',
	            nextDay : '[ხვალ] LT[-ზე]',
	            lastDay : '[გუშინ] LT[-ზე]',
	            nextWeek : '[შემდეგ] dddd LT[-ზე]',
	            lastWeek : '[წინა] dddd LT-ზე',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                    s.replace(/ი$/, 'ში') :
	                    s + 'ში';
	            },
	            past : function (s) {
	                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                    return s.replace(/(ი|ე)$/, 'ის წინ');
	                }
	                if ((/წელი/).test(s)) {
	                    return s.replace(/წელი$/, 'წლის წინ');
	                }
	            },
	            s : 'რამდენიმე წამი',
	            m : 'წუთი',
	            mm : '%d წუთი',
	            h : 'საათი',
	            hh : '%d საათი',
	            d : 'დღე',
	            dd : '%d დღე',
	            M : 'თვე',
	            MM : '%d თვე',
	            y : 'წელი',
	            yy : '%d წელი'
	        },
	        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-ლი';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return 'მე-' + number;
	            }
	            return number + '-ე';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });
	
	    return ka;
	
	}));

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : khmer (km)
	//! author : Kruy Vanna : https://github.com/kruyvanna
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var km = moment.defineLocale('km', {
	        months: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        monthsShort: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ថ្ងៃនៈ ម៉ោង] LT',
	            nextDay: '[ស្អែក ម៉ោង] LT',
	            nextWeek: 'dddd [ម៉ោង] LT',
	            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%sទៀត',
	            past: '%sមុន',
	            s: 'ប៉ុន្មានវិនាទី',
	            m: 'មួយនាទី',
	            mm: '%d នាទី',
	            h: 'មួយម៉ោង',
	            hh: '%d ម៉ោង',
	            d: 'មួយថ្ងៃ',
	            dd: '%d ថ្ងៃ',
	            M: 'មួយខែ',
	            MM: '%d ខែ',
	            y: 'មួយឆ្នាំ',
	            yy: '%d ឆ្នាំ'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return km;
	
	}));

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : korean (ko)
	//!
	//! authors
	//!
	//! - Kyungwook, Park : https://github.com/kyungw00k
	//! - Jeeeyul Lee <jeeeyul@gmail.com>
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ko = moment.defineLocale('ko', {
	        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	        longDateFormat : {
	            LT : 'A h시 m분',
	            LTS : 'A h시 m분 s초',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY년 MMMM D일',
	            LLL : 'YYYY년 MMMM D일 A h시 m분',
	            LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
	        },
	        calendar : {
	            sameDay : '오늘 LT',
	            nextDay : '내일 LT',
	            nextWeek : 'dddd LT',
	            lastDay : '어제 LT',
	            lastWeek : '지난주 dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s 후',
	            past : '%s 전',
	            s : '몇초',
	            ss : '%d초',
	            m : '일분',
	            mm : '%d분',
	            h : '한시간',
	            hh : '%d시간',
	            d : '하루',
	            dd : '%d일',
	            M : '한달',
	            MM : '%d달',
	            y : '일년',
	            yy : '%d년'
	        },
	        ordinalParse : /\d{1,2}일/,
	        ordinal : '%d일',
	        meridiemParse : /오전|오후/,
	        isPM : function (token) {
	            return token === '오후';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '오전' : '오후';
	        }
	    });
	
	    return ko;
	
	}));

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish (lb)
	//! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }
	
	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gëschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Méint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lb;
	
	}));

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian (lt)
	//! author : Mindaugas Mozūras : https://github.com/mmozuras
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm' : 'minutė_minutės_minutę',
	        'mm': 'minutės_minučių_minutes',
	        'h' : 'valanda_valandos_valandą',
	        'hh': 'valandos_valandų_valandas',
	        'd' : 'diena_dienos_dieną',
	        'dd': 'dienos_dienų_dienas',
	        'M' : 'mėnuo_mėnesio_mėnesį',
	        'MM': 'mėnesiai_mėnesių_mėnesius',
	        'y' : 'metai_metų_metus',
	        'yy': 'metai_metų_metus'
	    },
	    weekDays = 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_');
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekundės';
	        } else {
	            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	                'nominative': 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
	                'accusative': 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_')
	            },
	            nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	                'accusative' :
	                'nominative';
	        return months[nounCase][m.month()];
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    function relativeWeekDay(moment, format) {
	        var nominative = format.indexOf('dddd HH:mm') === -1,
	            weekDay = weekDays[moment.day()];
	        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + 'į';
	    }
	
	    var lt = moment.defineLocale('lt', {
	        months : monthsCaseReplace,
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : relativeWeekDay,
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[Šiandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Praėjusį] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prieš %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lt;
	
	}));

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : latvian (lv)
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var units = {
	        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	        'h': 'stundas_stundām_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	        'd': 'dienas_dienām_diena_dienas'.split('_'),
	        'dd': 'dienas_dienām_diena_dienas'.split('_'),
	        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minūte", "3 minūtes".
	            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 minūtes" as in "pēc 21 minūtes".
	            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	    }
	
	    var lv = moment.defineLocale('lv', {
	        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[Šodien pulksten] LT',
	            nextDay : '[Rīt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagājušā] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pēc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return lv;
	
	}));

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin (me)
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var me = moment.defineLocale('me', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'četvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'čet.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',
	
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedjelje] [u] LT',
	                    '[prošlog] [ponedjeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srijede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return me;
	
	}));

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : macedonian (mk)
	//! author : Borislav Mickov : https://github.com/B0k0
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var mk = moment.defineLocale('mk', {
	        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[Денес во] LT',
	            nextDay : '[Утре во] LT',
	            nextWeek : 'dddd [во] LT',
	            lastDay : '[Вчера во] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[Во изминатата] dddd [во] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[Во изминатиот] dddd [во] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'после %s',
	            past : 'пред %s',
	            s : 'неколку секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дена',
	            M : 'месец',
	            MM : '%d месеци',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mk;
	
	}));

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : malayalam (ml)
	//! author : Floyd Pink : https://github.com/floydpink
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ml = moment.defineLocale('ml', {
	        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -നു',
	            LTS : 'A h:mm:ss -നു',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -നു',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	        },
	        calendar : {
	            sameDay : '[ഇന്ന്] LT',
	            nextDay : '[നാളെ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ഇന്നലെ] LT',
	            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s കഴിഞ്ഞ്',
	            past : '%s മുൻപ്',
	            s : 'അൽപ നിമിഷങ്ങൾ',
	            m : 'ഒരു മിനിറ്റ്',
	            mm : '%d മിനിറ്റ്',
	            h : 'ഒരു മണിക്കൂർ',
	            hh : '%d മണിക്കൂർ',
	            d : 'ഒരു ദിവസം',
	            dd : '%d ദിവസം',
	            M : 'ഒരു മാസം',
	            MM : '%d മാസം',
	            y : 'ഒരു വർഷം',
	            yy : '%d വർഷം'
	        },
	        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	        isPM : function (input) {
	            return /^(ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'രാത്രി';
	            } else if (hour < 12) {
	                return 'രാവിലെ';
	            } else if (hour < 17) {
	                return 'ഉച്ച കഴിഞ്ഞ്';
	            } else if (hour < 20) {
	                return 'വൈകുന്നേരം';
	            } else {
	                return 'രാത്രി';
	            }
	        }
	    });
	
	    return ml;
	
	}));

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi (mr)
	//! author : Harshad Kale : https://github.com/kalehv
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var mr = moment.defineLocale('mr', {
	        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm वाजता',
	            LTS : 'A h:mm:ss वाजता',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm वाजता',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[उद्या] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[काल] LT',
	            lastWeek: '[मागील] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s नंतर',
	            past : '%s पूर्वी',
	            s : 'सेकंद',
	            m: 'एक मिनिट',
	            mm: '%d मिनिटे',
	            h : 'एक तास',
	            hh : '%d तास',
	            d : 'एक दिवस',
	            dd : '%d दिवस',
	            M : 'एक महिना',
	            MM : '%d महिने',
	            y : 'एक वर्ष',
	            yy : '%d वर्षे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात्री') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सकाळी') {
	                return hour;
	            } else if (meridiem === 'दुपारी') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'सायंकाळी') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात्री';
	            } else if (hour < 10) {
	                return 'सकाळी';
	            } else if (hour < 17) {
	                return 'दुपारी';
	            } else if (hour < 20) {
	                return 'सायंकाळी';
	            } else {
	                return 'रात्री';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return mr;
	
	}));

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms;
	
	}));

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bahasa Malaysia (ms-MY)
	//! author : Weldan Jamili : https://github.com/weldan
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ms_my;
	
	}));

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese (my)
	//! author : Squar team, mysquar.com
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '၁',
	        '2': '၂',
	        '3': '၃',
	        '4': '၄',
	        '5': '၅',
	        '6': '၆',
	        '7': '၇',
	        '8': '၈',
	        '9': '၉',
	        '0': '၀'
	    }, numberMap = {
	        '၁': '1',
	        '၂': '2',
	        '၃': '3',
	        '၄': '4',
	        '၅': '5',
	        '၆': '6',
	        '၇': '7',
	        '၈': '8',
	        '၉': '9',
	        '၀': '0'
	    };
	
	    var my = moment.defineLocale('my', {
	        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ယနေ.] LT [မှာ]',
	            nextDay: '[မနက်ဖြန်] LT [မှာ]',
	            nextWeek: 'dddd LT [မှာ]',
	            lastDay: '[မနေ.က] LT [မှာ]',
	            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'လာမည့် %s မှာ',
	            past: 'လွန်ခဲ့သော %s က',
	            s: 'စက္ကန်.အနည်းငယ်',
	            m: 'တစ်မိနစ်',
	            mm: '%d မိနစ်',
	            h: 'တစ်နာရီ',
	            hh: '%d နာရီ',
	            d: 'တစ်ရက်',
	            dd: '%d ရက်',
	            M: 'တစ်လ',
	            MM: '%d လ',
	            y: 'တစ်နှစ်',
	            yy: '%d နှစ်'
	        },
	        preparse: function (string) {
	            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return my;
	
	}));

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian bokmål (nb)
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tirs_ons_tors_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'H.mm',
	            LTS : 'H.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H.mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] H.mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i går kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nb;
	
	}));

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : nepali/nepalese
	//! author : suvash : https://github.com/suvash
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };
	
	    var ne = moment.defineLocale('ne', {
	        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	        weekdaysMin : 'आइ._सो._मङ्_बु._बि._शु._श.'.split('_'),
	        longDateFormat : {
	            LT : 'Aको h:mm बजे',
	            LTS : 'Aको h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, Aको h:mm बजे',
	            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /राती|बिहान|दिउँसो|बेलुका|साँझ|राती/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'राती') {
	                return hour < 3 ? hour : hour + 12;
	            } else if (meridiem === 'बिहान') {
	                return hour;
	            } else if (meridiem === 'दिउँसो') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'बेलुका' || meridiem === 'साँझ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return 'राती';
	            } else if (hour < 10) {
	                return 'बिहान';
	            } else if (hour < 15) {
	                return 'दिउँसो';
	            } else if (hour < 18) {
	                return 'बेलुका';
	            } else if (hour < 20) {
	                return 'साँझ';
	            } else {
	                return 'राती';
	            }
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[भोली] LT',
	            nextWeek : '[आउँदो] dddd[,] LT',
	            lastDay : '[हिजो] LT',
	            lastWeek : '[गएको] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sमा',
	            past : '%s अगाडी',
	            s : 'केही समय',
	            m : 'एक मिनेट',
	            mm : '%d मिनेट',
	            h : 'एक घण्टा',
	            hh : '%d घण्टा',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महिना',
	            MM : '%d महिना',
	            y : 'एक बर्ष',
	            yy : '%d बर्ष'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ne;
	
	}));

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : dutch (nl)
	//! author : Joris Röling : https://github.com/jjupiter
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'één minuut',
	            mm : '%d minuten',
	            h : 'één uur',
	            hh : '%d uur',
	            d : 'één dag',
	            dd : '%d dagen',
	            M : 'één maand',
	            MM : '%d maanden',
	            y : 'één jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nl;
	
	}));

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : norwegian nynorsk (nn)
	//! author : https://github.com/mechuwind
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I går klokka] LT',
	            lastWeek: '[Føregåande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein månad',
	            MM : '%d månader',
	            y : 'eit år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return nn;
	
	}));

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : polish (pl)
	//! author : Rafal Hirsz : https://github.com/evoL
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minutę';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzinę';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesiące' : 'miesięcy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }
	
	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
	        weekdaysMin : 'N_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dziś o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[W zeszłą niedzielę o] LT';
	                case 3:
	                    return '[W zeszłą środę o] LT';
	                case 6:
	                    return '[W zeszłą sobotę o] LT';
	                default:
	                    return '[W zeszły] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzień',
	            dd : '%d dni',
	            M : 'miesiąc',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pl;
	
	}));

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : portuguese (pt)
	//! author : Jefferson : https://github.com/jalex79
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'há %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return pt;
	
	}));

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : brazilian portuguese (pt-br)
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	        weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrás',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº'
	    });
	
	    return pt_br;
	
	}));

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : romanian (ro)
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }
	
	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mâine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s în urmă',
	            s : 'câteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o oră',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lună',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ro;
	
	}));

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : russian (ru)
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	            'hh': 'час_часа_часов',
	            'dd': 'день_дня_дней',
	            'MM': 'месяц_месяца_месяцев',
	            'yy': 'год_года_лет'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'минута' : 'минуту';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	            'accusative': 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = {
	            'nominative': 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	            'accusative': 'янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек'.split('_')
	        },
	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return monthsShort[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	            'accusative': 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_')
	        },
	        nounCase = (/\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';
	        return weekdays[nounCase][m.day()];
	    }
	
	    var ru = moment.defineLocale('ru', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        monthsParse : [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i],
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	        },
	        calendar : {
	            sameDay: '[Сегодня в] LT',
	            nextDay: '[Завтра в] LT',
	            lastDay: '[Вчера в] LT',
	            nextWeek: function () {
	                return this.day() === 2 ? '[Во] dddd [в] LT' : '[В] dddd [в] LT';
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[В прошлое] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В прошлый] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В прошлую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'через %s',
	            past : '%s назад',
	            s : 'несколько секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'час',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночи|утра|дня|вечера/i,
	        isPM : function (input) {
	            return /^(дня|вечера)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночи';
	            } else if (hour < 12) {
	                return 'утра';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечера';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го|я)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            case 'w':
	            case 'W':
	                return number + '-я';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ru;
	
	}));

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese (si)
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var si = moment.defineLocale('si', {
	        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[අද] LT[ට]',
	            nextDay : '[හෙට] LT[ට]',
	            nextWeek : 'dddd LT[ට]',
	            lastDay : '[ඊයේ] LT[ට]',
	            lastWeek : '[පසුගිය] dddd LT[ට]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sකින්',
	            past : '%sකට පෙර',
	            s : 'තත්පර කිහිපය',
	            m : 'මිනිත්තුව',
	            mm : 'මිනිත්තු %d',
	            h : 'පැය',
	            hh : 'පැය %d',
	            d : 'දිනය',
	            dd : 'දින %d',
	            M : 'මාසය',
	            MM : 'මාස %d',
	            y : 'වසර',
	            yy : 'වසර %d'
	        },
	        ordinalParse: /\d{1,2} වැනි/,
	        ordinal : function (number) {
	            return number + ' වැනි';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'ප.ව.' : 'පස් වරු';
	            } else {
	                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	            }
	        }
	    });
	
	    return si;
	
	}));

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovak (sk)
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minúty' : 'minút');
	            } else {
	                return result + 'minútami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodín');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dní');
	            } else {
	                return result + 'dňami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	        }
	    }
	
	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo štvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[včera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulú nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[minulý] dddd [o] LT';
	                case 3:
	                    return '[minulú stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [o] LT';
	                case 6:
	                    return '[minulú sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sk;
	
	}));

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : slovenian (sl)
	//! author : Robert Sedovšek : https://github.com/sedovsek
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	        }
	    }
	
	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',
	
	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[včeraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[prejšnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejšnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejšnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejšnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'čez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sl;
	
	}));

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian (sq)
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author: Menelion Elensúle: https://github.com/Oire (tests)
	//! author : Oerd Cukalla : https://github.com/oerd (fixes)
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot në] LT',
	            nextDay : '[Nesër në] LT',
	            nextWeek : 'dddd [në] LT',
	            lastDay : '[Dje në] LT',
	            lastWeek : 'dddd [e kaluar në] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'në %s',
	            past : '%s më parë',
	            s : 'disa sekonda',
	            m : 'një minutë',
	            mm : '%d minuta',
	            h : 'një orë',
	            hh : '%d orë',
	            d : 'një ditë',
	            dd : '%d ditë',
	            M : 'një muaj',
	            MM : '%d muaj',
	            y : 'një vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sq;
	
	}));

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-latin (sr)
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr = moment.defineLocale('sr', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'četvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'čet.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedelje] [u] LT',
	                    '[prošlog] [ponedeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr;
	
	}));

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian-cyrillic (sr-cyrl)
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['један минут', 'једне минуте'],
	            mm: ['минут', 'минуте', 'минута'],
	            h: ['један сат', 'једног сата'],
	            hh: ['сат', 'сата', 'сати'],
	            dd: ['дан', 'дана', 'дана'],
	            MM: ['месец', 'месеца', 'месеци'],
	            yy: ['година', 'године', 'година']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };
	
	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: ['јануар', 'фебруар', 'март', 'април', 'мај', 'јун', 'јул', 'август', 'септембар', 'октобар', 'новембар', 'децембар'],
	        monthsShort: ['јан.', 'феб.', 'мар.', 'апр.', 'мај', 'јун', 'јул', 'авг.', 'сеп.', 'окт.', 'нов.', 'дец.'],
	        weekdays: ['недеља', 'понедељак', 'уторак', 'среда', 'четвртак', 'петак', 'субота'],
	        weekdaysShort: ['нед.', 'пон.', 'уто.', 'сре.', 'чет.', 'пет.', 'суб.'],
	        weekdaysMin: ['не', 'по', 'ут', 'ср', 'че', 'пе', 'су'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[данас у] LT',
	            nextDay: '[сутра у] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[у] [недељу] [у] LT';
	                case 3:
	                    return '[у] [среду] [у] LT';
	                case 6:
	                    return '[у] [суботу] [у] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[у] dddd [у] LT';
	                }
	            },
	            lastDay  : '[јуче у] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[прошле] [недеље] [у] LT',
	                    '[прошлог] [понедељка] [у] LT',
	                    '[прошлог] [уторка] [у] LT',
	                    '[прошле] [среде] [у] LT',
	                    '[прошлог] [четвртка] [у] LT',
	                    '[прошлог] [петка] [у] LT',
	                    '[прошле] [суботе] [у] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past   : 'пре %s',
	            s      : 'неколико секунди',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'дан',
	            dd     : translator.translate,
	            M      : 'месец',
	            MM     : translator.translate,
	            y      : 'годину',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return sr_cyrl;
	
	}));

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : swedish (sv)
	//! author : Jens Alm : https://github.com/ulmus
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igår] LT',
	            nextWeek: '[På] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'för %s sedan',
	            s : 'några sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en månad',
	            MM : '%d månader',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return sv;
	
	}));

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : tamil (ta)
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var ta = moment.defineLocale('ta', {
	        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[இன்று] LT',
	            nextDay : '[நாளை] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[நேற்று] LT',
	            lastWeek : '[கடந்த வாரம்] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s இல்',
	            past : '%s முன்',
	            s : 'ஒரு சில விநாடிகள்',
	            m : 'ஒரு நிமிடம்',
	            mm : '%d நிமிடங்கள்',
	            h : 'ஒரு மணி நேரம்',
	            hh : '%d மணி நேரம்',
	            d : 'ஒரு நாள்',
	            dd : '%d நாட்கள்',
	            M : 'ஒரு மாதம்',
	            MM : '%d மாதங்கள்',
	            y : 'ஒரு வருடம்',
	            yy : '%d ஆண்டுகள்'
	        },
	        ordinalParse: /\d{1,2}வது/,
	        ordinal : function (number) {
	            return number + 'வது';
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' யாமம்';
	            } else if (hour < 6) {
	                return ' வைகறை';  // வைகறை
	            } else if (hour < 10) {
	                return ' காலை'; // காலை
	            } else if (hour < 14) {
	                return ' நண்பகல்'; // நண்பகல்
	            } else if (hour < 18) {
	                return ' எற்பாடு'; // எற்பாடு
	            } else if (hour < 22) {
	                return ' மாலை'; // மாலை
	            } else {
	                return ' யாமம்';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'யாமம்') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	                return hour;
	            } else if (meridiem === 'நண்பகல்') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return ta;
	
	}));

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : thai (th)
	//! author : Kridsada Thanabulpong : https://github.com/sirn
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var th = moment.defineLocale('th', {
	        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	        monthsShort : 'มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา'.split('_'),
	        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	        longDateFormat : {
	            LT : 'H นาฬิกา m นาที',
	            LTS : 'H นาฬิกา m นาที s วินาที',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY เวลา H นาฬิกา m นาที',
	            LLLL : 'วันddddที่ D MMMM YYYY เวลา H นาฬิกา m นาที'
	        },
	        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	        isPM: function (input) {
	            return input === 'หลังเที่ยง';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ก่อนเที่ยง';
	            } else {
	                return 'หลังเที่ยง';
	            }
	        },
	        calendar : {
	            sameDay : '[วันนี้ เวลา] LT',
	            nextDay : '[พรุ่งนี้ เวลา] LT',
	            nextWeek : 'dddd[หน้า เวลา] LT',
	            lastDay : '[เมื่อวานนี้ เวลา] LT',
	            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'อีก %s',
	            past : '%sที่แล้ว',
	            s : 'ไม่กี่วินาที',
	            m : '1 นาที',
	            mm : '%d นาที',
	            h : '1 ชั่วโมง',
	            hh : '%d ชั่วโมง',
	            d : '1 วัน',
	            dd : '%d วัน',
	            M : '1 เดือน',
	            MM : '%d เดือน',
	            y : '1 ปี',
	            yy : '%d ปี'
	        }
	    });
	
	    return th;
	
	}));

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog/Filipino (tl-ph)
	//! author : Dan Hagman
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return tl_ph;
	
	}));

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : turkish (tr)
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'üncü',
	        4: '\'üncü',
	        100: '\'üncü',
	        6: '\'ncı',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'ıncı',
	        90: '\'ıncı'
	    };
	
	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[yarın saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dün] LT',
	            lastWeek : '[geçen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s önce',
	            s : 'birkaç saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yıl',
	            yy : '%d yıl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tr;
	
	}));

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : talossan (tzl)
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iustì Canun
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	
	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY LT',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY LT'
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi à] LT',
	            nextDay : '[demà à] LT',
	            nextWeek : 'dddd [à] LT',
	            lastDay : '[ieiri à] LT',
	            lastWeek : '[sür el] dddd [lasteu à] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n míut', '\'iens míut'],
	            'mm': [number + ' míuts', ' ' + number + ' míuts'],
	            'h': ['\'n þora', '\'iensa þora'],
	            'hh': [number + ' þoras', ' ' + number + ' þoras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', ' ' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', ' ' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', ' ' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1].trim());
	    }
	
	    return tzl;
	
	}));

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamaziɣt (tzm)
	//! author : Abdel Said : https://github.com/abdelsaid
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm = moment.defineLocale('tzm', {
	        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	            nextWeek: 'dddd [ⴴ] LT',
	            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	            lastWeek: 'dddd [ⴴ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	            past : 'ⵢⴰⵏ %s',
	            s : 'ⵉⵎⵉⴽ',
	            m : 'ⵎⵉⵏⵓⴺ',
	            mm : '%d ⵎⵉⵏⵓⴺ',
	            h : 'ⵙⴰⵄⴰ',
	            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	            d : 'ⴰⵙⵙ',
	            dd : '%d oⵙⵙⴰⵏ',
	            M : 'ⴰⵢoⵓⵔ',
	            MM : '%d ⵉⵢⵢⵉⵔⵏ',
	            y : 'ⴰⵙⴳⴰⵙ',
	            yy : '%d ⵉⵙⴳⴰⵙⵏ'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm;
	
	}));

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Morocco Central Atlas Tamaziɣt in Latin (tzm-latn)
	//! author : Abdel Said : https://github.com/abdelsaid
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minuḍ',
	            mm : '%d minuḍ',
	            h : 'saɛa',
	            hh : '%d tassaɛin',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return tzm_latn;
	
	}));

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : ukrainian (uk)
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'хвилина_хвилини_хвилин',
	            'hh': 'година_години_годин',
	            'dd': 'день_дні_днів',
	            'MM': 'місяць_місяці_місяців',
	            'yy': 'рік_роки_років'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвилина' : 'хвилину';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'година' : 'годину';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_'),
	            'accusative': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_')
	        },
	        nounCase = (/D[oD]? *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';
	        return months[nounCase][m.month()];
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	        },
	        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	        };
	    }
	
	    var uk = moment.defineLocale('uk', {
	        months : monthsCaseReplace,
	        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY р.',
	            LLL : 'D MMMM YYYY р., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[Сьогодні '),
	            nextDay: processHoursFunction('[Завтра '),
	            lastDay: processHoursFunction('[Вчора '),
	            nextWeek: processHoursFunction('[У] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[Минулої] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[Минулого] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past : '%s тому',
	            s : 'декілька секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'годину',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'місяць',
	            MM : relativeTimeWithPlural,
	            y : 'рік',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /ночі|ранку|дня|вечора/,
	        isPM: function (input) {
	            return /^(дня|вечора)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночі';
	            } else if (hour < 12) {
	                return 'ранку';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечора';
	            }
	        },
	        ordinalParse: /\d{1,2}-(й|го)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            default:
	                return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	
	    return uk;
	
	}));

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : uzbek (uz)
	//! author : Sardor Muminov : https://github.com/muminoff
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var uz = moment.defineLocale('uz', {
	        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[Бугун соат] LT [да]',
	            nextDay : '[Эртага] LT [да]',
	            nextWeek : 'dddd [куни соат] LT [да]',
	            lastDay : '[Кеча соат] LT [да]',
	            lastWeek : '[Утган] dddd [куни соат] LT [да]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'Якин %s ичида',
	            past : 'Бир неча %s олдин',
	            s : 'фурсат',
	            m : 'бир дакика',
	            mm : '%d дакика',
	            h : 'бир соат',
	            hh : '%d соат',
	            d : 'бир кун',
	            dd : '%d кун',
	            M : 'бир ой',
	            MM : '%d ой',
	            y : 'бир йил',
	            yy : '%d йил'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return uz;
	
	}));

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : vietnamese (vi)
	//! author : Bang Nguyen : https://github.com/bangnk
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var vi = moment.defineLocale('vi', {
	        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [năm] YYYY',
	            LLL : 'D MMMM [năm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hôm nay lúc] LT',
	            nextDay: '[Ngày mai lúc] LT',
	            nextWeek: 'dddd [tuần tới lúc] LT',
	            lastDay: '[Hôm qua lúc] LT',
	            lastWeek: 'dddd [tuần rồi lúc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s tới',
	            past : '%s trước',
	            s : 'vài giây',
	            m : 'một phút',
	            mm : '%d phút',
	            h : 'một giờ',
	            hh : '%d giờ',
	            d : 'một ngày',
	            dd : '%d ngày',
	            M : 'một tháng',
	            MM : '%d tháng',
	            y : 'một năm',
	            yy : '%d năm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return vi;
	
	}));

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : chinese (zh-cn)
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah点mm分',
	            LTS : 'Ah点m分s秒',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah点mm分',
	            LLLL : 'YYYY年MMMD日ddddAh点mm分',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah点mm分',
	            llll : 'YYYY年MMMD日ddddAh点mm分'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' ||
	                    meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            } else {
	                // '中午'
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(日|月|周)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            case 'M':
	                return number + '月';
	            case 'w':
	            case 'W':
	                return number + '周';
	            default:
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s内',
	            past : '%s前',
	            s : '几秒',
	            m : '1 分钟',
	            mm : '%d 分钟',
	            h : '1 小时',
	            hh : '%d 小时',
	            d : '1 天',
	            dd : '%d 天',
	            M : '1 个月',
	            MM : '%d 个月',
	            y : '1 年',
	            yy : '%d 年'
	        },
	        week : {
	            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	
	    return zh_cn;
	
	}));

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : traditional chinese (zh-tw)
	//! author : Ben : https://github.com/ben-lin
	
	(function (global, factory) {
	    true ? factory(__webpack_require__(209)) :
	   typeof define === 'function' && define.amd ? define(['moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';
	
	
	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm分',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日Ah點mm分',
	            LLLL : 'YYYY年MMMD日ddddAh點mm分',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日Ah點mm分',
	            llll : 'YYYY年MMMD日ddddAh點mm分'
	        },
	        meridiemParse: /早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '一分鐘',
	            mm : '%d分鐘',
	            h : '一小時',
	            hh : '%d小時',
	            d : '一天',
	            dd : '%d天',
	            M : '一個月',
	            MM : '%d個月',
	            y : '一年',
	            yy : '%d年'
	        }
	    });
	
	    return zh_tw;
	
	}));

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
	 * Bootstrap v3.3.6 (http://getbootstrap.com)
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under the MIT license
	 */
	
	if (typeof jQuery === 'undefined') {
	  throw new Error('Bootstrap\'s JavaScript requires jQuery')
	}
	
	+function ($) {
	  'use strict';
	  var version = $.fn.jquery.split(' ')[0].split('.')
	  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
	    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')
	  }
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: transition.js v3.3.6
	 * http://getbootstrap.com/javascript/#transitions
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
	  // ============================================================
	
	  function transitionEnd() {
	    var el = document.createElement('bootstrap')
	
	    var transEndEventNames = {
	      WebkitTransition : 'webkitTransitionEnd',
	      MozTransition    : 'transitionend',
	      OTransition      : 'oTransitionEnd otransitionend',
	      transition       : 'transitionend'
	    }
	
	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return { end: transEndEventNames[name] }
	      }
	    }
	
	    return false // explicit for ie8 (  ._.)
	  }
	
	  // http://blog.alexmaccaw.com/css-transitions
	  $.fn.emulateTransitionEnd = function (duration) {
	    var called = false
	    var $el = this
	    $(this).one('bsTransitionEnd', function () { called = true })
	    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	    setTimeout(callback, duration)
	    return this
	  }
	
	  $(function () {
	    $.support.transition = transitionEnd()
	
	    if (!$.support.transition) return
	
	    $.event.special.bsTransitionEnd = {
	      bindType: $.support.transition.end,
	      delegateType: $.support.transition.end,
	      handle: function (e) {
	        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
	      }
	    }
	  })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: alert.js v3.3.6
	 * http://getbootstrap.com/javascript/#alerts
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // ALERT CLASS DEFINITION
	  // ======================
	
	  var dismiss = '[data-dismiss="alert"]'
	  var Alert   = function (el) {
	    $(el).on('click', dismiss, this.close)
	  }
	
	  Alert.VERSION = '3.3.6'
	
	  Alert.TRANSITION_DURATION = 150
	
	  Alert.prototype.close = function (e) {
	    var $this    = $(this)
	    var selector = $this.attr('data-target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    var $parent = $(selector)
	
	    if (e) e.preventDefault()
	
	    if (!$parent.length) {
	      $parent = $this.closest('.alert')
	    }
	
	    $parent.trigger(e = $.Event('close.bs.alert'))
	
	    if (e.isDefaultPrevented()) return
	
	    $parent.removeClass('in')
	
	    function removeElement() {
	      // detach from parent, fire event then clean up data
	      $parent.detach().trigger('closed.bs.alert').remove()
	    }
	
	    $.support.transition && $parent.hasClass('fade') ?
	      $parent
	        .one('bsTransitionEnd', removeElement)
	        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	      removeElement()
	  }
	
	
	  // ALERT PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.alert')
	
	      if (!data) $this.data('bs.alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  var old = $.fn.alert
	
	  $.fn.alert             = Plugin
	  $.fn.alert.Constructor = Alert
	
	
	  // ALERT NO CONFLICT
	  // =================
	
	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }
	
	
	  // ALERT DATA-API
	  // ==============
	
	  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: button.js v3.3.6
	 * http://getbootstrap.com/javascript/#buttons
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // BUTTON PUBLIC CLASS DEFINITION
	  // ==============================
	
	  var Button = function (element, options) {
	    this.$element  = $(element)
	    this.options   = $.extend({}, Button.DEFAULTS, options)
	    this.isLoading = false
	  }
	
	  Button.VERSION  = '3.3.6'
	
	  Button.DEFAULTS = {
	    loadingText: 'loading...'
	  }
	
	  Button.prototype.setState = function (state) {
	    var d    = 'disabled'
	    var $el  = this.$element
	    var val  = $el.is('input') ? 'val' : 'html'
	    var data = $el.data()
	
	    state += 'Text'
	
	    if (data.resetText == null) $el.data('resetText', $el[val]())
	
	    // push to event loop to allow forms to submit
	    setTimeout($.proxy(function () {
	      $el[val](data[state] == null ? this.options[state] : data[state])
	
	      if (state == 'loadingText') {
	        this.isLoading = true
	        $el.addClass(d).attr(d, d)
	      } else if (this.isLoading) {
	        this.isLoading = false
	        $el.removeClass(d).removeAttr(d)
	      }
	    }, this), 0)
	  }
	
	  Button.prototype.toggle = function () {
	    var changed = true
	    var $parent = this.$element.closest('[data-toggle="buttons"]')
	
	    if ($parent.length) {
	      var $input = this.$element.find('input')
	      if ($input.prop('type') == 'radio') {
	        if ($input.prop('checked')) changed = false
	        $parent.find('.active').removeClass('active')
	        this.$element.addClass('active')
	      } else if ($input.prop('type') == 'checkbox') {
	        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
	        this.$element.toggleClass('active')
	      }
	      $input.prop('checked', this.$element.hasClass('active'))
	      if (changed) $input.trigger('change')
	    } else {
	      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
	      this.$element.toggleClass('active')
	    }
	  }
	
	
	  // BUTTON PLUGIN DEFINITION
	  // ========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.button')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.button', (data = new Button(this, options)))
	
	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }
	
	  var old = $.fn.button
	
	  $.fn.button             = Plugin
	  $.fn.button.Constructor = Button
	
	
	  // BUTTON NO CONFLICT
	  // ==================
	
	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }
	
	
	  // BUTTON DATA-API
	  // ===============
	
	  $(document)
	    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      var $btn = $(e.target)
	      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	      Plugin.call($btn, 'toggle')
	      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
	    })
	    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
	    })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: carousel.js v3.3.6
	 * http://getbootstrap.com/javascript/#carousel
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // CAROUSEL CLASS DEFINITION
	  // =========================
	
	  var Carousel = function (element, options) {
	    this.$element    = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options     = options
	    this.paused      = null
	    this.sliding     = null
	    this.interval    = null
	    this.$active     = null
	    this.$items      = null
	
	    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
	
	    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
	      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
	      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
	  }
	
	  Carousel.VERSION  = '3.3.6'
	
	  Carousel.TRANSITION_DURATION = 600
	
	  Carousel.DEFAULTS = {
	    interval: 5000,
	    pause: 'hover',
	    wrap: true,
	    keyboard: true
	  }
	
	  Carousel.prototype.keydown = function (e) {
	    if (/input|textarea/i.test(e.target.tagName)) return
	    switch (e.which) {
	      case 37: this.prev(); break
	      case 39: this.next(); break
	      default: return
	    }
	
	    e.preventDefault()
	  }
	
	  Carousel.prototype.cycle = function (e) {
	    e || (this.paused = false)
	
	    this.interval && clearInterval(this.interval)
	
	    this.options.interval
	      && !this.paused
	      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
	
	    return this
	  }
	
	  Carousel.prototype.getItemIndex = function (item) {
	    this.$items = item.parent().children('.item')
	    return this.$items.index(item || this.$active)
	  }
	
	  Carousel.prototype.getItemForDirection = function (direction, active) {
	    var activeIndex = this.getItemIndex(active)
	    var willWrap = (direction == 'prev' && activeIndex === 0)
	                || (direction == 'next' && activeIndex == (this.$items.length - 1))
	    if (willWrap && !this.options.wrap) return active
	    var delta = direction == 'prev' ? -1 : 1
	    var itemIndex = (activeIndex + delta) % this.$items.length
	    return this.$items.eq(itemIndex)
	  }
	
	  Carousel.prototype.to = function (pos) {
	    var that        = this
	    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
	
	    if (pos > (this.$items.length - 1) || pos < 0) return
	
	    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
	    if (activeIndex == pos) return this.pause().cycle()
	
	    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
	  }
	
	  Carousel.prototype.pause = function (e) {
	    e || (this.paused = true)
	
	    if (this.$element.find('.next, .prev').length && $.support.transition) {
	      this.$element.trigger($.support.transition.end)
	      this.cycle(true)
	    }
	
	    this.interval = clearInterval(this.interval)
	
	    return this
	  }
	
	  Carousel.prototype.next = function () {
	    if (this.sliding) return
	    return this.slide('next')
	  }
	
	  Carousel.prototype.prev = function () {
	    if (this.sliding) return
	    return this.slide('prev')
	  }
	
	  Carousel.prototype.slide = function (type, next) {
	    var $active   = this.$element.find('.item.active')
	    var $next     = next || this.getItemForDirection(type, $active)
	    var isCycling = this.interval
	    var direction = type == 'next' ? 'left' : 'right'
	    var that      = this
	
	    if ($next.hasClass('active')) return (this.sliding = false)
	
	    var relatedTarget = $next[0]
	    var slideEvent = $.Event('slide.bs.carousel', {
	      relatedTarget: relatedTarget,
	      direction: direction
	    })
	    this.$element.trigger(slideEvent)
	    if (slideEvent.isDefaultPrevented()) return
	
	    this.sliding = true
	
	    isCycling && this.pause()
	
	    if (this.$indicators.length) {
	      this.$indicators.find('.active').removeClass('active')
	      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
	      $nextIndicator && $nextIndicator.addClass('active')
	    }
	
	    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
	    if ($.support.transition && this.$element.hasClass('slide')) {
	      $next.addClass(type)
	      $next[0].offsetWidth // force reflow
	      $active.addClass(direction)
	      $next.addClass(direction)
	      $active
	        .one('bsTransitionEnd', function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () {
	            that.$element.trigger(slidEvent)
	          }, 0)
	        })
	        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
	    } else {
	      $active.removeClass('active')
	      $next.addClass('active')
	      this.sliding = false
	      this.$element.trigger(slidEvent)
	    }
	
	    isCycling && this.cycle()
	
	    return this
	  }
	
	
	  // CAROUSEL PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.carousel')
	      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var action  = typeof option == 'string' ? option : options.slide
	
	      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }
	
	  var old = $.fn.carousel
	
	  $.fn.carousel             = Plugin
	  $.fn.carousel.Constructor = Carousel
	
	
	  // CAROUSEL NO CONFLICT
	  // ====================
	
	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }
	
	
	  // CAROUSEL DATA-API
	  // =================
	
	  var clickHandler = function (e) {
	    var href
	    var $this   = $(this)
	    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
	    if (!$target.hasClass('carousel')) return
	    var options = $.extend({}, $target.data(), $this.data())
	    var slideIndex = $this.attr('data-slide-to')
	    if (slideIndex) options.interval = false
	
	    Plugin.call($target, options)
	
	    if (slideIndex) {
	      $target.data('bs.carousel').to(slideIndex)
	    }
	
	    e.preventDefault()
	  }
	
	  $(document)
	    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
	    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
	
	  $(window).on('load', function () {
	    $('[data-ride="carousel"]').each(function () {
	      var $carousel = $(this)
	      Plugin.call($carousel, $carousel.data())
	    })
	  })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: collapse.js v3.3.6
	 * http://getbootstrap.com/javascript/#collapse
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // COLLAPSE PUBLIC CLASS DEFINITION
	  // ================================
	
	  var Collapse = function (element, options) {
	    this.$element      = $(element)
	    this.options       = $.extend({}, Collapse.DEFAULTS, options)
	    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
	                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
	    this.transitioning = null
	
	    if (this.options.parent) {
	      this.$parent = this.getParent()
	    } else {
	      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
	    }
	
	    if (this.options.toggle) this.toggle()
	  }
	
	  Collapse.VERSION  = '3.3.6'
	
	  Collapse.TRANSITION_DURATION = 350
	
	  Collapse.DEFAULTS = {
	    toggle: true
	  }
	
	  Collapse.prototype.dimension = function () {
	    var hasWidth = this.$element.hasClass('width')
	    return hasWidth ? 'width' : 'height'
	  }
	
	  Collapse.prototype.show = function () {
	    if (this.transitioning || this.$element.hasClass('in')) return
	
	    var activesData
	    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
	
	    if (actives && actives.length) {
	      activesData = actives.data('bs.collapse')
	      if (activesData && activesData.transitioning) return
	    }
	
	    var startEvent = $.Event('show.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return
	
	    if (actives && actives.length) {
	      Plugin.call(actives, 'hide')
	      activesData || actives.data('bs.collapse', null)
	    }
	
	    var dimension = this.dimension()
	
	    this.$element
	      .removeClass('collapse')
	      .addClass('collapsing')[dimension](0)
	      .attr('aria-expanded', true)
	
	    this.$trigger
	      .removeClass('collapsed')
	      .attr('aria-expanded', true)
	
	    this.transitioning = 1
	
	    var complete = function () {
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse in')[dimension]('')
	      this.transitioning = 0
	      this.$element
	        .trigger('shown.bs.collapse')
	    }
	
	    if (!$.support.transition) return complete.call(this)
	
	    var scrollSize = $.camelCase(['scroll', dimension].join('-'))
	
	    this.$element
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
	  }
	
	  Collapse.prototype.hide = function () {
	    if (this.transitioning || !this.$element.hasClass('in')) return
	
	    var startEvent = $.Event('hide.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return
	
	    var dimension = this.dimension()
	
	    this.$element[dimension](this.$element[dimension]())[0].offsetHeight
	
	    this.$element
	      .addClass('collapsing')
	      .removeClass('collapse in')
	      .attr('aria-expanded', false)
	
	    this.$trigger
	      .addClass('collapsed')
	      .attr('aria-expanded', false)
	
	    this.transitioning = 1
	
	    var complete = function () {
	      this.transitioning = 0
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse')
	        .trigger('hidden.bs.collapse')
	    }
	
	    if (!$.support.transition) return complete.call(this)
	
	    this.$element
	      [dimension](0)
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
	  }
	
	  Collapse.prototype.toggle = function () {
	    this[this.$element.hasClass('in') ? 'hide' : 'show']()
	  }
	
	  Collapse.prototype.getParent = function () {
	    return $(this.options.parent)
	      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
	      .each($.proxy(function (i, element) {
	        var $element = $(element)
	        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
	      }, this))
	      .end()
	  }
	
	  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
	    var isOpen = $element.hasClass('in')
	
	    $element.attr('aria-expanded', isOpen)
	    $trigger
	      .toggleClass('collapsed', !isOpen)
	      .attr('aria-expanded', isOpen)
	  }
	
	  function getTargetFromTrigger($trigger) {
	    var href
	    var target = $trigger.attr('data-target')
	      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
	
	    return $(target)
	  }
	
	
	  // COLLAPSE PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.collapse')
	      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
	
	      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
	      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.collapse
	
	  $.fn.collapse             = Plugin
	  $.fn.collapse.Constructor = Collapse
	
	
	  // COLLAPSE NO CONFLICT
	  // ====================
	
	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }
	
	
	  // COLLAPSE DATA-API
	  // =================
	
	  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	    var $this   = $(this)
	
	    if (!$this.attr('data-target')) e.preventDefault()
	
	    var $target = getTargetFromTrigger($this)
	    var data    = $target.data('bs.collapse')
	    var option  = data ? 'toggle' : $this.data()
	
	    Plugin.call($target, option)
	  })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: dropdown.js v3.3.6
	 * http://getbootstrap.com/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // DROPDOWN CLASS DEFINITION
	  // =========================
	
	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }
	
	  Dropdown.VERSION = '3.3.6'
	
	  function getParent($this) {
	    var selector = $this.attr('data-target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    var $parent = selector && $(selector)
	
	    return $parent && $parent.length ? $parent : $this.parent()
	  }
	
	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }
	
	      if (!$parent.hasClass('open')) return
	
	      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return
	
	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
	
	      if (e.isDefaultPrevented()) return
	
	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
	    })
	  }
	
	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)
	
	    if ($this.is('.disabled, :disabled')) return
	
	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')
	
	    clearMenus()
	
	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $(document.createElement('div'))
	          .addClass('dropdown-backdrop')
	          .insertAfter($(this))
	          .on('click', clearMenus)
	      }
	
	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
	
	      if (e.isDefaultPrevented()) return
	
	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')
	
	      $parent
	        .toggleClass('open')
	        .trigger($.Event('shown.bs.dropdown', relatedTarget))
	    }
	
	    return false
	  }
	
	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
	
	    var $this = $(this)
	
	    e.preventDefault()
	    e.stopPropagation()
	
	    if ($this.is('.disabled, :disabled')) return
	
	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')
	
	    if (!isActive && e.which != 27 || isActive && e.which == 27) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }
	
	    var desc = ' li:not(.disabled):visible a'
	    var $items = $parent.find('.dropdown-menu' + desc)
	
	    if (!$items.length) return
	
	    var index = $items.index(e.target)
	
	    if (e.which == 38 && index > 0)                 index--         // up
	    if (e.which == 40 && index < $items.length - 1) index++         // down
	    if (!~index)                                    index = 0
	
	    $items.eq(index).trigger('focus')
	  }
	
	
	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')
	
	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  var old = $.fn.dropdown
	
	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown
	
	
	  // DROPDOWN NO CONFLICT
	  // ====================
	
	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }
	
	
	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================
	
	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: modal.js v3.3.6
	 * http://getbootstrap.com/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // MODAL CLASS DEFINITION
	  // ======================
	
	  var Modal = function (element, options) {
	    this.options             = options
	    this.$body               = $(document.body)
	    this.$element            = $(element)
	    this.$dialog             = this.$element.find('.modal-dialog')
	    this.$backdrop           = null
	    this.isShown             = null
	    this.originalBodyPad     = null
	    this.scrollbarWidth      = 0
	    this.ignoreBackdropClick = false
	
	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }
	
	  Modal.VERSION  = '3.3.6'
	
	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150
	
	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }
	
	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }
	
	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })
	
	    this.$element.trigger(e)
	
	    if (this.isShown || e.isDefaultPrevented()) return
	
	    this.isShown = true
	
	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')
	
	    this.escape()
	    this.resize()
	
	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
	
	    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
	      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
	        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
	      })
	    })
	
	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')
	
	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }
	
	      that.$element
	        .show()
	        .scrollTop(0)
	
	      that.adjustDialog()
	
	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }
	
	      that.$element.addClass('in')
	
	      that.enforceFocus()
	
	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })
	
	      transition ?
	        that.$dialog // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }
	
	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()
	
	    e = $.Event('hide.bs.modal')
	
	    this.$element.trigger(e)
	
	    if (!this.isShown || e.isDefaultPrevented()) return
	
	    this.isShown = false
	
	    this.escape()
	    this.resize()
	
	    $(document).off('focusin.bs.modal')
	
	    this.$element
	      .removeClass('in')
	      .off('click.dismiss.bs.modal')
	      .off('mouseup.dismiss.bs.modal')
	
	    this.$dialog.off('mousedown.dismiss.bs.modal')
	
	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }
	
	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }
	
	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }
	
	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }
	
	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }
	
	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }
	
	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''
	
	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate
	
	      this.$backdrop = $(document.createElement('div'))
	        .addClass('modal-backdrop ' + animate)
	        .appendTo(this.$body)
	
	      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
	        if (this.ignoreBackdropClick) {
	          this.ignoreBackdropClick = false
	          return
	        }
	        if (e.target !== e.currentTarget) return
	        this.options.backdrop == 'static'
	          ? this.$element[0].focus()
	          : this.hide()
	      }, this))
	
	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
	
	      this.$backdrop.addClass('in')
	
	      if (!callback) return
	
	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()
	
	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')
	
	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()
	
	    } else if (callback) {
	      callback()
	    }
	  }
	
	  // these following methods are used to handle overflowing modals
	
	  Modal.prototype.handleUpdate = function () {
	    this.adjustDialog()
	  }
	
	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
	
	    this.$element.css({
	      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }
	
	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }
	
	  Modal.prototype.checkScrollbar = function () {
	    var fullWindowWidth = window.innerWidth
	    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
	      var documentElementRect = document.documentElement.getBoundingClientRect()
	      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
	    }
	    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
	    this.scrollbarWidth = this.measureScrollbar()
	  }
	
	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    this.originalBodyPad = document.body.style.paddingRight || ''
	    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
	  }
	
	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', this.originalBodyPad)
	  }
	
	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }
	
	
	  // MODAL PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
	
	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }
	
	  var old = $.fn.modal
	
	  $.fn.modal             = Plugin
	  $.fn.modal.Constructor = Modal
	
	
	  // MODAL NO CONFLICT
	  // =================
	
	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }
	
	
	  // MODAL DATA-API
	  // ==============
	
	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
	    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
	
	    if ($this.is('a')) e.preventDefault()
	
	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: tooltip.js v3.3.6
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================
	
	  var Tooltip = function (element, options) {
	    this.type       = null
	    this.options    = null
	    this.enabled    = null
	    this.timeout    = null
	    this.hoverState = null
	    this.$element   = null
	    this.inState    = null
	
	    this.init('tooltip', element, options)
	  }
	
	  Tooltip.VERSION  = '3.3.6'
	
	  Tooltip.TRANSITION_DURATION = 150
	
	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    }
	  }
	
	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
	    this.inState   = { click: false, hover: false, focus: false }
	
	    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
	      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
	    }
	
	    var triggers = this.options.trigger.split(' ')
	
	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]
	
	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
	
	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }
	
	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }
	
	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }
	
	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
	
	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }
	
	    return options
	  }
	
	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()
	
	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })
	
	    return options
	  }
	
	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)
	
	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }
	
	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
	    }
	
	    if (self.tip().hasClass('in') || self.hoverState == 'in') {
	      self.hoverState = 'in'
	      return
	    }
	
	    clearTimeout(self.timeout)
	
	    self.hoverState = 'in'
	
	    if (!self.options.delay || !self.options.delay.show) return self.show()
	
	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }
	
	  Tooltip.prototype.isInStateTrue = function () {
	    for (var key in this.inState) {
	      if (this.inState[key]) return true
	    }
	
	    return false
	  }
	
	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)
	
	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }
	
	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
	    }
	
	    if (self.isInStateTrue()) return
	
	    clearTimeout(self.timeout)
	
	    self.hoverState = 'out'
	
	    if (!self.options.delay || !self.options.delay.hide) return self.hide()
	
	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }
	
	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)
	
	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)
	
	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this
	
	      var $tip = this.tip()
	
	      var tipId = this.getUID(this.type)
	
	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)
	
	      if (this.options.animation) $tip.addClass('fade')
	
	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement
	
	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
	
	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)
	
	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	      this.$element.trigger('inserted.bs.' + this.type)
	
	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight
	
	      if (autoPlace) {
	        var orgPlacement = placement
	        var viewportDim = this.getPosition(this.$viewport)
	
	        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
	                    placement
	
	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }
	
	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
	
	      this.applyPlacement(calculatedOffset, placement)
	
	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null
	
	        if (prevHoverState == 'out') that.leave(that)
	      }
	
	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }
	
	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight
	
	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)
	
	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0
	
	    offset.top  += marginTop
	    offset.left += marginLeft
	
	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)
	
	    $tip.addClass('in')
	
	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight
	
	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }
	
	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
	
	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top
	
	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
	
	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }
	
	  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
	    this.arrow()
	      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isVertical ? 'top' : 'left', '')
	  }
	
	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()
	
	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }
	
	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = $(this.$tip)
	    var e    = $.Event('hide.bs.' + this.type)
	
	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      that.$element
	        .removeAttr('aria-describedby')
	        .trigger('hidden.bs.' + that.type)
	      callback && callback()
	    }
	
	    this.$element.trigger(e)
	
	    if (e.isDefaultPrevented()) return
	
	    $tip.removeClass('in')
	
	    $.support.transition && $tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()
	
	    this.hoverState = null
	
	    return this
	  }
	
	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }
	
	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }
	
	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element
	
	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'
	
	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null
	
	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }
	
	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
	
	  }
	
	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta
	
	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)
	
	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }
	
	    return delta
	  }
	
	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options
	
	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
	
	    return title
	  }
	
	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }
	
	  Tooltip.prototype.tip = function () {
	    if (!this.$tip) {
	      this.$tip = $(this.options.template)
	      if (this.$tip.length != 1) {
	        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
	      }
	    }
	    return this.$tip
	  }
	
	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }
	
	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }
	
	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }
	
	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }
	
	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }
	
	    if (e) {
	      self.inState.click = !self.inState.click
	      if (self.isInStateTrue()) self.enter(self)
	      else self.leave(self)
	    } else {
	      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	    }
	  }
	
	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	      if (that.$tip) {
	        that.$tip.detach()
	      }
	      that.$tip = null
	      that.$arrow = null
	      that.$viewport = null
	    })
	  }
	
	
	  // TOOLTIP PLUGIN DEFINITION
	  // =========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option
	
	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.tooltip
	
	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip
	
	
	  // TOOLTIP NO CONFLICT
	  // ===================
	
	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: popover.js v3.3.6
	 * http://getbootstrap.com/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================
	
	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }
	
	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
	
	  Popover.VERSION  = '3.3.6'
	
	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })
	
	
	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================
	
	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
	
	  Popover.prototype.constructor = Popover
	
	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }
	
	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()
	
	    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
	      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
	    ](content)
	
	    $tip.removeClass('fade top bottom left right in')
	
	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }
	
	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }
	
	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options
	
	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
	            o.content.call($e[0]) :
	            o.content)
	  }
	
	  Popover.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
	  }
	
	
	  // POPOVER PLUGIN DEFINITION
	  // =========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option
	
	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.popover
	
	  $.fn.popover             = Plugin
	  $.fn.popover.Constructor = Popover
	
	
	  // POPOVER NO CONFLICT
	  // ===================
	
	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: scrollspy.js v3.3.6
	 * http://getbootstrap.com/javascript/#scrollspy
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // SCROLLSPY CLASS DEFINITION
	  // ==========================
	
	  function ScrollSpy(element, options) {
	    this.$body          = $(document.body)
	    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
	    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	    this.selector       = (this.options.target || '') + ' .nav li > a'
	    this.offsets        = []
	    this.targets        = []
	    this.activeTarget   = null
	    this.scrollHeight   = 0
	
	    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
	    this.refresh()
	    this.process()
	  }
	
	  ScrollSpy.VERSION  = '3.3.6'
	
	  ScrollSpy.DEFAULTS = {
	    offset: 10
	  }
	
	  ScrollSpy.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
	  }
	
	  ScrollSpy.prototype.refresh = function () {
	    var that          = this
	    var offsetMethod  = 'offset'
	    var offsetBase    = 0
	
	    this.offsets      = []
	    this.targets      = []
	    this.scrollHeight = this.getScrollHeight()
	
	    if (!$.isWindow(this.$scrollElement[0])) {
	      offsetMethod = 'position'
	      offsetBase   = this.$scrollElement.scrollTop()
	    }
	
	    this.$body
	      .find(this.selector)
	      .map(function () {
	        var $el   = $(this)
	        var href  = $el.data('target') || $el.attr('href')
	        var $href = /^#./.test(href) && $(href)
	
	        return ($href
	          && $href.length
	          && $href.is(':visible')
	          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
	      })
	      .sort(function (a, b) { return a[0] - b[0] })
	      .each(function () {
	        that.offsets.push(this[0])
	        that.targets.push(this[1])
	      })
	  }
	
	  ScrollSpy.prototype.process = function () {
	    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	    var scrollHeight = this.getScrollHeight()
	    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
	    var offsets      = this.offsets
	    var targets      = this.targets
	    var activeTarget = this.activeTarget
	    var i
	
	    if (this.scrollHeight != scrollHeight) {
	      this.refresh()
	    }
	
	    if (scrollTop >= maxScroll) {
	      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
	    }
	
	    if (activeTarget && scrollTop < offsets[0]) {
	      this.activeTarget = null
	      return this.clear()
	    }
	
	    for (i = offsets.length; i--;) {
	      activeTarget != targets[i]
	        && scrollTop >= offsets[i]
	        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
	        && this.activate(targets[i])
	    }
	  }
	
	  ScrollSpy.prototype.activate = function (target) {
	    this.activeTarget = target
	
	    this.clear()
	
	    var selector = this.selector +
	      '[data-target="' + target + '"],' +
	      this.selector + '[href="' + target + '"]'
	
	    var active = $(selector)
	      .parents('li')
	      .addClass('active')
	
	    if (active.parent('.dropdown-menu').length) {
	      active = active
	        .closest('li.dropdown')
	        .addClass('active')
	    }
	
	    active.trigger('activate.bs.scrollspy')
	  }
	
	  ScrollSpy.prototype.clear = function () {
	    $(this.selector)
	      .parentsUntil(this.options.target, '.active')
	      .removeClass('active')
	  }
	
	
	  // SCROLLSPY PLUGIN DEFINITION
	  // ===========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.scrollspy')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.scrollspy
	
	  $.fn.scrollspy             = Plugin
	  $.fn.scrollspy.Constructor = ScrollSpy
	
	
	  // SCROLLSPY NO CONFLICT
	  // =====================
	
	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }
	
	
	  // SCROLLSPY DATA-API
	  // ==================
	
	  $(window).on('load.bs.scrollspy.data-api', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      Plugin.call($spy, $spy.data())
	    })
	  })
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: tab.js v3.3.6
	 * http://getbootstrap.com/javascript/#tabs
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // TAB CLASS DEFINITION
	  // ====================
	
	  var Tab = function (element) {
	    // jscs:disable requireDollarBeforejQueryAssignment
	    this.element = $(element)
	    // jscs:enable requireDollarBeforejQueryAssignment
	  }
	
	  Tab.VERSION = '3.3.6'
	
	  Tab.TRANSITION_DURATION = 150
	
	  Tab.prototype.show = function () {
	    var $this    = this.element
	    var $ul      = $this.closest('ul:not(.dropdown-menu)')
	    var selector = $this.data('target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    if ($this.parent('li').hasClass('active')) return
	
	    var $previous = $ul.find('.active:last a')
	    var hideEvent = $.Event('hide.bs.tab', {
	      relatedTarget: $this[0]
	    })
	    var showEvent = $.Event('show.bs.tab', {
	      relatedTarget: $previous[0]
	    })
	
	    $previous.trigger(hideEvent)
	    $this.trigger(showEvent)
	
	    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
	
	    var $target = $(selector)
	
	    this.activate($this.closest('li'), $ul)
	    this.activate($target, $target.parent(), function () {
	      $previous.trigger({
	        type: 'hidden.bs.tab',
	        relatedTarget: $this[0]
	      })
	      $this.trigger({
	        type: 'shown.bs.tab',
	        relatedTarget: $previous[0]
	      })
	    })
	  }
	
	  Tab.prototype.activate = function (element, container, callback) {
	    var $active    = container.find('> .active')
	    var transition = callback
	      && $.support.transition
	      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)
	
	    function next() {
	      $active
	        .removeClass('active')
	        .find('> .dropdown-menu > .active')
	          .removeClass('active')
	        .end()
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', false)
	
	      element
	        .addClass('active')
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', true)
	
	      if (transition) {
	        element[0].offsetWidth // reflow for transition
	        element.addClass('in')
	      } else {
	        element.removeClass('fade')
	      }
	
	      if (element.parent('.dropdown-menu').length) {
	        element
	          .closest('li.dropdown')
	            .addClass('active')
	          .end()
	          .find('[data-toggle="tab"]')
	            .attr('aria-expanded', true)
	      }
	
	      callback && callback()
	    }
	
	    $active.length && transition ?
	      $active
	        .one('bsTransitionEnd', next)
	        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
	      next()
	
	    $active.removeClass('in')
	  }
	
	
	  // TAB PLUGIN DEFINITION
	  // =====================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.tab')
	
	      if (!data) $this.data('bs.tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.tab
	
	  $.fn.tab             = Plugin
	  $.fn.tab.Constructor = Tab
	
	
	  // TAB NO CONFLICT
	  // ===============
	
	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }
	
	
	  // TAB DATA-API
	  // ============
	
	  var clickHandler = function (e) {
	    e.preventDefault()
	    Plugin.call($(this), 'show')
	  }
	
	  $(document)
	    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
	    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
	
	}(jQuery);
	
	/* ========================================================================
	 * Bootstrap: affix.js v3.3.6
	 * http://getbootstrap.com/javascript/#affix
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // AFFIX CLASS DEFINITION
	  // ======================
	
	  var Affix = function (element, options) {
	    this.options = $.extend({}, Affix.DEFAULTS, options)
	
	    this.$target = $(this.options.target)
	      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))
	
	    this.$element     = $(element)
	    this.affixed      = null
	    this.unpin        = null
	    this.pinnedOffset = null
	
	    this.checkPosition()
	  }
	
	  Affix.VERSION  = '3.3.6'
	
	  Affix.RESET    = 'affix affix-top affix-bottom'
	
	  Affix.DEFAULTS = {
	    offset: 0,
	    target: window
	  }
	
	  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
	    var scrollTop    = this.$target.scrollTop()
	    var position     = this.$element.offset()
	    var targetHeight = this.$target.height()
	
	    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
	
	    if (this.affixed == 'bottom') {
	      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
	      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
	    }
	
	    var initializing   = this.affixed == null
	    var colliderTop    = initializing ? scrollTop : position.top
	    var colliderHeight = initializing ? targetHeight : height
	
	    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
	    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
	
	    return false
	  }
	
	  Affix.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset
	    this.$element.removeClass(Affix.RESET).addClass('affix')
	    var scrollTop = this.$target.scrollTop()
	    var position  = this.$element.offset()
	    return (this.pinnedOffset = position.top - scrollTop)
	  }
	
	  Affix.prototype.checkPositionWithEventLoop = function () {
	    setTimeout($.proxy(this.checkPosition, this), 1)
	  }
	
	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return
	
	    var height       = this.$element.height()
	    var offset       = this.options.offset
	    var offsetTop    = offset.top
	    var offsetBottom = offset.bottom
	    var scrollHeight = Math.max($(document).height(), $(document.body).height())
	
	    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
	
	    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
	
	    if (this.affixed != affix) {
	      if (this.unpin != null) this.$element.css('top', '')
	
	      var affixType = 'affix' + (affix ? '-' + affix : '')
	      var e         = $.Event(affixType + '.bs.affix')
	
	      this.$element.trigger(e)
	
	      if (e.isDefaultPrevented()) return
	
	      this.affixed = affix
	      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
	
	      this.$element
	        .removeClass(Affix.RESET)
	        .addClass(affixType)
	        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
	    }
	
	    if (affix == 'bottom') {
	      this.$element.offset({
	        top: scrollHeight - height - offsetBottom
	      })
	    }
	  }
	
	
	  // AFFIX PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.affix')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.affix
	
	  $.fn.affix             = Plugin
	  $.fn.affix.Constructor = Affix
	
	
	  // AFFIX NO CONFLICT
	  // =================
	
	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }
	
	
	  // AFFIX DATA-API
	  // ==============
	
	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	      var data = $spy.data()
	
	      data.offset = data.offset || {}
	
	      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
	      if (data.offsetTop    != null) data.offset.top    = data.offsetTop
	
	      Plugin.call($spy, data)
	    })
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(gkClientInterface) {module.exports = ['gettextCatalog', '$q', 'gettext',function (gettextCatalog, $q,gettext) {
	    var getLang = function () {
	        var deferred = $q.defer();
	        var language = null;
	        gkClientInterface.getLanguage(function(clientLanType) {
	            language = gkClientInterface.getLanguageKey(clientLanType.type);
	
	            if (!language || language.toLowerCase().indexOf('zh_cn') >= 0 || language.toLowerCase().indexOf('zh-cn') >= 0) {
	                language = null;
	            }
	
	            deferred.resolve(language);
	        });
	        return deferred.promise;
	    };
	
	    //getLang().then(function(lang) {
	    //    jQuery.ajaxSetup({
	    //        headers: {
	    //            'Accept-Language': lang
	    //        }
	    //    });
	    //});
	
	    var gkI18N = {
	        getText: function (strText) {
	            return gettextCatalog.getString(strText)
	        },
	        getReplaceText: function (strText, replaceStrArr) {
	            return gettextCatalog.getString(strText, replaceStrArr)
	        },
	        getLang: getLang,
	        setLocal: function () {
	            //gettextCatalog.debug = true;
	            this.getLang().then(function(lang) {
	                if (lang) {
	                    gettextCatalog.currentLanguage = lang;
	                }
	            });
	            return language;
	        },
	        translate:function(strText){
	           return this.getText(gettext(strText))
	        }
	    };
	
	    return gkI18N;
	}]
	;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ },
/* 306 */
/***/ function(module, exports) {

	
	module.exports = "gokuai.html"

/***/ },
/* 307 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 308 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery UI Position 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/position/
	 */
	(function( factory ) {
		if ( true ) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory( jQuery );
		}
	}(function( $ ) {
	(function() {
	
	$.ui = $.ui || {};
	
	var cachedScrollbarWidth, supportsOffsetFractions,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;
	
	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}
	
	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}
	
	function getDimensions( elem ) {
		var raw = elem[0];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}
	
	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[0];
	
			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );
	
			w2 = innerDiv.offsetWidth;
	
			if ( w1 === w2 ) {
				w2 = div[0].clientWidth;
			}
	
			div.remove();
	
			return (cachedScrollbarWidth = w1 - w2);
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-x" ),
				overflowY = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[0].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[0] ),
				isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
			return {
				element: withinElement,
				isWindow: isWindow,
				isDocument: isDocument,
				offset: withinElement.offset() || { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
	
				// support: jQuery 1.6.x
				// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
				width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
				height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
			};
		}
	};
	
	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}
	
		// make a copy, we don't want to modify arguments
		options = $.extend( {}, options );
	
		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};
	
		dimensions = getDimensions( target );
		if ( target[0].preventDefault ) {
			// force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;
		// clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );
	
		// force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;
	
			if ( pos.length === 1) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
	
			// calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];
	
			// reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		});
	
		// normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}
	
		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}
	
		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}
	
		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];
	
		return this.each(function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
	
			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}
	
			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}
	
			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];
	
			// if the browser doesn't support fractions, then round for consistent results
			if ( !supportsOffsetFractions ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}
	
			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};
	
			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem: elem
					});
				}
			});
	
			if ( options.using ) {
				// adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}
	
			elem.offset( $.extend( position, { using: using } ) );
		});
	};
	
	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;
	
				// element is wider than within
				if ( data.collisionWidth > outerWidth ) {
					// element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
						position.left += overLeft - newOverRight;
					// element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;
					// element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}
				// too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;
				// too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;
				// adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;
	
				// element is taller than within
				if ( data.collisionHeight > outerHeight ) {
					// element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
						position.top += overTop - newOverBottom;
					// element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;
					// element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}
				// too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;
				// too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;
				// adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;
	
				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				} else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
					if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
						position.top += myOffset + atOffset + offset;
					}
				} else if ( overBottom > 0 ) {
					newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
					if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};
	
	// fraction support test
	(function() {
		var testElement, testElementParent, testElementStyle, offsetLeft, i,
			body = document.getElementsByTagName( "body" )[ 0 ],
			div = document.createElement( "div" );
	
		//Create a "fake body" for testing based on method used in jQuery.support
		testElement = document.createElement( body ? "div" : "body" );
		testElementStyle = {
			visibility: "hidden",
			width: 0,
			height: 0,
			border: 0,
			margin: 0,
			background: "none"
		};
		if ( body ) {
			$.extend( testElementStyle, {
				position: "absolute",
				left: "-1000px",
				top: "-1000px"
			});
		}
		for ( i in testElementStyle ) {
			testElement.style[ i ] = testElementStyle[ i ];
		}
		testElement.appendChild( div );
		testElementParent = body || document.documentElement;
		testElementParent.insertBefore( testElement, testElementParent.firstChild );
	
		div.style.cssText = "position: absolute; left: 10.7432222px;";
	
		offsetLeft = $( div ).offset().left;
		supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
	
		testElement.innerHTML = "";
		testElementParent.removeChild( testElement );
	})();
	
	})();
	
	return $.ui.position;
	
	}));


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery contextMenu v1.10.2 - Plugin for simple contextMenu handling
	 *
	 * Version: v1.10.2
	 *
	 * Authors: Björn Brala (SWIS.nl), Rodney Rehm, Addy Osmani (patches for FF)
	 * Web: http://swisnl.github.io/jQuery-contextMenu/
	 *
	 * Copyright (c) 2011-2015 SWIS BV and contributors
	 *
	 * Licensed under
	 *   MIT License http://www.opensource.org/licenses/mit-license
	 *   GPL v3 http://opensource.org/licenses/GPL-3.0
	 *
	 * Date: 2015-10-28T15:15:00.338Z
	 */
	
	(function (factory) {
	    if (true) {
	        // AMD. Register as anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node / CommonJS
	        factory(require('jquery'));
	    } else {
	        // Browser globals.
	        factory(jQuery);
	    }
	})(function ($) {
	
	    'use strict';
	
	    // TODO: -
	    // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
	    // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative
	
	    // determine html5 compatibility
	    $.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
	    $.support.htmlCommand = ('HTMLCommandElement' in window);
	    $.support.eventSelectstart = ('onselectstart' in document.documentElement);
	    /* // should the need arise, test for css user-select
	     $.support.cssUserSelect = (function(){
	     var t = false,
	     e = document.createElement('div');
	
	     $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
	     var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
	     prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';
	
	     e.style.cssText = prop + ': text;';
	     if (e.style[propCC] == 'text') {
	     t = true;
	     return false;
	     }
	
	     return true;
	     });
	
	     return t;
	     })();
	     */
	
	    if (!$.ui || !$.widget) {
	        // duck punch $.cleanData like jQueryUI does to get that remove event
	        $.cleanData = (function (orig) {
	            return function (elems) {
	                var events, elem, i;
	                for (i = 0; (elem = elems[i]) != null; i++) {
	                    try {
	                        // Only trigger remove when necessary to save time
	                        events = $._data(elem, 'events');
	                        if (events && events.remove) {
	                            $(elem).triggerHandler('remove');
	                        }
	
	                        // Http://bugs.jquery.com/ticket/8235
	                    } catch (e) {}
	                }
	                orig(elems);
	            };
	        })($.cleanData);
	    }
	
	    var // currently active contextMenu trigger
	        $currentTrigger = null,
	    // is contextMenu initialized with at least one menu?
	        initialized = false,
	    // window handle
	        $win = $(window),
	    // number of registered menus
	        counter = 0,
	    // mapping selector to namespace
	        namespaces = {},
	    // mapping namespace to options
	        menus = {},
	    // custom command type handlers
	        types = {},
	    // default values
	        defaults = {
	            // selector of contextMenu trigger
	            selector: null,
	            // where to append the menu to
	            appendTo: null,
	            // method to trigger context menu ["right", "left", "hover"]
	            trigger: 'right',
	            // hide menu when mouse leaves trigger / menu elements
	            autoHide: false,
	            // ms to wait before showing a hover-triggered context menu
	            delay: 200,
	            // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
	            // as long as the trigger happened on one of the trigger-element's child nodes
	            reposition: true,
	
	            // Default classname configuration to be able avoid conflicts in frameworks
	            classNames : {
	
	                hover: 'hover', // Item hover
	                disabled: 'disabled', // Item disabled
	                visible: 'visible', // Item visible
	                notSelectable: 'not-selectable', // Item not selectable
	
	                icon: 'icon',
	                iconEdit: 'icon-edit',
	                iconCut: 'icon-cut',
	                iconCopy: 'icon-copy',
	                iconPaste: 'icon-paste',
	                iconDelete: 'icon-delete',
	                iconAdd: 'icon-add',
	                iconQuit: 'icon-quit'
	            },
	
	            // determine position to show menu at
	            determinePosition: function ($menu) {
	                // position to the lower middle of the trigger element
	                if ($.ui && $.ui.position) {
	                    // .position() is provided as a jQuery UI utility
	                    // (...and it won't work on hidden elements)
	                    $menu.css('display', 'block').position({
	                        my: 'center top',
	                        at: 'center bottom',
	                        of: this,
	                        offset: '0 5',
	                        collision: 'fit'
	                    }).css('display', 'none');
	                } else {
	                    // determine contextMenu position
	                    var offset = this.offset();
	                    offset.top += this.outerHeight();
	                    offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
	                    $menu.css(offset);
	                }
	            },
	            // position menu
	            position: function (opt, x, y) {
	                var offset;
	                // determine contextMenu position
	                if (!x && !y) {
	                    opt.determinePosition.call(this, opt.$menu);
	                    return;
	                } else if (x === 'maintain' && y === 'maintain') {
	                    // x and y must not be changed (after re-show on command click)
	                    offset = opt.$menu.position();
	                } else {
	                    // x and y are given (by mouse event)
	                    offset = {top: y, left: x};
	                }
	
	                // correct offset if viewport demands it
	                var bottom = $win.scrollTop() + $win.height(),
	                    right = $win.scrollLeft() + $win.width(),
	                    height = opt.$menu.outerHeight(),
	                    width = opt.$menu.outerWidth();
	
	                if (offset.top + height > bottom) {
	                    offset.top -= height;
	                }
	
	                if (offset.top < 0) {
	                    offset.top = 0;
	                }
	
	                if (offset.left + width > right) {
	                    offset.left -= width;
	                }
	
	                if (offset.left < 0) {
	                    offset.left = 0;
	                }
	
	                opt.$menu.css(offset);
	            },
	            // position the sub-menu
	            positionSubmenu: function ($menu) {
	                if ($.ui && $.ui.position) {
	                    // .position() is provided as a jQuery UI utility
	                    // (...and it won't work on hidden elements)
	                    $menu.css('display', 'block').position({
	                        my: 'left top',
	                        at: 'right top',
	                        of: this,
	                        collision: 'flipfit fit'
	                    }).css('display', '');
	                } else {
	                    // determine contextMenu position
	                    var offset = {
	                        top: 0,
	                        left: this.outerWidth()
	                    };
	                    $menu.css(offset);
	                }
	            },
	            // offset to add to zIndex
	            zIndex: 1,
	            // show hide animation settings
	            animation: {
	                duration: 50,
	                show: 'slideDown',
	                hide: 'slideUp'
	            },
	            // events
	            events: {
	                show: $.noop,
	                hide: $.noop
	            },
	            // default callback
	            callback: null,
	            // list of contextMenu items
	            items: {}
	        },
	    // mouse position for hover activation
	        hoveract = {
	            timer: null,
	            pageX: null,
	            pageY: null
	        },
	    // determine zIndex
	        zindex = function ($t) {
	            var zin = 0,
	                $tt = $t;
	
	            while (true) {
	                zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
	                $tt = $tt.parent();
	                if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) > -1) {
	                    break;
	                }
	            }
	            return zin;
	        },
	    // event handlers
	        handle = {
	            // abort anything
	            abortevent: function (e) {
	                e.preventDefault();
	                e.stopImmediatePropagation();
	            },
	            // contextmenu show dispatcher
	            contextmenu: function (e) {
	                var $this = $(this);
	
	                // disable actual context-menu if we are using the right mouse button as the trigger
	                if (e.data.trigger === 'right') {
	                    e.preventDefault();
	                    e.stopImmediatePropagation();
	                }
	
	                // abort native-triggered events unless we're triggering on right click
	                if ((e.data.trigger !== 'right' && e.data.trigger !== 'demand') && e.originalEvent) {
	                    return;
	                }
	
	                // abort event if menu is visible for this trigger
	                if ($this.hasClass('context-menu-active')) {
	                    return;
	                }
	
	                if (!$this.hasClass('context-menu-disabled')) {
	                    // theoretically need to fire a show event at <menu>
	                    // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
	                    // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
	                    // e.data.$menu.trigger(evt);
	
	                    $currentTrigger = $this;
	                    if (e.data.build) {
	                        var built = e.data.build($currentTrigger, e);
	                        // abort if build() returned false
	                        if (built === false) {
	                            return;
	                        }
	
	                        // dynamically build menu on invocation
	                        e.data = $.extend(true, {}, defaults, e.data, built || {});
	
	                        // abort if there are no items to display
	                        if (!e.data.items || $.isEmptyObject(e.data.items)) {
	                            // Note: jQuery captures and ignores errors from event handlers
	                            if (window.console) {
	                                (console.error || console.log).call(console, 'No items specified to show in contextMenu');
	                            }
	
	                            throw new Error('No Items specified');
	                        }
	
	                        // backreference for custom command type creation
	                        e.data.$trigger = $currentTrigger;
	
	                        op.create(e.data);
	                    }
	                    var showMenu = false;
	                    for (var item in e.data.items) {
	                        if (e.data.items.hasOwnProperty(item)) {
	                            var visible;
	                            if ($.isFunction(e.data.items[item].visible)) {
	                                visible = e.data.items[item].visible.call($(e.currentTarget), item, e.data);
	                            } else if (typeof item.visible !== 'undefined') {
	                                visible = e.data.items[item].visible === true;
	                            } else {
	                                visible = true;
	                            }
	                            if (visible) {
	                                showMenu = true;
	                            }
	                        }
	                    }
	                    if (showMenu) {
	                        // show menu
	                        op.show.call($this, e.data, e.pageX, e.pageY);
	                    }
	                }
	            },
	            // contextMenu left-click trigger
	            click: function (e) {
	                e.preventDefault();
	                e.stopImmediatePropagation();
	                $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
	            },
	            // contextMenu right-click trigger
	            mousedown: function (e) {
	                // register mouse down
	                var $this = $(this);
	
	                // hide any previous menus
	                if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
	                    $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
	                }
	
	                // activate on right click
	                if (e.button === 2) {
	                    $currentTrigger = $this.data('contextMenuActive', true);
	                }
	            },
	            // contextMenu right-click trigger
	            mouseup: function (e) {
	                // show menu
	                var $this = $(this);
	                if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
	                    e.preventDefault();
	                    e.stopImmediatePropagation();
	                    $currentTrigger = $this;
	                    $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));
	                }
	
	                $this.removeData('contextMenuActive');
	            },
	            // contextMenu hover trigger
	            mouseenter: function (e) {
	                var $this = $(this),
	                    $related = $(e.relatedTarget),
	                    $document = $(document);
	
	                // abort if we're coming from a menu
	                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
	                    return;
	                }
	
	                // abort if a menu is shown
	                if ($currentTrigger && $currentTrigger.length) {
	                    return;
	                }
	
	                hoveract.pageX = e.pageX;
	                hoveract.pageY = e.pageY;
	                hoveract.data = e.data;
	                $document.on('mousemove.contextMenuShow', handle.mousemove);
	                hoveract.timer = setTimeout(function () {
	                    hoveract.timer = null;
	                    $document.off('mousemove.contextMenuShow');
	                    $currentTrigger = $this;
	                    $this.trigger($.Event('contextmenu', {
	                        data: hoveract.data,
	                        pageX: hoveract.pageX,
	                        pageY: hoveract.pageY
	                    }));
	                }, e.data.delay);
	            },
	            // contextMenu hover trigger
	            mousemove: function (e) {
	                hoveract.pageX = e.pageX;
	                hoveract.pageY = e.pageY;
	            },
	            // contextMenu hover trigger
	            mouseleave: function (e) {
	                // abort if we're leaving for a menu
	                var $related = $(e.relatedTarget);
	                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
	                    return;
	                }
	
	                try {
	                    clearTimeout(hoveract.timer);
	                } catch (e) {
	                }
	
	                hoveract.timer = null;
	            },
	            // click on layer to hide contextMenu
	            layerClick: function (e) {
	                var $this = $(this),
	                    root = $this.data('contextMenuRoot'),
	                    button = e.button,
	                    x = e.pageX,
	                    y = e.pageY,
	                    target,
	                    offset;
	
	                e.preventDefault();
	                e.stopImmediatePropagation();
	
	                setTimeout(function () {
	                    var $window;
	                    var triggerAction = ((root.trigger === 'left' && button === 0) || (root.trigger === 'right' && button === 2));
	
	                    // find the element that would've been clicked, wasn't the layer in the way
	                    if (document.elementFromPoint) {
	                        root.$layer.hide();
	                        target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
	                        root.$layer.show();
	                    }
	
	                    if (root.reposition && triggerAction) {
	                        if (document.elementFromPoint) {
	                            if (root.$trigger.is(target) || root.$trigger.has(target).length) {
	                                root.position.call(root.$trigger, root, x, y);
	                                return;
	                            }
	                        } else {
	                            offset = root.$trigger.offset();
	                            $window = $(window);
	                            // while this looks kinda awful, it's the best way to avoid
	                            // unnecessarily calculating any positions
	                            offset.top += $window.scrollTop();
	                            if (offset.top <= e.pageY) {
	                                offset.left += $window.scrollLeft();
	                                if (offset.left <= e.pageX) {
	                                    offset.bottom = offset.top + root.$trigger.outerHeight();
	                                    if (offset.bottom >= e.pageY) {
	                                        offset.right = offset.left + root.$trigger.outerWidth();
	                                        if (offset.right >= e.pageX) {
	                                            // reposition
	                                            root.position.call(root.$trigger, root, x, y);
	                                            return;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	
	                    if (target && triggerAction) {
	                        root.$trigger.one('contextmenu:hidden', function () {
	                            $(target).contextMenu({x: x, y: y});
	                        });
	                    }
	
	                    root.$menu.trigger('contextmenu:hide');
	                }, 50);
	            },
	            // key handled :hover
	            keyStop: function (e, opt) {
	                if (!opt.isInput) {
	                    e.preventDefault();
	                }
	
	                e.stopPropagation();
	            },
	            key: function (e) {
	
	                var opt = {};
	
	                // Only get the data from $currentTrigger if it exists
	                if ($currentTrigger) {
	                    opt = $currentTrigger.data('contextMenu') || {};
	                }
	
	                switch (e.keyCode) {
	                    case 9:
	                    case 38: // up
	                        handle.keyStop(e, opt);
	                        // if keyCode is [38 (up)] or [9 (tab) with shift]
	                        if (opt.isInput) {
	                            if (e.keyCode === 9 && e.shiftKey) {
	                                e.preventDefault();
	                                opt.$selected && opt.$selected.find('input, textarea, select').blur();
	                                opt.$menu.trigger('prevcommand');
	                                return;
	                            } else if (e.keyCode === 38 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
	                                // checkboxes don't capture this key
	                                e.preventDefault();
	                                return;
	                            }
	                        } else if (e.keyCode !== 9 || e.shiftKey) {
	                            opt.$menu.trigger('prevcommand');
	                            return;
	                        }
	                    // omitting break;
	                    // case 9: // tab - reached through omitted break;
	                    case 40: // down
	                        handle.keyStop(e, opt);
	                        if (opt.isInput) {
	                            if (e.keyCode === 9) {
	                                e.preventDefault();
	                                opt.$selected && opt.$selected.find('input, textarea, select').blur();
	                                opt.$menu.trigger('nextcommand');
	                                return;
	                            } else if (e.keyCode === 40 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {
	                                // checkboxes don't capture this key
	                                e.preventDefault();
	                                return;
	                            }
	                        } else {
	                            opt.$menu.trigger('nextcommand');
	                            return;
	                        }
	                        break;
	
	                    case 37: // left
	                        handle.keyStop(e, opt);
	                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
	                            break;
	                        }
	
	                        if (!opt.$selected.parent().hasClass('context-menu-root')) {
	                            var $parent = opt.$selected.parent().parent();
	                            opt.$selected.trigger('contextmenu:blur');
	                            opt.$selected = $parent;
	                            return;
	                        }
	                        break;
	
	                    case 39: // right
	                        handle.keyStop(e, opt);
	                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {
	                            break;
	                        }
	
	                        var itemdata = opt.$selected.data('contextMenu') || {};
	                        if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
	                            opt.$selected = null;
	                            itemdata.$selected = null;
	                            itemdata.$menu.trigger('nextcommand');
	                            return;
	                        }
	                        break;
	
	                    case 35: // end
	                    case 36: // home
	                        if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
	                            return;
	                        } else {
	                            (opt.$selected && opt.$selected.parent() || opt.$menu)
	                                .children(':not(.' + opt.classNames.disabled + ', .' + opt.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']()
	                                .trigger('contextmenu:focus');
	                            e.preventDefault();
	                            return;
	                        }
	                        break;
	
	                    case 13: // enter
	                        handle.keyStop(e, opt);
	                        if (opt.isInput) {
	                            if (opt.$selected && !opt.$selected.is('textarea, select')) {
	                                e.preventDefault();
	                                return;
	                            }
	                            break;
	                        }
	                        if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
	                            opt.$selected.trigger('mouseup');
	                        }
	                        return;
	
	                    case 32: // space
	                    case 33: // page up
	                    case 34: // page down
	                        // prevent browser from scrolling down while menu is visible
	                        handle.keyStop(e, opt);
	                        return;
	
	                    case 27: // esc
	                        handle.keyStop(e, opt);
	                        opt.$menu.trigger('contextmenu:hide');
	                        return;
	
	                    default: // 0-9, a-z
	                        var k = (String.fromCharCode(e.keyCode)).toUpperCase();
	                        if (opt.accesskeys && opt.accesskeys[k]) {
	                            // according to the specs accesskeys must be invoked immediately
	                            opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup');
	                            return;
	                        }
	                        break;
	                }
	                // pass event to selected item,
	                // stop propagation to avoid endless recursion
	                e.stopPropagation();
	                if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {
	                    opt.$selected.trigger(e);
	                }
	            },
	            // select previous possible command in menu
	            prevItem: function (e) {
	                e.stopPropagation();
	                var opt = $(this).data('contextMenu') || {};
	                var root = $(this).data('contextMenuRoot') || {};
	
	                // obtain currently selected menu
	                if (opt.$selected) {
	                    var $s = opt.$selected;
	                    opt = opt.$selected.parent().data('contextMenu') || {};
	                    opt.$selected = $s;
	                }
	
	                var $children = opt.$menu.children(),
	                    $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
	                    $round = $prev;
	
	                // skip disabled
	                while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable)) {
	                    if ($prev.prev().length) {
	                        $prev = $prev.prev();
	                    } else {
	                        $prev = $children.last();
	                    }
	                    if ($prev.is($round)) {
	                        // break endless loop
	                        return;
	                    }
	                }
	
	                // leave current
	                if (opt.$selected) {
	                    handle.itemMouseleave.call(opt.$selected.get(0), e);
	                }
	
	                // activate next
	                handle.itemMouseenter.call($prev.get(0), e);
	
	                // focus input
	                var $input = $prev.find('input, textarea, select');
	                if ($input.length) {
	                    $input.focus();
	                }
	            },
	            // select next possible command in menu
	            nextItem: function (e) {
	                e.stopPropagation();
	                var opt = $(this).data('contextMenu') || {};
	                var root = $(this).data('contextMenuRoot') || {};
	
	                // obtain currently selected menu
	                if (opt.$selected) {
	                    var $s = opt.$selected;
	                    opt = opt.$selected.parent().data('contextMenu') || {};
	                    opt.$selected = $s;
	                }
	
	                var $children = opt.$menu.children(),
	                    $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
	                    $round = $next;
	
	                // skip disabled
	                while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable)) {
	                    if ($next.next().length) {
	                        $next = $next.next();
	                    } else {
	                        $next = $children.first();
	                    }
	                    if ($next.is($round)) {
	                        // break endless loop
	                        return;
	                    }
	                }
	
	                // leave current
	                if (opt.$selected) {
	                    handle.itemMouseleave.call(opt.$selected.get(0), e);
	                }
	
	                // activate next
	                handle.itemMouseenter.call($next.get(0), e);
	
	                // focus input
	                var $input = $next.find('input, textarea, select');
	                if ($input.length) {
	                    $input.focus();
	                }
	            },
	            // flag that we're inside an input so the key handler can act accordingly
	            focusInput: function () {
	                var $this = $(this).closest('.context-menu-item'),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                root.$selected = opt.$selected = $this;
	                root.isInput = opt.isInput = true;
	            },
	            // flag that we're inside an input so the key handler can act accordingly
	            blurInput: function () {
	                var $this = $(this).closest('.context-menu-item'),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                root.isInput = opt.isInput = false;
	            },
	            // :hover on menu
	            menuMouseenter: function () {
	                var root = $(this).data().contextMenuRoot;
	                root.hovering = true;
	            },
	            // :hover on menu
	            menuMouseleave: function (e) {
	                var root = $(this).data().contextMenuRoot;
	                if (root.$layer && root.$layer.is(e.relatedTarget)) {
	                    root.hovering = false;
	                }
	            },
	            // :hover done manually so key handling is possible
	            itemMouseenter: function (e) {
	                var $this = $(this),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                root.hovering = true;
	
	                // abort if we're re-entering
	                if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
	                    e.preventDefault();
	                    e.stopImmediatePropagation();
	                }
	
	                // make sure only one item is selected
	                (opt.$menu ? opt : root).$menu
	                    .children('.hover').trigger('contextmenu:blur');
	
	                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {
	                    opt.$selected = null;
	                    return;
	                }
	
	                $this.trigger('contextmenu:focus');
	            },
	            // :hover done manually so key handling is possible
	            itemMouseleave: function (e) {
	                var $this = $(this),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
	                    if (typeof root.$selected !== 'undefined' && root.$selected !== null) {
	                        root.$selected.trigger('contextmenu:blur');
	                    }
	                    e.preventDefault();
	                    e.stopImmediatePropagation();
	                    root.$selected = opt.$selected = opt.$node;
	                    return;
	                }
	
	                $this.trigger('contextmenu:blur');
	            },
	            // contextMenu item click
	            itemClick: function (e) {
	                var $this = $(this),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot,
	                    key = data.contextMenuKey,
	                    callback;
	
	                // abort if the key is unknown or disabled or is a menu
	                if (!opt.items[key] || $this.is('.' + root.classNames.disabled + ', .context-menu-submenu, .context-menu-separator, .' + root.classNames.notSelectable)) {
	                    return;
	                }
	
	                e.preventDefault();
	                e.stopImmediatePropagation();
	
	                if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
	                    // item-specific callback
	                    callback = root.callbacks[key];
	                } else if ($.isFunction(root.callback)) {
	                    // default callback
	                    callback = root.callback;
	                } else {
	                    // no callback, no action
	                    return;
	                }
	
	                // hide menu if callback doesn't stop that
	                if (callback.call(root.$trigger, key, root) !== false) {
	                    root.$menu.trigger('contextmenu:hide');
	                } else if (root.$menu.parent().length) {
	                    op.update.call(root.$trigger, root);
	                }
	            },
	            // ignore click events on input elements
	            inputClick: function (e) {
	                e.stopImmediatePropagation();
	            },
	            // hide <menu>
	            hideMenu: function (e, data) {
	                var root = $(this).data('contextMenuRoot');
	                op.hide.call(root.$trigger, root, data && data.force);
	            },
	            // focus <command>
	            focusItem: function (e) {
	                e.stopPropagation();
	                var $this = $(this),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                $this
	                    .addClass([root.classNames.hover, root.classNames.visible].join(' '))
	                    .siblings()
	                    .removeClass(root.classNames.visible)
	                    .filter(root.classNames.hover)
	                    .trigger('contextmenu:blur');
	
	                // remember selected
	                opt.$selected = root.$selected = $this;
	
	                // position sub-menu - do after show so dumb $.ui.position can keep up
	                if (opt.$node) {
	                    root.positionSubmenu.call(opt.$node, opt.$menu);
	                }
	            },
	            // blur <command>
	            blurItem: function (e) {
	                e.stopPropagation();
	                var $this = $(this),
	                    data = $this.data(),
	                    opt = data.contextMenu,
	                    root = data.contextMenuRoot;
	
	                if (opt.autoHide) { // for tablets and touch screens this needs to remain
	                    $this.removeClass(root.classNames.visible);
	                }
	                $this.removeClass(root.classNames.hover);
	                opt.$selected = null;
	            }
	        },
	    // operations
	        op = {
	            show: function (opt, x, y) {
	                var $trigger = $(this),
	                    css = {};
	
	                // hide any open menus
	                $('#context-menu-layer').trigger('mousedown');
	
	                // backreference for callbacks
	                opt.$trigger = $trigger;
	
	                // show event
	                if (opt.events.show.call($trigger, opt) === false) {
	                    $currentTrigger = null;
	                    return;
	                }
	
	                // create or update context menu
	                op.update.call($trigger, opt);
	
	                // position menu
	                opt.position.call($trigger, opt, x, y);
	
	                // make sure we're in front
	                if (opt.zIndex) {
	                    css.zIndex = zindex($trigger) + opt.zIndex;
	                }
	
	                // add layer
	                op.layer.call(opt.$menu, opt, css.zIndex);
	
	                // adjust sub-menu zIndexes
	                opt.$menu.find('ul').css('zIndex', css.zIndex + 1);
	
	                // position and show context menu
	                opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function () {
	                    $trigger.trigger('contextmenu:visible');
	                });
	                // make options available and set state
	                $trigger
	                    .data('contextMenu', opt)
	                    .addClass('context-menu-active');
	
	                // register key handler
	                $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
	                // register autoHide handler
	                if (opt.autoHide) {
	                    // mouse position handler
	                    $(document).on('mousemove.contextMenuAutoHide', function (e) {
	                        // need to capture the offset on mousemove,
	                        // since the page might've been scrolled since activation
	                        var pos = $trigger.offset();
	                        pos.right = pos.left + $trigger.outerWidth();
	                        pos.bottom = pos.top + $trigger.outerHeight();
	
	                        if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
	                            // if mouse in menu...
	                            opt.$menu.trigger('contextmenu:hide');
	                        }
	                    });
	                }
	            },
	            hide: function (opt, force) {
	                var $trigger = $(this);
	                if (!opt) {
	                    opt = $trigger.data('contextMenu') || {};
	                }
	
	                // hide event
	                if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
	                    return;
	                }
	
	                // remove options and revert state
	                $trigger
	                    .removeData('contextMenu')
	                    .removeClass('context-menu-active');
	
	                if (opt.$layer) {
	                    // keep layer for a bit so the contextmenu event can be aborted properly by opera
	                    setTimeout((function ($layer) {
	                        return function () {
	                            $layer.remove();
	                        };
	                    })(opt.$layer), 10);
	
	                    try {
	                        delete opt.$layer;
	                    } catch (e) {
	                        opt.$layer = null;
	                    }
	                }
	
	                // remove handle
	                $currentTrigger = null;
	                // remove selected
	                opt.$menu.find('.' + opt.classNames.hover).trigger('contextmenu:blur');
	                opt.$selected = null;
	                // unregister key and mouse handlers
	                // $(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
	                $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
	                // hide menu
	                opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function () {
	                    // tear down dynamically built menu after animation is completed.
	                    if (opt.build) {
	                        opt.$menu.remove();
	                        $.each(opt, function (key) {
	                            switch (key) {
	                                case 'ns':
	                                case 'selector':
	                                case 'build':
	                                case 'trigger':
	                                    return true;
	
	                                default:
	                                    opt[key] = undefined;
	                                    try {
	                                        delete opt[key];
	                                    } catch (e) {
	                                    }
	                                    return true;
	                            }
	                        });
	                    }
	
	                    setTimeout(function () {
	                        $trigger.trigger('contextmenu:hidden');
	                    }, 10);
	                });
	            },
	            create: function (opt, root) {
	                if (root === undefined) {
	                    root = opt;
	                }
	                // create contextMenu
	                opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || '').data({
	                    'contextMenu': opt,
	                    'contextMenuRoot': root
	                });
	
	                $.each(['callbacks', 'commands', 'inputs'], function (i, k) {
	                    opt[k] = {};
	                    if (!root[k]) {
	                        root[k] = {};
	                    }
	                });
	
	                root.accesskeys || (root.accesskeys = {});
	
	                function createNameNode(item) {
	                    var $name = $('<span></span>');
	                    if (item._accesskey) {
	                        if (item._beforeAccesskey) {
	                            $name.append(document.createTextNode(item._beforeAccesskey));
	                        }
	                        $('<span></span>')
	                            .addClass('context-menu-accesskey')
	                            .text(item._accesskey)
	                            .appendTo($name);
	                        if (item._afterAccesskey) {
	                            $name.append(document.createTextNode(item._afterAccesskey));
	                        }
	                    } else {
	                        $name.text(item.name);
	                    }
	                    return $name;
	                }
	
	                // create contextMenu items
	                $.each(opt.items, function (key, item) {
	                    var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ''),
	                        $label = null,
	                        $input = null;
	
	                    // iOS needs to see a click-event bound to an element to actually
	                    // have the TouchEvents infrastructure trigger the click event
	                    $t.on('click', $.noop);
	
	                    // Make old school string seperator a real item so checks wont be
	                    // akward later.
	                    if (typeof item === 'string') {
	                        item = { type : 'cm_seperator' };
	                    }
	
	                    item.$node = $t.data({
	                        'contextMenu': opt,
	                        'contextMenuRoot': root,
	                        'contextMenuKey': key
	                    });
	
	                    // register accesskey
	                    // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
	                    if (typeof item.accesskey !== 'undefined') {
	                        var aks = splitAccesskey(item.accesskey);
	                        for (var i = 0, ak; ak = aks[i]; i++) {
	                            if (!root.accesskeys[ak]) {
	                                root.accesskeys[ak] = item;
	                                var matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i'));
	                                if (matched) {
	                                    item._beforeAccesskey = matched[1];
	                                    item._accesskey = matched[2];
	                                    item._afterAccesskey = matched[3];
	                                }
	                                break;
	                            }
	                        }
	                    }
	
	                    if (item.type && types[item.type]) {
	                        // run custom type handler
	                        types[item.type].call($t, item, opt, root);
	                        // register commands
	                        $.each([opt, root], function (i, k) {
	                            k.commands[key] = item;
	                            if ($.isFunction(item.callback)) {
	                                k.callbacks[key] = item.callback;
	                            }
	                        });
	                    } else {
	                        // add label for input
	                        if (item.type === 'cm_seperator') {
	                            $t.addClass('context-menu-separator ' + root.classNames.notSelectable);
	                        } else if (item.type === 'html') {
	                            $t.addClass('context-menu-html ' + root.classNames.notSelectable);
	                        } else if (item.type) {
	                            $label = $('<label></label>').appendTo($t);
	                            createNameNode(item).appendTo($t);
	
	                            $t.addClass('context-menu-input');
	                            opt.hasTypes = true;
	                            $.each([opt, root], function (i, k) {
	                                k.commands[key] = item;
	                                k.inputs[key] = item;
	                            });
	                        } else if (item.items) {
	                            item.type = 'sub';
	                        }
	
	                        switch (item.type) {
	                            case 'seperator':
	                                break;
	
	                            case 'text':
	                                $input = $('<input type="text" value="1" name="" value="">')
	                                    .attr('name', 'context-menu-input-' + key)
	                                    .val(item.value || '')
	                                    .appendTo($label);
	                                break;
	
	                            case 'textarea':
	                                $input = $('<textarea name=""></textarea>')
	                                    .attr('name', 'context-menu-input-' + key)
	                                    .val(item.value || '')
	                                    .appendTo($label);
	
	                                if (item.height) {
	                                    $input.height(item.height);
	                                }
	                                break;
	
	                            case 'checkbox':
	                                $input = $('<input type="checkbox" value="1" name="" value="">')
	                                    .attr('name', 'context-menu-input-' + key)
	                                    .val(item.value || '')
	                                    .prop('checked', !!item.selected)
	                                    .prependTo($label);
	                                break;
	
	                            case 'radio':
	                                $input = $('<input type="radio" value="1" name="" value="">')
	                                    .attr('name', 'context-menu-input-' + item.radio)
	                                    .val(item.value || '')
	                                    .prop('checked', !!item.selected)
	                                    .prependTo($label);
	                                break;
	
	                            case 'select':
	                                $input = $('<select name="">')
	                                    .attr('name', 'context-menu-input-' + key)
	                                    .appendTo($label);
	                                if (item.options) {
	                                    $.each(item.options, function (value, text) {
	                                        $('<option></option>').val(value).text(text).appendTo($input);
	                                    });
	                                    $input.val(item.selected);
	                                }
	                                break;
	
	                            case 'sub':
	                                createNameNode(item).appendTo($t);
	
	                                item.appendTo = item.$node;
	                                op.create(item, root);
	                                $t.data('contextMenu', item).addClass('context-menu-submenu');
	                                item.callback = null;
	                                break;
	
	                            case 'html':
	                                $(item.html).appendTo($t);
	                                break;
	
	                            default:
	                                $.each([opt, root], function (i, k) {
	                                    k.commands[key] = item;
	                                    if ($.isFunction(item.callback)) {
	                                        k.callbacks[key] = item.callback;
	                                    }
	                                });
	                                createNameNode(item).appendTo($t);
	                                break;
	                        }
	
	                        // disable key listener in <input>
	                        if (item.type && item.type !== 'sub' && item.type !== 'html' && item.type !== 'cm_seperator') {
	                            $input
	                                .on('focus', handle.focusInput)
	                                .on('blur', handle.blurInput);
	
	                            if (item.events) {
	                                $input.on(item.events, opt);
	                            }
	                        }
	
	                        // add icons
	                        if (item.icon) {
	                            if ($.isFunction(item.icon)) {
	                                item._icon = item.icon.call(this, $t, key, item);
	                            } else {
	                                item._icon = root.classNames.icon + ' ' + root.classNames.icon + '-' + item.icon;
	
	                            }
	                            $t.addClass(item._icon);
	                        }
	                    }
	
	                    // cache contained elements
	                    item.$input = $input;
	                    item.$label = $label;
	
	                    // attach item to menu
	                    $t.appendTo(opt.$menu);
	
	                    // Disable text selection
	                    if (!opt.hasTypes && $.support.eventSelectstart) {
	                        // browsers support user-select: none,
	                        // IE has a special event for text-selection
	                        // browsers supporting neither will not be preventing text-selection
	                        $t.on('selectstart.disableTextSelect', handle.abortevent);
	                    }
	                });
	                // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
	                if (!opt.$node) {
	                    opt.$menu.css('display', 'none').addClass('context-menu-root');
	                }
	                opt.$menu.appendTo(opt.appendTo || document.body);
	            },
	            resize: function ($menu, nested) {
	                // determine widths of submenus, as CSS won't grow them automatically
	                // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
	                // kinda sucks hard...
	
	                // determine width of absolutely positioned element
	                $menu.css({position: 'absolute', display: 'block'});
	                // don't apply yet, because that would break nested elements' widths
	                $menu.data('width', Math.ceil($menu.width()));
	                // reset styles so they allow nested elements to grow/shrink naturally
	                $menu.css({
	                    position: 'static',
	                    minWidth: '0px',
	                    maxWidth: '100000px'
	                });
	                // identify width of nested menus
	                $menu.find('> li > ul').each(function () {
	                    op.resize($(this), true);
	                });
	                // reset and apply changes in the end because nested
	                // elements' widths wouldn't be calculatable otherwise
	                if (!nested) {
	                    $menu.find('ul').addBack().css({
	                        position: '',
	                        display: '',
	                        minWidth: '',
	                        maxWidth: ''
	                    }).width(function () {
	                        return $(this).data('width');
	                    });
	                }
	            },
	            update: function (opt, root) {
	                var $trigger = this;
	                if (root === undefined) {
	                    root = opt;
	                    op.resize(opt.$menu);
	                }
	                // re-check disabled for each item
	                opt.$menu.children().each(function () {
	                    var $item = $(this),
	                        key = $item.data('contextMenuKey'),
	                        item = opt.items[key],
	                        disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true,
	                        visible;
	                    if ($.isFunction(item.visible)) {
	                        visible = item.visible.call($trigger, key, root);
	                    } else if (typeof item.visible !== 'undefined') {
	                        visible = item.visible === true;
	                    } else {
	                        visible = true;
	                    }
	                    $item[visible ? 'show' : 'hide']();
	
	                    // dis- / enable item
	                    $item[disabled ? 'addClass' : 'removeClass'](root.classNames.disabled);
	
	                    if ($.isFunction(item.icon)) {
	                        $item.removeClass(item._icon);
	                        item._icon = item.icon.call(this, $trigger, key, item);
	                        $item.addClass(item._icon);
	                    }
	
	                    if (item.type) {
	                        // dis- / enable input elements
	                        $item.find('input, select, textarea').prop('disabled', disabled);
	
	                        // update input states
	                        switch (item.type) {
	                            case 'text':
	                            case 'textarea':
	                                item.$input.val(item.value || '');
	                                break;
	
	                            case 'checkbox':
	                            case 'radio':
	                                item.$input.val(item.value || '').prop('checked', !!item.selected);
	                                break;
	
	                            case 'select':
	                                item.$input.val(item.selected || '');
	                                break;
	                        }
	                    }
	
	                    if (item.$menu) {
	                        // update sub-menu
	                        op.update.call($trigger, item, root);
	                    }
	                });
	            },
	            layer: function (opt, zIndex) {
	                // add transparent layer for click area
	                // filter and background for Internet Explorer, Issue #23
	                var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>')
	                    .css({height: $win.height(), width: $win.width(), display: 'block'})
	                    .data('contextMenuRoot', opt)
	                    .insertBefore(this)
	                    .on('contextmenu', handle.abortevent)
	                    .on('mousedown', handle.layerClick);
	
	                // IE6 doesn't know position:fixed;
	                if (document.body.style.maxWidth === undefined) { // IE6 doesn't support maxWidth
	                    $layer.css({
	                        'position': 'absolute',
	                        'height': $(document).height()
	                    });
	                }
	
	                return $layer;
	            }
	        };
	
	    // split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
	    function splitAccesskey(val) {
	        var t = val.split(/\s+/),
	            keys = [];
	
	        for (var i = 0, k; k = t[i]; i++) {
	            k = k.charAt(0).toUpperCase(); // first character only
	            // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
	            // a map to look up already used access keys would be nice
	            keys.push(k);
	        }
	
	        return keys;
	    }
	
	// handle contextMenu triggers
	    $.fn.contextMenu = function (operation) {
	        var $t = this, $o = operation;
	        if (this.length > 0) {  // this is not a build on demand menu
	            if (operation === undefined) {
	                this.first().trigger('contextmenu');
	            } else if (operation.x !== undefined && operation.y !== undefined) {
	                this.first().trigger($.Event('contextmenu', {pageX: operation.x, pageY: operation.y}));
	            } else if (operation === 'hide') {
	                var $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null;
	                $menu && $menu.trigger('contextmenu:hide');
	            } else if (operation === 'destroy') {
	                $.contextMenu('destroy', {context: this});
	            } else if ($.isPlainObject(operation)) {
	                operation.context = this;
	                $.contextMenu('create', operation);
	            } else if (operation) {
	                this.removeClass('context-menu-disabled');
	            } else if (!operation) {
	                this.addClass('context-menu-disabled');
	            }
	        } else {
	            $.each(menus, function () {
	                if (this.selector === $t.selector) {
	                    $o.data = this;
	
	                    $.extend($o.data, {trigger: 'demand'});
	                }
	            });
	
	            handle.contextmenu.call($o.target, $o);
	        }
	
	        return this;
	    };
	
	    // manage contextMenu instances
	    $.contextMenu = function (operation, options) {
	        if (typeof operation !== 'string') {
	            options = operation;
	            operation = 'create';
	        }
	
	        if (typeof options === 'string') {
	            options = {selector: options};
	        } else if (options === undefined) {
	            options = {};
	        }
	
	        // merge with default options
	        var o = $.extend(true, {}, defaults, options || {});
	        var $document = $(document);
	        var $context = $document;
	        var _hasContext = false;
	
	        if (!o.context || !o.context.length) {
	            o.context = document;
	        } else {
	            // you never know what they throw at you...
	            $context = $(o.context).first();
	            o.context = $context.get(0);
	            _hasContext = o.context !== document;
	        }
	
	        switch (operation) {
	            case 'create':
	                // no selector no joy
	                if (!o.selector) {
	                    throw new Error('No selector specified');
	                }
	                // make sure internal classes are not bound to
	                if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
	                    throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
	                }
	                if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
	                    throw new Error('No Items specified');
	                }
	                counter++;
	                o.ns = '.contextMenu' + counter;
	                if (!_hasContext) {
	                    namespaces[o.selector] = o.ns;
	                }
	                menus[o.ns] = o;
	
	                // default to right click
	                if (!o.trigger) {
	                    o.trigger = 'right';
	                }
	
	                if (!initialized) {
	                    // make sure item click is registered first
	                    $document
	                        .on({
	                            'contextmenu:hide.contextMenu': handle.hideMenu,
	                            'prevcommand.contextMenu': handle.prevItem,
	                            'nextcommand.contextMenu': handle.nextItem,
	                            'contextmenu.contextMenu': handle.abortevent,
	                            'mouseenter.contextMenu': handle.menuMouseenter,
	                            'mouseleave.contextMenu': handle.menuMouseleave
	                        }, '.context-menu-list')
	                        .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
	                        .on({
	                            'mouseup.contextMenu': handle.itemClick,
	                            'contextmenu:focus.contextMenu': handle.focusItem,
	                            'contextmenu:blur.contextMenu': handle.blurItem,
	                            'contextmenu.contextMenu': handle.abortevent,
	                            'mouseenter.contextMenu': handle.itemMouseenter,
	                            'mouseleave.contextMenu': handle.itemMouseleave
	                        }, '.context-menu-item');
	
	                    initialized = true;
	                }
	
	                // engage native contextmenu event
	                $context
	                    .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);
	
	                if (_hasContext) {
	                    // add remove hook, just in case
	                    $context.on('remove' + o.ns, function () {
	                        $(this).contextMenu('destroy');
	                    });
	                }
	
	                switch (o.trigger) {
	                    case 'hover':
	                        $context
	                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
	                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);
	                        break;
	
	                    case 'left':
	                        $context.on('click' + o.ns, o.selector, o, handle.click);
	                        break;
	                    /*
	                     default:
	                     // http://www.quirksmode.org/dom/events/contextmenu.html
	                     $document
	                     .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
	                     .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
	                     break;
	                     */
	                }
	
	                // create menu
	                if (!o.build) {
	                    op.create(o);
	                }
	                break;
	
	            case 'destroy':
	                var $visibleMenu;
	                if (_hasContext) {
	                    // get proper options
	                    var context = o.context;
	                    $.each(menus, function (ns, o) {
	                        if (o.context !== context) {
	                            return true;
	                        }
	
	                        $visibleMenu = $('.context-menu-list').filter(':visible');
	                        if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
	                            $visibleMenu.trigger('contextmenu:hide', {force: true});
	                        }
	
	                        try {
	                            if (menus[o.ns].$menu) {
	                                menus[o.ns].$menu.remove();
	                            }
	
	                            delete menus[o.ns];
	                        } catch (e) {
	                            menus[o.ns] = null;
	                        }
	
	                        $(o.context).off(o.ns);
	
	                        return true;
	                    });
	                } else if (!o.selector) {
	                    $document.off('.contextMenu .contextMenuAutoHide');
	                    $.each(menus, function (ns, o) {
	                        $(o.context).off(o.ns);
	                    });
	
	                    namespaces = {};
	                    menus = {};
	                    counter = 0;
	                    initialized = false;
	
	                    $('#context-menu-layer, .context-menu-list').remove();
	                } else if (namespaces[o.selector]) {
	                    $visibleMenu = $('.context-menu-list').filter(':visible');
	                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
	                        $visibleMenu.trigger('contextmenu:hide', {force: true});
	                    }
	
	                    try {
	                        if (menus[namespaces[o.selector]].$menu) {
	                            menus[namespaces[o.selector]].$menu.remove();
	                        }
	
	                        delete menus[namespaces[o.selector]];
	                    } catch (e) {
	                        menus[namespaces[o.selector]] = null;
	                    }
	
	                    $document.off(namespaces[o.selector]);
	                }
	                break;
	
	            case 'html5':
	                // if <command> or <menuitem> are not handled by the browser,
	                // or options was a bool true,
	                // initialize $.contextMenu for them
	                if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options === 'boolean' && options)) {
	                    $('menu[type="context"]').each(function () {
	                        if (this.id) {
	                            $.contextMenu({
	                                selector: '[contextmenu=' + this.id + ']',
	                                items: $.contextMenu.fromMenu(this)
	                            });
	                        }
	                    }).css('display', 'none');
	                }
	                break;
	
	            default:
	                throw new Error('Unknown operation "' + operation + '"');
	        }
	
	        return this;
	    };
	
	// import values into <input> commands
	    $.contextMenu.setInputValues = function (opt, data) {
	        if (data === undefined) {
	            data = {};
	        }
	
	        $.each(opt.inputs, function (key, item) {
	            switch (item.type) {
	                case 'text':
	                case 'textarea':
	                    item.value = data[key] || '';
	                    break;
	
	                case 'checkbox':
	                    item.selected = data[key] ? true : false;
	                    break;
	
	                case 'radio':
	                    item.selected = (data[item.radio] || '') === item.value;
	                    break;
	
	                case 'select':
	                    item.selected = data[key] || '';
	                    break;
	            }
	        });
	    };
	
	// export values from <input> commands
	    $.contextMenu.getInputValues = function (opt, data) {
	        if (data === undefined) {
	            data = {};
	        }
	
	        $.each(opt.inputs, function (key, item) {
	            switch (item.type) {
	                case 'text':
	                case 'textarea':
	                case 'select':
	                    data[key] = item.$input.val();
	                    break;
	
	                case 'checkbox':
	                    data[key] = item.$input.prop('checked');
	                    break;
	
	                case 'radio':
	                    if (item.$input.prop('checked')) {
	                        data[item.radio] = item.value;
	                    }
	                    break;
	            }
	        });
	
	        return data;
	    };
	
	// find <label for="xyz">
	    function inputLabel(node) {
	        return (node.id && $('label[for="' + node.id + '"]').val()) || node.name;
	    }
	
	// convert <menu> to items object
	    function menuChildren(items, $children, counter) {
	        if (!counter) {
	            counter = 0;
	        }
	
	        $children.each(function () {
	            var $node = $(this),
	                node = this,
	                nodeName = this.nodeName.toLowerCase(),
	                label,
	                item;
	
	            // extract <label><input>
	            if (nodeName === 'label' && $node.find('input, textarea, select').length) {
	                label = $node.text();
	                $node = $node.children().first();
	                node = $node.get(0);
	                nodeName = node.nodeName.toLowerCase();
	            }
	
	            /*
	             * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
	             * Not being the sadistic kind, $.contextMenu only accepts:
	             * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
	             * Everything else will be imported as an html node, which is not interfaced with contextMenu.
	             */
	
	            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
	            switch (nodeName) {
	                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
	                case 'menu':
	                    item = {name: $node.attr('label'), items: {}};
	                    counter = menuChildren(item.items, $node.children(), counter);
	                    break;
	
	                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
	                case 'a':
	                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
	                case 'button':
	                    item = {
	                        name: $node.text(),
	                        disabled: !!$node.attr('disabled'),
	                        callback: (function () {
	                            return function () {
	                                $node.click();
	                            };
	                        })()
	                    };
	                    break;
	
	                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command
	
	                case 'menuitem':
	                case 'command':
	                    switch ($node.attr('type')) {
	                        case undefined:
	                        case 'command':
	                        case 'menuitem':
	                            item = {
	                                name: $node.attr('label'),
	                                disabled: !!$node.attr('disabled'),
	                                icon: $node.attr('icon'),
	                                callback: (function () {
	                                    return function () {
	                                        $node.click();
	                                    };
	                                })()
	                            };
	                            break;
	
	                        case 'checkbox':
	                            item = {
	                                type: 'checkbox',
	                                disabled: !!$node.attr('disabled'),
	                                name: $node.attr('label'),
	                                selected: !!$node.attr('checked')
	                            };
	                            break;
	                        case 'radio':
	                            item = {
	                                type: 'radio',
	                                disabled: !!$node.attr('disabled'),
	                                name: $node.attr('label'),
	                                radio: $node.attr('radiogroup'),
	                                value: $node.attr('id'),
	                                selected: !!$node.attr('checked')
	                            };
	                            break;
	
	                        default:
	                            item = undefined;
	                    }
	                    break;
	
	                case 'hr':
	                    item = '-------';
	                    break;
	
	                case 'input':
	                    switch ($node.attr('type')) {
	                        case 'text':
	                            item = {
	                                type: 'text',
	                                name: label || inputLabel(node),
	                                disabled: !!$node.attr('disabled'),
	                                value: $node.val()
	                            };
	                            break;
	
	                        case 'checkbox':
	                            item = {
	                                type: 'checkbox',
	                                name: label || inputLabel(node),
	                                disabled: !!$node.attr('disabled'),
	                                selected: !!$node.attr('checked')
	                            };
	                            break;
	
	                        case 'radio':
	                            item = {
	                                type: 'radio',
	                                name: label || inputLabel(node),
	                                disabled: !!$node.attr('disabled'),
	                                radio: !!$node.attr('name'),
	                                value: $node.val(),
	                                selected: !!$node.attr('checked')
	                            };
	                            break;
	
	                        default:
	                            item = undefined;
	                            break;
	                    }
	                    break;
	
	                case 'select':
	                    item = {
	                        type: 'select',
	                        name: label || inputLabel(node),
	                        disabled: !!$node.attr('disabled'),
	                        selected: $node.val(),
	                        options: {}
	                    };
	                    $node.children().each(function () {
	                        item.options[this.value] = $(this).text();
	                    });
	                    break;
	
	                case 'textarea':
	                    item = {
	                        type: 'textarea',
	                        name: label || inputLabel(node),
	                        disabled: !!$node.attr('disabled'),
	                        value: $node.val()
	                    };
	                    break;
	
	                case 'label':
	                    break;
	
	                default:
	                    item = {type: 'html', html: $node.clone(true)};
	                    break;
	            }
	
	            if (item) {
	                counter++;
	                items['key' + counter] = item;
	            }
	        });
	
	        return counter;
	    }
	
	// convert html5 menu
	    $.contextMenu.fromMenu = function (element) {
	        var $this = $(element),
	            items = {};
	
	        menuChildren(items, $this.children());
	
	        return items;
	    };
	
	// make defaults accessible
	    $.contextMenu.defaults = defaults;
	    $.contextMenu.types = types;
	// export internal functions - undocumented, for hacking only!
	    $.contextMenu.handle = handle;
	    $.contextMenu.op = op;
	    $.contextMenu.menus = menus;
	
	
	});


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {/*globals define, jQuery, module, require */
	/*jslint vars:true */
	
	/**
	 * @license angular-bootstrap-datetimepicker  version: 0.3.15
	 * Copyright 2015 Knight Rider Consulting, Inc. http://www.knightrider.com
	 * License: MIT
	 */
	
	/**
	 *
	 *    @author        Dale "Ducky" Lotts
	 *    @since        2013-Jul-8
	 */
	
	(function (factory) {
	  'use strict';
	  /* istanbul ignore if */
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(209)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    /* istanbul ignore next */
	  } else if (typeof exports === 'object') {
	    module.exports = factory(require('angular'), require('moment')); // CommonJS
	  } else {
	    factory(window.angular, window.moment); // Browser global
	  }
	}(function (angular, moment) {
	  'use strict';
	  angular.module('ui.bootstrap.datetimepicker', [])
	    .constant('dateTimePickerConfig', {
	      dropdownSelector: null,
	      minuteStep: 5,
	      minView: 'minute',
	      startView: 'day'
	    })
	    .directive('datetimepicker', ['$log', 'dateTimePickerConfig', function datetimepickerDirective($log, defaultConfig) {
	
	      function DateObject() {
	
	        var tempDate = new Date();
	        var localOffset = tempDate.getTimezoneOffset() * 60000;
	        this.utcDateValue = tempDate.getTime();
	        this.selectable = true;
	
	        this.localDateValue = function () {
	          return this.utcDateValue + localOffset;
	        };
	
	        var validProperties = ['utcDateValue', 'localDateValue', 'display', 'active', 'selectable', 'past', 'future'];
	
	        for (var prop in arguments[0]) {
	          /* istanbul ignore else */
	          //noinspection JSUnfilteredForInLoop
	          if (validProperties.indexOf(prop) >= 0) {
	            //noinspection JSUnfilteredForInLoop
	            this[prop] = arguments[0][prop];
	          }
	        }
	      }
	
	      var validateConfiguration = function validateConfiguration(configuration) {
	        var validOptions = ['startView', 'minView', 'minuteStep', 'dropdownSelector'];
	
	        for (var prop in configuration) {
	          //noinspection JSUnfilteredForInLoop
	          if (validOptions.indexOf(prop) < 0) {
	            throw ('invalid option: ' + prop);
	          }
	        }
	
	        // Order of the elements in the validViews array is significant.
	        var validViews = ['minute', 'hour', 'day', 'month', 'year'];
	
	        if (validViews.indexOf(configuration.startView) < 0) {
	          throw ('invalid startView value: ' + configuration.startView);
	        }
	
	        if (validViews.indexOf(configuration.minView) < 0) {
	          throw ('invalid minView value: ' + configuration.minView);
	        }
	
	        if (validViews.indexOf(configuration.minView) > validViews.indexOf(configuration.startView)) {
	          throw ('startView must be greater than minView');
	        }
	
	        if (!angular.isNumber(configuration.minuteStep)) {
	          throw ('minuteStep must be numeric');
	        }
	        if (configuration.minuteStep <= 0 || configuration.minuteStep >= 60) {
	          throw ('minuteStep must be greater than zero and less than 60');
	        }
	        if (configuration.dropdownSelector !== null && !angular.isString(configuration.dropdownSelector)) {
	          throw ('dropdownSelector must be a string');
	        }
	
	        /* istanbul ignore next */
	        if (configuration.dropdownSelector !== null && ((typeof jQuery === 'undefined') || (typeof jQuery().dropdown !== 'function'))) {
	          $log.error('Please DO NOT specify the dropdownSelector option unless you are using jQuery AND Bootstrap.js. ' +
	          'Please include jQuery AND Bootstrap.js, or write code to close the dropdown in the on-set-time callback. \n\n' +
	          'The dropdownSelector configuration option is being removed because it will not function properly.');
	          delete configuration.dropdownSelector;
	        }
	      };
	
	      return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: '<div class="datetimepicker table-responsive">' +
	        '<table class="table table-condensed  {{ data.currentView }}-view">' +
	        '   <thead>' +
	        '       <tr>' +
	        '           <th class="left" data-ng-click="changeView(data.currentView, data.leftDate, $event)" data-ng-show="data.leftDate.selectable"><i class="glyphicon glyphicon-arrow-left"/></th>' +
	        '           <th class="switch" colspan="5" data-ng-show="data.previousViewDate.selectable" data-ng-click="changeView(data.previousView, data.previousViewDate, $event)">{{ data.previousViewDate.display }}</th>' +
	        '           <th class="right" data-ng-click="changeView(data.currentView, data.rightDate, $event)" data-ng-show="data.rightDate.selectable"><i class="glyphicon glyphicon-arrow-right"/></th>' +
	        '       </tr>' +
	        '       <tr>' +
	        '           <th class="dow" data-ng-repeat="day in data.dayNames" >{{ day }}</th>' +
	        '       </tr>' +
	        '   </thead>' +
	        '   <tbody>' +
	        '       <tr data-ng-if="data.currentView !== \'day\'" >' +
	        '           <td colspan="7" >' +
	        '              <span    class="{{ data.currentView }}" ' +
	        '                       data-ng-repeat="dateObject in data.dates"  ' +
	        '                       data-ng-class="{active: dateObject.active, past: dateObject.past, future: dateObject.future, disabled: !dateObject.selectable}" ' +
	        '                       data-ng-click="changeView(data.nextView, dateObject, $event)">{{ dateObject.display }}</span> ' +
	        '           </td>' +
	        '       </tr>' +
	        '       <tr data-ng-if="data.currentView === \'day\'" data-ng-repeat="week in data.weeks">' +
	        '           <td data-ng-repeat="dateObject in week.dates" ' +
	        '               data-ng-click="changeView(data.nextView, dateObject, $event)"' +
	        '               class="day" ' +
	        '               data-ng-class="{active: dateObject.active, past: dateObject.past, future: dateObject.future, disabled: !dateObject.selectable}" >{{ dateObject.display }}</td>' +
	        '       </tr>' +
	        '   </tbody>' +
	        '</table></div>',
	        scope: {
	          onSetTime: '&',
	          beforeRender: '&'
	        },
	        replace: true,
	        link: function link(scope, element, attrs, ngModelController) {
	
	          var directiveConfig = {};
	
	          if (attrs.datetimepickerConfig) {
	            directiveConfig = scope.$parent.$eval(attrs.datetimepickerConfig);
	          }
	
	          var configuration = {};
	
	          angular.extend(configuration, defaultConfig, directiveConfig);
	
	          validateConfiguration(configuration);
	
	          var startOfDecade = function startOfDecade(unixDate) {
	            var startYear = (parseInt(moment.utc(unixDate).year() / 10, 10) * 10);
	            return moment.utc(unixDate).year(startYear).startOf('year');
	          };
	
	          var dataFactory = {
	            year: function year(unixDate) {
	              var selectedDate = moment.utc(unixDate).startOf('year');
	              // View starts one year before the decade starts and ends one year after the decade ends
	              // i.e. passing in a date of 1/1/2013 will give a range of 2009 to 2020
	              // Truncate the last digit from the current year and subtract 1 to get the start of the decade
	              var startDecade = (parseInt(selectedDate.year() / 10, 10) * 10);
	              var startDate = moment.utc(startOfDecade(unixDate)).subtract(1, 'year').startOf('year');
	
	              var activeYear = ngModelController.$modelValue ? moment(ngModelController.$modelValue).year() : 0;
	
	              var result = {
	                'currentView': 'year',
	                'nextView': configuration.minView === 'year' ? 'setTime' : 'month',
	                'previousViewDate': new DateObject({
	                  utcDateValue: null,
	                  display: startDecade + '-' + (startDecade + 9)
	                }),
	                'leftDate': new DateObject({utcDateValue: moment.utc(startDate).subtract(9, 'year').valueOf()}),
	                'rightDate': new DateObject({utcDateValue: moment.utc(startDate).add(11, 'year').valueOf()}),
	                'dates': []
	              };
	
	              for (var i = 0; i < 12; i += 1) {
	                var yearMoment = moment.utc(startDate).add(i, 'years');
	                var dateValue = {
	                  'utcDateValue': yearMoment.valueOf(),
	                  'display': yearMoment.format('YYYY'),
	                  'past': yearMoment.year() < startDecade,
	                  'future': yearMoment.year() > startDecade + 9,
	                  'active': yearMoment.year() === activeYear
	                };
	
	                result.dates.push(new DateObject(dateValue));
	              }
	
	              return result;
	            },
	
	            month: function month(unixDate) {
	
	              var startDate = moment.utc(unixDate).startOf('year');
	              var previousViewDate = startOfDecade(unixDate);
	              var activeDate = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MMM') : 0;
	
	              var result = {
	                'previousView': 'year',
	                'currentView': 'month',
	                'nextView': configuration.minView === 'month' ? 'setTime' : 'day',
	                'previousViewDate': new DateObject({
	                  utcDateValue: previousViewDate.valueOf(),
	                  display: startDate.format('YYYY')
	                }),
	                'leftDate': new DateObject({utcDateValue: moment.utc(startDate).subtract(1, 'year').valueOf()}),
	                'rightDate': new DateObject({utcDateValue: moment.utc(startDate).add(1, 'year').valueOf()}),
	                'dates': []
	              };
	
	              for (var i = 0; i < 12; i += 1) {
	                var monthMoment = moment.utc(startDate).add(i, 'months');
	                var dateValue = {
	                  'utcDateValue': monthMoment.valueOf(),
	                  'display': monthMoment.format('MMM'),
	                  'active': monthMoment.format('YYYY-MMM') === activeDate
	                };
	
	                result.dates.push(new DateObject(dateValue));
	              }
	
	              return result;
	            },
	
	            day: function day(unixDate) {
	
	              var selectedDate = moment.utc(unixDate);
	              var startOfMonth = moment.utc(selectedDate).startOf('month');
	              var previousViewDate = moment.utc(selectedDate).startOf('year');
	              var endOfMonth = moment.utc(selectedDate).endOf('month');
	
	              var startDate = moment.utc(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
	
	              var activeDate = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MMM-DD') : '';
	
	              var result = {
	                'previousView': 'month',
	                'currentView': 'day',
	                'nextView': configuration.minView === 'day' ? 'setTime' : 'hour',
	                'previousViewDate': new DateObject({
	                  utcDateValue: previousViewDate.valueOf(),
	                  display: startOfMonth.format('YYYY-MMM')
	                }),
	                'leftDate': new DateObject({utcDateValue: moment.utc(startOfMonth).subtract(1, 'months').valueOf()}),
	                'rightDate': new DateObject({utcDateValue: moment.utc(startOfMonth).add(1, 'months').valueOf()}),
	                'dayNames': [],
	                'weeks': []
	              };
	
	
	              for (var dayNumber = 0; dayNumber < 7; dayNumber += 1) {
	                result.dayNames.push(moment.utc().weekday(dayNumber).format('dd'));
	              }
	
	              for (var i = 0; i < 6; i += 1) {
	                var week = {dates: []};
	                for (var j = 0; j < 7; j += 1) {
	                  var monthMoment = moment.utc(startDate).add((i * 7) + j, 'days');
	                  var dateValue = {
	                    'utcDateValue': monthMoment.valueOf(),
	                    'display': monthMoment.format('D'),
	                    'active': monthMoment.format('YYYY-MMM-DD') === activeDate,
	                    'past': monthMoment.isBefore(startOfMonth),
	                    'future': monthMoment.isAfter(endOfMonth)
	                  };
	                  week.dates.push(new DateObject(dateValue));
	                }
	                result.weeks.push(week);
	              }
	
	              return result;
	            },
	
	            hour: function hour(unixDate) {
	              var selectedDate = moment.utc(unixDate).startOf('day');
	              var previousViewDate = moment.utc(selectedDate).startOf('month');
	
	              var activeFormat = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MM-DD H') : '';
	
	              var result = {
	                'previousView': 'day',
	                'currentView': 'hour',
	                'nextView': configuration.minView === 'hour' ? 'setTime' : 'minute',
	                'previousViewDate': new DateObject({
	                  utcDateValue: previousViewDate.valueOf(),
	                  display: selectedDate.format('ll')
	                }),
	                'leftDate': new DateObject({utcDateValue: moment.utc(selectedDate).subtract(1, 'days').valueOf()}),
	                'rightDate': new DateObject({utcDateValue: moment.utc(selectedDate).add(1, 'days').valueOf()}),
	                'dates': []
	              };
	
	              for (var i = 0; i < 24; i += 1) {
	                var hourMoment = moment.utc(selectedDate).add(i, 'hours');
	                var dateValue = {
	                  'utcDateValue': hourMoment.valueOf(),
	                  'display': hourMoment.format('LT'),
	                  'active': hourMoment.format('YYYY-MM-DD H') === activeFormat
	                };
	
	                result.dates.push(new DateObject(dateValue));
	              }
	
	              return result;
	            },
	
	            minute: function minute(unixDate) {
	              var selectedDate = moment.utc(unixDate).startOf('hour');
	              var previousViewDate = moment.utc(selectedDate).startOf('day');
	              var activeFormat = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MM-DD H:mm') : '';
	
	              var result = {
	                'previousView': 'hour',
	                'currentView': 'minute',
	                'nextView': 'setTime',
	                'previousViewDate': new DateObject({
	                  utcDateValue: previousViewDate.valueOf(),
	                  display: selectedDate.format('lll')
	                }),
	                'leftDate': new DateObject({utcDateValue: moment.utc(selectedDate).subtract(1, 'hours').valueOf()}),
	                'rightDate': new DateObject({utcDateValue: moment.utc(selectedDate).add(1, 'hours').valueOf()}),
	                'dates': []
	              };
	
	              var limit = 60 / configuration.minuteStep;
	
	              for (var i = 0; i < limit; i += 1) {
	                var hourMoment = moment.utc(selectedDate).add(i * configuration.minuteStep, 'minute');
	                var dateValue = {
	                  'utcDateValue': hourMoment.valueOf(),
	                  'display': hourMoment.format('LT'),
	                  'active': hourMoment.format('YYYY-MM-DD H:mm') === activeFormat
	                };
	
	                result.dates.push(new DateObject(dateValue));
	              }
	
	              return result;
	            },
	
	            setTime: function setTime(unixDate) {
	              var tempDate = new Date(unixDate);
	              var newDate = new Date(tempDate.getTime() + (tempDate.getTimezoneOffset() * 60000));
	
	              var oldDate = ngModelController.$modelValue;
	              ngModelController.$setViewValue(newDate);
	
	              if (configuration.dropdownSelector) {
	                jQuery(configuration.dropdownSelector).dropdown('toggle');
	              }
	
	              scope.onSetTime({newDate: newDate, oldDate: oldDate});
	
	              return dataFactory[configuration.startView](unixDate);
	            }
	          };
	
	          var getUTCTime = function getUTCTime(modelValue) {
	            var tempDate = (modelValue ? moment(modelValue).toDate() : new Date());
	            return tempDate.getTime() - (tempDate.getTimezoneOffset() * 60000);
	          };
	
	          scope.changeView = function changeView(viewName, dateObject, event) {
	            if (event) {
	              event.stopPropagation();
	              event.preventDefault();
	            }
	
	            if (viewName && (dateObject.utcDateValue > -Infinity) && dateObject.selectable && dataFactory[viewName]) {
	              var result = dataFactory[viewName](dateObject.utcDateValue);
	
	              var weekDates = [];
	              if (result.weeks) {
	                for (var i = 0; i < result.weeks.length; i += 1) {
	                  var week = result.weeks[i];
	                  for (var j = 0; j < week.dates.length; j += 1) {
	                    var weekDate = week.dates[j];
	                    weekDates.push(weekDate);
	                  }
	                }
	              }
	
	              scope.beforeRender({
	                $view: result.currentView,
	                $dates: result.dates || weekDates,
	                $leftDate: result.leftDate,
	                $upDate: result.previousViewDate,
	                $rightDate: result.rightDate
	              });
	
	              scope.data = result;
	            }
	          };
	
	          ngModelController.$render = function $render() {
	            scope.changeView(configuration.startView, new DateObject({utcDateValue: getUTCTime(ngModelController.$viewValue)}));
	          };
	        }
	      };
	    }]);
	}));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 339 */
/***/ function(module, exports) {

	/**
	 * ng-context-menu - v1.0.1 - An AngularJS directive to display a context menu
	 * when a right-click event is triggered
	 *
	 * @author Ian Kennington Walter (http://ianvonwalter.com)
	 */
	angular
	  .module('ng-context-menu', [])
	  .factory('ContextMenuService', function() {
	    return {
	      element: null,
	      menuElement: null
	    };
	  })
	  .directive('contextMenu', [
	    '$document',
	    'ContextMenuService',
	    function($document, ContextMenuService) {
	      return {
	        restrict: 'A',
	        scope: {
	          'callback': '&contextMenu',
	          'disabled': '&contextMenuDisabled',
	          'closeCallback': '&contextMenuClose'
	        },
	        link: function($scope, $element, $attrs) {
	          var opened = false;
	
	          function open(event, menuElement) {
	            menuElement.addClass('open');
	
	            var doc = $document[0].documentElement;
	            var docLeft = (window.pageXOffset || doc.scrollLeft) -
	                          (doc.clientLeft || 0),
	                docTop = (window.pageYOffset || doc.scrollTop) -
	                         (doc.clientTop || 0),
	                elementWidth = menuElement[0].scrollWidth,
	                elementHeight = menuElement[0].scrollHeight;
	            var docWidth = doc.clientWidth + docLeft,
	              docHeight = doc.clientHeight + docTop,
	              totalWidth = elementWidth + event.pageX,
	              totalHeight = elementHeight + event.pageY,
	              left = Math.max(event.pageX - docLeft, 0),
	              top = Math.max(event.pageY - docTop, 0);
	
	            if (totalWidth > docWidth) {
	              left = left - (totalWidth - docWidth);
	            }
	
	            if (totalHeight > docHeight) {
	              top = top - (totalHeight - docHeight);
	            }
	
	            menuElement.css('top', top + 'px');
	            menuElement.css('left', left + 'px');
	            opened = true;
	          }
	
	          function close(menuElement) {
	            menuElement.removeClass('open');
	
	            if (opened) {
	              $scope.closeCallback();
	            }
	
	            opened = false;
	          }
	
	          $element.bind('contextmenu', function(event) {
	            if (!$scope.disabled()) {
	              if (ContextMenuService.menuElement !== null) {
	                close(ContextMenuService.menuElement);
	              }
	              ContextMenuService.menuElement = angular.element(
	                document.getElementById($attrs.target)
	              );
	              ContextMenuService.element = event.target;
	              //console.log('set', ContextMenuService.element);
	
	              event.preventDefault();
	              event.stopPropagation();
	              $scope.$apply(function() {
	                $scope.callback({ $event: event });
	              });
	              $scope.$apply(function() {
	                open(event, ContextMenuService.menuElement);
	              });
	            }
	          });
	
	          function handleKeyUpEvent(event) {
	            //console.log('keyup');
	            if (!$scope.disabled() && opened && event.keyCode === 27) {
	              $scope.$apply(function() {
	                close(ContextMenuService.menuElement);
	              });
	            }
	          }
	
	          function handleClickEvent(event) {
	            if (!$scope.disabled() &&
	              opened &&
	              (event.button !== 2 ||
	               event.target !== ContextMenuService.element)) {
	              $scope.$apply(function() {
	                close(ContextMenuService.menuElement);
	              });
	            }
	          }
	
	          $document.bind('keyup', handleKeyUpEvent);
	          // Firefox treats a right-click as a click and a contextmenu event
	          // while other browsers just treat it as a contextmenu event
	          $document.bind('click', handleClickEvent);
	          $document.bind('contextmenu', handleClickEvent);
	
	          $scope.$on('$destroy', function() {
	            //console.log('destroy');
	            $document.unbind('keyup', handleKeyUpEvent);
	            $document.unbind('click', handleClickEvent);
	            $document.unbind('contextmenu', handleClickEvent);
	          });
	        }
	      };
	    }
	  ]);


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var jQuery = __webpack_require__(2);
	
	/*! jQuery UI - v1.10.3 - 2013-05-03
	* http://jqueryui.com
	* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
	* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
	(function( $, undefined ) {
	
	var uuid = 0,
		runiqueId = /^ui-id-\d+$/;
	
	// $.ui might exist from components with no dependencies, e.g., $.ui.position
	$.ui = $.ui || {};
	
	$.extend( $.ui, {
		version: "1.10.3",
	
		keyCode: {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			LEFT: 37,
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		}
	});
	
	// plugins
	$.fn.extend({
		focus: (function( orig ) {
			return function( delay, fn ) {
				return typeof delay === "number" ?
					this.each(function() {
						var elem = this;
						setTimeout(function() {
							$( elem ).focus();
							if ( fn ) {
								fn.call( elem );
							}
						}, delay );
					}) :
					orig.apply( this, arguments );
			};
		})( $.fn.focus ),
	
		scrollParent: function() {
			var scrollParent;
			if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
				scrollParent = this.parents().filter(function() {
					return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
				}).eq(0);
			} else {
				scrollParent = this.parents().filter(function() {
					return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
				}).eq(0);
			}
	
			return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
		},
	
		zIndex: function( zIndex ) {
			if ( zIndex !== undefined ) {
				return this.css( "zIndex", zIndex );
			}
	
			if ( this.length ) {
				var elem = $( this[ 0 ] ), position, value;
				while ( elem.length && elem[ 0 ] !== document ) {
					// Ignore z-index if position is set to a value where z-index is ignored by the browser
					// This makes behavior of this function consistent across browsers
					// WebKit always returns auto if the element is positioned
					position = elem.css( "position" );
					if ( position === "absolute" || position === "relative" || position === "fixed" ) {
						// IE returns 0 when zIndex is not specified
						// other browsers return a string
						// we ignore the case of nested elements with an explicit value of 0
						// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
						value = parseInt( elem.css( "zIndex" ), 10 );
						if ( !isNaN( value ) && value !== 0 ) {
							return value;
						}
					}
					elem = elem.parent();
				}
			}
	
			return 0;
		},
	
		uniqueId: function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + (++uuid);
				}
			});
		},
	
		removeUniqueId: function() {
			return this.each(function() {
				if ( runiqueId.test( this.id ) ) {
					$( this ).removeAttr( "id" );
				}
			});
		}
	});
	
	// selectors
	function focusable( element, isTabIndexNotNaN ) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			map = element.parentNode;
			mapName = map.name;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap=#" + mapName + "]" )[0];
			return !!img && visible( img );
		}
		return ( /input|select|textarea|button|object/.test( nodeName ) ?
			!element.disabled :
			"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible( element );
	}
	
	function visible( element ) {
		return $.expr.filters.visible( element ) &&
			!$( element ).parents().addBack().filter(function() {
				return $.css( this, "visibility" ) === "hidden";
			}).length;
	}
	
	$.extend( $.expr[ ":" ], {
		data: $.expr.createPseudo ?
			$.expr.createPseudo(function( dataName ) {
				return function( elem ) {
					return !!$.data( elem, dataName );
				};
			}) :
			// support: jQuery <1.8
			function( elem, i, match ) {
				return !!$.data( elem, match[ 3 ] );
			},
	
		focusable: function( element ) {
			return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
		},
	
		tabbable: function( element ) {
			var tabIndex = $.attr( element, "tabindex" ),
				isTabIndexNaN = isNaN( tabIndex );
			return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
		}
	});
	
	// support: jQuery <1.8
	if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
		$.each( [ "Width", "Height" ], function( i, name ) {
			var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
				type = name.toLowerCase(),
				orig = {
					innerWidth: $.fn.innerWidth,
					innerHeight: $.fn.innerHeight,
					outerWidth: $.fn.outerWidth,
					outerHeight: $.fn.outerHeight
				};
	
			function reduce( elem, size, border, margin ) {
				$.each( side, function() {
					size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
					if ( border ) {
						size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
					}
					if ( margin ) {
						size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
					}
				});
				return size;
			}
	
			$.fn[ "inner" + name ] = function( size ) {
				if ( size === undefined ) {
					return orig[ "inner" + name ].call( this );
				}
	
				return this.each(function() {
					$( this ).css( type, reduce( this, size ) + "px" );
				});
			};
	
			$.fn[ "outer" + name] = function( size, margin ) {
				if ( typeof size !== "number" ) {
					return orig[ "outer" + name ].call( this, size );
				}
	
				return this.each(function() {
					$( this).css( type, reduce( this, size, true, margin ) + "px" );
				});
			};
		});
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
	if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
		$.fn.removeData = (function( removeData ) {
			return function( key ) {
				if ( arguments.length ) {
					return removeData.call( this, $.camelCase( key ) );
				} else {
					return removeData.call( this );
				}
			};
		})( $.fn.removeData );
	}
	
	
	
	
	
	// deprecated
	$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
	
	$.support.selectstart = "onselectstart" in document.createElement( "div" );
	$.fn.extend({
		disableSelection: function() {
			return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
				".ui-disableSelection", function( event ) {
					event.preventDefault();
				});
		},
	
		enableSelection: function() {
			return this.unbind( ".ui-disableSelection" );
		}
	});
	
	$.extend( $.ui, {
		// $.ui.plugin is deprecated. Use $.widget() extensions instead.
		plugin: {
			add: function( module, option, set ) {
				var i,
					proto = $.ui[ module ].prototype;
				for ( i in set ) {
					proto.plugins[ i ] = proto.plugins[ i ] || [];
					proto.plugins[ i ].push( [ option, set[ i ] ] );
				}
			},
			call: function( instance, name, args ) {
				var i,
					set = instance.plugins[ name ];
				if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
					return;
				}
	
				for ( i = 0; i < set.length; i++ ) {
					if ( instance.options[ set[ i ][ 0 ] ] ) {
						set[ i ][ 1 ].apply( instance.element, args );
					}
				}
			}
		},
	
		// only used by resizable
		hasScroll: function( el, a ) {
	
			//If overflow is hidden, the element might have extra content, but the user wants to hide it
			if ( $( el ).css( "overflow" ) === "hidden") {
				return false;
			}
	
			var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
				has = false;
	
			if ( el[ scroll ] > 0 ) {
				return true;
			}
	
			// TODO: determine which cases actually cause this to happen
			// if the element doesn't have the scroll set, see if it's possible to
			// set the scroll
			el[ scroll ] = 1;
			has = ( el[ scroll ] > 0 );
			el[ scroll ] = 0;
			return has;
		}
	});
	
	})( jQuery );
	
	(function( $, undefined ) {
	
	var uuid = 0,
		slice = Array.prototype.slice,
		_cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
	
	$.widget = function( name, base, prototype ) {
		var fullName, existingConstructor, constructor, basePrototype,
			// proxiedPrototype allows the provided prototype to remain unmodified
			// so that it can be used as a mixin for multiple widgets (#8876)
			proxiedPrototype = {},
			namespace = name.split( "." )[ 0 ];
	
		name = name.split( "." )[ 1 ];
		fullName = namespace + "-" + name;
	
		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}
	
		// create selector for plugin
		$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};
	
		$[ namespace ] = $[ namespace ] || {};
		existingConstructor = $[ namespace ][ name ];
		constructor = $[ namespace ][ name ] = function( options, element ) {
			// allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}
	
			// allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		// extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,
			// copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend( {}, prototype ),
			// track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		});
	
		basePrototype = new base();
		// we need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;
	
					this._super = _super;
					this._superApply = _superApply;
	
					returnValue = value.apply( this, arguments );
	
					this._super = __super;
					this._superApply = __superApply;
	
					return returnValue;
				};
			})();
		});
		constructor.prototype = $.widget.extend( basePrototype, {
			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		});
	
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;
	
				// redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
			});
			// remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push( constructor );
		}
	
		$.widget.bridge( name, constructor );
	};
	
	$.widget.extend = function( target ) {
		var input = slice.call( arguments, 1 ),
			inputIndex = 0,
			inputLength = input.length,
			key,
			value;
		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :
							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );
					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};
	
	$.widget.bridge = function( name, object ) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[ name ] = function( options ) {
			var isMethodCall = typeof options === "string",
				args = slice.call( arguments, 1 ),
				returnValue = this;
	
			// allow multiple hashes to be passed on init
			options = !isMethodCall && args.length ?
				$.widget.extend.apply( null, [ options ].concat(args) ) :
				options;
	
			if ( isMethodCall ) {
				this.each(function() {
					var methodValue,
						instance = $.data( this, fullName );
					if ( !instance ) {
						return $.error( "cannot call methods on " + name + " prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}
					if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name + " widget instance" );
					}
					methodValue = instance[ options ].apply( instance, args );
					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				});
			} else {
				this.each(function() {
					var instance = $.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} )._init();
					} else {
						$.data( this, fullName, new object( options, this ) );
					}
				});
			}
	
			return returnValue;
		};
	};
	
	$.Widget = function( /* options, element */ ) {};
	$.Widget._childConstructors = [];
	
	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			disabled: false,
	
			// callbacks
			create: null
		},
		_createWidget: function( options, element ) {
			element = $( element || this.defaultElement || this )[ 0 ];
			this.element = $( element );
			this.uuid = uuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;
			this.options = $.widget.extend( {},
				this.options,
				this._getCreateOptions(),
				options );
	
			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();
	
			if ( element !== this ) {
				$.data( element, this.widgetFullName, this );
				this._on( true, this.element, {
					remove: function( event ) {
						if ( event.target === element ) {
							this.destroy();
						}
					}
				});
				this.document = $( element.style ?
					// element within the document
					element.ownerDocument :
					// element is window or document
					element.document || element );
				this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
			}
	
			this._create();
			this._trigger( "create", null, this._getCreateEventData() );
			this._init();
		},
		_getCreateOptions: $.noop,
		_getCreateEventData: $.noop,
		_create: $.noop,
		_init: $.noop,
	
		destroy: function() {
			this._destroy();
			// we can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element
				.unbind( this.eventNamespace )
				// 1.9 BC for #7810
				// TODO remove dual storage
				.removeData( this.widgetName )
				.removeData( this.widgetFullName )
				// support: jquery <1.6.3
				// http://bugs.jquery.com/ticket/9413
				.removeData( $.camelCase( this.widgetFullName ) );
			this.widget()
				.unbind( this.eventNamespace )
				.removeAttr( "aria-disabled" )
				.removeClass(
					this.widgetFullName + "-disabled " +
					"ui-state-disabled" );
	
			// clean up events and states
			this.bindings.unbind( this.eventNamespace );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		},
		_destroy: $.noop,
	
		widget: function() {
			return this.element;
		},
	
		option: function( key, value ) {
			var options = key,
				parts,
				curOption,
				i;
	
			if ( arguments.length === 0 ) {
				// don't return a reference to the internal hash
				return $.widget.extend( {}, this.options );
			}
	
			if ( typeof key === "string" ) {
				// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split( "." );
				key = parts.shift();
				if ( parts.length ) {
					curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
					for ( i = 0; i < parts.length - 1; i++ ) {
						curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
						curOption = curOption[ parts[ i ] ];
					}
					key = parts.pop();
					if ( value === undefined ) {
						return curOption[ key ] === undefined ? null : curOption[ key ];
					}
					curOption[ key ] = value;
				} else {
					if ( value === undefined ) {
						return this.options[ key ] === undefined ? null : this.options[ key ];
					}
					options[ key ] = value;
				}
			}
	
			this._setOptions( options );
	
			return this;
		},
		_setOptions: function( options ) {
			var key;
	
			for ( key in options ) {
				this._setOption( key, options[ key ] );
			}
	
			return this;
		},
		_setOption: function( key, value ) {
			this.options[ key ] = value;
	
			if ( key === "disabled" ) {
				this.widget()
					.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
					.attr( "aria-disabled", value );
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
	
			return this;
		},
	
		enable: function() {
			return this._setOption( "disabled", false );
		},
		disable: function() {
			return this._setOption( "disabled", true );
		},
	
		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement,
				instance = this;
	
			// no suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}
	
			// no element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				// accept selectors, DOM elements
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}
	
			$.each( handlers, function( event, handler ) {
				function handlerProxy() {
					// allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
								$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}
	
				// copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}
	
				var match = event.match( /^(\w+)\s*(.*)$/ ),
					eventName = match[1] + instance.eventNamespace,
					selector = match[2];
				if ( selector ) {
					delegateElement.delegate( selector, eventName, handlerProxy );
				} else {
					element.bind( eventName, handlerProxy );
				}
			});
		},
	
		_off: function( element, eventName ) {
			eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
			element.unbind( eventName ).undelegate( eventName );
		},
	
		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},
	
		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-hover" );
				},
				mouseleave: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-hover" );
				}
			});
		},
	
		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-focus" );
				},
				focusout: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-focus" );
				}
			});
		},
	
		_trigger: function( type, event, data ) {
			var prop, orig,
				callback = this.options[ type ];
	
			data = data || {};
			event = $.Event( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();
			// the original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];
	
			// copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}
	
			this.element.trigger( event, data );
			return !( $.isFunction( callback ) &&
				callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}
	};
	
	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}
			var hasOptions,
				effectName = !options ?
					method :
					options === true || typeof options === "number" ?
						defaultEffect :
						options.effect || defaultEffect;
			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}
			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;
			if ( options.delay ) {
				element.delay( options.delay );
			}
			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue(function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				});
			}
		};
	});
	
	})( jQuery );
	
	(function( $, undefined ) {
	
	var mouseHandled = false;
	$( document ).mouseup( function() {
		mouseHandled = false;
	});
	
	$.widget("ui.mouse", {
		version: "1.10.3",
		options: {
			cancel: "input,textarea,button,select,option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function() {
			var that = this;
	
			this.element
				.bind("mousedown."+this.widgetName, function(event) {
					return that._mouseDown(event);
				})
				.bind("click."+this.widgetName, function(event) {
					if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
						$.removeData(event.target, that.widgetName + ".preventClickEvent");
						event.stopImmediatePropagation();
						return false;
					}
				});
	
			this.started = false;
		},
	
		// TODO: make sure destroying one instance of mouse doesn't mess with
		// other instances of mouse
		_mouseDestroy: function() {
			this.element.unbind("."+this.widgetName);
			if ( this._mouseMoveDelegate ) {
				$(document)
					.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
					.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
			}
		},
	
		_mouseDown: function(event) {
			// don't let more than one widget handle mouseStart
			if( mouseHandled ) { return; }
	
			// we may have missed mouseup (out of window)
			(this._mouseStarted && this._mouseUp(event));
	
			this._mouseDownEvent = event;
	
			var that = this,
				btnIsLeft = (event.which === 1),
				// event.target.nodeName works around a bug in IE 8 with
				// disabled inputs (#7620)
				elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
			if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
				return true;
			}
	
			this.mouseDelayMet = !this.options.delay;
			if (!this.mouseDelayMet) {
				this._mouseDelayTimer = setTimeout(function() {
					that.mouseDelayMet = true;
				}, this.options.delay);
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted = (this._mouseStart(event) !== false);
				if (!this._mouseStarted) {
					event.preventDefault();
					return true;
				}
			}
	
			// Click event may never have fired (Gecko & Opera)
			if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
				$.removeData(event.target, this.widgetName + ".preventClickEvent");
			}
	
			// these delegates are required to keep context
			this._mouseMoveDelegate = function(event) {
				return that._mouseMove(event);
			};
			this._mouseUpDelegate = function(event) {
				return that._mouseUp(event);
			};
			$(document)
				.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.bind("mouseup."+this.widgetName, this._mouseUpDelegate);
	
			event.preventDefault();
	
			mouseHandled = true;
			return true;
		},
	
		_mouseMove: function(event) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);
			}
	
			if (this._mouseStarted) {
				this._mouseDrag(event);
				return event.preventDefault();
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted =
					(this._mouseStart(this._mouseDownEvent, event) !== false);
				(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
			}
	
			return !this._mouseStarted;
		},
	
		_mouseUp: function(event) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
	
			if (this._mouseStarted) {
				this._mouseStarted = false;
	
				if (event.target === this._mouseDownEvent.target) {
					$.data(event.target, this.widgetName + ".preventClickEvent", true);
				}
	
				this._mouseStop(event);
			}
	
			return false;
		},
	
		_mouseDistanceMet: function(event) {
			return (Math.max(
					Math.abs(this._mouseDownEvent.pageX - event.pageX),
					Math.abs(this._mouseDownEvent.pageY - event.pageY)
				) >= this.options.distance
			);
		},
	
		_mouseDelayMet: function(/* event */) {
			return this.mouseDelayMet;
		},
	
		// These are placeholder methods, to be overriden by extending plugin
		_mouseStart: function(/* event */) {},
		_mouseDrag: function(/* event */) {},
		_mouseStop: function(/* event */) {},
		_mouseCapture: function(/* event */) { return true; }
	});
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.widget("ui.draggable", $.ui.mouse, {
		version: "1.10.3",
		widgetEventPrefix: "drag",
		options: {
			addClasses: true,
			appendTo: "parent",
			axis: false,
			connectToSortable: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			grid: false,
			handle: false,
			helper: "original",
			iframeFix: false,
			opacity: false,
			refreshPositions: false,
			revert: false,
			revertDuration: 500,
			scope: "default",
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			snap: false,
			snapMode: "both",
			snapTolerance: 20,
			stack: false,
			zIndex: false,
	
			// callbacks
			drag: null,
			start: null,
			stop: null
		},
		_create: function() {
	
			if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
				this.element[0].style.position = "relative";
			}
			if (this.options.addClasses){
				this.element.addClass("ui-draggable");
			}
			if (this.options.disabled){
				this.element.addClass("ui-draggable-disabled");
			}
	
			this._mouseInit();
	
		},
	
		_destroy: function() {
			this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
			this._mouseDestroy();
		},
	
		_mouseCapture: function(event) {
	
			var o = this.options;
	
			// among others, prevent a drag on a resizable-handle
			if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
				return false;
			}
	
			//Quit if we're not on a valid handle
			this.handle = this._getHandle(event);
			if (!this.handle) {
				return false;
			}
	
			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});
	
			return true;
	
		},
	
		_mouseStart: function(event) {
	
			var o = this.options;
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			this.helper.addClass("ui-draggable-dragging");
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			//If ddmanager is used for droppables, set the global draggable
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Store the helper's css position
			this.cssPosition = this.helper.css( "position" );
			this.scrollParent = this.helper.scrollParent();
			this.offsetParent = this.helper.offsetParent();
			this.offsetParentCssPosition = this.offsetParent.css( "position" );
	
			//The element's absolute position on the page minus margins
			this.offset = this.positionAbs = this.element.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};
	
			//Reset scroll cache
			this.offset.scroll = false;
	
			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});
	
			//Generate the original position
			this.originalPosition = this.position = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Set a containment if given in the options
			this._setContainment();
	
			//Trigger event + callbacks
			if(this._trigger("start", event) === false) {
				this._clear();
				return false;
			}
	
			//Recache the helper size
			this._cacheHelperProportions();
	
			//Prepare the droppable offsets
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
	
			this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
	
			//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStart(this, event);
			}
	
			return true;
		},
	
		_mouseDrag: function(event, noPropagation) {
			// reset any necessary cached properties (see #5009)
			if ( this.offsetParentCssPosition === "fixed" ) {
				this.offset.parent = this._getParentOffset();
			}
	
			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Call plugins and callbacks and use the resulting position if something is returned
			if (!noPropagation) {
				var ui = this._uiHash();
				if(this._trigger("drag", event, ui) === false) {
					this._mouseUp({});
					return false;
				}
				this.position = ui.position;
			}
	
			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			//If we are using droppables, inform the manager about the drop
			var that = this,
				dropped = false;
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				dropped = $.ui.ddmanager.drop(this, event);
			}
	
			//if a drop comes from outside (a sortable)
			if(this.dropped) {
				dropped = this.dropped;
				this.dropped = false;
			}
	
			//if the original element is no longer in the DOM don't bother to continue (see #8269)
			if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
				return false;
			}
	
			if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
				$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
					if(that._trigger("stop", event) !== false) {
						that._clear();
					}
				});
			} else {
				if(this._trigger("stop", event) !== false) {
					this._clear();
				}
			}
	
			return false;
		},
	
		_mouseUp: function(event) {
			//Remove frame helpers
			$("div.ui-draggable-iframeFix").each(function() {
				this.parentNode.removeChild(this);
			});
	
			//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
			if( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStop(this, event);
			}
	
			return $.ui.mouse.prototype._mouseUp.call(this, event);
		},
	
		cancel: function() {
	
			if(this.helper.is(".ui-draggable-dragging")) {
				this._mouseUp({});
			} else {
				this._clear();
			}
	
			return this;
	
		},
	
		_getHandle: function(event) {
			return this.options.handle ?
				!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
				true;
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);
	
			if(!helper.parents("body").length) {
				helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
			}
	
			if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
				helper.css("position", "absolute");
			}
	
			return helper;
	
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_getParentOffset: function() {
	
			//Get the offsetParent and cache its position
			var po = this.offsetParent.offset();
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			//This needs to be actually done for all browsers, since pageX/pageY includes this information
			//Ugly IE fix
			if((this.offsetParent[0] === document.body) ||
				(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
	
			if(this.cssPosition === "relative") {
				var p = this.element.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.element.css("marginLeft"),10) || 0),
				top: (parseInt(this.element.css("marginTop"),10) || 0),
				right: (parseInt(this.element.css("marginRight"),10) || 0),
				bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var over, c, ce,
				o = this.options;
	
			if ( !o.containment ) {
				this.containment = null;
				return;
			}
	
			if ( o.containment === "window" ) {
				this.containment = [
					$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
					$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
					$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
					$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment === "document") {
				this.containment = [
					0,
					0,
					$( document ).width() - this.helperProportions.width - this.margins.left,
					( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment.constructor === Array ) {
				this.containment = o.containment;
				return;
			}
	
			if ( o.containment === "parent" ) {
				o.containment = this.helper[ 0 ].parentNode;
			}
	
			c = $( o.containment );
			ce = c[ 0 ];
	
			if( !ce ) {
				return;
			}
	
			over = c.css( "overflow" ) !== "hidden";
	
			this.containment = [
				( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
				( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
				( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
				( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;
		},
	
		_convertPositionTo: function(d, pos) {
	
			if(!pos) {
				pos = this.position;
			}
	
			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;
	
			//Cache the scroll
			if (!this.offset.scroll) {
				this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
			}
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
				)
			};
	
		},
	
		_generatePosition: function(event) {
	
			var containment, co, top, left,
				o = this.options,
				scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
				pageX = event.pageX,
				pageY = event.pageY;
	
			//Cache the scroll
			if (!this.offset.scroll) {
				this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			// If we are not dragging yet, we won't check for options
			if ( this.originalPosition ) {
				if ( this.containment ) {
					if ( this.relative_container ){
						co = this.relative_container.offset();
						containment = [
							this.containment[ 0 ] + co.left,
							this.containment[ 1 ] + co.top,
							this.containment[ 2 ] + co.left,
							this.containment[ 3 ] + co.top
						];
					}
					else {
						containment = this.containment;
					}
	
					if(event.pageX - this.offset.click.left < containment[0]) {
						pageX = containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < containment[1]) {
						pageY = containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > containment[2]) {
						pageX = containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > containment[3]) {
						pageY = containment[3] + this.offset.click.top;
					}
				}
	
				if(o.grid) {
					//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
					top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
					pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
					pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
			}
	
			return {
				top: (
					pageY -																	// The absolute mouse position
					this.offset.click.top	-												// Click offset (relative to the element)
					this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
				),
				left: (
					pageX -																	// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
				)
			};
	
		},
	
		_clear: function() {
			this.helper.removeClass("ui-draggable-dragging");
			if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
				this.helper.remove();
			}
			this.helper = null;
			this.cancelHelperRemoval = false;
		},
	
		// From now on bulk stuff - mainly helpers
	
		_trigger: function(type, event, ui) {
			ui = ui || this._uiHash();
			$.ui.plugin.call(this, type, [event, ui]);
			//The absolute position has to be recalculated after plugins
			if(type === "drag") {
				this.positionAbs = this._convertPositionTo("absolute");
			}
			return $.Widget.prototype._trigger.call(this, type, event, ui);
		},
	
		plugins: {},
	
		_uiHash: function() {
			return {
				helper: this.helper,
				position: this.position,
				originalPosition: this.originalPosition,
				offset: this.positionAbs
			};
		}
	
	});
	
	$.ui.plugin.add("draggable", "connectToSortable", {
		start: function(event, ui) {
	
			var inst = $(this).data("ui-draggable"), o = inst.options,
				uiSortable = $.extend({}, ui, { item: inst.element });
			inst.sortables = [];
			$(o.connectToSortable).each(function() {
				var sortable = $.data(this, "ui-sortable");
				if (sortable && !sortable.options.disabled) {
					inst.sortables.push({
						instance: sortable,
						shouldRevert: sortable.options.revert
					});
					sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
					sortable._trigger("activate", event, uiSortable);
				}
			});
	
		},
		stop: function(event, ui) {
	
			//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
			var inst = $(this).data("ui-draggable"),
				uiSortable = $.extend({}, ui, { item: inst.element });
	
			$.each(inst.sortables, function() {
				if(this.instance.isOver) {
	
					this.instance.isOver = 0;
	
					inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
					this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)
	
					//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
					if(this.shouldRevert) {
						this.instance.options.revert = this.shouldRevert;
					}
	
					//Trigger the stop of the sortable
					this.instance._mouseStop(event);
	
					this.instance.options.helper = this.instance.options._helper;
	
					//If the helper has been the original item, restore properties in the sortable
					if(inst.options.helper === "original") {
						this.instance.currentItem.css({ top: "auto", left: "auto" });
					}
	
				} else {
					this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
					this.instance._trigger("deactivate", event, uiSortable);
				}
	
			});
	
		},
		drag: function(event, ui) {
	
			var inst = $(this).data("ui-draggable"), that = this;
	
			$.each(inst.sortables, function() {
	
				var innermostIntersecting = false,
					thisSortable = this;
	
				//Copy over some variables to allow calling the sortable's native _intersectsWith
				this.instance.positionAbs = inst.positionAbs;
				this.instance.helperProportions = inst.helperProportions;
				this.instance.offset.click = inst.offset.click;
	
				if(this.instance._intersectsWith(this.instance.containerCache)) {
					innermostIntersecting = true;
					$.each(inst.sortables, function () {
						this.instance.positionAbs = inst.positionAbs;
						this.instance.helperProportions = inst.helperProportions;
						this.instance.offset.click = inst.offset.click;
						if (this !== thisSortable &&
							this.instance._intersectsWith(this.instance.containerCache) &&
							$.contains(thisSortable.instance.element[0], this.instance.element[0])
						) {
							innermostIntersecting = false;
						}
						return innermostIntersecting;
					});
				}
	
	
				if(innermostIntersecting) {
					//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
					if(!this.instance.isOver) {
	
						this.instance.isOver = 1;
						//Now we fake the start of dragging for the sortable instance,
						//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
						//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
						this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
						this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
						this.instance.options.helper = function() { return ui.helper[0]; };
	
						event.target = this.instance.currentItem[0];
						this.instance._mouseCapture(event, true);
						this.instance._mouseStart(event, true, true);
	
						//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
						this.instance.offset.click.top = inst.offset.click.top;
						this.instance.offset.click.left = inst.offset.click.left;
						this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
						this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
	
						inst._trigger("toSortable", event);
						inst.dropped = this.instance.element; //draggable revert needs that
						//hack so receive/update callbacks work (mostly)
						inst.currentItem = inst.element;
						this.instance.fromOutside = inst;
	
					}
	
					//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
					if(this.instance.currentItem) {
						this.instance._mouseDrag(event);
					}
	
				} else {
	
					//If it doesn't intersect with the sortable, and it intersected before,
					//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
					if(this.instance.isOver) {
	
						this.instance.isOver = 0;
						this.instance.cancelHelperRemoval = true;
	
						//Prevent reverting on this forced stop
						this.instance.options.revert = false;
	
						// The out event needs to be triggered independently
						this.instance._trigger("out", event, this.instance._uiHash(this.instance));
	
						this.instance._mouseStop(event, true);
						this.instance.options.helper = this.instance.options._helper;
	
						//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
						this.instance.currentItem.remove();
						if(this.instance.placeholder) {
							this.instance.placeholder.remove();
						}
	
						inst._trigger("fromSortable", event);
						inst.dropped = false; //draggable revert needs that
					}
	
				}
	
			});
	
		}
	});
	
	$.ui.plugin.add("draggable", "cursor", {
		start: function() {
			var t = $("body"), o = $(this).data("ui-draggable").options;
			if (t.css("cursor")) {
				o._cursor = t.css("cursor");
			}
			t.css("cursor", o.cursor);
		},
		stop: function() {
			var o = $(this).data("ui-draggable").options;
			if (o._cursor) {
				$("body").css("cursor", o._cursor);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "opacity", {
		start: function(event, ui) {
			var t = $(ui.helper), o = $(this).data("ui-draggable").options;
			if(t.css("opacity")) {
				o._opacity = t.css("opacity");
			}
			t.css("opacity", o.opacity);
		},
		stop: function(event, ui) {
			var o = $(this).data("ui-draggable").options;
			if(o._opacity) {
				$(ui.helper).css("opacity", o._opacity);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "scroll", {
		start: function() {
			var i = $(this).data("ui-draggable");
			if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
				i.overflowOffset = i.scrollParent.offset();
			}
		},
		drag: function( event ) {
	
			var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;
	
			if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
	
				if(!o.axis || o.axis !== "x") {
					if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
						i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
					}
				}
	
				if(!o.axis || o.axis !== "y") {
					if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
						i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
				}
	
			} else {
	
				if(!o.axis || o.axis !== "x") {
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}
				}
	
				if(!o.axis || o.axis !== "y") {
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}
				}
	
			}
	
			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(i, event);
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "snap", {
		start: function() {
	
			var i = $(this).data("ui-draggable"),
				o = i.options;
	
			i.snapElements = [];
	
			$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
				var $t = $(this),
					$o = $t.offset();
				if(this !== i.element[0]) {
					i.snapElements.push({
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					});
				}
			});
	
		},
		drag: function(event, ui) {
	
			var ts, bs, ls, rs, l, r, t, b, i, first,
				inst = $(this).data("ui-draggable"),
				o = inst.options,
				d = o.snapTolerance,
				x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
				y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
	
			for (i = inst.snapElements.length - 1; i >= 0; i--){
	
				l = inst.snapElements[i].left;
				r = l + inst.snapElements[i].width;
				t = inst.snapElements[i].top;
				b = t + inst.snapElements[i].height;
	
				if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
					if(inst.snapElements[i].snapping) {
						(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
					}
					inst.snapElements[i].snapping = false;
					continue;
				}
	
				if(o.snapMode !== "inner") {
					ts = Math.abs(t - y2) <= d;
					bs = Math.abs(b - y1) <= d;
					ls = Math.abs(l - x2) <= d;
					rs = Math.abs(r - x1) <= d;
					if(ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
					}
					if(bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
					}
					if(ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
					}
					if(rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
					}
				}
	
				first = (ts || bs || ls || rs);
	
				if(o.snapMode !== "outer") {
					ts = Math.abs(t - y1) <= d;
					bs = Math.abs(b - y2) <= d;
					ls = Math.abs(l - x1) <= d;
					rs = Math.abs(r - x2) <= d;
					if(ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
					}
					if(bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
					}
					if(ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
					}
					if(rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
					}
				}
	
				if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
					(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
	
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "stack", {
		start: function() {
			var min,
				o = this.data("ui-draggable").options,
				group = $.makeArray($(o.stack)).sort(function(a,b) {
					return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
				});
	
			if (!group.length) { return; }
	
			min = parseInt($(group[0]).css("zIndex"), 10) || 0;
			$(group).each(function(i) {
				$(this).css("zIndex", min + i);
			});
			this.css("zIndex", (min + group.length));
		}
	});
	
	$.ui.plugin.add("draggable", "zIndex", {
		start: function(event, ui) {
			var t = $(ui.helper), o = $(this).data("ui-draggable").options;
			if(t.css("zIndex")) {
				o._zIndex = t.css("zIndex");
			}
			t.css("zIndex", o.zIndex);
		},
		stop: function(event, ui) {
			var o = $(this).data("ui-draggable").options;
			if(o._zIndex) {
				$(ui.helper).css("zIndex", o._zIndex);
			}
		}
	});
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	function isOverAxis( x, reference, size ) {
		return ( x > reference ) && ( x < ( reference + size ) );
	}
	
	$.widget("ui.droppable", {
		version: "1.10.3",
		widgetEventPrefix: "drop",
		options: {
			accept: "*",
			activeClass: false,
			addClasses: true,
			greedy: false,
			hoverClass: false,
			scope: "default",
			tolerance: "intersect",
	
			// callbacks
			activate: null,
			deactivate: null,
			drop: null,
			out: null,
			over: null
		},
		_create: function() {
	
			var o = this.options,
				accept = o.accept;
	
			this.isover = false;
			this.isout = true;
	
			this.accept = $.isFunction(accept) ? accept : function(d) {
				return d.is(accept);
			};
	
			//Store the droppable's proportions
			this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };
	
			// Add the reference and positions to the manager
			$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
			$.ui.ddmanager.droppables[o.scope].push(this);
	
			(o.addClasses && this.element.addClass("ui-droppable"));
	
		},
	
		_destroy: function() {
			var i = 0,
				drop = $.ui.ddmanager.droppables[this.options.scope];
	
			for ( ; i < drop.length; i++ ) {
				if ( drop[i] === this ) {
					drop.splice(i, 1);
				}
			}
	
			this.element.removeClass("ui-droppable ui-droppable-disabled");
		},
	
		_setOption: function(key, value) {
	
			if(key === "accept") {
				this.accept = $.isFunction(value) ? value : function(d) {
					return d.is(value);
				};
			}
			$.Widget.prototype._setOption.apply(this, arguments);
		},
	
		_activate: function(event) {
			var draggable = $.ui.ddmanager.current;
			if(this.options.activeClass) {
				this.element.addClass(this.options.activeClass);
			}
			if(draggable){
				this._trigger("activate", event, this.ui(draggable));
			}
		},
	
		_deactivate: function(event) {
			var draggable = $.ui.ddmanager.current;
			if(this.options.activeClass) {
				this.element.removeClass(this.options.activeClass);
			}
			if(draggable){
				this._trigger("deactivate", event, this.ui(draggable));
			}
		},
	
		_over: function(event) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return;
			}
	
			if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.hoverClass) {
					this.element.addClass(this.options.hoverClass);
				}
				this._trigger("over", event, this.ui(draggable));
			}
	
		},
	
		_out: function(event) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return;
			}
	
			if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.hoverClass) {
					this.element.removeClass(this.options.hoverClass);
				}
				this._trigger("out", event, this.ui(draggable));
			}
	
		},
	
		_drop: function(event,custom) {
	
			var draggable = custom || $.ui.ddmanager.current,
				childrenIntersection = false;
	
			// Bail if draggable and droppable are same element
			if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
				return false;
			}
	
			this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
				var inst = $.data(this, "ui-droppable");
				if(
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
					$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
				) { childrenIntersection = true; return false; }
			});
			if(childrenIntersection) {
				return false;
			}
	
			if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				if(this.options.activeClass) {
					this.element.removeClass(this.options.activeClass);
				}
				if(this.options.hoverClass) {
					this.element.removeClass(this.options.hoverClass);
				}
				this._trigger("drop", event, this.ui(draggable));
				return this.element;
			}
	
			return false;
	
		},
	
		ui: function(c) {
			return {
				draggable: (c.currentItem || c.element),
				helper: c.helper,
				position: c.position,
				offset: c.positionAbs
			};
		}
	
	});
	
	$.ui.intersect = function(draggable, droppable, toleranceMode) {
	
		if (!droppable.offset) {
			return false;
		}
	
		var draggableLeft, draggableTop,
			x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
			y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left, r = l + droppable.proportions.width,
			t = droppable.offset.top, b = t + droppable.proportions.height;
	
		switch (toleranceMode) {
			case "fit":
				return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
			case "intersect":
				return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
					x2 - (draggable.helperProportions.width / 2) < r && // Left Half
					t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
					y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			case "pointer":
				draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
				return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );
			case "touch":
				return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			default:
				return false;
			}
	
	};
	
	/*
		This manager tracks offsets of draggables and droppables
	*/
	$.ui.ddmanager = {
		current: null,
		droppables: { "default": [] },
		prepareOffsets: function(t, event) {
	
			var i, j,
				m = $.ui.ddmanager.droppables[t.options.scope] || [],
				type = event ? event.type : null, // workaround for #2317
				list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
	
			droppablesLoop: for (i = 0; i < m.length; i++) {
	
				//No disabled and non-accepted
				if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
					continue;
				}
	
				// Filter out elements in the current dragged item
				for (j=0; j < list.length; j++) {
					if(list[j] === m[i].element[0]) {
						m[i].proportions.height = 0;
						continue droppablesLoop;
					}
				}
	
				m[i].visible = m[i].element.css("display") !== "none";
				if(!m[i].visible) {
					continue;
				}
	
				//Activate the droppable if used directly from draggables
				if(type === "mousedown") {
					m[i]._activate.call(m[i], event);
				}
	
				m[i].offset = m[i].element.offset();
				m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };
	
			}
	
		},
		drop: function(draggable, event) {
	
			var dropped = false;
			// Create a copy of the droppables in case the list changes during the drop (#9116)
			$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
	
				if(!this.options) {
					return;
				}
				if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
					dropped = this._drop.call(this, event) || dropped;
				}
	
				if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
					this.isout = true;
					this.isover = false;
					this._deactivate.call(this, event);
				}
	
			});
			return dropped;
	
		},
		dragStart: function( draggable, event ) {
			//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
			draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
				if( !draggable.options.refreshPositions ) {
					$.ui.ddmanager.prepareOffsets( draggable, event );
				}
			});
		},
		drag: function(draggable, event) {
	
			//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
			if(draggable.options.refreshPositions) {
				$.ui.ddmanager.prepareOffsets(draggable, event);
			}
	
			//Run through all droppables and check their positions based on specific tolerance options
			$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
	
				if(this.options.disabled || this.greedyChild || !this.visible) {
					return;
				}
	
				var parentInstance, scope, parent,
					intersects = $.ui.intersect(draggable, this, this.options.tolerance),
					c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
				if(!c) {
					return;
				}
	
				if (this.options.greedy) {
					// find droppable parents with same scope
					scope = this.options.scope;
					parent = this.element.parents(":data(ui-droppable)").filter(function () {
						return $.data(this, "ui-droppable").options.scope === scope;
					});
	
					if (parent.length) {
						parentInstance = $.data(parent[0], "ui-droppable");
						parentInstance.greedyChild = (c === "isover");
					}
				}
	
				// we just moved into a greedy child
				if (parentInstance && c === "isover") {
					parentInstance.isover = false;
					parentInstance.isout = true;
					parentInstance._out.call(parentInstance, event);
				}
	
				this[c] = true;
				this[c === "isout" ? "isover" : "isout"] = false;
				this[c === "isover" ? "_over" : "_out"].call(this, event);
	
				// we just moved out of a greedy child
				if (parentInstance && c === "isout") {
					parentInstance.isout = false;
					parentInstance.isover = true;
					parentInstance._over.call(parentInstance, event);
				}
			});
	
		},
		dragStop: function( draggable, event ) {
			draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
			//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
			if( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		}
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	function num(v) {
		return parseInt(v, 10) || 0;
	}
	
	function isNumber(value) {
		return !isNaN(parseInt(value, 10));
	}
	
	$.widget("ui.resizable", $.ui.mouse, {
		version: "1.10.3",
		widgetEventPrefix: "resize",
		options: {
			alsoResize: false,
			animate: false,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: false,
			autoHide: false,
			containment: false,
			ghost: false,
			grid: false,
			handles: "e,s,se",
			helper: false,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			// See #7960
			zIndex: 90,
	
			// callbacks
			resize: null,
			start: null,
			stop: null
		},
		_create: function() {
	
			var n, i, handle, axis, hname,
				that = this,
				o = this.options;
			this.element.addClass("ui-resizable");
	
			$.extend(this, {
				_aspectRatio: !!(o.aspectRatio),
				aspectRatio: o.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
			});
	
			//Wrap the element if it cannot hold child nodes
			if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
	
				//Create a wrapper element and set the wrapper to the new current internal element
				this.element.wrap(
					$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
						position: this.element.css("position"),
						width: this.element.outerWidth(),
						height: this.element.outerHeight(),
						top: this.element.css("top"),
						left: this.element.css("left")
					})
				);
	
				//Overwrite the original this.element
				this.element = this.element.parent().data(
					"ui-resizable", this.element.data("ui-resizable")
				);
	
				this.elementIsWrapper = true;
	
				//Move margins to the wrapper
				this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
				this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
	
				//Prevent Safari textarea resize
				this.originalResizeStyle = this.originalElement.css("resize");
				this.originalElement.css("resize", "none");
	
				//Push the actual element to our proportionallyResize internal array
				this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));
	
				// avoid IE jump (hard set the margin)
				this.originalElement.css({ margin: this.originalElement.css("margin") });
	
				// fix handlers offset
				this._proportionallyResize();
	
			}
	
			this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
			if(this.handles.constructor === String) {
	
				if ( this.handles === "all") {
					this.handles = "n,e,s,w,se,sw,ne,nw";
				}
	
				n = this.handles.split(",");
				this.handles = {};
	
				for(i = 0; i < n.length; i++) {
	
					handle = $.trim(n[i]);
					hname = "ui-resizable-"+handle;
					axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
	
					// Apply zIndex to all handles - see #7960
					axis.css({ zIndex: o.zIndex });
	
					//TODO : What's going on here?
					if ("se" === handle) {
						axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
					}
	
					//Insert into internal handles object and append to element
					this.handles[handle] = ".ui-resizable-"+handle;
					this.element.append(axis);
				}
	
			}
	
			this._renderAxis = function(target) {
	
				var i, axis, padPos, padWrapper;
	
				target = target || this.element;
	
				for(i in this.handles) {
	
					if(this.handles[i].constructor === String) {
						this.handles[i] = $(this.handles[i], this.element).show();
					}
	
					//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
					if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
	
						axis = $(this.handles[i], this.element);
	
						//Checking the correct pad and border
						padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
	
						//The padding type i have to apply...
						padPos = [ "padding",
							/ne|nw|n/.test(i) ? "Top" :
							/se|sw|s/.test(i) ? "Bottom" :
							/^e$/.test(i) ? "Right" : "Left" ].join("");
	
						target.css(padPos, padWrapper);
	
						this._proportionallyResize();
	
					}
	
					//TODO: What's that good for? There's not anything to be executed left
					if(!$(this.handles[i]).length) {
						continue;
					}
				}
			};
	
			//TODO: make renderAxis a prototype function
			this._renderAxis(this.element);
	
			this._handles = $(".ui-resizable-handle", this.element)
				.disableSelection();
	
			//Matching axis name
			this._handles.mouseover(function() {
				if (!that.resizing) {
					if (this.className) {
						axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
					}
					//Axis, default = se
					that.axis = axis && axis[1] ? axis[1] : "se";
				}
			});
	
			//If we want to auto hide the elements
			if (o.autoHide) {
				this._handles.hide();
				$(this.element)
					.addClass("ui-resizable-autohide")
					.mouseenter(function() {
						if (o.disabled) {
							return;
						}
						$(this).removeClass("ui-resizable-autohide");
						that._handles.show();
					})
					.mouseleave(function(){
						if (o.disabled) {
							return;
						}
						if (!that.resizing) {
							$(this).addClass("ui-resizable-autohide");
							that._handles.hide();
						}
					});
			}
	
			//Initialize the mouse interaction
			this._mouseInit();
	
		},
	
		_destroy: function() {
	
			this._mouseDestroy();
	
			var wrapper,
				_destroy = function(exp) {
					$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
						.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
				};
	
			//TODO: Unwrap at same DOM position
			if (this.elementIsWrapper) {
				_destroy(this.element);
				wrapper = this.element;
				this.originalElement.css({
					position: wrapper.css("position"),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css("top"),
					left: wrapper.css("left")
				}).insertAfter( wrapper );
				wrapper.remove();
			}
	
			this.originalElement.css("resize", this.originalResizeStyle);
			_destroy(this.originalElement);
	
			return this;
		},
	
		_mouseCapture: function(event) {
			var i, handle,
				capture = false;
	
			for (i in this.handles) {
				handle = $(this.handles[i])[0];
				if (handle === event.target || $.contains(handle, event.target)) {
					capture = true;
				}
			}
	
			return !this.options.disabled && capture;
		},
	
		_mouseStart: function(event) {
	
			var curleft, curtop, cursor,
				o = this.options,
				iniPos = this.element.position(),
				el = this.element;
	
			this.resizing = true;
	
			// bugfix for http://dev.jquery.com/ticket/1749
			if ( (/absolute/).test( el.css("position") ) ) {
				el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
			} else if (el.is(".ui-draggable")) {
				el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
			}
	
			this._renderProxy();
	
			curleft = num(this.helper.css("left"));
			curtop = num(this.helper.css("top"));
	
			if (o.containment) {
				curleft += $(o.containment).scrollLeft() || 0;
				curtop += $(o.containment).scrollTop() || 0;
			}
	
			//Store needed variables
			this.offset = this.helper.offset();
			this.position = { left: curleft, top: curtop };
			this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
			this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
			this.originalPosition = { left: curleft, top: curtop };
			this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
			this.originalMousePosition = { left: event.pageX, top: event.pageY };
	
			//Aspect Ratio
			this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);
	
			cursor = $(".ui-resizable-" + this.axis).css("cursor");
			$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
	
			el.addClass("ui-resizable-resizing");
			this._propagate("start", event);
			return true;
		},
	
		_mouseDrag: function(event) {
	
			//Increase performance, avoid regex
			var data,
				el = this.helper, props = {},
				smp = this.originalMousePosition,
				a = this.axis,
				prevTop = this.position.top,
				prevLeft = this.position.left,
				prevWidth = this.size.width,
				prevHeight = this.size.height,
				dx = (event.pageX-smp.left)||0,
				dy = (event.pageY-smp.top)||0,
				trigger = this._change[a];
	
			if (!trigger) {
				return false;
			}
	
			// Calculate the attrs that will be change
			data = trigger.apply(this, [event, dx, dy]);
	
			// Put this in the mouseDrag handler since the user can start pressing shift while resizing
			this._updateVirtualBoundaries(event.shiftKey);
			if (this._aspectRatio || event.shiftKey) {
				data = this._updateRatio(data, event);
			}
	
			data = this._respectSize(data, event);
	
			this._updateCache(data);
	
			// plugins callbacks need to be called first
			this._propagate("resize", event);
	
			if (this.position.top !== prevTop) {
				props.top = this.position.top + "px";
			}
			if (this.position.left !== prevLeft) {
				props.left = this.position.left + "px";
			}
			if (this.size.width !== prevWidth) {
				props.width = this.size.width + "px";
			}
			if (this.size.height !== prevHeight) {
				props.height = this.size.height + "px";
			}
			el.css(props);
	
			if (!this._helper && this._proportionallyResizeElements.length) {
				this._proportionallyResize();
			}
	
			// Call the user callback if the element was resized
			if ( ! $.isEmptyObject(props) ) {
				this._trigger("resize", event, this.ui());
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			this.resizing = false;
			var pr, ista, soffseth, soffsetw, s, left, top,
				o = this.options, that = this;
	
			if(this._helper) {
	
				pr = this._proportionallyResizeElements;
				ista = pr.length && (/textarea/i).test(pr[0].nodeName);
				soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
				soffsetw = ista ? 0 : that.sizeDiff.width;
	
				s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
				left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
				top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
	
				if (!o.animate) {
					this.element.css($.extend(s, { top: top, left: left }));
				}
	
				that.helper.height(that.size.height);
				that.helper.width(that.size.width);
	
				if (this._helper && !o.animate) {
					this._proportionallyResize();
				}
			}
	
			$("body").css("cursor", "auto");
	
			this.element.removeClass("ui-resizable-resizing");
	
			this._propagate("stop", event);
	
			if (this._helper) {
				this.helper.remove();
			}
	
			return false;
	
		},
	
		_updateVirtualBoundaries: function(forceAspectRatio) {
			var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
				o = this.options;
	
			b = {
				minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
				maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
				minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
				maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
			};
	
			if(this._aspectRatio || forceAspectRatio) {
				// We want to create an enclosing box whose aspect ration is the requested one
				// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
				pMinWidth = b.minHeight * this.aspectRatio;
				pMinHeight = b.minWidth / this.aspectRatio;
				pMaxWidth = b.maxHeight * this.aspectRatio;
				pMaxHeight = b.maxWidth / this.aspectRatio;
	
				if(pMinWidth > b.minWidth) {
					b.minWidth = pMinWidth;
				}
				if(pMinHeight > b.minHeight) {
					b.minHeight = pMinHeight;
				}
				if(pMaxWidth < b.maxWidth) {
					b.maxWidth = pMaxWidth;
				}
				if(pMaxHeight < b.maxHeight) {
					b.maxHeight = pMaxHeight;
				}
			}
			this._vBoundaries = b;
		},
	
		_updateCache: function(data) {
			this.offset = this.helper.offset();
			if (isNumber(data.left)) {
				this.position.left = data.left;
			}
			if (isNumber(data.top)) {
				this.position.top = data.top;
			}
			if (isNumber(data.height)) {
				this.size.height = data.height;
			}
			if (isNumber(data.width)) {
				this.size.width = data.width;
			}
		},
	
		_updateRatio: function( data ) {
	
			var cpos = this.position,
				csize = this.size,
				a = this.axis;
	
			if (isNumber(data.height)) {
				data.width = (data.height * this.aspectRatio);
			} else if (isNumber(data.width)) {
				data.height = (data.width / this.aspectRatio);
			}
	
			if (a === "sw") {
				data.left = cpos.left + (csize.width - data.width);
				data.top = null;
			}
			if (a === "nw") {
				data.top = cpos.top + (csize.height - data.height);
				data.left = cpos.left + (csize.width - data.width);
			}
	
			return data;
		},
	
		_respectSize: function( data ) {
	
			var o = this._vBoundaries,
				a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
				isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
				dw = this.originalPosition.left + this.originalSize.width,
				dh = this.position.top + this.size.height,
				cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
			if (isminw) {
				data.width = o.minWidth;
			}
			if (isminh) {
				data.height = o.minHeight;
			}
			if (ismaxw) {
				data.width = o.maxWidth;
			}
			if (ismaxh) {
				data.height = o.maxHeight;
			}
	
			if (isminw && cw) {
				data.left = dw - o.minWidth;
			}
			if (ismaxw && cw) {
				data.left = dw - o.maxWidth;
			}
			if (isminh && ch) {
				data.top = dh - o.minHeight;
			}
			if (ismaxh && ch) {
				data.top = dh - o.maxHeight;
			}
	
			// fixing jump error on top/left - bug #2330
			if (!data.width && !data.height && !data.left && data.top) {
				data.top = null;
			} else if (!data.width && !data.height && !data.top && data.left) {
				data.left = null;
			}
	
			return data;
		},
	
		_proportionallyResize: function() {
	
			if (!this._proportionallyResizeElements.length) {
				return;
			}
	
			var i, j, borders, paddings, prel,
				element = this.helper || this.element;
	
			for ( i=0; i < this._proportionallyResizeElements.length; i++) {
	
				prel = this._proportionallyResizeElements[i];
	
				if (!this.borderDif) {
					this.borderDif = [];
					borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
					paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];
	
					for ( j = 0; j < borders.length; j++ ) {
						this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
					}
				}
	
				prel.css({
					height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
					width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
				});
	
			}
	
		},
	
		_renderProxy: function() {
	
			var el = this.element, o = this.options;
			this.elementOffset = el.offset();
	
			if(this._helper) {
	
				this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
	
				this.helper.addClass(this._helper).css({
					width: this.element.outerWidth() - 1,
					height: this.element.outerHeight() - 1,
					position: "absolute",
					left: this.elementOffset.left +"px",
					top: this.elementOffset.top +"px",
					zIndex: ++o.zIndex //TODO: Don't modify option
				});
	
				this.helper
					.appendTo("body")
					.disableSelection();
	
			} else {
				this.helper = this.element;
			}
	
		},
	
		_change: {
			e: function(event, dx) {
				return { width: this.originalSize.width + dx };
			},
			w: function(event, dx) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { left: sp.left + dx, width: cs.width - dx };
			},
			n: function(event, dx, dy) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { top: sp.top + dy, height: cs.height - dy };
			},
			s: function(event, dx, dy) {
				return { height: this.originalSize.height + dy };
			},
			se: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			sw: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			},
			ne: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			nw: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			}
		},
	
		_propagate: function(n, event) {
			$.ui.plugin.call(this, n, [event, this.ui()]);
			(n !== "resize" && this._trigger(n, event, this.ui()));
		},
	
		plugins: {},
	
		ui: function() {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			};
		}
	
	});
	
	/*
	 * Resizable Extensions
	 */
	
	$.ui.plugin.add("resizable", "animate", {
	
		stop: function( event ) {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				pr = that._proportionallyResizeElements,
				ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width,
				style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
				left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
	
			that.element.animate(
				$.extend(style, top && left ? { top: top, left: left } : {}), {
					duration: o.animateDuration,
					easing: o.animateEasing,
					step: function() {
	
						var data = {
							width: parseInt(that.element.css("width"), 10),
							height: parseInt(that.element.css("height"), 10),
							top: parseInt(that.element.css("top"), 10),
							left: parseInt(that.element.css("left"), 10)
						};
	
						if (pr && pr.length) {
							$(pr[0]).css({ width: data.width, height: data.height });
						}
	
						// propagating resize, and updating values for each animation step
						that._updateCache(data);
						that._propagate("resize", event);
	
					}
				}
			);
		}
	
	});
	
	$.ui.plugin.add("resizable", "containment", {
	
		start: function() {
			var element, p, co, ch, cw, width, height,
				that = $(this).data("ui-resizable"),
				o = that.options,
				el = that.element,
				oc = o.containment,
				ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
	
			if (!ce) {
				return;
			}
	
			that.containerElement = $(ce);
	
			if (/document/.test(oc) || oc === document) {
				that.containerOffset = { left: 0, top: 0 };
				that.containerPosition = { left: 0, top: 0 };
	
				that.parentData = {
					element: $(document), left: 0, top: 0,
					width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
				};
			}
	
			// i'm a node, so compute top, left, right, bottom
			else {
				element = $(ce);
				p = [];
				$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });
	
				that.containerOffset = element.offset();
				that.containerPosition = element.position();
				that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };
	
				co = that.containerOffset;
				ch = that.containerSize.height;
				cw = that.containerSize.width;
				width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
				height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);
	
				that.parentData = {
					element: ce, left: co.left, top: co.top, width: width, height: height
				};
			}
		},
	
		resize: function( event ) {
			var woset, hoset, isParent, isOffsetRelative,
				that = $(this).data("ui-resizable"),
				o = that.options,
				co = that.containerOffset, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey,
				cop = { top:0, left:0 }, ce = that.containerElement;
	
			if (ce[0] !== document && (/static/).test(ce.css("position"))) {
				cop = co;
			}
	
			if (cp.left < (that._helper ? co.left : 0)) {
				that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
				if (pRatio) {
					that.size.height = that.size.width / that.aspectRatio;
				}
				that.position.left = o.helper ? co.left : 0;
			}
	
			if (cp.top < (that._helper ? co.top : 0)) {
				that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
				if (pRatio) {
					that.size.width = that.size.height * that.aspectRatio;
				}
				that.position.top = that._helper ? co.top : 0;
			}
	
			that.offset.left = that.parentData.left+that.position.left;
			that.offset.top = that.parentData.top+that.position.top;
	
			woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
			hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );
	
			isParent = that.containerElement.get(0) === that.element.parent().get(0);
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
	
			if(isParent && isOffsetRelative) {
				woset -= that.parentData.left;
			}
	
			if (woset + that.size.width >= that.parentData.width) {
				that.size.width = that.parentData.width - woset;
				if (pRatio) {
					that.size.height = that.size.width / that.aspectRatio;
				}
			}
	
			if (hoset + that.size.height >= that.parentData.height) {
				that.size.height = that.parentData.height - hoset;
				if (pRatio) {
					that.size.width = that.size.height * that.aspectRatio;
				}
			}
		},
	
		stop: function(){
			var that = $(this).data("ui-resizable"),
				o = that.options,
				co = that.containerOffset,
				cop = that.containerPosition,
				ce = that.containerElement,
				helper = $(that.helper),
				ho = helper.offset(),
				w = helper.outerWidth() - that.sizeDiff.width,
				h = helper.outerHeight() - that.sizeDiff.height;
	
			if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
				$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
			}
	
			if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
				$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
			}
	
		}
	});
	
	$.ui.plugin.add("resizable", "alsoResize", {
	
		start: function () {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				_store = function (exp) {
					$(exp).each(function() {
						var el = $(this);
						el.data("ui-resizable-alsoresize", {
							width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
							left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
						});
					});
				};
	
			if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
				if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
				else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
			}else{
				_store(o.alsoResize);
			}
		},
	
		resize: function (event, ui) {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				os = that.originalSize,
				op = that.originalPosition,
				delta = {
					height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
					top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
				},
	
				_alsoResize = function (exp, c) {
					$(exp).each(function() {
						var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
							css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
	
						$.each(css, function (i, prop) {
							var sum = (start[prop]||0) + (delta[prop]||0);
							if (sum && sum >= 0) {
								style[prop] = sum || null;
							}
						});
	
						el.css(style);
					});
				};
	
			if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
			}else{
				_alsoResize(o.alsoResize);
			}
		},
	
		stop: function () {
			$(this).removeData("resizable-alsoresize");
		}
	});
	
	$.ui.plugin.add("resizable", "ghost", {
	
		start: function() {
	
			var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;
	
			that.ghost = that.originalElement.clone();
			that.ghost
				.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
				.addClass("ui-resizable-ghost")
				.addClass(typeof o.ghost === "string" ? o.ghost : "");
	
			that.ghost.appendTo(that.helper);
	
		},
	
		resize: function(){
			var that = $(this).data("ui-resizable");
			if (that.ghost) {
				that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
			}
		},
	
		stop: function() {
			var that = $(this).data("ui-resizable");
			if (that.ghost && that.helper) {
				that.helper.get(0).removeChild(that.ghost.get(0));
			}
		}
	
	});
	
	$.ui.plugin.add("resizable", "grid", {
	
		resize: function() {
			var that = $(this).data("ui-resizable"),
				o = that.options,
				cs = that.size,
				os = that.originalSize,
				op = that.originalPosition,
				a = that.axis,
				grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
				gridX = (grid[0]||1),
				gridY = (grid[1]||1),
				ox = Math.round((cs.width - os.width) / gridX) * gridX,
				oy = Math.round((cs.height - os.height) / gridY) * gridY,
				newWidth = os.width + ox,
				newHeight = os.height + oy,
				isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
				isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
				isMinWidth = o.minWidth && (o.minWidth > newWidth),
				isMinHeight = o.minHeight && (o.minHeight > newHeight);
	
			o.grid = grid;
	
			if (isMinWidth) {
				newWidth = newWidth + gridX;
			}
			if (isMinHeight) {
				newHeight = newHeight + gridY;
			}
			if (isMaxWidth) {
				newWidth = newWidth - gridX;
			}
			if (isMaxHeight) {
				newHeight = newHeight - gridY;
			}
	
			if (/^(se|s|e)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
			} else if (/^(ne)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else if (/^(sw)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.left = op.left - ox;
			} else {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.top = op.top - oy;
				that.position.left = op.left - ox;
			}
		}
	
	});
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.widget("ui.selectable", $.ui.mouse, {
		version: "1.10.3",
		options: {
			appendTo: "body",
			autoRefresh: true,
			distance: 0,
			filter: "*",
			tolerance: "touch",
	
			// callbacks
			selected: null,
			selecting: null,
			start: null,
			stop: null,
			unselected: null,
			unselecting: null
		},
		_create: function() {
			var selectees,
				that = this;
	
			this.element.addClass("ui-selectable");
	
			this.dragged = false;
	
			// cache selectee children based on filter
			this.refresh = function() {
				selectees = $(that.options.filter, that.element[0]);
				selectees.addClass("ui-selectee");
				selectees.each(function() {
					var $this = $(this),
						pos = $this.offset();
					$.data(this, "selectable-item", {
						element: this,
						$element: $this,
						left: pos.left,
						top: pos.top,
						right: pos.left + $this.outerWidth(),
						bottom: pos.top + $this.outerHeight(),
						startselected: false,
						selected: $this.hasClass("ui-selected"),
						selecting: $this.hasClass("ui-selecting"),
						unselecting: $this.hasClass("ui-unselecting")
					});
				});
			};
			this.refresh();
	
			this.selectees = selectees.addClass("ui-selectee");
	
			this._mouseInit();
	
			this.helper = $("<div class='ui-selectable-helper'></div>");
		},
	
		_destroy: function() {
			this.selectees
				.removeClass("ui-selectee")
				.removeData("selectable-item");
			this.element
				.removeClass("ui-selectable ui-selectable-disabled");
			this._mouseDestroy();
		},
	
		_mouseStart: function(event) {
			var that = this,
				options = this.options;
	
			this.opos = [event.pageX, event.pageY];
	
			if (this.options.disabled) {
				return;
			}
	
			this.selectees = $(options.filter, this.element[0]);
	
			this._trigger("start", event);
	
			$(options.appendTo).append(this.helper);
			// position helper (lasso)
			this.helper.css({
				"left": event.pageX,
				"top": event.pageY,
				"width": 0,
				"height": 0
			});
	
			if (options.autoRefresh) {
				this.refresh();
			}
	
			this.selectees.filter(".ui-selected").each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.startselected = true;
				if (!event.metaKey && !event.ctrlKey) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
					selectee.$element.addClass("ui-unselecting");
					selectee.unselecting = true;
					// selectable UNSELECTING callback
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
			});
	
			$(event.target).parents().addBack().each(function() {
				var doSelect,
					selectee = $.data(this, "selectable-item");
				if (selectee) {
					doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
					selectee.$element
						.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
						.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
					selectee.unselecting = !doSelect;
					selectee.selecting = doSelect;
					selectee.selected = doSelect;
					// selectable (UN)SELECTING callback
					if (doSelect) {
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					} else {
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
					return false;
				}
			});
	
		},
	
		_mouseDrag: function(event) {
	
			this.dragged = true;
	
			if (this.options.disabled) {
				return;
			}
	
			var tmp,
				that = this,
				options = this.options,
				x1 = this.opos[0],
				y1 = this.opos[1],
				x2 = event.pageX,
				y2 = event.pageY;
	
			if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
			if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
			this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
	
			this.selectees.each(function() {
				var selectee = $.data(this, "selectable-item"),
					hit = false;
	
				//prevent helper from being selected if appendTo: selectable
				if (!selectee || selectee.element === that.element[0]) {
					return;
				}
	
				if (options.tolerance === "touch") {
					hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
				} else if (options.tolerance === "fit") {
					hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
				}
	
				if (hit) {
					// SELECT
					if (selectee.selected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;
					}
					if (selectee.unselecting) {
						selectee.$element.removeClass("ui-unselecting");
						selectee.unselecting = false;
					}
					if (!selectee.selecting) {
						selectee.$element.addClass("ui-selecting");
						selectee.selecting = true;
						// selectable SELECTING callback
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					}
				} else {
					// UNSELECT
					if (selectee.selecting) {
						if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							selectee.$element.addClass("ui-selected");
							selectee.selected = true;
						} else {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							if (selectee.startselected) {
								selectee.$element.addClass("ui-unselecting");
								selectee.unselecting = true;
							}
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
					if (selectee.selected) {
						if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
							selectee.$element.removeClass("ui-selected");
							selectee.selected = false;
	
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
				}
			});
	
			return false;
		},
	
		_mouseStop: function(event) {
			var that = this;
	
			this.dragged = false;
	
			$(".ui-unselecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-unselecting");
				selectee.unselecting = false;
				selectee.startselected = false;
				that._trigger("unselected", event, {
					unselected: selectee.element
				});
			});
			$(".ui-selecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
				selectee.selecting = false;
				selectee.selected = true;
				selectee.startselected = true;
				that._trigger("selected", event, {
					selected: selectee.element
				});
			});
			this._trigger("stop", event);
	
			this.helper.remove();
	
			return false;
		}
	
	});
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	/*jshint loopfunc: true */
	
	function isOverAxis( x, reference, size ) {
		return ( x > reference ) && ( x < ( reference + size ) );
	}
	
	function isFloating(item) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	}
	
	$.widget("ui.sortable", $.ui.mouse, {
		version: "1.10.3",
		widgetEventPrefix: "sort",
		ready: false,
		options: {
			appendTo: "parent",
			axis: false,
			connectWith: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			dropOnEmpty: true,
			forcePlaceholderSize: false,
			forceHelperSize: false,
			grid: false,
			handle: false,
			helper: "original",
			items: "> *",
			opacity: false,
			placeholder: false,
			revert: false,
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1000,
	
			// callbacks
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},
		_create: function() {
	
			var o = this.options;
			this.containerCache = {};
			this.element.addClass("ui-sortable");
	
			//Get the items
			this.refresh();
	
			//Let's determine if the items are being displayed horizontally
			this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
	
			//Let's determine the parent's offset
			this.offset = this.element.offset();
	
			//Initialize mouse events for interaction
			this._mouseInit();
	
			//We're ready to go
			this.ready = true;
	
		},
	
		_destroy: function() {
			this.element
				.removeClass("ui-sortable ui-sortable-disabled");
			this._mouseDestroy();
	
			for ( var i = this.items.length - 1; i >= 0; i-- ) {
				this.items[i].item.removeData(this.widgetName + "-item");
			}
	
			return this;
		},
	
		_setOption: function(key, value){
			if ( key === "disabled" ) {
				this.options[ key ] = value;
	
				this.widget().toggleClass( "ui-sortable-disabled", !!value );
			} else {
				// Don't call widget base _setOption for disable as it adds ui-state-disabled class
				$.Widget.prototype._setOption.apply(this, arguments);
			}
		},
	
		_mouseCapture: function(event, overrideHandle) {
			var currentItem = null,
				validHandle = false,
				that = this;
	
			if (this.reverting) {
				return false;
			}
	
			if(this.options.disabled || this.options.type === "static") {
				return false;
			}
	
			//We have to refresh the items data once first
			this._refreshItems(event);
	
			//Find out if the clicked node (or one of its parents) is a actual item in this.items
			$(event.target).parents().each(function() {
				if($.data(this, that.widgetName + "-item") === that) {
					currentItem = $(this);
					return false;
				}
			});
			if($.data(event.target, that.widgetName + "-item") === that) {
				currentItem = $(event.target);
			}
	
			if(!currentItem) {
				return false;
			}
			if(this.options.handle && !overrideHandle) {
				$(this.options.handle, currentItem).find("*").addBack().each(function() {
					if(this === event.target) {
						validHandle = true;
					}
				});
				if(!validHandle) {
					return false;
				}
			}
	
			this.currentItem = currentItem;
			this._removeCurrentsFromItems();
			return true;
	
		},
	
		_mouseStart: function(event, overrideHandle, noActivation) {
	
			var i, body,
				o = this.options;
	
			this.currentContainer = this;
	
			//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
			this.refreshPositions();
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Get the next scrolling parent
			this.scrollParent = this.helper.scrollParent();
	
			//The element's absolute position on the page minus margins
			this.offset = this.currentItem.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};
	
			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});
	
			// Only after we got the offset, we can change the helper's position to absolute
			// TODO: Still need to figure out a way to make relative sorting possible
			this.helper.css("position", "absolute");
			this.cssPosition = this.helper.css("position");
	
			//Generate the original position
			this.originalPosition = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Cache the former DOM position
			this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
	
			//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
			if(this.helper[0] !== this.currentItem[0]) {
				this.currentItem.hide();
			}
	
			//Create the placeholder
			this._createPlaceholder();
	
			//Set a containment if given in the options
			if(o.containment) {
				this._setContainment();
			}
	
			if( o.cursor && o.cursor !== "auto" ) { // cursor option
				body = this.document.find( "body" );
	
				// support: IE
				this.storedCursor = body.css( "cursor" );
				body.css( "cursor", o.cursor );
	
				this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
			}
	
			if(o.opacity) { // opacity option
				if (this.helper.css("opacity")) {
					this._storedOpacity = this.helper.css("opacity");
				}
				this.helper.css("opacity", o.opacity);
			}
	
			if(o.zIndex) { // zIndex option
				if (this.helper.css("zIndex")) {
					this._storedZIndex = this.helper.css("zIndex");
				}
				this.helper.css("zIndex", o.zIndex);
			}
	
			//Prepare scrolling
			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
				this.overflowOffset = this.scrollParent.offset();
			}
	
			//Call callbacks
			this._trigger("start", event, this._uiHash());
	
			//Recache the helper size
			if(!this._preserveHelperProportions) {
				this._cacheHelperProportions();
			}
	
	
			//Post "activate" events to possible containers
			if( !noActivation ) {
				for ( i = this.containers.length - 1; i >= 0; i-- ) {
					this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
				}
			}
	
			//Prepare possible droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
			this.dragging = true;
	
			this.helper.addClass("ui-sortable-helper");
			this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
			return true;
	
		},
	
		_mouseDrag: function(event) {
			var i, item, itemElement, intersection,
				o = this.options,
				scrolled = false;
	
			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");
	
			if (!this.lastPositionAbs) {
				this.lastPositionAbs = this.positionAbs;
			}
	
			//Do scrolling
			if(this.options.scroll) {
				if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
	
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					}
	
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
	
				} else {
	
					if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}
	
					if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}
	
				}
	
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
			}
	
			//Regenerate the absolute position used for position checks
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Set the helper position
			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}
	
			//Rearrange
			for (i = this.items.length - 1; i >= 0; i--) {
	
				//Cache variables and intersection, continue if no intersection
				item = this.items[i];
				itemElement = item.item[0];
				intersection = this._intersectsWithPointer(item);
				if (!intersection) {
					continue;
				}
	
				// Only put the placeholder inside the current Container, skip all
				// items form other containers. This works because when moving
				// an item from one container to another the
				// currentContainer is switched before the placeholder is moved.
				//
				// Without this moving items in "sub-sortables" can cause the placeholder to jitter
				// beetween the outer and inner container.
				if (item.instance !== this.currentContainer) {
					continue;
				}
	
				// cannot intersect with itself
				// no useless actions that have been done before
				// no action if the item moved is the parent of the item checked
				if (itemElement !== this.currentItem[0] &&
					this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
					!$.contains(this.placeholder[0], itemElement) &&
					(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
				) {
	
					this.direction = intersection === 1 ? "down" : "up";
	
					if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
						this._rearrange(event, item);
					} else {
						break;
					}
	
					this._trigger("change", event, this._uiHash());
					break;
				}
			}
	
			//Post events to containers
			this._contactContainers(event);
	
			//Interconnect with droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			//Call callbacks
			this._trigger("sort", event, this._uiHash());
	
			this.lastPositionAbs = this.positionAbs;
			return false;
	
		},
	
		_mouseStop: function(event, noPropagation) {
	
			if(!event) {
				return;
			}
	
			//If we are using droppables, inform the manager about the drop
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				$.ui.ddmanager.drop(this, event);
			}
	
			if(this.options.revert) {
				var that = this,
					cur = this.placeholder.offset(),
					axis = this.options.axis,
					animation = {};
	
				if ( !axis || axis === "x" ) {
					animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
				}
				if ( !axis || axis === "y" ) {
					animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
				}
				this.reverting = true;
				$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
					that._clear(event);
				});
			} else {
				this._clear(event, noPropagation);
			}
	
			return false;
	
		},
	
		cancel: function() {
	
			if(this.dragging) {
	
				this._mouseUp({ target: null });
	
				if(this.options.helper === "original") {
					this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
				} else {
					this.currentItem.show();
				}
	
				//Post deactivating events to containers
				for (var i = this.containers.length - 1; i >= 0; i--){
					this.containers[i]._trigger("deactivate", null, this._uiHash(this));
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", null, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			if (this.placeholder) {
				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
				if(this.placeholder[0].parentNode) {
					this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
				}
				if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
					this.helper.remove();
				}
	
				$.extend(this, {
					helper: null,
					dragging: false,
					reverting: false,
					_noFinalSort: null
				});
	
				if(this.domPosition.prev) {
					$(this.domPosition.prev).after(this.currentItem);
				} else {
					$(this.domPosition.parent).prepend(this.currentItem);
				}
			}
	
			return this;
	
		},
	
		serialize: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				str = [];
			o = o || {};
	
			$(items).each(function() {
				var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
				if (res) {
					str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
				}
			});
	
			if(!str.length && o.key) {
				str.push(o.key + "=");
			}
	
			return str.join("&");
	
		},
	
		toArray: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				ret = [];
	
			o = o || {};
	
			items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
			return ret;
	
		},
	
		/* Be careful with the following core functions */
		_intersectsWith: function(item) {
	
			var x1 = this.positionAbs.left,
				x2 = x1 + this.helperProportions.width,
				y1 = this.positionAbs.top,
				y2 = y1 + this.helperProportions.height,
				l = item.left,
				r = l + item.width,
				t = item.top,
				b = t + item.height,
				dyClick = this.offset.click.top,
				dxClick = this.offset.click.left,
				isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
				isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
				isOverElement = isOverElementHeight && isOverElementWidth;
	
			if ( this.options.tolerance === "pointer" ||
				this.options.forcePointerForContainers ||
				(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
			) {
				return isOverElement;
			} else {
	
				return (l < x1 + (this.helperProportions.width / 2) && // Right Half
					x2 - (this.helperProportions.width / 2) < r && // Left Half
					t < y1 + (this.helperProportions.height / 2) && // Bottom Half
					y2 - (this.helperProportions.height / 2) < b ); // Top Half
	
			}
		},
	
		_intersectsWithPointer: function(item) {
	
			var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
				isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
				isOverElement = isOverElementHeight && isOverElementWidth,
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (!isOverElement) {
				return false;
			}
	
			return this.floating ?
				( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
				: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
	
		},
	
		_intersectsWithSides: function(item) {
	
			var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
				isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (this.floating && horizontalDirection) {
				return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
			} else {
				return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
			}
	
		},
	
		_getDragVerticalDirection: function() {
			var delta = this.positionAbs.top - this.lastPositionAbs.top;
			return delta !== 0 && (delta > 0 ? "down" : "up");
		},
	
		_getDragHorizontalDirection: function() {
			var delta = this.positionAbs.left - this.lastPositionAbs.left;
			return delta !== 0 && (delta > 0 ? "right" : "left");
		},
	
		refresh: function(event) {
			this._refreshItems(event);
			this.refreshPositions();
			return this;
		},
	
		_connectWith: function() {
			var options = this.options;
			return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
		},
	
		_getItemsAsjQuery: function(connected) {
	
			var i, j, cur, inst,
				items = [],
				queries = [],
				connectWith = this._connectWith();
	
			if(connectWith && connected) {
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i]);
					for ( j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
						}
					}
				}
			}
	
			queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
	
			for (i = queries.length - 1; i >= 0; i--){
				queries[i][0].each(function() {
					items.push(this);
				});
			}
	
			return $(items);
	
		},
	
		_removeCurrentsFromItems: function() {
	
			var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
	
			this.items = $.grep(this.items, function (item) {
				for (var j=0; j < list.length; j++) {
					if(list[j] === item.item[0]) {
						return false;
					}
				}
				return true;
			});
	
		},
	
		_refreshItems: function(event) {
	
			this.items = [];
			this.containers = [this];
	
			var i, j, cur, inst, targetData, _queries, item, queriesLength,
				items = this.items,
				queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
				connectWith = this._connectWith();
	
			if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i]);
					for (j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
							this.containers.push(inst);
						}
					}
				}
			}
	
			for (i = queries.length - 1; i >= 0; i--) {
				targetData = queries[i][1];
				_queries = queries[i][0];
	
				for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
					item = $(_queries[j]);
	
					item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
	
					items.push({
						item: item,
						instance: targetData,
						width: 0, height: 0,
						left: 0, top: 0
					});
				}
			}
	
		},
	
		refreshPositions: function(fast) {
	
			//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
			if(this.offsetParent && this.helper) {
				this.offset.parent = this._getParentOffset();
			}
	
			var i, item, t, p;
	
			for (i = this.items.length - 1; i >= 0; i--){
				item = this.items[i];
	
				//We ignore calculating positions of all connected containers when we're not over them
				if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
					continue;
				}
	
				t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
	
				if (!fast) {
					item.width = t.outerWidth();
					item.height = t.outerHeight();
				}
	
				p = t.offset();
				item.left = p.left;
				item.top = p.top;
			}
	
			if(this.options.custom && this.options.custom.refreshContainers) {
				this.options.custom.refreshContainers.call(this);
			} else {
				for (i = this.containers.length - 1; i >= 0; i--){
					p = this.containers[i].element.offset();
					this.containers[i].containerCache.left = p.left;
					this.containers[i].containerCache.top = p.top;
					this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
					this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
				}
			}
	
			return this;
		},
	
		_createPlaceholder: function(that) {
			that = that || this;
			var className,
				o = that.options;
	
			if(!o.placeholder || o.placeholder.constructor === String) {
				className = o.placeholder;
				o.placeholder = {
					element: function() {
	
						var nodeName = that.currentItem[0].nodeName.toLowerCase(),
							element = $( "<" + nodeName + ">", that.document[0] )
								.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
								.removeClass("ui-sortable-helper");
	
						if ( nodeName === "tr" ) {
							that.currentItem.children().each(function() {
								$( "<td>&#160;</td>", that.document[0] )
									.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
									.appendTo( element );
							});
						} else if ( nodeName === "img" ) {
							element.attr( "src", that.currentItem.attr( "src" ) );
						}
	
						if ( !className ) {
							element.css( "visibility", "hidden" );
						}
	
						return element;
					},
					update: function(container, p) {
	
						// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
						// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
						if(className && !o.forcePlaceholderSize) {
							return;
						}
	
						//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
						if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
						if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
					}
				};
			}
	
			//Create the placeholder
			that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
	
			//Append it after the actual current item
			that.currentItem.after(that.placeholder);
	
			//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
			o.placeholder.update(that, that.placeholder);
	
		},
	
		_contactContainers: function(event) {
			var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
				innermostContainer = null,
				innermostIndex = null;
	
			// get innermost container that intersects with item
			for (i = this.containers.length - 1; i >= 0; i--) {
	
				// never consider a container that's located within the item itself
				if($.contains(this.currentItem[0], this.containers[i].element[0])) {
					continue;
				}
	
				if(this._intersectsWith(this.containers[i].containerCache)) {
	
					// if we've already found a container and it's more "inner" than this, then continue
					if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
						continue;
					}
	
					innermostContainer = this.containers[i];
					innermostIndex = i;
	
				} else {
					// container doesn't intersect. trigger "out" event if necessary
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", event, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			// if no intersecting containers found, return
			if(!innermostContainer) {
				return;
			}
	
			// move the item into the container if it's not there already
			if(this.containers.length === 1) {
				if (!this.containers[innermostIndex].containerCache.over) {
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			} else {
	
				//When entering a new container, we will find the item with the least distance and append our item near it
				dist = 10000;
				itemWithLeastDistance = null;
				floating = innermostContainer.floating || isFloating(this.currentItem);
				posProperty = floating ? "left" : "top";
				sizeProperty = floating ? "width" : "height";
				base = this.positionAbs[posProperty] + this.offset.click[posProperty];
				for (j = this.items.length - 1; j >= 0; j--) {
					if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
						continue;
					}
					if(this.items[j].item[0] === this.currentItem[0]) {
						continue;
					}
					if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
						continue;
					}
					cur = this.items[j].item.offset()[posProperty];
					nearBottom = false;
					if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
						nearBottom = true;
						cur += this.items[j][sizeProperty];
					}
	
					if(Math.abs(cur - base) < dist) {
						dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
						this.direction = nearBottom ? "up": "down";
					}
				}
	
				//Check if dropOnEmpty is enabled
				if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
					return;
				}
	
				if(this.currentContainer === this.containers[innermostIndex]) {
					return;
				}
	
				itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
				this._trigger("change", event, this._uiHash());
				this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
				this.currentContainer = this.containers[innermostIndex];
	
				//Update the placeholder
				this.options.placeholder.update(this.currentContainer, this.placeholder);
	
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
	
	
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
	
			//Add the helper to the DOM if that didn't happen already
			if(!helper.parents("body").length) {
				$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
			}
	
			if(helper[0] === this.currentItem[0]) {
				this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
			}
	
			if(!helper[0].style.width || o.forceHelperSize) {
				helper.width(this.currentItem.width());
			}
			if(!helper[0].style.height || o.forceHelperSize) {
				helper.height(this.currentItem.height());
			}
	
			return helper;
	
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_getParentOffset: function() {
	
	
			//Get the offsetParent and cache its position
			this.offsetParent = this.helper.offsetParent();
			var po = this.offsetParent.offset();
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			// This needs to be actually done for all browsers, since pageX/pageY includes this information
			// with an ugly IE fix
			if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
	
			if(this.cssPosition === "relative") {
				var p = this.currentItem.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
				top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var ce, co, over,
				o = this.options;
			if(o.containment === "parent") {
				o.containment = this.helper[0].parentNode;
			}
			if(o.containment === "document" || o.containment === "window") {
				this.containment = [
					0 - this.offset.relative.left - this.offset.parent.left,
					0 - this.offset.relative.top - this.offset.parent.top,
					$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
					($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
				];
			}
	
			if(!(/^(document|window|parent)$/).test(o.containment)) {
				ce = $(o.containment)[0];
				co = $(o.containment).offset();
				over = ($(ce).css("overflow") !== "hidden");
	
				this.containment = [
					co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
					co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
					co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
					co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
				];
			}
	
		},
	
		_convertPositionTo: function(d, pos) {
	
			if(!pos) {
				pos = this.position;
			}
			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
				)
			};
	
		},
	
		_generatePosition: function(event) {
	
			var top, left,
				o = this.options,
				pageX = event.pageX,
				pageY = event.pageY,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			// This is another very weird special case that only happens for relative elements:
			// 1. If the css position is relative
			// 2. and the scroll parent is the document or similar to the offset parent
			// we have to refresh the relative offset during the scroll so there are no jumps
			if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
				this.offset.relative = this._getRelativeOffset();
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			if(this.originalPosition) { //If we are not dragging yet, we won't check for options
	
				if(this.containment) {
					if(event.pageX - this.offset.click.left < this.containment[0]) {
						pageX = this.containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < this.containment[1]) {
						pageY = this.containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > this.containment[2]) {
						pageX = this.containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > this.containment[3]) {
						pageY = this.containment[3] + this.offset.click.top;
					}
				}
	
				if(o.grid) {
					top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
					pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
					pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
			}
	
			return {
				top: (
					pageY -																// The absolute mouse position
					this.offset.click.top -													// Click offset (relative to the element)
					this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
				),
				left: (
					pageX -																// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
				)
			};
	
		},
	
		_rearrange: function(event, i, a, hardRefresh) {
	
			a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
	
			//Various things done here to improve the performance:
			// 1. we create a setTimeout, that calls refreshPositions
			// 2. on the instance, we have a counter variable, that get's higher after every append
			// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
			// 4. this lets only the last addition to the timeout stack through
			this.counter = this.counter ? ++this.counter : 1;
			var counter = this.counter;
	
			this._delay(function() {
				if(counter === this.counter) {
					this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
				}
			});
	
		},
	
		_clear: function(event, noPropagation) {
	
			this.reverting = false;
			// We delay all events that have to be triggered to after the point where the placeholder has been removed and
			// everything else normalized again
			var i,
				delayedTriggers = [];
	
			// We first have to update the dom position of the actual currentItem
			// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
			if(!this._noFinalSort && this.currentItem.parent().length) {
				this.placeholder.before(this.currentItem);
			}
			this._noFinalSort = null;
	
			if(this.helper[0] === this.currentItem[0]) {
				for(i in this._storedCSS) {
					if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
						this._storedCSS[i] = "";
					}
				}
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}
	
			if(this.fromOutside && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
			}
			if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
			}
	
			// Check if the items Container has Changed and trigger appropriate
			// events.
			if (this !== this.currentContainer) {
				if(!noPropagation) {
					delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
				}
			}
	
	
			//Post events to containers
			for (i = this.containers.length - 1; i >= 0; i--){
				if(!noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				}
				if(this.containers[i].containerCache.over) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					this.containers[i].containerCache.over = 0;
				}
			}
	
			//Do what was originally in plugins
			if ( this.storedCursor ) {
				this.document.find( "body" ).css( "cursor", this.storedCursor );
				this.storedStylesheet.remove();
			}
			if(this._storedOpacity) {
				this.helper.css("opacity", this._storedOpacity);
			}
			if(this._storedZIndex) {
				this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
			}
	
			this.dragging = false;
			if(this.cancelHelperRemoval) {
				if(!noPropagation) {
					this._trigger("beforeStop", event, this._uiHash());
					for (i=0; i < delayedTriggers.length; i++) {
						delayedTriggers[i].call(this, event);
					} //Trigger all delayed events
					this._trigger("stop", event, this._uiHash());
				}
	
				this.fromOutside = false;
				return false;
			}
	
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
			}
	
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
	
			if(this.helper[0] !== this.currentItem[0]) {
				this.helper.remove();
			}
			this.helper = null;
	
			if(!noPropagation) {
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
	
			this.fromOutside = false;
			return true;
	
		},
	
		_trigger: function() {
			if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
				this.cancel();
			}
		},
	
		_uiHash: function(_inst) {
			var inst = _inst || this;
			return {
				helper: inst.helper,
				placeholder: inst.placeholder || $([]),
				position: inst.position,
				originalPosition: inst.originalPosition,
				offset: inst.positionAbs,
				item: inst.currentItem,
				sender: _inst ? _inst.element : null
			};
		}
	
	});
	
	})(jQuery);
	
	(function($, undefined) {
	
	var dataSpace = "ui-effects-";
	
	$.effects = {
		effect: {}
	};
	
	/*!
	 * jQuery Color Animations v2.1.2
	 * https://github.com/jquery/jquery-color
	 *
	 * Copyright 2013 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: Wed Jan 16 08:47:09 2013 -0600
	 */
	(function( jQuery, undefined ) {
	
		var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
	
		// plusequals test for += 100 -= 100
		rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
		// a set of RE's that can match strings and generate color tuples.
		stringParsers = [{
				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ],
						execResult[ 3 ],
						execResult[ 4 ]
					];
				}
			}, {
				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ] * 2.55,
						execResult[ 2 ] * 2.55,
						execResult[ 3 ] * 2.55,
						execResult[ 4 ]
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ], 16 )
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
					];
				}
			}, {
				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				space: "hsla",
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ] / 100,
						execResult[ 3 ] / 100,
						execResult[ 4 ]
					];
				}
			}],
	
		// jQuery.Color( )
		color = jQuery.Color = function( color, green, blue, alpha ) {
			return new jQuery.Color.fn.parse( color, green, blue, alpha );
		},
		spaces = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},
	
			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		propTypes = {
			"byte": {
				floor: true,
				max: 255
			},
			"percent": {
				max: 1
			},
			"degrees": {
				mod: 360,
				floor: true
			}
		},
		support = color.support = {},
	
		// element for support tests
		supportElem = jQuery( "<p>" )[ 0 ],
	
		// colors = jQuery.Color.names
		colors,
	
		// local aliases of functions called often
		each = jQuery.each;
	
	// determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
	
	// define cache name and alpha properties
	// for rgba and hsla spaces
	each( spaces, function( spaceName, space ) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	});
	
	function clamp( value, prop, allowEmpty ) {
		var type = propTypes[ prop.type ] || {};
	
		if ( value == null ) {
			return (allowEmpty || !prop.def) ? null : prop.def;
		}
	
		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat( value );
	
		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if ( isNaN( value ) ) {
			return prop.def;
		}
	
		if ( type.mod ) {
			// we add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return (value + type.mod) % type.mod;
		}
	
		// for now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}
	
	function stringParse( string ) {
		var inst = color(),
			rgba = inst._rgba = [];
	
		string = string.toLowerCase();
	
		each( stringParsers, function( i, parser ) {
			var parsed,
				match = parser.re.exec( string ),
				values = match && parser.parse( match ),
				spaceName = parser.space || "rgba";
	
			if ( values ) {
				parsed = inst[ spaceName ]( values );
	
				// if this was an rgba parse the assignment might happen twice
				// oh well....
				inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
				rgba = inst._rgba = parsed._rgba;
	
				// exit each( stringParsers ) here because we matched
				return false;
			}
		});
	
		// Found a stringParser that handled it
		if ( rgba.length ) {
	
			// if this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if ( rgba.join() === "0,0,0,0" ) {
				jQuery.extend( rgba, colors.transparent );
			}
			return inst;
		}
	
		// named colors
		return colors[ string ];
	}
	
	color.fn = jQuery.extend( color.prototype, {
		parse: function( red, green, blue, alpha ) {
			if ( red === undefined ) {
				this._rgba = [ null, null, null, null ];
				return this;
			}
			if ( red.jquery || red.nodeType ) {
				red = jQuery( red ).css( green );
				green = undefined;
			}
	
			var inst = this,
				type = jQuery.type( red ),
				rgba = this._rgba = [];
	
			// more than 1 argument specified - assume ( red, green, blue, alpha )
			if ( green !== undefined ) {
				red = [ red, green, blue, alpha ];
				type = "array";
			}
	
			if ( type === "string" ) {
				return this.parse( stringParse( red ) || colors._default );
			}
	
			if ( type === "array" ) {
				each( spaces.rgba.props, function( key, prop ) {
					rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
				});
				return this;
			}
	
			if ( type === "object" ) {
				if ( red instanceof color ) {
					each( spaces, function( spaceName, space ) {
						if ( red[ space.cache ] ) {
							inst[ space.cache ] = red[ space.cache ].slice();
						}
					});
				} else {
					each( spaces, function( spaceName, space ) {
						var cache = space.cache;
						each( space.props, function( key, prop ) {
	
							// if the cache doesn't exist, and we know how to convert
							if ( !inst[ cache ] && space.to ) {
	
								// if the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if ( key === "alpha" || red[ key ] == null ) {
									return;
								}
								inst[ cache ] = space.to( inst._rgba );
							}
	
							// this is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
						});
	
						// everything defined but alpha?
						if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
							// use the default of 1
							inst[ cache ][ 3 ] = 1;
							if ( space.from ) {
								inst._rgba = space.from( inst[ cache ] );
							}
						}
					});
				}
				return this;
			}
		},
		is: function( compare ) {
			var is = color( compare ),
				same = true,
				inst = this;
	
			each( spaces, function( _, space ) {
				var localCache,
					isCache = is[ space.cache ];
				if (isCache) {
					localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
					each( space.props, function( _, prop ) {
						if ( isCache[ prop.idx ] != null ) {
							same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
							return same;
						}
					});
				}
				return same;
			});
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each( spaces, function( spaceName, space ) {
				if ( inst[ space.cache ] ) {
					used.push( spaceName );
				}
			});
			return used.pop();
		},
		transition: function( other, distance ) {
			var end = color( other ),
				spaceName = end._space(),
				space = spaces[ spaceName ],
				startColor = this.alpha() === 0 ? color( "transparent" ) : this,
				start = startColor[ space.cache ] || space.to( startColor._rgba ),
				result = start.slice();
	
			end = end[ space.cache ];
			each( space.props, function( key, prop ) {
				var index = prop.idx,
					startValue = start[ index ],
					endValue = end[ index ],
					type = propTypes[ prop.type ] || {};
	
				// if null, don't override start value
				if ( endValue === null ) {
					return;
				}
				// if null - use end
				if ( startValue === null ) {
					result[ index ] = endValue;
				} else {
					if ( type.mod ) {
						if ( endValue - startValue > type.mod / 2 ) {
							startValue += type.mod;
						} else if ( startValue - endValue > type.mod / 2 ) {
							startValue -= type.mod;
						}
					}
					result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
				}
			});
			return this[ spaceName ]( result );
		},
		blend: function( opaque ) {
			// if we are already opaque - return ourself
			if ( this._rgba[ 3 ] === 1 ) {
				return this;
			}
	
			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color( opaque )._rgba;
	
			return color( jQuery.map( rgb, function( v, i ) {
				return ( 1 - a ) * blend[ i ] + a * v;
			}));
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map( this._rgba, function( v, i ) {
					return v == null ? ( i > 2 ? 1 : 0 ) : v;
				});
	
			if ( rgba[ 3 ] === 1 ) {
				rgba.pop();
				prefix = "rgb(";
			}
	
			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map( this.hsla(), function( v, i ) {
					if ( v == null ) {
						v = i > 2 ? 1 : 0;
					}
	
					// catch 1 and 2
					if ( i && i < 3 ) {
						v = Math.round( v * 100 ) + "%";
					}
					return v;
				});
	
			if ( hsla[ 3 ] === 1 ) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function( includeAlpha ) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();
	
			if ( includeAlpha ) {
				rgba.push( ~~( alpha * 255 ) );
			}
	
			return "#" + jQuery.map( rgba, function( v ) {
	
				// default to 0 when nulls exist
				v = ( v || 0 ).toString( 16 );
				return v.length === 1 ? "0" + v : v;
			}).join("");
		},
		toString: function() {
			return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
		}
	});
	color.fn.parse.prototype = color.fn;
	
	// hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
	
	function hue2rgb( p, q, h ) {
		h = ( h + 1 ) % 1;
		if ( h * 6 < 1 ) {
			return p + (q - p) * h * 6;
		}
		if ( h * 2 < 1) {
			return q;
		}
		if ( h * 3 < 2 ) {
			return p + (q - p) * ((2/3) - h) * 6;
		}
		return p;
	}
	
	spaces.hsla.to = function ( rgba ) {
		if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
			return [ null, null, null, rgba[ 3 ] ];
		}
		var r = rgba[ 0 ] / 255,
			g = rgba[ 1 ] / 255,
			b = rgba[ 2 ] / 255,
			a = rgba[ 3 ],
			max = Math.max( r, g, b ),
			min = Math.min( r, g, b ),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;
	
		if ( min === max ) {
			h = 0;
		} else if ( r === max ) {
			h = ( 60 * ( g - b ) / diff ) + 360;
		} else if ( g === max ) {
			h = ( 60 * ( b - r ) / diff ) + 120;
		} else {
			h = ( 60 * ( r - g ) / diff ) + 240;
		}
	
		// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
		// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
		if ( diff === 0 ) {
			s = 0;
		} else if ( l <= 0.5 ) {
			s = diff / add;
		} else {
			s = diff / ( 2 - add );
		}
		return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
	};
	
	spaces.hsla.from = function ( hsla ) {
		if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
			return [ null, null, null, hsla[ 3 ] ];
		}
		var h = hsla[ 0 ] / 360,
			s = hsla[ 1 ],
			l = hsla[ 2 ],
			a = hsla[ 3 ],
			q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
			p = 2 * l - q;
	
		return [
			Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
			Math.round( hue2rgb( p, q, h ) * 255 ),
			Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
			a
		];
	};
	
	
	each( spaces, function( spaceName, space ) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;
	
		// makes rgba() and hsla()
		color.fn[ spaceName ] = function( value ) {
	
			// generate a cache for this space if it doesn't exist
			if ( to && !this[ cache ] ) {
				this[ cache ] = to( this._rgba );
			}
			if ( value === undefined ) {
				return this[ cache ].slice();
			}
	
			var ret,
				type = jQuery.type( value ),
				arr = ( type === "array" || type === "object" ) ? value : arguments,
				local = this[ cache ].slice();
	
			each( props, function( key, prop ) {
				var val = arr[ type === "object" ? key : prop.idx ];
				if ( val == null ) {
					val = local[ prop.idx ];
				}
				local[ prop.idx ] = clamp( val, prop );
			});
	
			if ( from ) {
				ret = color( from( local ) );
				ret[ cache ] = local;
				return ret;
			} else {
				return color( local );
			}
		};
	
		// makes red() green() blue() alpha() hue() saturation() lightness()
		each( props, function( key, prop ) {
			// alpha is included in more than one space
			if ( color.fn[ key ] ) {
				return;
			}
			color.fn[ key ] = function( value ) {
				var vtype = jQuery.type( value ),
					fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
					local = this[ fn ](),
					cur = local[ prop.idx ],
					match;
	
				if ( vtype === "undefined" ) {
					return cur;
				}
	
				if ( vtype === "function" ) {
					value = value.call( this, cur );
					vtype = jQuery.type( value );
				}
				if ( value == null && prop.empty ) {
					return this;
				}
				if ( vtype === "string" ) {
					match = rplusequals.exec( value );
					if ( match ) {
						value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
					}
				}
				local[ prop.idx ] = value;
				return this[ fn ]( local );
			};
		});
	});
	
	// add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function( hook ) {
		var hooks = hook.split( " " );
		each( hooks, function( i, hook ) {
			jQuery.cssHooks[ hook ] = {
				set: function( elem, value ) {
					var parsed, curElem,
						backgroundColor = "";
	
					if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
						value = color( parsed || value );
						if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								(backgroundColor === "" || backgroundColor === "transparent") &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css( curElem, "backgroundColor" );
									curElem = curElem.parentNode;
								} catch ( e ) {
								}
							}
	
							value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default" );
						}
	
						value = value.toRgbaString();
					}
					try {
						elem.style[ hook ] = value;
					} catch( e ) {
						// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[ hook ] = function( fx ) {
				if ( !fx.colorInit ) {
					fx.start = color( fx.elem, hook );
					fx.end = color( fx.end );
					fx.colorInit = true;
				}
				jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
			};
		});
	
	};
	
	color.hook( stepHooks );
	
	jQuery.cssHooks.borderColor = {
		expand: function( value ) {
			var expanded = {};
	
			each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
				expanded[ "border" + part + "Color" ] = value;
			});
			return expanded;
		}
	};
	
	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",
	
		// 4.2.3. "transparent" color keyword
		transparent: [ null, null, null, 0 ],
	
		_default: "#ffffff"
	};
	
	})( jQuery );
	
	
	/******************************************************************************/
	/****************************** CLASS ANIMATIONS ******************************/
	/******************************************************************************/
	(function() {
	
	var classAnimationActions = [ "add", "remove", "toggle" ],
		shorthandStyles = {
			border: 1,
			borderBottom: 1,
			borderColor: 1,
			borderLeft: 1,
			borderRight: 1,
			borderTop: 1,
			borderWidth: 1,
			margin: 1,
			padding: 1
		};
	
	$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	});
	
	function getElementStyles( elem ) {
		var key, len,
			style = elem.ownerDocument.defaultView ?
				elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
				elem.currentStyle,
			styles = {};
	
		if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
			len = style.length;
			while ( len-- ) {
				key = style[ len ];
				if ( typeof style[ key ] === "string" ) {
					styles[ $.camelCase( key ) ] = style[ key ];
				}
			}
		// support: Opera, IE <9
		} else {
			for ( key in style ) {
				if ( typeof style[ key ] === "string" ) {
					styles[ key ] = style[ key ];
				}
			}
		}
	
		return styles;
	}
	
	
	function styleDifference( oldStyle, newStyle ) {
		var diff = {},
			name, value;
	
		for ( name in newStyle ) {
			value = newStyle[ name ];
			if ( oldStyle[ name ] !== value ) {
				if ( !shorthandStyles[ name ] ) {
					if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
						diff[ name ] = value;
					}
				}
			}
		}
	
		return diff;
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	$.effects.animateClass = function( value, duration, easing, callback ) {
		var o = $.speed( duration, easing, callback );
	
		return this.queue( function() {
			var animated = $( this ),
				baseClass = animated.attr( "class" ) || "",
				applyClassChange,
				allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
	
			// map the animated objects to store the original styles.
			allAnimations = allAnimations.map(function() {
				var el = $( this );
				return {
					el: el,
					start: getElementStyles( this )
				};
			});
	
			// apply class change
			applyClassChange = function() {
				$.each( classAnimationActions, function(i, action) {
					if ( value[ action ] ) {
						animated[ action + "Class" ]( value[ action ] );
					}
				});
			};
			applyClassChange();
	
			// map all animated objects again - calculate new styles and diff
			allAnimations = allAnimations.map(function() {
				this.end = getElementStyles( this.el[ 0 ] );
				this.diff = styleDifference( this.start, this.end );
				return this;
			});
	
			// apply original class
			animated.attr( "class", baseClass );
	
			// map all animated objects again - this time collecting a promise
			allAnimations = allAnimations.map(function() {
				var styleInfo = this,
					dfd = $.Deferred(),
					opts = $.extend({}, o, {
						queue: false,
						complete: function() {
							dfd.resolve( styleInfo );
						}
					});
	
				this.el.animate( this.diff, opts );
				return dfd.promise();
			});
	
			// once all animations have completed:
			$.when.apply( $, allAnimations.get() ).done(function() {
	
				// set the final class
				applyClassChange();
	
				// for each animated element,
				// clear all css properties that were animated
				$.each( arguments, function() {
					var el = this.el;
					$.each( this.diff, function(key) {
						el.css( key, "" );
					});
				});
	
				// this is guarnteed to be there if you use jQuery.speed()
				// it also handles dequeuing the next anim...
				o.complete.call( animated[ 0 ] );
			});
		});
	};
	
	$.fn.extend({
		addClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return speed ?
					$.effects.animateClass.call( this,
						{ add: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.addClass ),
	
		removeClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return arguments.length > 1 ?
					$.effects.animateClass.call( this,
						{ remove: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.removeClass ),
	
		toggleClass: (function( orig ) {
			return function( classNames, force, speed, easing, callback ) {
				if ( typeof force === "boolean" || force === undefined ) {
					if ( !speed ) {
						// without speed parameter
						return orig.apply( this, arguments );
					} else {
						return $.effects.animateClass.call( this,
							(force ? { add: classNames } : { remove: classNames }),
							speed, easing, callback );
					}
				} else {
					// without force parameter
					return $.effects.animateClass.call( this,
						{ toggle: classNames }, force, speed, easing );
				}
			};
		})( $.fn.toggleClass ),
	
		switchClass: function( remove, add, speed, easing, callback) {
			return $.effects.animateClass.call( this, {
				add: add,
				remove: remove
			}, speed, easing, callback );
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EFFECTS **********************************/
	/******************************************************************************/
	
	(function() {
	
	$.extend( $.effects, {
		version: "1.10.3",
	
		// Saves a set of properties in a data storage
		save: function( element, set ) {
			for( var i=0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},
	
		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i;
			for( i=0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					// support: jQuery 1.6.2
					// http://bugs.jquery.com/ticket/9917
					// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
					// We can't differentiate between "" and 0 here, so we just assume
					// empty string since it's likely to be a more common value...
					if ( val === undefined ) {
						val = "";
					}
					element.css( set[ i ], val );
				}
			}
		},
	
		setMode: function( el, mode ) {
			if (mode === "toggle") {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},
	
		// Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		getBaseline: function( origin, original ) {
			var y, x;
			switch ( origin[ 0 ] ) {
				case "top": y = 0; break;
				case "middle": y = 0.5; break;
				case "bottom": y = 1; break;
				default: y = origin[ 0 ] / original.height;
			}
			switch ( origin[ 1 ] ) {
				case "left": x = 0; break;
				case "center": x = 0.5; break;
				case "right": x = 1; break;
				default: x = origin[ 1 ] / original.width;
			}
			return {
				x: x,
				y: y
			};
		},
	
		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {
	
			// if the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" )) {
				return element.parent();
			}
	
			// wrap the element
			var props = {
					width: element.outerWidth(true),
					height: element.outerHeight(true),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css({
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					}),
				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;
	
			// support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch( e ) {
				active = document.body;
			}
	
			element.wrap( wrapper );
	
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
	
			wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
	
			// transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css({ position: "relative" });
				element.css({ position: "relative" });
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				});
				$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				});
				element.css({
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				});
			}
			element.css(size);
	
			return wrapper.css( props ).show();
		},
	
		removeWrapper: function( element ) {
			var active = document.activeElement;
	
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );
	
				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).focus();
				}
			}
	
	
			return element;
		},
	
		setTransition: function( element, list, factor, value ) {
			value = value || {};
			$.each( list, function( i, x ) {
				var unit = element.cssUnit( x );
				if ( unit[ 0 ] > 0 ) {
					value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
				}
			});
			return value;
		}
	});
	
	// return an effect options object for the given parameters:
	function _normalizeArguments( effect, options, speed, callback ) {
	
		// allow passing all options as the first parameter
		if ( $.isPlainObject( effect ) ) {
			options = effect;
			effect = effect.effect;
		}
	
		// convert to an object
		effect = { effect: effect };
	
		// catch (effect, null, ...)
		if ( options == null ) {
			options = {};
		}
	
		// catch (effect, callback)
		if ( $.isFunction( options ) ) {
			callback = options;
			speed = null;
			options = {};
		}
	
		// catch (effect, speed, ?)
		if ( typeof options === "number" || $.fx.speeds[ options ] ) {
			callback = speed;
			speed = options;
			options = {};
		}
	
		// catch (effect, options, callback)
		if ( $.isFunction( speed ) ) {
			callback = speed;
			speed = null;
		}
	
		// add options to effect
		if ( options ) {
			$.extend( effect, options );
		}
	
		speed = speed || options.duration;
		effect.duration = $.fx.off ? 0 :
			typeof speed === "number" ? speed :
			speed in $.fx.speeds ? $.fx.speeds[ speed ] :
			$.fx.speeds._default;
	
		effect.complete = callback || options.complete;
	
		return effect;
	}
	
	function standardAnimationOption( option ) {
		// Valid standard speeds (nothing, number, named speed)
		if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
			return true;
		}
	
		// Invalid strings - treat as "normal" speed
		if ( typeof option === "string" && !$.effects.effect[ option ] ) {
			return true;
		}
	
		// Complete callback
		if ( $.isFunction( option ) ) {
			return true;
		}
	
		// Options hash (but not naming an effect)
		if ( typeof option === "object" && !option.effect ) {
			return true;
		}
	
		// Didn't match any standard API
		return false;
	}
	
	$.fn.extend({
		effect: function( /* effect, options, speed, callback */ ) {
			var args = _normalizeArguments.apply( this, arguments ),
				mode = args.mode,
				queue = args.queue,
				effectMethod = $.effects.effect[ args.effect ];
	
			if ( $.fx.off || !effectMethod ) {
				// delegate to the original method (e.g., .show()) if possible
				if ( mode ) {
					return this[ mode ]( args.duration, args.complete );
				} else {
					return this.each( function() {
						if ( args.complete ) {
							args.complete.call( this );
						}
					});
				}
			}
	
			function run( next ) {
				var elem = $( this ),
					complete = args.complete,
					mode = args.mode;
	
				function done() {
					if ( $.isFunction( complete ) ) {
						complete.call( elem[0] );
					}
					if ( $.isFunction( next ) ) {
						next();
					}
				}
	
				// If the element already has the correct final state, delegate to
				// the core methods so the internal tracking of "olddisplay" works.
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[0], args, done );
				}
			}
	
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		},
	
		show: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "show";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.show ),
	
		hide: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "hide";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.hide ),
	
		toggle: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "toggle";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.toggle ),
	
		// helper functions
		cssUnit: function(key) {
			var style = this.css( key ),
				val = [];
	
			$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
				if ( style.indexOf( unit ) > 0 ) {
					val = [ parseFloat( style ), unit ];
				}
			});
			return val;
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EASING ***********************************/
	/******************************************************************************/
	
	(function() {
	
	// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
	
	var baseEasings = {};
	
	$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
		baseEasings[ name ] = function( p ) {
			return Math.pow( p, i + 2 );
		};
	});
	
	$.extend( baseEasings, {
		Sine: function ( p ) {
			return 1 - Math.cos( p * Math.PI / 2 );
		},
		Circ: function ( p ) {
			return 1 - Math.sqrt( 1 - p * p );
		},
		Elastic: function( p ) {
			return p === 0 || p === 1 ? p :
				-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
		},
		Back: function( p ) {
			return p * p * ( 3 * p - 2 );
		},
		Bounce: function ( p ) {
			var pow2,
				bounce = 4;
	
			while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
			return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
		}
	});
	
	$.each( baseEasings, function( name, easeIn ) {
		$.easing[ "easeIn" + name ] = easeIn;
		$.easing[ "easeOut" + name ] = function( p ) {
			return 1 - easeIn( 1 - p );
		};
		$.easing[ "easeInOut" + name ] = function( p ) {
			return p < 0.5 ?
				easeIn( p * 2 ) / 2 :
				1 - easeIn( p * -2 + 2 ) / 2;
		};
	});
	
	})();
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	var uid = 0,
		hideProps = {},
		showProps = {};
	
	hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
		hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
	showProps.height = showProps.paddingTop = showProps.paddingBottom =
		showProps.borderTopWidth = showProps.borderBottomWidth = "show";
	
	$.widget( "ui.accordion", {
		version: "1.10.3",
		options: {
			active: 0,
			animate: {},
			collapsible: false,
			event: "click",
			header: "> li > :first-child,> :not(li):even",
			heightStyle: "auto",
			icons: {
				activeHeader: "ui-icon-triangle-1-s",
				header: "ui-icon-triangle-1-e"
			},
	
			// callbacks
			activate: null,
			beforeActivate: null
		},
	
		_create: function() {
			var options = this.options;
			this.prevShow = this.prevHide = $();
			this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
				// ARIA
				.attr( "role", "tablist" );
	
			// don't allow collapsible: false and active: false / null
			if ( !options.collapsible && (options.active === false || options.active == null) ) {
				options.active = 0;
			}
	
			this._processPanels();
			// handle negative values
			if ( options.active < 0 ) {
				options.active += this.headers.length;
			}
			this._refresh();
		},
	
		_getCreateEventData: function() {
			return {
				header: this.active,
				panel: !this.active.length ? $() : this.active.next(),
				content: !this.active.length ? $() : this.active.next()
			};
		},
	
		_createIcons: function() {
			var icons = this.options.icons;
			if ( icons ) {
				$( "<span>" )
					.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
					.prependTo( this.headers );
				this.active.children( ".ui-accordion-header-icon" )
					.removeClass( icons.header )
					.addClass( icons.activeHeader );
				this.headers.addClass( "ui-accordion-icons" );
			}
		},
	
		_destroyIcons: function() {
			this.headers
				.removeClass( "ui-accordion-icons" )
				.children( ".ui-accordion-header-icon" )
					.remove();
		},
	
		_destroy: function() {
			var contents;
	
			// clean up main element
			this.element
				.removeClass( "ui-accordion ui-widget ui-helper-reset" )
				.removeAttr( "role" );
	
			// clean up headers
			this.headers
				.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
				.removeAttr( "role" )
				.removeAttr( "aria-selected" )
				.removeAttr( "aria-controls" )
				.removeAttr( "tabIndex" )
				.each(function() {
					if ( /^ui-accordion/.test( this.id ) ) {
						this.removeAttribute( "id" );
					}
				});
			this._destroyIcons();
	
			// clean up content panels
			contents = this.headers.next()
				.css( "display", "" )
				.removeAttr( "role" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-labelledby" )
				.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
				.each(function() {
					if ( /^ui-accordion/.test( this.id ) ) {
						this.removeAttribute( "id" );
					}
				});
			if ( this.options.heightStyle !== "content" ) {
				contents.css( "height", "" );
			}
		},
	
		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}
	
			if ( key === "event" ) {
				if ( this.options.event ) {
					this._off( this.headers, this.options.event );
				}
				this._setupEvents( value );
			}
	
			this._super( key, value );
	
			// setting collapsible: false while collapsed; open first panel
			if ( key === "collapsible" && !value && this.options.active === false ) {
				this._activate( 0 );
			}
	
			if ( key === "icons" ) {
				this._destroyIcons();
				if ( value ) {
					this._createIcons();
				}
			}
	
			// #5332 - opacity doesn't cascade to positioned elements in IE
			// so we need to add the disabled class to the headers and panels
			if ( key === "disabled" ) {
				this.headers.add( this.headers.next() )
					.toggleClass( "ui-state-disabled", !!value );
			}
		},
	
		_keydown: function( event ) {
			/*jshint maxcomplexity:15*/
			if ( event.altKey || event.ctrlKey ) {
				return;
			}
	
			var keyCode = $.ui.keyCode,
				length = this.headers.length,
				currentIndex = this.headers.index( event.target ),
				toFocus = false;
	
			switch ( event.keyCode ) {
				case keyCode.RIGHT:
				case keyCode.DOWN:
					toFocus = this.headers[ ( currentIndex + 1 ) % length ];
					break;
				case keyCode.LEFT:
				case keyCode.UP:
					toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
					break;
				case keyCode.SPACE:
				case keyCode.ENTER:
					this._eventHandler( event );
					break;
				case keyCode.HOME:
					toFocus = this.headers[ 0 ];
					break;
				case keyCode.END:
					toFocus = this.headers[ length - 1 ];
					break;
			}
	
			if ( toFocus ) {
				$( event.target ).attr( "tabIndex", -1 );
				$( toFocus ).attr( "tabIndex", 0 );
				toFocus.focus();
				event.preventDefault();
			}
		},
	
		_panelKeyDown : function( event ) {
			if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
				$( event.currentTarget ).prev().focus();
			}
		},
	
		refresh: function() {
			var options = this.options;
			this._processPanels();
	
			// was collapsed or no panel
			if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
				options.active = false;
				this.active = $();
			// active false only when collapsible is true
			} else if ( options.active === false ) {
				this._activate( 0 );
			// was active, but active panel is gone
			} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				// all remaining panel are disabled
				if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
					options.active = false;
					this.active = $();
				// activate previous panel
				} else {
					this._activate( Math.max( 0, options.active - 1 ) );
				}
			// was active, active panel still exists
			} else {
				// make sure active index is correct
				options.active = this.headers.index( this.active );
			}
	
			this._destroyIcons();
	
			this._refresh();
		},
	
		_processPanels: function() {
			this.headers = this.element.find( this.options.header )
				.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
	
			this.headers.next()
				.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
				.filter(":not(.ui-accordion-content-active)")
				.hide();
		},
	
		_refresh: function() {
			var maxHeight,
				options = this.options,
				heightStyle = options.heightStyle,
				parent = this.element.parent(),
				accordionId = this.accordionId = "ui-accordion-" +
					(this.element.attr( "id" ) || ++uid);
	
			this.active = this._findActive( options.active )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
				.removeClass( "ui-corner-all" );
			this.active.next()
				.addClass( "ui-accordion-content-active" )
				.show();
	
			this.headers
				.attr( "role", "tab" )
				.each(function( i ) {
					var header = $( this ),
						headerId = header.attr( "id" ),
						panel = header.next(),
						panelId = panel.attr( "id" );
					if ( !headerId ) {
						headerId = accordionId + "-header-" + i;
						header.attr( "id", headerId );
					}
					if ( !panelId ) {
						panelId = accordionId + "-panel-" + i;
						panel.attr( "id", panelId );
					}
					header.attr( "aria-controls", panelId );
					panel.attr( "aria-labelledby", headerId );
				})
				.next()
					.attr( "role", "tabpanel" );
	
			this.headers
				.not( this.active )
				.attr({
					"aria-selected": "false",
					tabIndex: -1
				})
				.next()
					.attr({
						"aria-expanded": "false",
						"aria-hidden": "true"
					})
					.hide();
	
			// make sure at least one header is in the tab order
			if ( !this.active.length ) {
				this.headers.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active.attr({
					"aria-selected": "true",
					tabIndex: 0
				})
				.next()
					.attr({
						"aria-expanded": "true",
						"aria-hidden": "false"
					});
			}
	
			this._createIcons();
	
			this._setupEvents( options.event );
	
			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );
	
					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});
	
				this.headers.each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});
	
				this.headers.next()
					.each(function() {
						$( this ).height( Math.max( 0, maxHeight -
							$( this ).innerHeight() + $( this ).height() ) );
					})
					.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.headers.next()
					.each(function() {
						maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					})
					.height( maxHeight );
			}
		},
	
		_activate: function( index ) {
			var active = this._findActive( index )[ 0 ];
	
			// trying to activate the already active panel
			if ( active === this.active[ 0 ] ) {
				return;
			}
	
			// trying to collapse, simulate a click on the currently active header
			active = active || this.active[ 0 ];
	
			this._eventHandler({
				target: active,
				currentTarget: active,
				preventDefault: $.noop
			});
		},
	
		_findActive: function( selector ) {
			return typeof selector === "number" ? this.headers.eq( selector ) : $();
		},
	
		_setupEvents: function( event ) {
			var events = {
				keydown: "_keydown"
			};
			if ( event ) {
				$.each( event.split(" "), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}
	
			this._off( this.headers.add( this.headers.next() ) );
			this._on( this.headers, events );
			this._on( this.headers.next(), { keydown: "_panelKeyDown" });
			this._hoverable( this.headers );
			this._focusable( this.headers );
		},
	
		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				clicked = $( event.currentTarget ),
				clickedIsActive = clicked[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : clicked.next(),
				toHide = active.next(),
				eventData = {
					oldHeader: active,
					oldPanel: toHide,
					newHeader: collapsing ? $() : clicked,
					newPanel: toShow
				};
	
			event.preventDefault();
	
			if (
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}
	
			options.active = collapsing ? false : this.headers.index( clicked );
	
			// when the call to ._toggle() comes after the class changes
			// it causes a very odd bug in IE 8 (see #6720)
			this.active = clickedIsActive ? $() : clicked;
			this._toggle( eventData );
	
			// switch classes
			// corner classes on the previously active header stay after the animation
			active.removeClass( "ui-accordion-header-active ui-state-active" );
			if ( options.icons ) {
				active.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.activeHeader )
					.addClass( options.icons.header );
			}
	
			if ( !clickedIsActive ) {
				clicked
					.removeClass( "ui-corner-all" )
					.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
				if ( options.icons ) {
					clicked.children( ".ui-accordion-header-icon" )
						.removeClass( options.icons.header )
						.addClass( options.icons.activeHeader );
				}
	
				clicked
					.next()
					.addClass( "ui-accordion-content-active" );
			}
		},
	
		_toggle: function( data ) {
			var toShow = data.newPanel,
				toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
	
			// handle activating a panel during the animation for another activation
			this.prevShow.add( this.prevHide ).stop( true, true );
			this.prevShow = toShow;
			this.prevHide = toHide;
	
			if ( this.options.animate ) {
				this._animate( toShow, toHide, data );
			} else {
				toHide.hide();
				toShow.show();
				this._toggleComplete( data );
			}
	
			toHide.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});
			toHide.prev().attr( "aria-selected", "false" );
			// if we're switching panels, remove the old header from the tab order
			// if we're opening from collapsed state, remove the previous header from the tab order
			// if we're collapsing, then keep the collapsing header in the tab order
			if ( toShow.length && toHide.length ) {
				toHide.prev().attr( "tabIndex", -1 );
			} else if ( toShow.length ) {
				this.headers.filter(function() {
					return $( this ).attr( "tabIndex" ) === 0;
				})
				.attr( "tabIndex", -1 );
			}
	
			toShow
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				})
				.prev()
					.attr({
						"aria-selected": "true",
						tabIndex: 0
					});
		},
	
		_animate: function( toShow, toHide, data ) {
			var total, easing, duration,
				that = this,
				adjust = 0,
				down = toShow.length &&
					( !toHide.length || ( toShow.index() < toHide.index() ) ),
				animate = this.options.animate || {},
				options = down && animate.down || animate,
				complete = function() {
					that._toggleComplete( data );
				};
	
			if ( typeof options === "number" ) {
				duration = options;
			}
			if ( typeof options === "string" ) {
				easing = options;
			}
			// fall back from options to animation in case of partial down settings
			easing = easing || options.easing || animate.easing;
			duration = duration || options.duration || animate.duration;
	
			if ( !toHide.length ) {
				return toShow.animate( showProps, duration, easing, complete );
			}
			if ( !toShow.length ) {
				return toHide.animate( hideProps, duration, easing, complete );
			}
	
			total = toShow.show().outerHeight();
			toHide.animate( hideProps, {
				duration: duration,
				easing: easing,
				step: function( now, fx ) {
					fx.now = Math.round( now );
				}
			});
			toShow
				.hide()
				.animate( showProps, {
					duration: duration,
					easing: easing,
					complete: complete,
					step: function( now, fx ) {
						fx.now = Math.round( now );
						if ( fx.prop !== "height" ) {
							adjust += fx.now;
						} else if ( that.options.heightStyle !== "content" ) {
							fx.now = Math.round( total - toHide.outerHeight() - adjust );
							adjust = 0;
						}
					}
				});
		},
	
		_toggleComplete: function( data ) {
			var toHide = data.oldPanel;
	
			toHide
				.removeClass( "ui-accordion-content-active" )
				.prev()
					.removeClass( "ui-corner-top" )
					.addClass( "ui-corner-all" );
	
			// Work around for rendering bug in IE (#5421)
			if ( toHide.length ) {
				toHide.parent()[0].className = toHide.parent()[0].className;
			}
	
			this._trigger( "activate", null, data );
		}
	});
	
	})( jQuery );
	
	(function( $, undefined ) {
	
	// used to prevent race conditions with remote data sources
	var requestIndex = 0;
	
	$.widget( "ui.autocomplete", {
		version: "1.10.3",
		defaultElement: "<input>",
		options: {
			appendTo: null,
			autoFocus: false,
			delay: 300,
			minLength: 1,
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			source: null,
	
			// callbacks
			change: null,
			close: null,
			focus: null,
			open: null,
			response: null,
			search: null,
			select: null
		},
	
		pending: 0,
	
		_create: function() {
			// Some browsers only repeat keydown events, not keypress events,
			// so we use the suppressKeyPress flag to determine if we've already
			// handled the keydown event. #7269
			// Unfortunately the code for & in keypress is the same as the up arrow,
			// so we use the suppressKeyPressRepeat flag to avoid handling keypress
			// events when we know the keydown event was used to modify the
			// search term. #7799
			var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
				nodeName = this.element[0].nodeName.toLowerCase(),
				isTextarea = nodeName === "textarea",
				isInput = nodeName === "input";
	
			this.isMultiLine =
				// Textareas are always multi-line
				isTextarea ? true :
				// Inputs are always single-line, even if inside a contentEditable element
				// IE also treats inputs as contentEditable
				isInput ? false :
				// All other element types are determined by whether or not they're contentEditable
				this.element.prop( "isContentEditable" );
	
			this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
			this.isNewMenu = true;
	
			this.element
				.addClass( "ui-autocomplete-input" )
				.attr( "autocomplete", "off" );
	
			this._on( this.element, {
				keydown: function( event ) {
					/*jshint maxcomplexity:15*/
					if ( this.element.prop( "readOnly" ) ) {
						suppressKeyPress = true;
						suppressInput = true;
						suppressKeyPressRepeat = true;
						return;
					}
	
					suppressKeyPress = false;
					suppressInput = false;
					suppressKeyPressRepeat = false;
					var keyCode = $.ui.keyCode;
					switch( event.keyCode ) {
					case keyCode.PAGE_UP:
						suppressKeyPress = true;
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						suppressKeyPress = true;
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						suppressKeyPress = true;
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						suppressKeyPress = true;
						this._keyEvent( "next", event );
						break;
					case keyCode.ENTER:
					case keyCode.NUMPAD_ENTER:
						// when menu is open and has focus
						if ( this.menu.active ) {
							// #6055 - Opera still allows the keypress to occur
							// which causes forms to submit
							suppressKeyPress = true;
							event.preventDefault();
							this.menu.select( event );
						}
						break;
					case keyCode.TAB:
						if ( this.menu.active ) {
							this.menu.select( event );
						}
						break;
					case keyCode.ESCAPE:
						if ( this.menu.element.is( ":visible" ) ) {
							this._value( this.term );
							this.close( event );
							// Different browsers have different default behavior for escape
							// Single press can mean undo or clear
							// Double press in IE means clear the whole form
							event.preventDefault();
						}
						break;
					default:
						suppressKeyPressRepeat = true;
						// search timeout should be triggered before the input value is changed
						this._searchTimeout( event );
						break;
					}
				},
				keypress: function( event ) {
					if ( suppressKeyPress ) {
						suppressKeyPress = false;
						if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
							event.preventDefault();
						}
						return;
					}
					if ( suppressKeyPressRepeat ) {
						return;
					}
	
					// replicate some key handlers to allow them to repeat in Firefox and Opera
					var keyCode = $.ui.keyCode;
					switch( event.keyCode ) {
					case keyCode.PAGE_UP:
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						this._keyEvent( "next", event );
						break;
					}
				},
				input: function( event ) {
					if ( suppressInput ) {
						suppressInput = false;
						event.preventDefault();
						return;
					}
					this._searchTimeout( event );
				},
				focus: function() {
					this.selectedItem = null;
					this.previous = this._value();
				},
				blur: function( event ) {
					if ( this.cancelBlur ) {
						delete this.cancelBlur;
						return;
					}
	
					clearTimeout( this.searching );
					this.close( event );
					this._change( event );
				}
			});
	
			this._initSource();
			this.menu = $( "<ul>" )
				.addClass( "ui-autocomplete ui-front" )
				.appendTo( this._appendTo() )
				.menu({
					// disable ARIA support, the live region takes care of that
					role: null
				})
				.hide()
				.data( "ui-menu" );
	
			this._on( this.menu.element, {
				mousedown: function( event ) {
					// prevent moving focus out of the text field
					event.preventDefault();
	
					// IE doesn't prevent moving focus even with event.preventDefault()
					// so we set a flag to know when we should ignore the blur event
					this.cancelBlur = true;
					this._delay(function() {
						delete this.cancelBlur;
					});
	
					// clicking on the scrollbar causes focus to shift to the body
					// but we can't detect a mouseup or a click immediately afterward
					// so we have to track the next mousedown and close the menu if
					// the user clicks somewhere outside of the autocomplete
					var menuElement = this.menu.element[ 0 ];
					if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
						this._delay(function() {
							var that = this;
							this.document.one( "mousedown", function( event ) {
								if ( event.target !== that.element[ 0 ] &&
										event.target !== menuElement &&
										!$.contains( menuElement, event.target ) ) {
									that.close();
								}
							});
						});
					}
				},
				menufocus: function( event, ui ) {
					// support: Firefox
					// Prevent accidental activation of menu items in Firefox (#7024 #9118)
					if ( this.isNewMenu ) {
						this.isNewMenu = false;
						if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
							this.menu.blur();
	
							this.document.one( "mousemove", function() {
								$( event.target ).trigger( event.originalEvent );
							});
	
							return;
						}
					}
	
					var item = ui.item.data( "ui-autocomplete-item" );
					if ( false !== this._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
							this._value( item.value );
						}
					} else {
						// Normally the input is populated with the item's value as the
						// menu is navigated, causing screen readers to notice a change and
						// announce the item. Since the focus event was canceled, this doesn't
						// happen, so we update the live region so that screen readers can
						// still notice the change and announce it.
						this.liveRegion.text( item.value );
					}
				},
				menuselect: function( event, ui ) {
					var item = ui.item.data( "ui-autocomplete-item" ),
						previous = this.previous;
	
					// only trigger when focus was lost (click on menu)
					if ( this.element[0] !== this.document[0].activeElement ) {
						this.element.focus();
						this.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						this._delay(function() {
							this.previous = previous;
							this.selectedItem = item;
						});
					}
	
					if ( false !== this._trigger( "select", event, { item: item } ) ) {
						this._value( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					this.term = this._value();
	
					this.close( event );
					this.selectedItem = item;
				}
			});
	
			this.liveRegion = $( "<span>", {
					role: "status",
					"aria-live": "polite"
				})
				.addClass( "ui-helper-hidden-accessible" )
				.insertBefore( this.element );
	
			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},
	
		_destroy: function() {
			clearTimeout( this.searching );
			this.element
				.removeClass( "ui-autocomplete-input" )
				.removeAttr( "autocomplete" );
			this.menu.element.remove();
			this.liveRegion.remove();
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "source" ) {
				this._initSource();
			}
			if ( key === "appendTo" ) {
				this.menu.element.appendTo( this._appendTo() );
			}
			if ( key === "disabled" && value && this.xhr ) {
				this.xhr.abort();
			}
		},
	
		_appendTo: function() {
			var element = this.options.appendTo;
	
			if ( element ) {
				element = element.jquery || element.nodeType ?
					$( element ) :
					this.document.find( element ).eq( 0 );
			}
	
			if ( !element ) {
				element = this.element.closest( ".ui-front" );
			}
	
			if ( !element.length ) {
				element = this.document[0].body;
			}
	
			return element;
		},
	
		_initSource: function() {
			var array, url,
				that = this;
			if ( $.isArray(this.options.source) ) {
				array = this.options.source;
				this.source = function( request, response ) {
					response( $.ui.autocomplete.filter( array, request.term ) );
				};
			} else if ( typeof this.options.source === "string" ) {
				url = this.options.source;
				this.source = function( request, response ) {
					if ( that.xhr ) {
						that.xhr.abort();
					}
					that.xhr = $.ajax({
						url: url,
						data: request,
						dataType: "json",
						success: function( data ) {
							response( data );
						},
						error: function() {
							response( [] );
						}
					});
				};
			} else {
				this.source = this.options.source;
			}
		},
	
		_searchTimeout: function( event ) {
			clearTimeout( this.searching );
			this.searching = this._delay(function() {
				// only search if the value has changed
				if ( this.term !== this._value() ) {
					this.selectedItem = null;
					this.search( null, event );
				}
			}, this.options.delay );
		},
	
		search: function( value, event ) {
			value = value != null ? value : this._value();
	
			// always save the actual value, not the one passed as an argument
			this.term = this._value();
	
			if ( value.length < this.options.minLength ) {
				return this.close( event );
			}
	
			if ( this._trigger( "search", event ) === false ) {
				return;
			}
	
			return this._search( value );
		},
	
		_search: function( value ) {
			this.pending++;
			this.element.addClass( "ui-autocomplete-loading" );
			this.cancelSearch = false;
	
			this.source( { term: value }, this._response() );
		},
	
		_response: function() {
			var that = this,
				index = ++requestIndex;
	
			return function( content ) {
				if ( index === requestIndex ) {
					that.__response( content );
				}
	
				that.pending--;
				if ( !that.pending ) {
					that.element.removeClass( "ui-autocomplete-loading" );
				}
			};
		},
	
		__response: function( content ) {
			if ( content ) {
				content = this._normalize( content );
			}
			this._trigger( "response", null, { content: content } );
			if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
				this._suggest( content );
				this._trigger( "open" );
			} else {
				// use ._close() instead of .close() so we don't cancel future searches
				this._close();
			}
		},
	
		close: function( event ) {
			this.cancelSearch = true;
			this._close( event );
		},
	
		_close: function( event ) {
			if ( this.menu.element.is( ":visible" ) ) {
				this.menu.element.hide();
				this.menu.blur();
				this.isNewMenu = true;
				this._trigger( "close", event );
			}
		},
	
		_change: function( event ) {
			if ( this.previous !== this._value() ) {
				this._trigger( "change", event, { item: this.selectedItem } );
			}
		},
	
		_normalize: function( items ) {
			// assume all items have the right format when the first item is complete
			if ( items.length && items[0].label && items[0].value ) {
				return items;
			}
			return $.map( items, function( item ) {
				if ( typeof item === "string" ) {
					return {
						label: item,
						value: item
					};
				}
				return $.extend({
					label: item.label || item.value,
					value: item.value || item.label
				}, item );
			});
		},
	
		_suggest: function( items ) {
			var ul = this.menu.element.empty();
			this._renderMenu( ul, items );
			this.isNewMenu = true;
			this.menu.refresh();
	
			// size and position menu
			ul.show();
			this._resizeMenu();
			ul.position( $.extend({
				of: this.element
			}, this.options.position ));
	
			if ( this.options.autoFocus ) {
				this.menu.next();
			}
		},
	
		_resizeMenu: function() {
			var ul = this.menu.element;
			ul.outerWidth( Math.max(
				// Firefox wraps long text (possibly a rounding bug)
				// so we add 1px to avoid the wrapping (#7513)
				ul.width( "" ).outerWidth() + 1,
				this.element.outerWidth()
			) );
		},
	
		_renderMenu: function( ul, items ) {
			var that = this;
			$.each( items, function( index, item ) {
				that._renderItemData( ul, item );
			});
		},
	
		_renderItemData: function( ul, item ) {
			return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
		},
	
		_renderItem: function( ul, item ) {
			return $( "<li>" )
				.append( $( "<a>" ).text( item.label ) )
				.appendTo( ul );
		},
	
		_move: function( direction, event ) {
			if ( !this.menu.element.is( ":visible" ) ) {
				this.search( null, event );
				return;
			}
			if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
					this.menu.isLastItem() && /^next/.test( direction ) ) {
				this._value( this.term );
				this.menu.blur();
				return;
			}
			this.menu[ direction ]( event );
		},
	
		widget: function() {
			return this.menu.element;
		},
	
		_value: function() {
			return this.valueMethod.apply( this.element, arguments );
		},
	
		_keyEvent: function( keyEvent, event ) {
			if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
				this._move( keyEvent, event );
	
				// prevents moving cursor to beginning/end of the text field in some browsers
				event.preventDefault();
			}
		}
	});
	
	$.extend( $.ui.autocomplete, {
		escapeRegex: function( value ) {
			return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
		},
		filter: function(array, term) {
			var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
			return $.grep( array, function(value) {
				return matcher.test( value.label || value.value || value );
			});
		}
	});
	
	
	// live region extension, adding a `messages` option
	// NOTE: This is an experimental API. We are still investigating
	// a full solution for string manipulation and internationalization.
	$.widget( "ui.autocomplete", $.ui.autocomplete, {
		options: {
			messages: {
				noResults: "No search results.",
				results: function( amount ) {
					return amount + ( amount > 1 ? " results are" : " result is" ) +
						" available, use up and down arrow keys to navigate.";
				}
			}
		},
	
		__response: function( content ) {
			var message;
			this._superApply( arguments );
			if ( this.options.disabled || this.cancelSearch ) {
				return;
			}
			if ( content && content.length ) {
				message = this.options.messages.results( content.length );
			} else {
				message = this.options.messages.noResults;
			}
			this.liveRegion.text( message );
		}
	});
	
	}( jQuery ));
	
	(function( $, undefined ) {
	
	var lastActive, startXPos, startYPos, clickDragged,
		baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
		stateClasses = "ui-state-hover ui-state-active ",
		typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
		formResetHandler = function() {
			var form = $( this );
			setTimeout(function() {
				form.find( ":ui-button" ).button( "refresh" );
			}, 1 );
		},
		radioGroup = function( radio ) {
			var name = radio.name,
				form = radio.form,
				radios = $( [] );
			if ( name ) {
				name = name.replace( /'/g, "\\'" );
				if ( form ) {
					radios = $( form ).find( "[name='" + name + "']" );
				} else {
					radios = $( "[name='" + name + "']", radio.ownerDocument )
						.filter(function() {
							return !this.form;
						});
				}
			}
			return radios;
		};
	
	$.widget( "ui.button", {
		version: "1.10.3",
		defaultElement: "<button>",
		options: {
			disabled: null,
			text: true,
			label: null,
			icons: {
				primary: null,
				secondary: null
			}
		},
		_create: function() {
			this.element.closest( "form" )
				.unbind( "reset" + this.eventNamespace )
				.bind( "reset" + this.eventNamespace, formResetHandler );
	
			if ( typeof this.options.disabled !== "boolean" ) {
				this.options.disabled = !!this.element.prop( "disabled" );
			} else {
				this.element.prop( "disabled", this.options.disabled );
			}
	
			this._determineButtonType();
			this.hasTitle = !!this.buttonElement.attr( "title" );
	
			var that = this,
				options = this.options,
				toggleButton = this.type === "checkbox" || this.type === "radio",
				activeClass = !toggleButton ? "ui-state-active" : "",
				focusClass = "ui-state-focus";
	
			if ( options.label === null ) {
				options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
			}
	
			this._hoverable( this.buttonElement );
	
			this.buttonElement
				.addClass( baseClasses )
				.attr( "role", "button" )
				.bind( "mouseenter" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					if ( this === lastActive ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "mouseleave" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					$( this ).removeClass( activeClass );
				})
				.bind( "click" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						event.preventDefault();
						event.stopImmediatePropagation();
					}
				});
	
			this.element
				.bind( "focus" + this.eventNamespace, function() {
					// no need to check disabled, focus won't be triggered anyway
					that.buttonElement.addClass( focusClass );
				})
				.bind( "blur" + this.eventNamespace, function() {
					that.buttonElement.removeClass( focusClass );
				});
	
			if ( toggleButton ) {
				this.element.bind( "change" + this.eventNamespace, function() {
					if ( clickDragged ) {
						return;
					}
					that.refresh();
				});
				// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
				// prevents issue where button state changes but checkbox/radio checked state
				// does not in Firefox (see ticket #6970)
				this.buttonElement
					.bind( "mousedown" + this.eventNamespace, function( event ) {
						if ( options.disabled ) {
							return;
						}
						clickDragged = false;
						startXPos = event.pageX;
						startYPos = event.pageY;
					})
					.bind( "mouseup" + this.eventNamespace, function( event ) {
						if ( options.disabled ) {
							return;
						}
						if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
							clickDragged = true;
						}
				});
			}
	
			if ( this.type === "checkbox" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled || clickDragged ) {
						return false;
					}
				});
			} else if ( this.type === "radio" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled || clickDragged ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					that.buttonElement.attr( "aria-pressed", "true" );
	
					var radio = that.element[ 0 ];
					radioGroup( radio )
						.not( radio )
						.map(function() {
							return $( this ).button( "widget" )[ 0 ];
						})
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				});
			} else {
				this.buttonElement
					.bind( "mousedown" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).addClass( "ui-state-active" );
						lastActive = this;
						that.document.one( "mouseup", function() {
							lastActive = null;
						});
					})
					.bind( "mouseup" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).removeClass( "ui-state-active" );
					})
					.bind( "keydown" + this.eventNamespace, function(event) {
						if ( options.disabled ) {
							return false;
						}
						if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
							$( this ).addClass( "ui-state-active" );
						}
					})
					// see #8559, we bind to blur here in case the button element loses
					// focus between keydown and keyup, it would be left in an "active" state
					.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
						$( this ).removeClass( "ui-state-active" );
					});
	
				if ( this.buttonElement.is("a") ) {
					this.buttonElement.keyup(function(event) {
						if ( event.keyCode === $.ui.keyCode.SPACE ) {
							// TODO pass through original event correctly (just as 2nd argument doesn't work)
							$( this ).click();
						}
					});
				}
			}
	
			// TODO: pull out $.Widget's handling for the disabled option into
			// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
			// be overridden by individual plugins
			this._setOption( "disabled", options.disabled );
			this._resetButton();
		},
	
		_determineButtonType: function() {
			var ancestor, labelSelector, checked;
	
			if ( this.element.is("[type=checkbox]") ) {
				this.type = "checkbox";
			} else if ( this.element.is("[type=radio]") ) {
				this.type = "radio";
			} else if ( this.element.is("input") ) {
				this.type = "input";
			} else {
				this.type = "button";
			}
	
			if ( this.type === "checkbox" || this.type === "radio" ) {
				// we don't search against the document in case the element
				// is disconnected from the DOM
				ancestor = this.element.parents().last();
				labelSelector = "label[for='" + this.element.attr("id") + "']";
				this.buttonElement = ancestor.find( labelSelector );
				if ( !this.buttonElement.length ) {
					ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
					this.buttonElement = ancestor.filter( labelSelector );
					if ( !this.buttonElement.length ) {
						this.buttonElement = ancestor.find( labelSelector );
					}
				}
				this.element.addClass( "ui-helper-hidden-accessible" );
	
				checked = this.element.is( ":checked" );
				if ( checked ) {
					this.buttonElement.addClass( "ui-state-active" );
				}
				this.buttonElement.prop( "aria-pressed", checked );
			} else {
				this.buttonElement = this.element;
			}
		},
	
		widget: function() {
			return this.buttonElement;
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-helper-hidden-accessible" );
			this.buttonElement
				.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
				.removeAttr( "role" )
				.removeAttr( "aria-pressed" )
				.html( this.buttonElement.find(".ui-button-text").html() );
	
			if ( !this.hasTitle ) {
				this.buttonElement.removeAttr( "title" );
			}
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "disabled" ) {
				if ( value ) {
					this.element.prop( "disabled", true );
				} else {
					this.element.prop( "disabled", false );
				}
				return;
			}
			this._resetButton();
		},
	
		refresh: function() {
			//See #8237 & #8828
			var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );
	
			if ( isDisabled !== this.options.disabled ) {
				this._setOption( "disabled", isDisabled );
			}
			if ( this.type === "radio" ) {
				radioGroup( this.element[0] ).each(function() {
					if ( $( this ).is( ":checked" ) ) {
						$( this ).button( "widget" )
							.addClass( "ui-state-active" )
							.attr( "aria-pressed", "true" );
					} else {
						$( this ).button( "widget" )
							.removeClass( "ui-state-active" )
							.attr( "aria-pressed", "false" );
					}
				});
			} else if ( this.type === "checkbox" ) {
				if ( this.element.is( ":checked" ) ) {
					this.buttonElement
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					this.buttonElement
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			}
		},
	
		_resetButton: function() {
			if ( this.type === "input" ) {
				if ( this.options.label ) {
					this.element.val( this.options.label );
				}
				return;
			}
			var buttonElement = this.buttonElement.removeClass( typeClasses ),
				buttonText = $( "<span></span>", this.document[0] )
					.addClass( "ui-button-text" )
					.html( this.options.label )
					.appendTo( buttonElement.empty() )
					.text(),
				icons = this.options.icons,
				multipleIcons = icons.primary && icons.secondary,
				buttonClasses = [];
	
			if ( icons.primary || icons.secondary ) {
				if ( this.options.text ) {
					buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
				}
	
				if ( icons.primary ) {
					buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
				}
	
				if ( icons.secondary ) {
					buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
				}
	
				if ( !this.options.text ) {
					buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );
	
					if ( !this.hasTitle ) {
						buttonElement.attr( "title", $.trim( buttonText ) );
					}
				}
			} else {
				buttonClasses.push( "ui-button-text-only" );
			}
			buttonElement.addClass( buttonClasses.join( " " ) );
		}
	});
	
	$.widget( "ui.buttonset", {
		version: "1.10.3",
		options: {
			items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
		},
	
		_create: function() {
			this.element.addClass( "ui-buttonset" );
		},
	
		_init: function() {
			this.refresh();
		},
	
		_setOption: function( key, value ) {
			if ( key === "disabled" ) {
				this.buttons.button( "option", key, value );
			}
	
			this._super( key, value );
		},
	
		refresh: function() {
			var rtl = this.element.css( "direction" ) === "rtl";
	
			this.buttons = this.element.find( this.options.items )
				.filter( ":ui-button" )
					.button( "refresh" )
				.end()
				.not( ":ui-button" )
					.button()
				.end()
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
					.filter( ":first" )
						.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
					.end()
					.filter( ":last" )
						.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
					.end()
				.end();
		},
	
		_destroy: function() {
			this.element.removeClass( "ui-buttonset" );
			this.buttons
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-left ui-corner-right" )
				.end()
				.button( "destroy" );
		}
	});
	
	}( jQuery ) );
	
	(function( $, undefined ) {
	
	$.extend($.ui, { datepicker: { version: "1.10.3" } });
	
	var PROP_NAME = "datepicker",
		instActive;
	
	/* Date picker manager.
	   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
	   Settings for (groups of) date pickers are maintained in an instance object,
	   allowing multiple different settings on the same page. */
	
	function Datepicker() {
		this._curInst = null; // The current instance in use
		this._keyEvent = false; // If the last event was a key event
		this._disabledInputs = []; // List of date picker inputs that have been disabled
		this._datepickerShowing = false; // True if the popup picker is showing , false if not
		this._inDialog = false; // True if showing within a "dialog", false if not
		this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
		this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
		this._appendClass = "ui-datepicker-append"; // The name of the append marker class
		this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
		this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
		this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
		this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
		this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
		this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[""] = { // Default regional settings
			closeText: "Done", // Display text for close link
			prevText: "Prev", // Display text for previous month link
			nextText: "Next", // Display text for next month link
			currentText: "Today", // Display text for current month link
			monthNames: ["January","February","March","April","May","June",
				"July","August","September","October","November","December"], // Names of months for drop-down and formatting
			monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
			dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
			dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
			dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
			weekHeader: "Wk", // Column header for week of the year
			dateFormat: "mm/dd/yy", // See format options on parseDate
			firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
			isRTL: false, // True if right-to-left language, false if left-to-right
			showMonthAfterYear: false, // True if the year select precedes month, false for month then year
			yearSuffix: "" // Additional text to append to the year in the month headers
		};
		this._defaults = { // Global defaults for all the date picker instances
			showOn: "focus", // "focus" for popup on focus,
				// "button" for trigger button, or "both" for either
			showAnim: "fadeIn", // Name of jQuery animation for popup
			showOptions: {}, // Options for enhanced animations
			defaultDate: null, // Used when field is blank: actual date,
				// +/-number for offset from today, null for today
			appendText: "", // Display text following the input box, e.g. showing the format
			buttonText: "...", // Text for trigger button
			buttonImage: "", // URL for trigger button image
			buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
			hideIfNoPrevNext: false, // True to hide next/previous month links
				// if not applicable, false to just disable them
			navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
			gotoCurrent: false, // True if today link goes back to current selection instead
			changeMonth: false, // True if month can be selected directly, false if only prev/next
			changeYear: false, // True if year can be selected directly, false if only prev/next
			yearRange: "c-10:c+10", // Range of years to display in drop-down,
				// either relative to today's year (-nn:+nn), relative to currently displayed year
				// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
			showOtherMonths: false, // True to show dates in other months, false to leave blank
			selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
			showWeek: false, // True to show week of the year, false to not show it
			calculateWeek: this.iso8601Week, // How to calculate the week of the year,
				// takes a Date and returns the number of the week for it
			shortYearCutoff: "+10", // Short year values < this are in the current century,
				// > this are in the previous century,
				// string value starting with "+" for current year + value
			minDate: null, // The earliest selectable date, or null for no limit
			maxDate: null, // The latest selectable date, or null for no limit
			duration: "fast", // Duration of display/closure
			beforeShowDay: null, // Function that takes a date and returns an array with
				// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
				// [2] = cell title (optional), e.g. $.datepicker.noWeekends
			beforeShow: null, // Function that takes an input field and
				// returns a set of custom settings for the date picker
			onSelect: null, // Define a callback function when a date is selected
			onChangeMonthYear: null, // Define a callback function when the month or year is changed
			onClose: null, // Define a callback function when the datepicker is closed
			numberOfMonths: 1, // Number of months to show at a time
			showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
			stepMonths: 1, // Number of months to step back/forward
			stepBigMonths: 12, // Number of months to step back/forward for the big links
			altField: "", // Selector for an alternate field to store selected dates into
			altFormat: "", // The date format to use for the alternate field
			constrainInput: true, // The input is constrained by the current date format
			showButtonPanel: false, // True to show button panel, false to not show it
			autoSize: false, // True to size the input for the date format, false to leave as is
			disabled: false // The initial disabled state
		};
		$.extend(this._defaults, this.regional[""]);
		this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
	}
	
	$.extend(Datepicker.prototype, {
		/* Class name added to elements to indicate already configured with a date picker. */
		markerClassName: "hasDatepicker",
	
		//Keep track of the maximum number of rows displayed (see #7043)
		maxRows: 4,
	
		// TODO rename to "widget" when switching to widget factory
		_widgetDatepicker: function() {
			return this.dpDiv;
		},
	
		/* Override the default settings for all instances of the date picker.
		 * @param  settings  object - the new settings to use as defaults (anonymous object)
		 * @return the manager object
		 */
		setDefaults: function(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},
	
		/* Attach the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
		 */
		_attachDatepicker: function(target, settings) {
			var nodeName, inline, inst;
			nodeName = target.nodeName.toLowerCase();
			inline = (nodeName === "div" || nodeName === "span");
			if (!target.id) {
				this.uuid += 1;
				target.id = "dp" + this.uuid;
			}
			inst = this._newInst($(target), inline);
			inst.settings = $.extend({}, settings || {});
			if (nodeName === "input") {
				this._connectDatepicker(target, inst);
			} else if (inline) {
				this._inlineDatepicker(target, inst);
			}
		},
	
		/* Create a new instance object. */
		_newInst: function(target, inline) {
			var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
			return {id: id, input: target, // associated target
				selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
				drawMonth: 0, drawYear: 0, // month being drawn
				inline: inline, // is datepicker inline or not
				dpDiv: (!inline ? this.dpDiv : // presentation div
				bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
		},
	
		/* Attach the date picker to an input field. */
		_connectDatepicker: function(target, inst) {
			var input = $(target);
			inst.append = $([]);
			inst.trigger = $([]);
			if (input.hasClass(this.markerClassName)) {
				return;
			}
			this._attachments(input, inst);
			input.addClass(this.markerClassName).keydown(this._doKeyDown).
				keypress(this._doKeyPress).keyup(this._doKeyUp);
			this._autoSize(inst);
			$.data(target, PROP_NAME, inst);
			//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
		},
	
		/* Make attachments based on settings. */
		_attachments: function(input, inst) {
			var showOn, buttonText, buttonImage,
				appendText = this._get(inst, "appendText"),
				isRTL = this._get(inst, "isRTL");
	
			if (inst.append) {
				inst.append.remove();
			}
			if (appendText) {
				inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
				input[isRTL ? "before" : "after"](inst.append);
			}
	
			input.unbind("focus", this._showDatepicker);
	
			if (inst.trigger) {
				inst.trigger.remove();
			}
	
			showOn = this._get(inst, "showOn");
			if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
				input.focus(this._showDatepicker);
			}
			if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
				buttonText = this._get(inst, "buttonText");
				buttonImage = this._get(inst, "buttonImage");
				inst.trigger = $(this._get(inst, "buttonImageOnly") ?
					$("<img/>").addClass(this._triggerClass).
						attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
					$("<button type='button'></button>").addClass(this._triggerClass).
						html(!buttonImage ? buttonText : $("<img/>").attr(
						{ src:buttonImage, alt:buttonText, title:buttonText })));
				input[isRTL ? "before" : "after"](inst.trigger);
				inst.trigger.click(function() {
					if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
						$.datepicker._hideDatepicker();
					} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
						$.datepicker._hideDatepicker();
						$.datepicker._showDatepicker(input[0]);
					} else {
						$.datepicker._showDatepicker(input[0]);
					}
					return false;
				});
			}
		},
	
		/* Apply the maximum length for the date format. */
		_autoSize: function(inst) {
			if (this._get(inst, "autoSize") && !inst.inline) {
				var findMax, max, maxI, i,
					date = new Date(2009, 12 - 1, 20), // Ensure double digits
					dateFormat = this._get(inst, "dateFormat");
	
				if (dateFormat.match(/[DM]/)) {
					findMax = function(names) {
						max = 0;
						maxI = 0;
						for (i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
						"monthNames" : "monthNamesShort"))));
					date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
						"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
				}
				inst.input.attr("size", this._formatDate(inst, date).length);
			}
		},
	
		/* Attach an inline date picker to a div. */
		_inlineDatepicker: function(target, inst) {
			var divSpan = $(target);
			if (divSpan.hasClass(this.markerClassName)) {
				return;
			}
			divSpan.addClass(this.markerClassName).append(inst.dpDiv);
			$.data(target, PROP_NAME, inst);
			this._setDate(inst, this._getDefaultDate(inst), true);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
			//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
			// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
			// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
			inst.dpDiv.css( "display", "block" );
		},
	
		/* Pop-up the date picker in a "dialog" box.
		 * @param  input element - ignored
		 * @param  date	string or Date - the initial date to display
		 * @param  onSelect  function - the function to call when a date is selected
		 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
		 * @param  pos int[2] - coordinates for the dialog's position within the screen or
		 *					event - with x/y coordinates or
		 *					leave empty for default (screen centre)
		 * @return the manager object
		 */
		_dialogDatepicker: function(input, date, onSelect, settings, pos) {
			var id, browserWidth, browserHeight, scrollX, scrollY,
				inst = this._dialogInst; // internal instance
	
			if (!inst) {
				this.uuid += 1;
				id = "dp" + this.uuid;
				this._dialogInput = $("<input type='text' id='" + id +
					"' style='position: absolute; top: -100px; width: 0px;'/>");
				this._dialogInput.keydown(this._doKeyDown);
				$("body").append(this._dialogInput);
				inst = this._dialogInst = this._newInst(this._dialogInput, false);
				inst.settings = {};
				$.data(this._dialogInput[0], PROP_NAME, inst);
			}
			extendRemove(inst.settings, settings || {});
			date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
			this._dialogInput.val(date);
	
			this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
			if (!this._pos) {
				browserWidth = document.documentElement.clientWidth;
				browserHeight = document.documentElement.clientHeight;
				scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
				scrollY = document.documentElement.scrollTop || document.body.scrollTop;
				this._pos = // should use actual width/height below
					[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
			}
	
			// move input on screen for focus, but hidden behind dialog
			this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
			inst.settings.onSelect = onSelect;
			this._inDialog = true;
			this.dpDiv.addClass(this._dialogClass);
			this._showDatepicker(this._dialogInput[0]);
			if ($.blockUI) {
				$.blockUI(this.dpDiv);
			}
			$.data(this._dialogInput[0], PROP_NAME, inst);
			return this;
		},
	
		/* Detach a datepicker from its control.
		 * @param  target	element - the target input field or division or span
		 */
		_destroyDatepicker: function(target) {
			var nodeName,
				$target = $(target),
				inst = $.data(target, PROP_NAME);
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			$.removeData(target, PROP_NAME);
			if (nodeName === "input") {
				inst.append.remove();
				inst.trigger.remove();
				$target.removeClass(this.markerClassName).
					unbind("focus", this._showDatepicker).
					unbind("keydown", this._doKeyDown).
					unbind("keypress", this._doKeyPress).
					unbind("keyup", this._doKeyUp);
			} else if (nodeName === "div" || nodeName === "span") {
				$target.removeClass(this.markerClassName).empty();
			}
		},
	
		/* Enable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_enableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, PROP_NAME);
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = false;
				inst.trigger.filter("button").
					each(function() { this.disabled = false; }).end().
					filter("img").css({opacity: "1.0", cursor: ""});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().removeClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", false);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
		},
	
		/* Disable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_disableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, PROP_NAME);
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = true;
				inst.trigger.filter("button").
					each(function() { this.disabled = true; }).end().
					filter("img").css({opacity: "0.5", cursor: "default"});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().addClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", true);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
			this._disabledInputs[this._disabledInputs.length] = target;
		},
	
		/* Is the first field in a jQuery collection disabled as a datepicker?
		 * @param  target	element - the target input field or division or span
		 * @return boolean - true if disabled, false if enabled
		 */
		_isDisabledDatepicker: function(target) {
			if (!target) {
				return false;
			}
			for (var i = 0; i < this._disabledInputs.length; i++) {
				if (this._disabledInputs[i] === target) {
					return true;
				}
			}
			return false;
		},
	
		/* Retrieve the instance data for the target control.
		 * @param  target  element - the target input field or division or span
		 * @return  object - the associated instance data
		 * @throws  error if a jQuery problem getting data
		 */
		_getInst: function(target) {
			try {
				return $.data(target, PROP_NAME);
			}
			catch (err) {
				throw "Missing instance data for this datepicker";
			}
		},
	
		/* Update or retrieve the settings for a date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 * @param  name	object - the new settings to update or
		 *				string - the name of the setting to change or retrieve,
		 *				when retrieving also "all" for all instance settings or
		 *				"defaults" for all global defaults
		 * @param  value   any - the new value for the setting
		 *				(omit if above is an object or to retrieve a value)
		 */
		_optionDatepicker: function(target, name, value) {
			var settings, date, minDate, maxDate,
				inst = this._getInst(target);
	
			if (arguments.length === 2 && typeof name === "string") {
				return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
					(inst ? (name === "all" ? $.extend({}, inst.settings) :
					this._get(inst, name)) : null));
			}
	
			settings = name || {};
			if (typeof name === "string") {
				settings = {};
				settings[name] = value;
			}
	
			if (inst) {
				if (this._curInst === inst) {
					this._hideDatepicker();
				}
	
				date = this._getDateDatepicker(target, true);
				minDate = this._getMinMaxDate(inst, "min");
				maxDate = this._getMinMaxDate(inst, "max");
				extendRemove(inst.settings, settings);
				// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
				if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
					inst.settings.minDate = this._formatDate(inst, minDate);
				}
				if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
					inst.settings.maxDate = this._formatDate(inst, maxDate);
				}
				if ( "disabled" in settings ) {
					if ( settings.disabled ) {
						this._disableDatepicker(target);
					} else {
						this._enableDatepicker(target);
					}
				}
				this._attachments($(target), inst);
				this._autoSize(inst);
				this._setDate(inst, date);
				this._updateAlternate(inst);
				this._updateDatepicker(inst);
			}
		},
	
		// change method deprecated
		_changeDatepicker: function(target, name, value) {
			this._optionDatepicker(target, name, value);
		},
	
		/* Redraw the date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 */
		_refreshDatepicker: function(target) {
			var inst = this._getInst(target);
			if (inst) {
				this._updateDatepicker(inst);
			}
		},
	
		/* Set the dates for a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  date	Date - the new date
		 */
		_setDateDatepicker: function(target, date) {
			var inst = this._getInst(target);
			if (inst) {
				this._setDate(inst, date);
				this._updateDatepicker(inst);
				this._updateAlternate(inst);
			}
		},
	
		/* Get the date(s) for the first entry in a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  noDefault boolean - true if no default date is to be used
		 * @return Date - the current date
		 */
		_getDateDatepicker: function(target, noDefault) {
			var inst = this._getInst(target);
			if (inst && !inst.inline) {
				this._setDateFromField(inst, noDefault);
			}
			return (inst ? this._getDate(inst) : null);
		},
	
		/* Handle keystrokes. */
		_doKeyDown: function(event) {
			var onSelect, dateStr, sel,
				inst = $.datepicker._getInst(event.target),
				handled = true,
				isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
	
			inst._keyEvent = true;
			if ($.datepicker._datepickerShowing) {
				switch (event.keyCode) {
					case 9: $.datepicker._hideDatepicker();
							handled = false;
							break; // hide on tab out
					case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
										$.datepicker._currentClass + ")", inst.dpDiv);
							if (sel[0]) {
								$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							}
	
							onSelect = $.datepicker._get(inst, "onSelect");
							if (onSelect) {
								dateStr = $.datepicker._formatDate(inst);
	
								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							} else {
								$.datepicker._hideDatepicker();
							}
	
							return false; // don't submit the form
					case 27: $.datepicker._hideDatepicker();
							break; // hide on escape
					case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
							break; // previous month/year on page up/+ ctrl
					case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
							break; // next month/year on page down/+ ctrl
					case 35: if (event.ctrlKey || event.metaKey) {
								$.datepicker._clearDate(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // clear on ctrl or command +end
					case 36: if (event.ctrlKey || event.metaKey) {
								$.datepicker._gotoToday(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // current on ctrl or command +home
					case 37: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// -1 day on ctrl or command +left
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, "stepBigMonths") :
									-$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +left on Mac
							break;
					case 38: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, -7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // -1 week on ctrl or command +up
					case 39: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// +1 day on ctrl or command +right
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, "stepBigMonths") :
									+$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +right
							break;
					case 40: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, +7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // +1 week on ctrl or command +down
					default: handled = false;
				}
			} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
				$.datepicker._showDatepicker(this);
			} else {
				handled = false;
			}
	
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
		},
	
		/* Filter entered characters - based on date format. */
		_doKeyPress: function(event) {
			var chars, chr,
				inst = $.datepicker._getInst(event.target);
	
			if ($.datepicker._get(inst, "constrainInput")) {
				chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
				chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
				return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
			}
		},
	
		/* Synchronise manual entry and field/alternate field. */
		_doKeyUp: function(event) {
			var date,
				inst = $.datepicker._getInst(event.target);
	
			if (inst.input.val() !== inst.lastVal) {
				try {
					date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						(inst.input ? inst.input.val() : null),
						$.datepicker._getFormatConfig(inst));
	
					if (date) { // only if valid
						$.datepicker._setDateFromField(inst);
						$.datepicker._updateAlternate(inst);
						$.datepicker._updateDatepicker(inst);
					}
				}
				catch (err) {
				}
			}
			return true;
		},
	
		/* Pop-up the date picker for a given input field.
		 * If false returned from beforeShow event handler do not show.
		 * @param  input  element - the input field attached to the date picker or
		 *					event - if triggered by focus
		 */
		_showDatepicker: function(input) {
			input = input.target || input;
			if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
				input = $("input", input.parentNode)[0];
			}
	
			if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
				return;
			}
	
			var inst, beforeShow, beforeShowSettings, isFixed,
				offset, showAnim, duration;
	
			inst = $.datepicker._getInst(input);
			if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
				$.datepicker._curInst.dpDiv.stop(true, true);
				if ( inst && $.datepicker._datepickerShowing ) {
					$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
				}
			}
	
			beforeShow = $.datepicker._get(inst, "beforeShow");
			beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
			if(beforeShowSettings === false){
				return;
			}
			extendRemove(inst.settings, beforeShowSettings);
	
			inst.lastVal = null;
			$.datepicker._lastInput = input;
			$.datepicker._setDateFromField(inst);
	
			if ($.datepicker._inDialog) { // hide cursor
				input.value = "";
			}
			if (!$.datepicker._pos) { // position below input
				$.datepicker._pos = $.datepicker._findPos(input);
				$.datepicker._pos[1] += input.offsetHeight; // add the height
			}
	
			isFixed = false;
			$(input).parents().each(function() {
				isFixed |= $(this).css("position") === "fixed";
				return !isFixed;
			});
	
			offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
			$.datepicker._pos = null;
			//to avoid flashes on Firefox
			inst.dpDiv.empty();
			// determine sizing offscreen
			inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
			$.datepicker._updateDatepicker(inst);
			// fix width for dynamic number of date pickers
			// and adjust position before showing
			offset = $.datepicker._checkOffset(inst, offset, isFixed);
			inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
				"static" : (isFixed ? "fixed" : "absolute")), display: "none",
				left: offset.left + "px", top: offset.top + "px"});
	
			if (!inst.inline) {
				showAnim = $.datepicker._get(inst, "showAnim");
				duration = $.datepicker._get(inst, "duration");
				inst.dpDiv.zIndex($(input).zIndex()+1);
				$.datepicker._datepickerShowing = true;
	
				if ( $.effects && $.effects.effect[ showAnim ] ) {
					inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
				} else {
					inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
				}
	
				if ( $.datepicker._shouldFocusInput( inst ) ) {
					inst.input.focus();
				}
	
				$.datepicker._curInst = inst;
			}
		},
	
		/* Generate the date picker content. */
		_updateDatepicker: function(inst) {
			this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
			instActive = inst; // for delegate hover events
			inst.dpDiv.empty().append(this._generateHTML(inst));
			this._attachHandlers(inst);
			inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
	
			var origyearshtml,
				numMonths = this._getNumberOfMonths(inst),
				cols = numMonths[1],
				width = 17;
	
			inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
			if (cols > 1) {
				inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
			}
			inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
				"Class"]("ui-datepicker-multi");
			inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
				"Class"]("ui-datepicker-rtl");
	
			if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}
	
			// deffered render of the years select (to avoid flashes on Firefox)
			if( inst.yearshtml ){
				origyearshtml = inst.yearshtml;
				setTimeout(function(){
					//assure that inst.yearshtml didn't change.
					if( origyearshtml === inst.yearshtml && inst.yearshtml ){
						inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
					}
					origyearshtml = inst.yearshtml = null;
				}, 0);
			}
		},
	
		// #6694 - don't focus the input if it's already focused
		// this breaks the change event in IE
		// Support: IE and jQuery <1.9
		_shouldFocusInput: function( inst ) {
			return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
		},
	
		/* Check positioning to remain on screen. */
		_checkOffset: function(inst, offset, isFixed) {
			var dpWidth = inst.dpDiv.outerWidth(),
				dpHeight = inst.dpDiv.outerHeight(),
				inputWidth = inst.input ? inst.input.outerWidth() : 0,
				inputHeight = inst.input ? inst.input.outerHeight() : 0,
				viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
				viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
	
			offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
			offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
			offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
	
			// now check if datepicker is showing outside window viewport - move to a better place if so.
			offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
				Math.abs(offset.left + dpWidth - viewWidth) : 0);
			offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
				Math.abs(dpHeight + inputHeight) : 0);
	
			return offset;
		},
	
		/* Find an object's position on the screen. */
		_findPos: function(obj) {
			var position,
				inst = this._getInst(obj),
				isRTL = this._get(inst, "isRTL");
	
			while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
				obj = obj[isRTL ? "previousSibling" : "nextSibling"];
			}
	
			position = $(obj).offset();
			return [position.left, position.top];
		},
	
		/* Hide the date picker from view.
		 * @param  input  element - the input field attached to the date picker
		 */
		_hideDatepicker: function(input) {
			var showAnim, duration, postProcess, onClose,
				inst = this._curInst;
	
			if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
				return;
			}
	
			if (this._datepickerShowing) {
				showAnim = this._get(inst, "showAnim");
				duration = this._get(inst, "duration");
				postProcess = function() {
					$.datepicker._tidyDialog(inst);
				};
	
				// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
				if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
					inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
				} else {
					inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
						(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
				}
	
				if (!showAnim) {
					postProcess();
				}
				this._datepickerShowing = false;
	
				onClose = this._get(inst, "onClose");
				if (onClose) {
					onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
				}
	
				this._lastInput = null;
				if (this._inDialog) {
					this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
					if ($.blockUI) {
						$.unblockUI();
						$("body").append(this.dpDiv);
					}
				}
				this._inDialog = false;
			}
		},
	
		/* Tidy up after a dialog display. */
		_tidyDialog: function(inst) {
			inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
		},
	
		/* Close date picker if clicked elsewhere. */
		_checkExternalClick: function(event) {
			if (!$.datepicker._curInst) {
				return;
			}
	
			var $target = $(event.target),
				inst = $.datepicker._getInst($target[0]);
	
			if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
					$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
					!$target.hasClass($.datepicker.markerClassName) &&
					!$target.closest("." + $.datepicker._triggerClass).length &&
					$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
				( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
					$.datepicker._hideDatepicker();
			}
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustDate: function(id, offset, period) {
			var target = $(id),
				inst = this._getInst(target[0]);
	
			if (this._isDisabledDatepicker(target[0])) {
				return;
			}
			this._adjustInstDate(inst, offset +
				(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
				period);
			this._updateDatepicker(inst);
		},
	
		/* Action for current link. */
		_gotoToday: function(id) {
			var date,
				target = $(id),
				inst = this._getInst(target[0]);
	
			if (this._get(inst, "gotoCurrent") && inst.currentDay) {
				inst.selectedDay = inst.currentDay;
				inst.drawMonth = inst.selectedMonth = inst.currentMonth;
				inst.drawYear = inst.selectedYear = inst.currentYear;
			} else {
				date = new Date();
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
			}
			this._notifyChange(inst);
			this._adjustDate(target);
		},
	
		/* Action for selecting a new month/year. */
		_selectMonthYear: function(id, select, period) {
			var target = $(id),
				inst = this._getInst(target[0]);
	
			inst["selected" + (period === "M" ? "Month" : "Year")] =
			inst["draw" + (period === "M" ? "Month" : "Year")] =
				parseInt(select.options[select.selectedIndex].value,10);
	
			this._notifyChange(inst);
			this._adjustDate(target);
		},
	
		/* Action for selecting a day. */
		_selectDay: function(id, month, year, td) {
			var inst,
				target = $(id);
	
			if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
				return;
			}
	
			inst = this._getInst(target[0]);
			inst.selectedDay = inst.currentDay = $("a", td).html();
			inst.selectedMonth = inst.currentMonth = month;
			inst.selectedYear = inst.currentYear = year;
			this._selectDate(id, this._formatDate(inst,
				inst.currentDay, inst.currentMonth, inst.currentYear));
		},
	
		/* Erase the input field and hide the date picker. */
		_clearDate: function(id) {
			var target = $(id);
			this._selectDate(target, "");
		},
	
		/* Update the input field with the selected date. */
		_selectDate: function(id, dateStr) {
			var onSelect,
				target = $(id),
				inst = this._getInst(target[0]);
	
			dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
			if (inst.input) {
				inst.input.val(dateStr);
			}
			this._updateAlternate(inst);
	
			onSelect = this._get(inst, "onSelect");
			if (onSelect) {
				onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
			} else if (inst.input) {
				inst.input.trigger("change"); // fire the change event
			}
	
			if (inst.inline){
				this._updateDatepicker(inst);
			} else {
				this._hideDatepicker();
				this._lastInput = inst.input[0];
				if (typeof(inst.input[0]) !== "object") {
					inst.input.focus(); // restore focus
				}
				this._lastInput = null;
			}
		},
	
		/* Update any alternate field to synchronise with the main field. */
		_updateAlternate: function(inst) {
			var altFormat, date, dateStr,
				altField = this._get(inst, "altField");
	
			if (altField) { // update alternate field too
				altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
				date = this._getDate(inst);
				dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
				$(altField).each(function() { $(this).val(dateStr); });
			}
		},
	
		/* Set as beforeShowDay function to prevent selection of weekends.
		 * @param  date  Date - the date to customise
		 * @return [boolean, string] - is this date selectable?, what is its CSS class?
		 */
		noWeekends: function(date) {
			var day = date.getDay();
			return [(day > 0 && day < 6), ""];
		},
	
		/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
		 * @param  date  Date - the date to get the week for
		 * @return  number - the number of the week within the year that contains this date
		 */
		iso8601Week: function(date) {
			var time,
				checkDate = new Date(date.getTime());
	
			// Find Thursday of this week starting on Monday
			checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
	
			time = checkDate.getTime();
			checkDate.setMonth(0); // Compare with Jan 1
			checkDate.setDate(1);
			return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
		},
	
		/* Parse a string value into a date object.
		 * See formatDate below for the possible formats.
		 *
		 * @param  format string - the expected format of the date
		 * @param  value string - the date in the above format
		 * @param  settings Object - attributes include:
		 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  Date - the extracted date value or null if value is blank
		 */
		parseDate: function (format, value, settings) {
			if (format == null || value == null) {
				throw "Invalid arguments";
			}
	
			value = (typeof value === "object" ? value.toString() : value + "");
			if (value === "") {
				return null;
			}
	
			var iFormat, dim, extra,
				iValue = 0,
				shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
				shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
					new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				year = -1,
				month = -1,
				day = -1,
				doy = -1,
				literal = false,
				date,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Extract a number from the string value
				getNumber = function(match) {
					var isDoubled = lookAhead(match),
						size = (match === "@" ? 14 : (match === "!" ? 20 :
						(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
						digits = new RegExp("^\\d{1," + size + "}"),
						num = value.substring(iValue).match(digits);
					if (!num) {
						throw "Missing number at position " + iValue;
					}
					iValue += num[0].length;
					return parseInt(num[0], 10);
				},
				// Extract a name from the string value and convert to an index
				getName = function(match, shortNames, longNames) {
					var index = -1,
						names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
							return [ [k, v] ];
						}).sort(function (a, b) {
							return -(a[1].length - b[1].length);
						});
	
					$.each(names, function (i, pair) {
						var name = pair[1];
						if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
							index = pair[0];
							iValue += name.length;
							return false;
						}
					});
					if (index !== -1) {
						return index + 1;
					} else {
						throw "Unknown name at position " + iValue;
					}
				},
				// Confirm that a literal character matches the string value
				checkLiteral = function() {
					if (value.charAt(iValue) !== format.charAt(iFormat)) {
						throw "Unexpected literal at position " + iValue;
					}
					iValue++;
				};
	
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						checkLiteral();
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							day = getNumber("d");
							break;
						case "D":
							getName("D", dayNamesShort, dayNames);
							break;
						case "o":
							doy = getNumber("o");
							break;
						case "m":
							month = getNumber("m");
							break;
						case "M":
							month = getName("M", monthNamesShort, monthNames);
							break;
						case "y":
							year = getNumber("y");
							break;
						case "@":
							date = new Date(getNumber("@"));
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "!":
							date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "'":
							if (lookAhead("'")){
								checkLiteral();
							} else {
								literal = true;
							}
							break;
						default:
							checkLiteral();
					}
				}
			}
	
			if (iValue < value.length){
				extra = value.substr(iValue);
				if (!/^\s+/.test(extra)) {
					throw "Extra/unparsed characters found in date: " + extra;
				}
			}
	
			if (year === -1) {
				year = new Date().getFullYear();
			} else if (year < 100) {
				year += new Date().getFullYear() - new Date().getFullYear() % 100 +
					(year <= shortYearCutoff ? 0 : -100);
			}
	
			if (doy > -1) {
				month = 1;
				day = doy;
				do {
					dim = this._getDaysInMonth(year, month - 1);
					if (day <= dim) {
						break;
					}
					month++;
					day -= dim;
				} while (true);
			}
	
			date = this._daylightSavingAdjust(new Date(year, month - 1, day));
			if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
				throw "Invalid date"; // E.g. 31/02/00
			}
			return date;
		},
	
		/* Standard date formats. */
		ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
		COOKIE: "D, dd M yy",
		ISO_8601: "yy-mm-dd",
		RFC_822: "D, d M y",
		RFC_850: "DD, dd-M-y",
		RFC_1036: "D, d M y",
		RFC_1123: "D, d M yy",
		RFC_2822: "D, d M yy",
		RSS: "D, d M y", // RFC 822
		TICKS: "!",
		TIMESTAMP: "@",
		W3C: "yy-mm-dd", // ISO 8601
	
		_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
			Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
	
		/* Format a date object into a string value.
		 * The format can be combinations of the following:
		 * d  - day of month (no leading zero)
		 * dd - day of month (two digit)
		 * o  - day of year (no leading zeros)
		 * oo - day of year (three digit)
		 * D  - day name short
		 * DD - day name long
		 * m  - month of year (no leading zero)
		 * mm - month of year (two digit)
		 * M  - month name short
		 * MM - month name long
		 * y  - year (two digit)
		 * yy - year (four digit)
		 * @ - Unix timestamp (ms since 01/01/1970)
		 * ! - Windows ticks (100ns since 01/01/0001)
		 * "..." - literal text
		 * '' - single quote
		 *
		 * @param  format string - the desired format of the date
		 * @param  date Date - the date value to format
		 * @param  settings Object - attributes include:
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  string - the date in the above format
		 */
		formatDate: function (format, date, settings) {
			if (!date) {
				return "";
			}
	
			var iFormat,
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Format a number, with leading zero if necessary
				formatNumber = function(match, value, len) {
					var num = "" + value;
					if (lookAhead(match)) {
						while (num.length < len) {
							num = "0" + num;
						}
					}
					return num;
				},
				// Format a name, short or long as requested
				formatName = function(match, value, shortNames, longNames) {
					return (lookAhead(match) ? longNames[value] : shortNames[value]);
				},
				output = "",
				literal = false;
	
			if (date) {
				for (iFormat = 0; iFormat < format.length; iFormat++) {
					if (literal) {
						if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
							literal = false;
						} else {
							output += format.charAt(iFormat);
						}
					} else {
						switch (format.charAt(iFormat)) {
							case "d":
								output += formatNumber("d", date.getDate(), 2);
								break;
							case "D":
								output += formatName("D", date.getDay(), dayNamesShort, dayNames);
								break;
							case "o":
								output += formatNumber("o",
									Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
								break;
							case "m":
								output += formatNumber("m", date.getMonth() + 1, 2);
								break;
							case "M":
								output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
								break;
							case "y":
								output += (lookAhead("y") ? date.getFullYear() :
									(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
								break;
							case "@":
								output += date.getTime();
								break;
							case "!":
								output += date.getTime() * 10000 + this._ticksTo1970;
								break;
							case "'":
								if (lookAhead("'")) {
									output += "'";
								} else {
									literal = true;
								}
								break;
							default:
								output += format.charAt(iFormat);
						}
					}
				}
			}
			return output;
		},
	
		/* Extract all possible characters from the date format. */
		_possibleChars: function (format) {
			var iFormat,
				chars = "",
				literal = false,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				};
	
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						chars += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d": case "m": case "y": case "@":
							chars += "0123456789";
							break;
						case "D": case "M":
							return null; // Accept anything
						case "'":
							if (lookAhead("'")) {
								chars += "'";
							} else {
								literal = true;
							}
							break;
						default:
							chars += format.charAt(iFormat);
					}
				}
			}
			return chars;
		},
	
		/* Get a setting value, defaulting if necessary. */
		_get: function(inst, name) {
			return inst.settings[name] !== undefined ?
				inst.settings[name] : this._defaults[name];
		},
	
		/* Parse existing date and initialise date picker. */
		_setDateFromField: function(inst, noDefault) {
			if (inst.input.val() === inst.lastVal) {
				return;
			}
	
			var dateFormat = this._get(inst, "dateFormat"),
				dates = inst.lastVal = inst.input ? inst.input.val() : null,
				defaultDate = this._getDefaultDate(inst),
				date = defaultDate,
				settings = this._getFormatConfig(inst);
	
			try {
				date = this.parseDate(dateFormat, dates, settings) || defaultDate;
			} catch (event) {
				dates = (noDefault ? "" : dates);
			}
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			inst.currentDay = (dates ? date.getDate() : 0);
			inst.currentMonth = (dates ? date.getMonth() : 0);
			inst.currentYear = (dates ? date.getFullYear() : 0);
			this._adjustInstDate(inst);
		},
	
		/* Retrieve the default date shown on opening. */
		_getDefaultDate: function(inst) {
			return this._restrictMinMax(inst,
				this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
		},
	
		/* A date may be specified as an exact value or a relative one. */
		_determineDate: function(inst, date, defaultDate) {
			var offsetNumeric = function(offset) {
					var date = new Date();
					date.setDate(date.getDate() + offset);
					return date;
				},
				offsetString = function(offset) {
					try {
						return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
							offset, $.datepicker._getFormatConfig(inst));
					}
					catch (e) {
						// Ignore
					}
	
					var date = (offset.toLowerCase().match(/^c/) ?
						$.datepicker._getDate(inst) : null) || new Date(),
						year = date.getFullYear(),
						month = date.getMonth(),
						day = date.getDate(),
						pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
						matches = pattern.exec(offset);
	
					while (matches) {
						switch (matches[2] || "d") {
							case "d" : case "D" :
								day += parseInt(matches[1],10); break;
							case "w" : case "W" :
								day += parseInt(matches[1],10) * 7; break;
							case "m" : case "M" :
								month += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
							case "y": case "Y" :
								year += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
						}
						matches = pattern.exec(offset);
					}
					return new Date(year, month, day);
				},
				newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
					(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
	
			newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
			if (newDate) {
				newDate.setHours(0);
				newDate.setMinutes(0);
				newDate.setSeconds(0);
				newDate.setMilliseconds(0);
			}
			return this._daylightSavingAdjust(newDate);
		},
	
		/* Handle switch to/from daylight saving.
		 * Hours may be non-zero on daylight saving cut-over:
		 * > 12 when midnight changeover, but then cannot generate
		 * midnight datetime, so jump to 1AM, otherwise reset.
		 * @param  date  (Date) the date to check
		 * @return  (Date) the corrected date
		 */
		_daylightSavingAdjust: function(date) {
			if (!date) {
				return null;
			}
			date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
			return date;
		},
	
		/* Set the date(s) directly. */
		_setDate: function(inst, date, noChange) {
			var clear = !date,
				origMonth = inst.selectedMonth,
				origYear = inst.selectedYear,
				newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
	
			inst.selectedDay = inst.currentDay = newDate.getDate();
			inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
			inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
			if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
				this._notifyChange(inst);
			}
			this._adjustInstDate(inst);
			if (inst.input) {
				inst.input.val(clear ? "" : this._formatDate(inst));
			}
		},
	
		/* Retrieve the date(s) directly. */
		_getDate: function(inst) {
			var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
				this._daylightSavingAdjust(new Date(
				inst.currentYear, inst.currentMonth, inst.currentDay)));
				return startDate;
		},
	
		/* Attach the onxxx handlers.  These are declared statically so
		 * they work with static code transformers like Caja.
		 */
		_attachHandlers: function(inst) {
			var stepMonths = this._get(inst, "stepMonths"),
				id = "#" + inst.id.replace( /\\\\/g, "\\" );
			inst.dpDiv.find("[data-handler]").map(function () {
				var handler = {
					prev: function () {
						$.datepicker._adjustDate(id, -stepMonths, "M");
					},
					next: function () {
						$.datepicker._adjustDate(id, +stepMonths, "M");
					},
					hide: function () {
						$.datepicker._hideDatepicker();
					},
					today: function () {
						$.datepicker._gotoToday(id);
					},
					selectDay: function () {
						$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
						return false;
					},
					selectMonth: function () {
						$.datepicker._selectMonthYear(id, this, "M");
						return false;
					},
					selectYear: function () {
						$.datepicker._selectMonthYear(id, this, "Y");
						return false;
					}
				};
				$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
			});
		},
	
		/* Generate the HTML for the current state of the date picker. */
		_generateHTML: function(inst) {
			var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
				controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
				monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
				selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
				cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
				printDate, dRow, tbody, daySettings, otherMonth, unselectable,
				tempDate = new Date(),
				today = this._daylightSavingAdjust(
					new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
				isRTL = this._get(inst, "isRTL"),
				showButtonPanel = this._get(inst, "showButtonPanel"),
				hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
				navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
				numMonths = this._getNumberOfMonths(inst),
				showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
				stepMonths = this._get(inst, "stepMonths"),
				isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
				currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
					new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				drawMonth = inst.drawMonth - showCurrentAtPos,
				drawYear = inst.drawYear;
	
			if (drawMonth < 0) {
				drawMonth += 12;
				drawYear--;
			}
			if (maxDate) {
				maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
					maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
				maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
				while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
					drawMonth--;
					if (drawMonth < 0) {
						drawMonth = 11;
						drawYear--;
					}
				}
			}
			inst.drawMonth = drawMonth;
			inst.drawYear = drawYear;
	
			prevText = this._get(inst, "prevText");
			prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
				this._getFormatConfig(inst)));
	
			prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
				" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
	
			nextText = this._get(inst, "nextText");
			nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
				this._getFormatConfig(inst)));
	
			next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
				" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
	
			currentText = this._get(inst, "currentText");
			gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
			currentText = (!navigationAsDateFormat ? currentText :
				this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
	
			controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
				this._get(inst, "closeText") + "</button>" : "");
	
			buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
				(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
				">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
	
			firstDay = parseInt(this._get(inst, "firstDay"),10);
			firstDay = (isNaN(firstDay) ? 0 : firstDay);
	
			showWeek = this._get(inst, "showWeek");
			dayNames = this._get(inst, "dayNames");
			dayNamesMin = this._get(inst, "dayNamesMin");
			monthNames = this._get(inst, "monthNames");
			monthNamesShort = this._get(inst, "monthNamesShort");
			beforeShowDay = this._get(inst, "beforeShowDay");
			showOtherMonths = this._get(inst, "showOtherMonths");
			selectOtherMonths = this._get(inst, "selectOtherMonths");
			defaultDate = this._getDefaultDate(inst);
			html = "";
			dow;
			for (row = 0; row < numMonths[0]; row++) {
				group = "";
				this.maxRows = 4;
				for (col = 0; col < numMonths[1]; col++) {
					selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
					cornerClass = " ui-corner-all";
					calender = "";
					if (isMultiMonth) {
						calender += "<div class='ui-datepicker-group";
						if (numMonths[1] > 1) {
							switch (col) {
								case 0: calender += " ui-datepicker-group-first";
									cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
								case numMonths[1]-1: calender += " ui-datepicker-group-last";
									cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
								default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
							}
						}
						calender += "'>";
					}
					calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
						(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
						(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
						this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
						row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
						"</div><table class='ui-datepicker-calendar'><thead>" +
						"<tr>";
					thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
					for (dow = 0; dow < 7; dow++) { // days of the week
						day = (dow + firstDay) % 7;
						thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
							"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
					}
					calender += thead + "</tr></thead><tbody>";
					daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
					if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
						inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
					}
					leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
					curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
					numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
					this.maxRows = numRows;
					printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
					for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
						calender += "<tr>";
						tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
							this._get(inst, "calculateWeek")(printDate) + "</td>");
						for (dow = 0; dow < 7; dow++) { // create date picker days
							daySettings = (beforeShowDay ?
								beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
							otherMonth = (printDate.getMonth() !== drawMonth);
							unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
								(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
							tbody += "<td class='" +
								((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
								(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
								((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
								(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
								// or defaultDate is current printedDate and defaultDate is selectedDate
								" " + this._dayOverClass : "") + // highlight selected day
								(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
								(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
								(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
								(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
								((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
								(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
								(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
								(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
								(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
								(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
								(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
								"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
							printDate.setDate(printDate.getDate() + 1);
							printDate = this._daylightSavingAdjust(printDate);
						}
						calender += tbody + "</tr>";
					}
					drawMonth++;
					if (drawMonth > 11) {
						drawMonth = 0;
						drawYear++;
					}
					calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
								((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
					group += calender;
				}
				html += group;
			}
			html += buttonPanel;
			inst._keyEvent = false;
			return html;
		},
	
		/* Generate the month and year header. */
		_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
				secondary, monthNames, monthNamesShort) {
	
			var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
				changeMonth = this._get(inst, "changeMonth"),
				changeYear = this._get(inst, "changeYear"),
				showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
				html = "<div class='ui-datepicker-title'>",
				monthHtml = "";
	
			// month selection
			if (secondary || !changeMonth) {
				monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
			} else {
				inMinYear = (minDate && minDate.getFullYear() === drawYear);
				inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
				monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
				for ( month = 0; month < 12; month++) {
					if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
						monthHtml += "<option value='" + month + "'" +
							(month === drawMonth ? " selected='selected'" : "") +
							">" + monthNamesShort[month] + "</option>";
					}
				}
				monthHtml += "</select>";
			}
	
			if (!showMonthAfterYear) {
				html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
			}
	
			// year selection
			if ( !inst.yearshtml ) {
				inst.yearshtml = "";
				if (secondary || !changeYear) {
					html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
				} else {
					// determine range of years to display
					years = this._get(inst, "yearRange").split(":");
					thisYear = new Date().getFullYear();
					determineYear = function(value) {
						var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
							(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
							parseInt(value, 10)));
						return (isNaN(year) ? thisYear : year);
					};
					year = determineYear(years[0]);
					endYear = Math.max(year, determineYear(years[1] || ""));
					year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
					endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
					inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
					for (; year <= endYear; year++) {
						inst.yearshtml += "<option value='" + year + "'" +
							(year === drawYear ? " selected='selected'" : "") +
							">" + year + "</option>";
					}
					inst.yearshtml += "</select>";
	
					html += inst.yearshtml;
					inst.yearshtml = null;
				}
			}
	
			html += this._get(inst, "yearSuffix");
			if (showMonthAfterYear) {
				html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
			}
			html += "</div>"; // Close datepicker_header
			return html;
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustInstDate: function(inst, offset, period) {
			var year = inst.drawYear + (period === "Y" ? offset : 0),
				month = inst.drawMonth + (period === "M" ? offset : 0),
				day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
				date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
	
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			if (period === "M" || period === "Y") {
				this._notifyChange(inst);
			}
		},
	
		/* Ensure a date is within any min/max bounds. */
		_restrictMinMax: function(inst, date) {
			var minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				newDate = (minDate && date < minDate ? minDate : date);
			return (maxDate && newDate > maxDate ? maxDate : newDate);
		},
	
		/* Notify change of month/year. */
		_notifyChange: function(inst) {
			var onChange = this._get(inst, "onChangeMonthYear");
			if (onChange) {
				onChange.apply((inst.input ? inst.input[0] : null),
					[inst.selectedYear, inst.selectedMonth + 1, inst]);
			}
		},
	
		/* Determine the number of months to show. */
		_getNumberOfMonths: function(inst) {
			var numMonths = this._get(inst, "numberOfMonths");
			return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
		},
	
		/* Determine the current maximum date - ensure no time components are set. */
		_getMinMaxDate: function(inst, minMax) {
			return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
		},
	
		/* Find the number of days in a given month. */
		_getDaysInMonth: function(year, month) {
			return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
		},
	
		/* Find the day of the week of the first of a month. */
		_getFirstDayOfMonth: function(year, month) {
			return new Date(year, month, 1).getDay();
		},
	
		/* Determines if we should allow a "next/prev" month display change. */
		_canAdjustMonth: function(inst, offset, curYear, curMonth) {
			var numMonths = this._getNumberOfMonths(inst),
				date = this._daylightSavingAdjust(new Date(curYear,
				curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
	
			if (offset < 0) {
				date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
			}
			return this._isInRange(inst, date);
		},
	
		/* Is the given date in the accepted range? */
		_isInRange: function(inst, date) {
			var yearSplit, currentYear,
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				minYear = null,
				maxYear = null,
				years = this._get(inst, "yearRange");
				if (years){
					yearSplit = years.split(":");
					currentYear = new Date().getFullYear();
					minYear = parseInt(yearSplit[0], 10);
					maxYear = parseInt(yearSplit[1], 10);
					if ( yearSplit[0].match(/[+\-].*/) ) {
						minYear += currentYear;
					}
					if ( yearSplit[1].match(/[+\-].*/) ) {
						maxYear += currentYear;
					}
				}
	
			return ((!minDate || date.getTime() >= minDate.getTime()) &&
				(!maxDate || date.getTime() <= maxDate.getTime()) &&
				(!minYear || date.getFullYear() >= minYear) &&
				(!maxYear || date.getFullYear() <= maxYear));
		},
	
		/* Provide the configuration settings for formatting/parsing. */
		_getFormatConfig: function(inst) {
			var shortYearCutoff = this._get(inst, "shortYearCutoff");
			shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
			return {shortYearCutoff: shortYearCutoff,
				dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
				monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
		},
	
		/* Format the given date for display. */
		_formatDate: function(inst, day, month, year) {
			if (!day) {
				inst.currentDay = inst.selectedDay;
				inst.currentMonth = inst.selectedMonth;
				inst.currentYear = inst.selectedYear;
			}
			var date = (day ? (typeof day === "object" ? day :
				this._daylightSavingAdjust(new Date(year, month, day))) :
				this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
			return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
		}
	});
	
	/*
	 * Bind hover events for datepicker elements.
	 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
	 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
	 */
	function bindHover(dpDiv) {
		var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
		return dpDiv.delegate(selector, "mouseout", function() {
				$(this).removeClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).removeClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).removeClass("ui-datepicker-next-hover");
				}
			})
			.delegate(selector, "mouseover", function(){
				if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
					$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
					$(this).addClass("ui-state-hover");
					if (this.className.indexOf("ui-datepicker-prev") !== -1) {
						$(this).addClass("ui-datepicker-prev-hover");
					}
					if (this.className.indexOf("ui-datepicker-next") !== -1) {
						$(this).addClass("ui-datepicker-next-hover");
					}
				}
			});
	}
	
	/* jQuery extend now ignores nulls! */
	function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] == null) {
				target[name] = props[name];
			}
		}
		return target;
	}
	
	/* Invoke the datepicker functionality.
	   @param  options  string - a command, optionally followed by additional parameters or
						Object - settings for attaching new datepicker functionality
	   @return  jQuery object */
	$.fn.datepicker = function(options){
	
		/* Verify an empty collection wasn't passed - Fixes #6976 */
		if ( !this.length ) {
			return this;
		}
	
		/* Initialise the date picker. */
		if (!$.datepicker.initialized) {
			$(document).mousedown($.datepicker._checkExternalClick);
			$.datepicker.initialized = true;
		}
	
		/* Append datepicker main container to body if not exist. */
		if ($("#"+$.datepicker._mainDivId).length === 0) {
			$("body").append($.datepicker.dpDiv);
		}
	
		var otherArgs = Array.prototype.slice.call(arguments, 1);
		if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		return this.each(function() {
			typeof options === "string" ?
				$.datepicker["_" + options + "Datepicker"].
					apply($.datepicker, [this].concat(otherArgs)) :
				$.datepicker._attachDatepicker(this, options);
		});
	};
	
	$.datepicker = new Datepicker(); // singleton instance
	$.datepicker.initialized = false;
	$.datepicker.uuid = new Date().getTime();
	$.datepicker.version = "1.10.3";
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	var sizeRelatedOptions = {
			buttons: true,
			height: true,
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true,
			width: true
		},
		resizableRelatedOptions = {
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true
		};
	
	$.widget( "ui.dialog", {
		version: "1.10.3",
		options: {
			appendTo: "body",
			autoOpen: true,
			buttons: [],
			closeOnEscape: true,
			closeText: "close",
			dialogClass: "",
			draggable: true,
			hide: null,
			height: "auto",
			maxHeight: null,
			maxWidth: null,
			minHeight: 150,
			minWidth: 150,
			modal: false,
			position: {
				my: "center",
				at: "center",
				of: window,
				collision: "fit",
				// Ensure the titlebar is always visible
				using: function( pos ) {
					var topOffset = $( this ).css( pos ).offset().top;
					if ( topOffset < 0 ) {
						$( this ).css( "top", pos.top - topOffset );
					}
				}
			},
			resizable: true,
			show: null,
			title: null,
			width: 300,
	
			// callbacks
			beforeClose: null,
			close: null,
			drag: null,
			dragStart: null,
			dragStop: null,
			focus: null,
			open: null,
			resize: null,
			resizeStart: null,
			resizeStop: null
		},
	
		_create: function() {
			this.originalCss = {
				display: this.element[0].style.display,
				width: this.element[0].style.width,
				minHeight: this.element[0].style.minHeight,
				maxHeight: this.element[0].style.maxHeight,
				height: this.element[0].style.height
			};
			this.originalPosition = {
				parent: this.element.parent(),
				index: this.element.parent().children().index( this.element )
			};
			this.originalTitle = this.element.attr("title");
			this.options.title = this.options.title || this.originalTitle;
	
			this._createWrapper();
	
			this.element
				.show()
				.removeAttr("title")
				.addClass("ui-dialog-content ui-widget-content")
				.appendTo( this.uiDialog );
	
			this._createTitlebar();
			this._createButtonPane();
	
			if ( this.options.draggable && $.fn.draggable ) {
				this._makeDraggable();
			}
			if ( this.options.resizable && $.fn.resizable ) {
				this._makeResizable();
			}
	
			this._isOpen = false;
		},
	
		_init: function() {
			if ( this.options.autoOpen ) {
				this.open();
			}
		},
	
		_appendTo: function() {
			var element = this.options.appendTo;
			if ( element && (element.jquery || element.nodeType) ) {
				return $( element );
			}
			return this.document.find( element || "body" ).eq( 0 );
		},
	
		_destroy: function() {
			var next,
				originalPosition = this.originalPosition;
	
			this._destroyOverlay();
	
			this.element
				.removeUniqueId()
				.removeClass("ui-dialog-content ui-widget-content")
				.css( this.originalCss )
				// Without detaching first, the following becomes really slow
				.detach();
	
			this.uiDialog.stop( true, true ).remove();
	
			if ( this.originalTitle ) {
				this.element.attr( "title", this.originalTitle );
			}
	
			next = originalPosition.parent.children().eq( originalPosition.index );
			// Don't try to place the dialog next to itself (#8613)
			if ( next.length && next[0] !== this.element[0] ) {
				next.before( this.element );
			} else {
				originalPosition.parent.append( this.element );
			}
		},
	
		widget: function() {
			return this.uiDialog;
		},
	
		disable: $.noop,
		enable: $.noop,
	
		close: function( event ) {
			var that = this;
	
			if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
				return;
			}
	
			this._isOpen = false;
			this._destroyOverlay();
	
			if ( !this.opener.filter(":focusable").focus().length ) {
				// Hiding a focused element doesn't trigger blur in WebKit
				// so in case we have nothing to focus on, explicitly blur the active element
				// https://bugs.webkit.org/show_bug.cgi?id=47182
				$( this.document[0].activeElement ).blur();
			}
	
			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( "close", event );
			});
		},
	
		isOpen: function() {
			return this._isOpen;
		},
	
		moveToTop: function() {
			this._moveToTop();
		},
	
		_moveToTop: function( event, silent ) {
			var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
			if ( moved && !silent ) {
				this._trigger( "focus", event );
			}
			return moved;
		},
	
		open: function() {
			var that = this;
			if ( this._isOpen ) {
				if ( this._moveToTop() ) {
					this._focusTabbable();
				}
				return;
			}
	
			this._isOpen = true;
			this.opener = $( this.document[0].activeElement );
	
			this._size();
			this._position();
			this._createOverlay();
			this._moveToTop( null, true );
			this._show( this.uiDialog, this.options.show, function() {
				that._focusTabbable();
				that._trigger("focus");
			});
	
			this._trigger("open");
		},
	
		_focusTabbable: function() {
			// Set focus to the first match:
			// 1. First element inside the dialog matching [autofocus]
			// 2. Tabbable element inside the content element
			// 3. Tabbable element inside the buttonpane
			// 4. The close button
			// 5. The dialog itself
			var hasFocus = this.element.find("[autofocus]");
			if ( !hasFocus.length ) {
				hasFocus = this.element.find(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogButtonPane.find(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialog;
			}
			hasFocus.eq( 0 ).focus();
		},
	
		_keepFocus: function( event ) {
			function checkFocus() {
				var activeElement = this.document[0].activeElement,
					isActive = this.uiDialog[0] === activeElement ||
						$.contains( this.uiDialog[0], activeElement );
				if ( !isActive ) {
					this._focusTabbable();
				}
			}
			event.preventDefault();
			checkFocus.call( this );
			// support: IE
			// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
			// so we check again later
			this._delay( checkFocus );
		},
	
		_createWrapper: function() {
			this.uiDialog = $("<div>")
				.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
					this.options.dialogClass )
				.hide()
				.attr({
					// Setting tabIndex makes the div focusable
					tabIndex: -1,
					role: "dialog"
				})
				.appendTo( this._appendTo() );
	
			this._on( this.uiDialog, {
				keydown: function( event ) {
					if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						event.preventDefault();
						this.close( event );
						return;
					}
	
					// prevent tabbing out of dialogs
					if ( event.keyCode !== $.ui.keyCode.TAB ) {
						return;
					}
					var tabbables = this.uiDialog.find(":tabbable"),
						first = tabbables.filter(":first"),
						last  = tabbables.filter(":last");
	
					if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
						first.focus( 1 );
						event.preventDefault();
					} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
						last.focus( 1 );
						event.preventDefault();
					}
				},
				mousedown: function( event ) {
					if ( this._moveToTop( event ) ) {
						this._focusTabbable();
					}
				}
			});
	
			// We assume that any existing aria-describedby attribute means
			// that the dialog content is marked up properly
			// otherwise we brute force the content as the description
			if ( !this.element.find("[aria-describedby]").length ) {
				this.uiDialog.attr({
					"aria-describedby": this.element.uniqueId().attr("id")
				});
			}
		},
	
		_createTitlebar: function() {
			var uiDialogTitle;
	
			this.uiDialogTitlebar = $("<div>")
				.addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
				.prependTo( this.uiDialog );
			this._on( this.uiDialogTitlebar, {
				mousedown: function( event ) {
					// Don't prevent click on close button (#8838)
					// Focusing a dialog that is partially scrolled out of view
					// causes the browser to scroll it into view, preventing the click event
					if ( !$( event.target ).closest(".ui-dialog-titlebar-close") ) {
						// Dialog isn't getting focus when dragging (#8063)
						this.uiDialog.focus();
					}
				}
			});
	
			this.uiDialogTitlebarClose = $("<button></button>")
				.button({
					label: this.options.closeText,
					icons: {
						primary: "ui-icon-closethick"
					},
					text: false
				})
				.addClass("ui-dialog-titlebar-close")
				.appendTo( this.uiDialogTitlebar );
			this._on( this.uiDialogTitlebarClose, {
				click: function( event ) {
					event.preventDefault();
					this.close( event );
				}
			});
	
			uiDialogTitle = $("<span>")
				.uniqueId()
				.addClass("ui-dialog-title")
				.prependTo( this.uiDialogTitlebar );
			this._title( uiDialogTitle );
	
			this.uiDialog.attr({
				"aria-labelledby": uiDialogTitle.attr("id")
			});
		},
	
		_title: function( title ) {
			if ( !this.options.title ) {
				title.html("&#160;");
			}
			title.text( this.options.title );
		},
	
		_createButtonPane: function() {
			this.uiDialogButtonPane = $("<div>")
				.addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
	
			this.uiButtonSet = $("<div>")
				.addClass("ui-dialog-buttonset")
				.appendTo( this.uiDialogButtonPane );
	
			this._createButtons();
		},
	
		_createButtons: function() {
			var that = this,
				buttons = this.options.buttons;
	
			// if we already have a button pane, remove it
			this.uiDialogButtonPane.remove();
			this.uiButtonSet.empty();
	
			if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
				this.uiDialog.removeClass("ui-dialog-buttons");
				return;
			}
	
			$.each( buttons, function( name, props ) {
				var click, buttonOptions;
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				// Default to a non-submitting button
				props = $.extend( { type: "button" }, props );
				// Change the context for the click callback to be the main element
				click = props.click;
				props.click = function() {
					click.apply( that.element[0], arguments );
				};
				buttonOptions = {
					icons: props.icons,
					text: props.showText
				};
				delete props.icons;
				delete props.showText;
				$( "<button></button>", props )
					.button( buttonOptions )
					.appendTo( that.uiButtonSet );
			});
			this.uiDialog.addClass("ui-dialog-buttons");
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		},
	
		_makeDraggable: function() {
			var that = this,
				options = this.options;
	
			function filteredUi( ui ) {
				return {
					position: ui.position,
					offset: ui.offset
				};
			}
	
			this.uiDialog.draggable({
				cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
				handle: ".ui-dialog-titlebar",
				containment: "document",
				start: function( event, ui ) {
					$( this ).addClass("ui-dialog-dragging");
					that._blockFrames();
					that._trigger( "dragStart", event, filteredUi( ui ) );
				},
				drag: function( event, ui ) {
					that._trigger( "drag", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					options.position = [
						ui.position.left - that.document.scrollLeft(),
						ui.position.top - that.document.scrollTop()
					];
					$( this ).removeClass("ui-dialog-dragging");
					that._unblockFrames();
					that._trigger( "dragStop", event, filteredUi( ui ) );
				}
			});
		},
	
		_makeResizable: function() {
			var that = this,
				options = this.options,
				handles = options.resizable,
				// .ui-resizable has position: relative defined in the stylesheet
				// but dialogs have to use absolute or fixed positioning
				position = this.uiDialog.css("position"),
				resizeHandles = typeof handles === "string" ?
					handles	:
					"n,e,s,w,se,sw,ne,nw";
	
			function filteredUi( ui ) {
				return {
					originalPosition: ui.originalPosition,
					originalSize: ui.originalSize,
					position: ui.position,
					size: ui.size
				};
			}
	
			this.uiDialog.resizable({
				cancel: ".ui-dialog-content",
				containment: "document",
				alsoResize: this.element,
				maxWidth: options.maxWidth,
				maxHeight: options.maxHeight,
				minWidth: options.minWidth,
				minHeight: this._minHeight(),
				handles: resizeHandles,
				start: function( event, ui ) {
					$( this ).addClass("ui-dialog-resizing");
					that._blockFrames();
					that._trigger( "resizeStart", event, filteredUi( ui ) );
				},
				resize: function( event, ui ) {
					that._trigger( "resize", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					options.height = $( this ).height();
					options.width = $( this ).width();
					$( this ).removeClass("ui-dialog-resizing");
					that._unblockFrames();
					that._trigger( "resizeStop", event, filteredUi( ui ) );
				}
			})
			.css( "position", position );
		},
	
		_minHeight: function() {
			var options = this.options;
	
			return options.height === "auto" ?
				options.minHeight :
				Math.min( options.minHeight, options.height );
		},
	
		_position: function() {
			// Need to show the dialog to get the actual offset in the position plugin
			var isVisible = this.uiDialog.is(":visible");
			if ( !isVisible ) {
				this.uiDialog.show();
			}
			this.uiDialog.position( this.options.position );
			if ( !isVisible ) {
				this.uiDialog.hide();
			}
		},
	
		_setOptions: function( options ) {
			var that = this,
				resize = false,
				resizableOptions = {};
	
			$.each( options, function( key, value ) {
				that._setOption( key, value );
	
				if ( key in sizeRelatedOptions ) {
					resize = true;
				}
				if ( key in resizableRelatedOptions ) {
					resizableOptions[ key ] = value;
				}
			});
	
			if ( resize ) {
				this._size();
				this._position();
			}
			if ( this.uiDialog.is(":data(ui-resizable)") ) {
				this.uiDialog.resizable( "option", resizableOptions );
			}
		},
	
		_setOption: function( key, value ) {
			/*jshint maxcomplexity:15*/
			var isDraggable, isResizable,
				uiDialog = this.uiDialog;
	
			if ( key === "dialogClass" ) {
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}
	
			if ( key === "disabled" ) {
				return;
			}
	
			this._super( key, value );
	
			if ( key === "appendTo" ) {
				this.uiDialog.appendTo( this._appendTo() );
			}
	
			if ( key === "buttons" ) {
				this._createButtons();
			}
	
			if ( key === "closeText" ) {
				this.uiDialogTitlebarClose.button({
					// Ensure that we always pass a string
					label: "" + value
				});
			}
	
			if ( key === "draggable" ) {
				isDraggable = uiDialog.is(":data(ui-draggable)");
				if ( isDraggable && !value ) {
					uiDialog.draggable("destroy");
				}
	
				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
			}
	
			if ( key === "position" ) {
				this._position();
			}
	
			if ( key === "resizable" ) {
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is(":data(ui-resizable)");
				if ( isResizable && !value ) {
					uiDialog.resizable("destroy");
				}
	
				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}
	
				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable();
				}
			}
	
			if ( key === "title" ) {
				this._title( this.uiDialogTitlebar.find(".ui-dialog-title") );
			}
		},
	
		_size: function() {
			// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
			// divs will both have width and height set, so we need to reset them
			var nonContentHeight, minContentHeight, maxContentHeight,
				options = this.options;
	
			// Reset content sizing
			this.element.show().css({
				width: "auto",
				minHeight: 0,
				maxHeight: "none",
				height: 0
			});
	
			if ( options.minWidth > options.width ) {
				options.width = options.minWidth;
			}
	
			// reset wrapper sizing
			// determine the height of all the non-content elements
			nonContentHeight = this.uiDialog.css({
					height: "auto",
					width: options.width
				})
				.outerHeight();
			minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
			maxContentHeight = typeof options.maxHeight === "number" ?
				Math.max( 0, options.maxHeight - nonContentHeight ) :
				"none";
	
			if ( options.height === "auto" ) {
				this.element.css({
					minHeight: minContentHeight,
					maxHeight: maxContentHeight,
					height: "auto"
				});
			} else {
				this.element.height( Math.max( 0, options.height - nonContentHeight ) );
			}
	
			if (this.uiDialog.is(":data(ui-resizable)") ) {
				this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
			}
		},
	
		_blockFrames: function() {
			this.iframeBlocks = this.document.find( "iframe" ).map(function() {
				var iframe = $( this );
	
				return $( "<div>" )
					.css({
						position: "absolute",
						width: iframe.outerWidth(),
						height: iframe.outerHeight()
					})
					.appendTo( iframe.parent() )
					.offset( iframe.offset() )[0];
			});
		},
	
		_unblockFrames: function() {
			if ( this.iframeBlocks ) {
				this.iframeBlocks.remove();
				delete this.iframeBlocks;
			}
		},
	
		_allowInteraction: function( event ) {
			if ( $( event.target ).closest(".ui-dialog").length ) {
				return true;
			}
	
			// TODO: Remove hack when datepicker implements
			// the .ui-front logic (#8989)
			return !!$( event.target ).closest(".ui-datepicker").length;
		},
	
		_createOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}
	
			var that = this,
				widgetFullName = this.widgetFullName;
			if ( !$.ui.dialog.overlayInstances ) {
				// Prevent use of anchors and inputs.
				// We use a delay in case the overlay is created from an
				// event that we're going to be cancelling. (#2804)
				this._delay(function() {
					// Handle .dialog().dialog("close") (#4065)
					if ( $.ui.dialog.overlayInstances ) {
						this.document.bind( "focusin.dialog", function( event ) {
							if ( !that._allowInteraction( event ) ) {
								event.preventDefault();
								$(".ui-dialog:visible:last .ui-dialog-content")
									.data( widgetFullName )._focusTabbable();
							}
						});
					}
				});
			}
	
			this.overlay = $("<div>")
				.addClass("ui-widget-overlay ui-front")
				.appendTo( this._appendTo() );
			this._on( this.overlay, {
				mousedown: "_keepFocus"
			});
			$.ui.dialog.overlayInstances++;
		},
	
		_destroyOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}
	
			if ( this.overlay ) {
				$.ui.dialog.overlayInstances--;
	
				if ( !$.ui.dialog.overlayInstances ) {
					this.document.unbind( "focusin.dialog" );
				}
				this.overlay.remove();
				this.overlay = null;
			}
		}
	});
	
	$.ui.dialog.overlayInstances = 0;
	
	// DEPRECATED
	if ( $.uiBackCompat !== false ) {
		// position option with array notation
		// just override with old implementation
		$.widget( "ui.dialog", $.ui.dialog, {
			_position: function() {
				var position = this.options.position,
					myAt = [],
					offset = [ 0, 0 ],
					isVisible;
	
				if ( position ) {
					if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
						myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
						if ( myAt.length === 1 ) {
							myAt[1] = myAt[0];
						}
	
						$.each( [ "left", "top" ], function( i, offsetPosition ) {
							if ( +myAt[ i ] === myAt[ i ] ) {
								offset[ i ] = myAt[ i ];
								myAt[ i ] = offsetPosition;
							}
						});
	
						position = {
							my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
								myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
							at: myAt.join(" ")
						};
					}
	
					position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
				} else {
					position = $.ui.dialog.prototype.options.position;
				}
	
				// need to show the dialog to get the actual offset in the position plugin
				isVisible = this.uiDialog.is(":visible");
				if ( !isVisible ) {
					this.uiDialog.show();
				}
				this.uiDialog.position( position );
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
			}
		});
	}
	
	}( jQuery ) );
	
	(function( $, undefined ) {
	
	var rvertical = /up|down|vertical/,
		rpositivemotion = /up|left|vertical|horizontal/;
	
	$.effects.effect.blind = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			direction = o.direction || "up",
			vertical = rvertical.test( direction ),
			ref = vertical ? "height" : "width",
			ref2 = vertical ? "top" : "left",
			motion = rpositivemotion.test( direction ),
			animation = {},
			show = mode === "show",
			wrapper, distance, margin;
	
		// if already wrapped, the wrapper's properties are my property. #6245
		if ( el.parent().is( ".ui-effects-wrapper" ) ) {
			$.effects.save( el.parent(), props );
		} else {
			$.effects.save( el, props );
		}
		el.show();
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		distance = wrapper[ ref ]();
		margin = parseFloat( wrapper.css( ref2 ) ) || 0;
	
		animation[ ref ] = show ? distance : 0;
		if ( !motion ) {
			el
				.css( vertical ? "bottom" : "right", 0 )
				.css( vertical ? "top" : "left", "auto" )
				.css({ position: "absolute" });
	
			animation[ ref2 ] = show ? margin : distance + margin;
		}
	
		// start at 0 if we are showing
		if ( show ) {
			wrapper.css( ref, 0 );
			if ( ! motion ) {
				wrapper.css( ref2, margin + distance );
			}
		}
	
		// Animate
		wrapper.animate( animation, {
			duration: o.duration,
			easing: o.easing,
			queue: false,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.bounce = function( o, done ) {
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
	
			// defaults:
			mode = $.effects.setMode( el, o.mode || "effect" ),
			hide = mode === "hide",
			show = mode === "show",
			direction = o.direction || "up",
			distance = o.distance,
			times = o.times || 5,
	
			// number of internal animations
			anims = times * 2 + ( show || hide ? 1 : 0 ),
			speed = o.duration / anims,
			easing = o.easing,
	
			// utility:
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ),
			i,
			upAnim,
			downAnim,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		// Avoid touching opacity to prevent clearType and PNG issues in IE
		if ( show || hide ) {
			props.push( "opacity" );
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el ); // Create Wrapper
	
		// default distance for the BIGGEST bounce is the outer Distance / 3
		if ( !distance ) {
			distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
		}
	
		if ( show ) {
			downAnim = { opacity: 1 };
			downAnim[ ref ] = 0;
	
			// if we are showing, force opacity 0 and set the initial position
			// then do the "first" animation
			el.css( "opacity", 0 )
				.css( ref, motion ? -distance * 2 : distance * 2 )
				.animate( downAnim, speed, easing );
		}
	
		// start at the smallest distance if we are hiding
		if ( hide ) {
			distance = distance / Math.pow( 2, times - 1 );
		}
	
		downAnim = {};
		downAnim[ ref ] = 0;
		// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
		for ( i = 0; i < times; i++ ) {
			upAnim = {};
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing )
				.animate( downAnim, speed, easing );
	
			distance = hide ? distance * 2 : distance / 2;
		}
	
		// Last Bounce when Hiding
		if ( hide ) {
			upAnim = { opacity: 0 };
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing );
		}
	
		el.queue(function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.clip = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "vertical",
			vert = direction === "vertical",
			size = vert ? "height" : "width",
			position = vert ? "top" : "left",
			animation = {},
			wrapper, animate, distance;
	
		// Save & Show
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
		distance = animate[ size ]();
	
		// Shift
		if ( show ) {
			animate.css( size, 0 );
			animate.css( position, distance / 2 );
		}
	
		// Create Animation Object:
		animation[ size ] = show ? distance : 0;
		animation[ position ] = show ? 0 : distance / 2;
	
		// Animate
		animate.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( !show ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.drop = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
			animation = {
				opacity: show ? 1 : 0
			},
			distance;
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;
	
		if ( show ) {
			el
				.css( "opacity", 0 )
				.css( ref, motion === "pos" ? -distance : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( motion === "pos" ? "+=" : "-=" ) :
			( motion === "pos" ? "-=" : "+=" ) ) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.explode = function( o, done ) {
	
		var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
			cells = rows,
			el = $( this ),
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
	
			// show and then visibility:hidden the element before calculating offset
			offset = el.show().css( "visibility", "hidden" ).offset(),
	
			// width and height of a piece
			width = Math.ceil( el.outerWidth() / cells ),
			height = Math.ceil( el.outerHeight() / rows ),
			pieces = [],
	
			// loop
			i, j, left, top, mx, my;
	
		// children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}
	
		// clone the element for each row and cell.
		for( i = 0; i < rows ; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2 ;
	
			for( j = 0; j < cells ; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2 ;
	
				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				el
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css({
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					})
	
				// select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
					.parent()
					.addClass( "ui-effects-explode" )
					.css({
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					}).animate({
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, o.duration || 500, o.easing, childComplete );
			}
		}
	
		function animComplete() {
			el.css({
				visibility: "visible"
			});
			$( pieces ).remove();
			if ( !show ) {
				el.hide();
			}
			done();
		}
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.fade = function( o, done ) {
		var el = $( this ),
			mode = $.effects.setMode( el, o.mode || "toggle" );
	
		el.animate({
			opacity: mode
		}, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: done
		});
	};
	
	})( jQuery );
	
	(function( $, undefined ) {
	
	$.effects.effect.fold = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			hide = mode === "hide",
			size = o.size || 15,
			percent = /([0-9]+)%/.exec( size ),
			horizFirst = !!o.horizFirst,
			widthFirst = show !== horizFirst,
			ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
			duration = o.duration / 2,
			wrapper, distance,
			animation1 = {},
			animation2 = {};
	
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		distance = widthFirst ?
			[ wrapper.width(), wrapper.height() ] :
			[ wrapper.height(), wrapper.width() ];
	
		if ( percent ) {
			size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
		}
		if ( show ) {
			wrapper.css( horizFirst ? {
				height: 0,
				width: size
			} : {
				height: size,
				width: 0
			});
		}
	
		// Animation
		animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
		animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;
	
		// Animate
		wrapper
			.animate( animation1, duration, o.easing )
			.animate( animation2, duration, o.easing, function() {
				if ( hide ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.highlight = function( o, done ) {
		var elem = $( this ),
			props = [ "backgroundImage", "backgroundColor", "opacity" ],
			mode = $.effects.setMode( elem, o.mode || "show" ),
			animation = {
				backgroundColor: elem.css( "backgroundColor" )
			};
	
		if (mode === "hide") {
			animation.opacity = 0;
		}
	
		$.effects.save( elem, props );
	
		elem
			.show()
			.css({
				backgroundImage: "none",
				backgroundColor: o.color || "#ffff99"
			})
			.animate( animation, {
				queue: false,
				duration: o.duration,
				easing: o.easing,
				complete: function() {
					if ( mode === "hide" ) {
						elem.hide();
					}
					$.effects.restore( elem, props );
					done();
				}
			});
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.pulsate = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "show" ),
			show = mode === "show",
			hide = mode === "hide",
			showhide = ( show || mode === "hide" ),
	
			// showing or hiding leaves of the "last" animation
			anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = o.duration / anims,
			animateTo = 0,
			queue = elem.queue(),
			queuelen = queue.length,
			i;
	
		if ( show || !elem.is(":visible")) {
			elem.css( "opacity", 0 ).show();
			animateTo = 1;
		}
	
		// anims - 1 opacity "toggles"
		for ( i = 1; i < anims; i++ ) {
			elem.animate({
				opacity: animateTo
			}, duration, o.easing );
			animateTo = 1 - animateTo;
		}
	
		elem.animate({
			opacity: animateTo
		}, duration, o.easing);
	
		elem.queue(function() {
			if ( hide ) {
				elem.hide();
			}
			done();
		});
	
		// We just queued up "anims" animations, we need to put them next in the queue
		if ( queuelen > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		elem.dequeue();
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.puff = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "hide" ),
			hide = mode === "hide",
			percent = parseInt( o.percent, 10 ) || 150,
			factor = percent / 100,
			original = {
				height: elem.height(),
				width: elem.width(),
				outerHeight: elem.outerHeight(),
				outerWidth: elem.outerWidth()
			};
	
		$.extend( o, {
			effect: "scale",
			queue: false,
			fade: true,
			mode: mode,
			complete: done,
			percent: hide ? percent : 100,
			from: hide ?
				original :
				{
					height: original.height * factor,
					width: original.width * factor,
					outerHeight: original.outerHeight * factor,
					outerWidth: original.outerWidth * factor
				}
		});
	
		elem.effect( o );
	};
	
	$.effects.effect.scale = function( o, done ) {
	
		// Create element
		var el = $( this ),
			options = $.extend( true, {}, o ),
			mode = $.effects.setMode( el, o.mode || "effect" ),
			percent = parseInt( o.percent, 10 ) ||
				( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
			direction = o.direction || "both",
			origin = o.origin,
			original = {
				height: el.height(),
				width: el.width(),
				outerHeight: el.outerHeight(),
				outerWidth: el.outerWidth()
			},
			factor = {
				y: direction !== "horizontal" ? (percent / 100) : 1,
				x: direction !== "vertical" ? (percent / 100) : 1
			};
	
		// We are going to pass this effect to the size effect:
		options.effect = "size";
		options.queue = false;
		options.complete = done;
	
		// Set default origin and restore for show/hide
		if ( mode !== "effect" ) {
			options.origin = origin || ["middle","center"];
			options.restore = true;
		}
	
		options.from = o.from || ( mode === "show" ? {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		} : original );
		options.to = {
			height: original.height * factor.y,
			width: original.width * factor.x,
			outerHeight: original.outerHeight * factor.y,
			outerWidth: original.outerWidth * factor.x
		};
	
		// Fade option to support puff
		if ( options.fade ) {
			if ( mode === "show" ) {
				options.from.opacity = 0;
				options.to.opacity = 1;
			}
			if ( mode === "hide" ) {
				options.from.opacity = 1;
				options.to.opacity = 0;
			}
		}
	
		// Animate
		el.effect( options );
	
	};
	
	$.effects.effect.size = function( o, done ) {
	
		// Create element
		var original, baseline, factor,
			el = $( this ),
			props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],
	
			// Always restore
			props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],
	
			// Copy for children
			props2 = [ "width", "height", "overflow" ],
			cProps = [ "fontSize" ],
			vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
			hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
	
			// Set options
			mode = $.effects.setMode( el, o.mode || "effect" ),
			restore = o.restore || mode !== "effect",
			scale = o.scale || "both",
			origin = o.origin || [ "middle", "center" ],
			position = el.css( "position" ),
			props = restore ? props0 : props1,
			zero = {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
	
		if ( mode === "show" ) {
			el.show();
		}
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		};
	
		if ( o.mode === "toggle" && mode === "show" ) {
			el.from = o.to || zero;
			el.to = o.from || original;
		} else {
			el.from = o.from || ( mode === "show" ? zero : original );
			el.to = o.to || ( mode === "hide" ? zero : original );
		}
	
		// Set scaling factor
		factor = {
			from: {
				y: el.from.height / original.height,
				x: el.from.width / original.width
			},
			to: {
				y: el.to.height / original.height,
				x: el.to.width / original.width
			}
		};
	
		// Scale the css box
		if ( scale === "box" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( vProps );
				el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
			}
	
			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				props = props.concat( hProps );
				el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
				el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
			}
		}
	
		// Scale the content
		if ( scale === "content" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( cProps ).concat( props2 );
				el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
			}
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
		el.css( "overflow", "hidden" ).css( el.from );
	
		// Adjust
		if (origin) { // Calculate baseline shifts
			baseline = $.effects.getBaseline( origin, original );
			el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
			el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
			el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
			el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
		}
		el.css( el.from ); // set top & left
	
		// Animate
		if ( scale === "content" || scale === "both" ) { // Scale the children
	
			// Add margins/font-size
			vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
			hProps = hProps.concat([ "marginLeft", "marginRight" ]);
			props2 = props0.concat(vProps).concat(hProps);
	
			el.find( "*[width]" ).each( function(){
				var child = $( this ),
					c_original = {
						height: child.height(),
						width: child.width(),
						outerHeight: child.outerHeight(),
						outerWidth: child.outerWidth()
					};
				if (restore) {
					$.effects.save(child, props2);
				}
	
				child.from = {
					height: c_original.height * factor.from.y,
					width: c_original.width * factor.from.x,
					outerHeight: c_original.outerHeight * factor.from.y,
					outerWidth: c_original.outerWidth * factor.from.x
				};
				child.to = {
					height: c_original.height * factor.to.y,
					width: c_original.width * factor.to.x,
					outerHeight: c_original.height * factor.to.y,
					outerWidth: c_original.width * factor.to.x
				};
	
				// Vertical props scaling
				if ( factor.from.y !== factor.to.y ) {
					child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
					child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
				}
	
				// Horizontal props scaling
				if ( factor.from.x !== factor.to.x ) {
					child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
					child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
				}
	
				// Animate children
				child.css( child.from );
				child.animate( child.to, o.duration, o.easing, function() {
	
					// Restore children
					if ( restore ) {
						$.effects.restore( child, props2 );
					}
				});
			});
		}
	
		// Animate
		el.animate( el.to, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( el.to.opacity === 0 ) {
					el.css( "opacity", el.from.opacity );
				}
				if( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				if ( !restore ) {
	
					// we need to calculate our new positioning based on the scaling
					if ( position === "static" ) {
						el.css({
							position: "relative",
							top: el.to.top,
							left: el.to.left
						});
					} else {
						$.each([ "top", "left" ], function( idx, pos ) {
							el.css( pos, function( _, str ) {
								var val = parseInt( str, 10 ),
									toRef = idx ? el.to.left : el.to.top;
	
								// if original was "auto", recalculate the new value from wrapper
								if ( str === "auto" ) {
									return toRef + "px";
								}
	
								return val + toRef + "px";
							});
						});
					}
				}
	
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.shake = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "effect" ),
			direction = o.direction || "left",
			distance = o.distance || 20,
			times = o.times || 3,
			anims = times * 2 + 1,
			speed = Math.round(o.duration/anims),
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			animation = {},
			animation1 = {},
			animation2 = {},
			i,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		// Animation
		animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
		animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
		animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
	
		// Animate
		el.animate( animation, speed, o.easing );
	
		// Shakes
		for ( i = 1; i < times; i++ ) {
			el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
		}
		el
			.animate( animation1, speed, o.easing )
			.animate( animation, speed / 2, o.easing )
			.queue(function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.slide = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
			mode = $.effects.setMode( el, o.mode || "show" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			distance,
			animation = {};
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );
	
		$.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		if ( show ) {
			el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( positiveMotion ? "+=" : "-=") :
			( positiveMotion ? "-=" : "+=")) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.effects.effect.transfer = function( o, done ) {
		var elem = $( this ),
			target = $( o.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $("body"),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop ,
				left: endPosition.left - fixLeft ,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( document.body )
				.addClass( o.className )
				.css({
					top: startPosition.top - fixTop ,
					left: startPosition.left - fixLeft ,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				})
				.animate( animation, o.duration, o.easing, function() {
					transfer.remove();
					done();
				});
	};
	
	})(jQuery);
	
	(function( $, undefined ) {
	
	$.widget( "ui.menu", {
		version: "1.10.3",
		defaultElement: "<ul>",
		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-carat-1-e"
			},
			menus: "ul",
			position: {
				my: "left top",
				at: "right top"
			},
			role: "menu",
	
			// callbacks
			blur: null,
			focus: null,
			select: null
		},
	
		_create: function() {
			this.activeMenu = this.element;
			// flag used to prevent firing of the click handler
			// as the event bubbles up through nested menus
			this.mouseHandled = false;
			this.element
				.uniqueId()
				.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
				.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
				.attr({
					role: this.options.role,
					tabIndex: 0
				})
				// need to catch all clicks on disabled menu
				// not possible through _on
				.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
					if ( this.options.disabled ) {
						event.preventDefault();
					}
				}, this ));
	
			if ( this.options.disabled ) {
				this.element
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			}
	
			this._on({
				// Prevent focus from sticking to links inside menu after clicking
				// them (focus should always stay on UL during navigation).
				"mousedown .ui-menu-item > a": function( event ) {
					event.preventDefault();
				},
				"click .ui-state-disabled > a": function( event ) {
					event.preventDefault();
				},
				"click .ui-menu-item:has(a)": function( event ) {
					var target = $( event.target ).closest( ".ui-menu-item" );
					if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
						this.mouseHandled = true;
	
						this.select( event );
						// Open submenu on click
						if ( target.has( ".ui-menu" ).length ) {
							this.expand( event );
						} else if ( !this.element.is( ":focus" ) ) {
							// Redirect focus to the menu
							this.element.trigger( "focus", [ true ] );
	
							// If the active item is on the top level, let it stay active.
							// Otherwise, blur the active item since it is no longer visible.
							if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
								clearTimeout( this.timer );
							}
						}
					}
				},
				"mouseenter .ui-menu-item": function( event ) {
					var target = $( event.currentTarget );
					// Remove ui-state-active class from siblings of the newly focused menu item
					// to avoid a jump caused by adjacent elements both having a class with a border
					target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
					this.focus( event, target );
				},
				mouseleave: "collapseAll",
				"mouseleave .ui-menu": "collapseAll",
				focus: function( event, keepActiveItem ) {
					// If there's already an active item, keep it active
					// If not, activate the first item
					var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );
	
					if ( !keepActiveItem ) {
						this.focus( event, item );
					}
				},
				blur: function( event ) {
					this._delay(function() {
						if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
							this.collapseAll( event );
						}
					});
				},
				keydown: "_keydown"
			});
	
			this.refresh();
	
			// Clicks outside of a menu collapse any open menus
			this._on( this.document, {
				click: function( event ) {
					if ( !$( event.target ).closest( ".ui-menu" ).length ) {
						this.collapseAll( event );
					}
	
					// Reset the mouseHandled flag
					this.mouseHandled = false;
				}
			});
		},
	
		_destroy: function() {
			// Destroy (sub)menus
			this.element
				.removeAttr( "aria-activedescendant" )
				.find( ".ui-menu" ).addBack()
					.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
					.removeAttr( "role" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-disabled" )
					.removeUniqueId()
					.show();
	
			// Destroy menu items
			this.element.find( ".ui-menu-item" )
				.removeClass( "ui-menu-item" )
				.removeAttr( "role" )
				.removeAttr( "aria-disabled" )
				.children( "a" )
					.removeUniqueId()
					.removeClass( "ui-corner-all ui-state-hover" )
					.removeAttr( "tabIndex" )
					.removeAttr( "role" )
					.removeAttr( "aria-haspopup" )
					.children().each( function() {
						var elem = $( this );
						if ( elem.data( "ui-menu-submenu-carat" ) ) {
							elem.remove();
						}
					});
	
			// Destroy menu dividers
			this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
		},
	
		_keydown: function( event ) {
			/*jshint maxcomplexity:20*/
			var match, prev, character, skip, regex,
				preventDefault = true;
	
			function escape( value ) {
				return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
			}
	
			switch ( event.keyCode ) {
			case $.ui.keyCode.PAGE_UP:
				this.previousPage( event );
				break;
			case $.ui.keyCode.PAGE_DOWN:
				this.nextPage( event );
				break;
			case $.ui.keyCode.HOME:
				this._move( "first", "first", event );
				break;
			case $.ui.keyCode.END:
				this._move( "last", "last", event );
				break;
			case $.ui.keyCode.UP:
				this.previous( event );
				break;
			case $.ui.keyCode.DOWN:
				this.next( event );
				break;
			case $.ui.keyCode.LEFT:
				this.collapse( event );
				break;
			case $.ui.keyCode.RIGHT:
				if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
					this.expand( event );
				}
				break;
			case $.ui.keyCode.ENTER:
			case $.ui.keyCode.SPACE:
				this._activate( event );
				break;
			case $.ui.keyCode.ESCAPE:
				this.collapse( event );
				break;
			default:
				preventDefault = false;
				prev = this.previousFilter || "";
				character = String.fromCharCode( event.keyCode );
				skip = false;
	
				clearTimeout( this.filterTimer );
	
				if ( character === prev ) {
					skip = true;
				} else {
					character = prev + character;
				}
	
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
				match = skip && match.index( this.active.next() ) !== -1 ?
					this.active.nextAll( ".ui-menu-item" ) :
					match;
	
				// If no matches on the current filter, reset to the last character pressed
				// to move down the menu to the first item that starts with that character
				if ( !match.length ) {
					character = String.fromCharCode( event.keyCode );
					regex = new RegExp( "^" + escape( character ), "i" );
					match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
						return regex.test( $( this ).children( "a" ).text() );
					});
				}
	
				if ( match.length ) {
					this.focus( event, match );
					if ( match.length > 1 ) {
						this.previousFilter = character;
						this.filterTimer = this._delay(function() {
							delete this.previousFilter;
						}, 1000 );
					} else {
						delete this.previousFilter;
					}
				} else {
					delete this.previousFilter;
				}
			}
	
			if ( preventDefault ) {
				event.preventDefault();
			}
		},
	
		_activate: function( event ) {
			if ( !this.active.is( ".ui-state-disabled" ) ) {
				if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
					this.expand( event );
				} else {
					this.select( event );
				}
			}
		},
	
		refresh: function() {
			var menus,
				icon = this.options.icons.submenu,
				submenus = this.element.find( this.options.menus );
	
			// Initialize nested menus
			submenus.filter( ":not(.ui-menu)" )
				.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
				.hide()
				.attr({
					role: this.options.role,
					"aria-hidden": "true",
					"aria-expanded": "false"
				})
				.each(function() {
					var menu = $( this ),
						item = menu.prev( "a" ),
						submenuCarat = $( "<span>" )
							.addClass( "ui-menu-icon ui-icon " + icon )
							.data( "ui-menu-submenu-carat", true );
	
					item
						.attr( "aria-haspopup", "true" )
						.prepend( submenuCarat );
					menu.attr( "aria-labelledby", item.attr( "id" ) );
				});
	
			menus = submenus.add( this.element );
	
			// Don't refresh list items that are already adapted
			menus.children( ":not(.ui-menu-item):has(a)" )
				.addClass( "ui-menu-item" )
				.attr( "role", "presentation" )
				.children( "a" )
					.uniqueId()
					.addClass( "ui-corner-all" )
					.attr({
						tabIndex: -1,
						role: this._itemRole()
					});
	
			// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
			menus.children( ":not(.ui-menu-item)" ).each(function() {
				var item = $( this );
				// hyphen, em dash, en dash
				if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
					item.addClass( "ui-widget-content ui-menu-divider" );
				}
			});
	
			// Add aria-disabled attribute to any disabled menu item
			menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );
	
			// If the active item has been removed, blur the menu
			if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				this.blur();
			}
		},
	
		_itemRole: function() {
			return {
				menu: "menuitem",
				listbox: "option"
			}[ this.options.role ];
		},
	
		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				this.element.find( ".ui-menu-icon" )
					.removeClass( this.options.icons.submenu )
					.addClass( value.submenu );
			}
			this._super( key, value );
		},
	
		focus: function( event, item ) {
			var nested, focused;
			this.blur( event, event && event.type === "focus" );
	
			this._scrollIntoView( item );
	
			this.active = item.first();
			focused = this.active.children( "a" ).addClass( "ui-state-focus" );
			// Only update aria-activedescendant if there's a role
			// otherwise we assume focus is managed elsewhere
			if ( this.options.role ) {
				this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
			}
	
			// Highlight active parent menu item, if any
			this.active
				.parent()
				.closest( ".ui-menu-item" )
				.children( "a:first" )
				.addClass( "ui-state-active" );
	
			if ( event && event.type === "keydown" ) {
				this._close();
			} else {
				this.timer = this._delay(function() {
					this._close();
				}, this.delay );
			}
	
			nested = item.children( ".ui-menu" );
			if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
				this._startOpening(nested);
			}
			this.activeMenu = item.parent();
	
			this._trigger( "focus", event, { item: item } );
		},
	
		_scrollIntoView: function( item ) {
			var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
			if ( this._hasScroll() ) {
				borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
				paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
				offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
				scroll = this.activeMenu.scrollTop();
				elementHeight = this.activeMenu.height();
				itemHeight = item.height();
	
				if ( offset < 0 ) {
					this.activeMenu.scrollTop( scroll + offset );
				} else if ( offset + itemHeight > elementHeight ) {
					this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
				}
			}
		},
	
		blur: function( event, fromFocus ) {
			if ( !fromFocus ) {
				clearTimeout( this.timer );
			}
	
			if ( !this.active ) {
				return;
			}
	
			this.active.children( "a" ).removeClass( "ui-state-focus" );
			this.active = null;
	
			this._trigger( "blur", event, { item: this.active } );
		},
	
		_startOpening: function( submenu ) {
			clearTimeout( this.timer );
	
			// Don't open if already open fixes a Firefox bug that caused a .5 pixel
			// shift in the submenu position when mousing over the carat icon
			if ( submenu.attr( "aria-hidden" ) !== "true" ) {
				return;
			}
	
			this.timer = this._delay(function() {
				this._close();
				this._open( submenu );
			}, this.delay );
		},
	
		_open: function( submenu ) {
			var position = $.extend({
				of: this.active
			}, this.options.position );
	
			clearTimeout( this.timer );
			this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
				.hide()
				.attr( "aria-hidden", "true" );
	
			submenu
				.show()
				.removeAttr( "aria-hidden" )
				.attr( "aria-expanded", "true" )
				.position( position );
		},
	
		collapseAll: function( event, all ) {
			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				// If we were passed an event, look for the submenu that contains the event
				var currentMenu = all ? this.element :
					$( event && event.target ).closest( this.element.find( ".ui-menu" ) );
	
				// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
				if ( !currentMenu.length ) {
					currentMenu = this.element;
				}
	
				this._close( currentMenu );
	
				this.blur( event );
				this.activeMenu = currentMenu;
			}, this.delay );
		},
	
		// With no arguments, closes the currently active menu - if nothing is active
		// it closes all menus.  If passed an argument, it will search for menus BELOW
		_close: function( startMenu ) {
			if ( !startMenu ) {
				startMenu = this.active ? this.active.parent() : this.element;
			}
	
			startMenu
				.find( ".ui-menu" )
					.hide()
					.attr( "aria-hidden", "true" )
					.attr( "aria-expanded", "false" )
				.end()
				.find( "a.ui-state-active" )
					.removeClass( "ui-state-active" );
		},
	
		collapse: function( event ) {
			var newItem = this.active &&
				this.active.parent().closest( ".ui-menu-item", this.element );
			if ( newItem && newItem.length ) {
				this._close();
				this.focus( event, newItem );
			}
		},
	
		expand: function( event ) {
			var newItem = this.active &&
				this.active
					.children( ".ui-menu " )
					.children( ".ui-menu-item" )
					.first();
	
			if ( newItem && newItem.length ) {
				this._open( newItem.parent() );
	
				// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
				this._delay(function() {
					this.focus( event, newItem );
				});
			}
		},
	
		next: function( event ) {
			this._move( "next", "first", event );
		},
	
		previous: function( event ) {
			this._move( "prev", "last", event );
		},
	
		isFirstItem: function() {
			return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
		},
	
		isLastItem: function() {
			return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
		},
	
		_move: function( direction, filter, event ) {
			var next;
			if ( this.active ) {
				if ( direction === "first" || direction === "last" ) {
					next = this.active
						[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
						.eq( -1 );
				} else {
					next = this.active
						[ direction + "All" ]( ".ui-menu-item" )
						.eq( 0 );
				}
			}
			if ( !next || !next.length || !this.active ) {
				next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
			}
	
			this.focus( event, next );
		},
	
		nextPage: function( event ) {
			var item, base, height;
	
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isLastItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.nextAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base - height < 0;
				});
	
				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.children( ".ui-menu-item" )
					[ !this.active ? "first" : "last" ]() );
			}
		},
	
		previousPage: function( event ) {
			var item, base, height;
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isFirstItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.prevAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base + height > 0;
				});
	
				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
			}
		},
	
		_hasScroll: function() {
			return this.element.outerHeight() < this.element.prop( "scrollHeight" );
		},
	
		select: function( event ) {
			// TODO: It should never be possible to not have an active item at this
			// point, but the tests don't trigger mouseenter before click.
			this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
			var ui = { item: this.active };
			if ( !this.active.has( ".ui-menu" ).length ) {
				this.collapseAll( event, true );
			}
			this._trigger( "select", event, ui );
		}
	});
	
	}( jQuery ));
	
	(function( $, undefined ) {
	
	$.ui = $.ui || {};
	
	var cachedScrollbarWidth,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;
	
	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}
	
	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}
	
	function getDimensions( elem ) {
		var raw = elem[0];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}
	
	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[0];
	
			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );
	
			w2 = innerDiv.offsetWidth;
	
			if ( w1 === w2 ) {
				w2 = div[0].clientWidth;
			}
	
			div.remove();
	
			return (cachedScrollbarWidth = w1 - w2);
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
				overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[0].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[0] );
			return {
				element: withinElement,
				isWindow: isWindow,
				offset: withinElement.offset() || { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
				width: isWindow ? withinElement.width() : withinElement.outerWidth(),
				height: isWindow ? withinElement.height() : withinElement.outerHeight()
			};
		}
	};
	
	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}
	
		// make a copy, we don't want to modify arguments
		options = $.extend( {}, options );
	
		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};
	
		dimensions = getDimensions( target );
		if ( target[0].preventDefault ) {
			// force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;
		// clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );
	
		// force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;
	
			if ( pos.length === 1) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
	
			// calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];
	
			// reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		});
	
		// normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}
	
		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}
	
		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}
	
		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];
	
		return this.each(function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
	
			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}
	
			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}
	
			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];
	
			// if the browser doesn't support fractions, then round for consistent results
			if ( !$.support.offsetFractions ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}
	
			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};
	
			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem : elem
					});
				}
			});
	
			if ( options.using ) {
				// adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}
	
			elem.offset( $.extend( position, { using: using } ) );
		});
	};
	
	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;
	
				// element is wider than within
				if ( data.collisionWidth > outerWidth ) {
					// element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
						position.left += overLeft - newOverRight;
					// element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;
					// element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}
				// too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;
				// too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;
				// adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;
	
				// element is taller than within
				if ( data.collisionHeight > outerHeight ) {
					// element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
						position.top += overTop - newOverBottom;
					// element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;
					// element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}
				// too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;
				// too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;
				// adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;
	
				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				}
				else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
					if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
						position.top += myOffset + atOffset + offset;
					}
				}
				else if ( overBottom > 0 ) {
					newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
					if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};
	
	// fraction support test
	(function () {
		var testElement, testElementParent, testElementStyle, offsetLeft, i,
			body = document.getElementsByTagName( "body" )[ 0 ],
			div = document.createElement( "div" );
	
		//Create a "fake body" for testing based on method used in jQuery.support
		testElement = document.createElement( body ? "div" : "body" );
		testElementStyle = {
			visibility: "hidden",
			width: 0,
			height: 0,
			border: 0,
			margin: 0,
			background: "none"
		};
		if ( body ) {
			$.extend( testElementStyle, {
				position: "absolute",
				left: "-1000px",
				top: "-1000px"
			});
		}
		for ( i in testElementStyle ) {
			testElement.style[ i ] = testElementStyle[ i ];
		}
		testElement.appendChild( div );
		testElementParent = body || document.documentElement;
		testElementParent.insertBefore( testElement, testElementParent.firstChild );
	
		div.style.cssText = "position: absolute; left: 10.7432222px;";
	
		offsetLeft = $( div ).offset().left;
		$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
	
		testElement.innerHTML = "";
		testElementParent.removeChild( testElement );
	})();
	
	}( jQuery ) );
	
	(function( $, undefined ) {
	
	$.widget( "ui.progressbar", {
		version: "1.10.3",
		options: {
			max: 100,
			value: 0,
	
			change: null,
			complete: null
		},
	
		min: 0,
	
		_create: function() {
			// Constrain initial value
			this.oldValue = this.options.value = this._constrainedValue();
	
			this.element
				.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.attr({
					// Only set static values, aria-valuenow and aria-valuemax are
					// set inside _refreshValue()
					role: "progressbar",
					"aria-valuemin": this.min
				});
	
			this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
				.appendTo( this.element );
	
			this._refreshValue();
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );
	
			this.valueDiv.remove();
		},
	
		value: function( newValue ) {
			if ( newValue === undefined ) {
				return this.options.value;
			}
	
			this.options.value = this._constrainedValue( newValue );
			this._refreshValue();
		},
	
		_constrainedValue: function( newValue ) {
			if ( newValue === undefined ) {
				newValue = this.options.value;
			}
	
			this.indeterminate = newValue === false;
	
			// sanitize value
			if ( typeof newValue !== "number" ) {
				newValue = 0;
			}
	
			return this.indeterminate ? false :
				Math.min( this.options.max, Math.max( this.min, newValue ) );
		},
	
		_setOptions: function( options ) {
			// Ensure "value" option is set after other values (like max)
			var value = options.value;
			delete options.value;
	
			this._super( options );
	
			this.options.value = this._constrainedValue( value );
			this._refreshValue();
		},
	
		_setOption: function( key, value ) {
			if ( key === "max" ) {
				// Don't allow a max less than min
				value = Math.max( this.min, value );
			}
	
			this._super( key, value );
		},
	
		_percentage: function() {
			return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
		},
	
		_refreshValue: function() {
			var value = this.options.value,
				percentage = this._percentage();
	
			this.valueDiv
				.toggle( this.indeterminate || value > this.min )
				.toggleClass( "ui-corner-right", value === this.options.max )
				.width( percentage.toFixed(0) + "%" );
	
			this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );
	
			if ( this.indeterminate ) {
				this.element.removeAttr( "aria-valuenow" );
				if ( !this.overlayDiv ) {
					this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
				}
			} else {
				this.element.attr({
					"aria-valuemax": this.options.max,
					"aria-valuenow": value
				});
				if ( this.overlayDiv ) {
					this.overlayDiv.remove();
					this.overlayDiv = null;
				}
			}
	
			if ( this.oldValue !== value ) {
				this.oldValue = value;
				this._trigger( "change" );
			}
			if ( value === this.options.max ) {
				this._trigger( "complete" );
			}
		}
	});
	
	})( jQuery );
	
	(function( $, undefined ) {
	
	// number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	var numPages = 5;
	
	$.widget( "ui.slider", $.ui.mouse, {
		version: "1.10.3",
		widgetEventPrefix: "slide",
	
		options: {
			animate: false,
			distance: 0,
			max: 100,
			min: 0,
			orientation: "horizontal",
			range: false,
			step: 1,
			value: 0,
			values: null,
	
			// callbacks
			change: null,
			slide: null,
			start: null,
			stop: null
		},
	
		_create: function() {
			this._keySliding = false;
			this._mouseSliding = false;
			this._animateOff = true;
			this._handleIndex = null;
			this._detectOrientation();
			this._mouseInit();
	
			this.element
				.addClass( "ui-slider" +
					" ui-slider-" + this.orientation +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all");
	
			this._refresh();
			this._setOption( "disabled", this.options.disabled );
	
			this._animateOff = false;
		},
	
		_refresh: function() {
			this._createRange();
			this._createHandles();
			this._setupEvents();
			this._refreshValue();
		},
	
		_createHandles: function() {
			var i, handleCount,
				options = this.options,
				existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
				handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
				handles = [];
	
			handleCount = ( options.values && options.values.length ) || 1;
	
			if ( existingHandles.length > handleCount ) {
				existingHandles.slice( handleCount ).remove();
				existingHandles = existingHandles.slice( 0, handleCount );
			}
	
			for ( i = existingHandles.length; i < handleCount; i++ ) {
				handles.push( handle );
			}
	
			this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
	
			this.handle = this.handles.eq( 0 );
	
			this.handles.each(function( i ) {
				$( this ).data( "ui-slider-handle-index", i );
			});
		},
	
		_createRange: function() {
			var options = this.options,
				classes = "";
	
			if ( options.range ) {
				if ( options.range === true ) {
					if ( !options.values ) {
						options.values = [ this._valueMin(), this._valueMin() ];
					} else if ( options.values.length && options.values.length !== 2 ) {
						options.values = [ options.values[0], options.values[0] ];
					} else if ( $.isArray( options.values ) ) {
						options.values = options.values.slice(0);
					}
				}
	
				if ( !this.range || !this.range.length ) {
					this.range = $( "<div></div>" )
						.appendTo( this.element );
	
					classes = "ui-slider-range" +
					// note: this isn't the most fittingly semantic framework class for this element,
					// but worked best visually with a variety of themes
					" ui-widget-header ui-corner-all";
				} else {
					this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
						// Handle range switching from true to min/max
						.css({
							"left": "",
							"bottom": ""
						});
				}
	
				this.range.addClass( classes +
					( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
			} else {
				this.range = $([]);
			}
		},
	
		_setupEvents: function() {
			var elements = this.handles.add( this.range ).filter( "a" );
			this._off( elements );
			this._on( elements, this._handleEvents );
			this._hoverable( elements );
			this._focusable( elements );
		},
	
		_destroy: function() {
			this.handles.remove();
			this.range.remove();
	
			this.element
				.removeClass( "ui-slider" +
					" ui-slider-horizontal" +
					" ui-slider-vertical" +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all" );
	
			this._mouseDestroy();
		},
	
		_mouseCapture: function( event ) {
			var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
				that = this,
				o = this.options;
	
			if ( o.disabled ) {
				return false;
			}
	
			this.elementSize = {
				width: this.element.outerWidth(),
				height: this.element.outerHeight()
			};
			this.elementOffset = this.element.offset();
	
			position = { x: event.pageX, y: event.pageY };
			normValue = this._normValueFromMouse( position );
			distance = this._valueMax() - this._valueMin() + 1;
			this.handles.each(function( i ) {
				var thisDistance = Math.abs( normValue - that.values(i) );
				if (( distance > thisDistance ) ||
					( distance === thisDistance &&
						(i === that._lastChangedValue || that.values(i) === o.min ))) {
					distance = thisDistance;
					closestHandle = $( this );
					index = i;
				}
			});
	
			allowed = this._start( event, index );
			if ( allowed === false ) {
				return false;
			}
			this._mouseSliding = true;
	
			this._handleIndex = index;
	
			closestHandle
				.addClass( "ui-state-active" )
				.focus();
	
			offset = closestHandle.offset();
			mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
			this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
				left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
				top: event.pageY - offset.top -
					( closestHandle.height() / 2 ) -
					( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
					( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
					( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
			};
	
			if ( !this.handles.hasClass( "ui-state-hover" ) ) {
				this._slide( event, index, normValue );
			}
			this._animateOff = true;
			return true;
		},
	
		_mouseStart: function() {
			return true;
		},
	
		_mouseDrag: function( event ) {
			var position = { x: event.pageX, y: event.pageY },
				normValue = this._normValueFromMouse( position );
	
			this._slide( event, this._handleIndex, normValue );
	
			return false;
		},
	
		_mouseStop: function( event ) {
			this.handles.removeClass( "ui-state-active" );
			this._mouseSliding = false;
	
			this._stop( event, this._handleIndex );
			this._change( event, this._handleIndex );
	
			this._handleIndex = null;
			this._clickOffset = null;
			this._animateOff = false;
	
			return false;
		},
	
		_detectOrientation: function() {
			this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
		},
	
		_normValueFromMouse: function( position ) {
			var pixelTotal,
				pixelMouse,
				percentMouse,
				valueTotal,
				valueMouse;
	
			if ( this.orientation === "horizontal" ) {
				pixelTotal = this.elementSize.width;
				pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
			} else {
				pixelTotal = this.elementSize.height;
				pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
			}
	
			percentMouse = ( pixelMouse / pixelTotal );
			if ( percentMouse > 1 ) {
				percentMouse = 1;
			}
			if ( percentMouse < 0 ) {
				percentMouse = 0;
			}
			if ( this.orientation === "vertical" ) {
				percentMouse = 1 - percentMouse;
			}
	
			valueTotal = this._valueMax() - this._valueMin();
			valueMouse = this._valueMin() + percentMouse * valueTotal;
	
			return this._trimAlignValue( valueMouse );
		},
	
		_start: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}
			return this._trigger( "start", event, uiHash );
		},
	
		_slide: function( event, index, newVal ) {
			var otherVal,
				newValues,
				allowed;
	
			if ( this.options.values && this.options.values.length ) {
				otherVal = this.values( index ? 0 : 1 );
	
				if ( ( this.options.values.length === 2 && this.options.range === true ) &&
						( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
					) {
					newVal = otherVal;
				}
	
				if ( newVal !== this.values( index ) ) {
					newValues = this.values();
					newValues[ index ] = newVal;
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal,
						values: newValues
					} );
					otherVal = this.values( index ? 0 : 1 );
					if ( allowed !== false ) {
						this.values( index, newVal, true );
					}
				}
			} else {
				if ( newVal !== this.value() ) {
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal
					} );
					if ( allowed !== false ) {
						this.value( newVal );
					}
				}
			}
		},
	
		_stop: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}
	
			this._trigger( "stop", event, uiHash );
		},
	
		_change: function( event, index ) {
			if ( !this._keySliding && !this._mouseSliding ) {
				var uiHash = {
					handle: this.handles[ index ],
					value: this.value()
				};
				if ( this.options.values && this.options.values.length ) {
					uiHash.value = this.values( index );
					uiHash.values = this.values();
				}
	
				//store the last changed value index for reference when handles overlap
				this._lastChangedValue = index;
	
				this._trigger( "change", event, uiHash );
			}
		},
	
		value: function( newValue ) {
			if ( arguments.length ) {
				this.options.value = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, 0 );
				return;
			}
	
			return this._value();
		},
	
		values: function( index, newValue ) {
			var vals,
				newValues,
				i;
	
			if ( arguments.length > 1 ) {
				this.options.values[ index ] = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, index );
				return;
			}
	
			if ( arguments.length ) {
				if ( $.isArray( arguments[ 0 ] ) ) {
					vals = this.options.values;
					newValues = arguments[ 0 ];
					for ( i = 0; i < vals.length; i += 1 ) {
						vals[ i ] = this._trimAlignValue( newValues[ i ] );
						this._change( null, i );
					}
					this._refreshValue();
				} else {
					if ( this.options.values && this.options.values.length ) {
						return this._values( index );
					} else {
						return this.value();
					}
				}
			} else {
				return this._values();
			}
		},
	
		_setOption: function( key, value ) {
			var i,
				valsLength = 0;
	
			if ( key === "range" && this.options.range === true ) {
				if ( value === "min" ) {
					this.options.value = this._values( 0 );
					this.options.values = null;
				} else if ( value === "max" ) {
					this.options.value = this._values( this.options.values.length-1 );
					this.options.values = null;
				}
			}
	
			if ( $.isArray( this.options.values ) ) {
				valsLength = this.options.values.length;
			}
	
			$.Widget.prototype._setOption.apply( this, arguments );
	
			switch ( key ) {
				case "orientation":
					this._detectOrientation();
					this.element
						.removeClass( "ui-slider-horizontal ui-slider-vertical" )
						.addClass( "ui-slider-" + this.orientation );
					this._refreshValue();
					break;
				case "value":
					this._animateOff = true;
					this._refreshValue();
					this._change( null, 0 );
					this._animateOff = false;
					break;
				case "values":
					this._animateOff = true;
					this._refreshValue();
					for ( i = 0; i < valsLength; i += 1 ) {
						this._change( null, i );
					}
					this._animateOff = false;
					break;
				case "min":
				case "max":
					this._animateOff = true;
					this._refreshValue();
					this._animateOff = false;
					break;
				case "range":
					this._animateOff = true;
					this._refresh();
					this._animateOff = false;
					break;
			}
		},
	
		//internal value getter
		// _value() returns value trimmed by min and max, aligned by step
		_value: function() {
			var val = this.options.value;
			val = this._trimAlignValue( val );
	
			return val;
		},
	
		//internal values getter
		// _values() returns array of values trimmed by min and max, aligned by step
		// _values( index ) returns single value trimmed by min and max, aligned by step
		_values: function( index ) {
			var val,
				vals,
				i;
	
			if ( arguments.length ) {
				val = this.options.values[ index ];
				val = this._trimAlignValue( val );
	
				return val;
			} else if ( this.options.values && this.options.values.length ) {
				// .slice() creates a copy of the array
				// this copy gets trimmed by min and max and then returned
				vals = this.options.values.slice();
				for ( i = 0; i < vals.length; i+= 1) {
					vals[ i ] = this._trimAlignValue( vals[ i ] );
				}
	
				return vals;
			} else {
				return [];
			}
		},
	
		// returns the step-aligned value that val is closest to, between (inclusive) min and max
		_trimAlignValue: function( val ) {
			if ( val <= this._valueMin() ) {
				return this._valueMin();
			}
			if ( val >= this._valueMax() ) {
				return this._valueMax();
			}
			var step = ( this.options.step > 0 ) ? this.options.step : 1,
				valModStep = (val - this._valueMin()) % step,
				alignValue = val - valModStep;
	
			if ( Math.abs(valModStep) * 2 >= step ) {
				alignValue += ( valModStep > 0 ) ? step : ( -step );
			}
	
			// Since JavaScript has problems with large floats, round
			// the final value to 5 digits after the decimal point (see #4124)
			return parseFloat( alignValue.toFixed(5) );
		},
	
		_valueMin: function() {
			return this.options.min;
		},
	
		_valueMax: function() {
			return this.options.max;
		},
	
		_refreshValue: function() {
			var lastValPercent, valPercent, value, valueMin, valueMax,
				oRange = this.options.range,
				o = this.options,
				that = this,
				animate = ( !this._animateOff ) ? o.animate : false,
				_set = {};
	
			if ( this.options.values && this.options.values.length ) {
				this.handles.each(function( i ) {
					valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
					_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
					$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
					if ( that.options.range === true ) {
						if ( that.orientation === "horizontal" ) {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						} else {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						}
					}
					lastValPercent = valPercent;
				});
			} else {
				value = this.value();
				valueMin = this._valueMin();
				valueMax = this._valueMax();
				valPercent = ( valueMax !== valueMin ) ?
						( value - valueMin ) / ( valueMax - valueMin ) * 100 :
						0;
				_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
	
				if ( oRange === "min" && this.orientation === "horizontal" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "horizontal" ) {
					this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
				if ( oRange === "min" && this.orientation === "vertical" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "vertical" ) {
					this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
			}
		},
	
		_handleEvents: {
			keydown: function( event ) {
				/*jshint maxcomplexity:25*/
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}
	
				this._slide( event, index, newVal );
			},
			click: function( event ) {
				event.preventDefault();
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );
	
				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		}
	
	});
	
	}(jQuery));
	
	(function( $ ) {
	
	function modifier( fn ) {
		return function() {
			var previous = this.element.val();
			fn.apply( this, arguments );
			this._refresh();
			if ( previous !== this.element.val() ) {
				this._trigger( "change" );
			}
		};
	}
	
	$.widget( "ui.spinner", {
		version: "1.10.3",
		defaultElement: "<input>",
		widgetEventPrefix: "spin",
		options: {
			culture: null,
			icons: {
				down: "ui-icon-triangle-1-s",
				up: "ui-icon-triangle-1-n"
			},
			incremental: true,
			max: null,
			min: null,
			numberFormat: null,
			page: 10,
			step: 1,
	
			change: null,
			spin: null,
			start: null,
			stop: null
		},
	
		_create: function() {
			// handle string values that need to be parsed
			this._setOption( "max", this.options.max );
			this._setOption( "min", this.options.min );
			this._setOption( "step", this.options.step );
	
			// format the value, but don't constrain
			this._value( this.element.val(), true );
	
			this._draw();
			this._on( this._events );
			this._refresh();
	
			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},
	
		_getCreateOptions: function() {
			var options = {},
				element = this.element;
	
			$.each( [ "min", "max", "step" ], function( i, option ) {
				var value = element.attr( option );
				if ( value !== undefined && value.length ) {
					options[ option ] = value;
				}
			});
	
			return options;
		},
	
		_events: {
			keydown: function( event ) {
				if ( this._start( event ) && this._keydown( event ) ) {
					event.preventDefault();
				}
			},
			keyup: "_stop",
			focus: function() {
				this.previous = this.element.val();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}
	
				this._stop();
				this._refresh();
				if ( this.previous !== this.element.val() ) {
					this._trigger( "change", event );
				}
			},
			mousewheel: function( event, delta ) {
				if ( !delta ) {
					return;
				}
				if ( !this.spinning && !this._start( event ) ) {
					return false;
				}
	
				this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
				clearTimeout( this.mousewheelTimer );
				this.mousewheelTimer = this._delay(function() {
					if ( this.spinning ) {
						this._stop( event );
					}
				}, 100 );
				event.preventDefault();
			},
			"mousedown .ui-spinner-button": function( event ) {
				var previous;
	
				// We never want the buttons to have focus; whenever the user is
				// interacting with the spinner, the focus should be on the input.
				// If the input is focused then this.previous is properly set from
				// when the input first received focus. If the input is not focused
				// then we need to set this.previous based on the value before spinning.
				previous = this.element[0] === this.document[0].activeElement ?
					this.previous : this.element.val();
				function checkFocus() {
					var isActive = this.element[0] === this.document[0].activeElement;
					if ( !isActive ) {
						this.element.focus();
						this.previous = previous;
						// support: IE
						// IE sets focus asynchronously, so we need to check if focus
						// moved off of the input because the user clicked on the button.
						this._delay(function() {
							this.previous = previous;
						});
					}
				}
	
				// ensure focus is on (or stays on) the text field
				event.preventDefault();
				checkFocus.call( this );
	
				// support: IE
				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				// and check (again) if focus moved off of the input.
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
					checkFocus.call( this );
				});
	
				if ( this._start( event ) === false ) {
					return;
				}
	
				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			"mouseup .ui-spinner-button": "_stop",
			"mouseenter .ui-spinner-button": function( event ) {
				// button will add ui-state-active if mouse was down while mouseleave and kept down
				if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
					return;
				}
	
				if ( this._start( event ) === false ) {
					return false;
				}
				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			// TODO: do we really want to consider this a stop?
			// shouldn't we just stop the repeater and wait until mouseup before
			// we trigger the stop event?
			"mouseleave .ui-spinner-button": "_stop"
		},
	
		_draw: function() {
			var uiSpinner = this.uiSpinner = this.element
				.addClass( "ui-spinner-input" )
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()
					// add buttons
					.append( this._buttonHtml() );
	
			this.element.attr( "role", "spinbutton" );
	
			// button bindings
			this.buttons = uiSpinner.find( ".ui-spinner-button" )
				.attr( "tabIndex", -1 )
				.button()
				.removeClass( "ui-corner-all" );
	
			// IE 6 doesn't understand height: 50% for the buttons
			// unless the wrapper has an explicit height
			if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
					uiSpinner.height() > 0 ) {
				uiSpinner.height( uiSpinner.height() );
			}
	
			// disable spinner if element was already disabled
			if ( this.options.disabled ) {
				this.disable();
			}
		},
	
		_keydown: function( event ) {
			var options = this.options,
				keyCode = $.ui.keyCode;
	
			switch ( event.keyCode ) {
			case keyCode.UP:
				this._repeat( null, 1, event );
				return true;
			case keyCode.DOWN:
				this._repeat( null, -1, event );
				return true;
			case keyCode.PAGE_UP:
				this._repeat( null, options.page, event );
				return true;
			case keyCode.PAGE_DOWN:
				this._repeat( null, -options.page, event );
				return true;
			}
	
			return false;
		},
	
		_uiSpinnerHtml: function() {
			return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
		},
	
		_buttonHtml: function() {
			return "" +
				"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
					"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
				"</a>" +
				"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
					"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
				"</a>";
		},
	
		_start: function( event ) {
			if ( !this.spinning && this._trigger( "start", event ) === false ) {
				return false;
			}
	
			if ( !this.counter ) {
				this.counter = 1;
			}
			this.spinning = true;
			return true;
		},
	
		_repeat: function( i, steps, event ) {
			i = i || 500;
	
			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				this._repeat( 40, steps, event );
			}, i );
	
			this._spin( steps * this.options.step, event );
		},
	
		_spin: function( step, event ) {
			var value = this.value() || 0;
	
			if ( !this.counter ) {
				this.counter = 1;
			}
	
			value = this._adjustValue( value + step * this._increment( this.counter ) );
	
			if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
				this._value( value );
				this.counter++;
			}
		},
	
		_increment: function( i ) {
			var incremental = this.options.incremental;
	
			if ( incremental ) {
				return $.isFunction( incremental ) ?
					incremental( i ) :
					Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
			}
	
			return 1;
		},
	
		_precision: function() {
			var precision = this._precisionOf( this.options.step );
			if ( this.options.min !== null ) {
				precision = Math.max( precision, this._precisionOf( this.options.min ) );
			}
			return precision;
		},
	
		_precisionOf: function( num ) {
			var str = num.toString(),
				decimal = str.indexOf( "." );
			return decimal === -1 ? 0 : str.length - decimal - 1;
		},
	
		_adjustValue: function( value ) {
			var base, aboveMin,
				options = this.options;
	
			// make sure we're at a valid step
			// - find out where we are relative to the base (min or 0)
			base = options.min !== null ? options.min : 0;
			aboveMin = value - base;
			// - round to the nearest step
			aboveMin = Math.round(aboveMin / options.step) * options.step;
			// - rounding is based on 0, so adjust back to our base
			value = base + aboveMin;
	
			// fix precision from bad JS floating point math
			value = parseFloat( value.toFixed( this._precision() ) );
	
			// clamp the value
			if ( options.max !== null && value > options.max) {
				return options.max;
			}
			if ( options.min !== null && value < options.min ) {
				return options.min;
			}
	
			return value;
		},
	
		_stop: function( event ) {
			if ( !this.spinning ) {
				return;
			}
	
			clearTimeout( this.timer );
			clearTimeout( this.mousewheelTimer );
			this.counter = 0;
			this.spinning = false;
			this._trigger( "stop", event );
		},
	
		_setOption: function( key, value ) {
			if ( key === "culture" || key === "numberFormat" ) {
				var prevValue = this._parse( this.element.val() );
				this.options[ key ] = value;
				this.element.val( this._format( prevValue ) );
				return;
			}
	
			if ( key === "max" || key === "min" || key === "step" ) {
				if ( typeof value === "string" ) {
					value = this._parse( value );
				}
			}
			if ( key === "icons" ) {
				this.buttons.first().find( ".ui-icon" )
					.removeClass( this.options.icons.up )
					.addClass( value.up );
				this.buttons.last().find( ".ui-icon" )
					.removeClass( this.options.icons.down )
					.addClass( value.down );
			}
	
			this._super( key, value );
	
			if ( key === "disabled" ) {
				if ( value ) {
					this.element.prop( "disabled", true );
					this.buttons.button( "disable" );
				} else {
					this.element.prop( "disabled", false );
					this.buttons.button( "enable" );
				}
			}
		},
	
		_setOptions: modifier(function( options ) {
			this._super( options );
			this._value( this.element.val() );
		}),
	
		_parse: function( val ) {
			if ( typeof val === "string" && val !== "" ) {
				val = window.Globalize && this.options.numberFormat ?
					Globalize.parseFloat( val, 10, this.options.culture ) : +val;
			}
			return val === "" || isNaN( val ) ? null : val;
		},
	
		_format: function( value ) {
			if ( value === "" ) {
				return "";
			}
			return window.Globalize && this.options.numberFormat ?
				Globalize.format( value, this.options.numberFormat, this.options.culture ) :
				value;
		},
	
		_refresh: function() {
			this.element.attr({
				"aria-valuemin": this.options.min,
				"aria-valuemax": this.options.max,
				// TODO: what should we do with values that can't be parsed?
				"aria-valuenow": this._parse( this.element.val() )
			});
		},
	
		// update the value without triggering change
		_value: function( value, allowAny ) {
			var parsed;
			if ( value !== "" ) {
				parsed = this._parse( value );
				if ( parsed !== null ) {
					if ( !allowAny ) {
						parsed = this._adjustValue( parsed );
					}
					value = this._format( parsed );
				}
			}
			this.element.val( value );
			this._refresh();
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-spinner-input" )
				.prop( "disabled", false )
				.removeAttr( "autocomplete" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );
			this.uiSpinner.replaceWith( this.element );
		},
	
		stepUp: modifier(function( steps ) {
			this._stepUp( steps );
		}),
		_stepUp: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * this.options.step );
				this._stop();
			}
		},
	
		stepDown: modifier(function( steps ) {
			this._stepDown( steps );
		}),
		_stepDown: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * -this.options.step );
				this._stop();
			}
		},
	
		pageUp: modifier(function( pages ) {
			this._stepUp( (pages || 1) * this.options.page );
		}),
	
		pageDown: modifier(function( pages ) {
			this._stepDown( (pages || 1) * this.options.page );
		}),
	
		value: function( newVal ) {
			if ( !arguments.length ) {
				return this._parse( this.element.val() );
			}
			modifier( this._value ).call( this, newVal );
		},
	
		widget: function() {
			return this.uiSpinner;
		}
	});
	
	}( jQuery ) );
	
	(function( $, undefined ) {
	
	var tabId = 0,
		rhash = /#.*$/;
	
	function getNextTabId() {
		return ++tabId;
	}
	
	function isLocal( anchor ) {
		return anchor.hash.length > 1 &&
			decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
				decodeURIComponent( location.href.replace( rhash, "" ) );
	}
	
	$.widget( "ui.tabs", {
		version: "1.10.3",
		delay: 300,
		options: {
			active: null,
			collapsible: false,
			event: "click",
			heightStyle: "content",
			hide: null,
			show: null,
	
			// callbacks
			activate: null,
			beforeActivate: null,
			beforeLoad: null,
			load: null
		},
	
		_create: function() {
			var that = this,
				options = this.options;
	
			this.running = false;
	
			this.element
				.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
				.toggleClass( "ui-tabs-collapsible", options.collapsible )
				// Prevent users from focusing disabled tabs via click
				.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
					if ( $( this ).is( ".ui-state-disabled" ) ) {
						event.preventDefault();
					}
				})
				// support: IE <9
				// Preventing the default action in mousedown doesn't prevent IE
				// from focusing the element, so if the anchor gets focused, blur.
				// We don't have to worry about focusing the previously focused
				// element since clicking on a non-focusable element should focus
				// the body anyway.
				.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
					if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
						this.blur();
					}
				});
	
			this._processTabs();
			options.active = this._initialActive();
	
			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			if ( $.isArray( options.disabled ) ) {
				options.disabled = $.unique( options.disabled.concat(
					$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
						return that.tabs.index( li );
					})
				) ).sort();
			}
	
			// check for length avoids error when initializing empty list
			if ( this.options.active !== false && this.anchors.length ) {
				this.active = this._findActive( options.active );
			} else {
				this.active = $();
			}
	
			this._refresh();
	
			if ( this.active.length ) {
				this.load( options.active );
			}
		},
	
		_initialActive: function() {
			var active = this.options.active,
				collapsible = this.options.collapsible,
				locationHash = location.hash.substring( 1 );
	
			if ( active === null ) {
				// check the fragment identifier in the URL
				if ( locationHash ) {
					this.tabs.each(function( i, tab ) {
						if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
							active = i;
							return false;
						}
					});
				}
	
				// check for a tab marked active via a class
				if ( active === null ) {
					active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
				}
	
				// no active tab, set to false
				if ( active === null || active === -1 ) {
					active = this.tabs.length ? 0 : false;
				}
			}
	
			// handle numbers: negative, out of range
			if ( active !== false ) {
				active = this.tabs.index( this.tabs.eq( active ) );
				if ( active === -1 ) {
					active = collapsible ? false : 0;
				}
			}
	
			// don't allow collapsible: false and active: false
			if ( !collapsible && active === false && this.anchors.length ) {
				active = 0;
			}
	
			return active;
		},
	
		_getCreateEventData: function() {
			return {
				tab: this.active,
				panel: !this.active.length ? $() : this._getPanelForTab( this.active )
			};
		},
	
		_tabKeydown: function( event ) {
			/*jshint maxcomplexity:15*/
			var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
				selectedIndex = this.tabs.index( focusedTab ),
				goingForward = true;
	
			if ( this._handlePageNav( event ) ) {
				return;
			}
	
			switch ( event.keyCode ) {
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
					selectedIndex++;
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.LEFT:
					goingForward = false;
					selectedIndex--;
					break;
				case $.ui.keyCode.END:
					selectedIndex = this.anchors.length - 1;
					break;
				case $.ui.keyCode.HOME:
					selectedIndex = 0;
					break;
				case $.ui.keyCode.SPACE:
					// Activate only, no collapsing
					event.preventDefault();
					clearTimeout( this.activating );
					this._activate( selectedIndex );
					return;
				case $.ui.keyCode.ENTER:
					// Toggle (cancel delayed activation, allow collapsing)
					event.preventDefault();
					clearTimeout( this.activating );
					// Determine if we should collapse or activate
					this._activate( selectedIndex === this.options.active ? false : selectedIndex );
					return;
				default:
					return;
			}
	
			// Focus the appropriate tab, based on which key was pressed
			event.preventDefault();
			clearTimeout( this.activating );
			selectedIndex = this._focusNextTab( selectedIndex, goingForward );
	
			// Navigating with control key will prevent automatic activation
			if ( !event.ctrlKey ) {
				// Update aria-selected immediately so that AT think the tab is already selected.
				// Otherwise AT may confuse the user by stating that they need to activate the tab,
				// but the tab will already be activated by the time the announcement finishes.
				focusedTab.attr( "aria-selected", "false" );
				this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );
	
				this.activating = this._delay(function() {
					this.option( "active", selectedIndex );
				}, this.delay );
			}
		},
	
		_panelKeydown: function( event ) {
			if ( this._handlePageNav( event ) ) {
				return;
			}
	
			// Ctrl+up moves focus to the current tab
			if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
				event.preventDefault();
				this.active.focus();
			}
		},
	
		// Alt+page up/down moves focus to the previous/next tab (and activates)
		_handlePageNav: function( event ) {
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
				this._activate( this._focusNextTab( this.options.active - 1, false ) );
				return true;
			}
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
				this._activate( this._focusNextTab( this.options.active + 1, true ) );
				return true;
			}
		},
	
		_findNextTab: function( index, goingForward ) {
			var lastTabIndex = this.tabs.length - 1;
	
			function constrain() {
				if ( index > lastTabIndex ) {
					index = 0;
				}
				if ( index < 0 ) {
					index = lastTabIndex;
				}
				return index;
			}
	
			while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
				index = goingForward ? index + 1 : index - 1;
			}
	
			return index;
		},
	
		_focusNextTab: function( index, goingForward ) {
			index = this._findNextTab( index, goingForward );
			this.tabs.eq( index ).focus();
			return index;
		},
	
		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}
	
			if ( key === "disabled" ) {
				// don't use the widget factory's disabled handling
				this._setupDisabled( value );
				return;
			}
	
			this._super( key, value);
	
			if ( key === "collapsible" ) {
				this.element.toggleClass( "ui-tabs-collapsible", value );
				// Setting collapsible: false while collapsed; open first panel
				if ( !value && this.options.active === false ) {
					this._activate( 0 );
				}
			}
	
			if ( key === "event" ) {
				this._setupEvents( value );
			}
	
			if ( key === "heightStyle" ) {
				this._setupHeightStyle( value );
			}
		},
	
		_tabId: function( tab ) {
			return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
		},
	
		_sanitizeSelector: function( hash ) {
			return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
		},
	
		refresh: function() {
			var options = this.options,
				lis = this.tablist.children( ":has(a[href])" );
	
			// get disabled tabs from class attribute from HTML
			// this will get converted to a boolean if needed in _refresh()
			options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
				return lis.index( tab );
			});
	
			this._processTabs();
	
			// was collapsed or no tabs
			if ( options.active === false || !this.anchors.length ) {
				options.active = false;
				this.active = $();
			// was active, but active tab is gone
			} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
				// all remaining tabs are disabled
				if ( this.tabs.length === options.disabled.length ) {
					options.active = false;
					this.active = $();
				// activate previous tab
				} else {
					this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
				}
			// was active, active tab still exists
			} else {
				// make sure active index is correct
				options.active = this.tabs.index( this.active );
			}
	
			this._refresh();
		},
	
		_refresh: function() {
			this._setupDisabled( this.options.disabled );
			this._setupEvents( this.options.event );
			this._setupHeightStyle( this.options.heightStyle );
	
			this.tabs.not( this.active ).attr({
				"aria-selected": "false",
				tabIndex: -1
			});
			this.panels.not( this._getPanelForTab( this.active ) )
				.hide()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				});
	
			// Make sure one tab is in the tab order
			if ( !this.active.length ) {
				this.tabs.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active
					.addClass( "ui-tabs-active ui-state-active" )
					.attr({
						"aria-selected": "true",
						tabIndex: 0
					});
				this._getPanelForTab( this.active )
					.show()
					.attr({
						"aria-expanded": "true",
						"aria-hidden": "false"
					});
			}
		},
	
		_processTabs: function() {
			var that = this;
	
			this.tablist = this._getList()
				.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.attr( "role", "tablist" );
	
			this.tabs = this.tablist.find( "> li:has(a[href])" )
				.addClass( "ui-state-default ui-corner-top" )
				.attr({
					role: "tab",
					tabIndex: -1
				});
	
			this.anchors = this.tabs.map(function() {
					return $( "a", this )[ 0 ];
				})
				.addClass( "ui-tabs-anchor" )
				.attr({
					role: "presentation",
					tabIndex: -1
				});
	
			this.panels = $();
	
			this.anchors.each(function( i, anchor ) {
				var selector, panel, panelId,
					anchorId = $( anchor ).uniqueId().attr( "id" ),
					tab = $( anchor ).closest( "li" ),
					originalAriaControls = tab.attr( "aria-controls" );
	
				// inline tab
				if ( isLocal( anchor ) ) {
					selector = anchor.hash;
					panel = that.element.find( that._sanitizeSelector( selector ) );
				// remote tab
				} else {
					panelId = that._tabId( tab );
					selector = "#" + panelId;
					panel = that.element.find( selector );
					if ( !panel.length ) {
						panel = that._createPanel( panelId );
						panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
					}
					panel.attr( "aria-live", "polite" );
				}
	
				if ( panel.length) {
					that.panels = that.panels.add( panel );
				}
				if ( originalAriaControls ) {
					tab.data( "ui-tabs-aria-controls", originalAriaControls );
				}
				tab.attr({
					"aria-controls": selector.substring( 1 ),
					"aria-labelledby": anchorId
				});
				panel.attr( "aria-labelledby", anchorId );
			});
	
			this.panels
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.attr( "role", "tabpanel" );
		},
	
		// allow overriding how to find the list for rare usage scenarios (#7715)
		_getList: function() {
			return this.element.find( "ol,ul" ).eq( 0 );
		},
	
		_createPanel: function( id ) {
			return $( "<div>" )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		},
	
		_setupDisabled: function( disabled ) {
			if ( $.isArray( disabled ) ) {
				if ( !disabled.length ) {
					disabled = false;
				} else if ( disabled.length === this.anchors.length ) {
					disabled = true;
				}
			}
	
			// disable tabs
			for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
				if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
					$( li )
						.addClass( "ui-state-disabled" )
						.attr( "aria-disabled", "true" );
				} else {
					$( li )
						.removeClass( "ui-state-disabled" )
						.removeAttr( "aria-disabled" );
				}
			}
	
			this.options.disabled = disabled;
		},
	
		_setupEvents: function( event ) {
			var events = {
				click: function( event ) {
					event.preventDefault();
				}
			};
			if ( event ) {
				$.each( event.split(" "), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}
	
			this._off( this.anchors.add( this.tabs ).add( this.panels ) );
			this._on( this.anchors, events );
			this._on( this.tabs, { keydown: "_tabKeydown" } );
			this._on( this.panels, { keydown: "_panelKeydown" } );
	
			this._focusable( this.tabs );
			this._hoverable( this.tabs );
		},
	
		_setupHeightStyle: function( heightStyle ) {
			var maxHeight,
				parent = this.element.parent();
	
			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				maxHeight -= this.element.outerHeight() - this.element.height();
	
				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );
	
					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});
	
				this.element.children().not( this.panels ).each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});
	
				this.panels.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.panels.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				}).height( maxHeight );
			}
		},
	
		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				anchor = $( event.currentTarget ),
				tab = anchor.closest( "li" ),
				clickedIsActive = tab[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : this._getPanelForTab( tab ),
				toHide = !active.length ? $() : this._getPanelForTab( active ),
				eventData = {
					oldTab: active,
					oldPanel: toHide,
					newTab: collapsing ? $() : tab,
					newPanel: toShow
				};
	
			event.preventDefault();
	
			if ( tab.hasClass( "ui-state-disabled" ) ||
					// tab is already loading
					tab.hasClass( "ui-tabs-loading" ) ||
					// can't switch durning an animation
					this.running ||
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}
	
			options.active = collapsing ? false : this.tabs.index( tab );
	
			this.active = clickedIsActive ? $() : tab;
			if ( this.xhr ) {
				this.xhr.abort();
			}
	
			if ( !toHide.length && !toShow.length ) {
				$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
			}
	
			if ( toShow.length ) {
				this.load( this.tabs.index( tab ), event );
			}
			this._toggle( event, eventData );
		},
	
		// handles show/hide for selecting tabs
		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel;
	
			this.running = true;
	
			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}
	
			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );
	
				if ( toShow.length && that.options.show ) {
					that._show( toShow, that.options.show, complete );
				} else {
					toShow.show();
					complete();
				}
			}
	
			// start out by hiding, then showing, then completing
			if ( toHide.length && this.options.hide ) {
				this._hide( toHide, this.options.hide, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
	
			toHide.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});
			eventData.oldTab.attr( "aria-selected", "false" );
			// If we're switching tabs, remove the old tab from the tab order.
			// If we're opening from collapsed state, remove the previous tab from the tab order.
			// If we're collapsing, then keep the collapsing tab in the tab order.
			if ( toShow.length && toHide.length ) {
				eventData.oldTab.attr( "tabIndex", -1 );
			} else if ( toShow.length ) {
				this.tabs.filter(function() {
					return $( this ).attr( "tabIndex" ) === 0;
				})
				.attr( "tabIndex", -1 );
			}
	
			toShow.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			});
			eventData.newTab.attr({
				"aria-selected": "true",
				tabIndex: 0
			});
		},
	
		_activate: function( index ) {
			var anchor,
				active = this._findActive( index );
	
			// trying to activate the already active panel
			if ( active[ 0 ] === this.active[ 0 ] ) {
				return;
			}
	
			// trying to collapse, simulate a click on the current active header
			if ( !active.length ) {
				active = this.active;
			}
	
			anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
			this._eventHandler({
				target: anchor,
				currentTarget: anchor,
				preventDefault: $.noop
			});
		},
	
		_findActive: function( index ) {
			return index === false ? $() : this.tabs.eq( index );
		},
	
		_getIndex: function( index ) {
			// meta-function to give users option to provide a href string instead of a numerical index.
			if ( typeof index === "string" ) {
				index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
			}
	
			return index;
		},
	
		_destroy: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
	
			this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );
	
			this.tablist
				.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.removeAttr( "role" );
	
			this.anchors
				.removeClass( "ui-tabs-anchor" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeUniqueId();
	
			this.tabs.add( this.panels ).each(function() {
				if ( $.data( this, "ui-tabs-destroy" ) ) {
					$( this ).remove();
				} else {
					$( this )
						.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
							"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
						.removeAttr( "tabIndex" )
						.removeAttr( "aria-live" )
						.removeAttr( "aria-busy" )
						.removeAttr( "aria-selected" )
						.removeAttr( "aria-labelledby" )
						.removeAttr( "aria-hidden" )
						.removeAttr( "aria-expanded" )
						.removeAttr( "role" );
				}
			});
	
			this.tabs.each(function() {
				var li = $( this ),
					prev = li.data( "ui-tabs-aria-controls" );
				if ( prev ) {
					li
						.attr( "aria-controls", prev )
						.removeData( "ui-tabs-aria-controls" );
				} else {
					li.removeAttr( "aria-controls" );
				}
			});
	
			this.panels.show();
	
			if ( this.options.heightStyle !== "content" ) {
				this.panels.css( "height", "" );
			}
		},
	
		enable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === false ) {
				return;
			}
	
			if ( index === undefined ) {
				disabled = false;
			} else {
				index = this._getIndex( index );
				if ( $.isArray( disabled ) ) {
					disabled = $.map( disabled, function( num ) {
						return num !== index ? num : null;
					});
				} else {
					disabled = $.map( this.tabs, function( li, num ) {
						return num !== index ? num : null;
					});
				}
			}
			this._setupDisabled( disabled );
		},
	
		disable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === true ) {
				return;
			}
	
			if ( index === undefined ) {
				disabled = true;
			} else {
				index = this._getIndex( index );
				if ( $.inArray( index, disabled ) !== -1 ) {
					return;
				}
				if ( $.isArray( disabled ) ) {
					disabled = $.merge( [ index ], disabled ).sort();
				} else {
					disabled = [ index ];
				}
			}
			this._setupDisabled( disabled );
		},
	
		load: function( index, event ) {
			index = this._getIndex( index );
			var that = this,
				tab = this.tabs.eq( index ),
				anchor = tab.find( ".ui-tabs-anchor" ),
				panel = this._getPanelForTab( tab ),
				eventData = {
					tab: tab,
					panel: panel
				};
	
			// not remote
			if ( isLocal( anchor[ 0 ] ) ) {
				return;
			}
	
			this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );
	
			// support: jQuery <1.8
			// jQuery <1.8 returns false if the request is canceled in beforeSend,
			// but as of 1.8, $.ajax() always returns a jqXHR object.
			if ( this.xhr && this.xhr.statusText !== "canceled" ) {
				tab.addClass( "ui-tabs-loading" );
				panel.attr( "aria-busy", "true" );
	
				this.xhr
					.success(function( response ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							panel.html( response );
							that._trigger( "load", event, eventData );
						}, 1 );
					})
					.complete(function( jqXHR, status ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							if ( status === "abort" ) {
								that.panels.stop( false, true );
							}
	
							tab.removeClass( "ui-tabs-loading" );
							panel.removeAttr( "aria-busy" );
	
							if ( jqXHR === that.xhr ) {
								delete that.xhr;
							}
						}, 1 );
					});
			}
		},
	
		_ajaxSettings: function( anchor, event, eventData ) {
			var that = this;
			return {
				url: anchor.attr( "href" ),
				beforeSend: function( jqXHR, settings ) {
					return that._trigger( "beforeLoad", event,
						$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
				}
			};
		},
	
		_getPanelForTab: function( tab ) {
			var id = $( tab ).attr( "aria-controls" );
			return this.element.find( this._sanitizeSelector( "#" + id ) );
		}
	});
	
	})( jQuery );
	
	(function( $ ) {
	
	var increments = 0;
	
	function addDescribedBy( elem, id ) {
		var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	}
	
	function removeDescribedBy( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
			index = $.inArray( id, describedby );
		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}
	
		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	}
	
	$.widget( "ui.tooltip", {
		version: "1.10.3",
		options: {
			content: function() {
				// support: IE<9, Opera in jQuery <1.7
				// .text() can't accept undefined, so coerce to a string
				var title = $( this ).attr( "title" ) || "";
				// Escape title, since we're going from an attribute to raw HTML
				return $( "<a>" ).text( title ).html();
			},
			hide: true,
			// Disabled elements have inconsistent behavior across browsers (#8661)
			items: "[title]:not([disabled])",
			position: {
				my: "left top+15",
				at: "left bottom",
				collision: "flipfit flip"
			},
			show: true,
			tooltipClass: null,
			track: false,
	
			// callbacks
			close: null,
			open: null
		},
	
		_create: function() {
			this._on({
				mouseover: "open",
				focusin: "open"
			});
	
			// IDs of generated tooltips, needed for destroy
			this.tooltips = {};
			// IDs of parent tooltips where we removed the title attribute
			this.parents = {};
	
			if ( this.options.disabled ) {
				this._disable();
			}
		},
	
		_setOption: function( key, value ) {
			var that = this;
	
			if ( key === "disabled" ) {
				this[ value ? "_disable" : "_enable" ]();
				this.options[ key ] = value;
				// disable element style changes
				return;
			}
	
			this._super( key, value );
	
			if ( key === "content" ) {
				$.each( this.tooltips, function( id, element ) {
					that._updateContent( element );
				});
			}
		},
	
		_disable: function() {
			var that = this;
	
			// close open tooltips
			$.each( this.tooltips, function( id, element ) {
				var event = $.Event( "blur" );
				event.target = event.currentTarget = element[0];
				that.close( event, true );
			});
	
			// remove title attributes to prevent native tooltips
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.is( "[title]" ) ) {
					element
						.data( "ui-tooltip-title", element.attr( "title" ) )
						.attr( "title", "" );
				}
			});
		},
	
		_enable: function() {
			// restore title attributes
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
			});
		},
	
		open: function( event ) {
			var that = this,
				target = $( event ? event.target : this.element )
					// we need closest here due to mouseover bubbling,
					// but always pointing at the same event target
					.closest( this.options.items );
	
			// No element to show a tooltip for or the tooltip is already open
			if ( !target.length || target.data( "ui-tooltip-id" ) ) {
				return;
			}
	
			if ( target.attr( "title" ) ) {
				target.data( "ui-tooltip-title", target.attr( "title" ) );
			}
	
			target.data( "ui-tooltip-open", true );
	
			// kill parent tooltips, custom or native, for hover
			if ( event && event.type === "mouseover" ) {
				target.parents().each(function() {
					var parent = $( this ),
						blurEvent;
					if ( parent.data( "ui-tooltip-open" ) ) {
						blurEvent = $.Event( "blur" );
						blurEvent.target = blurEvent.currentTarget = this;
						that.close( blurEvent, true );
					}
					if ( parent.attr( "title" ) ) {
						parent.uniqueId();
						that.parents[ this.id ] = {
							element: this,
							title: parent.attr( "title" )
						};
						parent.attr( "title", "" );
					}
				});
			}
	
			this._updateContent( target, event );
		},
	
		_updateContent: function( target, event ) {
			var content,
				contentOption = this.options.content,
				that = this,
				eventType = event ? event.type : null;
	
			if ( typeof contentOption === "string" ) {
				return this._open( event, target, contentOption );
			}
	
			content = contentOption.call( target[0], function( response ) {
				// ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}
				// IE may instantly serve a cached response for ajax requests
				// delay this call to _open so the other call to _open runs first
				that._delay(function() {
					// jQuery creates a special event for focusin when it doesn't
					// exist natively. To improve performance, the native event
					// object is reused and the type is changed. Therefore, we can't
					// rely on the type being correct after the event finished
					// bubbling, so we set it back to the previous value. (#8740)
					if ( event ) {
						event.type = eventType;
					}
					this._open( event, target, response );
				});
			});
			if ( content ) {
				this._open( event, target, content );
			}
		},
	
		_open: function( event, target, content ) {
			var tooltip, events, delayedShow,
				positionOption = $.extend( {}, this.options.position );
	
			if ( !content ) {
				return;
			}
	
			// Content can be updated multiple times. If the tooltip already
			// exists, then just update the content and bail.
			tooltip = this._find( target );
			if ( tooltip.length ) {
				tooltip.find( ".ui-tooltip-content" ).html( content );
				return;
			}
	
			// if we have a title, clear it to prevent the native tooltip
			// we have to check first to avoid defining a title if none exists
			// (we don't want to cause an element to start matching [title])
			//
			// We use removeAttr only for key events, to allow IE to export the correct
			// accessible attributes. For mouse events, set to empty string to avoid
			// native tooltip showing up (happens only when removing inside mouseover).
			if ( target.is( "[title]" ) ) {
				if ( event && event.type === "mouseover" ) {
					target.attr( "title", "" );
				} else {
					target.removeAttr( "title" );
				}
			}
	
			tooltip = this._tooltip( target );
			addDescribedBy( target, tooltip.attr( "id" ) );
			tooltip.find( ".ui-tooltip-content" ).html( content );
	
			function position( event ) {
				positionOption.of = event;
				if ( tooltip.is( ":hidden" ) ) {
					return;
				}
				tooltip.position( positionOption );
			}
			if ( this.options.track && event && /^mouse/.test( event.type ) ) {
				this._on( this.document, {
					mousemove: position
				});
				// trigger once to override element-relative positioning
				position( event );
			} else {
				tooltip.position( $.extend({
					of: target
				}, this.options.position ) );
			}
	
			tooltip.hide();
	
			this._show( tooltip, this.options.show );
			// Handle tracking tooltips that are shown with a delay (#8644). As soon
			// as the tooltip is visible, position the tooltip using the most recent
			// event.
			if ( this.options.show && this.options.show.delay ) {
				delayedShow = this.delayedShow = setInterval(function() {
					if ( tooltip.is( ":visible" ) ) {
						position( positionOption.of );
						clearInterval( delayedShow );
					}
				}, $.fx.interval );
			}
	
			this._trigger( "open", event, { tooltip: tooltip } );
	
			events = {
				keyup: function( event ) {
					if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
						var fakeEvent = $.Event(event);
						fakeEvent.currentTarget = target[0];
						this.close( fakeEvent, true );
					}
				},
				remove: function() {
					this._removeTooltip( tooltip );
				}
			};
			if ( !event || event.type === "mouseover" ) {
				events.mouseleave = "close";
			}
			if ( !event || event.type === "focusin" ) {
				events.focusout = "close";
			}
			this._on( true, target, events );
		},
	
		close: function( event ) {
			var that = this,
				target = $( event ? event.currentTarget : this.element ),
				tooltip = this._find( target );
	
			// disabling closes the tooltip, so we need to track when we're closing
			// to avoid an infinite loop in case the tooltip becomes disabled on close
			if ( this.closing ) {
				return;
			}
	
			// Clear the interval for delayed tracking tooltips
			clearInterval( this.delayedShow );
	
			// only set title if we had one before (see comment in _open())
			if ( target.data( "ui-tooltip-title" ) ) {
				target.attr( "title", target.data( "ui-tooltip-title" ) );
			}
	
			removeDescribedBy( target );
	
			tooltip.stop( true );
			this._hide( tooltip, this.options.hide, function() {
				that._removeTooltip( $( this ) );
			});
	
			target.removeData( "ui-tooltip-open" );
			this._off( target, "mouseleave focusout keyup" );
			// Remove 'remove' binding only on delegated targets
			if ( target[0] !== this.element[0] ) {
				this._off( target, "remove" );
			}
			this._off( this.document, "mousemove" );
	
			if ( event && event.type === "mouseleave" ) {
				$.each( this.parents, function( id, parent ) {
					$( parent.element ).attr( "title", parent.title );
					delete that.parents[ id ];
				});
			}
	
			this.closing = true;
			this._trigger( "close", event, { tooltip: tooltip } );
			this.closing = false;
		},
	
		_tooltip: function( element ) {
			var id = "ui-tooltip-" + increments++,
				tooltip = $( "<div>" )
					.attr({
						id: id,
						role: "tooltip"
					})
					.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
						( this.options.tooltipClass || "" ) );
			$( "<div>" )
				.addClass( "ui-tooltip-content" )
				.appendTo( tooltip );
			tooltip.appendTo( this.document[0].body );
			this.tooltips[ id ] = element;
			return tooltip;
		},
	
		_find: function( target ) {
			var id = target.data( "ui-tooltip-id" );
			return id ? $( "#" + id ) : $();
		},
	
		_removeTooltip: function( tooltip ) {
			tooltip.remove();
			delete this.tooltips[ tooltip.attr( "id" ) ];
		},
	
		_destroy: function() {
			var that = this;
	
			// close open tooltips
			$.each( this.tooltips, function( id, element ) {
				// Delegate to close method to handle common cleanup
				var event = $.Event( "blur" );
				event.target = event.currentTarget = element[0];
				that.close( event, true );
	
				// Remove immediately; destroying an open tooltip doesn't use the
				// hide animation
				$( "#" + id ).remove();
	
				// Restore the title
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
					element.removeData( "ui-tooltip-title" );
				}
			});
		}
	});
	
	}( jQuery ) );


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/**
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	
	/**
	 * Implementing Drag and Drop functionality in AngularJS is easier than ever.
	 * Demo: http://codef0rmer.github.com/angular-dragdrop/
	 *
	 * @version 1.0.13
	 *
	 * (c) 2013 Amit Gharat a.k.a codef0rmer <amit.2006.it@gmail.com> - amitgharat.wordpress.com
	 */
	
	(function (window, angular, $, undefined) {
	'use strict';
	
	var jqyoui = angular.module('ngDragDrop', []).service('ngDragDropService', ['$timeout', '$parse', '$q', function($timeout, $parse, $q) {
	    this.draggableScope = null;
	    this.droppableScope = null;
	
	    $('head').prepend('<style type="text/css">@charset "UTF-8";.angular-dragdrop-hide{display: none !important;}</style>');
	
	    this.callEventCallback = function (scope, callbackName, event, ui) {
	      if (!callbackName) return;
	
	      var objExtract = extract(callbackName),
	          callback = objExtract.callback,
	          constructor = objExtract.constructor,
	          args = [event, ui].concat(objExtract.args);
	      
	      // call either $scoped method i.e. $scope.dropCallback or constructor's method i.e. this.dropCallback.
	      // Removing scope.$apply call that was performance intensive (especially onDrag) and does not require it
	      // always. So call it within the callback if needed.
	      return (scope[callback] || scope[constructor][callback]).apply(scope[callback] ? scope : scope[constructor], args);
	      
	      function extract(callbackName) {
	        var atStartBracket = callbackName.indexOf('(') !== -1 ? callbackName.indexOf('(') : callbackName.length,
	            atEndBracket = callbackName.lastIndexOf(')') !== -1 ? callbackName.lastIndexOf(')') : callbackName.length,
	            args = callbackName.substring(atStartBracket + 1, atEndBracket), // matching function arguments inside brackets
	            constructor = callbackName.indexOf('.') !== -1 ? callbackName.substr(0, callbackName.indexOf('.')) : null; // matching a string upto a dot to check ctrl as syntax
	            constructor = scope[constructor] && typeof scope[constructor].constructor === 'function' ? constructor : null;
	
	        return {
	          callback: callbackName.substring(constructor && constructor.length + 1 || 0, atStartBracket),
	          args: $.map(args && args.split(',') || [], function(item) { return [$parse(item)(scope)]; }),
	          constructor: constructor
	        }
	      }
	    };
	
	    this.invokeDrop = function ($draggable, $droppable, event, ui) {
	      var dragModel = '',
	        dropModel = '',
	        dragSettings = {},
	        dropSettings = {},
	        jqyoui_pos = null,
	        dragItem = {},
	        dropItem = {},
	        dragModelValue,
	        dropModelValue,
	        $droppableDraggable = null,
	        droppableScope = this.droppableScope,
	        draggableScope = this.draggableScope,
	        $helper = null,
	        promises = [],
	        temp;
	
	      dragModel = $draggable.ngattr('ng-model');
	      dropModel = $droppable.ngattr('ng-model');
	      dragModelValue = draggableScope.$eval(dragModel);
	      dropModelValue = droppableScope.$eval(dropModel);
	
	      $droppableDraggable = $droppable.find('[jqyoui-draggable]:last,[data-jqyoui-draggable]:last');
	      dropSettings = droppableScope.$eval($droppable.attr('jqyoui-droppable') || $droppable.attr('data-jqyoui-droppable')) || [];
	      dragSettings = draggableScope.$eval($draggable.attr('jqyoui-draggable') || $draggable.attr('data-jqyoui-draggable')) || [];
	
	      // Helps pick up the right item
	      dragSettings.index = this.fixIndex(draggableScope, dragSettings, dragModelValue);
	      dropSettings.index = this.fixIndex(droppableScope, dropSettings, dropModelValue);
	
	      jqyoui_pos = angular.isArray(dragModelValue) ? dragSettings.index : null;
	      dragItem = angular.isArray(dragModelValue) ? dragModelValue[jqyoui_pos] : dragModelValue;
	
	      if (dragSettings.deepCopy) {
	        dragItem = angular.copy(dragItem);
	      }
	
	      if (angular.isArray(dropModelValue) && dropSettings && dropSettings.index !== undefined) {
	        dropItem = dropModelValue[dropSettings.index];
	      } else if (!angular.isArray(dropModelValue)) {
	        dropItem = dropModelValue;
	      } else {
	        dropItem = {};
	      }
	
	      if (dropSettings.deepCopy) {
	        dropItem = angular.copy(dropItem);
	      }
	
	      if (dragSettings.beforeDrop) {
	        promises.push(this.callEventCallback(draggableScope, dragSettings.beforeDrop, event, ui));
	      }
	
	      $q.all(promises).then(angular.bind(this, function() {
	        if (dragSettings.insertInline && dragModel === dropModel) {
	          if (dragSettings.index > dropSettings.index) {
	            temp = dragModelValue[dragSettings.index];
	            for (var i = dragSettings.index; i > dropSettings.index; i--) {
	              dropModelValue[i] = angular.copy(dropModelValue[i - 1]);
	              dropModelValue[i - 1] = {};
	              dropModelValue[i][dragSettings.direction] = 'left';
	            }
	            dropModelValue[dropSettings.index] = temp;
	          } else {
	            temp = dragModelValue[dragSettings.index];
	            for (var i = dragSettings.index; i < dropSettings.index; i++) {
	              dropModelValue[i] = angular.copy(dropModelValue[i + 1]);
	              dropModelValue[i + 1] = {};
	              dropModelValue[i][dragSettings.direction] = 'right';
	            }
	            dropModelValue[dropSettings.index] = temp;
	          }
	          this.callEventCallback(droppableScope, dropSettings.onDrop, event, ui);
	        } else if (dragSettings.animate === true) {
	          // be nice with absolutely positioned brethren :-)
	          $helper = $draggable.clone();
	          $helper.css({'position': 'absolute'}).css($draggable.offset());
	          $('body').append($helper);
	          $draggable.addClass('angular-dragdrop-hide');
	
	          this.move($helper, $droppableDraggable.length > 0 ? $droppableDraggable : $droppable, null, 'fast', dropSettings, function() { $helper.remove(); });
	          this.move($droppableDraggable.length > 0 && !dropSettings.multiple ? $droppableDraggable : [], $draggable.parent('[jqyoui-droppable],[data-jqyoui-droppable]'), jqyoui.startXY, 'fast', dropSettings, angular.bind(this, function() {
	            $timeout(angular.bind(this, function() {
	              // Do not move this into move() to avoid flickering issue
	              $draggable.css({'position': 'relative', 'left': '', 'top': ''}).removeClass('angular-dragdrop-hide');
	              // Angular v1.2 uses ng-hide to hide an element not display property
	              // so we've to manually remove display:none set in this.move()
	              $droppableDraggable.css({'position': 'relative', 'left': '', 'top': '', 'display': $droppableDraggable.css('display') === 'none' ? '' : $droppableDraggable.css('display')});
	
	              this.mutateDraggable(draggableScope, dropSettings, dragSettings, dragModel, dropModel, dropItem, $draggable);
	              this.mutateDroppable(droppableScope, dropSettings, dragSettings, dropModel, dragItem, jqyoui_pos);
	              this.callEventCallback(droppableScope, dropSettings.onDrop, event, ui);
	            }));
	          }));
	        } else {
	          $timeout(angular.bind(this, function() {
	            this.mutateDraggable(draggableScope, dropSettings, dragSettings, dragModel, dropModel, dropItem, $draggable);
	            this.mutateDroppable(droppableScope, dropSettings, dragSettings, dropModel, dragItem, jqyoui_pos);
	            this.callEventCallback(droppableScope, dropSettings.onDrop, event, ui);
	          }));
	        }
	      })).finally(angular.bind(this, function() {
	        this.restore($draggable);
	      }));
	    };
	
	    this.move = function($fromEl, $toEl, toPos, duration, dropSettings, callback) {
	      if ($fromEl.length === 0) {
	        if (callback) {
	          window.setTimeout(function() {
	            callback();
	          }, 300);
	        }
	        return false;
	      }
	
	      var zIndex = $fromEl.css('z-index'),
	        fromPos = $fromEl[dropSettings.containment || 'offset'](),
	        displayProperty = $toEl.css('display'), // sometimes `display` is other than `block`
	        hadNgHideCls = $toEl.hasClass('ng-hide'),
	        hadDNDHideCls = $toEl.hasClass('angular-dragdrop-hide');
	
	      if (toPos === null && $toEl.length > 0) {
	        if (($toEl.attr('jqyoui-draggable') || $toEl.attr('data-jqyoui-draggable')) !== undefined && $toEl.ngattr('ng-model') !== undefined && $toEl.is(':visible') && dropSettings && dropSettings.multiple) {
	          toPos = $toEl[dropSettings.containment || 'offset']();
	          if (dropSettings.stack === false) {
	            toPos.left+= $toEl.outerWidth(true);
	          } else {
	            toPos.top+= $toEl.outerHeight(true);
	          }
	        } else {
	          // Angular v1.2 uses ng-hide to hide an element 
	          // so we've to remove it in order to grab its position
	          if (hadNgHideCls) $toEl.removeClass('ng-hide');
	          if (hadDNDHideCls) $toEl.removeClass('angular-dragdrop-hide');
	          toPos = $toEl.css({'visibility': 'hidden', 'display': 'block'})[dropSettings.containment || 'offset']();
	          $toEl.css({'visibility': '','display': displayProperty});
	        }
	      }
	
	      $fromEl.css({'position': 'absolute', 'z-index': 9999})
	        .css(fromPos)
	        .animate(toPos, duration, function() {
	          // Angular v1.2 uses ng-hide to hide an element
	          // and as we remove it above, we've to put it back to
	          // hide the element (while swapping) if it was hidden already
	          // because we remove the display:none in this.invokeDrop()
	          if (hadNgHideCls) $toEl.addClass('ng-hide');
	          if (hadDNDHideCls) $toEl.addClass('angular-dragdrop-hide');
	          $fromEl.css('z-index', zIndex);
	          if (callback) callback();
	        });
	    };
	
	    this.mutateDroppable = function(scope, dropSettings, dragSettings, dropModel, dragItem, jqyoui_pos) {
	      var dropModelValue = scope.$eval(dropModel);
	
	      scope.dndDragItem = dragItem;
	
	      if (angular.isArray(dropModelValue)) {
	        if (dropSettings && dropSettings.index >= 0) {
	          dropModelValue[dropSettings.index] = dragItem;
	        } else {
	          dropModelValue.push(dragItem);
	        }
	        if (dragSettings && dragSettings.placeholder === true) {
	          dropModelValue[dropModelValue.length - 1]['jqyoui_pos'] = jqyoui_pos;
	        }
	      } else {
	        $parse(dropModel + ' = dndDragItem')(scope);
	        if (dragSettings && dragSettings.placeholder === true) {
	          dropModelValue['jqyoui_pos'] = jqyoui_pos;
	        }
	      }
	    };
	
	    this.mutateDraggable = function(scope, dropSettings, dragSettings, dragModel, dropModel, dropItem, $draggable) {
	      var isEmpty = angular.equals(dropItem, {}) || !dropItem,
	        dragModelValue = scope.$eval(dragModel);
	
	      scope.dndDropItem = dropItem;
	
	      if (dragSettings && dragSettings.placeholder) {
	        if (dragSettings.placeholder != 'keep'){
	          if (angular.isArray(dragModelValue) && dragSettings.index !== undefined) {
	            dragModelValue[dragSettings.index] = dropItem;
	          } else {
	            $parse(dragModel + ' = dndDropItem')(scope);
	          }
	        }
	      } else {
	        if (angular.isArray(dragModelValue)) {
	          if (isEmpty) {
	            if (dragSettings && ( dragSettings.placeholder !== true && dragSettings.placeholder !== 'keep' )) {
	              dragModelValue.splice(dragSettings.index, 1);
	            }
	          } else {
	            dragModelValue[dragSettings.index] = dropItem;
	          }
	        } else {
	          // Fix: LIST(object) to LIST(array) - model does not get updated using just scope[dragModel] = {...}
	          // P.S.: Could not figure out why it happened
	          $parse(dragModel + ' = dndDropItem')(scope);
	          if (scope.$parent) {
	            $parse(dragModel + ' = dndDropItem')(scope.$parent);
	          }
	        }
	      }
	
	      this.restore($draggable);
	    };
	
	    this.restore = function($draggable) {
	      $draggable.css({'z-index': '', 'left': '', 'top': ''});
	    };
	
	    this.fixIndex = function(scope, settings, modelValue) {
	      if (settings.applyFilter && angular.isArray(modelValue) && modelValue.length > 0) {
	        var dragModelValueFiltered = scope[settings.applyFilter](),
	            lookup = dragModelValueFiltered[settings.index],
	            actualIndex = undefined;
	
	        modelValue.forEach(function(item, i) {
	           if (angular.equals(item, lookup)) {
	             actualIndex = i;
	           }
	        });
	
	        return actualIndex;
	      }
	
	      return settings.index;
	    };
	  }]).directive('jqyouiDraggable', ['ngDragDropService', function(ngDragDropService) {
	    return {
	      require: '?jqyouiDroppable',
	      restrict: 'A',
	      link: function(scope, elem, attrs) {
	        var element = $(elem);
	        var dragSettings, jqyouiOptions, zIndex, killWatcher;
	        var updateDraggable = function(newValue, oldValue) {
	          if (newValue) {
	            dragSettings = scope.$eval(element.attr('jqyoui-draggable') || element.attr('data-jqyoui-draggable')) || {};
	            jqyouiOptions = scope.$eval(attrs.jqyouiOptions) || {};
	            element
	              .draggable({disabled: false})
	              .draggable(jqyouiOptions)
	              .draggable({
	                start: function(event, ui) {
	                  ngDragDropService.draggableScope = scope;
	                  zIndex = $(jqyouiOptions.helper ? ui.helper : this).css('z-index');
	                  $(jqyouiOptions.helper ? ui.helper : this).css('z-index', 9999);
	                  jqyoui.startXY = $(this)[dragSettings.containment || 'offset']();
	                  ngDragDropService.callEventCallback(scope, dragSettings.onStart, event, ui);
	                },
	                stop: function(event, ui) {
	                  $(jqyouiOptions.helper ? ui.helper : this).css('z-index', zIndex);
	                  ngDragDropService.callEventCallback(scope, dragSettings.onStop, event, ui);
	                },
	                drag: function(event, ui) {
	                  ngDragDropService.callEventCallback(scope, dragSettings.onDrag, event, ui);
	                }
	              });
	          } else {
	            element.draggable({disabled: true});
	          }
	
	          if (killWatcher && angular.isDefined(newValue) && (angular.equals(attrs.drag, 'true') || angular.equals(attrs.drag, 'false'))) {
	            killWatcher();
	            killWatcher = null;
	          }
	        };
	
	        killWatcher = scope.$watch(function() { return scope.$eval(attrs.drag); }, updateDraggable);
	        updateDraggable();
	
	        element.on('$destroy', function() {
	          element.draggable({disabled: true}).draggable('destroy');
	        });
	      }
	    };
	  }]).directive('jqyouiDroppable', ['ngDragDropService', '$q', function(ngDragDropService, $q) {
	    return {
	      restrict: 'A',
	      priority: 1,
	      link: function(scope, elem, attrs) {
	        var element = $(elem);
	        var dropSettings, jqyouiOptions, killWatcher;
	        var updateDroppable = function(newValue, oldValue) {
	          if (newValue) {
	            dropSettings = scope.$eval($(element).attr('jqyoui-droppable') || $(element).attr('data-jqyoui-droppable')) || {};
	            jqyouiOptions = scope.$eval(attrs.jqyouiOptions) || {};
	            element
	              .droppable({disabled: false})
	              .droppable(jqyouiOptions)
	              .droppable({
	                over: function(event, ui) {
	                  ngDragDropService.callEventCallback(scope, dropSettings.onOver, event, ui);
	                },
	                out: function(event, ui) {
	                  ngDragDropService.callEventCallback(scope, dropSettings.onOut, event, ui);
	                },
	                drop: function(event, ui) {
	                  var beforeDropPromise = null;
	
	                  if (dropSettings.beforeDrop) {
	                    beforeDropPromise = ngDragDropService.callEventCallback(scope, dropSettings.beforeDrop, event, ui);
	                  } else {
	                    beforeDropPromise = (function() {
	                      var deferred = $q.defer();
	                      deferred.resolve();
	                      return deferred.promise;
	                    })();
	                  }
	
	                  beforeDropPromise.then(angular.bind(this, function() {
	                    if ($(ui.draggable).ngattr('ng-model') && attrs.ngModel) {
	                      ngDragDropService.droppableScope = scope;
	                      ngDragDropService.invokeDrop($(ui.draggable), $(this), event, ui);
	                    } else {
	                      ngDragDropService.callEventCallback(scope, dropSettings.onDrop, event, ui);
	                    }
	                  }), function() {
	                    ui.draggable.animate({left: '', top: ''}, jqyouiOptions.revertDuration || 0);
	                  });
	                }
	              });
	          } else {
	            element.droppable({disabled: true});
	          }
	
	          if (killWatcher && angular.isDefined(newValue) && (angular.equals(attrs.drop, 'true') || angular.equals(attrs.drop, 'false'))) {
	            killWatcher();
	            killWatcher = null;
	          }
	        };
	
	        killWatcher = scope.$watch(function() { return scope.$eval(attrs.drop); }, updateDroppable);
	        updateDroppable();
	        
	        element.on('$destroy', function() {
	          element.droppable({disabled: true}).droppable('destroy');
	        });
	      }
	    };
	  }]);
	
	  $.fn.ngattr = function(name, value) {
	    var element = this[0];
	
	    return element.getAttribute(name) || element.getAttribute('data-' + name);
	  };
	})(window, window.angular, __webpack_provided_window_dot_jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "images/default_logo.png";

/***/ }
]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzPzZmMTQqIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanM/YWNmZCoiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL2luZGV4LmpzPzVkZmMqIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9hbmd1bGFyLXVpLWJvb3RzdHJhcC91aS1ib290c3RyYXAtdHBscy5qcz8wZDE3KiIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1zYW5pdGl6ZS9pbmRleC5qcz8wZGVmKiIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1zYW5pdGl6ZS9hbmd1bGFyLXNhbml0aXplLmpzPzRhNGEqIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbW9tZW50LmpzP2I3MjEqIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbW9tZW50LmpzPzM5NTciLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcz9jM2MyIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlIF5cXC5cXC8uKiQ/OWY2OSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9hZi5qcz9lNWM2Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2FyLmpzPzIzMTAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYXItbWEuanM/YTJhOCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9hci1zYS5qcz8zOGMxIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2FyLXRuLmpzP2Y3MWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYXouanM/NjAzNSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9iZS5qcz81YTE3Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2JnLmpzP2YwMjEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYm4uanM/OWUzMSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9iby5qcz9hOTJkIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2JyLmpzPzM0NDQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYnMuanM/Y2I0NCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9jYS5qcz9jY2I3Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2NzLmpzP2EzOTgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvY3YuanM/MWY0ZSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9jeS5qcz81YmI2Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2RhLmpzPzc0NGIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZGUuanM/YjNiYyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9kZS1hdC5qcz9jMGE1Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2VsLmpzPzZhN2QiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZW4tYXUuanM/ZGNlZSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9lbi1jYS5qcz83Njc4Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2VuLWdiLmpzPzgyNjYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZW8uanM/NDI1MiIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9lcy5qcz9lMDAyIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2V0LmpzP2I5ZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZXUuanM/NGE5YSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9mYS5qcz9iNjRkIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2ZpLmpzPzE5ZGQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZm8uanM/ZTIzOCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9mci5qcz8yNGY1Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzPzdmMmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZnkuanM/NTkyOSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9nbC5qcz9lZGU4Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2hlLmpzP2Q5NzgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaGkuanM/MmU5YyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9oci5qcz9lYWI5Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2h1LmpzPzRlMDAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaHktYW0uanM/ODEzOCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9pZC5qcz9iYjVkIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2lzLmpzPzA3MTQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaXQuanM/NWUyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9qYS5qcz81ZDk0Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2p2LmpzPzZiMzAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUva2EuanM/YThkNSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9rbS5qcz80YmZlIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2tvLmpzP2MwZTMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbGIuanM/Mjc4YiIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9sdC5qcz8xNTk5Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2x2LmpzP2FiMWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbWUuanM/NWQ4OSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9tay5qcz8zMDA1Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL21sLmpzPzZlNGEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbXIuanM/OTgxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9tcy5qcz9kZjdmIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL21zLW15LmpzPzdlMTUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbXkuanM/MWJlMyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9uYi5qcz9mODEwIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL25lLmpzPzA2NjkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbmwuanM/ZjhjMCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9ubi5qcz81YzZkIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3BsLmpzP2ZjMzAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvcHQuanM/OTZlMCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9wdC1ici5qcz9jZjc5Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3JvLmpzPzMxZTciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvcnUuanM/MGRkMyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9zaS5qcz8yNmVlIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3NrLmpzPzJkMDYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvc2wuanM/YzBkMyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9zcS5qcz9hY2MwIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3NyLmpzPzQ1ZjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvc3ItY3lybC5qcz83YmMxIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3N2LmpzPzFkODIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdGEuanM/ZDc1MyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90aC5qcz85NWEzIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3RsLXBoLmpzPzJhNjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdHIuanM/NjZkNCIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90emwuanM/NTMzZiIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90em0uanM/NTllMSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90em0tbGF0bi5qcz8zNzY5Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3VrLmpzPzAwYzQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdXouanM/ZjE1OSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS92aS5qcz84NTg4Iiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3poLWNuLmpzP2RlZmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvemgtdHcuanM/NDNjZSIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzPzY3NDMiLCJ3ZWJwYWNrOi8vLy4vc2VydmljZS9na0kxOE4uanM/NTllYSIsIndlYnBhY2s6Ly8vLi4vZ29rdWFpLmh0bWwiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3NyYy9jc3MvZGF0ZXRpbWVwaWNrZXIuY3NzPzQ1N2EiLCJ3ZWJwYWNrOi8vLy4uL3N0eWxlcy9pbmRleC5zY3NzIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9qcXVlcnktY29udGV4dG1lbnUvZGlzdC9qcXVlcnkudWkucG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2pxdWVyeS1jb250ZXh0bWVudS9kaXN0L2pxdWVyeS5jb250ZXh0TWVudS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvc3JjL2pzL2RhdGV0aW1lcGlja2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9uZy1jb250ZXh0LW1lbnUvZGlzdC9uZy1jb250ZXh0LW1lbnUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2pxdWVyeS11aS9qcXVlcnktdWkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItZHJhZ2Ryb3Avc3JjL2FuZ3VsYXItZHJhZ2Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4uL2ltYWdlcy9kZWZhdWx0X2xvZ28ucG5nIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0IsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0IsMEJBQXlCO0FBQ3pCLHNCQUFxQjs7QUFFckIsa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQixjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsbUNBQWtDLG1EQUFtRDtBQUNyRjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBLFlBQVc7QUFDWCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7O0FBRUwsRUFBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1YkQsdUc7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHdDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQW9EO0FBQ3BELElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDO0FBQzFDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0Esc0JBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQSwwQkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLDZDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBLDBDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixlQUFjO0FBQ2QsZUFBYztBQUNkLGlCQUFnQjtBQUNoQixpQkFBZ0I7QUFDaEIsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMLGtCQUFpQjs7QUFFakI7QUFDQSxtREFBa0QsRUFBRSxpQkFBaUI7O0FBRXJFO0FBQ0EseUJBQXdCLDhCQUE4QjtBQUN0RCw0QkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQWtELGlCQUFpQjs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7Ozs7Ozs7QUMzZ0REO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQixjQUFhO0FBQ2IsWUFBVztBQUNYO0FBQ0Esb0JBQW1CO0FBQ25CLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixlQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQSxvQkFBbUI7QUFDbkIsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsWUFBWSxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQixjQUFhO0FBQ2IsWUFBVztBQUNYLHlDQUF3QztBQUN4QztBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixlQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQixjQUFhO0FBQ2IsWUFBVztBQUNYLHlDQUF3QztBQUN4QztBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLFlBQVksRUFBRTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFO0FBQ2pFLGdDQUErQixpREFBaUQsRUFBRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyw2Q0FBNkMsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsZ0JBQWdCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyxnQkFBZ0I7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQyxnQkFBZ0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQyxnQkFBZ0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQixRQUFROztBQUU1Qiw0QkFBMkIsbUNBQW1DO0FBQzlELDJDQUEwQyxHQUFHLG9DQUFvQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUgsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLHdEQUF3RDtBQUNyRjtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsYUFBYSxxQkFBcUI7QUFDdkQ7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixjQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsK0RBQThELEVBQUU7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLEVBQUU7QUFDdEIsaUNBQWdDLG9CQUFvQjtBQUNwRCxRQUFPO0FBQ1A7QUFDQSxxQkFBb0IsRUFBRTtBQUN0QixpQ0FBZ0MsMkJBQTJCO0FBQzNELFFBQU87QUFDUDtBQUNBLHFCQUFvQixJQUFJO0FBQ3hCLGlDQUFnQyxvQkFBb0I7QUFDcEQsUUFBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBZ0MsNERBQTREO0FBQzVGLFFBQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWdDLGlFQUFpRTtBQUNqRyxRQUFPO0FBQ1A7QUFDQTtBQUNBLGlDQUFnQyx3QkFBd0I7QUFDeEQsUUFBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBZ0Msd0JBQXdCO0FBQ3hELFFBQU87QUFDUDtBQUNBLDRCQUEyQixFQUFFLFFBQVEsRUFBRTtBQUN2QyxpQ0FBZ0Msb0JBQW9CO0FBQ3BELFFBQU87QUFDUDtBQUNBLDZCQUE0QixFQUFFLFFBQVEsRUFBRTtBQUN4QyxpQ0FBZ0Msb0JBQW9CO0FBQ3BELFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLGlDQUFnQyxxQkFBcUI7QUFDckQsUUFBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBZ0MscUJBQXFCO0FBQ3JELFFBQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWdDLHFCQUFxQjtBQUNyRCxRQUFPO0FBQ1A7QUFDQTtBQUNBLGlDQUFnQyxxQkFBcUI7QUFDckQsUUFBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBZ0MsdUJBQXVCO0FBQ3ZELFFBQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWdDLHVCQUF1QjtBQUN2RCxRQUFPO0FBQ1A7QUFDQTtBQUNBLGlDQUFnQyw0QkFBNEI7QUFDNUQsUUFBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBZ0MsdUJBQXVCO0FBQ3ZELFFBQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWdDLHVCQUF1QjtBQUN2RCxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCO0FBQzVCLHlEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7O0FBRUEsMENBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhLQUE2Syx3Q0FBd0M7QUFDck47O0FBRUE7QUFDQSxnQ0FBK0Isd0NBQXdDO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTJFO0FBQzNFO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCLE1BQUs7QUFDTCx1QkFBc0I7QUFDdEIsTUFBSztBQUNMLHVCQUFzQjtBQUN0QixNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCLE1BQUs7QUFDTCx1QkFBc0I7QUFDdEIsTUFBSztBQUNMLHVCQUFzQjtBQUN0QixNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsNEVBQTJFLFdBQVc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCLE1BQUs7QUFDTCx1QkFBc0I7QUFDdEIsTUFBSztBQUNMLHVCQUFzQjtBQUN0QixNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLHlEQUF3RCx5QkFBeUI7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNELHlCQUF5QjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EscURBQW9ELCtCQUErQixFQUFFO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQiwrQkFBK0I7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEtBQTZLLHdDQUF3QztBQUNyTjs7QUFFQTtBQUNBLGdDQUErQix3Q0FBd0M7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTs7QUFFN0IsMkRBQTBELFNBQVM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsaUJBQWlCO0FBQ2hEO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFvQixnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCLGlCQUFpQjtBQUNoRDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQW9CLGdEQUFnRDtBQUNwRTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsWUFBVztBQUNYO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVkseUJBQXlCLHFDQUFxQyx3QkFBd0I7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2YsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixnQkFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBVzs7QUFFWCxzQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixjQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyx5QkFBeUIscUNBQXFDLHdCQUF3QjtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsY0FBYTs7QUFFYix3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiw4QkFBOEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLDhCQUE4QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsMENBQXlDOztBQUV6QztBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxvQkFBb0I7QUFDeEQsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0Esa0NBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QztBQUN4QyxpRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGdCQUFnQixjQUFjLGVBQWU7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBZ0QsUUFBUTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGtCQUFrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZLDZFQUE2RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1oseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVksZ0ZBQWdGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVksNkVBQTZFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1oseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZLGdGQUFnRjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWix5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBWSw0RkFBNEY7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBWSx5RkFBeUY7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBWSw0RkFBNEY7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQVkseUZBQXlGO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkVBQTBFLG1CQUFtQjtBQUM3RjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixxQkFBcUI7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLG1CQUFtQjtBQUM3RjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDLG1DQUFrQyxXQUFXLEdBQUcsMEVBQTBFO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixhQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUSw0RUFBNEUsd0RBQXdEO0FBQ3ZKLFlBQVcsUUFBUTtBQUNuQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSx1RUFBc0UsZ0RBQWdEO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsb0RBQW9EO0FBQzdELFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLHNCQUFxQiw4QkFBOEI7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFFBQU8sMkJBQTJCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFPLDJCQUEyQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrREFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxlQUFlO0FBQ3hELFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLG9CQUFvQixFQUFFO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFtRTtBQUNuRTtBQUNBLDZIQUE0SDtBQUM1SDtBQUNBLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxlQUFlO0FBQzVELFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG9CQUFvQixFQUFFO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFtRTtBQUNuRTs7QUFFQSw2SEFBNEg7QUFDNUg7QUFDQSxpREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLDJCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBLCtJQUE4SSx5QkFBeUIsS0FBSyxTQUFTO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDBGQUF5RixlQUFlO0FBQ3hHLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUE4RiwwQkFBMEI7QUFDeEgsNENBQTJDLGNBQWMsTUFBTSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLCtDQUE4QyxZQUFZLG1DQUFtQyxjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUIsa0JBQWtCLFlBQVksZ09BQWdPLGFBQWEsT0FBTztBQUM5VDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUEyRyxjQUFjLEtBQUssY0FBYztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRSx1QkFBdUI7QUFDekYsd0dBQXVHLFVBQVU7QUFDakgsNkRBQTRELGdEQUFnRCw4Q0FBOEMsZ0dBQWdHLG9EQUFvRCxLQUFLLFlBQVk7QUFDL1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLCtDQUE4QyxZQUFZLG1DQUFtQyxjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixZQUFZLGdPQUFnTyxhQUFhLE9BQU87QUFDOVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF1RyxVQUFVO0FBQ2pILDZEQUE0RCx5Q0FBeUMsOENBQThDLGdHQUFnRyx3QkFBd0IsS0FBSyxZQUFZO0FBQzVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSx3R0FBdUcsaURBQWlEO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLGtJQUFpSSxzQkFBc0I7QUFDdkosNkZBQTRGLG9CQUFvQjtBQUNoSDtBQUNBLG1HQUFrRyxvQkFBb0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsK0NBQThDLFlBQVksbUNBQW1DLGNBQWM7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFlBQVksZ09BQWdPLGFBQWEsT0FBTztBQUM1UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXVHLFVBQVU7QUFDakgsNkRBQTRELHlDQUF5Qyw4Q0FBOEMsZ0dBQWdHLHdCQUF3QixLQUFLLFlBQVk7QUFDNVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0Esc0JBQXFCLDZDQUE2QztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixvREFBb0QsdURBQXVELHVCQUF1QjtBQUN6Six3QkFBdUIsNENBQTRDLHVEQUF1RCxtQkFBbUI7QUFDN0k7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELG1DQUFtQywyRUFBMkUsb0JBQW9CO0FBQ25MLG1EQUFrRCxtQ0FBbUMsaUZBQWlGLHVCQUF1QjtBQUM3TCxvRUFBbUUsdURBQXVELG9GQUFvRixXQUFXO0FBQ3pOLG1EQUFrRCwrQkFBK0IsaUZBQWlGLG1CQUFtQjtBQUNyTCxrREFBaUQsK0JBQStCLG1GQUFtRixtQkFBbUI7QUFDdEw7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EscUhBQW9ILE9BQU8seUNBQXlDLEtBQUssZUFBZSw2Q0FBNkMsc0JBQXNCLG9CQUFvQix3QkFBd0IsU0FBUyx3QkFBd0I7QUFDeFU7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxnRUFBK0QsU0FBUztBQUN4RSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHVIQUFzSCxPQUFPLHlDQUF5QyxLQUFLLGVBQWUsNkNBQTZDLHNCQUFzQixvQkFBb0Isd0JBQXdCLFNBQVMsd0JBQXdCO0FBQzFVO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSw0SUFBMkksY0FBYyxxQkFBcUIsT0FBTztBQUNyTCxvRkFBbUYsOEJBQThCO0FBQ2pILDRPQUEyTyxTQUFTLHNCQUFzQixTQUFTO0FBQ25SO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxzQkFBcUIsbUNBQW1DO0FBQ3hELG1FQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixnQkFBZ0IsZUFBZSxvREFBb0Q7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTRELDZCQUE2QiwwRUFBMEUsWUFBWTtBQUMvSyxzQkFBcUI7QUFDckIsK0RBQThELCtCQUErQiw0RUFBNEUsWUFBWTtBQUNyTDtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsMEJBQTBCO0FBQzFFLHdDQUF1QyxnS0FBZ0ssWUFBWTtBQUNuTjtBQUNBO0FBQ0EsaURBQWdELDRCQUE0QjtBQUM1RSx3Q0FBdUMsb0tBQW9LLFlBQVk7QUFDdk47QUFDQSw2RUFBNEUsNkJBQTZCLHVIQUF1SCxZQUFZLEtBQUssVUFBVTtBQUMzUDtBQUNBO0FBQ0EsNkRBQTRELDZCQUE2QiwwRUFBMEUsWUFBWTtBQUMvSyxzQkFBcUI7QUFDckIsK0RBQThELCtCQUErQiw0RUFBNEUsWUFBWTtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLHNGQUFxRixxREFBcUQsMEJBQTBCLG9DQUFvQyxXQUFXO0FBQ25OLHlFQUF3RSwwQkFBMEIsa0dBQWtHLFlBQVk7QUFDaE47QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Qsb0lBQW1JLHVDQUF1QywrQkFBK0IsVzs7Ozs7O0FDdHpRek07QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsdUNBQXVDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXdFO0FBQ3hFLHlCQUF3QjtBQUN4QjtBQUNBLG9FQUFtRSx3QkFBd0I7QUFDM0Y7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsOEJBQThCLFNBQVMsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsS0FBSSxRQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLHlCQUF5QixTQUFTLFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0Esb0JBQW1CLDBCQUEwQjtBQUM3QyxvQkFBbUIsZ0RBQWdELGNBQWMsT0FBTztBQUN4RiwyQkFBMEIsTUFBTTtBQUNoQyxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsMEJBQTBCLFFBQVEsTUFBTTtBQUMxRCxPQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixnQkFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZCxjQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckMsNkJBQTRCO0FBQzVCLGdDQUErQjtBQUMvQjtBQUNBLEtBQUk7QUFDSjtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsOEVBQTZFO0FBQzdFLE1BQUs7QUFDTDtBQUNBLDZDQUE0QztBQUM1QyxNQUFLO0FBQ0wsd0JBQXVCO0FBQ3ZCLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGNBQWEsT0FBTztBQUNwQixzQ0FBcUM7QUFDckMsNkJBQTRCO0FBQzVCLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPLHFCQUFxQiwwQkFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLHNDQUFzQyxRQUFRLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiw0REFBNEQsUUFBUSxRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsd0RBQXdELGdCQUFnQixLQUFLLFFBQVEsUUFBUTtBQUNsSDtBQUNBO0FBQ0Esc0VBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3Qix5QkFBeUIsUUFBUSxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQSx1RUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxLQUFLO0FBQy9FOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF3RixFQUFFOztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0QsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1c0JELDRHOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsb0JBQW9COztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJLQUEwSyxJQUFJOztBQUU5SyxzRUFBcUUsSUFBSTs7QUFFekU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBOEI7QUFDOUIsaUNBQWdDO0FBQ2hDLDhCQUE2QixFQUFFLEVBQUU7QUFDakMsOEJBQTZCLEVBQUUsRUFBRTtBQUNqQyxtQ0FBa0MsRUFBRSxFQUFFO0FBQ3RDLGtDQUFpQztBQUNqQyw4QkFBNkIsSUFBSSxFQUFFO0FBQ25DLDhCQUE2QixJQUFJLEVBQUU7QUFDbkMsbUNBQWtDLElBQUksRUFBRTs7QUFFeEMsZ0NBQStCO0FBQy9CLHFDQUFvQzs7QUFFcEMsK0NBQThDOztBQUU5Qyx5Q0FBd0MsSUFBSSxJQUFJOztBQUVoRDtBQUNBLGlJQUFnSSxJQUFJOztBQUVwSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTLCtCQUErQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUErQyxFQUFFLElBQUksRUFBRTs7QUFFdkQ7QUFDQSxrQ0FBaUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQy9DLDRCQUEyQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDekMsOEJBQTZCLEVBQUUsS0FBSyxFQUFFO0FBQ3RDLDRCQUEyQixFQUFFLEtBQUssRUFBRTtBQUNwQywwQkFBeUIsRUFBRSxJQUFJLEVBQUU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLCtCQUErQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUF5QyxnQkFBZ0I7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNFQUFxRSxFQUFFOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsNkJBQTZCO0FBQ3RDO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGNBQWM7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLHFCQUFxQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMscUJBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQWtDLElBQUk7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUFzRixJQUFJO0FBQzFGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUMsRzs7Ozs7OztBQzFuR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLHVEQUF1RDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0EsNkZBQTRGO0FBQzVGLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN2RUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDdElEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3pERDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDckdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDdkREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDdEdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNqSkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hGRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMvR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDNUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDekdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzNJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzdFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsNEJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMzSkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3REQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkMsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzdFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMxREQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN6RUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXdFO0FBQ3hFO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxrQ0FBaUM7QUFDakMsaUNBQWdDO0FBQ2hDLGlDQUFnQztBQUNoQyxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0EsMkRBQTBEO0FBQzFEO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzVGRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ2hFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3REQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ2pFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3ZFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsNEJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3RUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDOUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDOUREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3ZHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN6R0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDMUREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzVERDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hERDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNyRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDRCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDekVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNoRkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN6SEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzNHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJLElBQUksSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3R0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNqRkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDN0hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCw0QkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3BFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDL0REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDakZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULHFDQUFvQyxJQUFJLElBQUksSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3JHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDeEREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsNEJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNwSUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMzSEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDOUZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzNHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDeEZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNyRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3ZIRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNoRkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDaEZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMzRkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMzREQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3pIRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNyRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDMUREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN2R0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDOUREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QyxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUMxREQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ2xLRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQy9ERDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzVKRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQzlKRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDbkVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDMUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDMUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNqRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDJCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixpQ0FBZ0M7QUFDaEMsY0FBYTtBQUNiLGdDQUErQjtBQUMvQixjQUFhO0FBQ2IsbUNBQWtDO0FBQ2xDLGNBQWE7QUFDYixtQ0FBa0M7QUFDbEMsY0FBYTtBQUNiLGdDQUErQjtBQUMvQixjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3RkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQy9ERDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM1REQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDeEZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7O0FBSTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQyxHOzs7Ozs7QUNuRkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxFQUFDLEc7Ozs7OztBQ3hERDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDeEREO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBLEVBQUMsRzs7Ozs7O0FDdkpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsMEJBQTBCOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUN4REQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNoRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBCQUEwQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUM3SEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQywwQkFBMEI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCwyQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUEsRUFBQyxHOzs7Ozs7QUNuR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELGdCQUFnQjtBQUNoRSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQiw0QkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1RkFBc0YsZUFBZTtBQUNyRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFpRCxxREFBcUQ7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUgsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBc0Usc0JBQXNCO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUF5QyxnQ0FBZ0M7O0FBRXpFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQXlDLGdDQUFnQzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFLGtDQUFrQzs7QUFFcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDQUFpQyxLQUFLO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxpQkFBaUIsa0NBQWtDO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxvQ0FBb0M7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFLDJCQUEwQixXQUFXLHdFQUF3RTtBQUM3RztBQUNBLCtCQUE4QixrQkFBa0I7QUFDaEQsc0JBQXFCO0FBQ3JCLCtCQUE4Qix1REFBdUQ7O0FBRXJGLHVCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLHFDQUFvQyxnRkFBZ0Y7QUFDcEgscUNBQW9DLGdGQUFnRjtBQUNwSCxxQ0FBb0MsaUZBQWlGO0FBQ3JILHFDQUFvQzs7QUFFcEM7O0FBRUE7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQSxRQUFPLGtGQUFrRjtBQUN6RjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxzREFBcUQ7QUFDckQ7QUFDQSxRQUFPLHVEQUF1RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTs7QUFFQSxrQ0FBaUM7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCw4QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSCxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUMxekVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDO0FBQ0QsRTs7Ozs7Ozs7QUMvQ0EsK0I7Ozs7OztBQ0RBLDBDOzs7Ozs7QUNBQSwwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGtCQUFrQixXQUFXLFlBQVksZ0JBQWdCLDJCQUEyQixXQUFXO0FBQ3RJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DLGVBQWU7QUFDbkQsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsb0JBQW9COztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUEsRUFBQzs7Ozs7OztBQ3BnQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFNOztBQUVOO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELGtFQUFrRTtBQUN6SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFrRCwrQkFBK0I7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsNkNBQTZDO0FBQ3JHLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTBELDZDQUE2QztBQUN2Rzs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBbUQsV0FBVztBQUM5RCwwQkFBeUI7QUFDekI7O0FBRUE7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakIseURBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QiwwQkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLCtEQUE4RCxlQUFlLGVBQWU7QUFDNUY7O0FBRUE7QUFDQSw0QkFBMkIsdUNBQXVDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUdBQWdHLHdCQUF3QixPQUFPLFFBQVEsWUFBWSwwQkFBMEIsd0JBQXdCO0FBQ3JNLDJCQUEwQiw2REFBNkQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsVUFBVTtBQUNwQywyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBLGNBQWE7QUFDYiw4REFBNkQsdUNBQXVDO0FBQ3BHLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiLDJDQUEwQyxjQUFjO0FBQ3hELGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLHdDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUI7QUFDdkIsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXNFLFlBQVk7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUVBQWtFLFlBQVk7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEVBQUM7Ozs7Ozs7aUdDaHpERDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdiQUEyQztBQUMzQztBQUNBLElBQUc7QUFDSCxxRUFBb0U7QUFDcEUsSUFBRztBQUNILDRDQUEyQztBQUMzQztBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG1MQUFrTCxpQ0FBaUM7QUFDbk47QUFDQTtBQUNBO0FBQ0EsOEVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQSxpREFBZ0QsOEdBQThHO0FBQzlKLGlHQUFnRyxzQkFBc0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLDhHQUE4RyxLQUFLLHNCQUFzQjtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsNkNBQTRDLGtFQUFrRTtBQUM5Ryw4Q0FBNkMsOERBQThEO0FBQzNHO0FBQ0E7O0FBRUEsOEJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsNkNBQTRDLGtFQUFrRTtBQUM5Ryw4Q0FBNkMsNkRBQTZEO0FBQzFHO0FBQ0E7O0FBRUEsOEJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLDZDQUE0Qyx1RUFBdUU7QUFDbkgsOENBQTZDLGtFQUFrRTtBQUMvRztBQUNBO0FBQ0E7OztBQUdBLHNDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7O0FBRUEsOEJBQTZCLE9BQU87QUFDcEMsNkJBQTRCO0FBQzVCLGdDQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLDZDQUE0QyxxRUFBcUU7QUFDakgsOENBQTZDLGdFQUFnRTtBQUM3RztBQUNBOztBQUVBLDhCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQiw2Q0FBNEMsc0VBQXNFO0FBQ2xILDhDQUE2QyxpRUFBaUU7QUFDOUc7QUFDQTs7QUFFQTs7QUFFQSw4QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUErQixtQ0FBbUM7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQix5QkFBeUI7QUFDeEQ7QUFDQSxrQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXNFLHVEQUF1RDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7Ozs7QUN4WkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsZ0JBQWdCO0FBQ2pELGdCQUFlO0FBQ2Y7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRDtBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkMsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBLCtDQUE4QyxPQUFPLFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQsaUJBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsdUJBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSx1Q0FBc0M7QUFDdEMsc0NBQXFDO0FBQ3JDLHNDQUFxQztBQUNyQyx3Q0FBdUMsYUFBYTtBQUNwRCxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnQ0FBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0Esb0JBQW1CO0FBQ25CLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxZQUFXO0FBQ1g7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsYUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixPQUFPLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLElBQUc7O0FBRUgsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsT0FBTyxxQkFBcUI7O0FBRXZEO0FBQ0E7O0FBRUE7O0FBRUEscUNBQW9DO0FBQ3BDLCtDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DLDRCQUE0QjtBQUNoRTs7QUFFQSxLQUFJO0FBQ0osK0NBQThDO0FBQzlDO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSCxHQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBa0U7QUFDbEUsaURBQWdELHFCQUFxQjs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF3QyxRQUFROztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0hBQWlILHNDQUFzQztBQUN2SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNEQsa0RBQWtEO0FBQzlHO0FBQ0E7QUFDQSw2REFBNEQsa0JBQWtCO0FBQzlFO0FBQ0E7QUFDQSw4REFBNkQsaURBQWlEO0FBQzlHO0FBQ0E7QUFDQSw4REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTRELGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0EsNkRBQTRELGtEQUFrRDtBQUM5RztBQUNBO0FBQ0EsOERBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0EsOERBQTZELGlEQUFpRDtBQUM5RztBQUNBOztBQUVBO0FBQ0EsMkdBQTBHLHNDQUFzQztBQUNoSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKLHVCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsVUFBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxnQ0FBZ0M7QUFDOUUsT0FBTSw2QkFBNkIsY0FBYztBQUNqRCxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUI7O0FBRXZCOztBQUVBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIOztBQUVBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIscU5BQXFOO0FBQzFPLDhCQUE2Qiw4REFBOEQ7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFxRSxnREFBZ0Q7O0FBRXJIO0FBQ0EsOEJBQTZCLDZDQUE2Qzs7QUFFMUU7QUFDQTs7QUFFQTs7QUFFQSw4RkFBNkYseUxBQXlMO0FBQ3RSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWEsY0FBYzs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxtQkFBbUI7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVcsaUVBQWlFO0FBQzVFLElBQUc7QUFDSCxZQUFXLDJEQUEyRDtBQUN0RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkIsK0JBQThCLG1EQUFtRCxJQUFJO0FBQ3JGLHVDQUFzQyxtREFBbUQsSUFBSTtBQUM3Riw0QkFBMkI7QUFDM0Isb0JBQW1CO0FBQ25CLGlDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsbUNBQWtDLHVCQUF1QjtBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQVksK0NBQStDOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnRUFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBVztBQUNYLElBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBVztBQUNYLElBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBVztBQUNYLElBQUc7QUFDSDtBQUNBLFlBQVc7QUFDWCxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLGFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksNkVBQTZFO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0MsdUJBQXVCLEtBQUs7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQix5Q0FBeUM7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFtRSwyQ0FBMkMsRUFBRTs7QUFFaEg7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxnQkFBZ0I7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0IsMERBQTBEO0FBQzFFOztBQUVBO0FBQ0EsaUJBQWdCLDBEQUEwRDtBQUMxRTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDs7QUFFQTtBQUNBLDhCQUE2QixnQ0FBZ0Msc0JBQXNCO0FBQ25GLFVBQVMsc0NBQXNDLGFBQWEsRUFBRSxFQUFFO0FBQ2hFLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsbUZBQWtGO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0EsNENBQTJDLHFCQUFxQixFQUFFO0FBQ2xFLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTLHdIQUF3SDtBQUNqSTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHlFQUF5RTtBQUM1RjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0IsVUFBVSxTQUFTLFVBQVU7QUFDN0MsaUJBQWdCLFVBQVUsU0FBUyxVQUFVO0FBQzdDLG9CQUFtQiwrQ0FBK0M7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsaUNBQWlDLEVBQUU7QUFDM0U7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBeUI7QUFDekI7O0FBRUEsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDLFFBQVE7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUEsbUJBQWtCLGVBQWU7O0FBRWpDO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQkFBeUIsNkRBQTZELEVBQUU7QUFDeEY7O0FBRUEsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRDs7QUFFbkQ7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsOEJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUdBQWdHLGdEQUFnRDs7QUFFaEosK0JBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9HQUFtRyx5QkFBeUI7QUFDNUg7O0FBRUEsa0NBQWlDO0FBQ2pDLG9DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsNkJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBLHlHQUF3Ryx5QkFBeUI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBOEIsUUFBUTtBQUN0QztBQUNBOztBQUVBLDhDQUE2QyxtQkFBbUI7QUFDaEU7O0FBRUEsc0RBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILHdDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IseUpBQXlKO0FBQy9LLHNCQUFxQix1SkFBdUo7QUFDNUs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0MsUUFBUTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsWUFBVztBQUNYOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0EsSUFBRzs7QUFFSCxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsaUVBQWlFLEVBQUU7QUFDNUc7QUFDQTtBQUNBLDBDQUF5QyxnREFBZ0QsRUFBRSxFQUFFO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGdEQUFnRCxFQUFFO0FBQzVGLHdDQUF1Qyx5QkFBeUIsa0RBQWtELEdBQUcsR0FBRztBQUN4SCx3Q0FBdUMseUJBQXlCLGlEQUFpRCxJQUFJLEVBQUU7QUFDdkg7QUFDQTs7O0FBR0E7QUFDQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBLHdDQUF1Qyx5QkFBeUIscURBQXFELEdBQUcsR0FBRztBQUMzSDtBQUNBO0FBQ0Esd0NBQXVDLHlCQUF5Qiw4Q0FBOEMsR0FBRyxHQUFHO0FBQ3BIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSw0QkFBNEI7QUFDekM7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVksNEJBQTRCO0FBQ3hDO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLElBQUksWUFBWSxJQUFJLFlBQVksSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRiw4QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNLGtCQUFrQjtBQUN4QjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU0scUJBQXFCO0FBQzNCO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLGlCQUFnQixrQkFBa0IsSUFBSSxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsT0FBTSxxQkFBcUI7QUFDM0I7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsWUFBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsMkJBQTBCO0FBQzFCLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEIsMkJBQTBCO0FBQzFCLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxpQkFBZ0IsdUJBQXVCO0FBQ3ZDLGlCQUFnQix1QkFBdUI7QUFDdkMsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQsRUFBQzs7QUFFRDs7QUFFQTtBQUNBLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE9BQU07QUFDTjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047O0FBRUEscURBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCLGNBQWM7QUFDOUIsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxxQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUEsaUJBQWdCLGNBQWMsb0JBQW9CLEVBQUU7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0I7QUFDdEIseUJBQXdCO0FBQ3hCLDRCQUEyQjtBQUMzQixrQ0FBaUM7QUFDakMseUJBQXdCO0FBQ3hCLHdDQUF1QztBQUN2Qyw2Q0FBNEM7QUFDNUMsNkNBQTRDO0FBQzVDLCtDQUE4QztBQUM5Qyw2Q0FBNEM7QUFDNUMsZ0RBQStDO0FBQy9DLHlEQUF3RDtBQUN4RCxtREFBa0Q7QUFDbEQsc0RBQXFEO0FBQ3JELHFCQUFvQjtBQUNwQix1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLGlFQUFnRTtBQUNoRSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdURBQXVEO0FBQ2xFO0FBQ0E7QUFDQSxPQUFNLG9EQUFvRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsYUFBYSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHVCQUF1QixFQUFFO0FBQzlDLHdCQUF1QiwyQkFBMkI7QUFDbEQsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQiwwQ0FBMEMsRUFBRSxFQUFFO0FBQ2xFLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHNCQUFzQixFQUFFO0FBQzdDLHdCQUF1QixrQ0FBa0M7QUFDekQsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQiwwQ0FBMEMsRUFBRSxFQUFFO0FBQ2xFO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE0QztBQUM1QywwQ0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQSxvQkFBbUI7QUFDbkI7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0EsSUFBRyxrREFBa0Q7QUFDckQ7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTs7QUFFQSx3RkFBdUY7QUFDdkY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQSwrQ0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQix1REFBdUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQSxxREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsaURBQWlEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF3RTtBQUN4RSxJQUFHO0FBQ0gsaUNBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxzQkFBc0IsRUFBRTtBQUN4RDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxxQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRTtBQUNqRTtBQUNBLGtFQUFpRTtBQUNqRSwyREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixTQUFTLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQsMEZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSxtQkFBa0IsZ0JBQWdCLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFNBQVMsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE2RztBQUM3RztBQUNBLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUEyRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBK0Q7QUFDL0Q7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUEsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUssMkJBQTJCO0FBQ2hDO0FBQ0E7QUFDQSx1QkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0IsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsdUJBQXVCOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWSxXQUFXLFFBQVE7QUFDL0I7QUFDQTs7QUFFQSxjQUFhLFlBQVksUUFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBLGtEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQLE9BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixrQkFBaUI7QUFDakIsa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBa0MsYUFBYTtBQUMvQyxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWlDLG9CQUFvQjtBQUNyRCxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsV0FBVyxZQUFZLGdCQUFnQiwyQkFBMkIsV0FBVztBQUNwSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DLGVBQWU7QUFDbkQsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsb0JBQW9COztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsbUJBQWtCLGlDQUFpQztBQUNuRDs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdFLHlCQUF5QjtBQUN6RjtBQUNBO0FBQ0Esb0RBQW1ELCtDQUErQyxHQUFHLG9DQUFvQztBQUN6STtBQUNBLE9BQU07QUFDTjtBQUNBLGlFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBLG9EQUFtRCxnREFBZ0QsR0FBRyxvQ0FBb0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBNkQsMEJBQTBCO0FBQ3ZGO0FBQ0E7QUFDQSxpREFBZ0Qsb0NBQW9DLEdBQUcsb0NBQW9DO0FBQzNIO0FBQ0E7QUFDQSw4REFBNkQsMkJBQTJCO0FBQ3hGO0FBQ0E7QUFDQSxpREFBZ0QscUNBQXFDLEdBQUcsb0NBQW9DO0FBQzVIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUEsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLG1FQUFrRTtBQUNsRTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGlEQUFnRCxhQUFhLEVBQUU7QUFDL0QsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCLHlCQUF5QjtBQUNqRCwyQkFBMEIsMkJBQTJCOztBQUVyRDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxpQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQSxrQ0FBaUMsbUJBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBLG1DQUFrQyxtQkFBbUI7QUFDckQ7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQsRUFBQzs7Ozs7OztBQzVwZEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBK0QsdUJBQXVCLDBCQUEwQjs7QUFFaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUFzSDtBQUN0SDs7QUFFQTtBQUNBO0FBQ0Esc0VBQXFFLDhCQUE4QixFQUFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QiwwQkFBeUI7QUFDekI7QUFDQSxzQkFBcUI7QUFDckIsc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLDZDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQSx5SUFBd0ksa0JBQWtCLEVBQUU7QUFDNUo7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0Esd0NBQXVDLGtKQUFrSjs7QUFFekw7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsMkNBQTJDO0FBQ3hFLHNCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQTs7QUFFQSxvQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQStDO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsMkdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IscUNBQXFDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmLFlBQVc7QUFDWCxnQ0FBK0IsZUFBZTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQyxnQ0FBZ0MsRUFBRTtBQUNqRjs7QUFFQTtBQUNBLDhCQUE2QixlQUFlO0FBQzVDLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkIsMkNBQTBDLGtCQUFrQjtBQUM1RCxvQkFBbUI7QUFDbkI7QUFDQSxnQkFBZTtBQUNmLFlBQVc7QUFDWCxnQ0FBK0IsZUFBZTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUErQyxnQ0FBZ0MsRUFBRTtBQUNqRjs7QUFFQTtBQUNBLDhCQUE2QixlQUFlO0FBQzVDLFVBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7OztBQ2xhRCxvRSIsImZpbGUiOiJzY3JpcHRzL2luZGV4LWJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy/lhaXlj6PpobXpnaJcbnJlcXVpcmUoJy4uL2dva3VhaS5odG1sJyk7XG5cbi8vY3Nz5paH5Lu2XG5yZXF1aXJlKCdmb250LWF3ZXNvbWUvY3NzL2ZvbnQtYXdlc29tZS5jc3MnKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAuY3NzJyk7XG5yZXF1aXJlKCdhbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlci9zcmMvY3NzL2RhdGV0aW1lcGlja2VyLmNzcycpO1xucmVxdWlyZSgnLi4vc3R5bGVzL2luZGV4LnNjc3MnKTtcblxucmVxdWlyZSgnLi9na0NsaWVudENhbGxiYWNrLmpzJyk7XG5yZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4vL+esrOS4ieaWueS+nei1luaooeWdl1xucmVxdWlyZSgnZXhwb3NlPyQhZXhwb3NlP2pRdWVyeSFqcXVlcnknKTtcbnJlcXVpcmUoJ2V4cG9zZT9tb21lbnQhbW9tZW50Jyk7XG5yZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcbnJlcXVpcmUoJ2pxdWVyeS1jb250ZXh0bWVudS9kaXN0L2pxdWVyeS51aS5wb3NpdGlvbicpO1xucmVxdWlyZSgnanF1ZXJ5LWNvbnRleHRtZW51Jyk7XG5yZXF1aXJlKCdhbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlcicpO1xucmVxdWlyZSgnYW5ndWxhci1zYW5pdGl6ZScpO1xucmVxdWlyZSgnZXhwb3NlP18hdW5kZXJzY29yZScpO1xucmVxdWlyZSgnYW5ndWxhci11aS1ib290c3RyYXAnKTtcbnJlcXVpcmUoJ25nLWNvbnRleHQtbWVudS9kaXN0L25nLWNvbnRleHQtbWVudScpO1xucmVxdWlyZSgnanF1ZXJ5LXVpJyk7XG5yZXF1aXJlKCdhbmd1bGFyLWRyYWdkcm9wL3NyYy9hbmd1bGFyLWRyYWdkcm9wJyk7XG52YXIgaW8gPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG5hbmd1bGFyLm1vZHVsZSgnZ291a3VhaScsIFtcbiAgICAndWkucm91dGVyJyxcbiAgICAnTG9jYWxTdG9yYWdlTW9kdWxlJyxcbiAgICAnaW5maW5pdGUtc2Nyb2xsJyxcbiAgICAnbmdEaWFsb2cnLFxuICAgICdnZXR0ZXh0JyxcbiAgICAndWkuYm9vdHN0cmFwLmRhdGV0aW1lcGlja2VyJyxcbiAgICAnbmdTYW5pdGl6ZScsXG4gICAgJ3VpLmJvb3RzdHJhcCcsXG4gICAgJ25nLWNvbnRleHQtbWVudScsXG4gICAgJ2dvdWt1YWkuY29tbW9uJyxcbiAgICAnbmdEcmFnRHJvcCdcbl0pXG5cbiAgICAuY29uZmlnKHJlcXVpcmUoJy4vY29uZmlnL2luZGV4LmNvbmZpZycpKVxuXG4gICAgLnJ1bihbJ2drTW91bnQnLCckdGltZW91dCcsJ2xvY2FsU3RvcmFnZVNlcnZpY2UnLCAnJHJvb3RTY29wZScsICdna0FwaScsICckcScsJyRsb2NhdGlvbicsJyRzdGF0ZVBhcmFtcycsJyRzdGF0ZScsZnVuY3Rpb24oZ2tNb3VudCwkdGltZW91dCxsb2NhbFN0b3JhZ2VTZXJ2aWNlLCAkcm9vdFNjb3BlLCBna0FwaSwgJHEsICRsb2NhdGlvbiwkc3RhdGVQYXJhbXMsJHN0YXRlKSB7XG5cbiAgICAgICAgbW9tZW50LmxvY2FsZSgnemgtY24nKTtcblxuICAgICAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQsdG9TdGF0ZSx0b1BhcmFtKXtcbiAgICAgICAgICAgIGlmKHRvUGFyYW0gJiYgdG9QYXJhbS5tb3VudGlkKXtcbiAgICAgICAgICAgICAgICB2YXIgbW91bnQgPSBna01vdW50LmdldE1vdW50QnlJZCh0b1BhcmFtLm1vdW50aWQpO1xuICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnJHN0YXRlQ2hhbmdlU3RhcnQ6bW91bnQnLG1vdW50KTtcbiAgICAgICAgICAgICAgICBpZighbW91bnQpe1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2luZGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvL+aWh+S7tuWIl+ihqOm7mOiupOaOkuW6j1xuICAgICAgICB2YXIgZmlsZU9yZGVyID0gbG9jYWxTdG9yYWdlU2VydmljZS5nZXQoJ2ZpbGVPcmRlcicpO1xuICAgICAgICBpZiAoIWZpbGVPcmRlcikgbG9jYWxTdG9yYWdlU2VydmljZS5zZXQoJ2ZpbGVPcmRlcicsIFsnLWRpcicsICcrZmlsZW5hbWUnXSk7XG5cbiAgICAgICAgLy/liJ3lp4vljJblupNcbiAgICAgICAgJHJvb3RTY29wZS5QQUdFX0NPTkZJRyA9IHtcbiAgICAgICAgICAgIHZpZXc6ICcnLCAvL+mhtemdouinhuWbvlxuICAgICAgICAgICAgbGlzdFZpZXc6ICdsaXN0JyAvL+aWh+S7tuWIl+ihqOinhuWbvlxuICAgICAgICB9O1xuXG4gICAgICAgIGdrQXBpLmVudEluZm8oKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbnRzID0gZGF0YSAmJiBkYXRhLmxpc3Q7XG4gICAgICAgICAgICBpZiAoZW50cyAmJiBlbnRzLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5QQUdFX0NPTkZJRy5lbnRzID0gZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy/nqpflj6Pmi5bmi71cbiAgICAgICAgJChkb2N1bWVudCkub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdkcm9wJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vc29ja2V05aSE55CGXG4gICAgICAgIHZhciB1c2VyLFxuICAgICAgICAgICAgc29ja2V0ZGF0ZSxcbiAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgc2VydmVyLFxuICAgICAgICAgICAgc29ja2V0VXJsLFxuICAgICAgICAgICAgY29udGFjdHNVcmwsXG4gICAgICAgICAgICBsYXN0ZGF0ZTtcblxuICAgICAgICBpbml0U29ja2V0KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNvY2tldCgpIHtcbiAgICAgICAgICAgICRxLmFsbChbZ2tBcGkuZ2V0VXNlckluZm8oKSwgZ2tBcGkuZ2V0U29ja2V0RGF0ZSgpLCBna0FwaS5nZXRTb2NrZXRTZXJ2ZXIoKV0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnaW5pdFNvY2tldCcsZGF0YSk7XG4gICAgICAgICAgICAgICAgdXNlciA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgc29ja2V0ZGF0ZSA9IGRhdGFbMV0gJiYgZGF0YVsxXS5kYXRlbGluZTtcbiAgICAgICAgICAgICAgICBjYWNoZUtleSA9IHVzZXIudXVpZCArICdfc29ja2V0ZGF0ZSc7XG4gICAgICAgICAgICAgICAgc2VydmVyID0gZGF0YVsyXVswXTtcbiAgICAgICAgICAgICAgICBzb2NrZXRVcmwgPSAnaHR0cDovLycgKyBzZXJ2ZXIuaG9zdCArICc6JyArIHNlcnZlci5wb3J0ICsgJy9kaWFsb2cnO1xuICAgICAgICAgICAgICAgIGNvbnRhY3RzVXJsID0gJ2h0dHA6Ly8nICsgc2VydmVyLmhvc3QgKyAnOicgKyBzZXJ2ZXIucG9ydCArICcvY29udGFjdHMnO1xuXG4gICAgICAgICAgICAgICAgZ2tBcGkuZ2V0Q2FjaGUoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFNvY2tldERhdGEoY29udGFjdHNVcmwsIGRhdGEpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ZGF0ZSA9IGxhc3RkYXRlID8gbGFzdGRhdGUgOiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2tBcGkuYWRkQ2FjaGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxhc3RkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0U29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRTb2NrZXREYXRhKGNvbnRhY3RzVXJsLCBzb2NrZXRkYXRlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdGRhdGUgPSBsYXN0ZGF0ZSA/IGxhc3RkYXRlIDogc29ja2V0ZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdrQXBpLmFkZENhY2hlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsYXN0ZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zb2NrZXQuaW/lh7rplJnlkI7ph43mlrDlsJ3or5XnmoTmrKHmlbBcbiAgICAgICAgdmFyIHJlY29ubmVjdENvdW50ID0gMDtcblxuICAgICAgICAvL+WmguaenOe9kee7nOmHjeaWsOi/nuaOpeS4iuWwhumHjeivleasoeaVsOe9ruS4ujBcbiAgICAgICAgJHJvb3RTY29wZS4kb24oJ0xpbmtTdGF0dXMnLGZ1bmN0aW9uKGV2ZW50LGRhdGEpe1xuICAgICAgICAgICAgaWYoZGF0YS5saW5rID09IDEgJiYgcmVjb25uZWN0Q291bnQgPiAwKXtcbiAgICAgICAgICAgICAgICByZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbm5lY3RTb2NrZXQoZm9yY2VOZXcpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0ZWxpbmU6IGxhc3RkYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2tBcGkuYWpheEhlbHBlcigpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRva2VuID0gZGF0YVswXTtcblxuICAgICAgICAgICAgICAgIGdrQXBpLmdldEFwaUF1dGhvcml6YXRpb24ocGFyYW1zKS50aGVuKGZ1bmN0aW9uKHNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNpZ24gPSBzaWduO1xuXG4gICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnc29ja2V0OmNvbm5lY3Q6cHJlcGFyZTpwYXJhbXMnLHBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2tBcGkuY2hlY2tBdXRoUHJveHkoKS50aGVuKGZ1bmN0aW9uKGlzU2V0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAkLnBhcmFtKHBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VOZXc6IGFuZ3VsYXIuaXNEZWZpbmVkKGZvcmNlTmV3KSA/IGZvcmNlTmV3IDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0aW9uRGVsYXk6MjAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3Rpb25EZWxheU1heDoxMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OjMwMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WmguaenOiuvue9ruS6huS7o+eQhixzb2NrZXQuaW8g55qEIHRyYW5zcG9ydCDkvJjlhYggeGhyLXBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBpc1NldCA9PT0gJ3VuZGVmaW5lZCd8fCBpc1NldCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnRyYW5zcG9ydHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd4aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdqc29ucC1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BvbGxpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5Mb2cubG9nKCdzb2NrZXQ6Y29ubmVjdDppbml0Om9wdHMnLG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLlBBR0VfQ09ORklHLnNvY2tldCA9IGlvLmNvbm5lY3Qoc29ja2V0VXJsLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuUEFHRV9DT05GSUcuc29ja2V0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnc29ja2V0OmNvbm5lY3RlZCcsZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5QQUdFX0NPTkZJRy5zb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLkxvZy5sb2coJ3NvY2tldDpjb25uZWN0OmVycm9yJyxlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLlBBR0VfQ09ORklHLnNvY2tldC5vbignY29ubmVjdF90aW1lb3V0JyxmdW5jdGlvbihlcnJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5Mb2cubG9nKCdzb2NrZXQ6Y29ubmVjdDp0aW1lb3V0JyxlcnJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLlBBR0VfQ09ORklHLnNvY2tldC5vbigncmVjb25uZWN0X2Vycm9yJywgZnVuY3Rpb24oZXJycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnc29ja2V0OnJlY29ubmVjdDplcnJvcicsZXJycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5QQUdFX0NPTkZJRy5zb2NrZXQub24oJ2NvbnRhY3QnLCBmdW5jdGlvbihyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLkxvZy5sb2coJ3NvY2tldDpjb250YWN0OnJlY2VpdmVkJyxyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RkYXRlID0gcmV0LmRhdGVsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJldC5hY3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBna0NsaWVudC5nU29ja2V0QWN0aW9uKEpTT04uc3RyaW5naWZ5KHJldCksZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFsnYWRkX2VudF9yb2xlJywnbW9kaWZ5X2VudF9yb2xlJywnZGVsX2VudF9yb2xlJ10uaW5kZXhPZihyZXQuYWN0KSA+PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLkxvZy5sb2cocmV0LmFjdCArICcgYnJvYWRjYXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KHJldC5hY3QscmV0Lm1ldGFkYXRhfHx7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihbJ2pvaW5fb3JnJywncXVpdF9vcmcnXS5pbmRleE9mKHJldC5hY3QpID49IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJldC5tZXRhZGF0YSAmJiAkc3RhdGVQYXJhbXMubW91bnRpZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TW91bnQgPSBna01vdW50LmdldE1vdW50QnlJZCgkc3RhdGVQYXJhbXMubW91bnRpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRNb3VudCAmJiBjdXJyZW50TW91bnQub3JnaWQgPT0gcmV0Lm1ldGFkYXRhLm9yZ19pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hNZW1iZXJDb3VudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBna0FwaS5hZGRDYWNoZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShyZXQuZGF0ZWxpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5QQUdFX0NPTkZJRy5zb2NrZXQub24oJ2VycicsIGZ1bmN0aW9uKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnc29ja2V0OmVycicscmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JjZU5ldyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6YeN5paw5bCd6K+V6L+e5o6l55qE6Ze06ZqU5oyJMeenkumAkuWinlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnc29ja2V0OnJlY29ubmVjdGlubmcnLHJlY29ubmVjdENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFNvY2tldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LDEwMDAgKyAxMDAwICogcmVjb25uZWN0Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNvY2tldERhdGEodXJsLCBkYXRlbGluZSwgZGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0U2l6ZSA9IDEwMDA7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGVsaW5lOiBkYXRlbGluZSB8fCBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIHNpemU6IGRlZmF1bHRTaXplXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmZXJyZWQgPSBkZWZlcnJlZCB8fCAkcS5kZWZlcigpO1xuICAgICAgICAgICAgZ2tBcGkuYWpheEhlbHBlcigpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy50b2tlbiA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgZ2tBcGkuZ2V0QXBpQXV0aG9yaXphdGlvbihwYXJhbXMpLnRoZW4oZnVuY3Rpb24oc2lnbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc2lnbiA9IHNpZ247XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhICYmIGRhdGEubGlzdCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBna0NsaWVudC5nU29ja2V0QWN0aW9uKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAnbGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ZGF0ZSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5kYXRlbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U29ja2V0RGF0YSh1cmwsIGxhc3RkYXRlLCBkZWZlcnJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfV0pXG4gICAgLmNvbnRyb2xsZXIoJ2luaXRDdHJsJywgWyduZ0RpYWxvZycsJ2drQXBpJywnJHNjb3BlJywgJyRyb290U2NvcGUnLCAnJHN0YXRlJywgJ2drRmlsZScsICdna01vdW50JywnJHdpbmRvdycsJyR0aW1lb3V0JywnZ2tNb2RhbCcsIGZ1bmN0aW9uKG5nRGlhbG9nLGdrQXBpLCAkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgZ2tGaWxlLCBna01vdW50LCR3aW5kb3csJHRpbWVvdXQsZ2tNb2RhbCkge1xuXG5cbiAgICAgICAgJHNjb3BlLmJvZHlDbGljayA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdib2R5Q2xpY2tlZCcsZSk7XG4gICAgICAgICAgICBpZighJChlLnRhcmdldCkuY2xvc2VzdCgnLmNvbnRleHQtbWVudS1pdGVtJykuc2l6ZSgpKXtcbiAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2VDbG91ZENvbW1lbnRQYW5lbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgICRzY29wZS4kb24oJ2Nsb3NlQ2xvdWRDb21tZW50UGFuZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiB0b3Aud2luZG93LnVjLm1vZHVsZXMuY2xvdWQuQ2xvdWRNYW5hZ2VyLk9uQ2xvdWRIaWRlQ29tbWVudCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAgdG9wLndpbmRvdy51Yy5tb2R1bGVzLmNsb3VkLkNsb3VkTWFuYWdlci5PbkNsb3VkSGlkZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy/mlofku7blj5jmm7TvvIzlrqLmiLfnq6/pgJrnn6VcbiAgICAgICAgJHNjb3BlLiRvbignVXBkYXRlRmlsZUxpc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRzdGF0ZS5yZWxvYWQoJ2luZGV4LmZpbGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdrRmlsZS5jbGVhclNlbGVjdGVkRmlsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgT3Blbk1vdW50UGF0aENhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSxtb3VudCl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NsZWFyTW91bnRTZWFyY2gnKTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciAkbW91bnRJdGVtcyA9ICQoJy5tb3VudC1saXN0LXdyYXBwZXIgbGknKTtcbiAgICAgICAgICAgICAgICB2YXIgJHdyYXBwZXIgPSAkKCcubW91bnQtd3JhcHBlcicpO1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVySGVpZ2h0ID0gJHdyYXBwZXIub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEl0ZW07XG5cbiAgICAgICAgICAgICAgICAkd3JhcHBlci5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRtb3VudEl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQ9ICQoaXRlbSkuZGF0YSgnaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09IGRhdGEubW91bnRpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY3JvbGxJdGVtID0gJG1vdW50SXRlbXMuZXEocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgPSBzY3JvbGxJdGVtLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFRvcCA+IHdyYXBwZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR3cmFwcGVyLnNjcm9sbFRvcChvZmZzZXRUb3AgLSA1MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihkYXRhLmNyZWF0ZSl7XG4gICAgICAgICAgICAgICAgICAgIG5nRGlhbG9nLmNsb3NlQWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGdrTW9kYWwuYWRkTGliTWVtYmVyKG1vdW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgICAgIGdrRmlsZS5nZXRGaWxlSW5mbyh7XG4gICAgICAgICAgICAgICAgbW91bnRpZDogZGF0YS5tb3VudGlkLFxuICAgICAgICAgICAgICAgIGZ1bGxwYXRoOiBVdGlsLlN0cmluZy5ydHJpbShkYXRhLndlYnBhdGgsJy8nKVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEaXIgPSBVdGlsLlN0cmluZy5sYXN0Q2hhcihkYXRhLndlYnBhdGgpID09PSAnLyc7XG4gICAgICAgICAgICAgICAgdmFyIGdvVG9QYXRoID0gJycsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkaGFzaCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmKGlzRGlyKXtcbiAgICAgICAgICAgICAgICAgICAgZ29Ub1BhdGggPSBVdGlsLlN0cmluZy5ydHJpbShkYXRhLndlYnBhdGgsJy8nKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZ29Ub1BhdGggPSBna0ZpbGUuZ2V0RGlyTmFtZShyZXQucGF0aCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkaGFzaCA9IHJldC51dWlkaGFzaCB8fCAnJ1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnaW5kZXguZmlsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRpZDogZGF0YS5tb3VudGlkLFxuICAgICAgICAgICAgICAgICAgICBmdWxscGF0aDogZW5jb2RlVVJJQ29tcG9uZW50KGdvVG9QYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgdmlldzogJ21vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogMSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRoYXNoOiBlbmNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWRoYXNoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAkc2NvcGUuJG9uKCdPcGVuTW91bnRQYXRoJywgZnVuY3Rpb24oJGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBVdGlsLkxvZy5sb2coJ09wZW5Nb3VudFBhdGg6cmVjZWl2ZWQnLGRhdGEpO1xuICAgICAgICAgICAgJCgnLm1vdW50LW5hbWUnKS5yZW1vdmVDbGFzcygnb3BlbicpO1xuICAgICAgICAgICAgdmFyIG1vdW50ID0gZ2tNb3VudC5nZXRNb3VudEJ5SWQoZGF0YS5tb3VudGlkKTtcbiAgICAgICAgICAgIGlmICghbW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLmNyZWF0ZSA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBna0FwaS5ub3RpY2Uoe3R5cGU6ICdnZXRNb3VudCcsICdtb3VudF9pZCc6IE51bWJlcihkYXRhLm1vdW50aWQpfSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgT3Blbk1vdW50UGF0aENhbGxiYWNrKGRhdGEsbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICB9LGZ1bmN0aW9uKHJlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwuTG9nLmxvZygnZ2tBcGk6bm90aWNlOnJlamVjdCcscmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBPcGVuTW91bnRQYXRoQ2FsbGJhY2soZGF0YSxtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy90b3Aud2luZG93LnVjLklVSVNlcnZpY2UuYmluZENyb3NzV2luZG93RXZlbnQoJ2dvdWt1YWlQcmV2aWV3JywgZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgICAgIC8vICAgIGNvbnNvbGUubG9nKGV2ZW50RGF0YSk7XG4gICAgICAgIC8vfSk7XG4gICAgfV0pXG5cbiAgICAuY29udHJvbGxlcignZmlsZUN0cmwnLCByZXF1aXJlKCcuL2NvbnRyb2xsZXIvZmlsZUN0cmwnKSlcbiAgICAuY29udHJvbGxlcignZmlsZUhlYWRlckN0cmwnLCByZXF1aXJlKCcuL2NvbnRyb2xsZXIvZmlsZUhlYWRlckN0cmwnKSlcbiAgICAuY29udHJvbGxlcignZmlsZUJyZWFkQ3RybCcsIHJlcXVpcmUoJy4vY29udHJvbGxlci9maWxlQnJlYWRDdHJsJykpXG4gICAgLmNvbnRyb2xsZXIoJ2ZpbGVUb29sYmFyQ3RybCcsIHJlcXVpcmUoJy4vY29udHJvbGxlci9maWxlVG9vbGJhckN0cmwnKSlcbiAgICAuY29udHJvbGxlcignZmlsZUxpc3RDdHJsJywgcmVxdWlyZSgnLi9jb250cm9sbGVyL2ZpbGVMaXN0Q3RybCcpKVxuICAgIC5jb250cm9sbGVyKCdtZW1iZXJDdHJsJywgcmVxdWlyZSgnLi9jb250cm9sbGVyL21lbWJlckN0cmwnKSlcblxuICAgIC5kaXJlY3RpdmUoJ2ZpbGVTZWxlY3QnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZS9maWxlU2VsZWN0JykpXG4gICAgLmRpcmVjdGl2ZSgnZ2tDb250ZXh0bWVudScsIHJlcXVpcmUoJy4vZGlyZWN0aXZlL2drQ29udGV4dG1lbnUnKSlcbiAgICAuZGlyZWN0aXZlKCdkcm9wVXBsb2FkJywgcmVxdWlyZSgnLi9kaXJlY3RpdmUvZHJvcFVwbG9hZCcpKVxuICAgIC5kaXJlY3RpdmUoJ21lbWJlckF2YXRhcicsIHJlcXVpcmUoJy4vZGlyZWN0aXZlL21lbWJlckF2YXRhcicpKVxuICAgIC5mYWN0b3J5KCdna0kxOE4nLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tJMThOJykpXG4gICAgLmZhY3RvcnkoJ2drTW91bnQnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tNb3VudCcpKVxuICAgIC5mYWN0b3J5KCdna0ZpbGUnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tGaWxlJykpXG4gICAgLmZhY3RvcnkoJ2drSW1hZ2UnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tJbWFnZScpKVxuICAgIC5mYWN0b3J5KCdna01lbnUnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tNZW51JykpXG4gICAgLmZhY3RvcnkoJ2drRmlsZVRwbCcsIHJlcXVpcmUoJy4vc2VydmljZS9na0ZpbGVUcGwnKSlcbiAgICAuZmFjdG9yeSgnZ2tDbGlwYm9hcmQnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tDbGlwYm9hcmQnKSlcbiAgICAuZmFjdG9yeSgnZ2tNb2RhbCcsIHJlcXVpcmUoJy4vc2VydmljZS9na01vZGFsJykpXG4gICAgLmZhY3RvcnkoJ2drUXMnLCByZXF1aXJlKCcuL3NlcnZpY2UvcXVhbnNoaScpKVxuICAgIC5mYWN0b3J5KCdna01vdW50TWVudScsIHJlcXVpcmUoJy4vc2VydmljZS9na01vdW50TWVudScpKVxuICAgIC5mYWN0b3J5KCdna0RpYWxvZycsIHJlcXVpcmUoJy4vc2VydmljZS9na0RpYWxvZycpKVxuICAgIC5mYWN0b3J5KCdna0ZpbGVDbWQnLCByZXF1aXJlKCcuL3NlcnZpY2UvZ2tGaWxlQ21kJykpXG4gICAgLmZhY3RvcnkoJ2drTm90ZUVkaXRvcicscmVxdWlyZSgnLi9zZXJ2aWNlL2drTm90ZUVkaXRvcicpKVxuICAgIC5kaXJlY3RpdmUoJ2Vycm9yU3JjJywgW2Z1bmN0aW9uKCkge1xuICAgICAgICBVdGlsLkxvZy5sb2coJ2Vycm9yU3JjJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY29wZToge30sXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbGVtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5hdHRyKCdzcmMnLCByZXF1aXJlKCcuLi9pbWFnZXMvZGVmYXVsdF9sb2dvLnBuZycpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSlcbiAgICAuZGlyZWN0aXZlKCdrZXlib2FyZFNob3J0Y3V0JywgcmVxdWlyZSgnLi9kaXJlY3RpdmUva2V5Ym9hcmRTaG9ydGN1dCcpKVxuICAgIC5kaXJlY3RpdmUoJ2ZpbGVDb2xSZXNpemVyJywgcmVxdWlyZSgnLi9kaXJlY3RpdmUvZmlsZUNvbFJlc2l6ZXInKSlcbjtcbi8v5omL5Yqo5ZCv5YqoYW5ndWxhclxuVXRpbC5Mb2cubG9nKCdkb2N1bWVudCcsJ3JlZ2lzdEV2ZW50Jyk7XG5hbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIFV0aWwuTG9nLmxvZygnZG9jdW1lbnQnLCdyZWFkeScpO1xuICAgIGdrQ2xpZW50LmdTZXRMYXVuY2hwYWQoKTtcbiAgICB2YXIgb25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuICAgICAgICBhbmd1bGFyLmJvb3RzdHJhcChkb2N1bWVudCwgWydnb3VrdWFpJ10pO1xuICAgICAgICB0b3Aud2luZG93LnVjLm1vZHVsZXMuY2xvdWQuQ2xvdWRNYW5hZ2VyLk9uR0tMb2FkQ29tcGxldGUoKTtcbiAgICAgICAgVXRpbC5Mb2cubG9nKCdnb3VrdWFpOmFwcCcsJ2Jvb3RzdHJhcCcpO1xuICAgIH07XG5cbiAgICAvL+WIpOaWreWuouaIt+err+aVsOaNruWKoOi9veWujOavlVxuICAgIGdrQ2xpZW50SW50ZXJmYWNlLm5lZWRMb2FkaW5nKGZ1bmN0aW9uKHJlKSB7XG4gICAgICAgIFV0aWwuTG9nLmxvZygnbmVlZExvYWRpbmc6cmUnLHJlKTtcbiAgICAgICAgaWYgKHJlID09IDApIHtcbiAgICAgICAgICAgIG9uTG9hZENvbXBsZXRlKCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KHdpbmRvdy50b3AuZG9jdW1lbnQpLm9uKCdMb2FkQ29tcGxldGUnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgVXRpbC5Mb2cubG9nKCdMb2FkQ29tcGxldGUnLCdyZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIG9uTG9hZENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDJcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcIl9cIl0gPSByZXF1aXJlKFwiLSEvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qc1wiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2V4cG9zZS1sb2FkZXI/XyEvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyIDMgNCA1IDYgN1xuICoqLyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyIDMgNCA1IDYgN1xuICoqLyIsInJlcXVpcmUoJy4vdWktYm9vdHN0cmFwLXRwbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gJ3VpLmJvb3RzdHJhcCc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyIDNcbiAqKi8iLCIvKlxuICogYW5ndWxhci11aS1ib290c3RyYXBcbiAqIGh0dHA6Ly9hbmd1bGFyLXVpLmdpdGh1Yi5pby9ib290c3RyYXAvXG5cbiAqIFZlcnNpb246IDAuMTQuMyAtIDIwMTUtMTAtMjNcbiAqIExpY2Vuc2U6IE1JVFxuICovXG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcFwiLCBbXCJ1aS5ib290c3RyYXAudHBsc1wiLCBcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVwiLFwidWkuYm9vdHN0cmFwLmFjY29yZGlvblwiLFwidWkuYm9vdHN0cmFwLmFsZXJ0XCIsXCJ1aS5ib290c3RyYXAuYnV0dG9uc1wiLFwidWkuYm9vdHN0cmFwLmNhcm91c2VsXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBhcnNlclwiLFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duXCIsXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFwiLFwidWkuYm9vdHN0cmFwLm1vZGFsXCIsXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblwiLFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcIixcInVpLmJvb3RzdHJhcC5wb3BvdmVyXCIsXCJ1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXJcIixcInVpLmJvb3RzdHJhcC5yYXRpbmdcIixcInVpLmJvb3RzdHJhcC50YWJzXCIsXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFwiXSk7XG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC50cGxzXCIsIFtcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIixcInRlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsXCJ0ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIixcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIixcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcInRlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiXSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNvbGxhcHNlJywgW10pXG5cbiAgLmRpcmVjdGl2ZSgndWliQ29sbGFwc2UnLCBbJyRhbmltYXRlJywgJyRpbmplY3RvcicsIGZ1bmN0aW9uKCRhbmltYXRlLCAkaW5qZWN0b3IpIHtcbiAgICB2YXIgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpID8gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBmdW5jdGlvbiBleHBhbmQoKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICBhZGRDbGFzczogJ2luJyxcbiAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZScsXG4gICAgICAgICAgICAgIHRvOiB7IGhlaWdodDogZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKyAncHgnIH1cbiAgICAgICAgICAgIH0pLnN0YXJ0KCkuZmluYWxseShleHBhbmREb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgJ2luJywge1xuICAgICAgICAgICAgICB0bzogeyBoZWlnaHQ6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4JyB9XG4gICAgICAgICAgICB9KS50aGVuKGV4cGFuZERvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZERvbmUoKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgICAgIC5jc3Moe2hlaWdodDogJ2F1dG8nfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb2xsYXBzZSgpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlJykgJiYgIWVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXBzZURvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSBoZWlnaHQgbXVzdCBiZSBzZXQgYmVmb3JlIGFkZGluZyBcImNvbGxhcHNpbmdcIiBjbGFzcy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYW5pbWF0ZSBmcm9tIGhlaWdodCAwIChpblxuICAgICAgICAgICAgLy8gY29sbGFwc2luZyBjbGFzcykgdG8gdGhlIGdpdmVuIGhlaWdodCBoZXJlLlxuICAgICAgICAgICAgLmNzcyh7aGVpZ2h0OiBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCd9KVxuICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGFsbCBwYW5lbCBjb2xsYXBzZSBoYXZlIHRoZSBjb2xsYXBzZSBjbGFzcywgdGhpcyByZW1vdmFsXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyB0aGUgYW5pbWF0aW9uIGZyb20ganVtcGluZyB0byBjb2xsYXBzZWQgc3RhdGVcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzczogJ2luJyxcbiAgICAgICAgICAgICAgdG86IHtoZWlnaHQ6ICcwJ31cbiAgICAgICAgICAgIH0pLnN0YXJ0KCkuZmluYWxseShjb2xsYXBzZURvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCAnaW4nLCB7XG4gICAgICAgICAgICAgIHRvOiB7aGVpZ2h0OiAnMCd9XG4gICAgICAgICAgICB9KS50aGVuKGNvbGxhcHNlRG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2VEb25lKCkge1xuICAgICAgICAgIGVsZW1lbnQuY3NzKHtoZWlnaHQ6ICcwJ30pOyAvLyBSZXF1aXJlZCBzbyB0aGF0IGNvbGxhcHNlIHdvcmtzIHdoZW4gYW5pbWF0aW9uIGlzIGRpc2FibGVkXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kd2F0Y2goYXR0cnMudWliQ29sbGFwc2UsIGZ1bmN0aW9uKHNob3VsZENvbGxhcHNlKSB7XG4gICAgICAgICAgaWYgKHNob3VsZENvbGxhcHNlKSB7XG4gICAgICAgICAgICBjb2xsYXBzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBhbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuLyogRGVwcmVjYXRlZCBjb2xsYXBzZSBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNvbGxhcHNlJylcblxuICAudmFsdWUoJyRjb2xsYXBzZVN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4gIC5kaXJlY3RpdmUoJ2NvbGxhcHNlJywgWyckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJGxvZycsICckY29sbGFwc2VTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkYW5pbWF0ZSwgJGluamVjdG9yLCAkbG9nLCAkY29sbGFwc2VTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICB2YXIgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpID8gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBpZiAoISRjb2xsYXBzZVN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybignY29sbGFwc2UgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItY29sbGFwc2UgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZCgpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICAgICAgICB0bzogeyBoZWlnaHQ6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4JyB9XG4gICAgICAgICAgICB9KS5zdGFydCgpLmRvbmUoZXhwYW5kRG9uZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLmFuaW1hdGUoZWxlbWVudCwge30sIHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCdcbiAgICAgICAgICAgIH0pLnRoZW4oZXhwYW5kRG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UgaW4nKVxuICAgICAgICAgICAgLmNzcyh7aGVpZ2h0OiAnYXV0byd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxhcHNlKCkge1xuICAgICAgICAgIGlmICghZWxlbWVudC5oYXNDbGFzcygnY29sbGFwc2UnKSAmJiAhZWxlbWVudC5oYXNDbGFzcygnaW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxhcHNlRG9uZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogVGhlIGhlaWdodCBtdXN0IGJlIHNldCBiZWZvcmUgYWRkaW5nIFwiY29sbGFwc2luZ1wiIGNsYXNzLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhbmltYXRlIGZyb20gaGVpZ2h0IDAgKGluXG4gICAgICAgICAgICAvLyBjb2xsYXBzaW5nIGNsYXNzKSB0byB0aGUgZ2l2ZW4gaGVpZ2h0IGhlcmUuXG4gICAgICAgICAgICAuY3NzKHtoZWlnaHQ6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4J30pXG4gICAgICAgICAgICAvLyBpbml0aWFsbHkgYWxsIHBhbmVsIGNvbGxhcHNlIGhhdmUgdGhlIGNvbGxhcHNlIGNsYXNzLCB0aGlzIHJlbW92YWxcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBqdW1waW5nIHRvIGNvbGxhcHNlZCBzdGF0ZVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZSBpbicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHRvOiB7aGVpZ2h0OiAnMCd9XG4gICAgICAgICAgICB9KS5zdGFydCgpLmRvbmUoY29sbGFwc2VEb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUuYW5pbWF0ZShlbGVtZW50LCB7fSwge1xuICAgICAgICAgICAgICBoZWlnaHQ6ICcwJ1xuICAgICAgICAgICAgfSkudGhlbihjb2xsYXBzZURvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxhcHNlRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LmNzcyh7aGVpZ2h0OiAnMCd9KTsgLy8gUmVxdWlyZWQgc28gdGhhdCBjb2xsYXBzZSB3b3JrcyB3aGVuIGFuaW1hdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLmNvbGxhcHNlLCBmdW5jdGlvbihzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgIGlmIChzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgICAgY29sbGFwc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwYW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWNjb3JkaW9uJywgWyd1aS5ib290c3RyYXAuY29sbGFwc2UnXSlcblxuLmNvbnN0YW50KCd1aWJBY2NvcmRpb25Db25maWcnLCB7XG4gIGNsb3NlT3RoZXJzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignVWliQWNjb3JkaW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICd1aWJBY2NvcmRpb25Db25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgYWNjb3JkaW9uQ29uZmlnKSB7XG4gIC8vIFRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgdGhlIGFjY29yZGlvbiBncm91cHNcbiAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIGdyb3VwcyBpbiB0aGlzIGFjY29yZGlvbiBhcmUgY2xvc2VkLCB1bmxlc3MgY2xvc2Utb3RoZXJzIGV4cGxpY2l0bHkgc2F5cyBub3QgdG9cbiAgdGhpcy5jbG9zZU90aGVycyA9IGZ1bmN0aW9uKG9wZW5Hcm91cCkge1xuICAgIHZhciBjbG9zZU90aGVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5jbG9zZU90aGVycykgP1xuICAgICAgJHNjb3BlLiRldmFsKCRhdHRycy5jbG9zZU90aGVycykgOiBhY2NvcmRpb25Db25maWcuY2xvc2VPdGhlcnM7XG4gICAgaWYgKGNsb3NlT3RoZXJzKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCAhPT0gb3Blbkdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIHRvIGFkZCBpdHNlbGYgdG8gdGhlIGFjY29yZGlvblxuICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBTY29wZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmdyb3Vwcy5wdXNoKGdyb3VwU2NvcGUpO1xuXG4gICAgZ3JvdXBTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoYXQucmVtb3ZlR3JvdXAoZ3JvdXBTY29wZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB3aGVuIHRvIHJlbW92ZSBpdHNlbGZcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5ncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbn1dKVxuXG4vLyBUaGUgYWNjb3JkaW9uIGRpcmVjdGl2ZSBzaW1wbHkgc2V0cyB1cCB0aGUgZGlyZWN0aXZlIGNvbnRyb2xsZXJcbi8vIGFuZCBhZGRzIGFuIGFjY29yZGlvbiBDU1MgY2xhc3MgdG8gaXRzZWxmIGVsZW1lbnQuXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb24nLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiAnVWliQWNjb3JkaW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYWNjb3JkaW9uJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWwnO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIGluZGljYXRlcyBhIGJsb2NrIG9mIGh0bWwgdGhhdCB3aWxsIGV4cGFuZCBhbmQgY29sbGFwc2UgaW4gYW4gYWNjb3JkaW9uXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb25Hcm91cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedWliQWNjb3JkaW9uJywgICAgICAgICAvLyBXZSBuZWVkIHRoaXMgZGlyZWN0aXZlIHRvIGJlIGluc2lkZSBhbiBhY2NvcmRpb25cbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgICAgICAgICAgICAgLy8gSXQgdHJhbnNjbHVkZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RpdmUgaW50byB0aGUgdGVtcGxhdGVcbiAgICByZXBsYWNlOiB0cnVlLCAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmUgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSB0ZW1wbGF0ZVxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGhlYWRpbmc6ICdAJywgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZSB0aGUgaGVhZGluZyBhdHRyaWJ1dGUgb250byB0aGlzIHNjb3BlXG4gICAgICBpc09wZW46ICc9PycsXG4gICAgICBpc0Rpc2FibGVkOiAnPT8nXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFjY29yZGlvbkN0cmwpIHtcbiAgICAgIGFjY29yZGlvbkN0cmwuYWRkR3JvdXAoc2NvcGUpO1xuXG4gICAgICBzY29wZS5vcGVuQ2xhc3MgPSBhdHRycy5vcGVuQ2xhc3MgfHwgJ3BhbmVsLW9wZW4nO1xuICAgICAgc2NvcGUucGFuZWxDbGFzcyA9IGF0dHJzLnBhbmVsQ2xhc3M7XG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3Moc2NvcGUub3BlbkNsYXNzLCAhIXZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS50b2dnbGVPcGVuID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICghc2NvcGUuaXNEaXNhYmxlZCkge1xuICAgICAgICAgIGlmICghJGV2ZW50IHx8ICRldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9ICFzY29wZS5pc09wZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFVzZSBhY2NvcmRpb24taGVhZGluZyBiZWxvdyBhbiBhY2NvcmRpb24tZ3JvdXAgdG8gcHJvdmlkZSBhIGhlYWRpbmcgY29udGFpbmluZyBIVE1MXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb25IZWFkaW5nJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNjbHVkZTogdHJ1ZSwgICAvLyBHcmFiIHRoZSBjb250ZW50cyB0byBiZSB1c2VkIGFzIHRoZSBoZWFkaW5nXG4gICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBJbiBlZmZlY3QgcmVtb3ZlIHRoaXMgZWxlbWVudCFcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdedWliQWNjb3JkaW9uR3JvdXAnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgYWNjb3JkaW9uR3JvdXBDdHJsLCB0cmFuc2NsdWRlKSB7XG4gICAgICAvLyBQYXNzIHRoZSBoZWFkaW5nIHRvIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlclxuICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgdHJhbnNjbHVkZWQgaW50byB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAvLyBbVGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gdHJhbnNjbHVkZSBjYXVzZXMgdGhlIGVsZW1lbnRzIHRvIGJlIGNsb25lZCBzbyB0aGF0IHRoZXkgd29yayBpbiBuZy1yZXBlYXRdXG4gICAgICBhY2NvcmRpb25Hcm91cEN0cmwuc2V0SGVhZGluZyh0cmFuc2NsdWRlKHNjb3BlLCBhbmd1bGFyLm5vb3ApKTtcbiAgICB9XG4gIH07XG59KVxuXG4vLyBVc2UgaW4gdGhlIGFjY29yZGlvbi1ncm91cCB0ZW1wbGF0ZSB0byBpbmRpY2F0ZSB3aGVyZSB5b3Ugd2FudCB0aGUgaGVhZGluZyB0byBiZSB0cmFuc2NsdWRlZFxuLy8gWW91IG11c3QgcHJvdmlkZSB0aGUgcHJvcGVydHkgb24gdGhlIGFjY29yZGlvbi1ncm91cCBjb250cm9sbGVyIHRoYXQgd2lsbCBob2xkIHRoZSB0cmFuc2NsdWRlZCBlbGVtZW50XG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb25UcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyc/XnVpYkFjY29yZGlvbkdyb3VwJywgJz9eYWNjb3JkaW9uR3JvdXAnXSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyWzBdID8gY29udHJvbGxlclswXSA6IGNvbnRyb2xsZXJbMV07IC8vIERlbGV0ZSBhZnRlciB3ZSByZW1vdmUgZGVwcmVjYXRpb25cbiAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRyb2xsZXJbYXR0cnMudWliQWNjb3JkaW9uVHJhbnNjbHVkZV07IH0sIGZ1bmN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICBlbGVtZW50LmZpbmQoJ3NwYW4nKS5odG1sKCcnKTtcbiAgICAgICAgICBlbGVtZW50LmZpbmQoJ3NwYW4nKS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKiBEZXByZWNhdGVkIGFjY29yZGlvbiBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmFjY29yZGlvbicpXG5cbiAgLnZhbHVlKCckYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbiAgLmNvbnRyb2xsZXIoJ0FjY29yZGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJGNvbnRyb2xsZXInLCAnJGxvZycsICckYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRjb250cm9sbGVyLCAkbG9nLCAkYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgaWYgKCEkYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAkbG9nLndhcm4oJ0FjY29yZGlvbkNvbnRyb2xsZXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSBVaWJBY2NvcmRpb25Db250cm9sbGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgYW5ndWxhci5leHRlbmQodGhpcywgJGNvbnRyb2xsZXIoJ1VpYkFjY29yZGlvbkNvbnRyb2xsZXInLCB7XG4gICAgICAkc2NvcGU6ICRzY29wZSxcbiAgICAgICRhdHRyczogJGF0dHJzXG4gICAgfSkpO1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCdhY2NvcmRpb24nLCBbJyRsb2cnLCAnJGFjY29yZGlvblN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRhY2NvcmRpb25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICBjb250cm9sbGVyOiAnQWNjb3JkaW9uQ29udHJvbGxlcicsXG4gICAgICBjb250cm9sbGVyQXM6ICdhY2NvcmRpb24nLFxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IGZhbHNlLFxuICAgICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEkYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdhY2NvcmRpb24gaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItYWNjb3JkaW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCdhY2NvcmRpb25Hcm91cCcsIFsnJGxvZycsICckYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGFjY29yZGlvblN1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlOiAnXmFjY29yZGlvbicsICAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGRpcmVjdGl2ZSB0byBiZSBpbnNpZGUgYW4gYWNjb3JkaW9uXG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsICAgICAgICAgICAgICAvLyBJdCB0cmFuc2NsdWRlcyB0aGUgY29udGVudHMgb2YgdGhlIGRpcmVjdGl2ZSBpbnRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgcmVwbGFjZTogdHJ1ZSwgICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGlyZWN0aXZlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgdGVtcGxhdGVcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbCc7XG4gICAgICB9LFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaGVhZGluZzogJ0AnLCAgICAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHRoZSBoZWFkaW5nIGF0dHJpYnV0ZSBvbnRvIHRoaXMgc2NvcGVcbiAgICAgICAgaXNPcGVuOiAnPT8nLFxuICAgICAgICBpc0Rpc2FibGVkOiAnPT8nXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmhlYWRpbmcgPSBlbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgYWNjb3JkaW9uQ3RybCkge1xuICAgICAgICBpZiAoISRhY2NvcmRpb25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ2FjY29yZGlvbi1ncm91cCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1hY2NvcmRpb24tZ3JvdXAgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjY29yZGlvbkN0cmwuYWRkR3JvdXAoc2NvcGUpO1xuXG4gICAgICAgIHNjb3BlLm9wZW5DbGFzcyA9IGF0dHJzLm9wZW5DbGFzcyB8fCAncGFuZWwtb3Blbic7XG4gICAgICAgIHNjb3BlLnBhbmVsQ2xhc3MgPSBhdHRycy5wYW5lbENsYXNzO1xuICAgICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhzY29wZS5vcGVuQ2xhc3MsICEhdmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS50b2dnbGVPcGVuID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFzY29wZS5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoISRldmVudCB8fCAkZXZlbnQud2hpY2ggPT09IDMyKSB7XG4gICAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9ICFzY29wZS5pc09wZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ2FjY29yZGlvbkhlYWRpbmcnLCBbJyRsb2cnLCAnJGFjY29yZGlvblN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRhY2NvcmRpb25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlLCAgIC8vIEdyYWIgdGhlIGNvbnRlbnRzIHRvIGJlIHVzZWQgYXMgdGhlIGhlYWRpbmdcbiAgICAgIHRlbXBsYXRlOiAnJywgICAgICAgLy8gSW4gZWZmZWN0IHJlbW92ZSB0aGlzIGVsZW1lbnQhXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgcmVxdWlyZTogJ15hY2NvcmRpb25Hcm91cCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgYWNjb3JkaW9uR3JvdXBDdHJsLCB0cmFuc2NsdWRlKSB7XG4gICAgICAgIGlmICghJGFjY29yZGlvblN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybignYWNjb3JkaW9uLWhlYWRpbmcgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItYWNjb3JkaW9uLWhlYWRpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXNzIHRoZSBoZWFkaW5nIHRvIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlclxuICAgICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSB0cmFuc2NsdWRlZCBpbnRvIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgLy8gW1RoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIHRyYW5zY2x1ZGUgY2F1c2VzIHRoZSBlbGVtZW50cyB0byBiZSBjbG9uZWQgc28gdGhhdCB0aGV5IHdvcmsgaW4gbmctcmVwZWF0XVxuICAgICAgICBhY2NvcmRpb25Hcm91cEN0cmwuc2V0SGVhZGluZyh0cmFuc2NsdWRlKHNjb3BlLCBhbmd1bGFyLm5vb3ApKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCdhY2NvcmRpb25UcmFuc2NsdWRlJywgWyckbG9nJywgJyRhY2NvcmRpb25TdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKCEkYWNjb3JkaW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdhY2NvcmRpb24tdHJhbnNjbHVkZSBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1hY2NvcmRpb24tdHJhbnNjbHVkZSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udHJvbGxlclthdHRyLmFjY29yZGlvblRyYW5zY2x1ZGVdOyB9LCBmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZmluZCgnc3BhbicpLmh0bWwoJycpO1xuICAgICAgICAgICAgZWxlbWVudC5maW5kKCdzcGFuJykuYXBwZW5kKGhlYWRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWxlcnQnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1VpYkFsZXJ0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckaW50ZXJwb2xhdGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJGludGVycG9sYXRlLCAkdGltZW91dCkge1xuICAkc2NvcGUuY2xvc2VhYmxlID0gISEkYXR0cnMuY2xvc2U7XG5cbiAgdmFyIGRpc21pc3NPblRpbWVvdXQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGlzbWlzc09uVGltZW91dCkgP1xuICAgICRpbnRlcnBvbGF0ZSgkYXR0cnMuZGlzbWlzc09uVGltZW91dCkoJHNjb3BlLiRwYXJlbnQpIDogbnVsbDtcblxuICBpZiAoZGlzbWlzc09uVGltZW91dCkge1xuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmNsb3NlKCk7XG4gICAgfSwgcGFyc2VJbnQoZGlzbWlzc09uVGltZW91dCwgMTApKTtcbiAgfVxufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYkFsZXJ0JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlcjogJ1VpYkFsZXJ0Q29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYWxlcnQnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sJztcbiAgICB9LFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgdHlwZTogJ0AnLFxuICAgICAgY2xvc2U6ICcmJ1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKiBEZXByZWNhdGVkIGFsZXJ0IGJlbG93ICovXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWxlcnQnKVxuXG4gIC52YWx1ZSgnJGFsZXJ0U3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbiAgLmNvbnRyb2xsZXIoJ0FsZXJ0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckY29udHJvbGxlcicsICckbG9nJywgJyRhbGVydFN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkY29udHJvbGxlciwgJGxvZywgJGFsZXJ0U3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgaWYgKCEkYWxlcnRTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICRsb2cud2FybignQWxlcnRDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliQWxlcnRDb250cm9sbGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgYW5ndWxhci5leHRlbmQodGhpcywgJGNvbnRyb2xsZXIoJ1VpYkFsZXJ0Q29udHJvbGxlcicsIHtcbiAgICAgICRzY29wZTogJHNjb3BlLFxuICAgICAgJGF0dHJzOiAkYXR0cnNcbiAgICB9KSk7XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ2FsZXJ0JywgWyckbG9nJywgJyRhbGVydFN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRhbGVydFN1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sbGVyOiAnQWxlcnRDb250cm9sbGVyJyxcbiAgICAgIGNvbnRyb2xsZXJBczogJ2FsZXJ0JyxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWwnO1xuICAgICAgfSxcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgdHlwZTogJ0AnLFxuICAgICAgICBjbG9zZTogJyYnXG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghJGFsZXJ0U3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdhbGVydCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1hbGVydCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJ1dHRvbnMnLCBbXSlcblxuLmNvbnN0YW50KCd1aWJCdXR0b25Db25maWcnLCB7XG4gIGFjdGl2ZUNsYXNzOiAnYWN0aXZlJyxcbiAgdG9nZ2xlRXZlbnQ6ICdjbGljaydcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJCdXR0b25zQ29udHJvbGxlcicsIFsndWliQnV0dG9uQ29uZmlnJywgZnVuY3Rpb24oYnV0dG9uQ29uZmlnKSB7XG4gIHRoaXMuYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XG4gIHRoaXMudG9nZ2xlRXZlbnQgPSBidXR0b25Db25maWcudG9nZ2xlRXZlbnQgfHwgJ2NsaWNrJztcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJCdG5SYWRpbycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsndWliQnRuUmFkaW8nLCAnbmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJCdXR0b25zQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnYnV0dG9ucycsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGJ1dHRvbnNDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy51aWJCdG5SYWRpbykpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vdWktPm1vZGVsXG4gICAgICBlbGVtZW50Lm9uKGJ1dHRvbnNDdHJsLnRvZ2dsZUV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzQWN0aXZlID0gZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy51bmNoZWNrYWJsZSkpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGlzQWN0aXZlID8gbnVsbCA6IHNjb3BlLiRldmFsKGF0dHJzLnVpYkJ0blJhZGlvKSk7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkJ0bkNoZWNrYm94JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJCdG5DaGVja2JveCcsICduZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkJ1dHRvbnNDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBlbGVtZW50LmZpbmQoJ2lucHV0JykuY3NzKHtkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgICAgZnVuY3Rpb24gZ2V0VHJ1ZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShhdHRycy5idG5DaGVja2JveFRydWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRGYWxzZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShhdHRycy5idG5DaGVja2JveEZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoYXR0cmlidXRlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJpYnV0ZSkgPyBzY29wZS4kZXZhbChhdHRyaWJ1dGUpIDogZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBnZXRUcnVlVmFsdWUoKSkpO1xuICAgICAgfTtcblxuICAgICAgLy91aS0+bW9kZWxcbiAgICAgIGVsZW1lbnQub24oYnV0dG9uc0N0cmwudG9nZ2xlRXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShlbGVtZW50Lmhhc0NsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzKSA/IGdldEZhbHNlVmFsdWUoKSA6IGdldFRydWVWYWx1ZSgpKTtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8qIERlcHJlY2F0ZWQgYnV0dG9ucyBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJ1dHRvbnMnKVxuXG4gIC52YWx1ZSgnJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcnLCBmYWxzZSlcblxuICAuY29udHJvbGxlcignQnV0dG9uc0NvbnRyb2xsZXInLCBbJyRjb250cm9sbGVyJywgJyRsb2cnLCAnJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkY29udHJvbGxlciwgJGxvZywgJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICBpZiAoISRidXR0b25zU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAkbG9nLndhcm4oJ0J1dHRvbnNDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliQnV0dG9uc0NvbnRyb2xsZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBhbmd1bGFyLmV4dGVuZCh0aGlzLCAkY29udHJvbGxlcignVWliQnV0dG9uc0NvbnRyb2xsZXInKSk7XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ2J0blJhZGlvJywgWyckbG9nJywgJyRidXR0b25zU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogWydidG5SYWRpbycsICduZ01vZGVsJ10sXG4gICAgICBjb250cm9sbGVyOiAnQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9ucycsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICAgIGlmICghJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ2J0bi1yYWRpbyBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1idG4tcmFkaW8gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuXG4gICAgICAgIC8vbW9kZWwgLT4gVUlcbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy5idG5SYWRpbykpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3VpLT5tb2RlbFxuICAgICAgICBlbGVtZW50LmJpbmQoYnV0dG9uc0N0cmwudG9nZ2xlRXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy51bmNoZWNrYWJsZSkpIHtcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShpc0FjdGl2ZSA/IG51bGwgOiBzY29wZS4kZXZhbChhdHRycy5idG5SYWRpbykpO1xuICAgICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ2J0bkNoZWNrYm94JywgWyckZG9jdW1lbnQnLCAnJGxvZycsICckYnV0dG9uc1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJGxvZywgJGJ1dHRvbnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogWydidG5DaGVja2JveCcsICduZ01vZGVsJ10sXG4gICAgICBjb250cm9sbGVyOiAnQnV0dG9uc0NvbnRyb2xsZXInLFxuICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgICAgaWYgKCEkYnV0dG9uc1N1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybignYnRuLWNoZWNrYm94IGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWJ0bi1jaGVja2JveCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1dHRvbnNDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgICAgZWxlbWVudC5maW5kKCdpbnB1dCcpLmNzcyh7ZGlzcGxheTogJ25vbmUnfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VHJ1ZVZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94VHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRGYWxzZVZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGF0dHJzLmJ0bkNoZWNrYm94RmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoYXR0cmlidXRlVmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIHZhciB2YWwgPSBzY29wZS4kZXZhbChhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgPyB2YWwgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL21vZGVsIC0+IFVJXG4gICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50LnRvZ2dsZUNsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzLCBhbmd1bGFyLmVxdWFscyhuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSwgZ2V0VHJ1ZVZhbHVlKCkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3VpLT5tb2RlbFxuICAgICAgICBlbGVtZW50LmJpbmQoYnV0dG9uc0N0cmwudG9nZ2xlRXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZWxlbWVudC5oYXNDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcykgPyBnZXRGYWxzZVZhbHVlKCkgOiBnZXRUcnVlVmFsdWUoKSk7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vYWNjZXNzaWJpbGl0eVxuICAgICAgICBlbGVtZW50Lm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoYXR0cnMuZGlzYWJsZWQgfHwgZS53aGljaCAhPT0gMzIgfHwgJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgIT09IGVsZW1lbnRbMF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpID8gZ2V0RmFsc2VWYWx1ZSgpIDogZ2V0VHJ1ZVZhbHVlKCkpO1xuICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC5jYXJvdXNlbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW5ndWxhckpTIHZlcnNpb24gb2YgYW4gaW1hZ2UgY2Fyb3VzZWwuXG4gKlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNhcm91c2VsJywgW10pXG5cbi5jb250cm9sbGVyKCdVaWJDYXJvdXNlbENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckaW50ZXJ2YWwnLCAnJGFuaW1hdGUnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkaW50ZXJ2YWwsICRhbmltYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzbGlkZXMgPSBzZWxmLnNsaWRlcyA9ICRzY29wZS5zbGlkZXMgPSBbXSxcbiAgICBORVdfQU5JTUFURSA9IGFuZ3VsYXIudmVyc2lvbi5taW5vciA+PSA0LFxuICAgIE5PX1RSQU5TSVRJT04gPSAndWliLW5vVHJhbnNpdGlvbicsXG4gICAgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbicsXG4gICAgY3VycmVudEluZGV4ID0gLTEsXG4gICAgY3VycmVudEludGVydmFsLCBpc1BsYXlpbmc7XG4gIHNlbGYuY3VycmVudFNsaWRlID0gbnVsbDtcblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIC8qIGRpcmVjdGlvbjogXCJwcmV2XCIgb3IgXCJuZXh0XCIgKi9cbiAgc2VsZi5zZWxlY3QgPSAkc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24obmV4dFNsaWRlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gJHNjb3BlLmluZGV4T2ZTbGlkZShuZXh0U2xpZGUpO1xuICAgIC8vRGVjaWRlIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCBnaXZlblxuICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGlyZWN0aW9uID0gbmV4dEluZGV4ID4gc2VsZi5nZXRDdXJyZW50SW5kZXgoKSA/ICduZXh0JyA6ICdwcmV2JztcbiAgICB9XG4gICAgLy9QcmV2ZW50IHRoaXMgdXNlci10cmlnZ2VyZWQgdHJhbnNpdGlvbiBmcm9tIG9jY3VycmluZyBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzc1xuICAgIGlmIChuZXh0U2xpZGUgJiYgbmV4dFNsaWRlICE9PSBzZWxmLmN1cnJlbnRTbGlkZSAmJiAhJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgZ29OZXh0KG5leHRTbGlkZSwgbmV4dEluZGV4LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnb05leHQoc2xpZGUsIGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAvLyBTY29wZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHN0b3AgaGVyZS5cbiAgICBpZiAoZGVzdHJveWVkKSB7IHJldHVybjsgfVxuXG4gICAgYW5ndWxhci5leHRlbmQoc2xpZGUsIHtkaXJlY3Rpb246IGRpcmVjdGlvbiwgYWN0aXZlOiB0cnVlfSk7XG4gICAgYW5ndWxhci5leHRlbmQoc2VsZi5jdXJyZW50U2xpZGUgfHwge30sIHtkaXJlY3Rpb246IGRpcmVjdGlvbiwgYWN0aXZlOiBmYWxzZX0pO1xuICAgIGlmICgkYW5pbWF0ZS5lbmFibGVkKCkgJiYgISRzY29wZS5ub1RyYW5zaXRpb24gJiYgISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gJiZcbiAgICAgIHNsaWRlLiRlbGVtZW50ICYmIHNlbGYuc2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNsaWRlLiRlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgaWYgKHNlbGYuY3VycmVudFNsaWRlICYmIHNlbGYuY3VycmVudFNsaWRlLiRlbGVtZW50KSB7XG4gICAgICAgIHNlbGYuY3VycmVudFNsaWRlLiRlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgIGlmIChORVdfQU5JTUFURSkge1xuICAgICAgICAkYW5pbWF0ZS5vbignYWRkQ2xhc3MnLCBzbGlkZS4kZWxlbWVudCwgZnVuY3Rpb24oZWxlbWVudCwgcGhhc2UpIHtcbiAgICAgICAgICBpZiAocGhhc2UgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgJGFuaW1hdGUub2ZmKCdhZGRDbGFzcycsIGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZS4kZWxlbWVudC5vbmUoJyRhbmltYXRlOmNsb3NlJywgZnVuY3Rpb24gY2xvc2VGbigpIHtcbiAgICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5jdXJyZW50U2xpZGUgPSBzbGlkZTtcbiAgICBjdXJyZW50SW5kZXggPSBpbmRleDtcblxuICAgIC8vZXZlcnkgdGltZSB5b3UgY2hhbmdlIHNsaWRlcywgcmVzZXQgdGhlIHRpbWVyXG4gICAgcmVzdGFydFRpbWVyKCk7XG4gIH1cblxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldFNsaWRlQnlJbmRleChpbmRleCkge1xuICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKHNsaWRlc1tpbmRleF0uaW5kZXgpKSB7XG4gICAgICByZXR1cm4gc2xpZGVzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGksIGxlbiA9IHNsaWRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNsaWRlc1tpXS5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2xpZGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuY3VycmVudFNsaWRlICYmIGFuZ3VsYXIuaXNEZWZpbmVkKHNlbGYuY3VycmVudFNsaWRlLmluZGV4KSkge1xuICAgICAgcmV0dXJuICtzZWxmLmN1cnJlbnRTbGlkZS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgfTtcblxuICAvKiBBbGxvdyBvdXRzaWRlIHBlb3BsZSB0byBjYWxsIGluZGV4T2Ygb24gc2xpZGVzIGFycmF5ICovXG4gICRzY29wZS5pbmRleE9mU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChzbGlkZS5pbmRleCkgPyArc2xpZGUuaW5kZXggOiBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XG4gIH07XG5cbiAgJHNjb3BlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3SW5kZXggPSAoc2VsZi5nZXRDdXJyZW50SW5kZXgoKSArIDEpICUgc2xpZGVzLmxlbmd0aDtcblxuICAgIGlmIChuZXdJbmRleCA9PT0gMCAmJiAkc2NvcGUubm9XcmFwKCkpIHtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnNlbGVjdChnZXRTbGlkZUJ5SW5kZXgobmV3SW5kZXgpLCAnbmV4dCcpO1xuICB9O1xuXG4gICRzY29wZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gc2VsZi5nZXRDdXJyZW50SW5kZXgoKSAtIDEgPCAwID8gc2xpZGVzLmxlbmd0aCAtIDEgOiBzZWxmLmdldEN1cnJlbnRJbmRleCgpIC0gMTtcblxuICAgIGlmICgkc2NvcGUubm9XcmFwKCkgJiYgbmV3SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAkc2NvcGUucGF1c2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5zZWxlY3QoZ2V0U2xpZGVCeUluZGV4KG5ld0luZGV4KSwgJ3ByZXYnKTtcbiAgfTtcblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgICByZXR1cm4gc2VsZi5jdXJyZW50U2xpZGUgPT09IHNsaWRlO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ2ludGVydmFsJywgcmVzdGFydFRpbWVyKTtcbiAgJHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oJ3NsaWRlcycsIHJlc2V0VHJhbnNpdGlvbik7XG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgcmVzZXRUaW1lcik7XG5cbiAgZnVuY3Rpb24gcmVzdGFydFRpbWVyKCkge1xuICAgIHJlc2V0VGltZXIoKTtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCkge1xuICAgICAgY3VycmVudEludGVydmFsID0gJGludGVydmFsKHRpbWVyRm4sIGludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmIChjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICRpbnRlcnZhbC5jYW5jZWwoY3VycmVudEludGVydmFsKTtcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJGbigpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmIChpc1BsYXlpbmcgJiYgIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgc2xpZGVzLmxlbmd0aCkge1xuICAgICAgJHNjb3BlLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcmFuc2l0aW9uKHNsaWRlcykge1xuICAgIGlmICghc2xpZGVzLmxlbmd0aCkge1xuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzUGxheWluZykge1xuICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9QYXVzZSkge1xuICAgICAgaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXNldFRpbWVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHNlbGYuYWRkU2xpZGUgPSBmdW5jdGlvbihzbGlkZSwgZWxlbWVudCkge1xuICAgIHNsaWRlLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICBzbGlkZXMucHVzaChzbGlkZSk7XG4gICAgLy9pZiB0aGlzIGlzIHRoZSBmaXJzdCBzbGlkZSBvciB0aGUgc2xpZGUgaXMgc2V0IHRvIGFjdGl2ZSwgc2VsZWN0IGl0XG4gICAgaWYgKHNsaWRlcy5sZW5ndGggPT09IDEgfHwgc2xpZGUuYWN0aXZlKSB7XG4gICAgICBzZWxmLnNlbGVjdChzbGlkZXNbc2xpZGVzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICRzY29wZS5wbGF5KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBzZWxmLnJlbW92ZVNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoc2xpZGUuaW5kZXgpKSB7XG4gICAgICBzbGlkZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiArYS5pbmRleCA+ICtiLmluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vZ2V0IHRoZSBpbmRleCBvZiB0aGUgc2xpZGUgaW5zaWRlIHRoZSBjYXJvdXNlbFxuICAgIHZhciBpbmRleCA9IHNsaWRlcy5pbmRleE9mKHNsaWRlKTtcbiAgICBzbGlkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA+IDAgJiYgc2xpZGUuYWN0aXZlKSB7XG4gICAgICBpZiAoaW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXggLSAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbmRleCA+IGluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICB9XG5cbiAgICAvL2NsZWFuIHRoZSBjdXJyZW50U2xpZGUgd2hlbiBubyBtb3JlIHNsaWRlXG4gICAgaWYgKHNsaWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuY3VycmVudFNsaWRlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgnbm9UcmFuc2l0aW9uJywgZnVuY3Rpb24obm9UcmFuc2l0aW9uKSB7XG4gICAgJGVsZW1lbnQuZGF0YShOT19UUkFOU0lUSU9OLCBub1RyYW5zaXRpb24pO1xuICB9KTtcblxufV0pXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpjYXJvdXNlbFxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDYXJvdXNlbCBpcyB0aGUgb3V0ZXIgY29udGFpbmVyIGZvciBhIHNldCBvZiBpbWFnZSAnc2xpZGVzJyB0byBzaG93Y2FzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcj19IGludGVydmFsIFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRoYXQgaXQgd2lsbCB0YWtlIHRoZSBjYXJvdXNlbCB0byBnbyB0byB0aGUgbmV4dCBzbGlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVHJhbnNpdGlvbiBXaGV0aGVyIHRvIGRpc2FibGUgdHJhbnNpdGlvbnMgb24gdGhlIGNhcm91c2VsLlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9QYXVzZSBXaGV0aGVyIHRvIGRpc2FibGUgcGF1c2luZyBvbiB0aGUgY2Fyb3VzZWwgKGJ5IGRlZmF1bHQsIHRoZSBjYXJvdXNlbCBpbnRlcnZhbCBwYXVzZXMgb24gaG92ZXIpLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8dWliLWNhcm91c2VsPlxuICAgICAgPHVpYi1zbGlkZT5cbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzE1MC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxuICAgICAgICAgIDxwPkJlYXV0aWZ1bCE8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC91aWItc2xpZGU+XG4gICAgICA8dWliLXNsaWRlPlxuICAgICAgICA8aW1nIHNyYz1cImh0dHA6Ly9wbGFjZWtpdHRlbi5jb20vMTAwLzE1MFwiIHN0eWxlPVwibWFyZ2luOmF1dG87XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgICAgPHA+RCdhd3chPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvdWliLXNsaWRlPlxuICAgIDwvdWliLWNhcm91c2VsPlxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJkZW1vLmNzc1wiPlxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcbiAgICAgIHRvcDogYXV0bztcbiAgICAgIGJvdHRvbTogMTVweDtcbiAgICB9XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndWliQ2Fyb3VzZWwnLCBbZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJDYXJvdXNlbENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2Nhcm91c2VsJyxcbiAgICByZXF1aXJlOiAnY2Fyb3VzZWwnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBpbnRlcnZhbDogJz0nLFxuICAgICAgbm9UcmFuc2l0aW9uOiAnPScsXG4gICAgICBub1BhdXNlOiAnPScsXG4gICAgICBub1dyYXA6ICcmJ1xuICAgIH1cbiAgfTtcbn1dKVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC5jYXJvdXNlbC5kaXJlY3RpdmU6c2xpZGVcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIHNsaWRlIGluc2lkZSBhIHtAbGluayB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOmNhcm91c2VsIGNhcm91c2VsfS4gIE11c3QgYmUgcGxhY2VkIGFzIGEgY2hpbGQgb2YgYSBjYXJvdXNlbCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGFjdGl2ZSBNb2RlbCBiaW5kaW5nLCB3aGV0aGVyIG9yIG5vdCB0aGlzIHNsaWRlIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gKiBAcGFyYW0ge251bWJlcj19IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgc2xpZGUuIFRoZSBzbGlkZXMgd2lsbCBiZSBzb3J0ZWQgYnkgdGhpcyBwYXJhbWV0ZXIuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuPGRpdiBuZy1jb250cm9sbGVyPVwiQ2Fyb3VzZWxEZW1vQ3RybFwiPlxuICA8dWliLWNhcm91c2VsPlxuICAgIDx1aWItc2xpZGUgbmctcmVwZWF0PVwic2xpZGUgaW4gc2xpZGVzXCIgYWN0aXZlPVwic2xpZGUuYWN0aXZlXCIgaW5kZXg9XCIkaW5kZXhcIj5cbiAgICAgIDxpbWcgbmctc3JjPVwie3tzbGlkZS5pbWFnZX19XCIgc3R5bGU9XCJtYXJnaW46YXV0bztcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgIDxoND5TbGlkZSB7eyRpbmRleH19PC9oND5cbiAgICAgICAgPHA+e3tzbGlkZS50ZXh0fX08L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L3VpYi1zbGlkZT5cbiAgPC91aWItY2Fyb3VzZWw+XG4gIEludGVydmFsLCBpbiBtaWxsaXNlY29uZHM6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbmctbW9kZWw9XCJteUludGVydmFsXCI+XG4gIDxiciAvPkVudGVyIGEgbmVnYXRpdmUgbnVtYmVyIHRvIHN0b3AgdGhlIGludGVydmFsLlxuPC9kaXY+XG4gIDwvZmlsZT5cbiAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuZnVuY3Rpb24gQ2Fyb3VzZWxEZW1vQ3RybCgkc2NvcGUpIHtcbiAgJHNjb3BlLm15SW50ZXJ2YWwgPSA1MDAwO1xufVxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJkZW1vLmNzc1wiPlxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcbiAgICAgIHRvcDogYXV0bztcbiAgICAgIGJvdHRvbTogMTVweDtcbiAgICB9XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiovXG5cbi5kaXJlY3RpdmUoJ3VpYlNsaWRlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ151aWJDYXJvdXNlbCcsXG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBhY3RpdmU6ICc9PycsXG4gICAgICBhY3R1YWw6ICc9PycsXG4gICAgICBpbmRleDogJz0/J1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY2Fyb3VzZWxDdHJsKSB7XG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgLy93aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQgdGhlbiByZW1vdmUgdGhlIHNsaWRlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVzIGFycmF5XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIGNhcm91c2VsQ3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG4uYW5pbWF0aW9uKCcuaXRlbScsIFtcbiAgICAgICAgICckaW5qZWN0b3InLCAnJGFuaW1hdGUnLFxuZnVuY3Rpb24gKCRpbmplY3RvciwgJGFuaW1hdGUpIHtcbiAgdmFyIE5PX1RSQU5TSVRJT04gPSAndWliLW5vVHJhbnNpdGlvbicsXG4gICAgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbicsXG4gICAgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gIGlmICgkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpKSB7XG4gICAgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBjYWxsYmFjaykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWZvcmVBZGRDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XG4gICAgICAvLyBEdWUgdG8gdHJhbnNjbHVzaW9uLCBub1RyYW5zaXRpb24gcHJvcGVydHkgaXMgb24gcGFyZW50J3Mgc2NvcGVcbiAgICAgIGlmIChjbGFzc05hbWUgPT0gJ2FjdGl2ZScgJiYgZWxlbWVudC5wYXJlbnQoKSAmJiBlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpICYmXG4gICAgICAgICAgIWVsZW1lbnQucGFyZW50KCkucGFyZW50KCkuZGF0YShOT19UUkFOU0lUSU9OKSkge1xuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTik7XG4gICAgICAgIHZhciBkaXJlY3Rpb25DbGFzcyA9IGRpcmVjdGlvbiA9PSAnbmV4dCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3NGbiA9IHJlbW92ZUNsYXNzLmJpbmQodGhpcywgZWxlbWVudCxcbiAgICAgICAgICBkaXJlY3Rpb25DbGFzcyArICcgJyArIGRpcmVjdGlvbiwgZG9uZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuZG9uZShyZW1vdmVDbGFzc0ZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBkaXJlY3Rpb25DbGFzcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9LFxuICAgIGJlZm9yZVJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XG4gICAgICAvLyBEdWUgdG8gdHJhbnNjbHVzaW9uLCBub1RyYW5zaXRpb24gcHJvcGVydHkgaXMgb24gcGFyZW50J3Mgc2NvcGVcbiAgICAgIGlmIChjbGFzc05hbWUgPT09ICdhY3RpdmUnICYmIGVsZW1lbnQucGFyZW50KCkgJiYgZWxlbWVudC5wYXJlbnQoKS5wYXJlbnQoKSAmJlxuICAgICAgICAgICFlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpLmRhdGEoTk9fVFJBTlNJVElPTikpIHtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsZW1lbnQuZGF0YShTTElERV9ESVJFQ1RJT04pO1xuICAgICAgICB2YXIgZGlyZWN0aW9uQ2xhc3MgPSBkaXJlY3Rpb24gPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgdmFyIHJlbW92ZUNsYXNzRm4gPSByZW1vdmVDbGFzcy5iaW5kKHRoaXMsIGVsZW1lbnQsIGRpcmVjdGlvbkNsYXNzLCBkb25lKTtcblxuICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuZG9uZShyZW1vdmVDbGFzc0ZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBkaXJlY3Rpb25DbGFzcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzc0ZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyogZGVwcmVjYXRlZCBjYXJvdXNlbCBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNhcm91c2VsJylcblxuLnZhbHVlKCckY2Fyb3VzZWxTdXBwcmVzc1dhcm5pbmcnLCBmYWxzZSlcblxuLmNvbnRyb2xsZXIoJ0Nhcm91c2VsQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRjb250cm9sbGVyJywgJyRsb2cnLCAnJGNhcm91c2VsU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGNvbnRyb2xsZXIsICRsb2csICRjYXJvdXNlbFN1cHByZXNzV2FybmluZykge1xuICBpZiAoISRjYXJvdXNlbFN1cHByZXNzV2FybmluZykge1xuICAgICRsb2cud2FybignQ2Fyb3VzZWxDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliQ2Fyb3VzZWxDb250cm9sbGVyIGluc3RlYWQuJyk7XG4gIH1cblxuICBhbmd1bGFyLmV4dGVuZCh0aGlzLCAkY29udHJvbGxlcignVWliQ2Fyb3VzZWxDb250cm9sbGVyJywge1xuICAgICRzY29wZTogJHNjb3BlLFxuICAgICRlbGVtZW50OiAkZWxlbWVudFxuICB9KSk7XG59XSlcblxuLmRpcmVjdGl2ZSgnY2Fyb3VzZWwnLCBbJyRsb2cnLCAnJGNhcm91c2VsU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGNhcm91c2VsU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdDYXJvdXNlbENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2Nhcm91c2VsJyxcbiAgICByZXF1aXJlOiAnY2Fyb3VzZWwnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBpbnRlcnZhbDogJz0nLFxuICAgICAgbm9UcmFuc2l0aW9uOiAnPScsXG4gICAgICBub1BhdXNlOiAnPScsXG4gICAgICBub1dyYXA6ICcmJ1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISRjYXJvdXNlbFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ2Nhcm91c2VsIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWNhcm91c2VsIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3NsaWRlJywgWyckbG9nJywgJyRjYXJvdXNlbFN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRjYXJvdXNlbFN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdeY2Fyb3VzZWwnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgYWN0aXZlOiAnPT8nLFxuICAgICAgYWN0dWFsOiAnPT8nLFxuICAgICAgaW5kZXg6ICc9PydcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNhcm91c2VsQ3RybCkge1xuICAgICAgaWYgKCEkY2Fyb3VzZWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdzbGlkZSBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1zbGlkZSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgLy93aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQgdGhlbiByZW1vdmUgdGhlIHNsaWRlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVzIGFycmF5XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIGNhcm91c2VsQ3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsIFtdKVxuXG4uc2VydmljZSgndWliRGF0ZVBhcnNlcicsIFsnJGxvZycsICckbG9jYWxlJywgJ29yZGVyQnlGaWx0ZXInLCBmdW5jdGlvbigkbG9nLCAkbG9jYWxlLCBvcmRlckJ5RmlsdGVyKSB7XG4gIC8vIFB1bGxlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy9ibG9iL21hc3Rlci9zcmMvZm9ybWF0L3JlcXVvdGUuanNcbiAgdmFyIFNQRUNJQUxfQ0hBUkFDVEVSU19SRUdFWFAgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG5cbiAgdmFyIGxvY2FsZUlkO1xuICB2YXIgZm9ybWF0Q29kZVRvUmVnZXg7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgbG9jYWxlSWQgPSAkbG9jYWxlLmlkO1xuXG4gICAgdGhpcy5wYXJzZXJzID0ge307XG5cbiAgICBmb3JtYXRDb2RlVG9SZWdleCA9IHtcbiAgICAgICd5eXl5Jzoge1xuICAgICAgICByZWdleDogJ1xcXFxkezR9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMueWVhciA9ICt2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgICd5eSc6IHtcbiAgICAgICAgcmVnZXg6ICdcXFxcZHsyfScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnllYXIgPSArdmFsdWUgKyAyMDAwOyB9XG4gICAgICB9LFxuICAgICAgJ3knOiB7XG4gICAgICAgIHJlZ2V4OiAnXFxcXGR7MSw0fScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnllYXIgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnTU1NTSc6IHtcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5NT05USC5qb2luKCd8JyksXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmluZGV4T2YodmFsdWUpOyB9XG4gICAgICB9LFxuICAgICAgJ01NTSc6IHtcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TSE9SVE1PTlRILmpvaW4oJ3wnKSxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlRNT05USC5pbmRleE9mKHZhbHVlKTsgfVxuICAgICAgfSxcbiAgICAgICdNTSc6IHtcbiAgICAgICAgcmVnZXg6ICcwWzEtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSB2YWx1ZSAtIDE7IH1cbiAgICAgIH0sXG4gICAgICAnTSc6IHtcbiAgICAgICAgcmVnZXg6ICdbMS05XXwxWzAtMl0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfVxuICAgICAgfSxcbiAgICAgICdkZCc6IHtcbiAgICAgICAgcmVnZXg6ICdbMC0yXVswLTldezF9fDNbMC0xXXsxfScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnZCc6IHtcbiAgICAgICAgcmVnZXg6ICdbMS0yXT9bMC05XXsxfXwzWzAtMV17MX0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5kYXRlID0gK3ZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgJ0VFRUUnOiB7XG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuREFZLmpvaW4oJ3wnKVxuICAgICAgfSxcbiAgICAgICdFRUUnOiB7XG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlREQVkuam9pbignfCcpXG4gICAgICB9LFxuICAgICAgJ0hIJzoge1xuICAgICAgICByZWdleDogJyg/OjB8MSlbMC05XXwyWzAtM10nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgICdoaCc6IHtcbiAgICAgICAgcmVnZXg6ICcwWzAtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnSCc6IHtcbiAgICAgICAgcmVnZXg6ICcxP1swLTldfDJbMC0zXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgJ2gnOiB7XG4gICAgICAgIHJlZ2V4OiAnWzAtOV18MVswLTJdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnbW0nOiB7XG4gICAgICAgIHJlZ2V4OiAnWzAtNV1bMC05XScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1pbnV0ZXMgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnbSc6IHtcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS01XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWludXRlcyA9ICt2YWx1ZTsgfVxuICAgICAgfSxcbiAgICAgICdzc3MnOiB7XG4gICAgICAgIHJlZ2V4OiAnWzAtOV1bMC05XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWlsbGlzZWNvbmRzID0gK3ZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgJ3NzJzoge1xuICAgICAgICByZWdleDogJ1swLTVdWzAtOV0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5zZWNvbmRzID0gK3ZhbHVlOyB9XG4gICAgICB9LFxuICAgICAgJ3MnOiB7XG4gICAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNV1bMC05XScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnNlY29uZHMgPSArdmFsdWU7IH1cbiAgICAgIH0sXG4gICAgICAnYSc6IHtcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5BTVBNUy5qb2luKCd8JyksXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLmhvdXJzID09PSAxMikge1xuICAgICAgICAgICAgdGhpcy5ob3VycyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnUE0nKSB7XG4gICAgICAgICAgICB0aGlzLmhvdXJzICs9IDEyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5pbml0KCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGZvcm1hdCkge1xuICAgIHZhciBtYXAgPSBbXSwgcmVnZXggPSBmb3JtYXQuc3BsaXQoJycpO1xuXG4gICAgYW5ndWxhci5mb3JFYWNoKGZvcm1hdENvZGVUb1JlZ2V4LCBmdW5jdGlvbihkYXRhLCBjb2RlKSB7XG4gICAgICB2YXIgaW5kZXggPSBmb3JtYXQuaW5kZXhPZihjb2RlKTtcblxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNwbGl0KCcnKTtcblxuICAgICAgICByZWdleFtpbmRleF0gPSAnKCcgKyBkYXRhLnJlZ2V4ICsgJyknO1xuICAgICAgICBmb3JtYXRbaW5kZXhdID0gJyQnOyAvLyBDdXN0b20gc3ltYm9sIHRvIGRlZmluZSBjb25zdW1lZCBwYXJ0IG9mIGZvcm1hdFxuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxLCBuID0gaW5kZXggKyBjb2RlLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHJlZ2V4W2ldID0gJyc7XG4gICAgICAgICAgZm9ybWF0W2ldID0gJyQnO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5qb2luKCcnKTtcblxuICAgICAgICBtYXAucHVzaCh7IGluZGV4OiBpbmRleCwgYXBwbHk6IGRhdGEuYXBwbHkgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IG5ldyBSZWdFeHAoJ14nICsgcmVnZXguam9pbignJykgKyAnJCcpLFxuICAgICAgbWFwOiBvcmRlckJ5RmlsdGVyKG1hcCwgJ2luZGV4JylcbiAgICB9O1xuICB9XG5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmb3JtYXQsIGJhc2VEYXRlKSB7XG4gICAgaWYgKCFhbmd1bGFyLmlzU3RyaW5nKGlucHV0KSB8fCAhZm9ybWF0KSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xuICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFNQRUNJQUxfQ0hBUkFDVEVSU19SRUdFWFAsICdcXFxcJCYnKTtcblxuICAgIGlmICgkbG9jYWxlLmlkICE9PSBsb2NhbGVJZCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhcnNlcnNbZm9ybWF0XSkge1xuICAgICAgdGhpcy5wYXJzZXJzW2Zvcm1hdF0gPSBjcmVhdGVQYXJzZXIoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXJzW2Zvcm1hdF0sXG4gICAgICAgIHJlZ2V4ID0gcGFyc2VyLnJlZ2V4LFxuICAgICAgICBtYXAgPSBwYXJzZXIubWFwLFxuICAgICAgICByZXN1bHRzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBmaWVsZHMsIGR0O1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKGJhc2VEYXRlKSAmJiAhaXNOYU4oYmFzZURhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBmaWVsZHMgPSB7XG4gICAgICAgICAgeWVhcjogYmFzZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBtb250aDogYmFzZURhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICBkYXRlOiBiYXNlRGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgaG91cnM6IGJhc2VEYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgbWludXRlczogYmFzZURhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICAgIHNlY29uZHM6IGJhc2VEYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgICBtaWxsaXNlY29uZHM6IGJhc2VEYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFzZURhdGUpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ2RhdGVwYXJzZXI6JywgJ2Jhc2VEYXRlIGlzIG5vdCBhIHZhbGlkIGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSB7IHllYXI6IDE5MDAsIG1vbnRoOiAwLCBkYXRlOiAxLCBob3VyczogMCwgbWludXRlczogMCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcHBlciA9IG1hcFtpLTFdO1xuICAgICAgICBpZiAobWFwcGVyLmFwcGx5KSB7XG4gICAgICAgICAgbWFwcGVyLmFwcGx5LmNhbGwoZmllbGRzLCByZXN1bHRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNWYWxpZChmaWVsZHMueWVhciwgZmllbGRzLm1vbnRoLCBmaWVsZHMuZGF0ZSkpIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEYXRlKGJhc2VEYXRlKSAmJiAhaXNOYU4oYmFzZURhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgIGR0ID0gbmV3IERhdGUoYmFzZURhdGUpO1xuICAgICAgICAgIGR0LnNldEZ1bGxZZWFyKGZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXRlLFxuICAgICAgICAgICAgZmllbGRzLmhvdXJzLCBmaWVsZHMubWludXRlcywgZmllbGRzLnNlY29uZHMsXG4gICAgICAgICAgICBmaWVsZHMubWlsbGlzZWNvbmRzIHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR0ID0gbmV3IERhdGUoZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUsXG4gICAgICAgICAgICBmaWVsZHMuaG91cnMsIGZpZWxkcy5taW51dGVzLCBmaWVsZHMuc2Vjb25kcyxcbiAgICAgICAgICAgIGZpZWxkcy5taWxsaXNlY29uZHMgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR0O1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBpZiBkYXRlIGlzIHZhbGlkIGZvciBzcGVjaWZpYyBtb250aCAoYW5kIHllYXIgZm9yIEZlYnJ1YXJ5KS5cbiAgLy8gTW9udGg6IDAgPSBKYW4sIDEgPSBGZWIsIGV0Y1xuICBmdW5jdGlvbiBpc1ZhbGlkKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgaWYgKGRhdGUgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoID09PSAxICYmIGRhdGUgPiAyOCkge1xuICAgICAgcmV0dXJuIGRhdGUgPT09IDI5ICYmICgoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoID09PSAzIHx8IG1vbnRoID09PSA1IHx8IG1vbnRoID09PSA4IHx8IG1vbnRoID09PSAxMCkge1xuICAgICAgcmV0dXJuIGRhdGUgPCAzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV0pO1xuXG4vKiBEZXByZWNhdGVkIGRhdGVwYXJzZXIgYmVsb3cgKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGFyc2VyJylcblxuLnZhbHVlKCckZGF0ZVBhcnNlclN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4uc2VydmljZSgnZGF0ZVBhcnNlcicsIFsnJGxvZycsICckZGF0ZVBhcnNlclN1cHByZXNzV2FybmluZycsICd1aWJEYXRlUGFyc2VyJywgZnVuY3Rpb24oJGxvZywgJGRhdGVQYXJzZXJTdXBwcmVzc1dhcm5pbmcsIHVpYkRhdGVQYXJzZXIpIHtcbiAgaWYgKCEkZGF0ZVBhcnNlclN1cHByZXNzV2FybmluZykge1xuICAgICRsb2cud2FybignZGF0ZVBhcnNlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYkRhdGVQYXJzZXIgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGFuZ3VsYXIuZXh0ZW5kKHRoaXMsIHVpYkRhdGVQYXJzZXIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgW10pXG5cbi8qKlxuICogQSBzZXQgb2YgdXRpbGl0eSBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZSB0byByZXRyaWV2ZSBwb3NpdGlvbiBvZiBET00gZWxlbWVudHMuXG4gKiBJdCBpcyBtZWFudCB0byBiZSB1c2VkIHdoZXJlIHdlIG5lZWQgdG8gYWJzb2x1dGUtcG9zaXRpb24gRE9NIGVsZW1lbnRzIGluXG4gKiByZWxhdGlvbiB0byBvdGhlciwgZXhpc3RpbmcgZWxlbWVudHMgKHRoaXMgaXMgdGhlIGNhc2UgZm9yIHRvb2x0aXBzLCBwb3BvdmVycyxcbiAqIHR5cGVhaGVhZCBzdWdnZXN0aW9ucyBldGMuKS5cbiAqL1xuICAuZmFjdG9yeSgnJHVpYlBvc2l0aW9uJywgWyckZG9jdW1lbnQnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJHdpbmRvdykge1xuICAgIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBjc3Nwcm9wKSB7XG4gICAgICBpZiAoZWwuY3VycmVudFN0eWxlKSB7IC8vSUVcbiAgICAgICAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtjc3Nwcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAoJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIHJldHVybiAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW2Nzc3Byb3BdO1xuICAgICAgfVxuICAgICAgLy8gZmluYWxseSB0cnkgYW5kIGdldCBpbmxpbmUgc3R5bGVcbiAgICAgIHJldHVybiBlbC5zdHlsZVtjc3Nwcm9wXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHN0YXRpY2FsbHkgcG9zaXRpb25lZFxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gcmF3IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAoZ2V0U3R5bGUoZWxlbWVudCwgJ3Bvc2l0aW9uJykgfHwgJ3N0YXRpYycgKSA9PT0gJ3N0YXRpYyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY2xvc2VzdCwgbm9uLXN0YXRpY2FsbHkgcG9zaXRpb25lZCBwYXJlbnRPZmZzZXQgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICB2YXIgcGFyZW50T2Zmc2V0RWwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgZG9jRG9tRWwgPSAkZG9jdW1lbnRbMF07XG4gICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XG4gICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZG9jRG9tRWwgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0RvbUVsO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBwb3NpdGlvbiBmdW5jdGlvbjpcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wb3NpdGlvbi9cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsQkNSID0gdGhpcy5vZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRCQ1IgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50RWwgPSBwYXJlbnRPZmZzZXRFbChlbGVtZW50WzBdKTtcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudEVsICE9ICRkb2N1bWVudFswXSkge1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUiA9IHRoaXMub2Zmc2V0KGFuZ3VsYXIuZWxlbWVudChvZmZzZXRQYXJlbnRFbCkpO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi50b3AgKz0gb2Zmc2V0UGFyZW50RWwuY2xpZW50VG9wIC0gb2Zmc2V0UGFyZW50RWwuc2Nyb2xsVG9wO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi5sZWZ0ICs9IG9mZnNldFBhcmVudEVsLmNsaWVudExlZnQgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCB8fCBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICAgICAgdG9wOiBlbEJDUi50b3AgLSBvZmZzZXRQYXJlbnRCQ1IudG9wLFxuICAgICAgICAgIGxlZnQ6IGVsQkNSLmxlZnQgLSBvZmZzZXRQYXJlbnRCQ1IubGVmdFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246XG4gICAgICAgKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vb2Zmc2V0L1xuICAgICAgICovXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCB8fCBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICAgICAgdG9wOiBib3VuZGluZ0NsaWVudFJlY3QudG9wICsgKCR3aW5kb3cucGFnZVlPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgKCR3aW5kb3cucGFnZVhPZmZzZXQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBjb29yZGluYXRlcyBmb3IgdGhlIHRhcmdldEVsIGluIHJlbGF0aW9uIHRvIGhvc3RFbFxuICAgICAgICovXG4gICAgICBwb3NpdGlvbkVsZW1lbnRzOiBmdW5jdGlvbihob3N0RWwsIHRhcmdldEVsLCBwb3NpdGlvblN0ciwgYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIHZhciBwb3NpdGlvblN0clBhcnRzID0gcG9zaXRpb25TdHIuc3BsaXQoJy0nKTtcbiAgICAgICAgdmFyIHBvczAgPSBwb3NpdGlvblN0clBhcnRzWzBdLCBwb3MxID0gcG9zaXRpb25TdHJQYXJ0c1sxXSB8fCAnY2VudGVyJztcblxuICAgICAgICB2YXIgaG9zdEVsUG9zLFxuICAgICAgICAgIHRhcmdldEVsV2lkdGgsXG4gICAgICAgICAgdGFyZ2V0RWxIZWlnaHQsXG4gICAgICAgICAgdGFyZ2V0RWxQb3M7XG5cbiAgICAgICAgaG9zdEVsUG9zID0gYXBwZW5kVG9Cb2R5ID8gdGhpcy5vZmZzZXQoaG9zdEVsKSA6IHRoaXMucG9zaXRpb24oaG9zdEVsKTtcblxuICAgICAgICB0YXJnZXRFbFdpZHRoID0gdGFyZ2V0RWwucHJvcCgnb2Zmc2V0V2lkdGgnKTtcbiAgICAgICAgdGFyZ2V0RWxIZWlnaHQgPSB0YXJnZXRFbC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcblxuICAgICAgICB2YXIgc2hpZnRXaWR0aCA9IHtcbiAgICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3RFbFBvcy5sZWZ0ICsgaG9zdEVsUG9zLndpZHRoIC8gMiAtIHRhcmdldEVsV2lkdGggLyAyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLmxlZnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLmxlZnQgKyBob3N0RWxQb3Mud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaGlmdEhlaWdodCA9IHtcbiAgICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3RFbFBvcy50b3AgKyBob3N0RWxQb3MuaGVpZ2h0IC8gMiAtIHRhcmdldEVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLnRvcDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdEVsUG9zLnRvcCArIGhvc3RFbFBvcy5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAocG9zMCkge1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRhcmdldEVsUG9zID0ge1xuICAgICAgICAgICAgICB0b3A6IHNoaWZ0SGVpZ2h0W3BvczFdKCksXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMF0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgdGFyZ2V0RWxQb3MgPSB7XG4gICAgICAgICAgICAgIHRvcDogc2hpZnRIZWlnaHRbcG9zMV0oKSxcbiAgICAgICAgICAgICAgbGVmdDogaG9zdEVsUG9zLmxlZnQgLSB0YXJnZXRFbFdpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHRhcmdldEVsUG9zID0ge1xuICAgICAgICAgICAgICB0b3A6IHNoaWZ0SGVpZ2h0W3BvczBdKCksXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMV0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRFbFBvcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiBob3N0RWxQb3MudG9wIC0gdGFyZ2V0RWxIZWlnaHQsXG4gICAgICAgICAgICAgIGxlZnQ6IHNoaWZ0V2lkdGhbcG9zMV0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldEVsUG9zO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuLyogRGVwcmVjYXRlZCBwb3NpdGlvbiBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvc2l0aW9uJylcblxuLnZhbHVlKCckcG9zaXRpb25TdXBwcmVzc1dhcm5pbmcnLCBmYWxzZSlcblxuLnNlcnZpY2UoJyRwb3NpdGlvbicsIFsnJGxvZycsICckcG9zaXRpb25TdXBwcmVzc1dhcm5pbmcnLCAnJHVpYlBvc2l0aW9uJywgZnVuY3Rpb24oJGxvZywgJHBvc2l0aW9uU3VwcHJlc3NXYXJuaW5nLCAkdWliUG9zaXRpb24pIHtcbiAgaWYgKCEkcG9zaXRpb25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAkbG9nLndhcm4oJyRwb3NpdGlvbiBpcyBub3cgZGVwcmVjYXRlZC4gVXNlICR1aWJQb3NpdGlvbiBpbnN0ZWFkLicpO1xuICB9XG5cbiAgYW5ndWxhci5leHRlbmQodGhpcywgJHVpYlBvc2l0aW9uKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGlja2VyJywgWyd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLnZhbHVlKCckZGF0ZXBpY2tlclN1cHByZXNzRXJyb3InLCBmYWxzZSlcblxuLmNvbnN0YW50KCd1aWJEYXRlcGlja2VyQ29uZmlnJywge1xuICBmb3JtYXREYXk6ICdkZCcsXG4gIGZvcm1hdE1vbnRoOiAnTU1NTScsXG4gIGZvcm1hdFllYXI6ICd5eXl5JyxcbiAgZm9ybWF0RGF5SGVhZGVyOiAnRUVFJyxcbiAgZm9ybWF0RGF5VGl0bGU6ICdNTU1NIHl5eXknLFxuICBmb3JtYXRNb250aFRpdGxlOiAneXl5eScsXG4gIGRhdGVwaWNrZXJNb2RlOiAnZGF5JyxcbiAgbWluTW9kZTogJ2RheScsXG4gIG1heE1vZGU6ICd5ZWFyJyxcbiAgc2hvd1dlZWtzOiB0cnVlLFxuICBzdGFydGluZ0RheTogMCxcbiAgeWVhclJhbmdlOiAyMCxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbWF4RGF0ZTogbnVsbCxcbiAgc2hvcnRjdXRQcm9wYWdhdGlvbjogZmFsc2Vcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgJyRsb2cnLCAnZGF0ZUZpbHRlcicsICd1aWJEYXRlcGlja2VyQ29uZmlnJywgJyRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcicsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSwgJGxvZywgZGF0ZUZpbHRlciwgZGF0ZXBpY2tlckNvbmZpZywgJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfTsgLy8gbnVsbE1vZGVsQ3RybDtcblxuICAvLyBNb2RlcyBjaGFpblxuICB0aGlzLm1vZGVzID0gWydkYXknLCAnbW9udGgnLCAneWVhciddO1xuXG4gIC8vIENvbmZpZ3VyYXRpb24gYXR0cmlidXRlc1xuICBhbmd1bGFyLmZvckVhY2goWydmb3JtYXREYXknLCAnZm9ybWF0TW9udGgnLCAnZm9ybWF0WWVhcicsICdmb3JtYXREYXlIZWFkZXInLCAnZm9ybWF0RGF5VGl0bGUnLCAnZm9ybWF0TW9udGhUaXRsZScsXG4gICAgICAgICAgICAgICAgICAgJ3Nob3dXZWVrcycsICdzdGFydGluZ0RheScsICd5ZWFyUmFuZ2UnLCAnc2hvcnRjdXRQcm9wYWdhdGlvbiddLCBmdW5jdGlvbihrZXksIGluZGV4KSB7XG4gICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzW2tleV0pID8gKGluZGV4IDwgNiA/ICRpbnRlcnBvbGF0ZSgkYXR0cnNba2V5XSkoJHNjb3BlLiRwYXJlbnQpIDogJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzW2tleV0pKSA6IGRhdGVwaWNrZXJDb25maWdba2V5XTtcbiAgfSk7XG5cbiAgLy8gV2F0Y2hhYmxlIGRhdGUgYXR0cmlidXRlc1xuICBhbmd1bGFyLmZvckVhY2goWydtaW5EYXRlJywgJ21heERhdGUnXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCRhdHRyc1trZXldKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRyc1trZXldKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2VsZltrZXldID0gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBudWxsO1xuICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZltrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldID8gbmV3IERhdGUoZGF0ZXBpY2tlckNvbmZpZ1trZXldKSA6IG51bGw7XG4gICAgfVxuICB9KTtcblxuICBhbmd1bGFyLmZvckVhY2goWydtaW5Nb2RlJywgJ21heE1vZGUnXSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCRhdHRyc1trZXldKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRyc1trZXldKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiAkYXR0cnNba2V5XTtcbiAgICAgICAgJHNjb3BlW2tleV0gPSBzZWxmW2tleV07XG4gICAgICAgIGlmICgoa2V5ID09ICdtaW5Nb2RlJyAmJiBzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSA8IHNlbGYubW9kZXMuaW5kZXhPZihzZWxmW2tleV0pKSB8fCAoa2V5ID09ICdtYXhNb2RlJyAmJiBzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSA+IHNlbGYubW9kZXMuaW5kZXhPZihzZWxmW2tleV0pKSkge1xuICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IHNlbGZba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGZba2V5XSA9IGRhdGVwaWNrZXJDb25maWdba2V5XSB8fCBudWxsO1xuICAgICAgJHNjb3BlW2tleV0gPSBzZWxmW2tleV07XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgfHwgZGF0ZXBpY2tlckNvbmZpZy5kYXRlcGlja2VyTW9kZTtcbiAgJHNjb3BlLnVuaXF1ZUlkID0gJ2RhdGVwaWNrZXItJyArICRzY29wZS4kaWQgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG5cbiAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5pbml0RGF0ZSkpIHtcbiAgICB0aGlzLmFjdGl2ZURhdGUgPSAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuaW5pdERhdGUpIHx8IG5ldyBEYXRlKCk7XG4gICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRhdHRycy5pbml0RGF0ZSwgZnVuY3Rpb24oaW5pdERhdGUpIHtcbiAgICAgIGlmIChpbml0RGF0ZSAmJiAobmdNb2RlbEN0cmwuJGlzRW1wdHkobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUpIHx8IG5nTW9kZWxDdHJsLiRpbnZhbGlkKSkge1xuICAgICAgICBzZWxmLmFjdGl2ZURhdGUgPSBpbml0RGF0ZTtcbiAgICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihkYXRlT2JqZWN0KSB7XG4gICAgaWYgKHNlbGYuY29tcGFyZShkYXRlT2JqZWN0LmRhdGUsIHNlbGYuYWN0aXZlRGF0ZSkgPT09IDApIHtcbiAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSBkYXRlT2JqZWN0LnVpZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG5cbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlbmRlcigpO1xuICAgIH07XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSxcbiAgICAgICAgICBpc1ZhbGlkID0gIWlzTmFOKGRhdGUpO1xuXG4gICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgfSBlbHNlIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2hWaWV3KCk7XG5cbiAgICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZURpc2FibGVkJywgIWRhdGUgfHwgKHRoaXMuZWxlbWVudCAmJiAhdGhpcy5pc0Rpc2FibGVkKGRhdGUpKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgIHZhciBtb2RlbCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBsYWJlbDogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpLFxuICAgICAgc2VsZWN0ZWQ6IG1vZGVsICYmIHRoaXMuY29tcGFyZShkYXRlLCBtb2RlbCkgPT09IDAsXG4gICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkKGRhdGUpLFxuICAgICAgY3VycmVudDogdGhpcy5jb21wYXJlKGRhdGUsIG5ldyBEYXRlKCkpID09PSAwLFxuICAgICAgY3VzdG9tQ2xhc3M6IHRoaXMuY3VzdG9tQ2xhc3MoZGF0ZSlcbiAgICB9O1xuICB9O1xuXG4gIHRoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1pbkRhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWluRGF0ZSkgPCAwKSB8fCAodGhpcy5tYXhEYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1heERhdGUpID4gMCkgfHwgKCRhdHRycy5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSkpKTtcbiAgfTtcblxuICB0aGlzLmN1c3RvbUNsYXNzID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAkc2NvcGUuY3VzdG9tQ2xhc3Moe2RhdGU6IGRhdGUsIG1vZGU6ICRzY29wZS5kYXRlcGlja2VyTW9kZX0pO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcbiAgdGhpcy5zcGxpdCA9IGZ1bmN0aW9uKGFyciwgc2l6ZSkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlzO1xuICB9O1xuXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5taW5Nb2RlKSB7XG4gICAgICB2YXIgZHQgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID8gbmV3IERhdGUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkgOiBuZXcgRGF0ZSgwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgIGR0LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGR0KTtcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hY3RpdmVEYXRlID0gZGF0ZTtcbiAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IHNlbGYubW9kZXNbc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyTW9kZSkgLSAxXTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICB2YXIgeWVhciA9IHNlbGYuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpICsgZGlyZWN0aW9uICogKHNlbGYuc3RlcC55ZWFycyB8fCAwKSxcbiAgICAgICAgbW9udGggPSBzZWxmLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIGRpcmVjdGlvbiAqIChzZWxmLnN0ZXAubW9udGhzIHx8IDApO1xuICAgIHNlbGYuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMSk7XG4gICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICB9O1xuXG4gICRzY29wZS50b2dnbGVNb2RlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IDE7XG5cbiAgICBpZiAoKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5tYXhNb2RlICYmIGRpcmVjdGlvbiA9PT0gMSkgfHwgKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5taW5Nb2RlICYmIGRpcmVjdGlvbiA9PT0gLTEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZi5tb2Rlc1tzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSArIGRpcmVjdGlvbl07XG4gIH07XG5cbiAgLy8gS2V5IGV2ZW50IG1hcHBlclxuICAkc2NvcGUua2V5cyA9IHsgMTM6ICdlbnRlcicsIDMyOiAnc3BhY2UnLCAzMzogJ3BhZ2V1cCcsIDM0OiAncGFnZWRvd24nLCAzNTogJ2VuZCcsIDM2OiAnaG9tZScsIDM3OiAnbGVmdCcsIDM4OiAndXAnLCAzOTogJ3JpZ2h0JywgNDA6ICdkb3duJyB9O1xuXG4gIHZhciBmb2N1c0VsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgfTtcblxuICAvLyBMaXN0ZW4gZm9yIGZvY3VzIHJlcXVlc3RzIGZyb20gcG9wdXAgZGlyZWN0aXZlXG4gICRzY29wZS4kb24oJ3VpYjpkYXRlcGlja2VyLmZvY3VzJywgZm9jdXNFbGVtZW50KTtcblxuICAkc2NvcGUua2V5ZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBrZXkgPSAkc2NvcGUua2V5c1tldnQud2hpY2hdO1xuXG4gICAgaWYgKCFrZXkgfHwgZXZ0LnNoaWZ0S2V5IHx8IGV2dC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXNlbGYuc2hvcnRjdXRQcm9wYWdhdGlvbikge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnc3BhY2UnKSB7XG4gICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKHNlbGYuYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgICAkc2NvcGUuc2VsZWN0KHNlbGYuYWN0aXZlRGF0ZSk7XG4gICAgfSBlbHNlIGlmIChldnQuY3RybEtleSAmJiAoa2V5ID09PSAndXAnIHx8IGtleSA9PT0gJ2Rvd24nKSkge1xuICAgICAgJHNjb3BlLnRvZ2dsZU1vZGUoa2V5ID09PSAndXAnID8gMSA6IC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5oYW5kbGVLZXlEb3duKGtleSwgZXZ0KTtcbiAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnRyb2xsZXIoJ1VpYkRheXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICdkYXRlRmlsdGVyJywgZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBkYXRlRmlsdGVyKSB7XG4gIHZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG4gIHRoaXMuc3RlcCA9IHsgbW9udGhzOiAxIH07XG4gIHRoaXMuZWxlbWVudCA9ICRlbGVtZW50O1xuICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIHJldHVybiAoKG1vbnRoID09PSAxKSAmJiAoeWVhciAlIDQgPT09IDApICYmICgoeWVhciAlIDEwMCAhPT0gMCkgfHwgKHllYXIgJSA0MDAgPT09IDApKSkgPyAyOSA6IERBWVNfSU5fTU9OVEhbbW9udGhdO1xuICB9XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oY3RybCkge1xuICAgIGFuZ3VsYXIuZXh0ZW5kKGN0cmwsIHRoaXMpO1xuICAgIHNjb3BlLnNob3dXZWVrcyA9IGN0cmwuc2hvd1dlZWtzO1xuICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcbiAgfTtcblxuICB0aGlzLmdldERhdGVzID0gZnVuY3Rpb24oc3RhcnREYXRlLCBuKSB7XG4gICAgdmFyIGRhdGVzID0gbmV3IEFycmF5KG4pLCBjdXJyZW50ID0gbmV3IERhdGUoc3RhcnREYXRlKSwgaSA9IDAsIGRhdGU7XG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUoY3VycmVudCk7XG4gICAgICBkYXRlc1tpKytdID0gZGF0ZTtcbiAgICAgIGN1cnJlbnQuc2V0RGF0ZShjdXJyZW50LmdldERhdGUoKSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG4gIH07XG5cbiAgdGhpcy5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgbW9udGggPSB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSxcbiAgICAgIGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSk7XG5cbiAgICBmaXJzdERheU9mTW9udGguc2V0RnVsbFllYXIoeWVhciwgbW9udGgsIDEpO1xuXG4gICAgdmFyIGRpZmZlcmVuY2UgPSB0aGlzLnN0YXJ0aW5nRGF5IC0gZmlyc3REYXlPZk1vbnRoLmdldERheSgpLFxuICAgICAgbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggPSAoZGlmZmVyZW5jZSA+IDApID8gNyAtIGRpZmZlcmVuY2UgOiAtIGRpZmZlcmVuY2UsXG4gICAgICBmaXJzdERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mTW9udGgpO1xuXG4gICAgaWYgKG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID4gMCkge1xuICAgICAgZmlyc3REYXRlLnNldERhdGUoLW51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoICsgMSk7XG4gICAgfVxuXG4gICAgLy8gNDIgaXMgdGhlIG51bWJlciBvZiBkYXlzIG9uIGEgc2l4LW1vbnRoIGNhbGVuZGFyXG4gICAgdmFyIGRheXMgPSB0aGlzLmdldERhdGVzKGZpcnN0RGF0ZSwgNDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDI7IGkgKyspIHtcbiAgICAgIGRheXNbaV0gPSBhbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoZGF5c1tpXSwgdGhpcy5mb3JtYXREYXkpLCB7XG4gICAgICAgIHNlY29uZGFyeTogZGF5c1tpXS5nZXRNb250aCgpICE9PSBtb250aCxcbiAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNjb3BlLmxhYmVscyA9IG5ldyBBcnJheSg3KTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgc2NvcGUubGFiZWxzW2pdID0ge1xuICAgICAgICBhYmJyOiBkYXRlRmlsdGVyKGRheXNbal0uZGF0ZSwgdGhpcy5mb3JtYXREYXlIZWFkZXIpLFxuICAgICAgICBmdWxsOiBkYXRlRmlsdGVyKGRheXNbal0uZGF0ZSwgJ0VFRUUnKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzY29wZS50aXRsZSA9IGRhdGVGaWx0ZXIodGhpcy5hY3RpdmVEYXRlLCB0aGlzLmZvcm1hdERheVRpdGxlKTtcbiAgICBzY29wZS5yb3dzID0gdGhpcy5zcGxpdChkYXlzLCA3KTtcblxuICAgIGlmIChzY29wZS5zaG93V2Vla3MpIHtcbiAgICAgIHNjb3BlLndlZWtOdW1iZXJzID0gW107XG4gICAgICB2YXIgdGh1cnNkYXlJbmRleCA9ICg0ICsgNyAtIHRoaXMuc3RhcnRpbmdEYXkpICUgNyxcbiAgICAgICAgICBudW1XZWVrcyA9IHNjb3BlLnJvd3MubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgY3VyV2VlayA9IDA7IGN1cldlZWsgPCBudW1XZWVrczsgY3VyV2VlaysrKSB7XG4gICAgICAgIHNjb3BlLndlZWtOdW1iZXJzLnB1c2goXG4gICAgICAgICAgZ2V0SVNPODYwMVdlZWtOdW1iZXIoc2NvcGUucm93c1tjdXJXZWVrXVt0aHVyc2RheUluZGV4XS5kYXRlKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpKSAtIG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldElTTzg2MDFXZWVrTnVtYmVyKGRhdGUpIHtcbiAgICB2YXIgY2hlY2tEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTsgLy8gVGh1cnNkYXlcbiAgICB2YXIgdGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG4gICAgY2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcbiAgICBjaGVja0RhdGUuc2V0RGF0ZSgxKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgdmFyIGRhdGUgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIDE7ICAgLy8gdXBcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSA3OyAgIC8vIGRvd25cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyAxOyAgIC8vIGRvd25cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIDc7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgdmFyIG1vbnRoID0gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkgKyAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpO1xuICAgICAgdGhpcy5hY3RpdmVEYXRlLnNldE1vbnRoKG1vbnRoLCAxKTtcbiAgICAgIGRhdGUgPSBNYXRoLm1pbihnZXREYXlzSW5Nb250aCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkpLCBkYXRlKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hvbWUnKSB7XG4gICAgICBkYXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcbiAgICAgIGRhdGUgPSBnZXREYXlzSW5Nb250aCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZURhdGUuc2V0RGF0ZShkYXRlKTtcbiAgfTtcbn1dKVxuXG4uY29udHJvbGxlcignVWliTW9udGhwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnZGF0ZUZpbHRlcicsIGZ1bmN0aW9uKHNjb3BlLCAkZWxlbWVudCwgZGF0ZUZpbHRlcikge1xuICB0aGlzLnN0ZXAgPSB7IHllYXJzOiAxIH07XG4gIHRoaXMuZWxlbWVudCA9ICRlbGVtZW50O1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBhbmd1bGFyLmV4dGVuZChjdHJsLCB0aGlzKTtcbiAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbW9udGhzID0gbmV3IEFycmF5KDEyKSxcbiAgICAgICAgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkYXRlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhciwgaSwgMSk7XG4gICAgICBtb250aHNbaV0gPSBhbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoZGF0ZSwgdGhpcy5mb3JtYXRNb250aCksIHtcbiAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNjb3BlLnRpdGxlID0gZGF0ZUZpbHRlcih0aGlzLmFjdGl2ZURhdGUsIHRoaXMuZm9ybWF0TW9udGhUaXRsZSk7XG4gICAgc2NvcGUucm93cyA9IHRoaXMuc3BsaXQobW9udGhzLCAzKTtcbiAgfTtcblxuICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSkgLSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpKTtcbiAgfTtcblxuICB0aGlzLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgIHZhciBkYXRlID0gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCk7XG5cbiAgICBpZiAoa2V5ID09PSAnbGVmdCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTsgICAvLyB1cFxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIDM7ICAgLy8gZG93blxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIDE7ICAgLy8gZG93blxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcbiAgICAgIGRhdGUgPSBkYXRlICsgMztcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3BhZ2V1cCcgfHwga2V5ID09PSAncGFnZWRvd24nKSB7XG4gICAgICB2YXIgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpICsgKGtleSA9PT0gJ3BhZ2V1cCcgPyAtIDEgOiAxKTtcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hvbWUnKSB7XG4gICAgICBkYXRlID0gMDtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcbiAgICAgIGRhdGUgPSAxMTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVEYXRlLnNldE1vbnRoKGRhdGUpO1xuICB9O1xufV0pXG5cbi5jb250cm9sbGVyKCdVaWJZZWFycGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihzY29wZSwgJGVsZW1lbnQsIGRhdGVGaWx0ZXIpIHtcbiAgdmFyIHJhbmdlO1xuICB0aGlzLmVsZW1lbnQgPSAkZWxlbWVudDtcblxuICBmdW5jdGlvbiBnZXRTdGFydGluZ1llYXIoeWVhcikge1xuICAgIHJldHVybiBwYXJzZUludCgoeWVhciAtIDEpIC8gcmFuZ2UsIDEwKSAqIHJhbmdlICsgMTtcbiAgfVxuXG4gIHRoaXMueWVhcnBpY2tlckluaXQgPSBmdW5jdGlvbigpIHtcbiAgICByYW5nZSA9IHRoaXMueWVhclJhbmdlO1xuICAgIHRoaXMuc3RlcCA9IHsgeWVhcnM6IHJhbmdlIH07XG4gIH07XG5cbiAgdGhpcy5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeWVhcnMgPSBuZXcgQXJyYXkocmFuZ2UpLCBkYXRlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHN0YXJ0ID0gZ2V0U3RhcnRpbmdZZWFyKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKTsgaSA8IHJhbmdlOyBpKyspIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgZGF0ZS5zZXRGdWxsWWVhcihzdGFydCArIGksIDAsIDEpO1xuICAgICAgeWVhcnNbaV0gPSBhbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoZGF0ZSwgdGhpcy5mb3JtYXRZZWFyKSwge1xuICAgICAgICB1aWQ6IHNjb3BlLnVuaXF1ZUlkICsgJy0nICsgaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2NvcGUudGl0bGUgPSBbeWVhcnNbMF0ubGFiZWwsIHllYXJzW3JhbmdlIC0gMV0ubGFiZWxdLmpvaW4oJyAtICcpO1xuICAgIHNjb3BlLnJvd3MgPSB0aGlzLnNwbGl0KHllYXJzLCA1KTtcbiAgfTtcblxuICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcbiAgICByZXR1cm4gZGF0ZTEuZ2V0RnVsbFllYXIoKSAtIGRhdGUyLmdldEZ1bGxZZWFyKCk7XG4gIH07XG5cbiAgdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oa2V5LCBldnQpIHtcbiAgICB2YXIgZGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIDE7ICAgLy8gdXBcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSA1OyAgIC8vIGRvd25cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyAxOyAgIC8vIGRvd25cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIDU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xuICAgICAgZGF0ZSArPSAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpICogdGhpcy5zdGVwLnllYXJzO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcbiAgICAgIGRhdGUgPSBnZXRTdGFydGluZ1llYXIodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSkgKyByYW5nZSAtIDE7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcihkYXRlKTtcbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWwnO1xuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGRhdGVwaWNrZXJNb2RlOiAnPT8nLFxuICAgICAgZGF0ZURpc2FibGVkOiAnJicsXG4gICAgICBjdXN0b21DbGFzczogJyYnLFxuICAgICAgc2hvcnRjdXRQcm9wYWdhdGlvbjogJyY/J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWyd1aWJEYXRlcGlja2VyJywgJ15uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkRhdGVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdkYXRlcGlja2VyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZGF0ZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliRGF5cGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbCc7XG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ14/dWliRGF0ZXBpY2tlcicsICd1aWJEYXlwaWNrZXInLCAnXj9kYXRlcGlja2VyJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkRheXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdIHx8IGN0cmxzWzJdLFxuICAgICAgICBkYXlwaWNrZXJDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGRheXBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliTW9udGhwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWwnO1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydeP3VpYkRhdGVwaWNrZXInLCAndWliTW9udGhwaWNrZXInLCAnXj9kYXRlcGlja2VyJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYk1vbnRocGlja2VyQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGRhdGVwaWNrZXJDdHJsID0gY3RybHNbMF0gfHwgY3RybHNbMl0sXG4gICAgICAgIG1vbnRocGlja2VyQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBtb250aHBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliWWVhcnBpY2tlcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sJztcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnXj91aWJEYXRlcGlja2VyJywgJ3VpYlllYXJwaWNrZXInLCAnXj9kYXRlcGlja2VyJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYlllYXJwaWNrZXJDb250cm9sbGVyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgY3RybCA9IGN0cmxzWzBdIHx8IGN0cmxzWzJdO1xuICAgICAgYW5ndWxhci5leHRlbmQoY3RybCwgY3RybHNbMV0pO1xuICAgICAgY3RybC55ZWFycGlja2VySW5pdCgpO1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufSlcblxuLmNvbnN0YW50KCd1aWJEYXRlcGlja2VyUG9wdXBDb25maWcnLCB7XG4gIGRhdGVwaWNrZXJQb3B1cDogJ3l5eXktTU0tZGQnLFxuICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbCcsXG4gIGRhdGVwaWNrZXJUZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJyxcbiAgaHRtbDVUeXBlczoge1xuICAgIGRhdGU6ICd5eXl5LU1NLWRkJyxcbiAgICAnZGF0ZXRpbWUtbG9jYWwnOiAneXl5eS1NTS1kZFRISDptbTpzcy5zc3MnLFxuICAgICdtb250aCc6ICd5eXl5LU1NJ1xuICB9LFxuICBjdXJyZW50VGV4dDogJ1RvZGF5JyxcbiAgY2xlYXJUZXh0OiAnQ2xlYXInLFxuICBjbG9zZVRleHQ6ICdEb25lJyxcbiAgY2xvc2VPbkRhdGVTZWxlY3Rpb246IHRydWUsXG4gIGFwcGVuZFRvQm9keTogZmFsc2UsXG4gIHNob3dCdXR0b25CYXI6IHRydWUsXG4gIG9uT3BlbkZvY3VzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignVWliRGF0ZXBpY2tlclBvcHVwQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckY29tcGlsZScsICckcGFyc2UnLCAnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCAnJHVpYlBvc2l0aW9uJywgJ2RhdGVGaWx0ZXInLCAndWliRGF0ZVBhcnNlcicsICd1aWJEYXRlcGlja2VyUG9wdXBDb25maWcnLCAnJHRpbWVvdXQnLFxuZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCAkY29tcGlsZSwgJHBhcnNlLCAkZG9jdW1lbnQsICRyb290U2NvcGUsICRwb3NpdGlvbiwgZGF0ZUZpbHRlciwgZGF0ZVBhcnNlciwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLCAkdGltZW91dCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWNoZSA9IHt9LFxuICAgIGlzSHRtbDVEYXRlSW5wdXQgPSBmYWxzZTtcbiAgdmFyIGRhdGVGb3JtYXQsIGNsb3NlT25EYXRlU2VsZWN0aW9uLCBhcHBlbmRUb0JvZHksIG9uT3BlbkZvY3VzLFxuICAgIGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsLCBkYXRlcGlja2VyVGVtcGxhdGVVcmwsIHBvcHVwRWwsIGRhdGVwaWNrZXJFbCxcbiAgICBuZ01vZGVsLCAkcG9wdXA7XG5cbiAgc2NvcGUud2F0Y2hEYXRhID0ge307XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oX25nTW9kZWxfKSB7XG4gICAgbmdNb2RlbCA9IF9uZ01vZGVsXztcbiAgICBjbG9zZU9uRGF0ZVNlbGVjdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmNsb3NlT25EYXRlU2VsZWN0aW9uKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmNsb3NlT25EYXRlU2VsZWN0aW9uO1xuICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5hcHBlbmRUb0JvZHk7XG4gICAgb25PcGVuRm9jdXMgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5vbk9wZW5Gb2N1cykgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLm9uT3BlbkZvY3VzKSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5vbk9wZW5Gb2N1cztcbiAgICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsKSA/IGF0dHJzLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsO1xuICAgIGRhdGVwaWNrZXJUZW1wbGF0ZVVybCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCkgPyBhdHRycy5kYXRlcGlja2VyVGVtcGxhdGVVcmwgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclRlbXBsYXRlVXJsO1xuXG4gICAgc2NvcGUuc2hvd0J1dHRvbkJhciA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnNob3dCdXR0b25CYXIpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5zaG93QnV0dG9uQmFyKSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5zaG93QnV0dG9uQmFyO1xuXG4gICAgaWYgKGRhdGVwaWNrZXJQb3B1cENvbmZpZy5odG1sNVR5cGVzW2F0dHJzLnR5cGVdKSB7XG4gICAgICBkYXRlRm9ybWF0ID0gZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmh0bWw1VHlwZXNbYXR0cnMudHlwZV07XG4gICAgICBpc0h0bWw1RGF0ZUlucHV0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZUZvcm1hdCA9IGF0dHJzLmRhdGVwaWNrZXJQb3B1cCB8fCBhdHRycy51aWJEYXRlcGlja2VyUG9wdXAgfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cDtcbiAgICAgIGF0dHJzLiRvYnNlcnZlKCd1aWJEYXRlcGlja2VyUG9wdXAnLCBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICB2YXIgbmV3RGF0ZUZvcm1hdCA9IHZhbHVlIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyUG9wdXA7XG4gICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgJG1vZGVsVmFsdWUgdG8gZW5zdXJlIHRoYXQgZm9ybWF0dGVycyByZS1ydW5cbiAgICAgICAgICAvLyBGSVhNRTogUmVmYWN0b3Igd2hlbiBQUiBpcyBtZXJnZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8xMDc2NFxuICAgICAgICAgIGlmIChuZXdEYXRlRm9ybWF0ICE9PSBkYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICBkYXRlRm9ybWF0ID0gbmV3RGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGVGb3JtYXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aWJEYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGF0ZUZvcm1hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aWJEYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIGlmIChpc0h0bWw1RGF0ZUlucHV0ICYmIGF0dHJzLmRhdGVwaWNrZXJQb3B1cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVE1MNSBkYXRlIGlucHV0IHR5cGVzIGRvIG5vdCBzdXBwb3J0IGN1c3RvbSBmb3JtYXRzLicpO1xuICAgIH1cblxuICAgIC8vIHBvcHVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyXG4gICAgcG9wdXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItZGF0ZXBpY2tlci1wb3B1cC13cmFwPjxkaXYgdWliLWRhdGVwaWNrZXI+PC9kaXY+PC9kaXY+Jyk7XG4gICAgcG9wdXBFbC5hdHRyKHtcbiAgICAgICduZy1tb2RlbCc6ICdkYXRlJyxcbiAgICAgICduZy1jaGFuZ2UnOiAnZGF0ZVNlbGVjdGlvbihkYXRlKScsXG4gICAgICAndGVtcGxhdGUtdXJsJzogZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmxcbiAgICB9KTtcblxuICAgIC8vIGRhdGVwaWNrZXIgZWxlbWVudFxuICAgIGRhdGVwaWNrZXJFbCA9IGFuZ3VsYXIuZWxlbWVudChwb3B1cEVsLmNoaWxkcmVuKClbMF0pO1xuICAgIGRhdGVwaWNrZXJFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBkYXRlcGlja2VyVGVtcGxhdGVVcmwpO1xuXG4gICAgaWYgKGlzSHRtbDVEYXRlSW5wdXQpIHtcbiAgICAgIGlmIChhdHRycy50eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdkYXRlcGlja2VyLW1vZGUnLCAnXCJtb250aFwiJyk7XG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdtaW4tbW9kZScsICdtb250aCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRycy5kYXRlcGlja2VyT3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRhdGVwaWNrZXJPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5pdERhdGUpIHtcbiAgICAgICAgc2NvcGUuaW5pdERhdGUgPSBvcHRpb25zLmluaXREYXRlO1xuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignaW5pdC1kYXRlJywgJ2luaXREYXRlJyk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmluaXREYXRlO1xuICAgICAgfVxuICAgICAgYW5ndWxhci5mb3JFYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBvcHRpb24pIHtcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoY2FtZWx0b0Rhc2gob3B0aW9uKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYW5ndWxhci5mb3JFYWNoKFsnbWluTW9kZScsICdtYXhNb2RlJywgJ21pbkRhdGUnLCAnbWF4RGF0ZScsICdkYXRlcGlja2VyTW9kZScsICdpbml0RGF0ZScsICdzaG9ydGN1dFByb3BhZ2F0aW9uJ10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGF0dHJzW2tleV0pIHtcbiAgICAgICAgdmFyIGdldEF0dHJpYnV0ZSA9ICRwYXJzZShhdHRyc1trZXldKTtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goZ2V0QXR0cmlidXRlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHNjb3BlLndhdGNoRGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ21pbkRhdGUnIHx8IGtleSA9PT0gJ21heERhdGUnKSB7XG4gICAgICAgICAgICBjYWNoZVtrZXldID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKGNhbWVsdG9EYXNoKGtleSksICd3YXRjaERhdGEuJyArIGtleSk7XG5cbiAgICAgICAgLy8gUHJvcGFnYXRlIGNoYW5nZXMgZnJvbSBkYXRlcGlja2VyIHRvIG91dHNpZGVcbiAgICAgICAgaWYgKGtleSA9PT0gJ2RhdGVwaWNrZXJNb2RlJykge1xuICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSBnZXRBdHRyaWJ1dGUuYXNzaWduO1xuICAgICAgICAgIHNjb3BlLiR3YXRjaCgnd2F0Y2hEYXRhLicgKyBrZXksIGZ1bmN0aW9uKHZhbHVlLCBvbGR2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRBdHRyaWJ1dGUpICYmIHZhbHVlICE9PSBvbGR2YWx1ZSkge1xuICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoc2NvcGUuJHBhcmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGF0dHJzLmRhdGVEaXNhYmxlZCkge1xuICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2RhdGUtZGlzYWJsZWQnLCAnZGF0ZURpc2FibGVkKHsgZGF0ZTogZGF0ZSwgbW9kZTogbW9kZSB9KScpO1xuICAgIH1cblxuICAgIGlmIChhdHRycy5zaG93V2Vla3MpIHtcbiAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdzaG93LXdlZWtzJywgYXR0cnMuc2hvd1dlZWtzKTtcbiAgICB9XG5cbiAgICBpZiAoYXR0cnMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdjdXN0b20tY2xhc3MnLCAnY3VzdG9tQ2xhc3MoeyBkYXRlOiBkYXRlLCBtb2RlOiBtb2RlIH0pJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0h0bWw1RGF0ZUlucHV0KSB7XG4gICAgICAvLyBJbnRlcm5hbCBBUEkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgbmctaW52YWxpZC1ba2V5XSBjbGFzc1xuICAgICAgbmdNb2RlbC4kJHBhcnNlck5hbWUgPSAnZGF0ZSc7XG4gICAgICBuZ01vZGVsLiR2YWxpZGF0b3JzLmRhdGUgPSB2YWxpZGF0b3I7XG4gICAgICBuZ01vZGVsLiRwYXJzZXJzLnVuc2hpZnQocGFyc2VEYXRlKTtcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzY29wZS5kYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBuZ01vZGVsLiRpc0VtcHR5KHZhbHVlKSA/IHZhbHVlIDogZGF0ZUZpbHRlcih2YWx1ZSwgZGF0ZUZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHNjb3BlLmRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGNoYW5nZXMgaW4gdGhlIHZpZXcgZnJvbSB0aGUgdGV4dCBib3hcbiAgICBuZ01vZGVsLiR2aWV3Q2hhbmdlTGlzdGVuZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICBzY29wZS5kYXRlID0gZGF0ZVBhcnNlci5wYXJzZShuZ01vZGVsLiR2aWV3VmFsdWUsIGRhdGVGb3JtYXQsIHNjb3BlLmRhdGUpO1xuICAgIH0pO1xuXG4gICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgaW5wdXRLZXlkb3duQmluZCk7XG5cbiAgICAkcG9wdXAgPSAkY29tcGlsZShwb3B1cEVsKShzY29wZSk7XG4gICAgLy8gUHJldmVudCBqUXVlcnkgY2FjaGUgbWVtb3J5IGxlYWsgKHRlbXBsYXRlIGlzIG5vdyByZWR1bmRhbnQgYWZ0ZXIgbGlua2luZylcbiAgICBwb3B1cEVsLnJlbW92ZSgpO1xuXG4gICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQoJHBvcHVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgIH1cblxuICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzY29wZS5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkcG9wdXAucmVtb3ZlKCk7XG4gICAgICBlbGVtZW50LnVuYmluZCgna2V5ZG93bicsIGlucHV0S2V5ZG93bkJpbmQpO1xuICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBzY29wZVtrZXkgKyAnVGV4dCddIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZ1trZXkgKyAnVGV4dCddO1xuICB9O1xuXG4gIHNjb3BlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKGRhdGUgPT09ICd0b2RheScpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiAoKHNjb3BlLndhdGNoRGF0YS5taW5EYXRlICYmIHNjb3BlLmNvbXBhcmUoZGF0ZSwgY2FjaGUubWluRGF0ZSkgPCAwKSB8fFxuICAgICAgKHNjb3BlLndhdGNoRGF0YS5tYXhEYXRlICYmIHNjb3BlLmNvbXBhcmUoZGF0ZSwgY2FjaGUubWF4RGF0ZSkgPiAwKSk7XG4gIH07XG5cbiAgc2NvcGUuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpKSAtIG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSkpO1xuICB9O1xuXG4gIC8vIElubmVyIGNoYW5nZVxuICBzY29wZS5kYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oZHQpIHtcbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoZHQpKSB7XG4gICAgICBzY29wZS5kYXRlID0gZHQ7XG4gICAgfVxuICAgIHZhciBkYXRlID0gc2NvcGUuZGF0ZSA/IGRhdGVGaWx0ZXIoc2NvcGUuZGF0ZSwgZGF0ZUZvcm1hdCkgOiBudWxsOyAvLyBTZXR0aW5nIHRvIE5VTEwgaXMgbmVjZXNzYXJ5IGZvciBmb3JtIHZhbGlkYXRvcnMgdG8gZnVuY3Rpb25cbiAgICBlbGVtZW50LnZhbChkYXRlKTtcbiAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoZGF0ZSk7XG5cbiAgICBpZiAoY2xvc2VPbkRhdGVTZWxlY3Rpb24pIHtcbiAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBzY29wZS5rZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKGRhdGUgPT09ICd0b2RheScpIHtcbiAgICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICBpZiAoYW5ndWxhci5pc0RhdGUoc2NvcGUuZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHNjb3BlLmRhdGUpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0gbmV3IERhdGUodG9kYXkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY29wZS5kYXRlU2VsZWN0aW9uKGRhdGUpO1xuICB9O1xuXG4gIHNjb3BlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgZWxlbWVudFswXS5mb2N1cygpO1xuICB9O1xuXG4gIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHNjb3BlLnBvc2l0aW9uID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCA9IHNjb3BlLnBvc2l0aW9uLnRvcCArIGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG5cbiAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAob25PcGVuRm9jdXMpIHtcbiAgICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCd1aWI6ZGF0ZXBpY2tlci5mb2N1cycpO1xuICAgICAgICB9XG4gICAgICAgICRkb2N1bWVudC5iaW5kKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjYW1lbHRvRGFzaChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24oJDEpIHsgcmV0dXJuICctJyArICQxLnRvTG93ZXJDYXNlKCk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXRlKHZpZXdWYWx1ZSkge1xuICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZpZXdWYWx1ZSkpIHtcbiAgICAgIC8vIHByZXN1bWFibHkgdGltZXN0YW1wIHRvIGRhdGUgb2JqZWN0XG4gICAgICB2aWV3VmFsdWUgPSBuZXcgRGF0ZSh2aWV3VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghdmlld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNEYXRlKHZpZXdWYWx1ZSkgJiYgIWlzTmFOKHZpZXdWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB2aWV3VmFsdWU7XG4gICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZpZXdWYWx1ZSkpIHtcbiAgICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlci5wYXJzZSh2aWV3VmFsdWUsIGRhdGVGb3JtYXQsIHNjb3BlLmRhdGUpO1xuICAgICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0b3IobW9kZWxWYWx1ZSwgdmlld1ZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XG5cbiAgICBpZiAoIWF0dHJzLm5nUmVxdWlyZWQgJiYgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNEYXRlKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB2YXIgZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2UodmFsdWUsIGRhdGVGb3JtYXQpO1xuICAgICAgcmV0dXJuICFpc05hTihkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2tCaW5kKGV2ZW50KSB7XG4gICAgdmFyIHBvcHVwID0gJHBvcHVwWzBdO1xuICAgIHZhciBkcENvbnRhaW5zVGFyZ2V0ID0gZWxlbWVudFswXS5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgIC8vIFRoZSBwb3B1cCBub2RlIG1heSBub3QgYmUgYW4gZWxlbWVudCBub2RlXG4gICAgLy8gSW4gc29tZSBicm93c2VycyAoSUUpIG9ubHkgZWxlbWVudCBub2RlcyBoYXZlIHRoZSAnY29udGFpbnMnIGZ1bmN0aW9uXG4gICAgdmFyIHBvcHVwQ29udGFpbnNUYXJnZXQgPSBwb3B1cC5jb250YWlucyAhPT0gdW5kZWZpbmVkICYmIHBvcHVwLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKHNjb3BlLmlzT3BlbiAmJiAhKGRwQ29udGFpbnNUYXJnZXQgfHwgcG9wdXBDb250YWluc1RhcmdldCkpIHtcbiAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dEtleWRvd25CaW5kKGV2dCkge1xuICAgIGlmIChldnQud2hpY2ggPT09IDI3ICYmIHNjb3BlLmlzT3Blbikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDQwICYmICFzY29wZS5pc09wZW4pIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICBzY29wZS5pc09wZW4gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XSlcblxuLmRpcmVjdGl2ZSgndWliRGF0ZXBpY2tlclBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ3VpYkRhdGVwaWNrZXJQb3B1cCddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJEYXRlcGlja2VyUG9wdXBDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgaXNPcGVuOiAnPT8nLFxuICAgICAgY3VycmVudFRleHQ6ICdAJyxcbiAgICAgIGNsZWFyVGV4dDogJ0AnLFxuICAgICAgY2xvc2VUZXh0OiAnQCcsXG4gICAgICBkYXRlRGlzYWJsZWQ6ICcmJyxcbiAgICAgIGN1c3RvbUNsYXNzOiAnJidcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBuZ01vZGVsID0gY3RybHNbMF0sXG4gICAgICAgIGN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgY3RybC5pbml0KG5nTW9kZWwpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkRhdGVwaWNrZXJQb3B1cFdyYXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbCc7XG4gICAgfVxuICB9O1xufSk7XG5cbi8qIERlcHJlY2F0ZWQgZGF0ZXBpY2tlciBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInKVxuXG4udmFsdWUoJyRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbi5jb250cm9sbGVyKCdEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgJyRsb2cnLCAnZGF0ZUZpbHRlcicsICd1aWJEYXRlcGlja2VyQ29uZmlnJywgJyRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcicsICckZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSwgJGxvZywgZGF0ZUZpbHRlciwgZGF0ZXBpY2tlckNvbmZpZywgJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yLCAkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICBpZiAoISRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgJGxvZy53YXJuKCdEYXRlcGlja2VyQ29udHJvbGxlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIFVpYkRhdGVwaWNrZXJDb250cm9sbGVyIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9OyAvLyBudWxsTW9kZWxDdHJsO1xuXG4gIHRoaXMubW9kZXMgPSBbJ2RheScsICdtb250aCcsICd5ZWFyJ107XG5cbiAgYW5ndWxhci5mb3JFYWNoKFsnZm9ybWF0RGF5JywgJ2Zvcm1hdE1vbnRoJywgJ2Zvcm1hdFllYXInLCAnZm9ybWF0RGF5SGVhZGVyJywgJ2Zvcm1hdERheVRpdGxlJywgJ2Zvcm1hdE1vbnRoVGl0bGUnLFxuICAgICdzaG93V2Vla3MnLCAnc3RhcnRpbmdEYXknLCAneWVhclJhbmdlJywgJ3Nob3J0Y3V0UHJvcGFnYXRpb24nXSwgZnVuY3Rpb24oa2V5LCBpbmRleCkge1xuICAgIHNlbGZba2V5XSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRyc1trZXldKSA/IChpbmRleCA8IDYgPyAkaW50ZXJwb2xhdGUoJGF0dHJzW2tleV0pKCRzY29wZS4kcGFyZW50KSA6ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRyc1trZXldKSkgOiBkYXRlcGlja2VyQ29uZmlnW2tleV07XG4gIH0pO1xuXG4gIGFuZ3VsYXIuZm9yRWFjaChbJ21pbkRhdGUnLCAnbWF4RGF0ZSddLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoJGF0dHJzW2tleV0pIHtcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzW2tleV0pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmW2tleV0gPSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG51bGw7XG4gICAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmW2tleV0gPSBkYXRlcGlja2VyQ29uZmlnW2tleV0gPyBuZXcgRGF0ZShkYXRlcGlja2VyQ29uZmlnW2tleV0pIDogbnVsbDtcbiAgICB9XG4gIH0pO1xuXG4gIGFuZ3VsYXIuZm9yRWFjaChbJ21pbk1vZGUnLCAnbWF4TW9kZSddLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoJGF0dHJzW2tleV0pIHtcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzW2tleV0pLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6ICRhdHRyc1trZXldO1xuICAgICAgICAkc2NvcGVba2V5XSA9IHNlbGZba2V5XTtcbiAgICAgICAgaWYgKChrZXkgPT0gJ21pbk1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpIDwgc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkpIHx8IChrZXkgPT0gJ21heE1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpID4gc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkpKSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZltrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZltrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldIHx8IG51bGw7XG4gICAgICAkc2NvcGVba2V5XSA9IHNlbGZba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gICRzY29wZS5kYXRlcGlja2VyTW9kZSA9ICRzY29wZS5kYXRlcGlja2VyTW9kZSB8fCBkYXRlcGlja2VyQ29uZmlnLmRhdGVwaWNrZXJNb2RlO1xuICAkc2NvcGUudW5pcXVlSWQgPSAnZGF0ZXBpY2tlci0nICsgJHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcblxuICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmluaXREYXRlKSkge1xuICAgIHRoaXMuYWN0aXZlRGF0ZSA9ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5pbml0RGF0ZSkgfHwgbmV3IERhdGUoKTtcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJGF0dHJzLmluaXREYXRlLCBmdW5jdGlvbihpbml0RGF0ZSkge1xuICAgICAgaWYgKGluaXREYXRlICYmIChuZ01vZGVsQ3RybC4kaXNFbXB0eShuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkgfHwgbmdNb2RlbEN0cmwuJGludmFsaWQpKSB7XG4gICAgICAgIHNlbGYuYWN0aXZlRGF0ZSA9IGluaXREYXRlO1xuICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcbiAgICBpZiAoc2VsZi5jb21wYXJlKGRhdGVPYmplY3QuZGF0ZSwgc2VsZi5hY3RpdmVEYXRlKSA9PT0gMCkge1xuICAgICAgJHNjb3BlLmFjdGl2ZURhdGVJZCA9IGRhdGVPYmplY3QudWlkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8pIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcblxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpLFxuICAgICAgICBpc1ZhbGlkID0gIWlzTmFOKGRhdGUpO1xuXG4gICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgfSBlbHNlIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yKSB7XG4gICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3JlZnJlc2hWaWV3KCk7XG5cbiAgICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZURpc2FibGVkJywgIWRhdGUgfHwgKHRoaXMuZWxlbWVudCAmJiAhdGhpcy5pc0Rpc2FibGVkKGRhdGUpKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xuICAgIHZhciBtb2RlbCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBsYWJlbDogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpLFxuICAgICAgc2VsZWN0ZWQ6IG1vZGVsICYmIHRoaXMuY29tcGFyZShkYXRlLCBtb2RlbCkgPT09IDAsXG4gICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkKGRhdGUpLFxuICAgICAgY3VycmVudDogdGhpcy5jb21wYXJlKGRhdGUsIG5ldyBEYXRlKCkpID09PSAwLFxuICAgICAgY3VzdG9tQ2xhc3M6IHRoaXMuY3VzdG9tQ2xhc3MoZGF0ZSlcbiAgICB9O1xuICB9O1xuXG4gIHRoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1pbkRhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWluRGF0ZSkgPCAwKSB8fCAodGhpcy5tYXhEYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1heERhdGUpID4gMCkgfHwgKCRhdHRycy5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSkpKTtcbiAgfTtcblxuICB0aGlzLmN1c3RvbUNsYXNzID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAkc2NvcGUuY3VzdG9tQ2xhc3Moe2RhdGU6IGRhdGUsIG1vZGU6ICRzY29wZS5kYXRlcGlja2VyTW9kZX0pO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcbiAgdGhpcy5zcGxpdCA9IGZ1bmN0aW9uKGFyciwgc2l6ZSkge1xuICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlzO1xuICB9O1xuXG4gIHRoaXMuZml4VGltZVpvbmUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICAgIGRhdGUuc2V0SG91cnMoaG91cnMgPT09IDIzID8gaG91cnMgKyAyIDogMCk7XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1pbk1vZGUpIHtcbiAgICAgIHZhciBkdCA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG5ldyBEYXRlKDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgZHQuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZHQpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZi5tb2Rlc1tzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSAtIDFdO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciB5ZWFyID0gc2VsZi5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLnllYXJzIHx8IDApLFxuICAgICAgbW9udGggPSBzZWxmLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIGRpcmVjdGlvbiAqIChzZWxmLnN0ZXAubW9udGhzIHx8IDApO1xuICAgIHNlbGYuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMSk7XG4gICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICB9O1xuXG4gICRzY29wZS50b2dnbGVNb2RlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IDE7XG5cbiAgICBpZiAoKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5tYXhNb2RlICYmIGRpcmVjdGlvbiA9PT0gMSkgfHwgKCRzY29wZS5kYXRlcGlja2VyTW9kZSA9PT0gc2VsZi5taW5Nb2RlICYmIGRpcmVjdGlvbiA9PT0gLTEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID0gc2VsZi5tb2Rlc1tzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSArIGRpcmVjdGlvbl07XG4gIH07XG5cbiAgLy8gS2V5IGV2ZW50IG1hcHBlclxuICAkc2NvcGUua2V5cyA9IHsgMTM6ICdlbnRlcicsIDMyOiAnc3BhY2UnLCAzMzogJ3BhZ2V1cCcsIDM0OiAncGFnZWRvd24nLCAzNTogJ2VuZCcsIDM2OiAnaG9tZScsIDM3OiAnbGVmdCcsIDM4OiAndXAnLCAzOTogJ3JpZ2h0JywgNDA6ICdkb3duJyB9O1xuXG4gIHZhciBmb2N1c0VsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgfTtcblxuICAkc2NvcGUuJG9uKCd1aWI6ZGF0ZXBpY2tlci5mb2N1cycsIGZvY3VzRWxlbWVudCk7XG5cbiAgJHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIga2V5ID0gJHNjb3BlLmtleXNbZXZ0LndoaWNoXTtcblxuICAgIGlmICgha2V5IHx8IGV2dC5zaGlmdEtleSB8fCBldnQuYWx0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCFzZWxmLnNob3J0Y3V0UHJvcGFnYXRpb24pIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnZW50ZXInIHx8IGtleSA9PT0gJ3NwYWNlJykge1xuICAgICAgaWYgKHNlbGYuaXNEaXNhYmxlZChzZWxmLmFjdGl2ZURhdGUpKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xuICAgICAgfVxuICAgICAgJHNjb3BlLnNlbGVjdChzZWxmLmFjdGl2ZURhdGUpO1xuICAgIH0gZWxzZSBpZiAoZXZ0LmN0cmxLZXkgJiYgKGtleSA9PT0gJ3VwJyB8fCBrZXkgPT09ICdkb3duJykpIHtcbiAgICAgICRzY29wZS50b2dnbGVNb2RlKGtleSA9PT0gJ3VwJyA/IDEgOiAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaGFuZGxlS2V5RG93bihrZXksIGV2dCk7XG4gICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXInLCBbJyRsb2cnLCAnJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBkYXRlcGlja2VyTW9kZTogJz0/JyxcbiAgICAgIGRhdGVEaXNhYmxlZDogJyYnLFxuICAgICAgY3VzdG9tQ2xhc3M6ICcmJyxcbiAgICAgIHNob3J0Y3V0UHJvcGFnYXRpb246ICcmPydcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnZGF0ZXBpY2tlcicsICdebmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdEYXRlcGlja2VyQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAnZGF0ZXBpY2tlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgaWYgKCEkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ2RhdGVwaWNrZXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItZGF0ZXBpY2tlciBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZGF0ZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2RheXBpY2tlcicsIFsnJGxvZycsICckZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWwnLFxuICAgIHJlcXVpcmU6IFsnXmRhdGVwaWNrZXInLCAnZGF5cGlja2VyJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkRheXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdkYXlwaWNrZXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItZGF5cGlja2VyIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLFxuICAgICAgICBkYXlwaWNrZXJDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGRheXBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ21vbnRocGlja2VyJywgWyckbG9nJywgJyRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sJyxcbiAgICByZXF1aXJlOiBbJ15kYXRlcGlja2VyJywgJ21vbnRocGlja2VyJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYk1vbnRocGlja2VyQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgaWYgKCEkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ21vbnRocGlja2VyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLW1vbnRocGlja2VyIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLFxuICAgICAgICBtb250aHBpY2tlckN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgbW9udGhwaWNrZXJDdHJsLmluaXQoZGF0ZXBpY2tlckN0cmwpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd5ZWFycGlja2VyJywgWyckbG9nJywgJyRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWwnLFxuICAgIHJlcXVpcmU6IFsnXmRhdGVwaWNrZXInLCAneWVhcnBpY2tlciddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJZZWFycGlja2VyQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgaWYgKCEkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3llYXJwaWNrZXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWIteWVhcnBpY2tlciBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RybCA9IGN0cmxzWzBdO1xuICAgICAgYW5ndWxhci5leHRlbmQoY3RybCwgY3RybHNbMV0pO1xuICAgICAgY3RybC55ZWFycGlja2VySW5pdCgpO1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXJQb3B1cCcsIFsnJGxvZycsICckZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRkYXRlcGlja2VyU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ2RhdGVwaWNrZXJQb3B1cCddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJEYXRlcGlja2VyUG9wdXBDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgaXNPcGVuOiAnPT8nLFxuICAgICAgY3VycmVudFRleHQ6ICdAJyxcbiAgICAgIGNsZWFyVGV4dDogJ0AnLFxuICAgICAgY2xvc2VUZXh0OiAnQCcsXG4gICAgICBkYXRlRGlzYWJsZWQ6ICcmJyxcbiAgICAgIGN1c3RvbUNsYXNzOiAnJidcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIGlmICghJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdkYXRlcGlja2VyLXBvcHVwIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWRhdGVwaWNrZXItcG9wdXAgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5nTW9kZWwgPSBjdHJsc1swXSxcbiAgICAgICAgY3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBjdHJsLmluaXQobmdNb2RlbCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXJQb3B1cFdyYXAnLCBbJyRsb2cnLCAnJGRhdGVwaWNrZXJTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sJztcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEkZGF0ZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ2RhdGVwaWNrZXItcG9wdXAtd3JhcCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1kYXRlcGlja2VyLXBvcHVwLXdyYXAgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZHJvcGRvd24nLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4uY29uc3RhbnQoJ3VpYkRyb3Bkb3duQ29uZmlnJywge1xuICBvcGVuQ2xhc3M6ICdvcGVuJ1xufSlcblxuLnNlcnZpY2UoJ3VpYkRyb3Bkb3duU2VydmljZScsIFsnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCBmdW5jdGlvbigkZG9jdW1lbnQsICRyb290U2NvcGUpIHtcbiAgdmFyIG9wZW5TY29wZSA9IG51bGw7XG5cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSkge1xuICAgIGlmICghb3BlblNjb3BlKSB7XG4gICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBjbG9zZURyb3Bkb3duKTtcbiAgICAgICRkb2N1bWVudC5iaW5kKCdrZXlkb3duJywga2V5YmluZEZpbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKG9wZW5TY29wZSAmJiBvcGVuU2NvcGUgIT09IGRyb3Bkb3duU2NvcGUpIHtcbiAgICAgIG9wZW5TY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBvcGVuU2NvcGUgPSBkcm9wZG93blNjb3BlO1xuICB9O1xuXG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbihkcm9wZG93blNjb3BlKSB7XG4gICAgaWYgKG9wZW5TY29wZSA9PT0gZHJvcGRvd25TY29wZSkge1xuICAgICAgb3BlblNjb3BlID0gbnVsbDtcbiAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgY2xvc2VEcm9wZG93bik7XG4gICAgICAkZG9jdW1lbnQudW5iaW5kKCdrZXlkb3duJywga2V5YmluZEZpbHRlcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbG9zZURyb3Bkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbWF5IHN0aWxsIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHNhbWUgbW91c2UgZXZlbnQgdGhhdFxuICAgIC8vIHVuYm91bmQgdGhpcyBldmVudCBoYW5kbGVyLiBTbyBjaGVjayBvcGVuU2NvcGUgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKCFvcGVuU2NvcGUpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZXZ0ICYmIG9wZW5TY29wZS5nZXRBdXRvQ2xvc2UoKSA9PT0gJ2Rpc2FibGVkJykgIHsgcmV0dXJuIDsgfVxuXG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCgpO1xuICAgIGlmIChldnQgJiYgdG9nZ2xlRWxlbWVudCAmJiB0b2dnbGVFbGVtZW50WzBdLmNvbnRhaW5zKGV2dC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRyb3Bkb3duRWxlbWVudCA9IG9wZW5TY29wZS5nZXREcm9wZG93bkVsZW1lbnQoKTtcbiAgICBpZiAoZXZ0ICYmIG9wZW5TY29wZS5nZXRBdXRvQ2xvc2UoKSA9PT0gJ291dHNpZGVDbGljaycgJiZcbiAgICAgIGRyb3Bkb3duRWxlbWVudCAmJiBkcm9wZG93bkVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XG5cbiAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgb3BlblNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIga2V5YmluZEZpbHRlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICBvcGVuU2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50KCk7XG4gICAgICBjbG9zZURyb3Bkb3duKCk7XG4gICAgfSBlbHNlIGlmIChvcGVuU2NvcGUuaXNLZXluYXZFbmFibGVkKCkgJiYgLygzOHw0MCkvLnRlc3QoZXZ0LndoaWNoKSAmJiBvcGVuU2NvcGUuaXNPcGVuKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG9wZW5TY29wZS5mb2N1c0Ryb3Bkb3duRW50cnkoZXZ0LndoaWNoKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmNvbnRyb2xsZXIoJ1VpYkRyb3Bkb3duQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckcGFyc2UnLCAndWliRHJvcGRvd25Db25maWcnLCAndWliRHJvcGRvd25TZXJ2aWNlJywgJyRhbmltYXRlJywgJyR1aWJQb3NpdGlvbicsICckZG9jdW1lbnQnLCAnJGNvbXBpbGUnLCAnJHRlbXBsYXRlUmVxdWVzdCcsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHBhcnNlLCBkcm9wZG93bkNvbmZpZywgdWliRHJvcGRvd25TZXJ2aWNlLCAkYW5pbWF0ZSwgJHBvc2l0aW9uLCAkZG9jdW1lbnQsICRjb21waWxlLCAkdGVtcGxhdGVSZXF1ZXN0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzY29wZSA9ICRzY29wZS4kbmV3KCksIC8vIGNyZWF0ZSBhIGNoaWxkIHNjb3BlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIG9uZVxuICAgIHRlbXBsYXRlU2NvcGUsXG4gICAgb3BlbkNsYXNzID0gZHJvcGRvd25Db25maWcub3BlbkNsYXNzLFxuICAgIGdldElzT3BlbixcbiAgICBzZXRJc09wZW4gPSBhbmd1bGFyLm5vb3AsXG4gICAgdG9nZ2xlSW52b2tlciA9ICRhdHRycy5vblRvZ2dsZSA/ICRwYXJzZSgkYXR0cnMub25Ub2dnbGUpIDogYW5ndWxhci5ub29wLFxuICAgIGFwcGVuZFRvQm9keSA9IGZhbHNlLFxuICAgIGtleW5hdkVuYWJsZWQgPWZhbHNlLFxuICAgIHNlbGVjdGVkT3B0aW9uID0gbnVsbDtcblxuXG4gICRlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bicpO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkYXR0cnMuaXNPcGVuKSB7XG4gICAgICBnZXRJc09wZW4gPSAkcGFyc2UoJGF0dHJzLmlzT3Blbik7XG4gICAgICBzZXRJc09wZW4gPSBnZXRJc09wZW4uYXNzaWduO1xuXG4gICAgICAkc2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gISF2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kcm9wZG93bkFwcGVuZFRvQm9keSk7XG4gICAga2V5bmF2RW5hYmxlZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy51aWJLZXlib2FyZE5hdik7XG5cbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChzZWxmLmRyb3Bkb3duTWVudSk7XG4gICAgICAkZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbiBoYW5kbGVEZXN0cm95RXZlbnQoKSB7XG4gICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24ob3Blbikge1xuICAgIHJldHVybiBzY29wZS5pc09wZW4gPSBhcmd1bWVudHMubGVuZ3RoID8gISFvcGVuIDogIXNjb3BlLmlzT3BlbjtcbiAgfTtcblxuICAvLyBBbGxvdyBvdGhlciBkaXJlY3RpdmVzIHRvIHdhdGNoIHN0YXR1c1xuICB0aGlzLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzY29wZS5pc09wZW47XG4gIH07XG5cbiAgc2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnRvZ2dsZUVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuZ2V0QXV0b0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRhdHRycy5hdXRvQ2xvc2UgfHwgJ2Fsd2F5cyc7IC8vb3IgJ291dHNpZGVDbGljaycgb3IgJ2Rpc2FibGVkJ1xuICB9O1xuXG4gIHNjb3BlLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuaXNLZXluYXZFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGtleW5hdkVuYWJsZWQ7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5ID0gZnVuY3Rpb24oa2V5Q29kZSkge1xuICAgIHZhciBlbGVtcyA9IHNlbGYuZHJvcGRvd25NZW51ID8gLy9JZiBhcHBlbmQgdG8gYm9keSBpcyB1c2VkLlxuICAgICAgKGFuZ3VsYXIuZWxlbWVudChzZWxmLmRyb3Bkb3duTWVudSkuZmluZCgnYScpKSA6XG4gICAgICAoYW5ndWxhci5lbGVtZW50KCRlbGVtZW50KS5maW5kKCd1bCcpLmVxKDApLmZpbmQoJ2EnKSk7XG5cbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIGNhc2UgKDQwKToge1xuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoc2VsZi5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gKHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IGVsZW1zLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA6XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICgzOCk6IHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKHNlbGYuc2VsZWN0ZWRPcHRpb24pKSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IGVsZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IDAgP1xuICAgICAgICAgICAgMCA6IHNlbGYuc2VsZWN0ZWRPcHRpb24gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtc1tzZWxmLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xuICB9O1xuXG4gIHNjb3BlLmdldERyb3Bkb3duRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmRyb3Bkb3duTWVudTtcbiAgfTtcblxuICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi50b2dnbGVFbGVtZW50KSB7XG4gICAgICBzZWxmLnRvZ2dsZUVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbihpc09wZW4sIHdhc09wZW4pIHtcbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICB2YXIgcG9zID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoJGVsZW1lbnQsIHNlbGYuZHJvcGRvd25NZW51LCAnYm90dG9tLWxlZnQnLCB0cnVlKTtcbiAgICAgIHZhciBjc3MgPSB7XG4gICAgICAgIHRvcDogcG9zLnRvcCArICdweCcsXG4gICAgICAgIGRpc3BsYXk6IGlzT3BlbiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciByaWdodGFsaWduID0gc2VsZi5kcm9wZG93bk1lbnUuaGFzQ2xhc3MoJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnKTtcbiAgICAgIGlmICghcmlnaHRhbGlnbikge1xuICAgICAgICBjc3MubGVmdCA9IHBvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgY3NzLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIGNzcy5yaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIChwb3MubGVmdCArICRlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJykpKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZHJvcGRvd25NZW51LmNzcyhjc3MpO1xuICAgIH1cblxuICAgICRhbmltYXRlW2lzT3BlbiA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgkZWxlbWVudCwgb3BlbkNsYXNzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGlzT3BlbikgJiYgaXNPcGVuICE9PSB3YXNPcGVuKSB7XG4gICAgICAgIHRvZ2dsZUludm9rZXIoJHNjb3BlLCB7IG9wZW46ICEhaXNPcGVuIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChzZWxmLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uKHRwbENvbnRlbnQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKSh0ZW1wbGF0ZVNjb3BlLCBmdW5jdGlvbihkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbCA9IGRyb3Bkb3duRWxlbWVudDtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKG5ld0VsKTtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcbiAgICAgIHVpYkRyb3Bkb3duU2VydmljZS5vcGVuKHNjb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NvcGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0VsID0gYW5ndWxhci5lbGVtZW50KCc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCI+PC91bD4nKTtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudSA9IG5ld0VsO1xuICAgICAgfVxuXG4gICAgICB1aWJEcm9wZG93blNlcnZpY2UuY2xvc2Uoc2NvcGUpO1xuICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XG4gICAgICBzZXRJc09wZW4oJHNjb3BlLCBpc09wZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzY29wZS5nZXRBdXRvQ2xvc2UoKSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb2ZmRGVzdHJveSA9ICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgfSk7XG4gIHNjb3BlLiRvbignJGRlc3Ryb3knLCBvZmZEZXN0cm95KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJEcm9wZG93bicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdVaWJEcm9wZG93bkNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBkcm9wZG93bkN0cmwuaW5pdCgpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkRyb3Bkb3duTWVudScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQUMnLFxuICAgIHJlcXVpcmU6ICc/XnVpYkRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCFkcm9wZG93bkN0cmwgfHwgYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZHJvcGRvd25OZXN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygnZHJvcGRvd24tbWVudScpO1xuXG4gICAgICB2YXIgdHBsVXJsID0gYXR0cnMudGVtcGxhdGVVcmw7XG4gICAgICBpZiAodHBsVXJsKSB7XG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCA9IHRwbFVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51KSB7XG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYktleWJvYXJkTmF2JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnP151aWJEcm9wZG93bicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcbiAgICAgIGVsZW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKFszOCwgNDBdLmluZGV4T2YoZS53aGljaCkgIT09IC0xKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICB2YXIgZWxlbXMgPSBkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51LmZpbmQoJ2EnKTtcblxuICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgY2FzZSAoNDApOiB7IC8vIERvd25cbiAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9PT0gZWxlbXMubGVuZ3RoIC0xID9cbiAgICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA6IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICgzOCk6IHsgLy8gVXBcbiAgICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gPSBlbGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAwIDogZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uIC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbXNbZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJEcm9wZG93blRvZ2dsZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICc/XnVpYkRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCFkcm9wZG93bkN0cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bi10b2dnbGUnKTtcblxuICAgICAgZHJvcGRvd25DdHJsLnRvZ2dsZUVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICB2YXIgdG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghZWxlbWVudC5oYXNDbGFzcygnZGlzYWJsZWQnKSAmJiAhYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkcm9wZG93bkN0cmwudG9nZ2xlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnQuYmluZCgnY2xpY2snLCB0b2dnbGVEcm9wZG93bik7XG5cbiAgICAgIC8vIFdBSS1BUklBXG4gICAgICBlbGVtZW50LmF0dHIoeyAnYXJpYS1oYXNwb3B1cCc6IHRydWUsICdhcmlhLWV4cGFuZGVkJzogZmFsc2UgfSk7XG4gICAgICBzY29wZS4kd2F0Y2goZHJvcGRvd25DdHJsLmlzT3BlbiwgZnVuY3Rpb24oaXNPcGVuKSB7XG4gICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsICEhaXNPcGVuKTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudW5iaW5kKCdjbGljaycsIHRvZ2dsZURyb3Bkb3duKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKiBEZXByZWNhdGVkIGRyb3Bkb3duIGJlbG93ICovXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZHJvcGRvd24nKVxuXG4udmFsdWUoJyRkcm9wZG93blN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4uc2VydmljZSgnZHJvcGRvd25TZXJ2aWNlJywgWyckbG9nJywgJyRkcm9wZG93blN1cHByZXNzV2FybmluZycsICd1aWJEcm9wZG93blNlcnZpY2UnLCBmdW5jdGlvbigkbG9nLCAkZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcsIHVpYkRyb3Bkb3duU2VydmljZSkge1xuICBpZiAoISRkcm9wZG93blN1cHByZXNzV2FybmluZykge1xuICAgICRsb2cud2FybignZHJvcGRvd25TZXJ2aWNlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliRHJvcGRvd25TZXJ2aWNlIGluc3RlYWQuJyk7XG4gIH1cblxuICBhbmd1bGFyLmV4dGVuZCh0aGlzLCB1aWJEcm9wZG93blNlcnZpY2UpO1xufV0pXG5cbi5jb250cm9sbGVyKCdEcm9wZG93bkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJHBhcnNlJywgJ3VpYkRyb3Bkb3duQ29uZmlnJywgJ3VpYkRyb3Bkb3duU2VydmljZScsICckYW5pbWF0ZScsICckdWliUG9zaXRpb24nLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJGxvZycsICckZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRwYXJzZSwgZHJvcGRvd25Db25maWcsIHVpYkRyb3Bkb3duU2VydmljZSwgJGFuaW1hdGUsICRwb3NpdGlvbiwgJGRvY3VtZW50LCAkY29tcGlsZSwgJHRlbXBsYXRlUmVxdWVzdCwgJGxvZywgJGRyb3Bkb3duU3VwcHJlc3NXYXJuaW5nKSB7XG4gIGlmICghJGRyb3Bkb3duU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgJGxvZy53YXJuKCdEcm9wZG93bkNvbnRyb2xsZXIgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSBVaWJEcm9wZG93bkNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzY29wZSA9ICRzY29wZS4kbmV3KCksIC8vIGNyZWF0ZSBhIGNoaWxkIHNjb3BlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIG9uZVxuICAgIHRlbXBsYXRlU2NvcGUsXG4gICAgb3BlbkNsYXNzID0gZHJvcGRvd25Db25maWcub3BlbkNsYXNzLFxuICAgIGdldElzT3BlbixcbiAgICBzZXRJc09wZW4gPSBhbmd1bGFyLm5vb3AsXG4gICAgdG9nZ2xlSW52b2tlciA9ICRhdHRycy5vblRvZ2dsZSA/ICRwYXJzZSgkYXR0cnMub25Ub2dnbGUpIDogYW5ndWxhci5ub29wLFxuICAgIGFwcGVuZFRvQm9keSA9IGZhbHNlLFxuICAgIGtleW5hdkVuYWJsZWQgPWZhbHNlLFxuICAgIHNlbGVjdGVkT3B0aW9uID0gbnVsbDtcblxuXG4gICRlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bicpO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkYXR0cnMuaXNPcGVuKSB7XG4gICAgICBnZXRJc09wZW4gPSAkcGFyc2UoJGF0dHJzLmlzT3Blbik7XG4gICAgICBzZXRJc09wZW4gPSBnZXRJc09wZW4uYXNzaWduO1xuXG4gICAgICAkc2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gISF2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kcm9wZG93bkFwcGVuZFRvQm9keSk7XG4gICAga2V5bmF2RW5hYmxlZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy51aWJLZXlib2FyZE5hdik7XG5cbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChzZWxmLmRyb3Bkb3duTWVudSk7XG4gICAgICAkZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbiBoYW5kbGVEZXN0cm95RXZlbnQoKSB7XG4gICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24ob3Blbikge1xuICAgIHJldHVybiBzY29wZS5pc09wZW4gPSBhcmd1bWVudHMubGVuZ3RoID8gISFvcGVuIDogIXNjb3BlLmlzT3BlbjtcbiAgfTtcblxuICAvLyBBbGxvdyBvdGhlciBkaXJlY3RpdmVzIHRvIHdhdGNoIHN0YXR1c1xuICB0aGlzLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzY29wZS5pc09wZW47XG4gIH07XG5cbiAgc2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnRvZ2dsZUVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuZ2V0QXV0b0Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRhdHRycy5hdXRvQ2xvc2UgfHwgJ2Fsd2F5cyc7IC8vb3IgJ291dHNpZGVDbGljaycgb3IgJ2Rpc2FibGVkJ1xuICB9O1xuXG4gIHNjb3BlLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGVsZW1lbnQ7XG4gIH07XG5cbiAgc2NvcGUuaXNLZXluYXZFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGtleW5hdkVuYWJsZWQ7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNEcm9wZG93bkVudHJ5ID0gZnVuY3Rpb24oa2V5Q29kZSkge1xuICAgIHZhciBlbGVtcyA9IHNlbGYuZHJvcGRvd25NZW51ID8gLy9JZiBhcHBlbmQgdG8gYm9keSBpcyB1c2VkLlxuICAgICAgKGFuZ3VsYXIuZWxlbWVudChzZWxmLmRyb3Bkb3duTWVudSkuZmluZCgnYScpKSA6XG4gICAgICAoYW5ndWxhci5lbGVtZW50KCRlbGVtZW50KS5maW5kKCd1bCcpLmVxKDApLmZpbmQoJ2EnKSk7XG5cbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIGNhc2UgKDQwKToge1xuICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoc2VsZi5zZWxlY3RlZE9wdGlvbikpIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gKHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IGVsZW1zLmxlbmd0aCAtMSA/XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uIDpcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICgzOCk6IHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKHNlbGYuc2VsZWN0ZWRPcHRpb24pKSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IGVsZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IDAgP1xuICAgICAgICAgICAgMCA6IHNlbGYuc2VsZWN0ZWRPcHRpb24gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtc1tzZWxmLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xuICB9O1xuXG4gIHNjb3BlLmdldERyb3Bkb3duRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmRyb3Bkb3duTWVudTtcbiAgfTtcblxuICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi50b2dnbGVFbGVtZW50KSB7XG4gICAgICBzZWxmLnRvZ2dsZUVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbihpc09wZW4sIHdhc09wZW4pIHtcbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XG4gICAgICB2YXIgcG9zID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoJGVsZW1lbnQsIHNlbGYuZHJvcGRvd25NZW51LCAnYm90dG9tLWxlZnQnLCB0cnVlKTtcbiAgICAgIHZhciBjc3MgPSB7XG4gICAgICAgIHRvcDogcG9zLnRvcCArICdweCcsXG4gICAgICAgIGRpc3BsYXk6IGlzT3BlbiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHZhciByaWdodGFsaWduID0gc2VsZi5kcm9wZG93bk1lbnUuaGFzQ2xhc3MoJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnKTtcbiAgICAgIGlmICghcmlnaHRhbGlnbikge1xuICAgICAgICBjc3MubGVmdCA9IHBvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgY3NzLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzLmxlZnQgPSAnYXV0byc7XG4gICAgICAgIGNzcy5yaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIChwb3MubGVmdCArICRlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJykpKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZHJvcGRvd25NZW51LmNzcyhjc3MpO1xuICAgIH1cblxuICAgICRhbmltYXRlW2lzT3BlbiA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgkZWxlbWVudCwgb3BlbkNsYXNzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGlzT3BlbikgJiYgaXNPcGVuICE9PSB3YXNPcGVuKSB7XG4gICAgICAgIHRvZ2dsZUludm9rZXIoJHNjb3BlLCB7IG9wZW46ICEhaXNPcGVuIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChzZWxmLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uKHRwbENvbnRlbnQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKSh0ZW1wbGF0ZVNjb3BlLCBmdW5jdGlvbihkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbCA9IGRyb3Bkb3duRWxlbWVudDtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKG5ld0VsKTtcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcbiAgICAgIHVpYkRyb3Bkb3duU2VydmljZS5vcGVuKHNjb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlU2NvcGUpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0VsID0gYW5ndWxhci5lbGVtZW50KCc8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCI+PC91bD4nKTtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICBzZWxmLmRyb3Bkb3duTWVudSA9IG5ld0VsO1xuICAgICAgfVxuXG4gICAgICB1aWJEcm9wZG93blNlcnZpY2UuY2xvc2Uoc2NvcGUpO1xuICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XG4gICAgICBzZXRJc09wZW4oJHNjb3BlLCBpc09wZW4pO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzY29wZS5nZXRBdXRvQ2xvc2UoKSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb2ZmRGVzdHJveSA9ICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgfSk7XG4gIHNjb3BlLiRvbignJGRlc3Ryb3knLCBvZmZEZXN0cm95KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93bicsIFsnJGxvZycsICckZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiAnRHJvcGRvd25Db250cm9sbGVyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCEkZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdkcm9wZG93biBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1kcm9wZG93biBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBkcm9wZG93bkN0cmwuaW5pdCgpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93bk1lbnUnLCBbJyRsb2cnLCAnJGRyb3Bkb3duU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJGRyb3Bkb3duU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBQycsXG4gICAgcmVxdWlyZTogJz9eZHJvcGRvd24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kcm9wZG93bk5lc3RlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoISRkcm9wZG93blN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ2Ryb3Bkb3duLW1lbnUgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItZHJvcGRvd24tbWVudSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bi1tZW51Jyk7XG5cbiAgICAgIHZhciB0cGxVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcbiAgICAgIGlmICh0cGxVcmwpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsID0gdHBsVXJsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUpIHtcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ2tleWJvYXJkTmF2JywgWyckbG9nJywgJyRkcm9wZG93blN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRkcm9wZG93blN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJz9eZHJvcGRvd24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBpZiAoISRkcm9wZG93blN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ2tleWJvYXJkLW5hdiBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1rZXlib2FyZC1uYXYgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoWzM4LCA0MF0uaW5kZXhPZihlLndoaWNoKSAhPT0gLTEpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIHZhciBlbGVtcyA9IGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUuZmluZCgnYScpO1xuXG4gICAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlICg0MCk6IHsgLy8gRG93blxuICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID0gZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID09PSBlbGVtcy5sZW5ndGggLTEgP1xuICAgICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uIDogZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgKDM4KTogeyAvLyBVcFxuICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNOdW1iZXIoZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duQ3RybC5zZWxlY3RlZE9wdGlvbiA9IGVsZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID0gZHJvcGRvd25DdHJsLnNlbGVjdGVkT3B0aW9uID09PSAwID9cbiAgICAgICAgICAgICAgICAgIDAgOiBkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb24gLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtc1tkcm9wZG93bkN0cmwuc2VsZWN0ZWRPcHRpb25dLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdkcm9wZG93blRvZ2dsZScsIFsnJGxvZycsICckZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkZHJvcGRvd25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnP15kcm9wZG93bicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcbiAgICAgIGlmICghJGRyb3Bkb3duU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybignZHJvcGRvd24tdG9nZ2xlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWRyb3Bkb3duLXRvZ2dsZSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpO1xuXG4gICAgICBkcm9wZG93bkN0cmwudG9nZ2xlRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgIHZhciB0b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmICFhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duQ3RybC50b2dnbGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZWxlbWVudC5iaW5kKCdjbGljaycsIHRvZ2dsZURyb3Bkb3duKTtcblxuICAgICAgLy8gV0FJLUFSSUFcbiAgICAgIGVsZW1lbnQuYXR0cih7ICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSwgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSB9KTtcbiAgICAgIHNjb3BlLiR3YXRjaChkcm9wZG93bkN0cmwuaXNPcGVuLCBmdW5jdGlvbihpc09wZW4pIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgISFpc09wZW4pO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC51bmJpbmQoJ2NsaWNrJywgdG9nZ2xlRHJvcGRvd24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnN0YWNrZWRNYXAnLCBbXSlcbi8qKlxuICogQSBoZWxwZXIsIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHRoYXQgYWN0cyBhcyBhIG1hcCBidXQgYWxzbyBhbGxvd3MgZ2V0dGluZyAvIHJlbW92aW5nXG4gKiBlbGVtZW50cyBpbiB0aGUgTElGTyBvcmRlclxuICovXG4gIC5mYWN0b3J5KCckJHN0YWNrZWRNYXAnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKGlkeCwgMSlbMF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVUb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAubW9kYWwnLCBbJ3VpLmJvb3RzdHJhcC5zdGFja2VkTWFwJ10pXG4vKipcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB0aGF0IHN0b3JlcyBhbGwgcmVmZXJlbmNlcyBhdHRhY2hlZCB0byBrZXlcbiAqL1xuICAuZmFjdG9yeSgnJCRtdWx0aU1hcCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwID0ge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFwW2tleV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gISFtYXBba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbWFwW2tleV0pIHtcbiAgICAgICAgICAgICAgbWFwW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBtYXBba2V5XTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gdmFsdWVzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbi8qKlxuICogQSBoZWxwZXIgZGlyZWN0aXZlIGZvciB0aGUgJG1vZGFsIHNlcnZpY2UuIEl0IGNyZWF0ZXMgYSBiYWNrZHJvcCBlbGVtZW50LlxuICovXG4gIC5kaXJlY3RpdmUoJ3VpYk1vZGFsQmFja2Ryb3AnLCBbXG4gICAgICAgICAgICckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJHVpYk1vZGFsU3RhY2snLFxuICBmdW5jdGlvbigkYW5pbWF0ZSAsICAkaW5qZWN0b3IsICAgJG1vZGFsU3RhY2spIHtcbiAgICB2YXIgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gICAgaWYgKCRpbmplY3Rvci5oYXMoJyRhbmltYXRlQ3NzJykpIHtcbiAgICAgICRhbmltYXRlQ3NzID0gJGluamVjdG9yLmdldCgnJGFuaW1hdGVDc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbCcsXG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIHRFbGVtZW50LmFkZENsYXNzKHRBdHRycy5iYWNrZHJvcENsYXNzKTtcbiAgICAgICAgcmV0dXJuIGxpbmtGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgLy8gVGVtcG9yYXJ5IGZpeCBmb3IgcHJlZml4aW5nXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdtb2RhbC1iYWNrZHJvcCcpO1xuXG4gICAgICBpZiAoYXR0cnMubW9kYWxJbkNsYXNzKSB7XG4gICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xuICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIGFkZENsYXNzOiBhdHRycy5tb2RhbEluQ2xhc3NcbiAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kb24oJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIGZ1bmN0aW9uKGUsIHNldElzQXN5bmMpIHtcbiAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcbiAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgfSkuc3RhcnQoKS50aGVuKGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCBhdHRycy5tb2RhbEluQ2xhc3MpLnRoZW4oZG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYk1vZGFsV2luZG93JywgW1xuICAgICAgICAgICAnJHVpYk1vZGFsU3RhY2snLCAnJHEnLCAnJGFuaW1hdGUnLCAnJGluamVjdG9yJyxcbiAgZnVuY3Rpb24oJG1vZGFsU3RhY2sgLCAgJHEgLCAgJGFuaW1hdGUsICAgJGluamVjdG9yKSB7XG4gICAgdmFyICRhbmltYXRlQ3NzID0gbnVsbDtcblxuICAgIGlmICgkaW5qZWN0b3IuaGFzKCckYW5pbWF0ZUNzcycpKSB7XG4gICAgICAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnQCdcbiAgICAgIH0sXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIHJldHVybiB0QXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy53aW5kb3dDbGFzcyB8fCAnJyk7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMud2luZG93VG9wQ2xhc3MgfHwgJycpO1xuICAgICAgICBzY29wZS5zaXplID0gYXR0cnMuc2l6ZTtcblxuICAgICAgICBzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAhPT0gJ3N0YXRpYycgJiYgKGV2dC50YXJnZXQgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2JhY2tkcm9wIGNsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1vdmVkIGZyb20gdGVtcGxhdGUgdG8gZml4IGlzc3VlICMyMjgwXG4gICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgc2NvcGUuY2xvc2UpO1xuXG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgb25seSBhZGRlZCB0byB0aGUgc2NvcGUgZm9yIHRoZSBwdXJwb3NlIG9mIGRldGVjdGluZyB3aGVuIHRoaXMgZGlyZWN0aXZlIGlzIHJlbmRlcmVkLlxuICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgYnkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGlyZWN0aXZlIGFuZCB0aGVuIHVzZVxuICAgICAgICAvLyB7QGxpbmsgQXR0cmlidXRlIyRvYnNlcnZlfSBvbiBpdC4gRm9yIG1vcmUgZGV0YWlscyBwbGVhc2Ugc2VlIHtAbGluayBUYWJsZUNvbHVtblJlc2l6ZX0uXG4gICAgICAgIHNjb3BlLiRpc1JlbmRlcmVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBEZWZlcnJlZCBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhpcyBtb2RhbCBpcyByZW5kZXIuXG4gICAgICAgIHZhciBtb2RhbFJlbmRlckRlZmVyT2JqID0gJHEuZGVmZXIoKTtcbiAgICAgICAgLy8gT2JzZXJ2ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBuZXh0IGRpZ2VzdCBjeWNsZSBhZnRlciBjb21waWxhdGlvbiwgZW5zdXJpbmcgdGhhdCB0aGUgRE9NIGlzIHJlYWR5LlxuICAgICAgICAvLyBJbiBvcmRlciB0byB1c2UgdGhpcyB3YXkgb2YgZmluZGluZyB3aGV0aGVyIERPTSBpcyByZWFkeSwgd2UgbmVlZCB0byBvYnNlcnZlIGEgc2NvcGUgcHJvcGVydHkgdXNlZCBpbiBtb2RhbCdzIHRlbXBsYXRlLlxuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnbW9kYWxSZW5kZXInLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIG1vZGFsUmVuZGVyRGVmZXJPYmoucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGF0dHJzLm1vZGFsSW5DbGFzcykge1xuICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UgPSAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLiRvbigkbW9kYWxTdGFjay5OT1dfQ0xPU0lOR19FVkVOVCwgZnVuY3Rpb24oZSwgc2V0SXNBc3luYykge1xuICAgICAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcbiAgICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCBhdHRycy5tb2RhbEluQ2xhc3MpLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgJHEud2hlbihhbmltYXRpb25Qcm9taXNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0V2l0aEF1dG9mb2N1cyA9IGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignW2F1dG9mb2N1c10nKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXV0by1mb2N1c2luZyBvZiBhIGZyZXNobHktb3BlbmVkIG1vZGFsIGVsZW1lbnQgY2F1c2VzIGFueSBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICAgICogd2l0aCB0aGUgYXV0b2ZvY3VzIGF0dHJpYnV0ZSB0byBsb3NlIGZvY3VzLiBUaGlzIGlzIGFuIGlzc3VlIG9uIHRvdWNoXG4gICAgICAgICAgICAgKiBiYXNlZCBkZXZpY2VzIHdoaWNoIHdpbGwgc2hvdyBhbmQgdGhlbiBoaWRlIHRoZSBvbnNjcmVlbiBrZXlib2FyZC5cbiAgICAgICAgICAgICAqIEF0dGVtcHRzIHRvIHJlZm9jdXMgdGhlIGF1dG9mb2N1cyBlbGVtZW50IHZpYSBKYXZhU2NyaXB0IHdpbGwgbm90IHJlb3BlblxuICAgICAgICAgICAgICogdGhlIG9uc2NyZWVuIGtleWJvYXJkLiBGaXhlZCBieSB1cGRhdGVkIHRoZSBmb2N1c2luZyBsb2dpYyB0byBvbmx5IGF1dG9mb2N1c1xuICAgICAgICAgICAgICogdGhlIG1vZGFsIGVsZW1lbnQgaWYgdGhlIG1vZGFsIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0b2ZvY3VzIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpbnB1dFdpdGhBdXRvZm9jdXMpIHtcbiAgICAgICAgICAgICAgaW5wdXRXaXRoQXV0b2ZvY3VzLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBOb3RpZnkge0BsaW5rICRtb2RhbFN0YWNrfSB0aGF0IG1vZGFsIGlzIHJlbmRlcmVkLlxuICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZChtb2RhbC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgndWliTW9kYWxBbmltYXRpb25DbGFzcycsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIGlmICh0QXR0cnMubW9kYWxBbmltYXRpb24pIHtcbiAgICAgICAgICB0RWxlbWVudC5hZGRDbGFzcyh0QXR0cnMudWliTW9kYWxBbmltYXRpb25DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4gIC5kaXJlY3RpdmUoJ3VpYk1vZGFsVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsIGNvbnRyb2xsZXIsICR0cmFuc2NsdWRlKSB7XG4gICAgICAgICR0cmFuc2NsdWRlKCRzY29wZS4kcGFyZW50LCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICRlbGVtZW50LmVtcHR5KCk7XG4gICAgICAgICAgJGVsZW1lbnQuYXBwZW5kKGNsb25lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuICAuZmFjdG9yeSgnJHVpYk1vZGFsU3RhY2snLCBbXG4gICAgICAgICAgICAgJyRhbmltYXRlJywgJyR0aW1lb3V0JywgJyRkb2N1bWVudCcsICckY29tcGlsZScsICckcm9vdFNjb3BlJyxcbiAgICAgICAgICAgICAnJHEnLFxuICAgICAgICAgICAgICckaW5qZWN0b3InLFxuICAgICAgICAgICAgICckJG11bHRpTWFwJyxcbiAgICAgICAgICAgICAnJCRzdGFja2VkTWFwJyxcbiAgICBmdW5jdGlvbigkYW5pbWF0ZSAsICAkdGltZW91dCAsICAkZG9jdW1lbnQgLCAgJGNvbXBpbGUgLCAgJHJvb3RTY29wZSAsXG4gICAgICAgICAgICAgICRxLFxuICAgICAgICAgICAgICAkaW5qZWN0b3IsXG4gICAgICAgICAgICAgICQkbXVsdGlNYXAsXG4gICAgICAgICAgICAgICQkc3RhY2tlZE1hcCkge1xuICAgICAgdmFyICRhbmltYXRlQ3NzID0gbnVsbDtcblxuICAgICAgaWYgKCRpbmplY3Rvci5oYXMoJyRhbmltYXRlQ3NzJykpIHtcbiAgICAgICAgJGFuaW1hdGVDc3MgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgT1BFTkVEX01PREFMX0NMQVNTID0gJ21vZGFsLW9wZW4nO1xuXG4gICAgICB2YXIgYmFja2Ryb3BEb21FbCwgYmFja2Ryb3BTY29wZTtcbiAgICAgIHZhciBvcGVuZWRXaW5kb3dzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xuICAgICAgdmFyIG9wZW5lZENsYXNzZXMgPSAkJG11bHRpTWFwLmNyZWF0ZU5ldygpO1xuICAgICAgdmFyICRtb2RhbFN0YWNrID0ge1xuICAgICAgICBOT1dfQ0xPU0lOR19FVkVOVDogJ21vZGFsLnN0YWNrLm5vdy1jbG9zaW5nJ1xuICAgICAgfTtcblxuICAgICAgLy9Nb2RhbCBmb2N1cyBiZWhhdmlvclxuICAgICAgdmFyIGZvY3VzYWJsZUVsZW1lbnRMaXN0O1xuICAgICAgdmFyIGZvY3VzSW5kZXggPSAwO1xuICAgICAgdmFyIHRhYmFiYmxlU2VsZWN0b3IgPSAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgICAgICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCAnICtcbiAgICAgICAgJ2lmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlPXRydWVdJztcblxuICAgICAgZnVuY3Rpb24gYmFja2Ryb3BJbmRleCgpIHtcbiAgICAgICAgdmFyIHRvcEJhY2tkcm9wSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG9wZW5lZCA9IG9wZW5lZFdpbmRvd3Mua2V5cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZW5lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChvcGVuZWRXaW5kb3dzLmdldChvcGVuZWRbaV0pLnZhbHVlLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0b3BCYWNrZHJvcEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcEJhY2tkcm9wSW5kZXg7XG4gICAgICB9XG5cbiAgICAgICRyb290U2NvcGUuJHdhdGNoKGJhY2tkcm9wSW5kZXgsIGZ1bmN0aW9uKG5ld0JhY2tkcm9wSW5kZXgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wU2NvcGUpIHtcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlLmluZGV4ID0gbmV3QmFja2Ryb3BJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UsIGVsZW1lbnRUb1JlY2VpdmVGb2N1cykge1xuICAgICAgICB2YXIgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5JykuZXEoMCk7XG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpLnZhbHVlO1xuXG4gICAgICAgIC8vY2xlYW4gdXAgdGhlIHN0YWNrXG4gICAgICAgIG9wZW5lZFdpbmRvd3MucmVtb3ZlKG1vZGFsSW5zdGFuY2UpO1xuXG4gICAgICAgIHJlbW92ZUFmdGVyQW5pbWF0ZShtb2RhbFdpbmRvdy5tb2RhbERvbUVsLCBtb2RhbFdpbmRvdy5tb2RhbFNjb3BlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbW9kYWxCb2R5Q2xhc3MgPSBtb2RhbFdpbmRvdy5vcGVuZWRDbGFzcyB8fCBPUEVORURfTU9EQUxfQ0xBU1M7XG4gICAgICAgICAgb3BlbmVkQ2xhc3Nlcy5yZW1vdmUobW9kYWxCb2R5Q2xhc3MsIG1vZGFsSW5zdGFuY2UpO1xuICAgICAgICAgIGJvZHkudG9nZ2xlQ2xhc3MobW9kYWxCb2R5Q2xhc3MsIG9wZW5lZENsYXNzZXMuaGFzS2V5KG1vZGFsQm9keUNsYXNzKSk7XG4gICAgICAgICAgdG9nZ2xlVG9wV2luZG93Q2xhc3ModHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja1JlbW92ZUJhY2tkcm9wKCk7XG5cbiAgICAgICAgLy9tb3ZlIGZvY3VzIHRvIHNwZWNpZmllZCBlbGVtZW50IGlmIGF2YWlsYWJsZSwgb3IgZWxzZSB0byBib2R5XG4gICAgICAgIGlmIChlbGVtZW50VG9SZWNlaXZlRm9jdXMgJiYgZWxlbWVudFRvUmVjZWl2ZUZvY3VzLmZvY3VzKSB7XG4gICAgICAgICAgZWxlbWVudFRvUmVjZWl2ZUZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9keS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBvciByZW1vdmUgXCJ3aW5kb3dUb3BDbGFzc1wiIGZyb20gdGhlIHRvcCB3aW5kb3cgaW4gdGhlIHN0YWNrXG4gICAgICBmdW5jdGlvbiB0b2dnbGVUb3BXaW5kb3dDbGFzcyh0b2dnbGVTd2l0Y2gpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93O1xuXG4gICAgICAgIGlmIChvcGVuZWRXaW5kb3dzLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZTtcbiAgICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbERvbUVsLnRvZ2dsZUNsYXNzKG1vZGFsV2luZG93LndpbmRvd1RvcENsYXNzIHx8ICcnLCB0b2dnbGVTd2l0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgICAgIC8vcmVtb3ZlIGJhY2tkcm9wIGlmIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgaWYgKGJhY2tkcm9wRG9tRWwgJiYgYmFja2Ryb3BJbmRleCgpID09IC0xKSB7XG4gICAgICAgICAgdmFyIGJhY2tkcm9wU2NvcGVSZWYgPSBiYWNrZHJvcFNjb3BlO1xuICAgICAgICAgIHJlbW92ZUFmdGVyQW5pbWF0ZShiYWNrZHJvcERvbUVsLCBiYWNrZHJvcFNjb3BlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJhY2tkcm9wU2NvcGVSZWYgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVBZnRlckFuaW1hdGUoZG9tRWwsIHNjb3BlLCBkb25lKSB7XG4gICAgICAgIHZhciBhc3luY0RlZmVycmVkO1xuICAgICAgICB2YXIgYXN5bmNQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdmFyIHNldElzQXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIWFzeW5jRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGFzeW5jRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgYXN5bmNQcm9taXNlID0gYXN5bmNEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBhc3luY0RvbmUoKSB7XG4gICAgICAgICAgICBhc3luY0RlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBzZXRJc0FzeW5jKTtcblxuICAgICAgICAvLyBOb3RlIHRoYXQgaXQncyBpbnRlbnRpb25hbCB0aGF0IGFzeW5jUHJvbWlzZSBtaWdodCBiZSBudWxsLlxuICAgICAgICAvLyBUaGF0J3Mgd2hlbiBzZXRJc0FzeW5jIGhhcyBub3QgYmVlbiBjYWxsZWQgZHVyaW5nIHRoZVxuICAgICAgICAvLyBOT1dfQ0xPU0lOR19FVkVOVCBicm9hZGNhc3QuXG4gICAgICAgIHJldHVybiAkcS53aGVuKGFzeW5jUHJvbWlzZSkudGhlbihhZnRlckFuaW1hdGluZyk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWZ0ZXJBbmltYXRpbmcoKSB7XG4gICAgICAgICAgaWYgKGFmdGVyQW5pbWF0aW5nLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWZ0ZXJBbmltYXRpbmcuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICRhbmltYXRlQ3NzKGRvbUVsLCB7XG4gICAgICAgICAgICAgIGV2ZW50OiAnbGVhdmUnXG4gICAgICAgICAgICB9KS5zdGFydCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRvbUVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGRvbUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkZG9jdW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5rZXlib2FyZCkge1xuICAgICAgICAgIHN3aXRjaCAoZXZ0LndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlIDI3OiB7XG4gICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2VzY2FwZSBrZXkgcHJlc3MnKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLmxvYWRGb2N1c0VsZW1lbnRMaXN0KG1vZGFsKTtcbiAgICAgICAgICAgICAgdmFyIGZvY3VzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbShldnQpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgkbW9kYWxTdGFjay5pc0ZvY3VzSW5MYXN0SXRlbShldnQpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChmb2N1c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgJG1vZGFsU3RhY2sub3BlbiA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIG1vZGFsKSB7XG4gICAgICAgIHZhciBtb2RhbE9wZW5lciA9ICRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgIG1vZGFsQm9keUNsYXNzID0gbW9kYWwub3BlbmVkQ2xhc3MgfHwgT1BFTkVEX01PREFMX0NMQVNTO1xuXG4gICAgICAgIHRvZ2dsZVRvcFdpbmRvd0NsYXNzKGZhbHNlKTtcblxuICAgICAgICBvcGVuZWRXaW5kb3dzLmFkZChtb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxuICAgICAgICAgIHJlbmRlckRlZmVycmVkOiBtb2RhbC5yZW5kZXJEZWZlcnJlZCxcbiAgICAgICAgICBtb2RhbFNjb3BlOiBtb2RhbC5zY29wZSxcbiAgICAgICAgICBiYWNrZHJvcDogbW9kYWwuYmFja2Ryb3AsXG4gICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsLmtleWJvYXJkLFxuICAgICAgICAgIG9wZW5lZENsYXNzOiBtb2RhbC5vcGVuZWRDbGFzcyxcbiAgICAgICAgICB3aW5kb3dUb3BDbGFzczogbW9kYWwud2luZG93VG9wQ2xhc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3BlbmVkQ2xhc3Nlcy5wdXQobW9kYWxCb2R5Q2xhc3MsIG1vZGFsSW5zdGFuY2UpO1xuXG4gICAgICAgIHZhciBib2R5ID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5lcSgwKSxcbiAgICAgICAgICAgIGN1cnJCYWNrZHJvcEluZGV4ID0gYmFja2Ryb3BJbmRleCgpO1xuXG4gICAgICAgIGlmIChjdXJyQmFja2Ryb3BJbmRleCA+PSAwICYmICFiYWNrZHJvcERvbUVsKSB7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZSA9ICRyb290U2NvcGUuJG5ldyh0cnVlKTtcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlLmluZGV4ID0gY3VyckJhY2tkcm9wSW5kZXg7XG4gICAgICAgICAgdmFyIGFuZ3VsYXJCYWNrZ3JvdW5kRG9tRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgdWliLW1vZGFsLWJhY2tkcm9wPVwibW9kYWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgICBhbmd1bGFyQmFja2dyb3VuZERvbUVsLmF0dHIoJ2JhY2tkcm9wLWNsYXNzJywgbW9kYWwuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5ndWxhckJhY2tncm91bmREb21FbC5hdHRyKCdtb2RhbC1hbmltYXRpb24nLCAndHJ1ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiYWNrZHJvcERvbUVsID0gJGNvbXBpbGUoYW5ndWxhckJhY2tncm91bmREb21FbCkoYmFja2Ryb3BTY29wZSk7XG4gICAgICAgICAgYm9keS5hcHBlbmQoYmFja2Ryb3BEb21FbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5ndWxhckRvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1tb2RhbC13aW5kb3c9XCJtb2RhbC13aW5kb3dcIj48L2Rpdj4nKTtcbiAgICAgICAgYW5ndWxhckRvbUVsLmF0dHIoe1xuICAgICAgICAgICd0ZW1wbGF0ZS11cmwnOiBtb2RhbC53aW5kb3dUZW1wbGF0ZVVybCxcbiAgICAgICAgICAnd2luZG93LWNsYXNzJzogbW9kYWwud2luZG93Q2xhc3MsXG4gICAgICAgICAgJ3dpbmRvdy10b3AtY2xhc3MnOiBtb2RhbC53aW5kb3dUb3BDbGFzcyxcbiAgICAgICAgICAnc2l6ZSc6IG1vZGFsLnNpemUsXG4gICAgICAgICAgJ2luZGV4Jzogb3BlbmVkV2luZG93cy5sZW5ndGgoKSAtIDEsXG4gICAgICAgICAgJ2FuaW1hdGUnOiAnYW5pbWF0ZSdcbiAgICAgICAgfSkuaHRtbChtb2RhbC5jb250ZW50KTtcbiAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xuICAgICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCdtb2RhbC1hbmltYXRpb24nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZGFsRG9tRWwgPSAkY29tcGlsZShhbmd1bGFyRG9tRWwpKG1vZGFsLnNjb3BlKTtcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbERvbUVsID0gbW9kYWxEb21FbDtcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbE9wZW5lciA9IG1vZGFsT3BlbmVyO1xuICAgICAgICBib2R5LmFwcGVuZChtb2RhbERvbUVsKTtcbiAgICAgICAgYm9keS5hZGRDbGFzcyhtb2RhbEJvZHlDbGFzcyk7XG5cbiAgICAgICAgJG1vZGFsU3RhY2suY2xlYXJGb2N1c0xpc3RDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVzdWx0T3JSZWFzb24sIGNsb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiRicm9hZGNhc3QoJ21vZGFsLmNsb3NpbmcnLCByZXN1bHRPclJlYXNvbiwgY2xvc2luZykuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH1cblxuICAgICAgJG1vZGFsU3RhY2suY2xvc2UgPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdyAmJiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZXN1bHQsIHRydWUpKSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxPcGVuZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbW9kYWxXaW5kb3c7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgcmVhc29uKSB7XG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpO1xuICAgICAgICBpZiAobW9kYWxXaW5kb3cgJiYgYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVhc29uLCBmYWxzZSkpIHtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLmRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UsIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsT3BlbmVyKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93O1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZGlzbWlzc0FsbCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB2YXIgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xuICAgICAgICB3aGlsZSAodG9wTW9kYWwgJiYgdGhpcy5kaXNtaXNzKHRvcE1vZGFsLmtleSwgcmVhc29uKSkge1xuICAgICAgICAgIHRvcE1vZGFsID0gdGhpcy5nZXRUb3AoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZ2V0VG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZCA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLnJlbmRlckRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb2N1c2FibGVFbGVtZW50TGlzdFswXS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9jdXNhYmxlRWxlbWVudExpc3RbZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5pc0ZvY3VzSW5GaXJzdEl0ZW0gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gKGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQpID09IGZvY3VzYWJsZUVsZW1lbnRMaXN0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkxhc3RJdGVtID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIChldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KSA9PSBmb2N1c2FibGVFbGVtZW50TGlzdFtmb2N1c2FibGVFbGVtZW50TGlzdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5jbGVhckZvY3VzTGlzdENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRMaXN0ID0gW107XG4gICAgICAgIGZvY3VzSW5kZXggPSAwO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2subG9hZEZvY3VzRWxlbWVudExpc3QgPSBmdW5jdGlvbihtb2RhbFdpbmRvdykge1xuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudExpc3QgPT09IHVuZGVmaW5lZCB8fCAhZm9jdXNhYmxlRWxlbWVudExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxEb21FMSA9IG1vZGFsV2luZG93LnZhbHVlLm1vZGFsRG9tRWw7XG4gICAgICAgICAgICBpZiAobW9kYWxEb21FMSAmJiBtb2RhbERvbUUxLmxlbmd0aCkge1xuICAgICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50TGlzdCA9IG1vZGFsRG9tRTFbMF0ucXVlcnlTZWxlY3RvckFsbCh0YWJhYmJsZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAkbW9kYWxTdGFjaztcbiAgICB9XSlcblxuICAucHJvdmlkZXIoJyR1aWJNb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciAkbW9kYWxQcm92aWRlciA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBiYWNrZHJvcDogdHJ1ZSwgLy9jYW4gYWxzbyBiZSBmYWxzZSBvciAnc3RhdGljJ1xuICAgICAgICBrZXlib2FyZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgICRnZXQ6IFsnJGluamVjdG9yJywgJyRyb290U2NvcGUnLCAnJHEnLCAnJHRlbXBsYXRlUmVxdWVzdCcsICckY29udHJvbGxlcicsICckdWliTW9kYWxTdGFjaycsICckbW9kYWxTdXBwcmVzc1dhcm5pbmcnLCAnJGxvZycsXG4gICAgICAgIGZ1bmN0aW9uICgkaW5qZWN0b3IsICRyb290U2NvcGUsICRxLCAkdGVtcGxhdGVSZXF1ZXN0LCAkY29udHJvbGxlciwgJG1vZGFsU3RhY2ssICRtb2RhbFN1cHByZXNzV2FybmluZywgJGxvZykge1xuICAgICAgICAgIHZhciAkbW9kYWwgPSB7fTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlUHJvbWlzZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy50ZW1wbGF0ZSA/ICRxLndoZW4ob3B0aW9ucy50ZW1wbGF0ZSkgOlxuICAgICAgICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KGFuZ3VsYXIuaXNGdW5jdGlvbihvcHRpb25zLnRlbXBsYXRlVXJsKSA/IChvcHRpb25zLnRlbXBsYXRlVXJsKSgpIDogb3B0aW9ucy50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0UmVzb2x2ZVByb21pc2VzKHJlc29sdmVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXNBcnIgPSBbXTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNvbHZlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbih2YWx1ZSkgfHwgYW5ndWxhci5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzQXJyLnB1c2goJHEud2hlbigkaW5qZWN0b3IuaW52b2tlKHZhbHVlKSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNBcnIucHVzaCgkcS53aGVuKCRpbmplY3Rvci5nZXQodmFsdWUpKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNBcnIucHVzaCgkcS53aGVuKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzQXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9taXNlQ2hhaW4gPSBudWxsO1xuICAgICAgICAgICRtb2RhbC5nZXRQcm9taXNlQ2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlQ2hhaW47XG4gICAgICAgICAgfTtcblxuICAgICAgICAgICRtb2RhbC5vcGVuID0gZnVuY3Rpb24obW9kYWxPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxSZXN1bHREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxPcGVuZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxSZW5kZXJEZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIC8vcHJlcGFyZSBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsIHRvIGJlIGluamVjdGVkIGludG8gY29udHJvbGxlcnMgYW5kIHJldHVybmVkIHRvIGEgY2FsbGVyXG4gICAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBtb2RhbFJlc3VsdERlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIG9wZW5lZDogbW9kYWxPcGVuZWREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICByZW5kZXJlZDogbW9kYWxSZW5kZXJEZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkbW9kYWxTdGFjay5jbG9zZShtb2RhbEluc3RhbmNlLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkaXNtaXNzOiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWxJbnN0YW5jZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9tZXJnZSBhbmQgY2xlYW4gdXAgb3B0aW9uc1xuICAgICAgICAgICAgbW9kYWxPcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sICRtb2RhbFByb3ZpZGVyLm9wdGlvbnMsIG1vZGFsT3B0aW9ucyk7XG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMucmVzb2x2ZSA9IG1vZGFsT3B0aW9ucy5yZXNvbHZlIHx8IHt9O1xuXG4gICAgICAgICAgICAvL3ZlcmlmeSBvcHRpb25zXG4gICAgICAgICAgICBpZiAoIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZSAmJiAhbW9kYWxPcHRpb25zLnRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIHRlbXBsYXRlIG9yIHRlbXBsYXRlVXJsIG9wdGlvbnMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlID1cbiAgICAgICAgICAgICAgJHEuYWxsKFtnZXRUZW1wbGF0ZVByb21pc2UobW9kYWxPcHRpb25zKV0uY29uY2F0KGdldFJlc29sdmVQcm9taXNlcyhtb2RhbE9wdGlvbnMucmVzb2x2ZSkpKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVdpdGhUZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBleGlzdGluZyBwcm9taXNlIGNoYWluLlxuICAgICAgICAgICAgLy8gVGhlbiBzd2l0Y2ggdG8gb3VyIG93biBjb21iaW5lZCBwcm9taXNlIGRlcGVuZGVuY3kgKHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBwcmV2aW91cyBtb2RhbCBmYXJlZCkuXG4gICAgICAgICAgICAvLyBUaGVuIGFkZCB0byAkbW9kYWxTdGFjayBhbmQgcmVzb2x2ZSBvcGVuZWQuXG4gICAgICAgICAgICAvLyBGaW5hbGx5IGNsZWFuIHVwIHRoZSBjaGFpbiB2YXJpYWJsZSBpZiBubyBzdWJzZXF1ZW50IG1vZGFsIGhhcyBvdmVyd3JpdHRlbiBpdC5cbiAgICAgICAgICAgIHZhciBzYW1lUHJvbWlzZTtcbiAgICAgICAgICAgIHNhbWVQcm9taXNlID0gcHJvbWlzZUNoYWluID0gJHEuYWxsKFtwcm9taXNlQ2hhaW5dKVxuICAgICAgICAgICAgICAudGhlbihyZXNvbHZlV2l0aFRlbXBsYXRlLCByZXNvbHZlV2l0aFRlbXBsYXRlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiByZXNvbHZlU3VjY2Vzcyh0cGxBbmRWYXJzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9kYWxTY29wZSA9IChtb2RhbE9wdGlvbnMuc2NvcGUgfHwgJHJvb3RTY29wZSkuJG5ldygpO1xuICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGNsb3NlID0gbW9kYWxJbnN0YW5jZS5jbG9zZTtcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRkaXNtaXNzID0gbW9kYWxJbnN0YW5jZS5kaXNtaXNzO1xuXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRkaXNtaXNzKCckdWliVW5zY2hlZHVsZWREZXN0cnVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN0cmxJbnN0YW5jZSwgY3RybExvY2FscyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlSXRlciA9IDE7XG5cbiAgICAgICAgICAgICAgICAvL2NvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICBjdHJsTG9jYWxzLiRzY29wZSA9IG1vZGFsU2NvcGU7XG4gICAgICAgICAgICAgICAgICBjdHJsTG9jYWxzLiR1aWJNb2RhbEluc3RhbmNlID0gbW9kYWxJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHJsTG9jYWxzLCAnJG1vZGFsSW5zdGFuY2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRsb2cud2FybignJG1vZGFsSW5zdGFuY2UgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSAkdWliTW9kYWxJbnN0YW5jZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2RhbE9wdGlvbnMucmVzb2x2ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjdHJsTG9jYWxzW2tleV0gPSB0cGxBbmRWYXJzW3Jlc29sdmVJdGVyKytdO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZSA9ICRjb250cm9sbGVyKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyLCBjdHJsTG9jYWxzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlckFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuYmluZFRvQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGN0cmxJbnN0YW5jZSwgbW9kYWxTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtb2RhbFNjb3BlW21vZGFsT3B0aW9ucy5jb250cm9sbGVyQXNdID0gY3RybEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLm9wZW4obW9kYWxJbnN0YW5jZSwge1xuICAgICAgICAgICAgICAgICAgc2NvcGU6IG1vZGFsU2NvcGUsXG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZDogbW9kYWxSZXN1bHREZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckRlZmVycmVkOiBtb2RhbFJlbmRlckRlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogdHBsQW5kVmFyc1swXSxcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogbW9kYWxPcHRpb25zLmFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3AsXG4gICAgICAgICAgICAgICAgICBrZXlib2FyZDogbW9kYWxPcHRpb25zLmtleWJvYXJkLFxuICAgICAgICAgICAgICAgICAgYmFja2Ryb3BDbGFzczogbW9kYWxPcHRpb25zLmJhY2tkcm9wQ2xhc3MsXG4gICAgICAgICAgICAgICAgICB3aW5kb3dUb3BDbGFzczogbW9kYWxPcHRpb25zLndpbmRvd1RvcENsYXNzLFxuICAgICAgICAgICAgICAgICAgd2luZG93Q2xhc3M6IG1vZGFsT3B0aW9ucy53aW5kb3dDbGFzcyxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd1RlbXBsYXRlVXJsOiBtb2RhbE9wdGlvbnMud2luZG93VGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICBzaXplOiBtb2RhbE9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIG9wZW5lZENsYXNzOiBtb2RhbE9wdGlvbnMub3BlbmVkQ2xhc3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RhbE9wZW5lZERlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG5cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIHJlc29sdmVFcnJvcihyZWFzb24pIHtcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgbW9kYWxSZXN1bHREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHByb21pc2VDaGFpbiA9PT0gc2FtZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2hhaW4gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1vZGFsSW5zdGFuY2U7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiAkbW9kYWw7XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgcmV0dXJuICRtb2RhbFByb3ZpZGVyO1xuICB9KTtcblxuLyogZGVwcmVjYXRlZCBtb2RhbCBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLm1vZGFsJylcblxuICAudmFsdWUoJyRtb2RhbFN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBkaXJlY3RpdmUgZm9yIHRoZSAkbW9kYWwgc2VydmljZS4gSXQgY3JlYXRlcyBhIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAqL1xuICAuZGlyZWN0aXZlKCdtb2RhbEJhY2tkcm9wJywgW1xuICAgICckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJG1vZGFsU3RhY2snLCAnJGxvZycsICckbW9kYWxTdXBwcmVzc1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uKCRhbmltYXRlICwgICRpbmplY3RvciwgICAkbW9kYWxTdGFjaywgJGxvZywgJG1vZGFsU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICB2YXIgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gICAgICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICAgICAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbCcsXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgICAgICB0RWxlbWVudC5hZGRDbGFzcyh0QXR0cnMuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgICAgcmV0dXJuIGxpbmtGbjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBpZiAoISRtb2RhbFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybignbW9kYWwtYmFja2Ryb3AgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItbW9kYWwtYmFja2Ryb3AgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdtb2RhbC1iYWNrZHJvcCcpO1xuXG4gICAgICAgIGlmIChhdHRycy5tb2RhbEluQ2xhc3MpIHtcbiAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgYWRkQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgfSkuc3RhcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY29wZS4kb24oJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIGZ1bmN0aW9uKGUsIHNldElzQXN5bmMpIHtcbiAgICAgICAgICAgIHZhciBkb25lID0gc2V0SXNBc3luYygpO1xuICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXG4gICAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcykudGhlbihkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ21vZGFsV2luZG93JywgW1xuICAgICckbW9kYWxTdGFjaycsICckcScsICckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJGxvZycsICckbW9kYWxTdXBwcmVzc1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uKCRtb2RhbFN0YWNrICwgICRxICwgICRhbmltYXRlLCAgICRpbmplY3RvciwgJGxvZywgJG1vZGFsU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICB2YXIgJGFuaW1hdGVDc3MgPSBudWxsO1xuXG4gICAgICBpZiAoJGluamVjdG9yLmhhcygnJGFuaW1hdGVDc3MnKSkge1xuICAgICAgICAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRlQ3NzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgaW5kZXg6ICdAJ1xuICAgICAgICB9LFxuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgICAgIHJldHVybiB0QXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sJztcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKCEkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAgICRsb2cud2FybignbW9kYWwtd2luZG93IGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLW1vZGFsLXdpbmRvdyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKGF0dHJzLndpbmRvd0NsYXNzIHx8ICcnKTtcbiAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKGF0dHJzLndpbmRvd1RvcENsYXNzIHx8ICcnKTtcbiAgICAgICAgICBzY29wZS5zaXplID0gYXR0cnMuc2l6ZTtcblxuICAgICAgICAgIHNjb3BlLmNsb3NlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcbiAgICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAhPT0gJ3N0YXRpYycgJiYgKGV2dC50YXJnZXQgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2JhY2tkcm9wIGNsaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIG1vdmVkIGZyb20gdGVtcGxhdGUgdG8gZml4IGlzc3VlICMyMjgwXG4gICAgICAgICAgZWxlbWVudC5vbignY2xpY2snLCBzY29wZS5jbG9zZSk7XG5cbiAgICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG9ubHkgYWRkZWQgdG8gdGhlIHNjb3BlIGZvciB0aGUgcHVycG9zZSBvZiBkZXRlY3Rpbmcgd2hlbiB0aGlzIGRpcmVjdGl2ZSBpcyByZW5kZXJlZC5cbiAgICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgYnkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGlyZWN0aXZlIGFuZCB0aGVuIHVzZVxuICAgICAgICAgIC8vIHtAbGluayBBdHRyaWJ1dGUjJG9ic2VydmV9IG9uIGl0LiBGb3IgbW9yZSBkZXRhaWxzIHBsZWFzZSBzZWUge0BsaW5rIFRhYmxlQ29sdW1uUmVzaXplfS5cbiAgICAgICAgICBzY29wZS4kaXNSZW5kZXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBEZWZlcnJlZCBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhpcyBtb2RhbCBpcyByZW5kZXIuXG4gICAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJPYmogPSAkcS5kZWZlcigpO1xuICAgICAgICAgIC8vIE9ic2VydmUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gbmV4dCBkaWdlc3QgY3ljbGUgYWZ0ZXIgY29tcGlsYXRpb24sIGVuc3VyaW5nIHRoYXQgdGhlIERPTSBpcyByZWFkeS5cbiAgICAgICAgICAvLyBJbiBvcmRlciB0byB1c2UgdGhpcyB3YXkgb2YgZmluZGluZyB3aGV0aGVyIERPTSBpcyByZWFkeSwgd2UgbmVlZCB0byBvYnNlcnZlIGEgc2NvcGUgcHJvcGVydHkgdXNlZCBpbiBtb2RhbCdzIHRlbXBsYXRlLlxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCdtb2RhbFJlbmRlcicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgIG1vZGFsUmVuZGVyRGVmZXJPYmoucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChhdHRycy5tb2RhbEluQ2xhc3MpIHtcbiAgICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgIGFkZENsYXNzOiBhdHRycy5tb2RhbEluQ2xhc3NcbiAgICAgICAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UgPSAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCBhdHRycy5tb2RhbEluQ2xhc3MpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBzZXRJc0FzeW5jKCk7XG4gICAgICAgICAgICAgICAgaWYgKCRhbmltYXRlQ3NzKSB7XG4gICAgICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBhdHRycy5tb2RhbEluQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pLnN0YXJ0KCkudGhlbihkb25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKS50aGVuKGRvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgJHEud2hlbihhbmltYXRpb25Qcm9taXNlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgaW5wdXRXaXRoQXV0b2ZvY3VzID0gZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCdbYXV0b2ZvY3VzXScpO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQXV0by1mb2N1c2luZyBvZiBhIGZyZXNobHktb3BlbmVkIG1vZGFsIGVsZW1lbnQgY2F1c2VzIGFueSBjaGlsZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgKiB3aXRoIHRoZSBhdXRvZm9jdXMgYXR0cmlidXRlIHRvIGxvc2UgZm9jdXMuIFRoaXMgaXMgYW4gaXNzdWUgb24gdG91Y2hcbiAgICAgICAgICAgICAgICogYmFzZWQgZGV2aWNlcyB3aGljaCB3aWxsIHNob3cgYW5kIHRoZW4gaGlkZSB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuXG4gICAgICAgICAgICAgICAqIEF0dGVtcHRzIHRvIHJlZm9jdXMgdGhlIGF1dG9mb2N1cyBlbGVtZW50IHZpYSBKYXZhU2NyaXB0IHdpbGwgbm90IHJlb3BlblxuICAgICAgICAgICAgICAgKiB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuIEZpeGVkIGJ5IHVwZGF0ZWQgdGhlIGZvY3VzaW5nIGxvZ2ljIHRvIG9ubHkgYXV0b2ZvY3VzXG4gICAgICAgICAgICAgICAqIHRoZSBtb2RhbCBlbGVtZW50IGlmIHRoZSBtb2RhbCBkb2VzIG5vdCBjb250YWluIGFuIGF1dG9mb2N1cyBlbGVtZW50LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKGlucHV0V2l0aEF1dG9mb2N1cykge1xuICAgICAgICAgICAgICAgIGlucHV0V2l0aEF1dG9mb2N1cy5mb2N1cygpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vdGlmeSB7QGxpbmsgJG1vZGFsU3RhY2t9IHRoYXQgbW9kYWwgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcbiAgICAgICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgICAgICAkbW9kYWxTdGFjay5tb2RhbFJlbmRlcmVkKG1vZGFsLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxBbmltYXRpb25DbGFzcycsIFtcbiAgICAnJGxvZycsICckbW9kYWxTdXBwcmVzc1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uICgkbG9nLCAkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgICAgICBpZiAoISRtb2RhbFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICAgJGxvZy53YXJuKCdtb2RhbC1hbmltYXRpb24tY2xhc3MgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0QXR0cnMubW9kYWxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRFbGVtZW50LmFkZENsYXNzKHRBdHRycy5tb2RhbEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxUcmFuc2NsdWRlJywgW1xuICAgICckbG9nJywgJyRtb2RhbFN1cHByZXNzV2FybmluZycsXG4gICAgZnVuY3Rpb24gKCRsb2csICRtb2RhbFN1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsIGNvbnRyb2xsZXIsICR0cmFuc2NsdWRlKSB7XG4gICAgICAgIGlmICghJG1vZGFsU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdtb2RhbC10cmFuc2NsdWRlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLW1vZGFsLXRyYW5zY2x1ZGUgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAkdHJhbnNjbHVkZSgkc2NvcGUuJHBhcmVudCwgZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgICAgICAkZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICRlbGVtZW50LmFwcGVuZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5zZXJ2aWNlKCckbW9kYWxTdGFjaycsIFtcbiAgICAnJGFuaW1hdGUnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyRyb290U2NvcGUnLFxuICAgICckcScsXG4gICAgJyRpbmplY3RvcicsXG4gICAgJyQkbXVsdGlNYXAnLFxuICAgICckJHN0YWNrZWRNYXAnLFxuICAgICckdWliTW9kYWxTdGFjaycsXG4gICAgJyRsb2cnLFxuICAgICckbW9kYWxTdXBwcmVzc1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uKCRhbmltYXRlICwgICR0aW1lb3V0ICwgICRkb2N1bWVudCAsICAkY29tcGlsZSAsICAkcm9vdFNjb3BlICxcbiAgICAgICAgICAgICAkcSxcbiAgICAgICAgICAgICAkaW5qZWN0b3IsXG4gICAgICAgICAgICAgJCRtdWx0aU1hcCxcbiAgICAgICAgICAgICAkJHN0YWNrZWRNYXAsXG4gICAgICAgICAgICAgJHVpYk1vZGFsU3RhY2ssXG4gICAgICAgICAgICAgJGxvZyxcbiAgICAgICAgICAgICAkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgIGlmICghJG1vZGFsU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybignJG1vZGFsU3RhY2sgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSAkdWliTW9kYWxTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBhbmd1bGFyLmV4dGVuZCh0aGlzLCAkdWliTW9kYWxTdGFjayk7XG4gICAgfV0pXG5cbiAgLnByb3ZpZGVyKCckbW9kYWwnLCBbJyR1aWJNb2RhbFByb3ZpZGVyJywgZnVuY3Rpb24oJHVpYk1vZGFsUHJvdmlkZXIpIHtcbiAgICBhbmd1bGFyLmV4dGVuZCh0aGlzLCAkdWliTW9kYWxQcm92aWRlcik7XG5cbiAgICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsICckbG9nJywgJyRtb2RhbFN1cHByZXNzV2FybmluZycsXG4gICAgICBmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9nLCAkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgaWYgKCEkbW9kYWxTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJyRtb2RhbCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlICR1aWJNb2RhbCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRpbmplY3Rvci5pbnZva2UoJHVpYk1vZGFsUHJvdmlkZXIuJGdldCk7XG4gICAgICB9XTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2luYXRpb24nLCBbXSlcbi5jb250cm9sbGVyKCdVaWJQYWdpbmF0aW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJHBhcnNlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfSwgLy8gbnVsbE1vZGVsQ3RybFxuICAgICAgc2V0TnVtUGFnZXMgPSAkYXR0cnMubnVtUGFnZXMgPyAkcGFyc2UoJGF0dHJzLm51bVBhZ2VzKS5hc3NpZ24gOiBhbmd1bGFyLm5vb3A7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBjb25maWcpIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5pdGVtc1BlclBhZ2UpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLml0ZW1zUGVyUGFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBjb25maWcuaXRlbXNQZXJQYWdlO1xuICAgIH1cblxuICAgICRzY29wZS4kd2F0Y2goJ3RvdGFsSXRlbXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJHdhdGNoKCd0b3RhbFBhZ2VzJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldE51bVBhZ2VzKCRzY29wZS4kcGFyZW50LCB2YWx1ZSk7IC8vIFJlYWRvbmx5IHZhcmlhYmxlXG5cbiAgICAgIGlmICggJHNjb3BlLnBhZ2UgPiB2YWx1ZSApIHtcbiAgICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY2FsY3VsYXRlVG90YWxQYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbFBhZ2VzID0gdGhpcy5pdGVtc1BlclBhZ2UgPCAxID8gMSA6IE1hdGguY2VpbCgkc2NvcGUudG90YWxJdGVtcyAvIHRoaXMuaXRlbXNQZXJQYWdlKTtcbiAgICByZXR1cm4gTWF0aC5tYXgodG90YWxQYWdlcyB8fCAwLCAxKTtcbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5wYWdlID0gcGFyc2VJbnQobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwgMTApIHx8IDE7XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbihwYWdlLCBldnQpIHtcbiAgICBpZiAoZXZ0KSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgY2xpY2tBbGxvd2VkID0gISRzY29wZS5uZ0Rpc2FibGVkIHx8ICFldnQ7XG4gICAgaWYgKGNsaWNrQWxsb3dlZCAmJiAkc2NvcGUucGFnZSAhPT0gcGFnZSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICBpZiAoZXZ0ICYmIGV2dC50YXJnZXQpIHtcbiAgICAgICAgZXZ0LnRhcmdldC5ibHVyKCk7XG4gICAgICB9XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHBhZ2UpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAkc2NvcGVba2V5ICsgJ1RleHQnXSB8fCBzZWxmLmNvbmZpZ1trZXkgKyAnVGV4dCddO1xuICB9O1xuXG4gICRzY29wZS5ub1ByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzY29wZS5wYWdlID09PSAxO1xuICB9O1xuXG4gICRzY29wZS5ub05leHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xuICB9O1xufV0pXG5cbi5jb25zdGFudCgndWliUGFnaW5hdGlvbkNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgYm91bmRhcnlMaW5rczogZmFsc2UsXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxuICBmaXJzdFRleHQ6ICdGaXJzdCcsXG4gIHByZXZpb3VzVGV4dDogJ1ByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0JyxcbiAgbGFzdFRleHQ6ICdMYXN0JyxcbiAgcm90YXRlOiB0cnVlXG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQYWdpbmF0aW9uJywgWyckcGFyc2UnLCAndWliUGFnaW5hdGlvbkNvbmZpZycsIGZ1bmN0aW9uKCRwYXJzZSwgcGFnaW5hdGlvbkNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHNjb3BlOiB7XG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXG4gICAgICBmaXJzdFRleHQ6ICdAJyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIGxhc3RUZXh0OiAnQCcsXG4gICAgICBuZ0Rpc2FibGVkOic9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWyd1aWJQYWdpbmF0aW9uJywgJz9uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYlBhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdpbmF0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWwnO1xuICAgIH0sXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgcGFnaW5hdGlvbkN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xuICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgdmFyIG1heFNpemUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5tYXhTaXplKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMubWF4U2l6ZSkgOiBwYWdpbmF0aW9uQ29uZmlnLm1heFNpemUsXG4gICAgICAgICAgcm90YXRlID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMucm90YXRlKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMucm90YXRlKSA6IHBhZ2luYXRpb25Db25maWcucm90YXRlO1xuICAgICAgc2NvcGUuYm91bmRhcnlMaW5rcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmJvdW5kYXJ5TGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5ib3VuZGFyeUxpbmtzKSA6IHBhZ2luYXRpb25Db25maWcuYm91bmRhcnlMaW5rcztcbiAgICAgIHNjb3BlLmRpcmVjdGlvbkxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGlyZWN0aW9uTGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5kaXJlY3Rpb25MaW5rcykgOiBwYWdpbmF0aW9uQ29uZmlnLmRpcmVjdGlvbkxpbmtzO1xuXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBwYWdpbmF0aW9uQ29uZmlnKTtcblxuICAgICAgaWYgKGF0dHJzLm1heFNpemUpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1heFNpemUpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIG1heFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIHBhZ2luYXRpb25DdHJsLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgaW4gdGVtcGxhdGVcbiAgICAgIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGFnZXMoY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gW107XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwYWdlIGxpbWl0c1xuICAgICAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgIHZhciBpc01heFNpemVkID0gYW5ndWxhci5pc0RlZmluZWQobWF4U2l6ZSkgJiYgbWF4U2l6ZSA8IHRvdGFsUGFnZXM7XG5cbiAgICAgICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcbiAgICAgICAgaWYgKGlzTWF4U2l6ZWQpIHtcbiAgICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgICAgICAgICAgc3RhcnRQYWdlID0gTWF0aC5tYXgoY3VycmVudFBhZ2UgLSBNYXRoLmZsb29yKG1heFNpemUvMiksIDEpO1xuICAgICAgICAgICAgZW5kUGFnZSAgID0gc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICAgIGVuZFBhZ2UgICA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBtYXhTaXplICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICAgICAgc3RhcnRQYWdlID0gKChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSkgKyAxO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgbGFzdCBwYWdlIGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwYWdlIG51bWJlciBsaW5rc1xuICAgICAgICBmb3IgKHZhciBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xuICAgICAgICAgIHZhciBwYWdlID0gbWFrZVBhZ2UobnVtYmVyLCBudW1iZXIsIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgICAgICBpZiAoaXNNYXhTaXplZCAmJiAhIHJvdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYWdlU2V0ID0gbWFrZVBhZ2Uoc3RhcnRQYWdlIC0gMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5kUGFnZSA8IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UGFnZVNldCA9IG1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBwYWdpbmF0aW9uQ3RybC5yZW5kZXI7XG4gICAgICBwYWdpbmF0aW9uQ3RybC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWxSZW5kZXIoKTtcbiAgICAgICAgaWYgKHNjb3BlLnBhZ2UgPiAwICYmIHNjb3BlLnBhZ2UgPD0gc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgICAgIHNjb3BlLnBhZ2VzID0gZ2V0UGFnZXMoc2NvcGUucGFnZSwgc2NvcGUudG90YWxQYWdlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgndWliUGFnZXJDb25maWcnLCB7XG4gIGl0ZW1zUGVyUGFnZTogMTAsXG4gIHByZXZpb3VzVGV4dDogJ8KrIFByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0IMK7JyxcbiAgYWxpZ246IHRydWVcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBhZ2VyJywgWyd1aWJQYWdlckNvbmZpZycsIGZ1bmN0aW9uKHBhZ2VyQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIG5nRGlzYWJsZWQ6ICc9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWyd1aWJQYWdlcicsICc/bmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJQYWdpbmF0aW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAncGFnaW5hdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbCc7XG4gICAgfSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XG4gICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgc2NvcGUuYWxpZ24gPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5hbGlnbikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmFsaWduKSA6IHBhZ2VyQ29uZmlnLmFsaWduO1xuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChuZ01vZGVsQ3RybCwgcGFnZXJDb25maWcpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyogRGVwcmVjYXRlZCBQYWdpbmF0aW9uIEJlbG93ICovXG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucGFnaW5hdGlvbicpXG4udmFsdWUoJyRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG4uY29udHJvbGxlcignUGFnaW5hdGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJyRsb2cnLCAnJHBhZ2luYXRpb25TdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJHBhcnNlLCAkbG9nLCAkcGFnaW5hdGlvblN1cHByZXNzV2FybmluZykge1xuICBpZiAoISRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgJGxvZy53YXJuKCdQYWdpbmF0aW9uQ29udHJvbGxlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIFVpYlBhZ2luYXRpb25Db250cm9sbGVyIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9LCAvLyBudWxsTW9kZWxDdHJsXG4gICAgc2V0TnVtUGFnZXMgPSAkYXR0cnMubnVtUGFnZXMgPyAkcGFyc2UoJGF0dHJzLm51bVBhZ2VzKS5hc3NpZ24gOiBhbmd1bGFyLm5vb3A7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBjb25maWcpIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5pdGVtc1BlclBhZ2UpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLml0ZW1zUGVyUGFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBjb25maWcuaXRlbXNQZXJQYWdlO1xuICAgIH1cblxuICAgICRzY29wZS4kd2F0Y2goJ3RvdGFsSXRlbXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJHdhdGNoKCd0b3RhbFBhZ2VzJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldE51bVBhZ2VzKCRzY29wZS4kcGFyZW50LCB2YWx1ZSk7IC8vIFJlYWRvbmx5IHZhcmlhYmxlXG5cbiAgICAgIGlmICggJHNjb3BlLnBhZ2UgPiB2YWx1ZSApIHtcbiAgICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY2FsY3VsYXRlVG90YWxQYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbFBhZ2VzID0gdGhpcy5pdGVtc1BlclBhZ2UgPCAxID8gMSA6IE1hdGguY2VpbCgkc2NvcGUudG90YWxJdGVtcyAvIHRoaXMuaXRlbXNQZXJQYWdlKTtcbiAgICByZXR1cm4gTWF0aC5tYXgodG90YWxQYWdlcyB8fCAwLCAxKTtcbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5wYWdlID0gcGFyc2VJbnQobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwgMTApIHx8IDE7XG4gIH07XG5cbiAgJHNjb3BlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbihwYWdlLCBldnQpIHtcbiAgICBpZiAoZXZ0KSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgY2xpY2tBbGxvd2VkID0gISRzY29wZS5uZ0Rpc2FibGVkIHx8ICFldnQ7XG4gICAgaWYgKGNsaWNrQWxsb3dlZCAmJiAkc2NvcGUucGFnZSAhPT0gcGFnZSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICBpZiAoZXZ0ICYmIGV2dC50YXJnZXQpIHtcbiAgICAgICAgZXZ0LnRhcmdldC5ibHVyKCk7XG4gICAgICB9XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHBhZ2UpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAkc2NvcGVba2V5ICsgJ1RleHQnXSB8fCBzZWxmLmNvbmZpZ1trZXkgKyAnVGV4dCddO1xuICB9O1xuXG4gICRzY29wZS5ub1ByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzY29wZS5wYWdlID09PSAxO1xuICB9O1xuXG4gICRzY29wZS5ub05leHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xuICB9O1xufV0pXG4uZGlyZWN0aXZlKCdwYWdpbmF0aW9uJywgWyckcGFyc2UnLCAndWliUGFnaW5hdGlvbkNvbmZpZycsICckbG9nJywgJyRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJHBhcnNlLCBwYWdpbmF0aW9uQ29uZmlnLCAkbG9nLCAkcGFnaW5hdGlvblN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHNjb3BlOiB7XG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXG4gICAgICBmaXJzdFRleHQ6ICdAJyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIGxhc3RUZXh0OiAnQCcsXG4gICAgICBuZ0Rpc2FibGVkOic9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydwYWdpbmF0aW9uJywgJz9uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1BhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdpbmF0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWwnO1xuICAgIH0sXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICBpZiAoISRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigncGFnaW5hdGlvbiBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wYWdpbmF0aW9uIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcGFnaW5hdGlvbkN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xuICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgdmFyIG1heFNpemUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5tYXhTaXplKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMubWF4U2l6ZSkgOiBwYWdpbmF0aW9uQ29uZmlnLm1heFNpemUsXG4gICAgICAgICAgcm90YXRlID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMucm90YXRlKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMucm90YXRlKSA6IHBhZ2luYXRpb25Db25maWcucm90YXRlO1xuICAgICAgc2NvcGUuYm91bmRhcnlMaW5rcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmJvdW5kYXJ5TGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5ib3VuZGFyeUxpbmtzKSA6IHBhZ2luYXRpb25Db25maWcuYm91bmRhcnlMaW5rcztcbiAgICAgIHNjb3BlLmRpcmVjdGlvbkxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGlyZWN0aW9uTGlua3MpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy5kaXJlY3Rpb25MaW5rcykgOiBwYWdpbmF0aW9uQ29uZmlnLmRpcmVjdGlvbkxpbmtzO1xuXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBwYWdpbmF0aW9uQ29uZmlnKTtcblxuICAgICAgaWYgKGF0dHJzLm1heFNpemUpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1heFNpemUpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIG1heFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIHBhZ2luYXRpb25DdHJsLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgaW4gdGVtcGxhdGVcbiAgICAgIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGFnZXMoY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gW107XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwYWdlIGxpbWl0c1xuICAgICAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgIHZhciBpc01heFNpemVkID0gYW5ndWxhci5pc0RlZmluZWQobWF4U2l6ZSkgJiYgbWF4U2l6ZSA8IHRvdGFsUGFnZXM7XG5cbiAgICAgICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcbiAgICAgICAgaWYgKGlzTWF4U2l6ZWQpIHtcbiAgICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgICAgICAgICAgc3RhcnRQYWdlID0gTWF0aC5tYXgoY3VycmVudFBhZ2UgLSBNYXRoLmZsb29yKG1heFNpemUvMiksIDEpO1xuICAgICAgICAgICAgZW5kUGFnZSAgID0gc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICAgIGVuZFBhZ2UgICA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBtYXhTaXplICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICAgICAgc3RhcnRQYWdlID0gKChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSkgKyAxO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgbGFzdCBwYWdlIGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwYWdlIG51bWJlciBsaW5rc1xuICAgICAgICBmb3IgKHZhciBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xuICAgICAgICAgIHZhciBwYWdlID0gbWFrZVBhZ2UobnVtYmVyLCBudW1iZXIsIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgICAgICBpZiAoaXNNYXhTaXplZCAmJiAhIHJvdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYWdlU2V0ID0gbWFrZVBhZ2Uoc3RhcnRQYWdlIC0gMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5kUGFnZSA8IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UGFnZVNldCA9IG1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBwYWdpbmF0aW9uQ3RybC5yZW5kZXI7XG4gICAgICBwYWdpbmF0aW9uQ3RybC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWxSZW5kZXIoKTtcbiAgICAgICAgaWYgKHNjb3BlLnBhZ2UgPiAwICYmIHNjb3BlLnBhZ2UgPD0gc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgICAgIHNjb3BlLnBhZ2VzID0gZ2V0UGFnZXMoc2NvcGUucGFnZSwgc2NvcGUudG90YWxQYWdlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3BhZ2VyJywgWyd1aWJQYWdlckNvbmZpZycsICckbG9nJywgJyRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24ocGFnZXJDb25maWcsICRsb2csICRwYWdpbmF0aW9uU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIHByZXZpb3VzVGV4dDogJ0AnLFxuICAgICAgbmV4dFRleHQ6ICdAJyxcbiAgICAgIG5nRGlzYWJsZWQ6ICc9J1xuICAgIH0sXG4gICAgcmVxdWlyZTogWydwYWdlcicsICc/bmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6ICdQYWdpbmF0aW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAncGFnaW5hdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbCc7XG4gICAgfSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIGlmICghJHBhZ2luYXRpb25TdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdwYWdlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wYWdlciBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgdmFyIHBhZ2luYXRpb25DdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGlmICghbmdNb2RlbEN0cmwpIHtcbiAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxuICAgICAgfVxuXG4gICAgICBzY29wZS5hbGlnbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmFsaWduKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuYWxpZ24pIDogcGFnZXJDb25maWcuYWxpZ247XG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBwYWdlckNvbmZpZyk7XG4gICAgfVxuICB9O1xufV0pO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBhbmltYXRpb24gYXMgYVxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxuICoganVzdCBtb3VzZSBlbnRlci9sZWF2ZSwgaHRtbCB0b29sdGlwcywgYW5kIHNlbGVjdG9yIGRlbGVnYXRpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudG9vbHRpcCcsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgJ3VpLmJvb3RzdHJhcC5zdGFja2VkTWFwJ10pXG5cbi8qKlxuICogVGhlICR0b29sdGlwIHNlcnZpY2UgY3JlYXRlcyB0b29sdGlwLSBhbmQgcG9wb3Zlci1saWtlIGRpcmVjdGl2ZXMgYXMgd2VsbCBhc1xuICogaG91c2VzIGdsb2JhbCBvcHRpb25zIGZvciB0aGVtLlxuICovXG4ucHJvdmlkZXIoJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oKSB7XG4gIC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgdG9vbHRpcCBhbmQgcG9wb3Zlci5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBvcHVwRGVsYXk6IDAsXG4gICAgcG9wdXBDbG9zZURlbGF5OiAwLFxuICAgIHVzZUNvbnRlbnRFeHA6IGZhbHNlXG4gIH07XG5cbiAgLy8gRGVmYXVsdCBoaWRlIHRyaWdnZXJzIGZvciBlYWNoIHNob3cgdHJpZ2dlclxuICB2YXIgdHJpZ2dlck1hcCA9IHtcbiAgICAnbW91c2VlbnRlcic6ICdtb3VzZWxlYXZlJyxcbiAgICAnY2xpY2snOiAnY2xpY2snLFxuICAgICdmb2N1cyc6ICdibHVyJyxcbiAgICAnbm9uZSc6ICcnXG4gIH07XG5cbiAgLy8gVGhlIG9wdGlvbnMgc3BlY2lmaWVkIHRvIHRoZSBwcm92aWRlciBnbG9iYWxseS5cbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogYG9wdGlvbnMoe30pYCBhbGxvd3MgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHRvb2x0aXBzIGluIHRoZVxuICAgKiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogICB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoICdBcHAnLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10sIGZ1bmN0aW9uKCAkdG9vbHRpcFByb3ZpZGVyICkge1xuICAgKiAgICAgLy8gcGxhY2UgdG9vbHRpcHMgbGVmdCBpbnN0ZWFkIG9mIHRvcCBieSBkZWZhdWx0XG4gICAqICAgICAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnMoIHsgcGxhY2VtZW50OiAnbGVmdCcgfSApO1xuICAgKiAgIH0pO1xuICAgKi9cblx0dGhpcy5vcHRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRhbmd1bGFyLmV4dGVuZChnbG9iYWxPcHRpb25zLCB2YWx1ZSk7XG5cdH07XG5cbiAgLyoqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBleHRlbmQgdGhlIHNldCBvZiB0cmlnZ2VyIG1hcHBpbmdzIGF2YWlsYWJsZS4gRS5nLjpcbiAgICpcbiAgICogICAkdG9vbHRpcFByb3ZpZGVyLnNldFRyaWdnZXJzKCAnb3BlblRyaWdnZXInOiAnY2xvc2VUcmlnZ2VyJyApO1xuICAgKi9cbiAgdGhpcy5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uIHNldFRyaWdnZXJzKHRyaWdnZXJzKSB7XG4gICAgYW5ndWxhci5leHRlbmQodHJpZ2dlck1hcCwgdHJpZ2dlcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjYW1lbC1jYXNlIHRvIHNuYWtlLWNhc2UuXG4gICAqL1xuICBmdW5jdGlvbiBzbmFrZV9jYXNlKG5hbWUpIHtcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XG4gICAgdmFyIHNlcGFyYXRvciA9ICctJztcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIGluc3RhbmNlIG9mIHRoZSAkdG9vbHRpcCBzZXJ2aWNlLlxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcbiAgICovXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckY29tcGlsZScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHVpYlBvc2l0aW9uJywgJyRpbnRlcnBvbGF0ZScsICckcm9vdFNjb3BlJywgJyRwYXJzZScsICckJHN0YWNrZWRNYXAnLCBmdW5jdGlvbigkd2luZG93LCAkY29tcGlsZSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHBvc2l0aW9uLCAkaW50ZXJwb2xhdGUsICRyb290U2NvcGUsICRwYXJzZSwgJCRzdGFja2VkTWFwKSB7XG4gICAgdmFyIG9wZW5lZFRvb2x0aXBzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xuICAgICRkb2N1bWVudC5vbigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBvcGVuZWRUb29sdGlwcy50b3AoKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICBsYXN0LnZhbHVlLmNsb3NlKCk7XG4gICAgICAgICAgb3BlbmVkVG9vbHRpcHMucmVtb3ZlVG9wKCk7XG4gICAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAkdG9vbHRpcCh0dFR5cGUsIHByZWZpeCwgZGVmYXVsdFRyaWdnZXJTaG93LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBnbG9iYWxPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBzaG93IGFuZCBoaWRlIHRyaWdnZXJzLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgdHJpZ2dlciBpcyBzdXBwbGllZCxcbiAgICAgICAqIGl0IGlzIHVzZWQgdG8gc2hvdyB0aGUgdG9vbHRpcDsgb3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRyaWdnZXJgXG4gICAgICAgKiBvcHRpb24gcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2Q7IGVsc2UgaXQgd2lsbFxuICAgICAgICogZGVmYXVsdCB0byB0aGUgdHJpZ2dlciBzdXBwbGllZCB0byB0aGlzIGRpcmVjdGl2ZSBmYWN0b3J5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBoaWRlIHRyaWdnZXIgaXMgYmFzZWQgb24gdGhlIHNob3cgdHJpZ2dlci4gSWYgdGhlIGB0cmlnZ2VyYCBvcHRpb25cbiAgICAgICAqIHdhcyBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZCwgaXQgd2lsbCB1c2UgdGhlXG4gICAgICAgKiBtYXBwZWQgdHJpZ2dlciBmcm9tIGB0cmlnZ2VyTWFwYCBvciB0aGUgcGFzc2VkIHRyaWdnZXIgaWYgdGhlIG1hcCBpc1xuICAgICAgICogdW5kZWZpbmVkOyBvdGhlcndpc2UsIGl0IHVzZXMgdGhlIGB0cmlnZ2VyTWFwYCB2YWx1ZSBvZiB0aGUgc2hvd1xuICAgICAgICogdHJpZ2dlcjsgZWxzZSBpdCB3aWxsIGp1c3QgdXNlIHRoZSBzaG93IHRyaWdnZXIuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldFRyaWdnZXJzKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIHNob3cgPSAodHJpZ2dlciB8fCBvcHRpb25zLnRyaWdnZXIgfHwgZGVmYXVsdFRyaWdnZXJTaG93KS5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgaGlkZSA9IHNob3cubWFwKGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlck1hcFt0cmlnZ2VyXSB8fCB0cmlnZ2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaG93OiBzaG93LFxuICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGl2ZU5hbWUgPSBzbmFrZV9jYXNlKHR0VHlwZSk7XG5cbiAgICAgIHZhciBzdGFydFN5bSA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpO1xuICAgICAgdmFyIGVuZFN5bSA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9XG4gICAgICAgICc8ZGl2ICcrIGRpcmVjdGl2ZU5hbWUgKyAnLXBvcHVwICcrXG4gICAgICAgICAgJ3RpdGxlPVwiJyArIHN0YXJ0U3ltICsgJ3RpdGxlJyArIGVuZFN5bSArICdcIiAnK1xuICAgICAgICAgIChvcHRpb25zLnVzZUNvbnRlbnRFeHAgP1xuICAgICAgICAgICAgJ2NvbnRlbnQtZXhwPVwiY29udGVudEV4cCgpXCIgJyA6XG4gICAgICAgICAgICAnY29udGVudD1cIicgKyBzdGFydFN5bSArICdjb250ZW50JyArIGVuZFN5bSArICdcIiAnKSArXG4gICAgICAgICAgJ3BsYWNlbWVudD1cIicgKyBzdGFydFN5bSArICdwbGFjZW1lbnQnICsgZW5kU3ltICsgJ1wiICcrXG4gICAgICAgICAgJ3BvcHVwLWNsYXNzPVwiJyArIHN0YXJ0U3ltICsgJ3BvcHVwQ2xhc3MnICsgZW5kU3ltICsgJ1wiICcrXG4gICAgICAgICAgJ2FuaW1hdGlvbj1cImFuaW1hdGlvblwiICcgK1xuICAgICAgICAgICdpcy1vcGVuPVwiaXNPcGVuXCInICtcbiAgICAgICAgICAnb3JpZ2luLXNjb3BlPVwib3JpZ1Njb3BlXCIgJyArXG4gICAgICAgICAgJ3N0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuOyBkaXNwbGF5OiBibG9jazsgdG9wOiAtOTk5OXB4OyBsZWZ0OiAtOTk5OXB4O1wiJyArXG4gICAgICAgICAgJz4nICtcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtLCB0QXR0cnMpIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcExpbmtlciA9ICRjb21waWxlKHRlbXBsYXRlKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdG9vbHRpcEN0cmwpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwO1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBMaW5rZWRTY29wZTtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHZhciBzaG93VGltZW91dDtcbiAgICAgICAgICAgIHZhciBoaWRlVGltZW91dDtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQob3B0aW9ucy5hcHBlbmRUb0JvZHkpID8gb3B0aW9ucy5hcHBlbmRUb0JvZHkgOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB2YXIgaGFzRW5hYmxlRXhwID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnNbcHJlZml4ICsgJ0VuYWJsZSddKTtcbiAgICAgICAgICAgIHZhciB0dFNjb3BlID0gc2NvcGUuJG5ldyh0cnVlKTtcbiAgICAgICAgICAgIHZhciByZXBvc2l0aW9uU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNPcGVuUGFyc2UgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnSXNPcGVuJ10pID8gJHBhcnNlKGF0dHJzW3ByZWZpeCArICdJc09wZW4nXSkgOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb250ZW50UGFyc2UgPSBvcHRpb25zLnVzZUNvbnRlbnRFeHAgPyAkcGFyc2UoYXR0cnNbdHRUeXBlXSkgOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0b29sdGlwIGV4aXN0cyBhbmQgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgIGlmICghdG9vbHRpcCB8fCAhdG9vbHRpcC5odG1sKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAgICAgIHRvb2x0aXAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwIH0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyBOb3cgc2V0IHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uaW5nLlxuICAgICAgICAgICAgICAgICAgdmFyIHR0Q3NzID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoZWxlbWVudCwgdG9vbHRpcCwgdHRTY29wZS5wbGFjZW1lbnQsIGFwcGVuZFRvQm9keSk7XG4gICAgICAgICAgICAgICAgICB0dENzcy50b3AgKz0gJ3B4JztcbiAgICAgICAgICAgICAgICAgIHR0Q3NzLmxlZnQgKz0gJ3B4JztcbiAgICAgICAgICAgICAgICAgIHR0Q3NzLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICB0b29sdGlwLmNzcyh0dENzcyk7XG5cbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTZXQgdXAgdGhlIGNvcnJlY3Qgc2NvcGUgdG8gYWxsb3cgdHJhbnNjbHVzaW9uIGxhdGVyXG4gICAgICAgICAgICB0dFNjb3BlLm9yaWdTY29wZSA9IHNjb3BlO1xuXG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBpcyBub3Qgb3Blbi5cbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIGFiaWxpdHkgdG8gc3RhcnQgdG9vbHRpcCBvcGVuZWRcbiAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICBvcGVuZWRUb29sdGlwcy5hZGQodHRTY29wZSwge1xuICAgICAgICAgICAgICBjbG9zZTogaGlkZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBCaW5kKCkge1xuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCB3aXRoIGRlbGF5IGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNob3cgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwQmluZCgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc0VuYWJsZUV4cCAmJiAhc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0VuYWJsZSddKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbEhpZGUoKTtcbiAgICAgICAgICAgICAgcHJlcGFyZVRvb2x0aXAoKTtcblxuICAgICAgICAgICAgICBpZiAodHRTY29wZS5wb3B1cERlbGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgdG9vbHRpcCB3YXMgYWxyZWFkeSBzY2hlZHVsZWQgdG8gcG9wLXVwLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBpZiBzaG93IGlzIHRyaWdnZXJlZCBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgYW55IGhpZGUgaXMgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmICghc2hvd1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgIHNob3dUaW1lb3V0ID0gJHRpbWVvdXQoc2hvdywgdHRTY29wZS5wb3B1cERlbGF5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcEJpbmQoKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFNob3coKTtcblxuICAgICAgICAgICAgICBpZiAodHRTY29wZS5wb3B1cENsb3NlRGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhpZGVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICBoaWRlVGltZW91dCA9ICR0aW1lb3V0KGhpZGUsIHR0U2NvcGUucG9wdXBDbG9zZURlbGF5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwIHBvcHVwIGVsZW1lbnQuXG4gICAgICAgICAgICBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XG4gICAgICAgICAgICAgIGNhbmNlbEhpZGUoKTtcblxuICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGVtcHR5IHRvb2x0aXBzLlxuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUuY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLm5vb3A7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjcmVhdGVUb29sdGlwKCk7XG5cbiAgICAgICAgICAgICAgLy8gQW5kIHNob3cgdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAgIHR0U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXNzaWduSXNPcGVuKHRydWUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsU2hvdygpIHtcbiAgICAgICAgICAgICAgaWYgKHNob3dUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHNob3dUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzaG93VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocG9zaXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHBvc2l0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwIHBvcHVwIGVsZW1lbnQuXG4gICAgICAgICAgICBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XG4gICAgICAgICAgICAgIGNhbmNlbEhpZGUoKTtcblxuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3Q6IHdlIGRvbid0IHNob3cgaXQgYW55bW9yZS5cbiAgICAgICAgICAgICAgdHRTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXNzaWduSXNPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBBbmQgbm93IHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uIEhvd2V2ZXIsIGlmIHdlIGhhdmUgYW5pbWF0aW9uLCB3ZVxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgaXQgdG8gZXhwaXJlIGJlZm9yZWhhbmQuXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBwb3J0IG9mIHRoZSB0cmFuc2l0aW9ucyBsaWJyYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBmYWRlIHRyYW5zaXRpb24gaW4gVFdCUyBpcyAxNTBtcy5cbiAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSAkdGltZW91dChyZW1vdmVUb29sdGlwLCAxNTAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbEhpZGUoKSB7XG4gICAgICAgICAgICAgIGlmIChoaWRlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChoaWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgaGlkZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSB0b29sdGlwIGVsZW1lbnQgcGVyIGRpcmVjdGl2ZSBzaG93biBhdCBvbmNlLlxuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZSA9IHR0U2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICB0b29sdGlwID0gdG9vbHRpcExpbmtlcih0b29sdGlwTGlua2VkU2NvcGUsIGZ1bmN0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCh0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZnRlcih0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHByZXBPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgdW5yZWdpc3Rlck9ic2VydmVycygpO1xuXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0b29sdGlwTGlua2VkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBpbml0YWwgc2NvcGUgdmFsdWVzLiBPbmNlXG4gICAgICAgICAgICAgKiB0aGUgdG9vbHRpcCBpcyBjcmVhdGVkLCB0aGUgb2JzZXJ2ZXJzXG4gICAgICAgICAgICAgKiB3aWxsIGJlIGFkZGVkIHRvIGtlZXAgdGhpbmdzIGluIHN5bmNoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgdHRTY29wZS50aXRsZSA9IGF0dHJzW3ByZWZpeCArICdUaXRsZSddO1xuICAgICAgICAgICAgICBpZiAoY29udGVudFBhcnNlKSB7XG4gICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gY29udGVudFBhcnNlKHNjb3BlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnQgPSBhdHRyc1t0dFR5cGVdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHRTY29wZS5wb3B1cENsYXNzID0gYXR0cnNbcHJlZml4ICsgJ0NsYXNzJ107XG4gICAgICAgICAgICAgIHR0U2NvcGUucGxhY2VtZW50ID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnNbcHJlZml4ICsgJ1BsYWNlbWVudCddKSA/IGF0dHJzW3ByZWZpeCArICdQbGFjZW1lbnQnXSA6IG9wdGlvbnMucGxhY2VtZW50O1xuXG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KGF0dHJzW3ByZWZpeCArICdQb3B1cERlbGF5J10sIDEwKTtcbiAgICAgICAgICAgICAgdmFyIGNsb3NlRGVsYXkgPSBwYXJzZUludChhdHRyc1twcmVmaXggKyAnUG9wdXBDbG9zZURlbGF5J10sIDEwKTtcbiAgICAgICAgICAgICAgdHRTY29wZS5wb3B1cERlbGF5ID0gIWlzTmFOKGRlbGF5KSA/IGRlbGF5IDogb3B0aW9ucy5wb3B1cERlbGF5O1xuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSA9ICFpc05hTihjbG9zZURlbGF5KSA/IGNsb3NlRGVsYXkgOiBvcHRpb25zLnBvcHVwQ2xvc2VEZWxheTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXNzaWduSXNPcGVuKGlzT3Blbikge1xuICAgICAgICAgICAgICBpZiAoaXNPcGVuUGFyc2UgJiYgYW5ndWxhci5pc0Z1bmN0aW9uKGlzT3BlblBhcnNlLmFzc2lnbikpIHtcbiAgICAgICAgICAgICAgICBpc09wZW5QYXJzZS5hc3NpZ24oc2NvcGUsIGlzT3Blbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHRTY29wZS5jb250ZW50RXhwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0dFNjb3BlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9ic2VydmUgdGhlIHJlbGV2YW50IGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU2hvdygpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc09wZW5QYXJzZSkge1xuICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goaXNPcGVuUGFyc2UsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUgJiYgIXZhbCA9PT0gdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgIHRvZ2dsZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qanNoaW50ICtXMDE4ICovXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwT2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgICBvYnNlcnZlcnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICBpZiAoY29udGVudFBhcnNlKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goY29udGVudFBhcnNlLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcG9zaXRpb25TY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3NpdGlvblNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUgJiYgdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcbiAgICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHR0VHlwZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0U2NvcGUuY29udGVudCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwgJiYgdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9ic2VydmVycy5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdUaXRsZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgdHRTY29wZS50aXRsZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIG9ic2VydmVycy5wdXNoKFxuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdQbGFjZW1lbnQnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHR0U2NvcGUucGxhY2VtZW50ID0gdmFsID8gdmFsIDogb3B0aW9ucy5wbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdW5yZWdpc3Rlck9ic2VydmVycygpIHtcbiAgICAgICAgICAgICAgaWYgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gob2JzZXJ2ZXJzLCBmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5yZWdpc3RlclRyaWdnZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC51bmJpbmQodHJpZ2dlciwgc2hvd1Rvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRyaWdnZXJzLmhpZGUuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlci5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oaGlkZVRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihoaWRlVHJpZ2dlciwgaGlkZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwVHJpZ2dlcnMoKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBhdHRyc1twcmVmaXggKyAnVHJpZ2dlciddO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgICB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKHZhbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzLnNob3cgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIHJhdyBhZGRFdmVudExpc3RlbmVyIGR1ZSB0byBqcUxpdGUvalF1ZXJ5IGJ1ZyAtICM0MDYwXG4gICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA9PT0gdHJpZ2dlcnMuaGlkZVtpZHhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCB0b2dnbGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzLmhpZGVbaWR4XS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyLCBoaWRlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVwVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdBbmltYXRpb24nXSk7XG4gICAgICAgICAgICB0dFNjb3BlLmFuaW1hdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFuaW1hdGlvbikgPyAhIWFuaW1hdGlvbiA6IG9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5VmFsID0gc2NvcGUuJGV2YWwoYXR0cnNbcHJlZml4ICsgJ0FwcGVuZFRvQm9keSddKTtcbiAgICAgICAgICAgIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFwcGVuZFRvQm9keVZhbCkgPyBhcHBlbmRUb0JvZHlWYWwgOiBhcHBlbmRUb0JvZHk7XG5cbiAgICAgICAgICAgIC8vIGlmIGEgdG9vbHRpcCBpcyBhdHRhY2hlZCB0byA8Ym9keT4gd2UgbmVlZCB0byByZW1vdmUgaXQgb25cbiAgICAgICAgICAgIC8vIGxvY2F0aW9uIGNoYW5nZSBhcyBpdHMgcGFyZW50IHNjb3BlIHdpbGwgcHJvYmFibHkgbm90IGJlIGRlc3Ryb3llZFxuICAgICAgICAgICAgLy8gYnkgdGhlIGNoYW5nZS5cbiAgICAgICAgICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICAgICAgc2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gY2xvc2VUb29sdGlwT25Mb2NhdGlvbkNoYW5nZVN1Y2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgZGVzdHJveWVkIGFuZCByZW1vdmVkLlxuICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uIG9uRGVzdHJveVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFNob3coKTtcbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcbiAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICBvcGVuZWRUb29sdGlwcy5yZW1vdmUodHRTY29wZSk7XG4gICAgICAgICAgICAgIHR0U2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XTtcbn0pXG5cbi8vIFRoaXMgaXMgbW9zdGx5IG5nSW5jbHVkZSBjb2RlIGJ1dCB3aXRoIGEgY3VzdG9tIHNjb3BlXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlJywgW1xuICAgICAgICAgJyRhbmltYXRlJywgJyRzY2UnLCAnJGNvbXBpbGUnLCAnJHRlbXBsYXRlUmVxdWVzdCcsXG5mdW5jdGlvbiAoJGFuaW1hdGUgLCAgJHNjZSAsICAkY29tcGlsZSAsICAkdGVtcGxhdGVSZXF1ZXN0KSB7XG4gIHJldHVybiB7XG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICB2YXIgb3JpZ1Njb3BlID0gc2NvcGUuJGV2YWwoYXR0cnMudG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZVNjb3BlKTtcblxuICAgICAgdmFyIGNoYW5nZUNvdW50ZXIgPSAwLFxuICAgICAgICBjdXJyZW50U2NvcGUsXG4gICAgICAgIHByZXZpb3VzRWxlbWVudCxcbiAgICAgICAgY3VycmVudEVsZW1lbnQ7XG5cbiAgICAgIHZhciBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgJGFuaW1hdGUubGVhdmUoY3VycmVudEVsZW1lbnQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IGN1cnJlbnRFbGVtZW50O1xuICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCRzY2UucGFyc2VBc1Jlc291cmNlVXJsKGF0dHJzLnVpYlRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUpLCBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgdmFyIHRoaXNDaGFuZ2VJZCA9ICsrY2hhbmdlQ291bnRlcjtcblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgLy9zZXQgdGhlIDJuZCBwYXJhbSB0byB0cnVlIHRvIGlnbm9yZSB0aGUgdGVtcGxhdGUgcmVxdWVzdCBlcnJvciBzbyB0aGF0IHRoZSBpbm5lclxuICAgICAgICAgIC8vY29udGVudHMgYW5kIHNjb3BlIGNhbiBiZSBjbGVhbmVkIHVwLlxuICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3Qoc3JjLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkICE9PSBjaGFuZ2VDb3VudGVyKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gb3JpZ1Njb3BlLiRuZXcoKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJlc3BvbnNlO1xuXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSAkY29tcGlsZSh0ZW1wbGF0ZSkobmV3U2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY2xvbmUsIGVsZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBjbG9uZTtcblxuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRMb2FkZWQnLCBzcmMpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCA9PT0gY2hhbmdlQ291bnRlcikge1xuICAgICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRFcnJvcicsIHNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudFJlcXVlc3RlZCcsIHNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4vKipcbiAqIE5vdGUgdGhhdCBpdCdzIGludGVudGlvbmFsIHRoYXQgdGhlc2UgY2xhc3NlcyBhcmUgKm5vdCogYXBwbGllZCB0aHJvdWdoICRhbmltYXRlLlxuICogVGhleSBtdXN0IG5vdCBiZSBhbmltYXRlZCBhcyB0aGV5J3JlIGV4cGVjdGVkIHRvIGJlIHByZXNlbnQgb24gdGhlIHRvb2x0aXAgb25cbiAqIGluaXRpYWxpemF0aW9uLlxuICovXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwQ2xhc3NlcycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICBpZiAoc2NvcGUucGxhY2VtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3Moc2NvcGUucGxhY2VtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLnBvcHVwQ2xhc3MpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhzY29wZS5wb3B1cENsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLmFuaW1hdGlvbigpKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMudG9vbHRpcEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3Rvb2x0aXAnKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwJywgWyAnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlRvb2x0aXAnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJyk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcFRlbXBsYXRlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnLFxuICAgICAgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCd0b29sdGlwJyk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcFRlbXBsYXRlJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliVG9vbHRpcFRlbXBsYXRlJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBIdG1sUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5hZGRDbGFzcygndG9vbHRpcCcpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBIdG1sJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliVG9vbHRpcEh0bWwnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSk7XG5cbi8qIERlcHJlY2F0ZWQgdG9vbHRpcCBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRvb2x0aXAnKVxuXG4udmFsdWUoJyR0b29sdGlwU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbi5wcm92aWRlcignJHRvb2x0aXAnLCBbJyR1aWJUb29sdGlwUHJvdmlkZXInLCBmdW5jdGlvbigkdWliVG9vbHRpcFByb3ZpZGVyKSB7XG4gIGFuZ3VsYXIuZXh0ZW5kKHRoaXMsICR1aWJUb29sdGlwUHJvdmlkZXIpO1xuXG4gIHRoaXMuJGdldCA9IFsnJGxvZycsICckdG9vbHRpcFN1cHByZXNzV2FybmluZycsICckaW5qZWN0b3InLCBmdW5jdGlvbigkbG9nLCAkdG9vbHRpcFN1cHByZXNzV2FybmluZywgJGluamVjdG9yKSB7XG4gICAgaWYgKCEkdG9vbHRpcFN1cHByZXNzV2FybmluZykge1xuICAgICAgJGxvZy53YXJuKCckdG9vbHRpcCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlICR1aWJUb29sdGlwIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRpbmplY3Rvci5pbnZva2UoJHVpYlRvb2x0aXBQcm92aWRlci4kZ2V0KTtcbiAgfV07XG59XSlcblxuLy8gVGhpcyBpcyBtb3N0bHkgbmdJbmNsdWRlIGNvZGUgYnV0IHdpdGggYSBjdXN0b20gc2NvcGVcbi5kaXJlY3RpdmUoJ3Rvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUnLCBbXG4gICAgICAgICAnJGFuaW1hdGUnLCAnJHNjZScsICckY29tcGlsZScsICckdGVtcGxhdGVSZXF1ZXN0JywgJyRsb2cnLCAnJHRvb2x0aXBTdXBwcmVzc1dhcm5pbmcnLFxuZnVuY3Rpb24gKCRhbmltYXRlICwgICRzY2UgLCAgJGNvbXBpbGUgLCAgJHRlbXBsYXRlUmVxdWVzdCwgICAkbG9nLCAgICR0b29sdGlwU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICBpZiAoISR0b29sdGlwU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigndG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ1Njb3BlID0gc2NvcGUuJGV2YWwoYXR0cnMudG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZVNjb3BlKTtcblxuICAgICAgdmFyIGNoYW5nZUNvdW50ZXIgPSAwLFxuICAgICAgICBjdXJyZW50U2NvcGUsXG4gICAgICAgIHByZXZpb3VzRWxlbWVudCxcbiAgICAgICAgY3VycmVudEVsZW1lbnQ7XG5cbiAgICAgIHZhciBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShjdXJyZW50RWxlbWVudCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzUmVzb3VyY2VVcmwoYXR0cnMudG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZSksIGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgdGhpc0NoYW5nZUlkID0gKytjaGFuZ2VDb3VudGVyO1xuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAvL3NldCB0aGUgMm5kIHBhcmFtIHRvIHRydWUgdG8gaWdub3JlIHRoZSB0ZW1wbGF0ZSByZXF1ZXN0IGVycm9yIHNvIHRoYXQgdGhlIGlubmVyXG4gICAgICAgICAgLy9jb250ZW50cyBhbmQgc2NvcGUgY2FuIGJlIGNsZWFuZWQgdXAuXG4gICAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChzcmMsIHRydWUpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgIT09IGNoYW5nZUNvdW50ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBvcmlnU2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9ICRjb21waWxlKHRlbXBsYXRlKShuZXdTY29wZSwgZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgZWxlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGNsb25lO1xuXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudExvYWRlZCcsIHNyYyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkID09PSBjaGFuZ2VDb3VudGVyKSB7XG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgc2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudEVycm9yJywgc3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50UmVxdWVzdGVkJywgc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBDbGFzc2VzJywgWyckbG9nJywgJyR0b29sdGlwU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHRvb2x0aXBTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgaWYgKCEkdG9vbHRpcFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3Rvb2x0aXAtY2xhc3NlcyBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10b29sdGlwLWNsYXNzZXMgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjb3BlLnBsYWNlbWVudCkge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHNjb3BlLnBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUucG9wdXBDbGFzcykge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHNjb3BlLnBvcHVwQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlLmFuaW1hdGlvbigpKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMudG9vbHRpcEFuaW1hdGlvbkNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndG9vbHRpcFBvcHVwJywgWyckbG9nJywgJyR0b29sdGlwU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHRvb2x0aXBTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgIGlmICghJHRvb2x0aXBTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCd0b29sdGlwLXBvcHVwIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXRvb2x0aXAtcG9wdXAgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygndG9vbHRpcCcpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwJywgWyckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCgndG9vbHRpcCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInKTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwVGVtcGxhdGVQb3B1cCcsIFsnJGxvZycsICckdG9vbHRpcFN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICR0b29sdGlwU3VwcHJlc3NXYXJuaW5nKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyxcbiAgICAgIG9yaWdpblNjb3BlOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgaWYgKCEkdG9vbHRpcFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cCBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCd0b29sdGlwJyk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Rvb2x0aXBUZW1wbGF0ZScsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoJ3Rvb2x0aXBUZW1wbGF0ZScsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwSHRtbFBvcHVwJywgWyckbG9nJywgJyR0b29sdGlwU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHRvb2x0aXBTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgaWYgKCEkdG9vbHRpcFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3Rvb2x0aXAtaHRtbC1wb3B1cCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10b29sdGlwLWh0bWwtcG9wdXAgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygndG9vbHRpcCcpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0b29sdGlwSHRtbCcsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoJ3Rvb2x0aXBIdG1sJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBwb3B1cCBkZWxheSwgYW5pbWF0aW9uIGFzIGFcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGFuZCBzZWxlY3RvciBkZWxlZ2F0YXRpb24uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9wb3ZlcicsIFsndWkuYm9vdHN0cmFwLnRvb2x0aXAnXSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclRlbXBsYXRlUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IHRpdGxlOiAnQCcsIGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnLFxuICAgICAgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdwb3BvdmVyJyk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclRlbXBsYXRlJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3ZlclRlbXBsYXRlJywgJ3BvcG92ZXInLCAnY2xpY2snLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVySHRtbFBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHRpdGxlOiAnQCcsIHBsYWNlbWVudDogJ0AnLCBwb3B1cENsYXNzOiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BvcG92ZXInKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVySHRtbCcsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlBvcG92ZXJIdG1sJywgJ3BvcG92ZXInLCAnY2xpY2snLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVyUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IHRpdGxlOiAnQCcsIGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BvcG92ZXInKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVyJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3ZlcicsICdwb3BvdmVyJywgJ2NsaWNrJyk7XG59XSk7XG5cbi8qIERlcHJlY2F0ZWQgcG9wb3ZlciBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvcG92ZXInKVxuXG4udmFsdWUoJyRwb3BvdmVyU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbi5kaXJlY3RpdmUoJ3BvcG92ZXJUZW1wbGF0ZVBvcHVwJywgWyckbG9nJywgJyRwb3BvdmVyU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHBvcG92ZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IHRpdGxlOiAnQCcsIGNvbnRlbnRFeHA6ICcmJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnLFxuICAgICAgb3JpZ2luU2NvcGU6ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICBpZiAoISRwb3BvdmVyU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigncG9wb3Zlci10ZW1wbGF0ZS1wb3B1cCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BvcG92ZXInKTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgncG9wb3ZlclRlbXBsYXRlJywgWyckdG9vbHRpcCcsIGZ1bmN0aW9uKCR0b29sdGlwKSB7XG4gIHJldHVybiAkdG9vbHRpcCgncG9wb3ZlclRlbXBsYXRlJywgJ3BvcG92ZXInLCAnY2xpY2snLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVySHRtbFBvcHVwJywgWyckbG9nJywgJyRwb3BvdmVyU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHBvcG92ZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnRFeHA6ICcmJywgdGl0bGU6ICdAJywgcGxhY2VtZW50OiAnQCcsIHBvcHVwQ2xhc3M6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgaWYgKCEkcG9wb3ZlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3BvcG92ZXItaHRtbC1wb3B1cCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wb3BvdmVyLWh0bWwtcG9wdXAgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygncG9wb3ZlcicpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVySHRtbCcsIFsnJHRvb2x0aXAnLCBmdW5jdGlvbigkdG9vbHRpcCkge1xuICByZXR1cm4gJHRvb2x0aXAoJ3BvcG92ZXJIdG1sJywgJ3BvcG92ZXInLCAnY2xpY2snLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdwb3BvdmVyUG9wdXAnLCBbJyRsb2cnLCAnJHBvcG92ZXJTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkcG9wb3ZlclN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHsgdGl0bGU6ICdAJywgY29udGVudDogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgcG9wdXBDbGFzczogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xuICAgICAgaWYgKCEkcG9wb3ZlclN1cHByZXNzV2FybmluZykge1xuICAgICAgICAkbG9nLndhcm4oJ3BvcG92ZXItcG9wdXAgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItcG9wb3Zlci1wb3B1cCBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdwb3BvdmVyJyk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3BvcG92ZXInLCBbJyR0b29sdGlwJywgZnVuY3Rpb24oJHRvb2x0aXApIHtcblxuICByZXR1cm4gJHRvb2x0aXAoJ3BvcG92ZXInLCAncG9wb3ZlcicsICdjbGljaycpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnByb2dyZXNzYmFyJywgW10pXG5cbi5jb25zdGFudCgndWliUHJvZ3Jlc3NDb25maWcnLCB7XG4gIGFuaW1hdGU6IHRydWUsXG4gIG1heDogMTAwXG59KVxuXG4uY29udHJvbGxlcignVWliUHJvZ3Jlc3NDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ3VpYlByb2dyZXNzQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHByb2dyZXNzQ29uZmlnKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGFuaW1hdGUgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYW5pbWF0ZSkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYW5pbWF0ZSkgOiBwcm9ncmVzc0NvbmZpZy5hbmltYXRlO1xuXG4gIHRoaXMuYmFycyA9IFtdO1xuICAkc2NvcGUubWF4ID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLm1heCkgPyAkc2NvcGUubWF4IDogcHJvZ3Jlc3NDb25maWcubWF4O1xuXG4gIHRoaXMuYWRkQmFyID0gZnVuY3Rpb24oYmFyLCBlbGVtZW50LCBhdHRycykge1xuICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgZWxlbWVudC5jc3Moeyd0cmFuc2l0aW9uJzogJ25vbmUnfSk7XG4gICAgfVxuXG4gICAgdGhpcy5iYXJzLnB1c2goYmFyKTtcblxuICAgIGJhci5tYXggPSAkc2NvcGUubWF4O1xuICAgIGJhci50aXRsZSA9IGF0dHJzICYmIGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnRpdGxlKSA/IGF0dHJzLnRpdGxlIDogJ3Byb2dyZXNzYmFyJztcblxuICAgIGJhci4kd2F0Y2goJ3ZhbHVlJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcblxuICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b3RhbFBlcmNlbnRhZ2UgPSBzZWxmLmJhcnMucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBiYXIpIHtcbiAgICAgICAgYmFyLnBlcmNlbnQgPSArKDEwMCAqIGJhci52YWx1ZSAvIGJhci5tYXgpLnRvRml4ZWQoMik7XG4gICAgICAgIHJldHVybiB0b3RhbCArIGJhci5wZXJjZW50O1xuICAgICAgfSwgMCk7XG5cbiAgICAgIGlmICh0b3RhbFBlcmNlbnRhZ2UgPiAxMDApIHtcbiAgICAgICAgYmFyLnBlcmNlbnQgLT0gdG90YWxQZXJjZW50YWdlIC0gMTAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBiYXIuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICBzZWxmLnJlbW92ZUJhcihiYXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlQmFyID0gZnVuY3Rpb24oYmFyKSB7XG4gICAgdGhpcy5iYXJzLnNwbGljZSh0aGlzLmJhcnMuaW5kZXhPZihiYXIpLCAxKTtcbiAgICB0aGlzLmJhcnMuZm9yRWFjaChmdW5jdGlvbiAoYmFyKSB7XG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgnbWF4JywgZnVuY3Rpb24obWF4KSB7XG4gICAgc2VsZi5iYXJzLmZvckVhY2goZnVuY3Rpb24oYmFyKSB7XG4gICAgICBiYXIubWF4ID0gJHNjb3BlLm1heDtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1VpYlByb2dyZXNzQ29udHJvbGxlcicsXG4gICAgcmVxdWlyZTogJ3VpYlByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgbWF4OiAnPT8nXG4gICAgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJCYXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVxdWlyZTogJ151aWJQcm9ncmVzcycsXG4gICAgc2NvcGU6IHtcbiAgICAgIHZhbHVlOiAnPScsXG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgcHJvZ3Jlc3NDdHJsKSB7XG4gICAgICBwcm9ncmVzc0N0cmwuYWRkQmFyKHNjb3BlLCBlbGVtZW50LCBhdHRycyk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliUHJvZ3Jlc3NiYXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1VpYlByb2dyZXNzQ29udHJvbGxlcicsXG4gICAgc2NvcGU6IHtcbiAgICAgIHZhbHVlOiAnPScsXG4gICAgICBtYXg6ICc9PycsXG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LmNoaWxkcmVuKClbMF0pLCB7dGl0bGU6IGF0dHJzLnRpdGxlfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8qIERlcHJlY2F0ZWQgcHJvZ3Jlc3NiYXIgYmVsb3cgKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wcm9ncmVzc2JhcicpXG5cbi52YWx1ZSgnJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nJywgZmFsc2UpXG5cbi5jb250cm9sbGVyKCdQcm9ncmVzc0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUHJvZ3Jlc3NDb25maWcnLCAnJGxvZycsICckcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcHJvZ3Jlc3NDb25maWcsICRsb2csICRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICBpZiAoISRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICAgICRsb2cud2FybignUHJvZ3Jlc3NDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliUHJvZ3Jlc3NDb250cm9sbGVyIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgYW5pbWF0ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hbmltYXRlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XG5cbiAgdGhpcy5iYXJzID0gW107XG4gICRzY29wZS5tYXggPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUubWF4KSA/ICRzY29wZS5tYXggOiBwcm9ncmVzc0NvbmZpZy5tYXg7XG5cbiAgdGhpcy5hZGRCYXIgPSBmdW5jdGlvbihiYXIsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICBlbGVtZW50LmNzcyh7J3RyYW5zaXRpb24nOiAnbm9uZSd9KTtcbiAgICB9XG5cbiAgICB0aGlzLmJhcnMucHVzaChiYXIpO1xuXG4gICAgYmFyLm1heCA9ICRzY29wZS5tYXg7XG4gICAgYmFyLnRpdGxlID0gYXR0cnMgJiYgYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudGl0bGUpID8gYXR0cnMudGl0bGUgOiAncHJvZ3Jlc3NiYXInO1xuXG4gICAgYmFyLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpO1xuICAgIH0pO1xuXG4gICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgYmFyLnBlcmNlbnQgPSArKDEwMCAqIGJhci52YWx1ZSAvIGJhci5tYXgpLnRvRml4ZWQoMik7XG5cbiAgICAgIHZhciB0b3RhbFBlcmNlbnRhZ2UgPSBzZWxmLmJhcnMucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBiYXIpIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgYmFyLnBlcmNlbnQ7XG4gICAgICB9LCAwKTtcblxuICAgICAgaWYgKHRvdGFsUGVyY2VudGFnZSA+IDEwMCkge1xuICAgICAgICBiYXIucGVyY2VudCAtPSB0b3RhbFBlcmNlbnRhZ2UgLSAxMDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGJhci4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIHNlbGYucmVtb3ZlQmFyKGJhcik7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmVCYXIgPSBmdW5jdGlvbihiYXIpIHtcbiAgICB0aGlzLmJhcnMuc3BsaWNlKHRoaXMuYmFycy5pbmRleE9mKGJhciksIDEpO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ21heCcsIGZ1bmN0aW9uKG1heCkge1xuICAgIHNlbGYuYmFycy5mb3JFYWNoKGZ1bmN0aW9uKGJhcikge1xuICAgICAgYmFyLm1heCA9ICRzY29wZS5tYXg7XG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gICAgfSk7XG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Byb2dyZXNzJywgWyckbG9nJywgJyRwcm9ncmVzc1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnUHJvZ3Jlc3NDb250cm9sbGVyJyxcbiAgICByZXF1aXJlOiAncHJvZ3Jlc3MnLFxuICAgIHNjb3BlOiB7XG4gICAgICBtYXg6ICc9PycsXG4gICAgICB0aXRsZTogJ0A/J1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigncHJvZ3Jlc3MgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItcHJvZ3Jlc3MgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgnYmFyJywgWyckbG9nJywgJyRwcm9ncmVzc1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIGlmICghJHByb2dyZXNzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybignYmFyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLWJhciBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgZWxlbWVudCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3Byb2dyZXNzYmFyJywgWyckbG9nJywgJyRwcm9ncmVzc1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICRwcm9ncmVzc1N1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnUHJvZ3Jlc3NDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIG1heDogJz0/JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHByb2dyZXNzQ3RybCkge1xuICAgICAgaWYgKCEkcHJvZ3Jlc3NTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdwcm9ncmVzc2JhciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi1wcm9ncmVzc2JhciBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgYW5ndWxhci5lbGVtZW50KGVsZW1lbnQuY2hpbGRyZW4oKVswXSksIHt0aXRsZTogYXR0cnMudGl0bGV9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucmF0aW5nJywgW10pXG5cbi5jb25zdGFudCgndWliUmF0aW5nQ29uZmlnJywge1xuICBtYXg6IDUsXG4gIHN0YXRlT246IG51bGwsXG4gIHN0YXRlT2ZmOiBudWxsLFxuICB0aXRsZXMgOiBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJ11cbn0pXG5cbi5jb250cm9sbGVyKCdVaWJSYXRpbmdDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ3VpYlJhdGluZ0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCByYXRpbmdDb25maWcpIHtcbiAgdmFyIG5nTW9kZWxDdHJsICA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH07XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IHRoaXMucmVuZGVyO1xuXG4gICAgbmdNb2RlbEN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlIDw8IDAgIT09IHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0YXRlT24gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhdGVPbikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPbikgOiByYXRpbmdDb25maWcuc3RhdGVPbjtcbiAgICB0aGlzLnN0YXRlT2ZmID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnN0YXRlT2ZmKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zdGF0ZU9mZikgOiByYXRpbmdDb25maWcuc3RhdGVPZmY7XG4gICAgdmFyIHRtcFRpdGxlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy50aXRsZXMpICA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy50aXRsZXMpIDogcmF0aW5nQ29uZmlnLnRpdGxlcyA7XG4gICAgdGhpcy50aXRsZXMgPSBhbmd1bGFyLmlzQXJyYXkodG1wVGl0bGVzKSAmJiB0bXBUaXRsZXMubGVuZ3RoID4gMCA/XG4gICAgICB0bXBUaXRsZXMgOiByYXRpbmdDb25maWcudGl0bGVzO1xuXG4gICAgdmFyIHJhdGluZ1N0YXRlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yYXRpbmdTdGF0ZXMpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yYXRpbmdTdGF0ZXMpIDpcbiAgICAgIG5ldyBBcnJheShhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubWF4KSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tYXgpIDogcmF0aW5nQ29uZmlnLm1heCk7XG4gICAgJHNjb3BlLnJhbmdlID0gdGhpcy5idWlsZFRlbXBsYXRlT2JqZWN0cyhyYXRpbmdTdGF0ZXMpO1xuICB9O1xuXG4gIHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMgPSBmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN0YXRlc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHsgaW5kZXg6IGkgfSwgeyBzdGF0ZU9uOiB0aGlzLnN0YXRlT24sIHN0YXRlT2ZmOiB0aGlzLnN0YXRlT2ZmLCB0aXRsZTogdGhpcy5nZXRUaXRsZShpKSB9LCBzdGF0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuXG4gIHRoaXMuZ2V0VGl0bGUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnRpdGxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpdGxlc1tpbmRleF07XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5yYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISRzY29wZS5yZWFkb25seSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9ICRzY29wZS5yYW5nZS5sZW5ndGgpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PT0gdmFsdWUgPyAwIDogdmFsdWUpO1xuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZW50ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghJHNjb3BlLnJlYWRvbmx5KSB7XG4gICAgICAkc2NvcGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgJHNjb3BlLm9uSG92ZXIoe3ZhbHVlOiB2YWx1ZX0pO1xuICB9O1xuXG4gICRzY29wZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS52YWx1ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XG4gICAgJHNjb3BlLm9uTGVhdmUoKTtcbiAgfTtcblxuICAkc2NvcGUub25LZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgaWYgKC8oMzd8Mzh8Mzl8NDApLy50ZXN0KGV2dC53aGljaCkpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgJHNjb3BlLnJhdGUoJHNjb3BlLnZhbHVlICsgKGV2dC53aGljaCA9PT0gMzggfHwgZXZ0LndoaWNoID09PSAzOSA/IDEgOiAtMSkpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS52YWx1ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUmF0aW5nJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJSYXRpbmcnLCAnbmdNb2RlbCddLFxuICAgIHNjb3BlOiB7XG4gICAgICByZWFkb25seTogJz0/JyxcbiAgICAgIG9uSG92ZXI6ICcmJyxcbiAgICAgIG9uTGVhdmU6ICcmJ1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogJ1VpYlJhdGluZ0NvbnRyb2xsZXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciByYXRpbmdDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG4gICAgICByYXRpbmdDdHJsLmluaXQobmdNb2RlbEN0cmwpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKiBEZXByZWNhdGVkIHJhdGluZyBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnJhdGluZycpXG5cbi52YWx1ZSgnJHJhdGluZ1N1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4uY29udHJvbGxlcignUmF0aW5nQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckY29udHJvbGxlcicsICckbG9nJywgJyRyYXRpbmdTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJGNvbnRyb2xsZXIsICRsb2csICRyYXRpbmdTdXBwcmVzc1dhcm5pbmcpIHtcbiAgaWYgKCEkcmF0aW5nU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgJGxvZy53YXJuKCdSYXRpbmdDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliUmF0aW5nQ29udHJvbGxlciBpbnN0ZWFkLicpO1xuICB9XG5cbiAgYW5ndWxhci5leHRlbmQodGhpcywgJGNvbnRyb2xsZXIoJ1VpYlJhdGluZ0NvbnRyb2xsZXInLCB7XG4gICAgJHNjb3BlOiAkc2NvcGUsXG4gICAgJGF0dHJzOiAkYXR0cnNcbiAgfSkpO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3JhdGluZycsIFsnJGxvZycsICckcmF0aW5nU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJGxvZywgJHJhdGluZ1N1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsncmF0aW5nJywgJ25nTW9kZWwnXSxcbiAgICBzY29wZToge1xuICAgICAgcmVhZG9ubHk6ICc9PycsXG4gICAgICBvbkhvdmVyOiAnJicsXG4gICAgICBvbkxlYXZlOiAnJidcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6ICdSYXRpbmdDb250cm9sbGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbCcsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICBpZiAoISRyYXRpbmdTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgJGxvZy53YXJuKCdyYXRpbmcgaXMgbm93IGRlcHJlY2F0ZWQuIFVzZSB1aWItcmF0aW5nIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmF0aW5nQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuICAgICAgcmF0aW5nQ3RybC5pbml0KG5nTW9kZWxDdHJsKTtcbiAgICB9XG4gIH07XG59XSk7XG5cblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbmd1bGFySlMgdmVyc2lvbiBvZiB0aGUgdGFicyBkaXJlY3RpdmUuXG4gKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50YWJzJywgW10pXG5cbi5jb250cm9sbGVyKCdVaWJUYWJzZXRDb250cm9sbGVyJywgWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gIHZhciBjdHJsID0gdGhpcyxcbiAgICAgIHRhYnMgPSBjdHJsLnRhYnMgPSAkc2NvcGUudGFicyA9IFtdO1xuXG4gIGN0cmwuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0ZWRUYWIpIHtcbiAgICBhbmd1bGFyLmZvckVhY2godGFicywgZnVuY3Rpb24odGFiKSB7XG4gICAgICBpZiAodGFiLmFjdGl2ZSAmJiB0YWIgIT09IHNlbGVjdGVkVGFiKSB7XG4gICAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGFiLm9uRGVzZWxlY3QoKTtcbiAgICAgICAgc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0ZWRUYWIuYWN0aXZlID0gdHJ1ZTtcbiAgICAvLyBvbmx5IGNhbGwgc2VsZWN0IGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgIGlmICghc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5vblNlbGVjdCgpO1xuICAgICAgc2VsZWN0ZWRUYWIuc2VsZWN0Q2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5hZGRUYWIgPSBmdW5jdGlvbiBhZGRUYWIodGFiKSB7XG4gICAgdGFicy5wdXNoKHRhYik7XG4gICAgLy8gd2UgY2FuJ3QgcnVuIHRoZSBzZWxlY3QgZnVuY3Rpb24gb24gdGhlIGZpcnN0IHRhYlxuICAgIC8vIHNpbmNlIHRoYXQgd291bGQgc2VsZWN0IGl0IHR3aWNlXG4gICAgaWYgKHRhYnMubGVuZ3RoID09PSAxICYmIHRhYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICB0YWIuYWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhYi5hY3RpdmUpIHtcbiAgICAgIGN0cmwuc2VsZWN0KHRhYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5yZW1vdmVUYWIgPSBmdW5jdGlvbiByZW1vdmVUYWIodGFiKSB7XG4gICAgdmFyIGluZGV4ID0gdGFicy5pbmRleE9mKHRhYik7XG4gICAgLy9TZWxlY3QgYSBuZXcgdGFiIGlmIHRoZSB0YWIgdG8gYmUgcmVtb3ZlZCBpcyBzZWxlY3RlZCBhbmQgbm90IGRlc3Ryb3llZFxuICAgIGlmICh0YWIuYWN0aXZlICYmIHRhYnMubGVuZ3RoID4gMSAmJiAhZGVzdHJveWVkKSB7XG4gICAgICAvL0lmIHRoaXMgaXMgdGhlIGxhc3QgdGFiLCBzZWxlY3QgdGhlIHByZXZpb3VzIHRhYi4gZWxzZSwgdGhlIG5leHQgdGFiLlxuICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gaW5kZXggPT0gdGFicy5sZW5ndGggLSAxID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgY3RybC5zZWxlY3QodGFic1tuZXdBY3RpdmVJbmRleF0pO1xuICAgIH1cbiAgICB0YWJzLnNwbGljZShpbmRleCwgMSk7XG4gIH07XG5cbiAgdmFyIGRlc3Ryb3llZDtcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9KTtcbn1dKVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJzZXRcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGFic2V0IGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIHRoZSB0YWJzIGRpcmVjdGl2ZVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHZlcnRpY2FsIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB2ZXJ0aWNhbCBzdHlsaW5nIGZvciB0aGUgdGFicy5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGp1c3RpZmllZCBXaGV0aGVyIG9yIG5vdCB0byB1c2UganVzdGlmaWVkIHN0eWxpbmcgZm9yIHRoZSB0YWJzLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8dWliLXRhYnNldD5cbiAgICAgIDx1aWItdGFiIGhlYWRpbmc9XCJUYWIgMVwiPjxiPkZpcnN0PC9iPiBDb250ZW50ITwvdWliLXRhYj5cbiAgICAgIDx1aWItdGFiIGhlYWRpbmc9XCJUYWIgMlwiPjxpPlNlY29uZDwvaT4gQ29udGVudCE8L3VpYi10YWI+XG4gICAgPC91aWItdGFic2V0PlxuICAgIDxociAvPlxuICAgIDx1aWItdGFic2V0IHZlcnRpY2FsPVwidHJ1ZVwiPlxuICAgICAgPHVpYi10YWIgaGVhZGluZz1cIlZlcnRpY2FsIFRhYiAxXCI+PGI+Rmlyc3Q8L2I+IFZlcnRpY2FsIENvbnRlbnQhPC91aWItdGFiPlxuICAgICAgPHVpYi10YWIgaGVhZGluZz1cIlZlcnRpY2FsIFRhYiAyXCI+PGk+U2Vjb25kPC9pPiBWZXJ0aWNhbCBDb250ZW50ITwvdWliLXRhYj5cbiAgICA8L3VpYi10YWJzZXQ+XG4gICAgPHVpYi10YWJzZXQganVzdGlmaWVkPVwidHJ1ZVwiPlxuICAgICAgPHVpYi10YWIgaGVhZGluZz1cIkp1c3RpZmllZCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBKdXN0aWZpZWQgQ29udGVudCE8L3VpYi10YWI+XG4gICAgICA8dWliLXRhYiBoZWFkaW5nPVwiSnVzdGlmaWVkIFRhYiAyXCI+PGk+U2Vjb25kPC9pPiBKdXN0aWZpZWQgQ29udGVudCE8L3VpYi10YWI+XG4gICAgPC91aWItdGFic2V0PlxuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ3VpYlRhYnNldCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgdHlwZTogJ0AnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiAnVWliVGFic2V0Q29udHJvbGxlcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHNjb3BlLnZlcnRpY2FsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudmVydGljYWwpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy52ZXJ0aWNhbCkgOiBmYWxzZTtcbiAgICAgIHNjb3BlLmp1c3RpZmllZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmp1c3RpZmllZCkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmp1c3RpZmllZCkgOiBmYWxzZTtcbiAgICB9XG4gIH07XG59KVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gaGVhZGluZyBUaGUgdmlzaWJsZSBoZWFkaW5nLCBvciB0aXRsZSwgb2YgdGhlIHRhYi4gU2V0IEhUTUwgaGVhZGluZ3Mgd2l0aCB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYkhlYWRpbmcgdGFiSGVhZGluZ30uXG4gKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdCBBbiBleHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIHRhYiBpcyBzZWxlY3RlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGFjdGl2ZSBBIGJpbmRpbmcsIHRlbGxpbmcgd2hldGhlciBvciBub3QgdGhpcyB0YWIgaXMgc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBkaXNhYmxlZCBBIGJpbmRpbmcsIHRlbGxpbmcgd2hldGhlciBvciBub3QgdGhpcyB0YWIgaXMgZGlzYWJsZWQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGEgdGFiIHdpdGggYSBoZWFkaW5nIGFuZCBjb250ZW50LiBNdXN0IGJlIHBsYWNlZCB3aXRoaW4gYSB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYnNldCB0YWJzZXR9LlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJUYWJzRGVtb0N0cmxcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgbmctY2xpY2s9XCJpdGVtc1swXS5hY3RpdmUgPSB0cnVlXCI+XG4gICAgICAgIFNlbGVjdCBpdGVtIDEsIHVzaW5nIGFjdGl2ZSBiaW5kaW5nXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtYWxsXCIgbmctY2xpY2s9XCJpdGVtc1sxXS5kaXNhYmxlZCA9ICFpdGVtc1sxXS5kaXNhYmxlZFwiPlxuICAgICAgICBFbmFibGUvZGlzYWJsZSBpdGVtIDIsIHVzaW5nIGRpc2FibGVkIGJpbmRpbmdcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJyIC8+XG4gICAgICA8dWliLXRhYnNldD5cbiAgICAgICAgPHVpYi10YWIgaGVhZGluZz1cIlRhYiAxXCI+Rmlyc3QgVGFiPC91aWItdGFiPlxuICAgICAgICA8dWliLXRhYiBzZWxlY3Q9XCJhbGVydE1lKClcIj5cbiAgICAgICAgICA8dWliLXRhYi1oZWFkaW5nPjxpIGNsYXNzPVwiaWNvbi1iZWxsXCI+PC9pPiBBbGVydCBtZSE8L3RhYi1oZWFkaW5nPlxuICAgICAgICAgIFNlY29uZCBUYWIsIHdpdGggYWxlcnQgY2FsbGJhY2sgYW5kIGh0bWwgaGVhZGluZyFcbiAgICAgICAgPC91aWItdGFiPlxuICAgICAgICA8dWliLXRhYiBuZy1yZXBlYXQ9XCJpdGVtIGluIGl0ZW1zXCJcbiAgICAgICAgICBoZWFkaW5nPVwie3tpdGVtLnRpdGxlfX1cIlxuICAgICAgICAgIGRpc2FibGVkPVwiaXRlbS5kaXNhYmxlZFwiXG4gICAgICAgICAgYWN0aXZlPVwiaXRlbS5hY3RpdmVcIj5cbiAgICAgICAgICB7e2l0ZW0uY29udGVudH19XG4gICAgICAgIDwvdWliLXRhYj5cbiAgICAgIDwvdWliLXRhYnNldD5cbiAgICA8L2Rpdj5cbiAgPC9maWxlPlxuICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgZnVuY3Rpb24gVGFic0RlbW9DdHJsKCRzY29wZSkge1xuICAgICAgJHNjb3BlLml0ZW1zID0gW1xuICAgICAgICB7IHRpdGxlOlwiRHluYW1pYyBUaXRsZSAxXCIsIGNvbnRlbnQ6XCJEeW5hbWljIEl0ZW0gMFwiIH0sXG4gICAgICAgIHsgdGl0bGU6XCJEeW5hbWljIFRpdGxlIDJcIiwgY29udGVudDpcIkR5bmFtaWMgSXRlbSAxXCIsIGRpc2FibGVkOiB0cnVlIH1cbiAgICAgIF07XG5cbiAgICAgICRzY29wZS5hbGVydE1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYWxlcnQoXCJZb3UndmUgc2VsZWN0ZWQgdGhlIGFsZXJ0IHRhYiFcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuICA8L2ZpbGU+XG48L2V4YW1wbGU+XG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiSGVhZGluZ1xuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuIEhUTUwgaGVhZGluZyBmb3IgYSB7QGxpbmsgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYiB0YWJ9LiBNdXN0IGJlIHBsYWNlZCBhcyBhIGNoaWxkIG9mIGEgdGFiIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDx1aWItdGFic2V0PlxuICAgICAgPHVpYi10YWI+XG4gICAgICAgIDx1aWItdGFiLWhlYWRpbmc+PGI+SFRNTDwvYj4gaW4gbXkgdGl0bGVzPyE8L3RhYi1oZWFkaW5nPlxuICAgICAgICBBbmQgc29tZSBjb250ZW50LCB0b28hXG4gICAgICA8L3VpYi10YWI+XG4gICAgICA8dWliLXRhYj5cbiAgICAgICAgPHVpYi10YWItaGVhZGluZz48aSBjbGFzcz1cImljb24taGVhcnRcIj48L2k+IEljb24gaGVhZGluZz8hPzwvdGFiLWhlYWRpbmc+XG4gICAgICAgIFRoYXQncyByaWdodC5cbiAgICAgIDwvdWliLXRhYj5cbiAgICA8L3VpYi10YWJzZXQ+XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndWliVGFiJywgWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXnVpYlRhYnNldCcsXG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFiLmh0bWwnLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgc2NvcGU6IHtcbiAgICAgIGFjdGl2ZTogJz0/JyxcbiAgICAgIGhlYWRpbmc6ICdAJyxcbiAgICAgIG9uU2VsZWN0OiAnJnNlbGVjdCcsIC8vVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgaW4gY29udGVudEhlYWRpbmdUcmFuc2NsdWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25jZSBpdCBpbnNlcnRzIHRoZSB0YWIncyBjb250ZW50IGludG8gdGhlIGRvbVxuICAgICAgb25EZXNlbGVjdDogJyZkZXNlbGVjdCdcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgLy9FbXB0eSBjb250cm9sbGVyIHNvIG90aGVyIGRpcmVjdGl2ZXMgY2FuIHJlcXVpcmUgYmVpbmcgJ3VuZGVyJyBhIHRhYlxuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICB0YWJzZXRDdHJsLnNlbGVjdChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGF0dHJzLmRpc2FibGUpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLmRpc2FibGUpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHNjb3BlLmRpc2FibGVkID0gISEgdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzY29wZS5kaXNhYmxlZCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGFic2V0Q3RybC5yZW1vdmVUYWIoc2NvcGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vV2UgbmVlZCB0byB0cmFuc2NsdWRlIGxhdGVyLCBvbmNlIHRoZSBjb250ZW50IGNvbnRhaW5lciBpcyByZWFkeS5cbiAgICAgIC8vd2hlbiB0aGlzIGxpbmsgaGFwcGVucywgd2UncmUgaW5zaWRlIGEgdGFiIGhlYWRpbmcuXG4gICAgICBzY29wZS4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliVGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6IFsnP151aWJUYWInLCAnP150YWInXSwgLy8gVE9ETzogY2hhbmdlIHRvICdedWliVGFiJyBhZnRlciBkZXByZWNhdGlvbiByZW1vdmFsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSkge1xuICAgICAgc2NvcGUuJHdhdGNoKCdoZWFkaW5nRWxlbWVudCcsIGZ1bmN0aW9uIHVwZGF0ZUhlYWRpbmdFbGVtZW50KGhlYWRpbmcpIHtcbiAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICBlbG0uaHRtbCgnJyk7XG4gICAgICAgICAgZWxtLmFwcGVuZChoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliVGFiQ29udGVudFRyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6IFsnP151aWJUYWJzZXQnLCAnP150YWJzZXQnXSwgLy8gVE9ETzogY2hhbmdlIHRvICdedWliVGFic2V0JyBhZnRlciBkZXByZWNhdGlvbiByZW1vdmFsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMpIHtcbiAgICAgIHZhciB0YWIgPSBzY29wZS4kZXZhbChhdHRycy51aWJUYWJDb250ZW50VHJhbnNjbHVkZSk7XG5cbiAgICAgIC8vTm93IG91ciB0YWIgaXMgcmVhZHkgdG8gYmUgdHJhbnNjbHVkZWQ6IGJvdGggdGhlIHRhYiBoZWFkaW5nIGFyZWFcbiAgICAgIC8vYW5kIHRoZSB0YWIgY29udGVudCBhcmVhIGFyZSBsb2FkZWQuICBUcmFuc2NsdWRlICdlbSBib3RoLlxuICAgICAgdGFiLiR0cmFuc2NsdWRlRm4odGFiLiRwYXJlbnQsIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChpc1RhYkhlYWRpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vTGV0IHRhYkhlYWRpbmdUcmFuc2NsdWRlIGtub3cuXG4gICAgICAgICAgICB0YWIuaGVhZGluZ0VsZW1lbnQgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbG0uYXBwZW5kKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNUYWJIZWFkaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIChcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCd0YWItaGVhZGluZycpIHx8IC8vIFRPRE86IHJlbW92ZSBhZnRlciBkZXByZWNhdGlvbiByZW1vdmFsXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10YWItaGVhZGluZycpIHx8IC8vIFRPRE86IHJlbW92ZSBhZnRlciBkZXByZWNhdGlvbiByZW1vdmFsXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgneC10YWItaGVhZGluZycpIHx8IC8vIFRPRE86IHJlbW92ZSBhZnRlciBkZXByZWNhdGlvbiByZW1vdmFsXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgndWliLXRhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXVpYi10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgneC11aWItdGFiLWhlYWRpbmcnKSB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWItaGVhZGluZycgfHwgLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGRlcHJlY2F0aW9uIHJlbW92YWxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGF0YS10YWItaGVhZGluZycgfHwgLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGRlcHJlY2F0aW9uIHJlbW92YWxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC10YWItaGVhZGluZycgfHwgLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGRlcHJlY2F0aW9uIHJlbW92YWxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWliLXRhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRhLXVpYi10YWItaGVhZGluZycgfHxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC11aWItdGFiLWhlYWRpbmcnXG4gICAgKTtcbiAgfVxufSk7XG5cbi8qIGRlcHJlY2F0ZWQgdGFicyBiZWxvdyAqL1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRhYnMnKVxuXG4gIC52YWx1ZSgnJHRhYnNTdXBwcmVzc1dhcm5pbmcnLCBmYWxzZSlcblxuICAuY29udHJvbGxlcignVGFic2V0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRjb250cm9sbGVyJywgJyRsb2cnLCAnJHRhYnNTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkc2NvcGUsICRjb250cm9sbGVyLCAkbG9nLCAkdGFic1N1cHByZXNzV2FybmluZykge1xuICAgIGlmICghJHRhYnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICRsb2cud2FybignVGFic2V0Q29udHJvbGxlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIFVpYlRhYnNldENvbnRyb2xsZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBhbmd1bGFyLmV4dGVuZCh0aGlzLCAkY29udHJvbGxlcignVWliVGFic2V0Q29udHJvbGxlcicsIHtcbiAgICAgICRzY29wZTogJHNjb3BlXG4gICAgfSkpO1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCd0YWJzZXQnLCBbJyRsb2cnLCAnJHRhYnNTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkdGFic1N1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgdHlwZTogJ0AnXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlcjogJ1RhYnNldENvbnRyb2xsZXInLFxuICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuXG4gICAgICAgIGlmICghJHRhYnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ3RhYnNldCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10YWJzZXQgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZS52ZXJ0aWNhbCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnZlcnRpY2FsKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMudmVydGljYWwpIDogZmFsc2U7XG4gICAgICAgIHNjb3BlLmp1c3RpZmllZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmp1c3RpZmllZCkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmp1c3RpZmllZCkgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCd0YWInLCBbJyRwYXJzZScsICckbG9nJywgJyR0YWJzU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJHBhcnNlLCAkbG9nLCAkdGFic1N1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlOiAnXnRhYnNldCcsXG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFiLmh0bWwnLFxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGFjdGl2ZTogJz0/JyxcbiAgICAgICAgaGVhZGluZzogJ0AnLFxuICAgICAgICBvblNlbGVjdDogJyZzZWxlY3QnLCAvL1RoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGluIGNvbnRlbnRIZWFkaW5nVHJhbnNjbHVkZVxuICAgICAgICAvL29uY2UgaXQgaW5zZXJ0cyB0aGUgdGFiJ3MgY29udGVudCBpbnRvIHRoZSBkb21cbiAgICAgICAgb25EZXNlbGVjdDogJyZkZXNlbGVjdCdcbiAgICAgIH0sXG4gICAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9FbXB0eSBjb250cm9sbGVyIHNvIG90aGVyIGRpcmVjdGl2ZXMgY2FuIHJlcXVpcmUgYmVpbmcgJ3VuZGVyJyBhIHRhYlxuICAgICAgfSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzLCB0YWJzZXRDdHJsLCB0cmFuc2NsdWRlKSB7XG4gICAgICAgIGlmICghJHRhYnNTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ3RhYiBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10YWIgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgdGFic2V0Q3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGUpIHtcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzY29wZS5kaXNhYmxlZCA9ICEhdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXNjb3BlLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBzY29wZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0YWJzZXRDdHJsLmFkZFRhYihzY29wZSk7XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0YWJzZXRDdHJsLnJlbW92ZVRhYihzY29wZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vV2UgbmVlZCB0byB0cmFuc2NsdWRlIGxhdGVyLCBvbmNlIHRoZSBjb250ZW50IGNvbnRhaW5lciBpcyByZWFkeS5cbiAgICAgICAgLy93aGVuIHRoaXMgbGluayBoYXBwZW5zLCB3ZSdyZSBpbnNpZGUgYSB0YWIgaGVhZGluZy5cbiAgICAgICAgc2NvcGUuJHRyYW5zY2x1ZGVGbiA9IHRyYW5zY2x1ZGU7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgndGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBbJyRsb2cnLCAnJHRhYnNTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkdGFic1N1cHByZXNzV2FybmluZykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogJ150YWInLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSkge1xuICAgICAgICBpZiAoISR0YWJzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCd0YWItaGVhZGluZy10cmFuc2NsdWRlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXRhYi1oZWFkaW5nLXRyYW5zY2x1ZGUgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaGVhZGluZ0VsZW1lbnQnLCBmdW5jdGlvbiB1cGRhdGVIZWFkaW5nRWxlbWVudChoZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICAgIGVsbS5odG1sKCcnKTtcbiAgICAgICAgICAgIGVsbS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAuZGlyZWN0aXZlKCd0YWJDb250ZW50VHJhbnNjbHVkZScsIFsnJGxvZycsICckdGFic1N1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRsb2csICR0YWJzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiAnXnRhYnNldCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycykge1xuICAgICAgICBpZiAoISR0YWJzU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCd0YWItY29udGVudC10cmFuc2NsdWRlIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXRhYi1jb250ZW50LXRyYW5zY2x1ZGUgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YWIgPSBzY29wZS4kZXZhbChhdHRycy50YWJDb250ZW50VHJhbnNjbHVkZSk7XG5cbiAgICAgICAgLy9Ob3cgb3VyIHRhYiBpcyByZWFkeSB0byBiZSB0cmFuc2NsdWRlZDogYm90aCB0aGUgdGFiIGhlYWRpbmcgYXJlYVxuICAgICAgICAvL2FuZCB0aGUgdGFiIGNvbnRlbnQgYXJlYSBhcmUgbG9hZGVkLiAgVHJhbnNjbHVkZSAnZW0gYm90aC5cbiAgICAgICAgdGFiLiR0cmFuc2NsdWRlRm4odGFiLiRwYXJlbnQsIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAoaXNUYWJIZWFkaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vTGV0IHRhYkhlYWRpbmdUcmFuc2NsdWRlIGtub3cuXG4gICAgICAgICAgICAgIHRhYi5oZWFkaW5nRWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZWxtLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzVGFiSGVhZGluZyhub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIChcbiAgICAgICAgICBub2RlLmhhc0F0dHJpYnV0ZSgndGFiLWhlYWRpbmcnKSB8fFxuICAgICAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXRhYi1oZWFkaW5nJykgfHxcbiAgICAgICAgICBub2RlLmhhc0F0dHJpYnV0ZSgneC10YWItaGVhZGluZycpIHx8XG4gICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWItaGVhZGluZycgfHxcbiAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGEtdGFiLWhlYWRpbmcnIHx8XG4gICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd4LXRhYi1oZWFkaW5nJ1xuICAgICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInLCBbXSlcblxuLmNvbnN0YW50KCd1aWJUaW1lcGlja2VyQ29uZmlnJywge1xuICBob3VyU3RlcDogMSxcbiAgbWludXRlU3RlcDogMSxcbiAgc2hvd01lcmlkaWFuOiB0cnVlLFxuICBtZXJpZGlhbnM6IG51bGwsXG4gIHJlYWRvbmx5SW5wdXQ6IGZhbHNlLFxuICBtb3VzZXdoZWVsOiB0cnVlLFxuICBhcnJvd2tleXM6IHRydWUsXG4gIHNob3dTcGlubmVyczogdHJ1ZVxufSlcblxuLmNvbnRyb2xsZXIoJ1VpYlRpbWVwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRwYXJzZScsICckbG9nJywgJyRsb2NhbGUnLCAndWliVGltZXBpY2tlckNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHBhcnNlLCAkbG9nLCAkbG9jYWxlLCB0aW1lcGlja2VyQ29uZmlnKSB7XG4gIHZhciBzZWxlY3RlZCA9IG5ldyBEYXRlKCksXG4gICAgICBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sIC8vIG51bGxNb2RlbEN0cmxcbiAgICAgIG1lcmlkaWFucyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tZXJpZGlhbnMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1lcmlkaWFucykgOiB0aW1lcGlja2VyQ29uZmlnLm1lcmlkaWFucyB8fCAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuQU1QTVM7XG5cbiAgJHNjb3BlLnRhYmluZGV4ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnRhYmluZGV4KSA/ICRhdHRycy50YWJpbmRleCA6IDA7XG4gICRlbGVtZW50LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBpbnB1dHMpIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gdGhpcy5yZW5kZXI7XG5cbiAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy51bnNoaWZ0KGZ1bmN0aW9uKG1vZGVsVmFsdWUpIHtcbiAgICAgIHJldHVybiBtb2RlbFZhbHVlID8gbmV3IERhdGUobW9kZWxWYWx1ZSkgOiBudWxsO1xuICAgIH0pO1xuXG4gICAgdmFyIGhvdXJzSW5wdXRFbCA9IGlucHV0cy5lcSgwKSxcbiAgICAgICAgbWludXRlc0lucHV0RWwgPSBpbnB1dHMuZXEoMSk7XG5cbiAgICB2YXIgbW91c2V3aGVlbCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tb3VzZXdoZWVsKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tb3VzZXdoZWVsKSA6IHRpbWVwaWNrZXJDb25maWcubW91c2V3aGVlbDtcbiAgICBpZiAobW91c2V3aGVlbCkge1xuICAgICAgdGhpcy5zZXR1cE1vdXNld2hlZWxFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCk7XG4gICAgfVxuXG4gICAgdmFyIGFycm93a2V5cyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hcnJvd2tleXMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFycm93a2V5cykgOiB0aW1lcGlja2VyQ29uZmlnLmFycm93a2V5cztcbiAgICBpZiAoYXJyb3drZXlzKSB7XG4gICAgICB0aGlzLnNldHVwQXJyb3drZXlFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCk7XG4gICAgfVxuXG4gICAgJHNjb3BlLnJlYWRvbmx5SW5wdXQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmVhZG9ubHlJbnB1dCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmVhZG9ubHlJbnB1dCkgOiB0aW1lcGlja2VyQ29uZmlnLnJlYWRvbmx5SW5wdXQ7XG4gICAgdGhpcy5zZXR1cElucHV0RXZlbnRzKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpO1xuICB9O1xuXG4gIHZhciBob3VyU3RlcCA9IHRpbWVwaWNrZXJDb25maWcuaG91clN0ZXA7XG4gIGlmICgkYXR0cnMuaG91clN0ZXApIHtcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5ob3VyU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBob3VyU3RlcCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbWludXRlU3RlcCA9IHRpbWVwaWNrZXJDb25maWcubWludXRlU3RlcDtcbiAgaWYgKCRhdHRycy5taW51dGVTdGVwKSB7XG4gICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWludXRlU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBtaW51dGVTdGVwID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtaW47XG4gICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbiksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgIG1pbiA9IGlzTmFOKGR0KSA/IHVuZGVmaW5lZCA6IGR0O1xuICB9KTtcblxuICB2YXIgbWF4O1xuICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5tYXgpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBtYXggPSBpc05hTihkdCkgPyB1bmRlZmluZWQgOiBkdDtcbiAgfSk7XG5cbiAgJHNjb3BlLm5vSW5jcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5jcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIGhvdXJTdGVwICogNjApO1xuICAgIHJldHVybiBpbmNyZW1lbnRlZFNlbGVjdGVkID4gbWF4IHx8XG4gICAgICAoaW5jcmVtZW50ZWRTZWxlY3RlZCA8IHNlbGVjdGVkICYmIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4pO1xuICB9O1xuXG4gICRzY29wZS5ub0RlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCAtaG91clN0ZXAgKiA2MCk7XG4gICAgcmV0dXJuIGRlY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4gfHxcbiAgICAgIChkZWNyZW1lbnRlZFNlbGVjdGVkID4gc2VsZWN0ZWQgJiYgZGVjcmVtZW50ZWRTZWxlY3RlZCA+IG1heCk7XG4gIH07XG5cbiAgJHNjb3BlLm5vSW5jcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgbWludXRlU3RlcCk7XG4gICAgcmV0dXJuIGluY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXggfHxcbiAgICAgIChpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbik7XG4gIH07XG5cbiAgJHNjb3BlLm5vRGVjcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgLW1pbnV0ZVN0ZXApO1xuICAgIHJldHVybiBkZWNyZW1lbnRlZFNlbGVjdGVkIDwgbWluIHx8XG4gICAgICAoZGVjcmVtZW50ZWRTZWxlY3RlZCA+IHNlbGVjdGVkICYmIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXgpO1xuICB9O1xuXG4gICRzY29wZS5ub1RvZ2dsZU1lcmlkaWFuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMykge1xuICAgICAgcmV0dXJuIGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIDEyICogNjApID4gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkTWludXRlcyhzZWxlY3RlZCwgLTEyICogNjApIDwgbWluO1xuICAgIH1cbiAgfTtcblxuICAvLyAxMkggLyAyNEggbW9kZVxuICAkc2NvcGUuc2hvd01lcmlkaWFuID0gdGltZXBpY2tlckNvbmZpZy5zaG93TWVyaWRpYW47XG4gIGlmICgkYXR0cnMuc2hvd01lcmlkaWFuKSB7XG4gICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuc2hvd01lcmlkaWFuKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICRzY29wZS5zaG93TWVyaWRpYW4gPSAhIXZhbHVlO1xuXG4gICAgICBpZiAobmdNb2RlbEN0cmwuJGVycm9yLnRpbWUpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgZnJvbSB0ZW1wbGF0ZVxuICAgICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLCBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpKSB7XG4gICAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoaG91cnMpO1xuICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdldCAkc2NvcGUuaG91cnMgaW4gMjRIIG1vZGUgaWYgdmFsaWRcbiAgZnVuY3Rpb24gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKSB7XG4gICAgdmFyIGhvdXJzID0gcGFyc2VJbnQoJHNjb3BlLmhvdXJzLCAxMCk7XG4gICAgdmFyIHZhbGlkID0gJHNjb3BlLnNob3dNZXJpZGlhbiA/IChob3VycyA+IDAgJiYgaG91cnMgPCAxMykgOiAoaG91cnMgPj0gMCAmJiBob3VycyA8IDI0KTtcbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgkc2NvcGUuc2hvd01lcmlkaWFuKSB7XG4gICAgICBpZiAoaG91cnMgPT09IDEyKSB7XG4gICAgICAgIGhvdXJzID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICgkc2NvcGUubWVyaWRpYW4gPT09IG1lcmlkaWFuc1sxXSkge1xuICAgICAgICBob3VycyA9IGhvdXJzICsgMTI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBob3VycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKSB7XG4gICAgdmFyIG1pbnV0ZXMgPSBwYXJzZUludCgkc2NvcGUubWludXRlcywgMTApO1xuICAgIHJldHVybiAobWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPCA2MCkgPyBtaW51dGVzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFkKHZhbHVlKSB7XG4gICAgcmV0dXJuIChhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCAyKSA/ICcwJyArIHZhbHVlIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIFJlc3BvbmQgb24gbW91c2V3aGVlbCBzcGluXG4gIHRoaXMuc2V0dXBNb3VzZXdoZWVsRXZlbnRzID0gZnVuY3Rpb24oaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCkge1xuICAgIHZhciBpc1Njcm9sbGluZ1VwID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkge1xuICAgICAgICBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgfVxuICAgICAgLy9waWNrIGNvcnJlY3QgZGVsdGEgdmFyaWFibGUgZGVwZW5kaW5nIG9uIGV2ZW50XG4gICAgICB2YXIgZGVsdGEgPSAoZS53aGVlbERlbHRhKSA/IGUud2hlZWxEZWx0YSA6IC1lLmRlbHRhWTtcbiAgICAgIHJldHVybiAoZS5kZXRhaWwgfHwgZGVsdGEgPiAwKTtcbiAgICB9O1xuXG4gICAgaG91cnNJbnB1dEVsLmJpbmQoJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50SG91cnMoKSA6ICRzY29wZS5kZWNyZW1lbnRIb3VycygpKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50TWludXRlcygpIDogJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMoKSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgfTtcblxuICAvLyBSZXNwb25kIG9uIHVwL2Rvd24gYXJyb3drZXlzXG4gIHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwpIHtcbiAgICBob3Vyc0lucHV0RWwuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLndoaWNoID09PSAzOCkgeyAvLyB1cFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICRzY29wZS5pbmNyZW1lbnRIb3VycygpO1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkc2NvcGUuZGVjcmVtZW50SG91cnMoKTtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWludXRlc0lucHV0RWwuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLndoaWNoID09PSAzOCkgeyAvLyB1cFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICRzY29wZS5pbmNyZW1lbnRNaW51dGVzKCk7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gNDApIHsgLy8gZG93blxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICRzY29wZS5kZWNyZW1lbnRNaW51dGVzKCk7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLnNldHVwSW5wdXRFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsKSB7XG4gICAgaWYgKCRzY29wZS5yZWFkb25seUlucHV0KSB7XG4gICAgICAkc2NvcGUudXBkYXRlSG91cnMgPSBhbmd1bGFyLm5vb3A7XG4gICAgICAkc2NvcGUudXBkYXRlTWludXRlcyA9IGFuZ3VsYXIubm9vcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGludmFsaWRIb3VycywgaW52YWxpZE1pbnV0ZXMpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobnVsbCk7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZEhvdXJzKSkge1xuICAgICAgICAkc2NvcGUuaW52YWxpZEhvdXJzID0gaW52YWxpZEhvdXJzO1xuICAgICAgfVxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRNaW51dGVzKSkge1xuICAgICAgICAkc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSBpbnZhbGlkTWludXRlcztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHNjb3BlLnVwZGF0ZUhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLFxuICAgICAgICBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpKSB7XG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgICAgaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKCdoJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhvdXJzSW5wdXRFbC5iaW5kKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCEkc2NvcGUuaW52YWxpZEhvdXJzICYmICRzY29wZS5ob3VycyA8IDEwKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLmhvdXJzID0gcGFkKCRzY29wZS5ob3Vycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpLFxuICAgICAgICBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChob3VycykpIHtcbiAgICAgICAgc2VsZWN0ZWQuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goJ20nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBtaW51dGVzSW5wdXRFbC5iaW5kKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCEkc2NvcGUuaW52YWxpZE1pbnV0ZXMgJiYgJHNjb3BlLm1pbnV0ZXMgPCAxMCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzY29wZS5taW51dGVzID0gcGFkKCRzY29wZS5taW51dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcblxuICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgJGxvZy5lcnJvcignVGltZXBpY2tlciBkaXJlY3RpdmU6IFwibmctbW9kZWxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgIHNlbGVjdGVkID0gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgICAgJHNjb3BlLmludmFsaWRIb3VycyA9IHRydWU7XG4gICAgICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlVmFsaWQoKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGwgaW50ZXJuYWxseSB3aGVuIHdlIGtub3cgdGhhdCBtb2RlbCBpcyB2YWxpZC5cbiAgZnVuY3Rpb24gcmVmcmVzaChrZXlib2FyZENoYW5nZSkge1xuICAgIG1ha2VWYWxpZCgpO1xuICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobmV3IERhdGUoc2VsZWN0ZWQpKTtcbiAgICB1cGRhdGVUZW1wbGF0ZShrZXlib2FyZENoYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVmFsaWQoKSB7XG4gICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgdHJ1ZSk7XG4gICAgJHNjb3BlLmludmFsaWRIb3VycyA9IGZhbHNlO1xuICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGVtcGxhdGUoa2V5Ym9hcmRDaGFuZ2UpIHtcbiAgICB2YXIgaG91cnMgPSBzZWxlY3RlZC5nZXRIb3VycygpLCBtaW51dGVzID0gc2VsZWN0ZWQuZ2V0TWludXRlcygpO1xuXG4gICAgaWYgKCRzY29wZS5zaG93TWVyaWRpYW4pIHtcbiAgICAgIGhvdXJzID0gKGhvdXJzID09PSAwIHx8IGhvdXJzID09PSAxMikgPyAxMiA6IGhvdXJzICUgMTI7IC8vIENvbnZlcnQgMjQgdG8gMTIgaG91ciBzeXN0ZW1cbiAgICB9XG5cbiAgICAkc2NvcGUuaG91cnMgPSBrZXlib2FyZENoYW5nZSA9PT0gJ2gnID8gaG91cnMgOiBwYWQoaG91cnMpO1xuICAgIGlmIChrZXlib2FyZENoYW5nZSAhPT0gJ20nKSB7XG4gICAgICAkc2NvcGUubWludXRlcyA9IHBhZChtaW51dGVzKTtcbiAgICB9XG4gICAgJHNjb3BlLm1lcmlkaWFuID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gbWVyaWRpYW5zWzBdIDogbWVyaWRpYW5zWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTWludXRlcyhkYXRlLCBtaW51dGVzKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyBtaW51dGVzICogNjAwMDApO1xuICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgbmV3RGF0ZS5zZXRIb3VycyhkdC5nZXRIb3VycygpLCBkdC5nZXRNaW51dGVzKCkpO1xuICAgIHJldHVybiBuZXdEYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTWludXRlc1RvU2VsZWN0ZWQobWludXRlcykge1xuICAgIHNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgbWludXRlcyk7XG4gICAgcmVmcmVzaCgpO1xuICB9XG5cbiAgJHNjb3BlLnNob3dTcGlubmVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zaG93U3Bpbm5lcnMpID9cbiAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc2hvd1NwaW5uZXJzKSA6IHRpbWVwaWNrZXJDb25maWcuc2hvd1NwaW5uZXJzO1xuXG4gICRzY29wZS5pbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vSW5jcmVtZW50SG91cnMoKSkge1xuICAgICAgYWRkTWludXRlc1RvU2VsZWN0ZWQoaG91clN0ZXAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5kZWNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vRGVjcmVtZW50SG91cnMoKSkge1xuICAgICAgYWRkTWludXRlc1RvU2VsZWN0ZWQoLWhvdXJTdGVwICogNjApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuaW5jcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vSW5jcmVtZW50TWludXRlcygpKSB7XG4gICAgICBhZGRNaW51dGVzVG9TZWxlY3RlZChtaW51dGVTdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0RlY3JlbWVudE1pbnV0ZXMoKSkge1xuICAgICAgYWRkTWludXRlc1RvU2VsZWN0ZWQoLW1pbnV0ZVN0ZXApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUudG9nZ2xlTWVyaWRpYW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub1RvZ2dsZU1lcmlkaWFuKCkpIHtcbiAgICAgIGFkZE1pbnV0ZXNUb1NlbGVjdGVkKDEyICogNjAgKiAoc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gMSA6IC0xKSk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRpbWVwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiBbJ3VpYlRpbWVwaWNrZXInLCAnP15uZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYlRpbWVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICd0aW1lcGlja2VyJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWwnO1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIHRpbWVwaWNrZXJDdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XG5cbiAgICAgIGlmIChuZ01vZGVsQ3RybCkge1xuICAgICAgICB0aW1lcGlja2VyQ3RybC5pbml0KG5nTW9kZWxDdHJsLCBlbGVtZW50LmZpbmQoJ2lucHV0JykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG4vKiBEZXByZWNhdGVkIHRpbWVwaWNrZXIgYmVsb3cgKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50aW1lcGlja2VyJylcblxuLnZhbHVlKCckdGltZXBpY2tlclN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuXG4uY29udHJvbGxlcignVGltZXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJGNvbnRyb2xsZXInLCAnJGxvZycsICckdGltZXBpY2tlclN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGNvbnRyb2xsZXIsICRsb2csICR0aW1lcGlja2VyU3VwcHJlc3NXYXJuaW5nKSB7XG4gIGlmICghJHRpbWVwaWNrZXJTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAkbG9nLndhcm4oJ1RpbWVwaWNrZXJDb250cm9sbGVyIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgVWliVGltZXBpY2tlckNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGFuZ3VsYXIuZXh0ZW5kKHRoaXMsICRjb250cm9sbGVyKCdVaWJUaW1lcGlja2VyQ29udHJvbGxlcicsIHtcbiAgICAkc2NvcGU6ICRzY29wZSxcbiAgICAkZWxlbWVudDogJGVsZW1lbnQsXG4gICAgJGF0dHJzOiAkYXR0cnNcbiAgfSkpO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3RpbWVwaWNrZXInLCBbJyRsb2cnLCAnJHRpbWVwaWNrZXJTdXBwcmVzc1dhcm5pbmcnLCBmdW5jdGlvbigkbG9nLCAkdGltZXBpY2tlclN1cHByZXNzV2FybmluZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6IFsndGltZXBpY2tlcicsICc/Xm5nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnVGltZXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ3RpbWVwaWNrZXInLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgc2NvcGU6IHt9LFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbCc7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICBpZiAoISR0aW1lcGlja2VyU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigndGltZXBpY2tlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10aW1lcGlja2VyIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgdGltZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKG5nTW9kZWxDdHJsKSB7XG4gICAgICAgIHRpbWVwaWNrZXJDdHJsLmluaXQobmdNb2RlbEN0cmwsIGVsZW1lbnQuZmluZCgnaW5wdXQnKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJ10pXG5cbi8qKlxuICogQSBoZWxwZXIgc2VydmljZSB0aGF0IGNhbiBwYXJzZSB0eXBlYWhlYWQncyBzeW50YXggKHN0cmluZyBwcm92aWRlZCBieSB1c2VycylcbiAqIEV4dHJhY3RlZCB0byBhIHNlcGFyYXRlIHNlcnZpY2UgZm9yIGVhc2Ugb2YgdW5pdCB0ZXN0aW5nXG4gKi9cbiAgLmZhY3RvcnkoJ3VpYlR5cGVhaGVhZFBhcnNlcicsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgMDAwMDAxMTEwMDAwMDAwMDAwMDAwMjIyMDAwMDAwMDAwMDAwMDAwMDMzMzMzMzMzMzMzMzMzMzAwMDAwMDAwMDAwNDQwMDBcbiAgICB2YXIgVFlQRUFIRUFEX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KSg/Olxccythc1xccysoW1xcc1xcU10rPykpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd1xcZF0qKSlcXHMraW5cXHMrKFtcXHNcXFNdKz8pJC87XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChUWVBFQUhFQURfUkVHRVhQKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHBlY3RlZCB0eXBlYWhlYWQgc3BlY2lmaWNhdGlvbiBpbiBmb3JtIG9mIFwiX21vZGVsVmFsdWVfIChhcyBfbGFiZWxfKT8gZm9yIF9pdGVtXyBpbiBfY29sbGVjdGlvbl9cIicgK1xuICAgICAgICAgICAgICAnIGJ1dCBnb3QgXCInICsgaW5wdXQgKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGl0ZW1OYW1lOiBtYXRjaFszXSxcbiAgICAgICAgICBzb3VyY2U6ICRwYXJzZShtYXRjaFs0XSksXG4gICAgICAgICAgdmlld01hcHBlcjogJHBhcnNlKG1hdGNoWzJdIHx8IG1hdGNoWzFdKSxcbiAgICAgICAgICBtb2RlbE1hcHBlcjogJHBhcnNlKG1hdGNoWzFdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5jb250cm9sbGVyKCdVaWJUeXBlYWhlYWRDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRjb21waWxlJywgJyRwYXJzZScsICckcScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHdpbmRvdycsICckcm9vdFNjb3BlJywgJyR1aWJQb3NpdGlvbicsICd1aWJUeXBlYWhlYWRQYXJzZXInLFxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCAkY29tcGlsZSwgJHBhcnNlLCAkcSwgJHRpbWVvdXQsICRkb2N1bWVudCwgJHdpbmRvdywgJHJvb3RTY29wZSwgJHBvc2l0aW9uLCB0eXBlYWhlYWRQYXJzZXIpIHtcbiAgICB2YXIgSE9UX0tFWVMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xuICAgIHZhciBldmVudERlYm91bmNlVGltZSA9IDIwMDtcbiAgICB2YXIgbW9kZWxDdHJsLCBuZ01vZGVsT3B0aW9ucztcbiAgICAvL1NVUFBPUlRFRCBBVFRSSUJVVEVTIChPUFRJT05TKVxuXG4gICAgLy9taW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICB2YXIgbWluTGVuZ3RoID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRNaW5MZW5ndGgpO1xuICAgIGlmICghbWluTGVuZ3RoICYmIG1pbkxlbmd0aCAhPT0gMCkge1xuICAgICAgbWluTGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICAvL21pbmltYWwgd2FpdCB0aW1lIGFmdGVyIGxhc3QgY2hhcmFjdGVyIHR5cGVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICB2YXIgd2FpdFRpbWUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFdhaXRNcykgfHwgMDtcblxuICAgIC8vc2hvdWxkIGl0IHJlc3RyaWN0IG1vZGVsIHZhbHVlcyB0byB0aGUgb25lcyBzZWxlY3RlZCBmcm9tIHRoZSBwb3B1cCBvbmx5P1xuICAgIHZhciBpc0VkaXRhYmxlID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRFZGl0YWJsZSkgIT09IGZhbHNlO1xuXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XG4gICAgdmFyIGlzTG9hZGluZ1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRMb2FkaW5nKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgLy9hIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gYSBtYXRjaCBpcyBzZWxlY3RlZFxuICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcblxuICAgIC8vc2hvdWxkIGl0IHNlbGVjdCBoaWdobGlnaHRlZCBwb3B1cCB2YWx1ZSB3aGVuIGxvc2luZyBmb2N1cz9cbiAgICB2YXIgaXNTZWxlY3RPbkJsdXIgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpIDogZmFsc2U7XG5cbiAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiB0aGVyZSB3ZXJlIG5vIHJlc3VsdHMgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlZFxuICAgIHZhciBpc05vUmVzdWx0c1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWROb1Jlc3VsdHMpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICB2YXIgaW5wdXRGb3JtYXR0ZXIgPSBhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlciA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcikgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gIGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5KSA6IGZhbHNlO1xuXG4gICAgdmFyIGFwcGVuZFRvRWxlbWVudElkID0gIGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvRWxlbWVudElkIHx8IGZhbHNlO1xuXG4gICAgdmFyIGZvY3VzRmlyc3QgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEZvY3VzRmlyc3QpICE9PSBmYWxzZTtcblxuICAgIC8vSWYgaW5wdXQgbWF0Y2hlcyBhbiBpdGVtIG9mIHRoZSBsaXN0IGV4YWN0bHksIHNlbGVjdCBpdCBhdXRvbWF0aWNhbGx5XG4gICAgdmFyIHNlbGVjdE9uRXhhY3QgPSBhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0ID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0KSA6IGZhbHNlO1xuXG4gICAgLy9JTlRFUk5BTCBWQVJJQUJMRVNcblxuICAgIC8vbW9kZWwgc2V0dGVyIGV4ZWN1dGVkIHVwb24gbWF0Y2ggc2VsZWN0aW9uXG4gICAgdmFyIHBhcnNlZE1vZGVsID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpO1xuICAgIHZhciBpbnZva2VNb2RlbFNldHRlciA9ICRwYXJzZShhdHRycy5uZ01vZGVsICsgJygkJCRwKScpO1xuICAgIHZhciAkc2V0TW9kZWxWYWx1ZSA9IGZ1bmN0aW9uKHNjb3BlLCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihwYXJzZWRNb2RlbChvcmlnaW5hbFNjb3BlKSkgJiZcbiAgICAgICAgbmdNb2RlbE9wdGlvbnMgJiYgbmdNb2RlbE9wdGlvbnMuJG9wdGlvbnMgJiYgbmdNb2RlbE9wdGlvbnMuJG9wdGlvbnMuZ2V0dGVyU2V0dGVyKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VNb2RlbFNldHRlcihzY29wZSwgeyQkJHA6IG5ld1ZhbHVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VkTW9kZWwuYXNzaWduKHNjb3BlLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vZXhwcmVzc2lvbnMgdXNlZCBieSB0eXBlYWhlYWRcbiAgICB2YXIgcGFyc2VyUmVzdWx0ID0gdHlwZWFoZWFkUGFyc2VyLnBhcnNlKGF0dHJzLnVpYlR5cGVhaGVhZCk7XG5cbiAgICB2YXIgaGFzRm9jdXM7XG5cbiAgICAvL1VzZWQgdG8gYXZvaWQgYnVnIGluIGlPUyB3ZWJ2aWV3IHdoZXJlIGlPUyBrZXlib2FyZCBkb2VzIG5vdCBmaXJlXG4gICAgLy9tb3VzZWRvd24gJiBtb3VzZXVwIGV2ZW50c1xuICAgIC8vSXNzdWUgIzM2OTlcbiAgICB2YXIgc2VsZWN0ZWQ7XG5cbiAgICAvL2NyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxuICAgIC8vd2l0aCB0eXBlYWhlYWQtc3BlY2lmaWMgZGF0YSAobWF0Y2hlcywgcXVlcnkgZXRjLilcbiAgICB2YXIgc2NvcGUgPSBvcmlnaW5hbFNjb3BlLiRuZXcoKTtcbiAgICB2YXIgb2ZmRGVzdHJveSA9IG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBzY29wZS4kb24oJyRkZXN0cm95Jywgb2ZmRGVzdHJveSk7XG5cbiAgICAvLyBXQUktQVJJQVxuICAgIHZhciBwb3B1cElkID0gJ3R5cGVhaGVhZC0nICsgc2NvcGUuJGlkICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgIGVsZW1lbnQuYXR0cih7XG4gICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCcsXG4gICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxuICAgICAgJ2FyaWEtb3ducyc6IHBvcHVwSWRcbiAgICB9KTtcblxuICAgIC8vcG9wLXVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IG1hdGNoZXNcbiAgICB2YXIgcG9wVXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItdHlwZWFoZWFkLXBvcHVwPjwvZGl2PicpO1xuICAgIHBvcFVwRWwuYXR0cih7XG4gICAgICBpZDogcG9wdXBJZCxcbiAgICAgIG1hdGNoZXM6ICdtYXRjaGVzJyxcbiAgICAgIGFjdGl2ZTogJ2FjdGl2ZUlkeCcsXG4gICAgICBzZWxlY3Q6ICdzZWxlY3QoYWN0aXZlSWR4KScsXG4gICAgICAnbW92ZS1pbi1wcm9ncmVzcyc6ICdtb3ZlSW5Qcm9ncmVzcycsXG4gICAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICAgIHBvc2l0aW9uOiAncG9zaXRpb24nXG4gICAgfSk7XG4gICAgLy9jdXN0b20gaXRlbSB0ZW1wbGF0ZVxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCkpIHtcbiAgICAgIHBvcFVwRWwuYXR0cigndGVtcGxhdGUtdXJsJywgYXR0cnMudHlwZWFoZWFkVGVtcGxhdGVVcmwpO1xuICAgIH1cblxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRQb3B1cFRlbXBsYXRlVXJsKSkge1xuICAgICAgcG9wVXBFbC5hdHRyKCdwb3B1cC10ZW1wbGF0ZS11cmwnLCBhdHRycy50eXBlYWhlYWRQb3B1cFRlbXBsYXRlVXJsKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzZXRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICBzY29wZS5tYXRjaGVzID0gW107XG4gICAgICBzY29wZS5hY3RpdmVJZHggPSAtMTtcbiAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE1hdGNoSWQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHBvcHVwSWQgKyAnLW9wdGlvbi0nICsgaW5kZXg7XG4gICAgfTtcblxuICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIHNwZWNpZmllZCBtYXRjaCBpcyB0aGUgYWN0aXZlIChwcmUtc2VsZWN0ZWQpIGl0ZW0gaW4gdGhlIGxpc3Qgb3duZWQgYnkgdGhpcyB0eXBlYWhlYWQuXG4gICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgYWRkZWQgb3IgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGBhY3RpdmVJZHhgIGNoYW5nZXMuXG4gICAgc2NvcGUuJHdhdGNoKCdhY3RpdmVJZHgnLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBnZXRNYXRjaElkKGluZGV4KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgaW5wdXRJc0V4YWN0TWF0Y2ggPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gaW5kZXggJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZS50b1VwcGVyQ2FzZSgpID09PSBzY29wZS5tYXRjaGVzW2luZGV4XS5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBnZXRNYXRjaGVzQXN5bmMgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICB2YXIgbG9jYWxzID0geyR2aWV3VmFsdWU6IGlucHV0VmFsdWV9O1xuICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xuICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgJHEud2hlbihwYXJzZXJSZXN1bHQuc291cmNlKG9yaWdpbmFsU2NvcGUsIGxvY2FscykpLnRoZW4oZnVuY3Rpb24obWF0Y2hlcykge1xuICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHNldmVyYWwgYXN5bmMgcXVlcmllcyB3ZXJlIGluIHByb2dyZXNzIGlmIGEgdXNlciB3ZXJlIHR5cGluZyBmYXN0XG4gICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXG4gICAgICAgIHZhciBvbkN1cnJlbnRSZXF1ZXN0ID0gKGlucHV0VmFsdWUgPT09IG1vZGVsQ3RybC4kdmlld1ZhbHVlKTtcbiAgICAgICAgaWYgKG9uQ3VycmVudFJlcXVlc3QgJiYgaGFzRm9jdXMpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IGZvY3VzRmlyc3QgPyAwIDogLTE7XG4gICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBzY29wZS5tYXRjaGVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVsc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0TWF0Y2hJZChpKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXG4gICAgICAgICAgICAgICAgbW9kZWw6IG1hdGNoZXNbaV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnF1ZXJ5ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIC8vcG9zaXRpb24gcG9wLXVwIHdpdGggbWF0Y2hlcyAtIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGl0cyBwb3NpdGlvbiBlYWNoIHRpbWUgd2UgYXJlIG9wZW5pbmcgYSB3aW5kb3dcbiAgICAgICAgICAgIC8vd2l0aCBtYXRjaGVzIGFzIGEgcG9wLXVwIG1pZ2h0IGJlIGFic29sdXRlLXBvc2l0aW9uZWQgYW5kIHBvc2l0aW9uIG9mIGFuIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZCBvbiBhIHBhZ2VcbiAgICAgICAgICAgIC8vZHVlIHRvIG90aGVyIGVsZW1lbnRzIGJlaW5nIHJlbmRlcmVkXG4gICAgICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICAvL1NlbGVjdCB0aGUgc2luZ2xlIHJlbWFpbmluZyBvcHRpb24gaWYgdXNlciBpbnB1dCBtYXRjaGVzXG4gICAgICAgICAgICBpZiAoc2VsZWN0T25FeGFjdCAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dElzRXhhY3RNYXRjaChpbnB1dFZhbHVlLCAwKSkge1xuICAgICAgICAgICAgICBzY29wZS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkN1cnJlbnRSZXF1ZXN0KSB7XG4gICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIGV2ZW50cyBvbmx5IGlmIGFwcGVuZFRvQm9keSBwYXJhbXMgZXhpc3QgLSBwZXJmb3JtYW5jZSBmZWF0dXJlXG4gICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYmluZCgnc2Nyb2xsJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xuICAgIH1cblxuICAgIC8vIERlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXJcbiAgICB2YXIgdGltZW91dEV2ZW50UHJvbWlzZTtcblxuICAgIC8vIERlZmF1bHQgcHJvZ3Jlc3MgdHlwZVxuICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmaXJlUmVjYWxjdWxhdGluZygpIHtcbiAgICAgIGlmICghc2NvcGUubW92ZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBwcmV2aW91cyB0aW1lb3V0XG4gICAgICBpZiAodGltZW91dEV2ZW50UHJvbWlzZSkge1xuICAgICAgICAkdGltZW91dC5jYW5jZWwodGltZW91dEV2ZW50UHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlYm91bmNlZCBleGVjdXRpbmcgcmVjYWxjdWxhdGUgYWZ0ZXIgZXZlbnRzIGZpcmVkXG4gICAgICB0aW1lb3V0RXZlbnRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGlmIHBvcHVwIGlzIHZpc2libGVcbiAgICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH0sIGV2ZW50RGVib3VuY2VUaW1lKTtcbiAgICB9XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNldCBuZXcgdmFsdWVzIHRvIHNjb3BlXG4gICAgLy8gYWZ0ZXIgZGlnZXN0IGxvb3AgaXMgcG9wdXAgaW4gcmlnaHQgcG9zaXRpb25cbiAgICBmdW5jdGlvbiByZWNhbGN1bGF0ZVBvc2l0aW9uKCkge1xuICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgc2NvcGUucG9zaXRpb24udG9wICs9IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG4gICAgfVxuXG4gICAgLy93ZSBuZWVkIHRvIHByb3BhZ2F0ZSB1c2VyJ3MgcXVlcnkgc28gd2UgY2FuIGhpZ2xpZ2h0IG1hdGNoZXNcbiAgICBzY29wZS5xdWVyeSA9IHVuZGVmaW5lZDtcblxuICAgIC8vRGVjbGFyZSB0aGUgdGltZW91dCBwcm9taXNlIHZhciBvdXRzaWRlIHRoZSBmdW5jdGlvbiBzY29wZSBzbyB0aGF0IHN0YWNrZWQgY2FsbHMgY2FuIGJlIGNhbmNlbGxlZCBsYXRlclxuICAgIHZhciB0aW1lb3V0UHJvbWlzZTtcblxuICAgIHZhciBzY2hlZHVsZVNlYXJjaFdpdGhUaW1lb3V0ID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuICAgICAgdGltZW91dFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgfSwgd2FpdFRpbWUpO1xuICAgIH07XG5cbiAgICB2YXIgY2FuY2VsUHJldmlvdXNUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGltZW91dFByb21pc2UpIHtcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVzZXRNYXRjaGVzKCk7XG5cbiAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihhY3RpdmVJZHgpIHtcbiAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIHRoZSAkZGlnZXN0KCkgY3ljbGVcbiAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgIHZhciBtb2RlbCwgaXRlbTtcblxuICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBpdGVtID0gc2NvcGUubWF0Y2hlc1thY3RpdmVJZHhdLm1vZGVsO1xuICAgICAgbW9kZWwgPSBwYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG1vZGVsKTtcbiAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdwYXJzZScsIHRydWUpO1xuXG4gICAgICBvblNlbGVjdENhbGxiYWNrKG9yaWdpbmFsU2NvcGUsIHtcbiAgICAgICAgJGl0ZW06IGl0ZW0sXG4gICAgICAgICRtb2RlbDogbW9kZWwsXG4gICAgICAgICRsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKVxuICAgICAgfSk7XG5cbiAgICAgIHJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICAvL3JldHVybiBmb2N1cyB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBhIG1hdGNoIHdhcyBzZWxlY3RlZCB2aWEgYSBtb3VzZSBjbGljayBldmVudFxuICAgICAgLy8gdXNlIHRpbWVvdXQgdG8gYXZvaWQgJHJvb3RTY29wZTppbnByb2cgZXJyb3JcbiAgICAgIGlmIChzY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRGb2N1c09uU2VsZWN0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IGVsZW1lbnRbMF0uZm9jdXMoKTsgfSwgMCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvL2JpbmQga2V5Ym9hcmQgZXZlbnRzOiBhcnJvd3MgdXAoMzgpIC8gZG93big0MCksIGVudGVyKDEzKSBhbmQgdGFiKDkpLCBlc2MoMjcpXG4gICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvL3R5cGVhaGVhZCBpcyBvcGVuIGFuZCBhbiBcImludGVyZXN0aW5nXCIga2V5IHdhcyBwcmVzc2VkXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgSE9UX0tFWVMuaW5kZXhPZihldnQud2hpY2gpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBzZWxlY3RlZCAoaS5lLiBmb2N1c0ZpcnN0KSBhbmQgZW50ZXIgb3IgdGFiIGlzIGhpdCwgY2xlYXIgdGhlIHJlc3VsdHNcbiAgICAgIGlmIChzY29wZS5hY3RpdmVJZHggPT09IC0xICYmIChldnQud2hpY2ggPT09IDkgfHwgZXZ0LndoaWNoID09PSAxMykpIHtcbiAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGV2dC53aGljaCA9PT0gNDApIHtcbiAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCArIDEpICUgc2NvcGUubWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAzOCkge1xuICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAoc2NvcGUuYWN0aXZlSWR4ID4gMCA/IHNjb3BlLmFjdGl2ZUlkeCA6IHNjb3BlLm1hdGNoZXMubGVuZ3RoKSAtIDE7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAxMyB8fCBldnQud2hpY2ggPT09IDkpIHtcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlbGVtZW50LmJpbmQoJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChpc1NlbGVjdE9uQmx1ciAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAmJiBzY29wZS5hY3RpdmVJZHggIT09IC0xICYmICFzZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBoYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgcmVmZXJlbmNlIHRvIGNsaWNrIGhhbmRsZXIgdG8gdW5iaW5kIGl0LlxuICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvLyBJc3N1ZSAjMzk3M1xuICAgICAgLy8gRmlyZWZveCB0cmVhdHMgcmlnaHQgY2xpY2sgYXMgYSBjbGljayBvbiBkb2N1bWVudFxuICAgICAgaWYgKGVsZW1lbnRbMF0gIT09IGV2dC50YXJnZXQgJiYgZXZ0LndoaWNoICE9PSAzICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcblxuICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcbiAgICAgIGlmIChhcHBlbmRUb0JvZHkgfHwgYXBwZW5kVG9FbGVtZW50SWQpIHtcbiAgICAgICAgJHBvcHVwLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS51bmJpbmQoJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS51bmJpbmQoJ3Njcm9sbCcsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgalF1ZXJ5IGNhY2hlIG1lbW9yeSBsZWFrXG4gICAgICBwb3BVcEVsLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgdmFyICRwb3B1cCA9ICRjb21waWxlKHBvcFVwRWwpKHNjb3BlKTtcblxuICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XG4gICAgfSBlbHNlIGlmIChhcHBlbmRUb0VsZW1lbnRJZCAhPT0gZmFsc2UpIHtcbiAgICAgIGFuZ3VsYXIuZWxlbWVudCgkZG9jdW1lbnRbMF0uZ2V0RWxlbWVudEJ5SWQoYXBwZW5kVG9FbGVtZW50SWQpKS5hcHBlbmQoJHBvcHVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKF9tb2RlbEN0cmwsIF9uZ01vZGVsT3B0aW9ucykge1xuICAgICAgbW9kZWxDdHJsID0gX21vZGVsQ3RybDtcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gX25nTW9kZWxPcHRpb25zO1xuXG4gICAgICAvL3BsdWcgaW50byAkcGFyc2VycyBwaXBlbGluZSB0byBvcGVuIGEgdHlwZWFoZWFkIG9uIHZpZXcgY2hhbmdlcyBpbml0aWF0ZWQgZnJvbSBET01cbiAgICAgIC8vJHBhcnNlcnMga2ljay1pbiBvbiBhbGwgdGhlIGNoYW5nZXMgY29taW5nIGZyb20gdGhlIHZpZXcgYXMgd2VsbCBhcyBtYW51YWxseSB0cmlnZ2VyZWQgYnkgJHNldFZpZXdWYWx1ZVxuICAgICAgbW9kZWxDdHJsLiRwYXJzZXJzLnVuc2hpZnQoZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuICAgICAgICBoYXNGb2N1cyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1pbkxlbmd0aCA9PT0gMCB8fCBpbnB1dFZhbHVlICYmIGlucHV0VmFsdWUubGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgICAgIGlmICh3YWl0VGltZSA+IDApIHtcbiAgICAgICAgICAgIGNhbmNlbFByZXZpb3VzVGltZW91dCgpO1xuICAgICAgICAgICAgc2NoZWR1bGVTZWFyY2hXaXRoVGltZW91dChpbnB1dFZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgIGNhbmNlbFByZXZpb3VzVGltZW91dCgpO1xuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGluIGNhc2UgdXNlciBoYWQgdHlwZWQgc29tZXRoaW5nIHByZXZpb3VzbHkuXG4gICAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2RlbEN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVWaWV3VmFsdWUsIGVtcHR5Vmlld1ZhbHVlO1xuICAgICAgICB2YXIgbG9jYWxzID0ge307XG5cbiAgICAgICAgLy8gVGhlIHZhbGlkaXR5IG1heSBiZSBzZXQgdG8gZmFsc2UgdmlhICRwYXJzZXJzIChzZWUgYWJvdmUpIGlmXG4gICAgICAgIC8vIHRoZSBtb2RlbCBpcyByZXN0cmljdGVkIHRvIHNlbGVjdGVkIHZhbHVlcy4gSWYgdGhlIG1vZGVsXG4gICAgICAgIC8vIGlzIHNldCBtYW51YWxseSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIHZhbGlkLlxuICAgICAgICBpZiAoIWlzRWRpdGFibGUpIHtcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgbG9jYWxzLiRtb2RlbCA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGlucHV0Rm9ybWF0dGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbmZvIHRvIHByb3Blcmx5IHJlbmRlciBpbnB1dCB2YWx1ZVxuICAgICAgICAgIC8vd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBzaXR1YXRpb24gYW5kIHNpbXBseSByZXR1cm4gbW9kZWwgdmFsdWUgaWYgd2UgY2FuJ3QgYXBwbHkgY3VzdG9tIGZvcm1hdHRpbmdcbiAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgY2FuZGlkYXRlVmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbXB0eVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG5cbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlVmlld1ZhbHVlICE9PSBlbXB0eVZpZXdWYWx1ZSA/IGNhbmRpZGF0ZVZpZXdWYWx1ZSA6IG1vZGVsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYlR5cGVhaGVhZCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sbGVyOiAnVWliVHlwZWFoZWFkQ29udHJvbGxlcicsXG4gICAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnXj9uZ01vZGVsT3B0aW9ucycsICd1aWJUeXBlYWhlYWQnXSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgICBjdHJsc1syXS5pbml0KGN0cmxzWzBdLCBjdHJsc1sxXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuICAuZGlyZWN0aXZlKCd1aWJUeXBlYWhlYWRQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY29wZToge1xuICAgICAgICBtYXRjaGVzOiAnPScsXG4gICAgICAgIHF1ZXJ5OiAnPScsXG4gICAgICAgIGFjdGl2ZTogJz0nLFxuICAgICAgICBwb3NpdGlvbjogJyYnLFxuICAgICAgICBtb3ZlSW5Qcm9ncmVzczogJz0nLFxuICAgICAgICBzZWxlY3Q6ICcmJ1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzLnBvcHVwVGVtcGxhdGVVcmwgfHwgJ3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbCc7XG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHNjb3BlLnRlbXBsYXRlVXJsID0gYXR0cnMudGVtcGxhdGVVcmw7XG5cbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKG1hdGNoSWR4KSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmFjdGl2ZSA9PSBtYXRjaElkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5zZWxlY3RBY3RpdmUgPSBmdW5jdGlvbihtYXRjaElkeCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IG1hdGNoSWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLnNlbGVjdE1hdGNoID0gZnVuY3Rpb24oYWN0aXZlSWR4KSB7XG4gICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6YWN0aXZlSWR4fSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuICAuZGlyZWN0aXZlKCd1aWJUeXBlYWhlYWRNYXRjaCcsIFsnJHRlbXBsYXRlUmVxdWVzdCcsICckY29tcGlsZScsICckcGFyc2UnLCBmdW5jdGlvbigkdGVtcGxhdGVSZXF1ZXN0LCAkY29tcGlsZSwgJHBhcnNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnPScsXG4gICAgICAgIG1hdGNoOiAnPScsXG4gICAgICAgIHF1ZXJ5OiAnPSdcbiAgICAgIH0sXG4gICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgdHBsVXJsID0gJHBhcnNlKGF0dHJzLnRlbXBsYXRlVXJsKShzY29wZS4kcGFyZW50KSB8fCAndGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sJztcbiAgICAgICAgJHRlbXBsYXRlUmVxdWVzdCh0cGxVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKShzY29wZSwgZnVuY3Rpb24oY2xvbmVkRWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChjbG9uZWRFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmZpbHRlcigndWliVHlwZWFoZWFkSGlnaGxpZ2h0JywgWyckc2NlJywgJyRpbmplY3RvcicsICckbG9nJywgZnVuY3Rpb24oJHNjZSwgJGluamVjdG9yLCAkbG9nKSB7XG4gICAgdmFyIGlzU2FuaXRpemVQcmVzZW50O1xuICAgIGlzU2FuaXRpemVQcmVzZW50ID0gJGluamVjdG9yLmhhcygnJHNhbml0aXplJyk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgICAgLy8gUmVnZXg6IGNhcHR1cmUgdGhlIHdob2xlIHF1ZXJ5IHN0cmluZyBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2hcbiAgICAgIC8vIHRoZSByZXN1bHRzLCBmb3IgZXhhbXBsZSBpZiB0aGUgY2FwdHVyZSBpcyBcImFcIiB0aGUgcmVzdWx0IHdpbGwgYmUgXFxhXG4gICAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zSHRtbChtYXRjaEl0ZW0pIHtcbiAgICAgIHJldHVybiAvPC4qPi9nLnRlc3QobWF0Y2hJdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xuICAgICAgaWYgKCFpc1Nhbml0aXplUHJlc2VudCAmJiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSkge1xuICAgICAgICAkbG9nLndhcm4oJ1Vuc2FmZSB1c2Ugb2YgdHlwZWFoZWFkIHBsZWFzZSB1c2UgbmdTYW5pdGl6ZScpOyAvLyBXYXJuIHRoZSB1c2VyIGFib3V0IHRoZSBkYW5nZXJcbiAgICAgIH1cbiAgICAgIG1hdGNoSXRlbSA9IHF1ZXJ5PyAoJycgKyBtYXRjaEl0ZW0pLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSwgJzxzdHJvbmc+JCY8L3N0cm9uZz4nKSA6IG1hdGNoSXRlbTsgLy8gUmVwbGFjZXMgdGhlIGNhcHR1cmUgc3RyaW5nIHdpdGggYSB0aGUgc2FtZSBzdHJpbmcgaW5zaWRlIG9mIGEgXCJzdHJvbmdcIiB0YWdcbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQpIHtcbiAgICAgICAgbWF0Y2hJdGVtID0gJHNjZS50cnVzdEFzSHRtbChtYXRjaEl0ZW0pOyAvLyBJZiAkc2FuaXRpemUgaXMgbm90IHByZXNlbnQgd2UgcGFjayB0aGUgc3RyaW5nIGluIGEgJHNjZSBvYmplY3QgZm9yIHRoZSBuZy1iaW5kLWh0bWwgZGlyZWN0aXZlXG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hJdGVtO1xuICAgIH07XG4gIH1dKTtcblxuLyogRGVwcmVjYXRlZCB0eXBlYWhlYWQgYmVsb3cgKi9cbiAgXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcpXG4gIC52YWx1ZSgnJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZycsIGZhbHNlKVxuICAuc2VydmljZSgndHlwZWFoZWFkUGFyc2VyJywgWyckcGFyc2UnLCAndWliVHlwZWFoZWFkUGFyc2VyJywgJyRsb2cnLCAnJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZycsIGZ1bmN0aW9uKCRwYXJzZSwgdWliVHlwZWFoZWFkUGFyc2VyLCAkbG9nLCAkdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgaWYgKCEkdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAkbG9nLndhcm4oJ3R5cGVhaGVhZFBhcnNlciBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYlR5cGVhaGVhZFBhcnNlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHJldHVybiB1aWJUeXBlYWhlYWRQYXJzZXI7XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZCcsIFsnJGNvbXBpbGUnLCAnJHBhcnNlJywgJyRxJywgJyR0aW1lb3V0JywgJyRkb2N1bWVudCcsICckd2luZG93JywgJyRyb290U2NvcGUnLCAnJHVpYlBvc2l0aW9uJywgJ3R5cGVhaGVhZFBhcnNlcicsICckbG9nJywgJyR0eXBlYWhlYWRTdXBwcmVzc1dhcm5pbmcnLFxuICAgIGZ1bmN0aW9uKCRjb21waWxlLCAkcGFyc2UsICRxLCAkdGltZW91dCwgJGRvY3VtZW50LCAkd2luZG93LCAkcm9vdFNjb3BlLCAkcG9zaXRpb24sIHR5cGVhaGVhZFBhcnNlciwgJGxvZywgJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZykge1xuICAgIHZhciBIT1RfS0VZUyA9IFs5LCAxMywgMjcsIDM4LCA0MF07XG4gICAgdmFyIGV2ZW50RGVib3VuY2VUaW1lID0gMjAwO1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnXj9uZ01vZGVsT3B0aW9ucyddLFxuICAgICAgbGluazogZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICAgIGlmICghJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybigndHlwZWFoZWFkIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXR5cGVhaGVhZCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RlbEN0cmwgPSBjdHJsc1swXTtcbiAgICAgICAgdmFyIG5nTW9kZWxPcHRpb25zID0gY3RybHNbMV07XG4gICAgICAgIC8vU1VQUE9SVEVEIEFUVFJJQlVURVMgKE9QVElPTlMpXG5cbiAgICAgICAgLy9taW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoKTtcbiAgICAgICAgaWYgKCFtaW5MZW5ndGggJiYgbWluTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgbWluTGVuZ3RoID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbWluaW1hbCB3YWl0IHRpbWUgYWZ0ZXIgbGFzdCBjaGFyYWN0ZXIgdHlwZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxuICAgICAgICB2YXIgd2FpdFRpbWUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFdhaXRNcykgfHwgMDtcblxuICAgICAgICAvL3Nob3VsZCBpdCByZXN0cmljdCBtb2RlbCB2YWx1ZXMgdG8gdGhlIG9uZXMgc2VsZWN0ZWQgZnJvbSB0aGUgcG9wdXAgb25seT9cbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEVkaXRhYmxlKSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIHZhciBpc0xvYWRpbmdTZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkTG9hZGluZykuYXNzaWduIHx8IGFuZ3VsYXIubm9vcDtcblxuICAgICAgICAvL2EgY2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBhIG1hdGNoIGlzIHNlbGVjdGVkXG4gICAgICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcblxuICAgICAgICAvL3Nob3VsZCBpdCBzZWxlY3QgaGlnaGxpZ2h0ZWQgcG9wdXAgdmFsdWUgd2hlbiBsb3NpbmcgZm9jdXM/XG4gICAgICAgIHZhciBpc1NlbGVjdE9uQmx1ciA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uQmx1cikgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uQmx1cikgOiBmYWxzZTtcblxuICAgICAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiB0aGVyZSB3ZXJlIG5vIHJlc3VsdHMgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlZFxuICAgICAgICB2YXIgaXNOb1Jlc3VsdHNTZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkTm9SZXN1bHRzKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgICAgIHZhciBpbnB1dEZvcm1hdHRlciA9IGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyID8gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gIGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5KSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBhcHBlbmRUb0VsZW1lbnRJZCA9ICBhdHRycy50eXBlYWhlYWRBcHBlbmRUb0VsZW1lbnRJZCB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgZm9jdXNGaXJzdCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNGaXJzdCkgIT09IGZhbHNlO1xuXG4gICAgICAgIC8vSWYgaW5wdXQgbWF0Y2hlcyBhbiBpdGVtIG9mIHRoZSBsaXN0IGV4YWN0bHksIHNlbGVjdCBpdCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHZhciBzZWxlY3RPbkV4YWN0ID0gYXR0cnMudHlwZWFoZWFkU2VsZWN0T25FeGFjdCA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkU2VsZWN0T25FeGFjdCkgOiBmYWxzZTtcblxuICAgICAgICAvL0lOVEVSTkFMIFZBUklBQkxFU1xuXG4gICAgICAgIC8vbW9kZWwgc2V0dGVyIGV4ZWN1dGVkIHVwb24gbWF0Y2ggc2VsZWN0aW9uXG4gICAgICAgIHZhciBwYXJzZWRNb2RlbCA9ICRwYXJzZShhdHRycy5uZ01vZGVsKTtcbiAgICAgICAgdmFyIGludm9rZU1vZGVsU2V0dGVyID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwgKyAnKCQkJHApJyk7XG4gICAgICAgIHZhciAkc2V0TW9kZWxWYWx1ZSA9IGZ1bmN0aW9uKHNjb3BlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ocGFyc2VkTW9kZWwob3JpZ2luYWxTY29wZSkpICYmXG4gICAgICAgICAgICBuZ01vZGVsT3B0aW9ucyAmJiBuZ01vZGVsT3B0aW9ucy4kb3B0aW9ucyAmJiBuZ01vZGVsT3B0aW9ucy4kb3B0aW9ucy5nZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VNb2RlbFNldHRlcihzY29wZSwgeyQkJHA6IG5ld1ZhbHVlfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRNb2RlbC5hc3NpZ24oc2NvcGUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9leHByZXNzaW9ucyB1c2VkIGJ5IHR5cGVhaGVhZFxuICAgICAgICB2YXIgcGFyc2VyUmVzdWx0ID0gdHlwZWFoZWFkUGFyc2VyLnBhcnNlKGF0dHJzLnR5cGVhaGVhZCk7XG5cbiAgICAgICAgdmFyIGhhc0ZvY3VzO1xuXG4gICAgICAgIC8vVXNlZCB0byBhdm9pZCBidWcgaW4gaU9TIHdlYnZpZXcgd2hlcmUgaU9TIGtleWJvYXJkIGRvZXMgbm90IGZpcmVcbiAgICAgICAgLy9tb3VzZWRvd24gJiBtb3VzZXVwIGV2ZW50c1xuICAgICAgICAvL0lzc3VlICMzNjk5XG4gICAgICAgIHZhciBzZWxlY3RlZDtcblxuICAgICAgICAvL2NyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxuICAgICAgICAvL3dpdGggdHlwZWFoZWFkLXNwZWNpZmljIGRhdGEgKG1hdGNoZXMsIHF1ZXJ5IGV0Yy4pXG4gICAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xuICAgICAgICB2YXIgb2ZmRGVzdHJveSA9IG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICAgIHNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95Jywgb2ZmRGVzdHJveSk7XG5cbiAgICAgICAgLy8gV0FJLUFSSUFcbiAgICAgICAgdmFyIHBvcHVwSWQgPSAndHlwZWFoZWFkLScgKyBzY29wZS4kaWQgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgICAgIGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnLFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgJ2FyaWEtb3ducyc6IHBvcHVwSWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9wb3AtdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgbWF0Y2hlc1xuICAgICAgICB2YXIgcG9wVXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB0eXBlYWhlYWQtcG9wdXA+PC9kaXY+Jyk7XG4gICAgICAgIHBvcFVwRWwuYXR0cih7XG4gICAgICAgICAgaWQ6IHBvcHVwSWQsXG4gICAgICAgICAgbWF0Y2hlczogJ21hdGNoZXMnLFxuICAgICAgICAgIGFjdGl2ZTogJ2FjdGl2ZUlkeCcsXG4gICAgICAgICAgc2VsZWN0OiAnc2VsZWN0KGFjdGl2ZUlkeCknLFxuICAgICAgICAgICdtb3ZlLWluLXByb2dyZXNzJzogJ21vdmVJblByb2dyZXNzJyxcbiAgICAgICAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICAgICAgICBwb3NpdGlvbjogJ3Bvc2l0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy9jdXN0b20gaXRlbSB0ZW1wbGF0ZVxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkVGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgcG9wVXBFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICBwb3BVcEVsLmF0dHIoJ3BvcHVwLXRlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNjb3BlLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAtMTtcbiAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldE1hdGNoSWQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwb3B1cElkICsgJy1vcHRpb24tJyArIGluZGV4O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIHNwZWNpZmllZCBtYXRjaCBpcyB0aGUgYWN0aXZlIChwcmUtc2VsZWN0ZWQpIGl0ZW0gaW4gdGhlIGxpc3Qgb3duZWQgYnkgdGhpcyB0eXBlYWhlYWQuXG4gICAgICAgIC8vIFRoaXMgYXR0cmlidXRlIGlzIGFkZGVkIG9yIHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBgYWN0aXZlSWR4YCBjaGFuZ2VzLlxuICAgICAgICBzY29wZS4kd2F0Y2goJ2FjdGl2ZUlkeCcsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBnZXRNYXRjaElkKGluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5wdXRJc0V4YWN0TWF0Y2ggPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA+IGluZGV4ICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlLnRvVXBwZXJDYXNlKCkgPT09IHNjb3BlLm1hdGNoZXNbaW5kZXhdLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRNYXRjaGVzQXN5bmMgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxvY2FscyA9IHskdmlld1ZhbHVlOiBpbnB1dFZhbHVlfTtcbiAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICRxLndoZW4ocGFyc2VyUmVzdWx0LnNvdXJjZShvcmlnaW5hbFNjb3BlLCBsb2NhbHMpKS50aGVuKGZ1bmN0aW9uKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgc2V2ZXJhbCBhc3luYyBxdWVyaWVzIHdlcmUgaW4gcHJvZ3Jlc3MgaWYgYSB1c2VyIHdlcmUgdHlwaW5nIGZhc3RcbiAgICAgICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXG4gICAgICAgICAgICB2YXIgb25DdXJyZW50UmVxdWVzdCA9IChpbnB1dFZhbHVlID09PSBtb2RlbEN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob25DdXJyZW50UmVxdWVzdCAmJiBoYXNGb2N1cykge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSBmb2N1c0ZpcnN0ID8gMCA6IC0xO1xuICAgICAgICAgICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzY29wZS5tYXRjaGVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybSBsYWJlbHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLm1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBnZXRNYXRjaElkKGkpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtYXRjaGVzW2ldXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY29wZS5xdWVyeSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICAgICAgLy9wb3NpdGlvbiBwb3AtdXAgd2l0aCBtYXRjaGVzIC0gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgaXRzIHBvc2l0aW9uIGVhY2ggdGltZSB3ZSBhcmUgb3BlbmluZyBhIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vd2l0aCBtYXRjaGVzIGFzIGEgcG9wLXVwIG1pZ2h0IGJlIGFic29sdXRlLXBvc2l0aW9uZWQgYW5kIHBvc2l0aW9uIG9mIGFuIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZCBvbiBhIHBhZ2VcbiAgICAgICAgICAgICAgICAvL2R1ZSB0byBvdGhlciBlbGVtZW50cyBiZWluZyByZW5kZXJlZFxuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy9TZWxlY3QgdGhlIHNpbmdsZSByZW1haW5pbmcgb3B0aW9uIGlmIHVzZXIgaW5wdXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RPbkV4YWN0ICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoID09PSAxICYmIGlucHV0SXNFeGFjdE1hdGNoKGlucHV0VmFsdWUsIDApKSB7XG4gICAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3QoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25DdXJyZW50UmVxdWVzdCkge1xuICAgICAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYmluZCBldmVudHMgb25seSBpZiBhcHBlbmRUb0JvZHkgcGFyYW1zIGV4aXN0IC0gcGVyZm9ybWFuY2UgZmVhdHVyZVxuICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmJpbmQoJ3Njcm9sbCcsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXJcbiAgICAgICAgdmFyIHRpbWVvdXRFdmVudFByb21pc2U7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwcm9ncmVzcyB0eXBlXG4gICAgICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gZmlyZVJlY2FsY3VsYXRpbmcoKSB7XG4gICAgICAgICAgaWYgKCFzY29wZS5tb3ZlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbmNlbCBwcmV2aW91cyB0aW1lb3V0XG4gICAgICAgICAgaWYgKHRpbWVvdXRFdmVudFByb21pc2UpIHtcbiAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0RXZlbnRQcm9taXNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWJvdW5jZWQgZXhlY3V0aW5nIHJlY2FsY3VsYXRlIGFmdGVyIGV2ZW50cyBmaXJlZFxuICAgICAgICAgIHRpbWVvdXRFdmVudFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlmIHBvcHVwIGlzIHZpc2libGVcbiAgICAgICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgfSwgZXZlbnREZWJvdW5jZVRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjYWxjdWxhdGUgYWN0dWFsIHBvc2l0aW9uIGFuZCBzZXQgbmV3IHZhbHVlcyB0byBzY29wZVxuICAgICAgICAvLyBhZnRlciBkaWdlc3QgbG9vcCBpcyBwb3B1cCBpbiByaWdodCBwb3NpdGlvblxuICAgICAgICBmdW5jdGlvbiByZWNhbGN1bGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICAgIHNjb3BlLnBvc2l0aW9uID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcbiAgICAgICAgICBzY29wZS5wb3NpdGlvbi50b3AgKz0gZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBwcm9wYWdhdGUgdXNlcidzIHF1ZXJ5IHNvIHdlIGNhbiBoaWdsaWdodCBtYXRjaGVzXG4gICAgICAgIHNjb3BlLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vRGVjbGFyZSB0aGUgdGltZW91dCBwcm9taXNlIHZhciBvdXRzaWRlIHRoZSBmdW5jdGlvbiBzY29wZSBzbyB0aGF0IHN0YWNrZWQgY2FsbHMgY2FuIGJlIGNhbmNlbGxlZCBsYXRlclxuICAgICAgICB2YXIgdGltZW91dFByb21pc2U7XG5cbiAgICAgICAgdmFyIHNjaGVkdWxlU2VhcmNoV2l0aFRpbWVvdXQgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgdGltZW91dFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdldE1hdGNoZXNBc3luYyhpbnB1dFZhbHVlKTtcbiAgICAgICAgICB9LCB3YWl0VGltZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNhbmNlbFByZXZpb3VzVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aW1lb3V0UHJvbWlzZSkge1xuICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9wbHVnIGludG8gJHBhcnNlcnMgcGlwZWxpbmUgdG8gb3BlbiBhIHR5cGVhaGVhZCBvbiB2aWV3IGNoYW5nZXMgaW5pdGlhdGVkIGZyb20gRE9NXG4gICAgICAgIC8vJHBhcnNlcnMga2ljay1pbiBvbiBhbGwgdGhlIGNoYW5nZXMgY29taW5nIGZyb20gdGhlIHZpZXcgYXMgd2VsbCBhcyBtYW51YWxseSB0cmlnZ2VyZWQgYnkgJHNldFZpZXdWYWx1ZVxuICAgICAgICBtb2RlbEN0cmwuJHBhcnNlcnMudW5zaGlmdChmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgaGFzRm9jdXMgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG1pbkxlbmd0aCA9PT0gMCB8fCBpbnB1dFZhbHVlICYmIGlucHV0VmFsdWUubGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHdhaXRUaW1lID4gMCkge1xuICAgICAgICAgICAgICBjYW5jZWxQcmV2aW91c1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgc2NoZWR1bGVTZWFyY2hXaXRoVGltZW91dChpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdldE1hdGNoZXNBc3luYyhpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhbmNlbFByZXZpb3VzVGltZW91dCgpO1xuICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gUmVzZXQgaW4gY2FzZSB1c2VyIGhhZCB0eXBlZCBzb21ldGhpbmcgcHJldmlvdXNseS5cbiAgICAgICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICB2YXIgY2FuZGlkYXRlVmlld1ZhbHVlLCBlbXB0eVZpZXdWYWx1ZTtcbiAgICAgICAgICB2YXIgbG9jYWxzID0ge307XG5cbiAgICAgICAgICAvLyBUaGUgdmFsaWRpdHkgbWF5IGJlIHNldCB0byBmYWxzZSB2aWEgJHBhcnNlcnMgKHNlZSBhYm92ZSkgaWZcbiAgICAgICAgICAvLyB0aGUgbW9kZWwgaXMgcmVzdHJpY3RlZCB0byBzZWxlY3RlZCB2YWx1ZXMuIElmIHRoZSBtb2RlbFxuICAgICAgICAgIC8vIGlzIHNldCBtYW51YWxseSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIHZhbGlkLlxuICAgICAgICAgIGlmICghaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5wdXRGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIGxvY2Fscy4kbW9kZWwgPSBtb2RlbFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Rm9ybWF0dGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW5mbyB0byBwcm9wZXJseSByZW5kZXIgaW5wdXQgdmFsdWVcbiAgICAgICAgICAgIC8vd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBzaXR1YXRpb24gYW5kIHNpbXBseSByZXR1cm4gbW9kZWwgdmFsdWUgaWYgd2UgY2FuJ3QgYXBwbHkgY3VzdG9tIGZvcm1hdHRpbmdcbiAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVtcHR5Vmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVZpZXdWYWx1ZSAhPT0gZW1wdHlWaWV3VmFsdWUgPyBjYW5kaWRhdGVWaWV3VmFsdWUgOiBtb2RlbFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oYWN0aXZlSWR4KSB7XG4gICAgICAgICAgLy9jYWxsZWQgZnJvbSB3aXRoaW4gdGhlICRkaWdlc3QoKSBjeWNsZVxuICAgICAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgICAgICB2YXIgbW9kZWwsIGl0ZW07XG5cbiAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBpdGVtID0gc2NvcGUubWF0Y2hlc1thY3RpdmVJZHhdLm1vZGVsO1xuICAgICAgICAgIG1vZGVsID0gcGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgJHNldE1vZGVsVmFsdWUob3JpZ2luYWxTY29wZSwgbW9kZWwpO1xuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgncGFyc2UnLCB0cnVlKTtcblxuICAgICAgICAgIG9uU2VsZWN0Q2FsbGJhY2sob3JpZ2luYWxTY29wZSwge1xuICAgICAgICAgICAgJGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAkbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgJGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXNldE1hdGNoZXMoKTtcblxuICAgICAgICAgIC8vcmV0dXJuIGZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIGEgbWF0Y2ggd2FzIHNlbGVjdGVkIHZpYSBhIG1vdXNlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgLy8gdXNlIHRpbWVvdXQgdG8gYXZvaWQgJHJvb3RTY29wZTppbnByb2cgZXJyb3JcbiAgICAgICAgICBpZiAoc2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNPblNlbGVjdCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHsgZWxlbWVudFswXS5mb2N1cygpOyB9LCAwLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vYmluZCBrZXlib2FyZCBldmVudHM6IGFycm93cyB1cCgzOCkgLyBkb3duKDQwKSwgZW50ZXIoMTMpIGFuZCB0YWIoOSksIGVzYygyNylcbiAgICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgLy90eXBlYWhlYWQgaXMgb3BlbiBhbmQgYW4gXCJpbnRlcmVzdGluZ1wiIGtleSB3YXMgcHJlc3NlZFxuICAgICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMCB8fCBIT1RfS0VZUy5pbmRleE9mKGV2dC53aGljaCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBub3RoaW5nIHNlbGVjdGVkIChpLmUuIGZvY3VzRmlyc3QpIGFuZCBlbnRlciBvciB0YWIgaXMgaGl0LCBjbGVhciB0aGUgcmVzdWx0c1xuICAgICAgICAgIGlmIChzY29wZS5hY3RpdmVJZHggPT09IC0xICYmIChldnQud2hpY2ggPT09IDkgfHwgZXZ0LndoaWNoID09PSAxMykpIHtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gNDApIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggKyAxKSAlIHNjb3BlLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAzOCkge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCA+IDAgPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAxMyB8fCBldnQud2hpY2ggPT09IDkpIHtcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDI3KSB7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWxlbWVudC5iaW5kKCdibHVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlzU2VsZWN0T25CbHVyICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICYmIHNjb3BlLmFjdGl2ZUlkeCAhPT0gLTEgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gS2VlcCByZWZlcmVuY2UgdG8gY2xpY2sgaGFuZGxlciB0byB1bmJpbmQgaXQuXG4gICAgICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgLy8gSXNzdWUgIzM5NzNcbiAgICAgICAgICAvLyBGaXJlZm94IHRyZWF0cyByaWdodCBjbGljayBhcyBhIGNsaWNrIG9uIGRvY3VtZW50XG4gICAgICAgICAgaWYgKGVsZW1lbnRbMF0gIT09IGV2dC50YXJnZXQgJiYgZXZ0LndoaWNoICE9PSAzICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5IHx8IGFwcGVuZFRvRWxlbWVudElkKSB7XG4gICAgICAgICAgICAkcG9wdXAucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLnVuYmluZCgncmVzaXplJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xuICAgICAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS51bmJpbmQoJ3Njcm9sbCcsIGZpcmVSZWNhbGN1bGF0aW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJldmVudCBqUXVlcnkgY2FjaGUgbWVtb3J5IGxlYWtcbiAgICAgICAgICBwb3BVcEVsLnJlbW92ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgJHBvcHVwID0gJGNvbXBpbGUocG9wVXBFbCkoc2NvcGUpO1xuXG4gICAgICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCgkcG9wdXApO1xuICAgICAgICB9IGVsc2UgaWYgKGFwcGVuZFRvRWxlbWVudElkICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkZG9jdW1lbnRbMF0uZ2V0RWxlbWVudEJ5SWQoYXBwZW5kVG9FbGVtZW50SWQpKS5hcHBlbmQoJHBvcHVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmFmdGVyKCRwb3B1cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XSlcbiAgXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZFBvcHVwJywgWyckdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nJywgJyRsb2cnLCBmdW5jdGlvbigkdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nLCAkbG9nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG1hdGNoZXM6ICc9JyxcbiAgICAgICAgcXVlcnk6ICc9JyxcbiAgICAgICAgYWN0aXZlOiAnPScsXG4gICAgICAgIHBvc2l0aW9uOiAnJicsXG4gICAgICAgIG1vdmVJblByb2dyZXNzOiAnPScsXG4gICAgICAgIHNlbGVjdDogJyYnXG4gICAgICB9LFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMucG9wdXBUZW1wbGF0ZVVybCB8fCAndGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sJztcbiAgICAgIH0sXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgXG4gICAgICAgIGlmICghJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZykge1xuICAgICAgICAgICRsb2cud2FybigndHlwZWFoZWFkLXBvcHVwIGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliLXR5cGVhaGVhZC1wb3B1cCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLnRlbXBsYXRlVXJsID0gYXR0cnMudGVtcGxhdGVVcmw7XG5cbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKG1hdGNoSWR4KSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmFjdGl2ZSA9PSBtYXRjaElkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5zZWxlY3RBY3RpdmUgPSBmdW5jdGlvbihtYXRjaElkeCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IG1hdGNoSWR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLnNlbGVjdE1hdGNoID0gZnVuY3Rpb24oYWN0aXZlSWR4KSB7XG4gICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6YWN0aXZlSWR4fSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG4gIFxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWRNYXRjaCcsIFsnJHRlbXBsYXRlUmVxdWVzdCcsICckY29tcGlsZScsICckcGFyc2UnLCAnJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZycsICckbG9nJywgZnVuY3Rpb24oJHRlbXBsYXRlUmVxdWVzdCwgJGNvbXBpbGUsICRwYXJzZSwgJHR5cGVhaGVhZFN1cHByZXNzV2FybmluZywgJGxvZykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnPScsXG4gICAgICAgIG1hdGNoOiAnPScsXG4gICAgICAgIHF1ZXJ5OiAnPSdcbiAgICAgIH0sXG4gICAgICBsaW5rOmZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBpZiAoISR0eXBlYWhlYWRTdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICAkbG9nLndhcm4oJ3R5cGVhaGVhZC1tYXRjaCBpcyBub3cgZGVwcmVjYXRlZC4gVXNlIHVpYi10eXBlYWhlYWQtbWF0Y2ggaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cGxVcmwgPSAkcGFyc2UoYXR0cnMudGVtcGxhdGVVcmwpKHNjb3BlLiRwYXJlbnQpIHx8ICd0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWwnO1xuICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHRwbFVybCkudGhlbihmdW5jdGlvbih0cGxDb250ZW50KSB7XG4gICAgICAgICAgJGNvbXBpbGUodHBsQ29udGVudC50cmltKCkpKHNjb3BlLCBmdW5jdGlvbihjbG9uZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlcGxhY2VXaXRoKGNsb25lZEVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcbiAgXG4gIC5maWx0ZXIoJ3R5cGVhaGVhZEhpZ2hsaWdodCcsIFsnJHNjZScsICckaW5qZWN0b3InLCAnJGxvZycsICckdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nJywgZnVuY3Rpb24oJHNjZSwgJGluamVjdG9yLCAkbG9nLCAkdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgdmFyIGlzU2FuaXRpemVQcmVzZW50O1xuICAgIGlzU2FuaXRpemVQcmVzZW50ID0gJGluamVjdG9yLmhhcygnJHNhbml0aXplJyk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgICAgLy8gUmVnZXg6IGNhcHR1cmUgdGhlIHdob2xlIHF1ZXJ5IHN0cmluZyBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2hcbiAgICAgIC8vIHRoZSByZXN1bHRzLCBmb3IgZXhhbXBsZSBpZiB0aGUgY2FwdHVyZSBpcyBcImFcIiB0aGUgcmVzdWx0IHdpbGwgYmUgXFxhXG4gICAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zSHRtbChtYXRjaEl0ZW0pIHtcbiAgICAgIHJldHVybiAvPC4qPi9nLnRlc3QobWF0Y2hJdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xuICAgICAgaWYgKCEkdHlwZWFoZWFkU3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigndHlwZWFoZWFkSGlnaGxpZ2h0IGlzIG5vdyBkZXByZWNhdGVkLiBVc2UgdWliVHlwZWFoZWFkSGlnaGxpZ2h0IGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQgJiYgY29udGFpbnNIdG1sKG1hdGNoSXRlbSkpIHtcbiAgICAgICAgJGxvZy53YXJuKCdVbnNhZmUgdXNlIG9mIHR5cGVhaGVhZCBwbGVhc2UgdXNlIG5nU2FuaXRpemUnKTsgLy8gV2FybiB0aGUgdXNlciBhYm91dCB0aGUgZGFuZ2VyXG4gICAgICB9XG5cbiAgICAgIG1hdGNoSXRlbSA9IHF1ZXJ5PyAoJycgKyBtYXRjaEl0ZW0pLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSwgJzxzdHJvbmc+JCY8L3N0cm9uZz4nKSA6IG1hdGNoSXRlbTsgLy8gUmVwbGFjZXMgdGhlIGNhcHR1cmUgc3RyaW5nIHdpdGggYSB0aGUgc2FtZSBzdHJpbmcgaW5zaWRlIG9mIGEgXCJzdHJvbmdcIiB0YWdcbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQpIHtcbiAgICAgICAgbWF0Y2hJdGVtID0gJHNjZS50cnVzdEFzSHRtbChtYXRjaEl0ZW0pOyAvLyBJZiAkc2FuaXRpemUgaXMgbm90IHByZXNlbnQgd2UgcGFjayB0aGUgc3RyaW5nIGluIGEgJHNjZSBvYmplY3QgZm9yIHRoZSBuZy1iaW5kLWh0bWwgZGlyZWN0aXZlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaEl0ZW07XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicGFuZWwge3twYW5lbENsYXNzIHx8ICdwYW5lbC1kZWZhdWx0J319XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiIG5nLWtleXByZXNzPVxcXCJ0b2dnbGVPcGVuKCRldmVudClcXFwiPlxcblwiICtcbiAgICBcIiAgICA8aDQgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8YSBocmVmIHRhYmluZGV4PVxcXCIwXFxcIiBjbGFzcz1cXFwiYWNjb3JkaW9uLXRvZ2dsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU9wZW4oKVxcXCIgdWliLWFjY29yZGlvbi10cmFuc2NsdWRlPVxcXCJoZWFkaW5nXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwieyd0ZXh0LW11dGVkJzogaXNEaXNhYmxlZH1cXFwiPnt7aGVhZGluZ319PC9zcGFuPjwvYT5cXG5cIiArXG4gICAgXCIgICAgPC9oND5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtY29sbGFwc2UgY29sbGFwc2VcXFwiIHVpYi1jb2xsYXBzZT1cXFwiIWlzT3BlblxcXCI+XFxuXCIgK1xuICAgIFwiXHQgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ncm91cFxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFsZXJ0XFxcIiBuZy1jbGFzcz1cXFwiWydhbGVydC0nICsgKHR5cGUgfHwgJ3dhcm5pbmcnKSwgY2xvc2VhYmxlID8gJ2FsZXJ0LWRpc21pc3NpYmxlJyA6IG51bGxdXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxidXR0b24gbmctc2hvdz1cXFwiY2xvc2VhYmxlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgbmctY2xpY2s9XFxcImNsb3NlKHskZXZlbnQ6ICRldmVudH0pXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9zcGFuPlxcblwiICtcbiAgICBcIiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPkNsb3NlPC9zcGFuPlxcblwiICtcbiAgICBcIiAgICA8L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1tb3VzZWVudGVyPVxcXCJwYXVzZSgpXFxcIiBuZy1tb3VzZWxlYXZlPVxcXCJwbGF5KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbFxcXCIgbmctc3dpcGUtcmlnaHQ9XFxcInByZXYoKVxcXCIgbmctc3dpcGUtbGVmdD1cXFwibmV4dCgpXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImNhcm91c2VsLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGEgcm9sZT1cXFwiYnV0dG9uXFxcIiBocmVmIGNsYXNzPVxcXCJsZWZ0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJwcmV2KClcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9zcGFuPlxcblwiICtcbiAgICBcIiAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+cHJldmlvdXM8L3NwYW4+XFxuXCIgK1xuICAgIFwiICA8L2E+XFxuXCIgK1xuICAgIFwiICA8YSByb2xlPVxcXCJidXR0b25cXFwiIGhyZWYgY2xhc3M9XFxcInJpZ2h0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvc3Bhbj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+XFxuXCIgK1xuICAgIFwiICA8L2E+XFxuXCIgK1xuICAgIFwiICA8b2wgY2xhc3M9XFxcImNhcm91c2VsLWluZGljYXRvcnNcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwic2xpZGUgaW4gc2xpZGVzIHwgb3JkZXJCeTppbmRleE9mU2xpZGUgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwieyBhY3RpdmU6IGlzQWN0aXZlKHNsaWRlKSB9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KHNsaWRlKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnNsaWRlIHt7ICRpbmRleCArIDEgfX0gb2Yge3sgc2xpZGVzLmxlbmd0aCB9fTxzcGFuIG5nLWlmPVxcXCJpc0FjdGl2ZShzbGlkZSlcXFwiPiwgY3VycmVudGx5IGFjdGl2ZTwvc3Bhbj48L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgIDwvbGk+XFxuXCIgK1xuICAgIFwiICA8L29sPlxcblwiICtcbiAgICBcIjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1jbGFzcz1cXFwie1xcblwiICtcbiAgICBcIiAgICAnYWN0aXZlJzogYWN0aXZlXFxuXCIgK1xuICAgIFwiICB9XFxcIiBjbGFzcz1cXFwiaXRlbSB0ZXh0LWNlbnRlclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1zd2l0Y2g9XFxcImRhdGVwaWNrZXJNb2RlXFxcIiByb2xlPVxcXCJhcHBsaWNhdGlvblxcXCIgbmcta2V5ZG93bj1cXFwia2V5ZG93bigkZXZlbnQpXFxcIj5cXG5cIiArXG4gICAgXCIgIDx1aWItZGF5cGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJkYXlcXFwiIHRhYmluZGV4PVxcXCIwXFxcIj48L3VpYi1kYXlwaWNrZXI+XFxuXCIgK1xuICAgIFwiICA8dWliLW1vbnRocGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJtb250aFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvdWliLW1vbnRocGlja2VyPlxcblwiICtcbiAgICBcIiAgPHVpYi15ZWFycGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJ5ZWFyXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC91aWIteWVhcnBpY2tlcj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIixcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6NSArIHNob3dXZWVrc319XFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoIG5nLXJlcGVhdD1cXFwibGFiZWwgaW4gOjpsYWJlbHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxzbWFsbCBhcmlhLWxhYmVsPVxcXCJ7ezo6bGFiZWwuZnVsbH19XFxcIj57ezo6bGFiZWwuYWJicn19PC9zbWFsbD48L3RoPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyIGg2XFxcIj48ZW0+e3sgd2Vla051bWJlcnNbJGluZGV4XSB9fTwvZW0+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3cgdHJhY2sgYnkgZHQuZGF0ZVxcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCIgaWQ9XFxcInt7OjpkdC51aWR9fVxcXCIgbmctY2xhc3M9XFxcIjo6ZHQuY3VzdG9tQ2xhc3NcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHN0eWxlPVxcXCJtaW4td2lkdGg6MTAwJTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIiBuZy1jbGFzcz1cXFwieydidG4taW5mbyc6IGR0LnNlbGVjdGVkLCBhY3RpdmU6IGlzQWN0aXZlKGR0KX1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiIG5nLWRpc2FibGVkPVxcXCJkdC5kaXNhYmxlZFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtbXV0ZWQnOiBkdC5zZWNvbmRhcnksICd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHN0eWxlPVxcXCJ3aWR0aDoxMDAlO1xcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3RoZWFkPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvdyB0cmFjayBieSBkdC5kYXRlXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIiBpZD1cXFwie3s6OmR0LnVpZH19XFxcIiBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xhc3M9XFxcInsnYnRuLWluZm8nOiBkdC5zZWxlY3RlZCwgYWN0aXZlOiBpc0FjdGl2ZShkdCl9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZHQuZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIGRyb3Bkb3duLW5lc3RlZCBuZy1pZj1cXFwiaXNPcGVuXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogYmxvY2tcXFwiIG5nLXN0eWxlPVxcXCJ7dG9wOiBwb3NpdGlvbi50b3ArJ3B4JywgbGVmdDogcG9zaXRpb24ubGVmdCsncHgnfVxcXCIgbmcta2V5ZG93bj1cXFwia2V5ZG93bigkZXZlbnQpXFxcIiBuZy1jbGljaz1cXFwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXFxcIj5cXG5cIiArXG4gICAgXCJcdDxsaSBuZy10cmFuc2NsdWRlPjwvbGk+XFxuXCIgK1xuICAgIFwiXHQ8bGkgbmctaWY9XFxcInNob3dCdXR0b25CYXJcXFwiIHN0eWxlPVxcXCJwYWRkaW5nOjEwcHggOXB4IDJweFxcXCI+XFxuXCIgK1xuICAgIFwiXHRcdDxzcGFuIGNsYXNzPVxcXCJidG4tZ3JvdXAgcHVsbC1sZWZ0XFxcIj5cXG5cIiArXG4gICAgXCJcdFx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWluZm9cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoJ3RvZGF5JylcXFwiIG5nLWRpc2FibGVkPVxcXCJpc0Rpc2FibGVkKCd0b2RheScpXFxcIj57eyBnZXRUZXh0KCdjdXJyZW50JykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdFx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlclxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChudWxsKVxcXCI+e3sgZ2V0VGV4dCgnY2xlYXInKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIlx0XHQ8L3NwYW4+XFxuXCIgK1xuICAgIFwiXHRcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoKVxcXCI+e3sgZ2V0VGV4dCgnY2xvc2UnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIlx0PC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwiM1xcXCI+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHN0eWxlPVxcXCJ3aWR0aDoxMDAlO1xcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3RoZWFkPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvdyB0cmFjayBieSBkdC5kYXRlXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIiBpZD1cXFwie3s6OmR0LnVpZH19XFxcIiBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xhc3M9XFxcInsnYnRuLWluZm8nOiBkdC5zZWxlY3RlZCwgYWN0aXZlOiBpc0FjdGl2ZShkdCl9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZHQuZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIixcbiAgICBcIjxkaXYgdWliLW1vZGFsLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgICAgIG1vZGFsLWluLWNsYXNzPVxcXCJpblxcXCJcXG5cIiArXG4gICAgXCIgICAgIG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDQwICsgKGluZGV4ICYmIDEgfHwgMCkgKyBpbmRleCoxMH1cXFwiXFxuXCIgK1xuICAgIFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXG4gICAgXCI8ZGl2IG1vZGFsLXJlbmRlcj1cXFwie3skaXNSZW5kZXJlZH19XFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgY2xhc3M9XFxcIm1vZGFsXFxcIlxcblwiICtcbiAgICBcIiAgICB1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgICBtb2RhbC1pbi1jbGFzcz1cXFwiaW5cXFwiXFxuXCIgK1xuICAgIFwiICAgIG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDUwICsgaW5kZXgqMTAsIGRpc3BsYXk6ICdibG9jayd9XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nXFxcIiBuZy1jbGFzcz1cXFwic2l6ZSA/ICdtb2RhbC0nICsgc2l6ZSA6ICcnXFxcIj48ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIiB1aWItbW9kYWwtdHJhbnNjbHVkZT48L2Rpdj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcInBhZ2VyXFxcIj5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWQsIHByZXZpb3VzOiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSAtIDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCdwcmV2aW91cycpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZCwgbmV4dDogYWxpZ259XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgKyAxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dCgnbmV4dCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXG4gICAgXCI8dWwgY2xhc3M9XFxcInBhZ2luYXRpb25cXFwiPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLWZpcnN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCdmaXJzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1pZj1cXFwiOjpkaXJlY3Rpb25MaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcHJldlxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoJ3ByZXZpb3VzJyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSxkaXNhYmxlZDogbmdEaXNhYmxlZCYmIXBhZ2UuYWN0aXZlfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcGFnZVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlciwgJGV2ZW50KVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLW5leHRcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiPnt7OjpnZXRUZXh0KCduZXh0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbGFzdFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZSh0b3RhbFBhZ2VzLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dCgnbGFzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB1aWItdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udGVudEV4cCgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdlxcblwiICtcbiAgICBcIiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxuXCIgK1xuICAgIFwiICB1aWItdG9vbHRpcC1jbGFzc2VzXFxuXCIgK1xuICAgIFwiICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXCIsXG4gICAgXCI8ZGl2XFxuXCIgK1xuICAgIFwiICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHVpYi10b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCJcXG5cIiArXG4gICAgXCIgICAgdWliLXRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZT1cXFwiY29udGVudEV4cCgpXFxcIlxcblwiICtcbiAgICBcIiAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLFxuICAgIFwiPGRpdiB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHVpYi10b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidGl0bGVcXFwiIG5nLWlmPVxcXCJ0aXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udGVudEV4cCgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXCIsXG4gICAgXCI8ZGl2IHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgdWliLXRvb2x0aXAtY2xhc3Nlc1xcblwiICtcbiAgICBcIiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctaWY9XFxcInRpdGxlXFxcIj48L2gzPlxcblwiICtcbiAgICBcIiAgICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIHVpYi10b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZS1zY29wZT1cXFwib3JpZ2luU2NvcGUoKVxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFxuICAgIFwiPGRpdiB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXG5cIiArXG4gICAgXCIgIHVpYi10b29sdGlwLWNsYXNzZXNcXG5cIiArXG4gICAgXCIgIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidGl0bGVcXFwiIG5nLWlmPVxcXCJ0aXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDogMDtcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCIgbmctdHJhbnNjbHVkZSBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp0aXRsZX19XFxcIj48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIj5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCIgc3R5bGU9XFxcIm1pbi13aWR0aDogMDtcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCIgbmcta2V5ZG93bj1cXFwib25LZXlkb3duKCRldmVudClcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7cmFuZ2UubGVuZ3RofX1cXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxzcGFuIG5nLXJlcGVhdC1zdGFydD1cXFwiciBpbiByYW5nZSB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj4oe3sgJGluZGV4IDwgdmFsdWUgPyAnKicgOiAnICcgfX0pPC9zcGFuPlxcblwiICtcbiAgICBcIiAgICA8aSBuZy1yZXBlYXQtZW5kIG5nLW1vdXNlZW50ZXI9XFxcImVudGVyKCRpbmRleCArIDEpXFxcIiBuZy1jbGljaz1cXFwicmF0ZSgkaW5kZXggKyAxKVxcXCIgY2xhc3M9XFxcImdseXBoaWNvblxcXCIgbmctY2xhc3M9XFxcIiRpbmRleCA8IHZhbHVlICYmIChyLnN0YXRlT24gfHwgJ2dseXBoaWNvbi1zdGFyJykgfHwgKHIuc3RhdGVPZmYgfHwgJ2dseXBoaWNvbi1zdGFyLWVtcHR5JylcXFwiIG5nLWF0dHItdGl0bGU9XFxcInt7ci50aXRsZX19XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3tyLnRpdGxlfX1cXFwiPjwvaT5cXG5cIiArXG4gICAgXCI8L3NwYW4+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXG4gICAgXCI8bGkgbmctY2xhc3M9XFxcInthY3RpdmU6IGFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3QoKVxcXCIgdWliLXRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxuXCIgK1xuICAgIFwiPC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcbiAgICBcIjxkaXY+XFxuXCIgK1xuICAgIFwiICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYte3t0eXBlIHx8ICd0YWJzJ319XFxcIiBuZy1jbGFzcz1cXFwieyduYXYtc3RhY2tlZCc6IHZlcnRpY2FsLCAnbmF2LWp1c3RpZmllZCc6IGp1c3RpZmllZH1cXFwiIG5nLXRyYW5zY2x1ZGU+PC91bD5cXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIFxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLXJlcGVhdD1cXFwidGFiIGluIHRhYnNcXFwiIFxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiB0YWIuYWN0aXZlfVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICB1aWItdGFiLWNvbnRlbnQtdHJhbnNjbHVkZT1cXFwidGFiXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPC9kaXY+XFxuXCIgK1xuICAgIFwiICA8L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLFxuICAgIFwiPHRhYmxlPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRIb3VycygpXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+Jm5ic3A7PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRNaW51dGVzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRNaW51dGVzKClcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRIb3Vyc31cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHN0eWxlPVxcXCJ3aWR0aDo1MHB4O1xcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcImhvdXJzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZUhvdXJzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD46PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRNaW51dGVzfVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOjUwcHg7XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwibWludXRlc1xcXCIgbmctY2hhbmdlPVxcXCJ1cGRhdGVNaW51dGVzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1RvZ2dsZU1lcmlkaWFuKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IHRleHQtY2VudGVyXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTWVyaWRpYW4oKVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vVG9nZ2xlTWVyaWRpYW4oKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj57e21lcmlkaWFufX08L2J1dHRvbj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkPjxhIG5nLWNsaWNrPVxcXCJkZWNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9EZWNyZW1lbnRIb3VycygpXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudE1pbnV0ZXMoKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXG4gICAgXCI8L3RhYmxlPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcbiAgICBcIjxhIGhyZWYgdGFiaW5kZXg9XFxcIi0xXFxcIiBuZy1iaW5kLWh0bWw9XFxcIm1hdGNoLmxhYmVsIHwgdWliVHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIj48L2E+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLFxuICAgIFwiPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBuZy1zaG93PVxcXCJpc09wZW4oKSAmJiAhbW92ZUluUHJvZ3Jlc3NcXFwiIG5nLXN0eWxlPVxcXCJ7dG9wOiBwb3NpdGlvbigpLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbigpLmxlZnQrJ3B4J31cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBibG9jaztcXFwiIHJvbGU9XFxcImxpc3Rib3hcXFwiIGFyaWEtaGlkZGVuPVxcXCJ7eyFpc09wZW4oKX19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwibWF0Y2ggaW4gbWF0Y2hlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBpc0FjdGl2ZSgkaW5kZXgpIH1cXFwiIG5nLW1vdXNlZW50ZXI9XFxcInNlbGVjdEFjdGl2ZSgkaW5kZXgpXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0TWF0Y2goJGluZGV4KVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBpZD1cXFwie3s6Om1hdGNoLmlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiB1aWItdHlwZWFoZWFkLW1hdGNoIGluZGV4PVxcXCIkaW5kZXhcXFwiIG1hdGNoPVxcXCJtYXRjaFxcXCIgcXVlcnk9XFxcInF1ZXJ5XFxcIiB0ZW1wbGF0ZS11cmw9XFxcInRlbXBsYXRlVXJsXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcbiFhbmd1bGFyLiQkY3NwKCkgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi5uZy1hbmltYXRlLml0ZW06bm90KC5sZWZ0KTpub3QoLnJpZ2h0KXstd2Via2l0LXRyYW5zaXRpb246MHMgZWFzZS1pbi1vdXQgbGVmdDt0cmFuc2l0aW9uOjBzIGVhc2UtaW4tb3V0IGxlZnR9PC9zdHlsZT4nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyIDNcbiAqKi8iLCJyZXF1aXJlKCcuL2FuZ3VsYXItc2FuaXRpemUnKTtcbm1vZHVsZS5leHBvcnRzID0gJ25nU2FuaXRpemUnO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9hbmd1bGFyLXNhbml0aXplL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNSA2IDdcbiAqKi8iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS41LjNcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgQW55IGNvbW1pdHMgdG8gdGhpcyBmaWxlIHNob3VsZCBiZSByZXZpZXdlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuICAqXG4gKiAgIENoYW5nZXMgdG8gdGhpcyBmaWxlIGNhbiBwb3RlbnRpYWxseSBjcmVhdGUgc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzLiAqXG4gKiAgICAgICAgICBBbiBhcHByb3ZhbCBmcm9tIDIgQ29yZSBtZW1iZXJzIHdpdGggaGlzdG9yeSBvZiBtb2RpZnlpbmcgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGZpbGUgaXMgcmVxdWlyZWQuICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgRG9lcyB0aGUgY2hhbmdlIHNvbWVob3cgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkPyAqXG4gKiAgICBPciBhbGxvd3MgZm9yIHNvbWVvbmUgdG8gY2hhbmdlIHRoZSBwcm90b3R5cGUgb2YgYnVpbHQtaW4gb2JqZWN0cz8gICAqXG4gKiAgICAgT3IgZ2l2ZXMgdW5kZXNpcmVkIGFjY2VzcyB0byB2YXJpYWJsZXMgbGlrZXMgZG9jdW1lbnQgb3Igd2luZG93PyAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG52YXIgJHNhbml0aXplTWluRXJyID0gYW5ndWxhci4kJG1pbkVycignJHNhbml0aXplJyk7XG5cbi8qKlxuICogQG5nZG9jIG1vZHVsZVxuICogQG5hbWUgbmdTYW5pdGl6ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ1Nhbml0aXplXG4gKlxuICogVGhlIGBuZ1Nhbml0aXplYCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byBzYW5pdGl6ZSBIVE1MLlxuICpcbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nU2FuaXRpemVcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplIGAkc2FuaXRpemVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHNhbml0aXplXG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogICBTYW5pdGl6ZXMgYW4gaHRtbCBzdHJpbmcgYnkgc3RyaXBwaW5nIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgdG9rZW5zLlxuICpcbiAqICAgVGhlIGlucHV0IGlzIHNhbml0aXplZCBieSBwYXJzaW5nIHRoZSBIVE1MIGludG8gdG9rZW5zLiBBbGwgc2FmZSB0b2tlbnMgKGZyb20gYSB3aGl0ZWxpc3QpIGFyZVxuICogICB0aGVuIHNlcmlhbGl6ZWQgYmFjayB0byBwcm9wZXJseSBlc2NhcGVkIGh0bWwgc3RyaW5nLiBUaGlzIG1lYW5zIHRoYXQgbm8gdW5zYWZlIGlucHV0IGNhbiBtYWtlXG4gKiAgIGl0IGludG8gdGhlIHJldHVybmVkIHN0cmluZy5cbiAqXG4gKiAgIFRoZSB3aGl0ZWxpc3QgZm9yIFVSTCBzYW5pdGl6YXRpb24gb2YgYXR0cmlidXRlIHZhbHVlcyBpcyBjb25maWd1cmVkIHVzaW5nIHRoZSBmdW5jdGlvbnNcbiAqICAgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBhbmQgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgb2Yge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXJcbiAqICAgYCRjb21waWxlUHJvdmlkZXJgfS5cbiAqXG4gKiAgIFRoZSBpbnB1dCBtYXkgYWxzbyBjb250YWluIFNWRyBtYXJrdXAgaWYgdGhpcyBpcyBlbmFibGVkIHZpYSB7QGxpbmsgJHNhbml0aXplUHJvdmlkZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEhUTUwgaW5wdXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYW5pdGl6ZWQgSFRNTC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwic2FuaXRpemVFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItc2FuaXRpemUuanNcIj5cbiAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgIDxzY3JpcHQ+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnc2FuaXRpemVFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRzY2UnLCBmdW5jdGlvbigkc2NvcGUsICRzY2UpIHtcbiAgICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgICAnPHAgc3R5bGU9XCJjb2xvcjpibHVlXCI+YW4gaHRtbFxcbicgK1xuICAgICAgICAgICAgICAgJzxlbSBvbm1vdXNlb3Zlcj1cInRoaXMudGV4dENvbnRlbnQ9XFwnUFdOM0QhXFwnXCI+Y2xpY2sgaGVyZTwvZW0+XFxuJyArXG4gICAgICAgICAgICAgICAnc25pcHBldDwvcD4nO1xuICAgICAgICAgICAgICRzY29wZS5kZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNIdG1sKCRzY29wZS5zbmlwcGV0KTtcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9XSk7XG4gICAgIDwvc2NyaXB0PlxuICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgICBTbmlwcGV0OiA8dGV4dGFyZWEgbmctbW9kZWw9XCJzbmlwcGV0XCIgY29scz1cIjYwXCIgcm93cz1cIjNcIj48L3RleHRhcmVhPlxuICAgICAgIDx0YWJsZT5cbiAgICAgICAgIDx0cj5cbiAgICAgICAgICAgPHRkPkRpcmVjdGl2ZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5Ib3c8L3RkPlxuICAgICAgICAgICA8dGQ+U291cmNlPC90ZD5cbiAgICAgICAgICAgPHRkPlJlbmRlcmVkPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZVwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgdXNlcyAkc2FuaXRpemU8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImJpbmQtaHRtbC13aXRoLXRydXN0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kLWh0bWw8L3RkPlxuICAgICAgICAgICA8dGQ+QnlwYXNzICRzYW5pdGl6ZSBieSBleHBsaWNpdGx5IHRydXN0aW5nIHRoZSBkYW5nZXJvdXMgdmFsdWU8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiJmd0O1xuJmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cImRlbGliZXJhdGVseVRydXN0RGFuZ2Vyb3VzU25pcHBldCgpXCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWRlZmF1bHRcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQ8L3RkPlxuICAgICAgICAgICA8dGQ+QXV0b21hdGljYWxseSBlc2NhcGVzPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxici8+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICAgIDwvZGl2PlxuICAgPC9maWxlPlxuICAgPGZpbGUgbmFtZT1cInByb3RyYWN0b3IuanNcIiB0eXBlPVwicHJvdHJhY3RvclwiPlxuICAgICBpdCgnc2hvdWxkIHNhbml0aXplIHRoZSBodG1sIHNuaXBwZXQgYnkgZGVmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCc8cD5hbiBodG1sXFxuPGVtPmNsaWNrIGhlcmU8L2VtPlxcbnNuaXBwZXQ8L3A+Jyk7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgaW5saW5lIHJhdyBzbmlwcGV0IGlmIGJvdW5kIHRvIGEgdHJ1c3RlZCB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXRydXN0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiPHAgc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiPmFuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiPGVtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIj5jbGljayBoZXJlPC9lbT5cXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldDwvcD5cIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgZXNjYXBlIHNuaXBwZXQgd2l0aG91dCBhbnkgZmlsdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiJmx0O3Agc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiJmd0O2FuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiJmx0O2VtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIiZndDtjbGljayBoZXJlJmx0Oy9lbSZndDtcXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldCZsdDsvcCZndDtcIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuc2VuZEtleXMoJ25ldyA8YiBvbmNsaWNrPVwiYWxlcnQoMSlcIj50ZXh0PC9iPicpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCduZXcgPGI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLnRvQmUoXG4gICAgICAgICAnbmV3IDxiIG9uY2xpY2s9XCJhbGVydCgxKVwiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkudG9CZShcbiAgICAgICAgIFwibmV3ICZsdDtiIG9uY2xpY2s9XFxcImFsZXJ0KDEpXFxcIiZndDt0ZXh0Jmx0Oy9iJmd0O1wiKTtcbiAgICAgfSk7XG4gICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJHNhbml0aXplUHJvdmlkZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMge0BsaW5rICRzYW5pdGl6ZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uICRTYW5pdGl6ZVByb3ZpZGVyKCkge1xuICB2YXIgc3ZnRW5hYmxlZCA9IGZhbHNlO1xuXG4gIHRoaXMuJGdldCA9IFsnJCRzYW5pdGl6ZVVyaScsIGZ1bmN0aW9uKCQkc2FuaXRpemVVcmkpIHtcbiAgICBpZiAoc3ZnRW5hYmxlZCkge1xuICAgICAgYW5ndWxhci5leHRlbmQodmFsaWRFbGVtZW50cywgc3ZnRWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgaHRtbFBhcnNlcihodG1sLCBodG1sU2FuaXRpemVXcml0ZXIoYnVmLCBmdW5jdGlvbih1cmksIGlzSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuICEvXnVuc2FmZTovLnRlc3QoJCRzYW5pdGl6ZVVyaSh1cmksIGlzSW1hZ2UpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfTtcbiAgfV07XG5cblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSAkc2FuaXRpemVQcm92aWRlciNlbmFibGVTdmdcbiAgICogQGtpbmQgZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEVuYWJsZXMgYSBzdWJzZXQgb2Ygc3ZnIHRvIGJlIHN1cHBvcnRlZCBieSB0aGUgc2FuaXRpemVyLlxuICAgKlxuICAgKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICAgKiAgIDxwPkJ5IGVuYWJsaW5nIHRoaXMgc2V0dGluZyB3aXRob3V0IHRha2luZyBvdGhlciBwcmVjYXV0aW9ucywgeW91IG1pZ2h0IGV4cG9zZSB5b3VyXG4gICAqICAgYXBwbGljYXRpb24gdG8gY2xpY2staGlqYWNraW5nIGF0dGFja3MuIEluIHRoZXNlIGF0dGFja3MsIHNhbml0aXplZCBzdmcgZWxlbWVudHMgY291bGQgYmUgcG9zaXRpb25lZFxuICAgKiAgIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5pbmcgZWxlbWVudCBhbmQgYmUgcmVuZGVyZWQgb3ZlciBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZSAoZS5nLiBhIGxvZ2luXG4gICAqICAgbGluaykuIFN1Y2ggYmVoYXZpb3IgY2FuIHRoZW4gcmVzdWx0IGluIHBoaXNoaW5nIGluY2lkZW50cy48L3A+XG4gICAqXG4gICAqICAgPHA+VG8gcHJvdGVjdCBhZ2FpbnN0IHRoZXNlLCBleHBsaWNpdGx5IHNldHVwIGBvdmVyZmxvdzogaGlkZGVuYCBjc3MgcnVsZSBmb3IgYWxsIHBvdGVudGlhbCBzdmdcbiAgICogICB0YWdzIHdpdGhpbiB0aGUgc2FuaXRpemVkIGNvbnRlbnQ6PC9wPlxuICAgKlxuICAgKiAgIDxicj5cbiAgICpcbiAgICogICA8cHJlPjxjb2RlPlxuICAgKiAgIC5yb290T2ZUaGVJbmNsdWRlZENvbnRlbnQgc3ZnIHtcbiAgICogICAgIG92ZXJmbG93OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICogICB9XG4gICAqICAgPC9jb2RlPjwvcHJlPlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cbiAgICogQHJldHVybnMge2Jvb2xlYW58bmcuJHNhbml0aXplUHJvdmlkZXJ9IFJldHVybnMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHZhbHVlIGlmIGNhbGxlZFxuICAgKiAgICB3aXRob3V0IGFuIGFyZ3VtZW50IG9yIHNlbGYgZm9yIGNoYWluaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIHRoaXMuZW5hYmxlU3ZnID0gZnVuY3Rpb24oZW5hYmxlU3ZnKSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGVuYWJsZVN2ZykpIHtcbiAgICAgIHN2Z0VuYWJsZWQgPSBlbmFibGVTdmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN2Z0VuYWJsZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgYW5ndWxhci5ub29wKTtcbiAgd3JpdGVyLmNoYXJzKGNoYXJzKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cblxuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLFxuICAvLyBNYXRjaCBldmVyeXRoaW5nIG91dHNpZGUgb2Ygbm9ybWFsIGNoYXJzIGFuZCBcIiAocXVvdGUgY2hhcmFjdGVyKVxuICBOT05fQUxQSEFOVU1FUklDX1JFR0VYUCA9IC8oW15cXCMtfiB8IV0pL2c7XG5cblxuLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3NlbWFudGljc1xuLy8gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sLWVsZW1lbnRzXG5cbi8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xudmFyIHZvaWRFbGVtZW50cyA9IHRvTWFwKFwiYXJlYSxicixjb2wsaHIsaW1nLHdiclwiKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbi8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG52YXIgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzID0gdG9NYXAoXCJjb2xncm91cCxkZCxkdCxsaSxwLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyXCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnSW5saW5lRWxlbWVudHMgPSB0b01hcChcInJwLHJ0XCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzKTtcblxuLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG52YXIgYmxvY2tFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMsIHRvTWFwKFwiYWRkcmVzcyxhcnRpY2xlLFwiICtcbiAgICAgICAgXCJhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSxcIiArXG4gICAgICAgIFwiaDYsaGVhZGVyLGhncm91cCxocixpbnMsbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHRhYmxlLHVsXCIpKTtcblxuLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBpbmxpbmVFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLCB0b01hcChcImEsYWJicixhY3JvbnltLGIsXCIgK1xuICAgICAgICBcImJkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxxLHJ1YnkscnAscnQscyxcIiArXG4gICAgICAgIFwic2FtcCxzbWFsbCxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0aW1lLHR0LHUsdmFyXCIpKTtcblxuLy8gU1ZHIEVsZW1lbnRzXG4vLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfRWxlbWVudHNcbi8vIE5vdGU6IHRoZSBlbGVtZW50cyBhbmltYXRlLGFuaW1hdGVDb2xvcixhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sc2V0IGFyZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQuXG4vLyBUaGV5IGNhbiBwb3RlbnRpYWxseSBhbGxvdyBmb3IgYXJiaXRyYXJ5IGphdmFzY3JpcHQgdG8gYmUgZXhlY3V0ZWQuIFNlZSAjMTEyOTBcbnZhciBzdmdFbGVtZW50cyA9IHRvTWFwKFwiY2lyY2xlLGRlZnMsZGVzYyxlbGxpcHNlLGZvbnQtZmFjZSxmb250LWZhY2UtbmFtZSxmb250LWZhY2Utc3JjLGcsZ2x5cGgsXCIgK1xuICAgICAgICBcImhrZXJuLGltYWdlLGxpbmVhckdyYWRpZW50LGxpbmUsbWFya2VyLG1ldGFkYXRhLG1pc3NpbmctZ2x5cGgsbXBhdGgscGF0aCxwb2x5Z29uLHBvbHlsaW5lLFwiICtcbiAgICAgICAgXCJyYWRpYWxHcmFkaWVudCxyZWN0LHN0b3Asc3ZnLHN3aXRjaCx0ZXh0LHRpdGxlLHRzcGFuXCIpO1xuXG4vLyBCbG9ja2VkIEVsZW1lbnRzICh3aWxsIGJlIHN0cmlwcGVkKVxudmFyIGJsb2NrZWRFbGVtZW50cyA9IHRvTWFwKFwic2NyaXB0LHN0eWxlXCIpO1xuXG52YXIgdmFsaWRFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubGluZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0VsZW1lbnRzKTtcblxuLy9BdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxudmFyIHVyaUF0dHJzID0gdG9NYXAoXCJiYWNrZ3JvdW5kLGNpdGUsaHJlZixsb25nZGVzYyxzcmMseGxpbms6aHJlZlwiKTtcblxudmFyIGh0bWxBdHRycyA9IHRvTWFwKCdhYmJyLGFsaWduLGFsdCxheGlzLGJnY29sb3IsYm9yZGVyLGNlbGxwYWRkaW5nLGNlbGxzcGFjaW5nLGNsYXNzLGNsZWFyLCcgK1xuICAgICdjb2xvcixjb2xzLGNvbHNwYW4sY29tcGFjdCxjb29yZHMsZGlyLGZhY2UsaGVhZGVycyxoZWlnaHQsaHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICdpc21hcCxsYW5nLGxhbmd1YWdlLG5vaHJlZixub3dyYXAscmVsLHJldixyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgJ3Njb3BlLHNjcm9sbGluZyxzaGFwZSxzaXplLHNwYW4sc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHlwZSwnICtcbiAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuXG4vLyBTVkcgYXR0cmlidXRlcyAod2l0aG91dCBcImlkXCIgYW5kIFwibmFtZVwiIGF0dHJpYnV0ZXMpXG4vLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfQXR0cmlidXRlc1xudmFyIHN2Z0F0dHJzID0gdG9NYXAoJ2FjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbHBoYWJldGljLGFyYWJpYy1mb3JtLGFzY2VudCwnICtcbiAgICAnYmFzZVByb2ZpbGUsYmJveCxiZWdpbixieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNvbG9yLGNvbG9yLXJlbmRlcmluZyxjb250ZW50LCcgK1xuICAgICdjeCxjeSxkLGR4LGR5LGRlc2NlbnQsZGlzcGxheSxkdXIsZW5kLGZpbGwsZmlsbC1ydWxlLGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXN0cmV0Y2gsJyArXG4gICAgJ2ZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZyb20sZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxncmFkaWVudFVuaXRzLGhhbmdpbmcsJyArXG4gICAgJ2hlaWdodCxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZGVvZ3JhcGhpYyxrLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsJyArXG4gICAgJ21hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hdGhlbWF0aWNhbCwnICtcbiAgICAnbWF4LG1pbixvZmZzZXQsb3BhY2l0eSxvcmllbnQsb3JpZ2luLG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSwnICtcbiAgICAncGF0aCxwYXRoTGVuZ3RoLHBvaW50cyxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHIscmVmWCxyZWZZLHJlcGVhdENvdW50LHJlcGVhdER1ciwnICtcbiAgICAncmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyb3RhdGUscngscnksc2xvcGUsc3RlbWgsc3RlbXYsc3RvcC1jb2xvciwnICtcbiAgICAnc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksJyArXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSwnICtcbiAgICAnc3Ryb2tlLXdpZHRoLHN5c3RlbUxhbmd1YWdlLHRhcmdldCx0ZXh0LWFuY2hvcix0byx0cmFuc2Zvcm0sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sJyArXG4gICAgJ3VuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2YWx1ZXMsdmVyc2lvbix2aWV3Qm94LHZpc2liaWxpdHksJyArXG4gICAgJ3dpZHRoLHdpZHRocyx4LHgtaGVpZ2h0LHgxLHgyLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUsJyArXG4gICAgJ3hsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHhtbG5zLHhtbG5zOnhsaW5rLHkseTEseTIsem9vbUFuZFBhbicsIHRydWUpO1xuXG52YXIgdmFsaWRBdHRycyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmlBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRycyk7XG5cbmZ1bmN0aW9uIHRvTWFwKHN0ciwgbG93ZXJjYXNlS2V5cykge1xuICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KCcsJyksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIG9ialtsb3dlcmNhc2VLZXlzID8gYW5ndWxhci5sb3dlcmNhc2UoaXRlbXNbaV0pIDogaXRlbXNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgaW5lcnRCb2R5RWxlbWVudDtcbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgdmFyIGRvYztcbiAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuaW1wbGVtZW50YXRpb24pIHtcbiAgICBkb2MgPSB3aW5kb3cuZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiaW5lcnRcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCdub2luZXJ0JywgXCJDYW4ndCBjcmVhdGUgYW4gaW5lcnQgaHRtbCBkb2N1bWVudFwiKTtcbiAgfVxuICB2YXIgZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgfHwgZG9jLmdldERvY3VtZW50RWxlbWVudCgpO1xuICB2YXIgYm9keUVsZW1lbnRzID0gZG9jRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpO1xuXG4gIC8vIHVzdWFsbHkgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJvZHkgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQsIGJ1dCBJRSBkb2Vzbid0IGhhdmUgYW55LCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgaWYgKGJvZHlFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmVydEJvZHlFbGVtZW50ID0gYm9keUVsZW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHZhciBodG1sID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBpbmVydEJvZHlFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBodG1sLmFwcGVuZENoaWxkKGluZXJ0Qm9keUVsZW1lbnQpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChodG1sKTtcbiAgfVxufSkod2luZG93KTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogaHRtbFBhcnNlcihodG1sU3RyaW5nLCB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMpIHt9LFxuICogICAgIGVuZDogZnVuY3Rpb24odGFnKSB7fSxcbiAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gKiAgICAgY29tbWVudDogZnVuY3Rpb24odGV4dCkge31cbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gaHRtbFBhcnNlcihodG1sLCBoYW5kbGVyKSB7XG4gIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09IHVuZGVmaW5lZCkge1xuICAgIGh0bWwgPSAnJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICBodG1sID0gJycgKyBodG1sO1xuICB9XG4gIGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcblxuICAvL21YU1MgcHJvdGVjdGlvblxuICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgZG8ge1xuICAgIGlmIChtWFNTQXR0ZW1wdHMgPT09IDApIHtcbiAgICAgIHRocm93ICRzYW5pdGl6ZU1pbkVycigndWlucHV0JywgXCJGYWlsZWQgdG8gc2FuaXRpemUgaHRtbCBiZWNhdXNlIHRoZSBpbnB1dCBpcyB1bnN0YWJsZVwiKTtcbiAgICB9XG4gICAgbVhTU0F0dGVtcHRzLS07XG5cbiAgICAvLyBzdHJpcCBjdXN0b20tbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIG9uIElFPD0xMVxuICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTEpIHtcbiAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhpbmVydEJvZHlFbGVtZW50KTtcbiAgICB9XG4gICAgaHRtbCA9IGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MOyAvL3RyaWdnZXIgbVhTU1xuICAgIGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgfSB3aGlsZSAoaHRtbCAhPT0gaW5lcnRCb2R5RWxlbWVudC5pbm5lckhUTUwpO1xuXG4gIHZhciBub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSAxOiAvLyBFTEVNRU5UX05PREVcbiAgICAgICAgaGFuZGxlci5zdGFydChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJUb01hcChub2RlLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6IC8vIFRFWFQgTk9ERVxuICAgICAgICBoYW5kbGVyLmNoYXJzKG5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbmV4dE5vZGU7XG4gICAgaWYgKCEobmV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoIW5leHROb2RlKSB7XG4gICAgICAgIHdoaWxlIChuZXh0Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gaW5lcnRCb2R5RWxlbWVudCkgYnJlYWs7XG4gICAgICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxuXG4gIHdoaWxlIChub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgaW5lcnRCb2R5RWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRyVG9NYXAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBtYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuXG4vKipcbiAqIEVzY2FwZXMgYWxsIHBvdGVudGlhbGx5IGRhbmdlcm91cyBjaGFyYWN0ZXJzLCBzbyB0aGF0IHRoZVxuICogcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGludG8gYXR0cmlidXRlIG9yXG4gKiBlbGVtZW50IHRleHQuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgdGV4dFxuICovXG5mdW5jdGlvbiBlbmNvZGVFbnRpdGllcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuXG4gICAgcmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5cbiAgICByZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBoaSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICB2YXIgbG93ID0gdmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgIHJldHVybiAnJiMnICsgKCgoaGkgLSAweEQ4MDApICogMHg0MDApICsgKGxvdyAtIDB4REMwMCkgKyAweDEwMDAwKSArICc7JztcbiAgICB9KS5cbiAgICByZXBsYWNlKE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICcmIycgKyB2YWx1ZS5jaGFyQ29kZUF0KDApICsgJzsnO1xuICAgIH0pLlxuICAgIHJlcGxhY2UoLzwvZywgJyZsdDsnKS5cbiAgICByZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbi8qKlxuICogY3JlYXRlIGFuIEhUTUwvWE1MIHdyaXRlciB3aGljaCB3cml0ZXMgdG8gYnVmZmVyXG4gKiBAcGFyYW0ge0FycmF5fSBidWYgdXNlIGJ1Zi5qb2luKCcnKSB0byBnZXQgb3V0IHNhbml0aXplZCBodG1sIHN0cmluZ1xuICogQHJldHVybnMge29iamVjdH0gaW4gdGhlIGZvcm0gb2Yge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzKSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIHVyaVZhbGlkYXRvcikge1xuICB2YXIgaWdub3JlQ3VycmVudEVsZW1lbnQgPSBmYWxzZTtcbiAgdmFyIG91dCA9IGFuZ3VsYXIuYmluZChidWYsIGJ1Zi5wdXNoKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycykge1xuICAgICAgdGFnID0gYW5ndWxhci5sb3dlcmNhc2UodGFnKTtcbiAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQgJiYgYmxvY2tlZEVsZW1lbnRzW3RhZ10pIHtcbiAgICAgICAgaWdub3JlQ3VycmVudEVsZW1lbnQgPSB0YWc7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZUN1cnJlbnRFbGVtZW50ICYmIHZhbGlkRWxlbWVudHNbdGFnXSA9PT0gdHJ1ZSkge1xuICAgICAgICBvdXQoJzwnKTtcbiAgICAgICAgb3V0KHRhZyk7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChhdHRycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHZhciBsa2V5PWFuZ3VsYXIubG93ZXJjYXNlKGtleSk7XG4gICAgICAgICAgdmFyIGlzSW1hZ2UgPSAodGFnID09PSAnaW1nJyAmJiBsa2V5ID09PSAnc3JjJykgfHwgKGxrZXkgPT09ICdiYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgaWYgKHZhbGlkQXR0cnNbbGtleV0gPT09IHRydWUgJiZcbiAgICAgICAgICAgICh1cmlBdHRyc1tsa2V5XSAhPT0gdHJ1ZSB8fCB1cmlWYWxpZGF0b3IodmFsdWUsIGlzSW1hZ2UpKSkge1xuICAgICAgICAgICAgb3V0KCcgJyk7XG4gICAgICAgICAgICBvdXQoa2V5KTtcbiAgICAgICAgICAgIG91dCgnPVwiJyk7XG4gICAgICAgICAgICBvdXQoZW5jb2RlRW50aXRpZXModmFsdWUpKTtcbiAgICAgICAgICAgIG91dCgnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvdXQoJz4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24odGFnKSB7XG4gICAgICB0YWcgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWcpO1xuICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUgJiYgdm9pZEVsZW1lbnRzW3RhZ10gIT09IHRydWUpIHtcbiAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgb3V0KCc+Jyk7XG4gICAgICB9XG4gICAgICBpZiAodGFnID09IGlnbm9yZUN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGFyczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgb3V0KGVuY29kZUVudGl0aWVzKGNoYXJzKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5cbi8qKlxuICogV2hlbiBJRTktMTEgY29tZXMgYWNyb3NzIGFuIHVua25vd24gbmFtZXNwYWNlZCBhdHRyaWJ1dGUgZS5nLiAneGxpbms6Zm9vJyBpdCBhZGRzICd4bWxuczpuczEnIGF0dHJpYnV0ZSB0byBkZWNsYXJlXG4gKiBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy4gJ25zMTp4bGluazpmb28nKS4gVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50XG4gKiB0byBhbGxvdyBhbnkgb2YgdGhlc2UgY3VzdG9tIGF0dHJpYnV0ZXMuIFRoaXMgbWV0aG9kIHN0cmlwcyB0aGVtIGFsbC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBSb290IGVsZW1lbnQgdG8gcHJvY2Vzc1xuICovXG5mdW5jdGlvbiBzdHJpcEN1c3RvbU5zQXR0cnMobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyTm9kZSA9IGF0dHJzW2ldO1xuICAgICAgdmFyIGF0dHJOYW1lID0gYXR0ck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGF0dHJOYW1lID09PSAneG1sbnM6bnMxJyB8fCBhdHRyTmFtZS5pbmRleE9mKCduczE6JykgPT09IDApIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHJOb2RlKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBsLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBpZiAobmV4dE5vZGUpIHtcbiAgICBzdHJpcEN1c3RvbU5zQXR0cnMobmV4dE5vZGUpO1xuICB9XG5cbiAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICBpZiAobmV4dE5vZGUpIHtcbiAgICBzdHJpcEN1c3RvbU5zQXR0cnMobmV4dE5vZGUpO1xuICB9XG59XG5cblxuXG4vLyBkZWZpbmUgbmdTYW5pdGl6ZSBtb2R1bGUgYW5kIHJlZ2lzdGVyICRzYW5pdGl6ZSBzZXJ2aWNlXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScsIFtdKS5wcm92aWRlcignJHNhbml0aXplJywgJFNhbml0aXplUHJvdmlkZXIpO1xuXG4vKiBnbG9iYWwgc2FuaXRpemVUZXh0OiBmYWxzZSAqL1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIGxpbmt5XG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmluZHMgbGlua3MgaW4gdGV4dCBpbnB1dCBhbmQgdHVybnMgdGhlbSBpbnRvIGh0bWwgbGlua3MuIFN1cHBvcnRzIGBodHRwL2h0dHBzL2Z0cC9tYWlsdG9gIGFuZFxuICogcGxhaW4gZW1haWwgYWRkcmVzcyBsaW5rcy5cbiAqXG4gKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nU2FuaXRpemUgYG5nU2FuaXRpemVgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IElucHV0IHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFdpbmRvdyAoYF9ibGFua3xfc2VsZnxfcGFyZW50fF90b3BgKSBvciBuYW1lZCBmcmFtZSB0byBvcGVuIGxpbmtzIGluLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb24odXJsKX0gW2F0dHJpYnV0ZXNdIEFkZCBjdXN0b20gYXR0cmlidXRlcyB0byB0aGUgbGluayBlbGVtZW50LlxuICpcbiAqICAgIENhbiBiZSBvbmUgb2Y6XG4gKlxuICogICAgLSBgb2JqZWN0YDogQSBtYXAgb2YgYXR0cmlidXRlc1xuICogICAgLSBgZnVuY3Rpb25gOiBUYWtlcyB0aGUgdXJsIGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgbWFwIG9mIGF0dHJpYnV0ZXNcbiAqXG4gKiAgICBJZiB0aGUgbWFwIG9mIGF0dHJpYnV0ZXMgY29udGFpbnMgYSB2YWx1ZSBmb3IgYHRhcmdldGAsIGl0IG92ZXJyaWRlcyB0aGUgdmFsdWUgb2ZcbiAqICAgIHRoZSB0YXJnZXQgcGFyYW1ldGVyLlxuICpcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIdG1sLWxpbmtpZmllZCBhbmQge0BsaW5rICRzYW5pdGl6ZSBzYW5pdGl6ZWR9IHRleHQuXG4gKlxuICogQHVzYWdlXG4gICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJsaW5reV9leHByZXNzaW9uIHwgbGlua3lcIj48L3NwYW4+XG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cImxpbmt5RXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCI+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiRXhhbXBsZUNvbnRyb2xsZXJcIj5cbiAgICAgICBTbmlwcGV0OiA8dGV4dGFyZWEgbmctbW9kZWw9XCJzbmlwcGV0XCIgY29scz1cIjYwXCIgcm93cz1cIjNcIj48L3RleHRhcmVhPlxuICAgICAgIDx0YWJsZT5cbiAgICAgICAgIDx0cj5cbiAgICAgICAgICAgPHRoPkZpbHRlcjwvdGg+XG4gICAgICAgICAgIDx0aD5Tb3VyY2U8L3RoPlxuICAgICAgICAgICA8dGg+UmVuZGVyZWQ8L3RoPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImxpbmt5LWZpbHRlclwiPlxuICAgICAgICAgICA8dGQ+bGlua3kgZmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0IHwgbGlua3lcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXQgfCBsaW5reVwiPjwvZGl2PlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImxpbmt5LXRhcmdldFwiPlxuICAgICAgICAgIDx0ZD5saW5reSB0YXJnZXQ8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCI+PC9kaXY+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS1jdXN0b20tYXR0cmlidXRlc1wiPlxuICAgICAgICAgIDx0ZD5saW5reSBjdXN0b20gYXR0cmlidXRlczwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19zZWxmJzp7cmVsOiAnbm9mb2xsb3cnfVwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhTaW5nbGVVUkwgfCBsaW5reTonX3NlbGYnOntyZWw6ICdub2ZvbGxvdyd9XCI+PC9kaXY+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJlc2NhcGVkLWh0bWxcIj5cbiAgICAgICAgICAgPHRkPm5vIGZpbHRlcjwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZD1cInNuaXBwZXRcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgICBhbmd1bGFyLm1vZHVsZSgnbGlua3lFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAuY29udHJvbGxlcignRXhhbXBsZUNvbnRyb2xsZXInLCBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczpcXG4nK1xuICAgICAgICAgICAgICdodHRwOi8vYW5ndWxhcmpzLm9yZy8sXFxuJytcbiAgICAgICAgICAgICAnbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsXFxuJytcbiAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgJ2FuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nO1xuICAgICAgICAgICAkc2NvcGUuc25pcHBldFdpdGhTaW5nbGVVUkwgPSAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJztcbiAgICAgICAgIH1dKTtcbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwicHJvdHJhY3Rvci5qc1wiIHR5cGU9XCJwcm90cmFjdG9yXCI+XG4gICAgICAgaXQoJ3Nob3VsZCBsaW5raWZ5IHRoZSBzbmlwcGV0IHdpdGggdXJscycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczogaHR0cDovL2FuZ3VsYXJqcy5vcmcvLCB1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDQpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBub3QgbGlua2lmeSBzbmlwcGV0IHdpdGhvdXQgdGhlIGxpbmt5IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsICcgK1xuICAgICAgICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZywgYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2VzY2FwZWQtaHRtbCBhJykpLmNvdW50KCkpLnRvRXF1YWwoMCk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5zZW5kS2V5cygnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKVxuICAgICAgICAgICAgIC50b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHdvcmsgd2l0aCB0aGUgdGFyZ2V0IHByb3BlcnR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS10YXJnZXQnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCIpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgdG9CZSgnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJyk7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2xpbmt5LXRhcmdldCBhJykpLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpLnRvRXF1YWwoJ19ibGFuaycpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBvcHRpb25hbGx5IGFkZCBjdXN0b20gYXR0cmlidXRlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5Oidfc2VsZic6e3JlbDogJ25vZm9sbG93J31cIikpLmdldFRleHQoKSkuXG4gICAgICAgICAgICB0b0JlKCdodHRwOi8vYW5ndWxhcmpzLm9yZy8nKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMgYScpKS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKS50b0VxdWFsKCdub2ZvbGxvdycpO1xuICAgICAgIH0pO1xuICAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1Nhbml0aXplJykuZmlsdGVyKCdsaW5reScsIFsnJHNhbml0aXplJywgZnVuY3Rpb24oJHNhbml0aXplKSB7XG4gIHZhciBMSU5LWV9VUkxfUkVHRVhQID1cbiAgICAgICAgLygoZnRwfGh0dHBzPyk6XFwvXFwvfCh3d3dcXC4pfChtYWlsdG86KT9bQS1aYS16MC05Ll8lKy1dK0ApXFxTKlteXFxzLjssKCl7fTw+XCJcXHUyMDFkXFx1MjAxOV0vaSxcbiAgICAgIE1BSUxUT19SRUdFWFAgPSAvXm1haWx0bzovaTtcblxuICB2YXIgbGlua3lNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCdsaW5reScpO1xuICB2YXIgaXNTdHJpbmcgPSBhbmd1bGFyLmlzU3RyaW5nO1xuXG4gIHJldHVybiBmdW5jdGlvbih0ZXh0LCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dCA9PSBudWxsIHx8IHRleHQgPT09ICcnKSByZXR1cm4gdGV4dDtcbiAgICBpZiAoIWlzU3RyaW5nKHRleHQpKSB0aHJvdyBsaW5reU1pbkVycignbm90c3RyaW5nJywgJ0V4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQ6IHswfScsIHRleHQpO1xuXG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciByYXcgPSB0ZXh0O1xuICAgIHZhciBodG1sID0gW107XG4gICAgdmFyIHVybDtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmF3Lm1hdGNoKExJTktZX1VSTF9SRUdFWFApKSkge1xuICAgICAgLy8gV2UgY2FuIG5vdCBlbmQgaW4gdGhlc2UgYXMgdGhleSBhcmUgc29tZXRpbWVzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNlbnRlbmNlXG4gICAgICB1cmwgPSBtYXRjaFswXTtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgbWF0Y2ggZnRwL2h0dHAvd3d3L21haWx0byB0aGVuIGFzc3VtZSBtYWlsdG9cbiAgICAgIGlmICghbWF0Y2hbMl0gJiYgIW1hdGNoWzRdKSB7XG4gICAgICAgIHVybCA9IChtYXRjaFszXSA/ICdodHRwOi8vJyA6ICdtYWlsdG86JykgKyB1cmw7XG4gICAgICB9XG4gICAgICBpID0gbWF0Y2guaW5kZXg7XG4gICAgICBhZGRUZXh0KHJhdy5zdWJzdHIoMCwgaSkpO1xuICAgICAgYWRkTGluayh1cmwsIG1hdGNoWzBdLnJlcGxhY2UoTUFJTFRPX1JFR0VYUCwgJycpKTtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoaSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIGFkZFRleHQocmF3KTtcbiAgICByZXR1cm4gJHNhbml0aXplKGh0bWwuam9pbignJykpO1xuXG4gICAgZnVuY3Rpb24gYWRkVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKHNhbml0aXplVGV4dCh0ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluayh1cmwsIHRleHQpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBodG1sLnB1c2goJzxhICcpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihhdHRyaWJ1dGVzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyh1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKGFuZ3VsYXIuaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGh0bWwucHVzaChrZXkgKyAnPVwiJyArIGF0dHJpYnV0ZXNba2V5XSArICdcIiAnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHRhcmdldCkgJiYgISgndGFyZ2V0JyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBodG1sLnB1c2goJ3RhcmdldD1cIicsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAnXCIgJyk7XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goJ2hyZWY9XCInLFxuICAgICAgICAgICAgICAgIHVybC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JyksXG4gICAgICAgICAgICAgICAgJ1wiPicpO1xuICAgICAgYWRkVGV4dCh0ZXh0KTtcbiAgICAgIGh0bWwucHVzaCgnPC9hPicpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1zYW5pdGl6ZS9hbmd1bGFyLXNhbml0aXplLmpzXG4gKiogbW9kdWxlIGlkID0gMTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNSA2IDdcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcIm1vbWVudFwiXSA9IHJlcXVpcmUoXCItIS9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qc1wiKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2V4cG9zZS1sb2FkZXI/bW9tZW50IS9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9tb21lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyXG4gKiovIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjEwLjZcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc0FNb21lbnRPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fc3RyaWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3R6bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc1VUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3BmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbG9jYWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKCkge1xuICAgIH1cblxuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdIHx8IG5ldyBMb2NhbGUoKTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3VuaXRzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbiAoc3RoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMzI1XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RoID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RoKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICB2YXIgZnJvbV9zdHJpbmdfX2lzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC8oVHwgKVxcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZnJvbV9zdHJpbmdfX2lzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gKG1hdGNoWzZdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaChtYXRjaE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gJ1onO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IGxvY2FsX19jcmVhdGVMb2NhbChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIHdlZWsxSmFuID0gNiArIGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3REYXlPZldlZWtPZlllYXIsIGphblggPSBjcmVhdGVVVENEYXRlKHllYXIsIDAsIDEgKyB3ZWVrMUphbiksIGQgPSBqYW5YLmdldFVUQ0RheSgpLCBkYXlPZlllYXI7XG4gICAgICAgIGlmIChkIDwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgICAgIGQgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHdlZWtkYXkgPSB3ZWVrZGF5ICE9IG51bGwgPyAxICogd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyB3ZWVrMUphbiArIDcgKiAod2VlayAtIDEpIC0gZCArIHdlZWtkYXk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCBkb3csIGRveSkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoT2Zmc2V0KSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2lzRFNUU2hpZnRlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBjcmVhdGVfX2lzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGNyZWF0ZV9faXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChmb3JtYXRzICYmIGZvcm1hdHNbZm9ybWF0XSB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpICYmIHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyksXG4gICAgICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0LFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkX19pc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgMCwgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gdGhpcy5fd2Vla2RheXNQYXJzZSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgID0gY2xvbmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgPSBmb3JtYXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICA9IHRvO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICA9IHRvT2JqZWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICA9IHRvU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG5cbiAgICAvLyBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgLy8gV2VlayBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgIC8vIFF1YXJ0ZXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgIC8vIE1vbnRoXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgIC8vIFdlZWtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgIC8vIERheVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgLy8gSG91clxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgLy8gTWludXRlXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAvLyBTZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAvLyBPZmZzZXRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLl9jYWxlbmRhciAgICAgICA9IGRlZmF1bHRDYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWwgICAgICAgID0gZGVmYXVsdE9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgIC8vIE1vbnRoXG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRocyAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1BhcnNlICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcblxuICAgIC8vIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzICAgICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgY291bnQsIHNldHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzJywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0JywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3QgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgID09PSAxICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA9PT0gMSAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPT09IDEgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgID09PSAxICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTAuNic7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L21vbWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCJ2YXIgbWFwID0ge1xuXHRcIi4vYWZcIjogMjEyLFxuXHRcIi4vYWYuanNcIjogMjEyLFxuXHRcIi4vYXJcIjogMjEzLFxuXHRcIi4vYXItbWFcIjogMjE0LFxuXHRcIi4vYXItbWEuanNcIjogMjE0LFxuXHRcIi4vYXItc2FcIjogMjE1LFxuXHRcIi4vYXItc2EuanNcIjogMjE1LFxuXHRcIi4vYXItdG5cIjogMjE2LFxuXHRcIi4vYXItdG4uanNcIjogMjE2LFxuXHRcIi4vYXIuanNcIjogMjEzLFxuXHRcIi4vYXpcIjogMjE3LFxuXHRcIi4vYXouanNcIjogMjE3LFxuXHRcIi4vYmVcIjogMjE4LFxuXHRcIi4vYmUuanNcIjogMjE4LFxuXHRcIi4vYmdcIjogMjE5LFxuXHRcIi4vYmcuanNcIjogMjE5LFxuXHRcIi4vYm5cIjogMjIwLFxuXHRcIi4vYm4uanNcIjogMjIwLFxuXHRcIi4vYm9cIjogMjIxLFxuXHRcIi4vYm8uanNcIjogMjIxLFxuXHRcIi4vYnJcIjogMjIyLFxuXHRcIi4vYnIuanNcIjogMjIyLFxuXHRcIi4vYnNcIjogMjIzLFxuXHRcIi4vYnMuanNcIjogMjIzLFxuXHRcIi4vY2FcIjogMjI0LFxuXHRcIi4vY2EuanNcIjogMjI0LFxuXHRcIi4vY3NcIjogMjI1LFxuXHRcIi4vY3MuanNcIjogMjI1LFxuXHRcIi4vY3ZcIjogMjI2LFxuXHRcIi4vY3YuanNcIjogMjI2LFxuXHRcIi4vY3lcIjogMjI3LFxuXHRcIi4vY3kuanNcIjogMjI3LFxuXHRcIi4vZGFcIjogMjI4LFxuXHRcIi4vZGEuanNcIjogMjI4LFxuXHRcIi4vZGVcIjogMjI5LFxuXHRcIi4vZGUtYXRcIjogMjMwLFxuXHRcIi4vZGUtYXQuanNcIjogMjMwLFxuXHRcIi4vZGUuanNcIjogMjI5LFxuXHRcIi4vZWxcIjogMjMxLFxuXHRcIi4vZWwuanNcIjogMjMxLFxuXHRcIi4vZW4tYXVcIjogMjMyLFxuXHRcIi4vZW4tYXUuanNcIjogMjMyLFxuXHRcIi4vZW4tY2FcIjogMjMzLFxuXHRcIi4vZW4tY2EuanNcIjogMjMzLFxuXHRcIi4vZW4tZ2JcIjogMjM0LFxuXHRcIi4vZW4tZ2IuanNcIjogMjM0LFxuXHRcIi4vZW9cIjogMjM1LFxuXHRcIi4vZW8uanNcIjogMjM1LFxuXHRcIi4vZXNcIjogMjM2LFxuXHRcIi4vZXMuanNcIjogMjM2LFxuXHRcIi4vZXRcIjogMjM3LFxuXHRcIi4vZXQuanNcIjogMjM3LFxuXHRcIi4vZXVcIjogMjM4LFxuXHRcIi4vZXUuanNcIjogMjM4LFxuXHRcIi4vZmFcIjogMjM5LFxuXHRcIi4vZmEuanNcIjogMjM5LFxuXHRcIi4vZmlcIjogMjQwLFxuXHRcIi4vZmkuanNcIjogMjQwLFxuXHRcIi4vZm9cIjogMjQxLFxuXHRcIi4vZm8uanNcIjogMjQxLFxuXHRcIi4vZnJcIjogMjQyLFxuXHRcIi4vZnItY2FcIjogMjQzLFxuXHRcIi4vZnItY2EuanNcIjogMjQzLFxuXHRcIi4vZnIuanNcIjogMjQyLFxuXHRcIi4vZnlcIjogMjQ0LFxuXHRcIi4vZnkuanNcIjogMjQ0LFxuXHRcIi4vZ2xcIjogMjQ1LFxuXHRcIi4vZ2wuanNcIjogMjQ1LFxuXHRcIi4vaGVcIjogMjQ2LFxuXHRcIi4vaGUuanNcIjogMjQ2LFxuXHRcIi4vaGlcIjogMjQ3LFxuXHRcIi4vaGkuanNcIjogMjQ3LFxuXHRcIi4vaHJcIjogMjQ4LFxuXHRcIi4vaHIuanNcIjogMjQ4LFxuXHRcIi4vaHVcIjogMjQ5LFxuXHRcIi4vaHUuanNcIjogMjQ5LFxuXHRcIi4vaHktYW1cIjogMjUwLFxuXHRcIi4vaHktYW0uanNcIjogMjUwLFxuXHRcIi4vaWRcIjogMjUxLFxuXHRcIi4vaWQuanNcIjogMjUxLFxuXHRcIi4vaXNcIjogMjUyLFxuXHRcIi4vaXMuanNcIjogMjUyLFxuXHRcIi4vaXRcIjogMjUzLFxuXHRcIi4vaXQuanNcIjogMjUzLFxuXHRcIi4vamFcIjogMjU0LFxuXHRcIi4vamEuanNcIjogMjU0LFxuXHRcIi4vanZcIjogMjU1LFxuXHRcIi4vanYuanNcIjogMjU1LFxuXHRcIi4va2FcIjogMjU2LFxuXHRcIi4va2EuanNcIjogMjU2LFxuXHRcIi4va21cIjogMjU3LFxuXHRcIi4va20uanNcIjogMjU3LFxuXHRcIi4va29cIjogMjU4LFxuXHRcIi4va28uanNcIjogMjU4LFxuXHRcIi4vbGJcIjogMjU5LFxuXHRcIi4vbGIuanNcIjogMjU5LFxuXHRcIi4vbHRcIjogMjYwLFxuXHRcIi4vbHQuanNcIjogMjYwLFxuXHRcIi4vbHZcIjogMjYxLFxuXHRcIi4vbHYuanNcIjogMjYxLFxuXHRcIi4vbWVcIjogMjYyLFxuXHRcIi4vbWUuanNcIjogMjYyLFxuXHRcIi4vbWtcIjogMjYzLFxuXHRcIi4vbWsuanNcIjogMjYzLFxuXHRcIi4vbWxcIjogMjY0LFxuXHRcIi4vbWwuanNcIjogMjY0LFxuXHRcIi4vbXJcIjogMjY1LFxuXHRcIi4vbXIuanNcIjogMjY1LFxuXHRcIi4vbXNcIjogMjY2LFxuXHRcIi4vbXMtbXlcIjogMjY3LFxuXHRcIi4vbXMtbXkuanNcIjogMjY3LFxuXHRcIi4vbXMuanNcIjogMjY2LFxuXHRcIi4vbXlcIjogMjY4LFxuXHRcIi4vbXkuanNcIjogMjY4LFxuXHRcIi4vbmJcIjogMjY5LFxuXHRcIi4vbmIuanNcIjogMjY5LFxuXHRcIi4vbmVcIjogMjcwLFxuXHRcIi4vbmUuanNcIjogMjcwLFxuXHRcIi4vbmxcIjogMjcxLFxuXHRcIi4vbmwuanNcIjogMjcxLFxuXHRcIi4vbm5cIjogMjcyLFxuXHRcIi4vbm4uanNcIjogMjcyLFxuXHRcIi4vcGxcIjogMjczLFxuXHRcIi4vcGwuanNcIjogMjczLFxuXHRcIi4vcHRcIjogMjc0LFxuXHRcIi4vcHQtYnJcIjogMjc1LFxuXHRcIi4vcHQtYnIuanNcIjogMjc1LFxuXHRcIi4vcHQuanNcIjogMjc0LFxuXHRcIi4vcm9cIjogMjc2LFxuXHRcIi4vcm8uanNcIjogMjc2LFxuXHRcIi4vcnVcIjogMjc3LFxuXHRcIi4vcnUuanNcIjogMjc3LFxuXHRcIi4vc2lcIjogMjc4LFxuXHRcIi4vc2kuanNcIjogMjc4LFxuXHRcIi4vc2tcIjogMjc5LFxuXHRcIi4vc2suanNcIjogMjc5LFxuXHRcIi4vc2xcIjogMjgwLFxuXHRcIi4vc2wuanNcIjogMjgwLFxuXHRcIi4vc3FcIjogMjgxLFxuXHRcIi4vc3EuanNcIjogMjgxLFxuXHRcIi4vc3JcIjogMjgyLFxuXHRcIi4vc3ItY3lybFwiOiAyODMsXG5cdFwiLi9zci1jeXJsLmpzXCI6IDI4Myxcblx0XCIuL3NyLmpzXCI6IDI4Mixcblx0XCIuL3N2XCI6IDI4NCxcblx0XCIuL3N2LmpzXCI6IDI4NCxcblx0XCIuL3RhXCI6IDI4NSxcblx0XCIuL3RhLmpzXCI6IDI4NSxcblx0XCIuL3RoXCI6IDI4Nixcblx0XCIuL3RoLmpzXCI6IDI4Nixcblx0XCIuL3RsLXBoXCI6IDI4Nyxcblx0XCIuL3RsLXBoLmpzXCI6IDI4Nyxcblx0XCIuL3RyXCI6IDI4OCxcblx0XCIuL3RyLmpzXCI6IDI4OCxcblx0XCIuL3R6bFwiOiAyODksXG5cdFwiLi90emwuanNcIjogMjg5LFxuXHRcIi4vdHptXCI6IDI5MCxcblx0XCIuL3R6bS1sYXRuXCI6IDI5MSxcblx0XCIuL3R6bS1sYXRuLmpzXCI6IDI5MSxcblx0XCIuL3R6bS5qc1wiOiAyOTAsXG5cdFwiLi91a1wiOiAyOTIsXG5cdFwiLi91ay5qc1wiOiAyOTIsXG5cdFwiLi91elwiOiAyOTMsXG5cdFwiLi91ei5qc1wiOiAyOTMsXG5cdFwiLi92aVwiOiAyOTQsXG5cdFwiLi92aS5qc1wiOiAyOTQsXG5cdFwiLi96aC1jblwiOiAyOTUsXG5cdFwiLi96aC1jbi5qc1wiOiAyOTUsXG5cdFwiLi96aC10d1wiOiAyOTYsXG5cdFwiLi96aC10dy5qc1wiOiAyOTZcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIikgfSgpKTtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMjExO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlIF5cXC5cXC8uKiRcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogYWZyaWthYW5zIChhZilcbi8vISBhdXRob3IgOiBXZXJuZXIgTW9sbGVudHplIDogaHR0cHM6Ly9naXRodWIuY29tL3dlcm5lcm1cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgYWYgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdhZicsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbnVhcmllX0ZlYnJ1YXJpZV9NYWFydF9BcHJpbF9NZWlfSnVuaWVfSnVsaWVfQXVndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NZWlfSnVuX0p1bF9BdWdfU2VwX09rdF9Ob3ZfRGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdTb25kYWdfTWFhbmRhZ19EaW5zZGFnX1dvZW5zZGFnX0RvbmRlcmRhZ19WcnlkYWdfU2F0ZXJkYWcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU29uX01hYV9EaW5fV29lX0Rvbl9WcnlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTb19NYV9EaV9Xb19Eb19Wcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL3ZtfG5tL2ksXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXm5tJC9pLnRlc3QoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICd2bScgOiAnVk0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdubScgOiAnTk0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVmFuZGFnIG9tXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tNw7RyZSBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbb21dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0dpc3RlciBvbV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW0xhYXNdIGRkZGQgW29tXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnb29yICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgZ2VsZWRlJyxcbiAgICAgICAgICAgIHMgOiAnXFwnbiBwYWFyIHNla29uZGVzJyxcbiAgICAgICAgICAgIG0gOiAnXFwnbiBtaW51dXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlJyxcbiAgICAgICAgICAgIGggOiAnXFwnbiB1dXInLFxuICAgICAgICAgICAgaGggOiAnJWQgdXJlJyxcbiAgICAgICAgICAgIGQgOiAnXFwnbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFlJyxcbiAgICAgICAgICAgIE0gOiAnXFwnbiBtYWFuZCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtYWFuZGUnLFxuICAgICAgICAgICAgeSA6ICdcXCduIGphYXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgamFhcidcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3RlfGRlKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKChudW1iZXIgPT09IDEgfHwgbnVtYmVyID09PSA4IHx8IG51bWJlciA+PSAyMCkgPyAnc3RlJyA6ICdkZScpOyAvLyBUaGFua3MgdG8gSm9yaXMgUsO2bGluZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qanVwaXRlclxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTWFhbmRhZyBpcyBkaWUgZWVyc3RlIGRhZyB2YW4gZGllIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBEaWUgd2VlayB3YXQgZGllIDRkZSBKYW51YXJpZSBiZXZhdCBpcyBkaWUgZWVyc3RlIHdlZWsgdmFuIGRpZSBqYWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWY7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYWYuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgTG9jYWxlOiBBcmFiaWMgKGFyKVxuLy8hIEF1dGhvcjogQWJkZWwgU2FpZDogaHR0cHM6Ly9naXRodWIuY29tL2FiZGVsc2FpZFxuLy8hIENoYW5nZXMgaW4gbW9udGhzLCB3ZWVrZGF5czogQWhtZWQgRWxraGF0aWJcbi8vISBOYXRpdmUgcGx1cmFsIGZvcm1zOiBmb3JhYmkgaHR0cHM6Ly9naXRodWIuY29tL2ZvcmFiaVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgICcxJzogJ9mhJyxcbiAgICAgICAgJzInOiAn2aInLFxuICAgICAgICAnMyc6ICfZoycsXG4gICAgICAgICc0JzogJ9mkJyxcbiAgICAgICAgJzUnOiAn2aUnLFxuICAgICAgICAnNic6ICfZpicsXG4gICAgICAgICc3JzogJ9mnJyxcbiAgICAgICAgJzgnOiAn2agnLFxuICAgICAgICAnOSc6ICfZqScsXG4gICAgICAgICcwJzogJ9mgJ1xuICAgIH0sIG51bWJlck1hcCA9IHtcbiAgICAgICAgJ9mhJzogJzEnLFxuICAgICAgICAn2aInOiAnMicsXG4gICAgICAgICfZoyc6ICczJyxcbiAgICAgICAgJ9mkJzogJzQnLFxuICAgICAgICAn2aUnOiAnNScsXG4gICAgICAgICfZpic6ICc2JyxcbiAgICAgICAgJ9mnJzogJzcnLFxuICAgICAgICAn2agnOiAnOCcsXG4gICAgICAgICfZqSc6ICc5JyxcbiAgICAgICAgJ9mgJzogJzAnXG4gICAgfSwgcGx1cmFsRm9ybSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuID09PSAwID8gMCA6IG4gPT09IDEgPyAxIDogbiA9PT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDU7XG4gICAgfSwgcGx1cmFscyA9IHtcbiAgICAgICAgcyA6IFsn2KPZgtmEINmF2YYg2KvYp9mG2YrYqScsICfYq9in2YbZitipINmI2KfYrdiv2KknLCBbJ9ir2KfZhtmK2KrYp9mGJywgJ9ir2KfZhtmK2KrZitmGJ10sICclZCDYq9mI2KfZhicsICclZCDYq9in2YbZitipJywgJyVkINir2KfZhtmK2KknXSxcbiAgICAgICAgbSA6IFsn2KPZgtmEINmF2YYg2K/ZgtmK2YLYqScsICfYr9mC2YrZgtipINmI2KfYrdiv2KknLCBbJ9iv2YLZitmC2KrYp9mGJywgJ9iv2YLZitmC2KrZitmGJ10sICclZCDYr9mC2KfYptmCJywgJyVkINiv2YLZitmC2KknLCAnJWQg2K/ZgtmK2YLYqSddLFxuICAgICAgICBoIDogWyfYo9mC2YQg2YXZhiDYs9in2LnYqScsICfYs9in2LnYqSDZiNin2K3Yr9ipJywgWyfYs9in2LnYqtin2YYnLCAn2LPYp9i52KrZitmGJ10sICclZCDYs9in2LnYp9iqJywgJyVkINiz2KfYudipJywgJyVkINiz2KfYudipJ10sXG4gICAgICAgIGQgOiBbJ9ij2YLZhCDZhdmGINmK2YjZhScsICfZitmI2YUg2YjYp9it2K8nLCBbJ9mK2YjZhdin2YYnLCAn2YrZiNmF2YrZhiddLCAnJWQg2KPZitin2YUnLCAnJWQg2YrZiNmF2YvYpycsICclZCDZitmI2YUnXSxcbiAgICAgICAgTSA6IFsn2KPZgtmEINmF2YYg2LTZh9ixJywgJ9i02YfYsSDZiNin2K3YrycsIFsn2LTZh9ix2KfZhicsICfYtNmH2LHZitmGJ10sICclZCDYo9i02YfYsScsICclZCDYtNmH2LHYpycsICclZCDYtNmH2LEnXSxcbiAgICAgICAgeSA6IFsn2KPZgtmEINmF2YYg2LnYp9mFJywgJ9i52KfZhSDZiNin2K3YrycsIFsn2LnYp9mF2KfZhicsICfYudin2YXZitmGJ10sICclZCDYo9i52YjYp9mFJywgJyVkINi52KfZhdmL2KcnLCAnJWQg2LnYp9mFJ11cbiAgICB9LCBwbHVyYWxpemUgPSBmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgdmFyIGYgPSBwbHVyYWxGb3JtKG51bWJlciksXG4gICAgICAgICAgICAgICAgc3RyID0gcGx1cmFsc1t1XVtwbHVyYWxGb3JtKG51bWJlcildO1xuICAgICAgICAgICAgaWYgKGYgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHJbd2l0aG91dFN1ZmZpeCA/IDAgOiAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBtb250aHMgPSBbXG4gICAgICAgICfZg9in2YbZiNmGINin2YTYq9in2YbZiiDZitmG2KfZitixJyxcbiAgICAgICAgJ9i02KjYp9i3INmB2KjYsdin2YrYsScsXG4gICAgICAgICfYotiw2KfYsSDZhdin2LHYsycsXG4gICAgICAgICfZhtmK2LPYp9mGINij2KjYsdmK2YQnLFxuICAgICAgICAn2KPZitin2LEg2YXYp9mK2YgnLFxuICAgICAgICAn2K3YstmK2LHYp9mGINmK2YjZhtmK2YgnLFxuICAgICAgICAn2KrZhdmI2LIg2YrZiNmE2YrZiCcsXG4gICAgICAgICfYotioINij2LrYs9i32LMnLFxuICAgICAgICAn2KPZitmE2YjZhCDYs9io2KrZhdio2LEnLFxuICAgICAgICAn2KrYtNix2YrZhiDYp9mE2KPZiNmEINij2YPYqtmI2KjYsScsXG4gICAgICAgICfYqti02LHZitmGINin2YTYq9in2YbZiiDZhtmI2YHZhdio2LEnLFxuICAgICAgICAn2YPYp9mG2YjZhiDYp9mE2KPZiNmEINiv2YrYs9mF2KjYsSdcbiAgICBdO1xuXG4gICAgdmFyIGFyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXInLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHMsXG4gICAgICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnRC9cXHUyMDBGTS9cXHUyMDBGWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2LUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9mFJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2YvYpyDYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn2KjYudivICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcbiAgICAgICAgICAgIHMgOiBwbHVyYWxpemUoJ3MnKSxcbiAgICAgICAgICAgIG0gOiBwbHVyYWxpemUoJ20nKSxcbiAgICAgICAgICAgIG1tIDogcGx1cmFsaXplKCdtJyksXG4gICAgICAgICAgICBoIDogcGx1cmFsaXplKCdoJyksXG4gICAgICAgICAgICBoaCA6IHBsdXJhbGl6ZSgnaCcpLFxuICAgICAgICAgICAgZCA6IHBsdXJhbGl6ZSgnZCcpLFxuICAgICAgICAgICAgZGQgOiBwbHVyYWxpemUoJ2QnKSxcbiAgICAgICAgICAgIE0gOiBwbHVyYWxpemUoJ00nKSxcbiAgICAgICAgICAgIE1NIDogcGx1cmFsaXplKCdNJyksXG4gICAgICAgICAgICB5IDogcGx1cmFsaXplKCd5JyksXG4gICAgICAgICAgICB5eSA6IHBsdXJhbGl6ZSgneScpXG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcdTIwMGYvZywgJycpLnJlcGxhY2UoL1vZodmi2aPZpNml2abZp9mo2anZoF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC/YjC9nLCAnLCcpO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLywvZywgJ9iMJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2FyLmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IE1vcm9jY2FuIEFyYWJpYyAoYXItbWEpXG4vLyEgYXV0aG9yIDogRWxGYWRpbGkgWWFzc2luZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9FbEZhZGlsaVlcbi8vISBhdXRob3IgOiBBYmRlbCBTYWlkIDogaHR0cHM6Ly9naXRodWIuY29tL2FiZGVsc2FpZFxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBhcl9tYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLW1hJywge1xuICAgICAgICBtb250aHMgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2Ypf2YrZiNmG2YrZiF/ZitmI2YTZitmI2LJf2LrYtNiqX9i02KrZhtio2LFf2KPZg9iq2YjYqNixX9mG2YjZhtio2LFf2K/YrNmG2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2Ypf2YrZiNmG2YrZiF/ZitmI2YTZitmI2LJf2LrYtNiqX9i02KrZhtio2LFf2KPZg9iq2YjYqNixX9mG2YjZhtio2LFf2K/YrNmG2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYqtmG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9in2K3Yr1/Yp9iq2YbZitmGX9ir2YTYp9ir2KfYoV/Yp9ix2KjYudin2KFf2K7ZhdmK2LNf2KzZhdi52Klf2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfYrV/Zhl/Yq1/YsV/Yrl/YrF/Ysycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb2LrYr9inINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vYo9mF2LMg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfZgdmKICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcbiAgICAgICAgICAgIHMgOiAn2KvZiNin2YYnLFxuICAgICAgICAgICAgbSA6ICfYr9mC2YrZgtipJyxcbiAgICAgICAgICAgIG1tIDogJyVkINiv2YLYp9im2YInLFxuICAgICAgICAgICAgaCA6ICfYs9in2LnYqScsXG4gICAgICAgICAgICBoaCA6ICclZCDYs9in2LnYp9iqJyxcbiAgICAgICAgICAgIGQgOiAn2YrZiNmFJyxcbiAgICAgICAgICAgIGRkIDogJyVkINij2YrYp9mFJyxcbiAgICAgICAgICAgIE0gOiAn2LTZh9ixJyxcbiAgICAgICAgICAgIE1NIDogJyVkINij2LTZh9ixJyxcbiAgICAgICAgICAgIHkgOiAn2LPZhtipJyxcbiAgICAgICAgICAgIHl5IDogJyVkINiz2YbZiNin2KonXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyX21hO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2FyLW1hLmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IEFyYWJpYyBTYXVkaSBBcmFiaWEgKGFyLXNhKVxuLy8hIGF1dGhvciA6IFN1aGFpbCBBbGtvd2FpbGVldCA6IGh0dHBzOi8vZ2l0aHViLmNvbS94c29oXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn2aEnLFxuICAgICAgICAnMic6ICfZoicsXG4gICAgICAgICczJzogJ9mjJyxcbiAgICAgICAgJzQnOiAn2aQnLFxuICAgICAgICAnNSc6ICfZpScsXG4gICAgICAgICc2JzogJ9mmJyxcbiAgICAgICAgJzcnOiAn2acnLFxuICAgICAgICAnOCc6ICfZqCcsXG4gICAgICAgICc5JzogJ9mpJyxcbiAgICAgICAgJzAnOiAn2aAnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn2aEnOiAnMScsXG4gICAgICAgICfZoic6ICcyJyxcbiAgICAgICAgJ9mjJzogJzMnLFxuICAgICAgICAn2aQnOiAnNCcsXG4gICAgICAgICfZpSc6ICc1JyxcbiAgICAgICAgJ9mmJzogJzYnLFxuICAgICAgICAn2acnOiAnNycsXG4gICAgICAgICfZqCc6ICc4JyxcbiAgICAgICAgJ9mpJzogJzknLFxuICAgICAgICAn2aAnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGFyX3NhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItc2EnLCB7XG4gICAgICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZitmIX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiF/Yo9i62LPYt9izX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2YrZiF/ZitmI2YbZitmIX9mK2YjZhNmK2Yhf2KPYutiz2LfYs1/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2LUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9mFJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgcyA6ICfYq9mI2KfZhicsXG4gICAgICAgICAgICBtIDogJ9iv2YLZitmC2KknLFxuICAgICAgICAgICAgbW0gOiAnJWQg2K/Zgtin2KbZgicsXG4gICAgICAgICAgICBoIDogJ9iz2KfYudipJyxcbiAgICAgICAgICAgIGhoIDogJyVkINiz2KfYudin2KonLFxuICAgICAgICAgICAgZCA6ICfZitmI2YUnLFxuICAgICAgICAgICAgZGQgOiAnJWQg2KPZitin2YUnLFxuICAgICAgICAgICAgTSA6ICfYtNmH2LEnLFxuICAgICAgICAgICAgTU0gOiAnJWQg2KPYtNmH2LEnLFxuICAgICAgICAgICAgeSA6ICfYs9mG2KknLFxuICAgICAgICAgICAgeXkgOiAnJWQg2LPZhtmI2KfYqidcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW9mh2aLZo9mk2aXZptmn2ajZqdmgXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvLC9nLCAn2IwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJfc2E7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYXItc2EuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlICA6IFR1bmlzaWFuIEFyYWJpYyAoYXItdG4pXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGFyX3RuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItdG4nLCB7XG4gICAgICAgIG1vbnRoczogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfYrNin2YbZgdmKX9mB2YrZgdix2Ypf2YXYp9ix2LNf2KPZgdix2YrZhF/Zhdin2Ypf2KzZiNin2YZf2KzZiNmK2YTZitipX9ij2YjYql/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzOiAn2KfZhNij2K3Yr1/Yp9mE2KXYq9mG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICfZgdmKICVzJyxcbiAgICAgICAgICAgIHBhc3Q6ICfZhdmG2LAgJXMnLFxuICAgICAgICAgICAgczogJ9ir2YjYp9mGJyxcbiAgICAgICAgICAgIG06ICfYr9mC2YrZgtipJyxcbiAgICAgICAgICAgIG1tOiAnJWQg2K/Zgtin2KbZgicsXG4gICAgICAgICAgICBoOiAn2LPYp9i52KknLFxuICAgICAgICAgICAgaGg6ICclZCDYs9in2LnYp9iqJyxcbiAgICAgICAgICAgIGQ6ICfZitmI2YUnLFxuICAgICAgICAgICAgZGQ6ICclZCDYo9mK2KfZhScsXG4gICAgICAgICAgICBNOiAn2LTZh9ixJyxcbiAgICAgICAgICAgIE1NOiAnJWQg2KPYtNmH2LEnLFxuICAgICAgICAgICAgeTogJ9iz2YbYqScsXG4gICAgICAgICAgICB5eTogJyVkINiz2YbZiNin2KonXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3k6IDQgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJfdG47XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYXItdG4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogYXplcmJhaWphbmkgKGF6KVxuLy8hIGF1dGhvciA6IHRvcGNoaXlldiA6IGh0dHBzOi8vZ2l0aHViLmNvbS90b3BjaGl5ZXZcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3VmZml4ZXMgPSB7XG4gICAgICAgIDE6ICctaW5jaScsXG4gICAgICAgIDU6ICctaW5jaScsXG4gICAgICAgIDg6ICctaW5jaScsXG4gICAgICAgIDcwOiAnLWluY2knLFxuICAgICAgICA4MDogJy1pbmNpJyxcbiAgICAgICAgMjogJy1uY2knLFxuICAgICAgICA3OiAnLW5jaScsXG4gICAgICAgIDIwOiAnLW5jaScsXG4gICAgICAgIDUwOiAnLW5jaScsXG4gICAgICAgIDM6ICctw7xuY8O8JyxcbiAgICAgICAgNDogJy3DvG5jw7wnLFxuICAgICAgICAxMDA6ICctw7xuY8O8JyxcbiAgICAgICAgNjogJy1uY8SxJyxcbiAgICAgICAgOTogJy11bmN1JyxcbiAgICAgICAgMTA6ICctdW5jdScsXG4gICAgICAgIDMwOiAnLXVuY3UnLFxuICAgICAgICA2MDogJy3EsW5jxLEnLFxuICAgICAgICA5MDogJy3EsW5jxLEnXG4gICAgfTtcblxuICAgIHZhciBheiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2F6Jywge1xuICAgICAgICBtb250aHMgOiAneWFudmFyX2ZldnJhbF9tYXJ0X2FwcmVsX21heV9peXVuX2l5dWxfYXZxdXN0X3NlbnR5YWJyX29rdHlhYnJfbm95YWJyX2Rla2Ficicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAneWFuX2Zldl9tYXJfYXByX21heV9peW5faXlsX2F2cV9zZW5fb2t0X25veV9kZWsnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0JhemFyX0JhemFyIGVydMmZc2lfw4fJmXLFn8mZbmLJmSBheMWfYW3EsV/Dh8mZcsWfyZluYsmZX0PDvG3JmSBheMWfYW3EsV9Dw7xtyZlfxZ7JmW5iyZknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnQmF6X0J6RV/Dh0F4X8OHyZlyX0NBeF9Dw7xtX8WeyZluJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdCel9CRV/Dh0Ffw4fJmV9DQV9Dw7xfxZ7JmScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW2J1Z8O8biBzYWF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tzYWJhaCBzYWF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdbZ8mZbMmZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tkw7xuyZluXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdba2XDp8mZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgc29ucmEnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDJmXZ2yZlsJyxcbiAgICAgICAgICAgIHMgOiAnYmlybmXDp8mZIHNhbml5ecmZJyxcbiAgICAgICAgICAgIG0gOiAnYmlyIGTJmXFpccmZJyxcbiAgICAgICAgICAgIG1tIDogJyVkIGTJmXFpccmZJyxcbiAgICAgICAgICAgIGggOiAnYmlyIHNhYXQnLFxuICAgICAgICAgICAgaGggOiAnJWQgc2FhdCcsXG4gICAgICAgICAgICBkIDogJ2JpciBnw7xuJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGfDvG4nLFxuICAgICAgICAgICAgTSA6ICdiaXIgYXknLFxuICAgICAgICAgICAgTU0gOiAnJWQgYXknLFxuICAgICAgICAgICAgeSA6ICdiaXIgaWwnLFxuICAgICAgICAgICAgeXkgOiAnJWQgaWwnXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC9nZWPJmXxzyZloyZlyfGfDvG5kw7x6fGF4xZ9hbS8sXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXihnw7xuZMO8enxheMWfYW0pJC8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdnZWPJmSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc8mZaMmZcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZ8O8bmTDvHonO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2F4xZ9hbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjEsW5jxLF8aW5jaXxuY2l8w7xuY8O8fG5jxLF8dW5jdSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMCkgeyAgLy8gc3BlY2lhbCBjYXNlIGZvciB6ZXJvXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICctxLFuY8SxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXG4gICAgICAgICAgICAgICAgYyA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSB8fCBzdWZmaXhlc1tjXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF6O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2F6LmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGJlbGFydXNpYW4gKGJlKVxuLy8hIGF1dGhvciA6IERtaXRyeSBEZW1pZG92IDogaHR0cHM6Ly9naXRodWIuY29tL2RlbWlkb3Y5MVxuLy8hIGF1dGhvcjogUHJhbGVza2E6IGh0dHA6Ly9wcmFsZXNrYS5wcm8vXG4vLyEgQXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ21tJzogd2l0aG91dFN1ZmZpeCA/ICfRhdCy0ZbQu9GW0L3QsF/RhdCy0ZbQu9GW0L3Ri1/RhdCy0ZbQu9GW0L0nIDogJ9GF0LLRltC70ZbQvdGDX9GF0LLRltC70ZbQvdGLX9GF0LLRltC70ZbQvScsXG4gICAgICAgICAgICAnaGgnOiB3aXRob3V0U3VmZml4ID8gJ9Cz0LDQtNC30ZbQvdCwX9Cz0LDQtNC30ZbQvdGLX9Cz0LDQtNC30ZbQvScgOiAn0LPQsNC00LfRltC90YNf0LPQsNC00LfRltC90Ytf0LPQsNC00LfRltC9JyxcbiAgICAgICAgICAgICdkZCc6ICfQtNC30LXQvdGMX9C00L3Rll/QtNC30ZHQvScsXG4gICAgICAgICAgICAnTU0nOiAn0LzQtdGB0Y/Rhl/QvNC10YHRj9GG0Ytf0LzQtdGB0Y/RhtCw0Z4nLFxuICAgICAgICAgICAgJ3l5JzogJ9Cz0L7QtF/Qs9Cw0LTRi1/Qs9Cw0LTQvtGeJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoa2V5ID09PSAnbScpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9GF0LLRltC70ZbQvdCwJyA6ICfRhdCy0ZbQu9GW0L3Rgyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnaCcpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9Cz0LDQtNC30ZbQvdCwJyA6ICfQs9Cw0LTQt9GW0L3Rgyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgcGx1cmFsKGZvcm1hdFtrZXldLCArbnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb250aHNDYXNlUmVwbGFjZShtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIG1vbnRocyA9IHtcbiAgICAgICAgICAgICdub21pbmF0aXZlJzogJ9GB0YLRg9C00LfQtdC90Yxf0LvRjtGC0Ytf0YHQsNC60LDQstGW0Lpf0LrRgNCw0YHQsNCy0ZbQul/RgtGA0LDQstC10L3RjF/Rh9GN0YDQstC10L3RjF/Qu9GW0L/QtdC90Yxf0LbQvdGW0LLQtdC90Yxf0LLQtdGA0LDRgdC10L3RjF/QutCw0YHRgtGA0YvRh9C90ZbQul/Qu9GW0YHRgtCw0L/QsNC0X9GB0L3QtdC20LDQvdGMJy5zcGxpdCgnXycpLFxuICAgICAgICAgICAgJ2FjY3VzYXRpdmUnOiAn0YHRgtGD0LTQt9C10L3Rj1/Qu9GO0YLQsNCz0LBf0YHQsNC60LDQstGW0LrQsF/QutGA0LDRgdCw0LLRltC60LBf0YLRgNCw0Z7QvdGPX9GH0Y3RgNCy0LXQvdGPX9C70ZbQv9C10L3Rj1/QttC90ZbRntC90Y9f0LLQtdGA0LDRgdC90Y9f0LrQsNGB0YLRgNGL0YfQvdGW0LrQsF/Qu9GW0YHRgtCw0L/QsNC00LBf0YHQvdC10LbQvdGPJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdW5DYXNlID0gKC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgJ25vbWluYXRpdmUnO1xuICAgICAgICByZXR1cm4gbW9udGhzW25vdW5DYXNlXVttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfQvdGP0LTQt9C10LvRj1/Qv9Cw0L3Rj9C00LfQtdC70LDQul/QsNGe0YLQvtGA0LDQul/RgdC10YDQsNC00LBf0YfQsNGG0LLQtdGAX9C/0Y/RgtC90ZbRhtCwX9GB0YPQsdC+0YLQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgICdhY2N1c2F0aXZlJzogJ9C90Y/QtNC30LXQu9GOX9C/0LDQvdGP0LTQt9C10LvQsNC6X9Cw0Z7RgtC+0YDQsNC6X9GB0LXRgNCw0LTRg1/Rh9Cw0YbQstC10YBf0L/Rj9GC0L3RltGG0YNf0YHRg9Cx0L7RgtGDJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdW5DYXNlID0gKC9cXFsgP1vQktCyXSA/KD860LzRltC90YPQu9GD0Y580L3QsNGB0YLRg9C/0L3Rg9GOKT8gP1xcXSA/ZGRkZC8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgJ25vbWluYXRpdmUnO1xuICAgICAgICByZXR1cm4gd2Vla2RheXNbbm91bkNhc2VdW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBiZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JlJywge1xuICAgICAgICBtb250aHMgOiBtb250aHNDYXNlUmVwbGFjZSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn0YHRgtGD0LRf0LvRjtGCX9GB0LDQul/QutGA0LDRgV/RgtGA0LDQsl/Rh9GN0YDQsl/Qu9GW0L9f0LbQvdGW0LJf0LLQtdGAX9C60LDRgdGCX9C70ZbRgdGCX9GB0L3QtdC2Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6IHdlZWtkYXlzQ2FzZVJlcGxhY2UsXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0L3QtF/Qv9C9X9Cw0YJf0YHRgF/Rh9GGX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0L3QtF/Qv9C9X9Cw0YJf0YHRgF/Rh9GGX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZINCzLicsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg0LMuLCBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZINCzLiwgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vQodGR0L3QvdGPINGeXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9CX0LDRntGC0YDQsCDRnl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vQo9GH0L7RgNCwINGeXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW9CjXSBkZGRkIFvRnl0gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQoyDQvNGW0L3Rg9C70YPRjl0gZGRkZCBb0Z5dIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0KMg0LzRltC90YPQu9GLXSBkZGRkIFvRnl0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfQv9GA0LDQtyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzINGC0LDQvNGDJyxcbiAgICAgICAgICAgIHMgOiAn0L3QtdC60LDQu9GM0LrRliDRgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGQgOiAn0LTQt9C10L3RjCcsXG4gICAgICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBNIDogJ9C80LXRgdGP0YYnLFxuICAgICAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgeSA6ICfQs9C+0LQnLFxuICAgICAgICAgICAgeXkgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/QvdC+0YfRi3zRgNCw0L3RltGG0Yt80LTQvdGPfNCy0LXRh9Cw0YDQsC8sXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXijQtNC90Y980LLQtdGH0LDRgNCwKSQvLnRlc3QoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0L3QvtGH0YsnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9GA0LDQvdGW0YbRiyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0LTQvdGPJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQstC10YfQsNGA0LAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0ZZ80Yt80LPQsCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChudW1iZXIgJSAxMCA9PT0gMiB8fCBudW1iZXIgJSAxMCA9PT0gMykgJiYgKG51bWJlciAlIDEwMCAhPT0gMTIgJiYgbnVtYmVyICUgMTAwICE9PSAxMykgPyBudW1iZXIgKyAnLdGWJyA6IG51bWJlciArICct0YsnO1xuICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LPQsCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJlO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2JlLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGJ1bGdhcmlhbiAoYmcpXG4vLyEgYXV0aG9yIDogS3Jhc2VuIEJvcmlzb3YgOiBodHRwczovL2dpdGh1Yi5jb20va3JhelxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBiZyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JnJywge1xuICAgICAgICBtb250aHMgOiAn0Y/QvdGD0LDRgNC4X9GE0LXQstGA0YPQsNGA0Lhf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Llf0Y7QvdC4X9GO0LvQuF/QsNCy0LPRg9GB0YJf0YHQtdC/0YLQtdC80LLRgNC4X9C+0LrRgtC+0LzQstGA0Lhf0L3QvtC10LzQstGA0Lhf0LTQtdC60LXQvNCy0YDQuCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn0Y/QvdGAX9GE0LXQsl/QvNCw0YBf0LDQv9GAX9C80LDQuV/RjtC90Lhf0Y7Qu9C4X9Cw0LLQs1/RgdC10L9f0L7QutGCX9C90L7QtV/QtNC10LonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9C90LXQtNC10LvRj1/Qv9C+0L3QtdC00LXQu9C90LjQul/QstGC0L7RgNC90LjQul/RgdGA0Y/QtNCwX9GH0LXRgtCy0YrRgNGC0YrQul/Qv9C10YLRitC6X9GB0YrQsdC+0YLQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfQvdC10LRf0L/QvtC9X9Cy0YLQvl/RgdGA0Y9f0YfQtdGCX9C/0LXRgl/RgdGK0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9C90LRf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0QuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb0JTQvdC10YEg0LJdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW9Cj0YLRgNC1INCyXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvQsl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb0JLRh9C10YDQsCDQsl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC40LfQvNC40L3QsNC70LDRgtCwXSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0LjQt9C80LjQvdCw0LvQuNGPXSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn0YHQu9C10LQgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfQv9GA0LXQtNC4ICVzJyxcbiAgICAgICAgICAgIHMgOiAn0L3Rj9C60L7Qu9C60L4g0YHQtdC60YPQvdC00LgnLFxuICAgICAgICAgICAgbSA6ICfQvNC40L3Rg9GC0LAnLFxuICAgICAgICAgICAgbW0gOiAnJWQg0LzQuNC90YPRgtC4JyxcbiAgICAgICAgICAgIGggOiAn0YfQsNGBJyxcbiAgICAgICAgICAgIGhoIDogJyVkINGH0LDRgdCwJyxcbiAgICAgICAgICAgIGQgOiAn0LTQtdC9JyxcbiAgICAgICAgICAgIGRkIDogJyVkINC00L3QuCcsXG4gICAgICAgICAgICBNIDogJ9C80LXRgdC10YYnLFxuICAgICAgICAgICAgTU0gOiAnJWQg0LzQtdGB0LXRhtCwJyxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC00LjQvdCwJyxcbiAgICAgICAgICAgIHl5IDogJyVkINCz0L7QtNC40L3QuCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNC10LJ80LXQvXzRgtC4fNCy0Lh80YDQuHzQvNC4KS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdERpZ2l0ID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgbGFzdDJEaWdpdHMgPSBudW1iZXIgJSAxMDA7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQsic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQvSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID4gMTAgJiYgbGFzdDJEaWdpdHMgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGC0LgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QstC4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YDQuCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNyB8fCBsYXN0RGlnaXQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QvNC4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJnO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2JnLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IEJlbmdhbGkgKGJuKVxuLy8hIGF1dGhvciA6IEthdXNoaWsgR2FuZGhpIDogaHR0cHM6Ly9naXRodWIuY29tL2thdXNoaWtnYW5kaGlcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfgp6cnLFxuICAgICAgICAnMic6ICfgp6gnLFxuICAgICAgICAnMyc6ICfgp6knLFxuICAgICAgICAnNCc6ICfgp6onLFxuICAgICAgICAnNSc6ICfgp6snLFxuICAgICAgICAnNic6ICfgp6wnLFxuICAgICAgICAnNyc6ICfgp60nLFxuICAgICAgICAnOCc6ICfgp64nLFxuICAgICAgICAnOSc6ICfgp68nLFxuICAgICAgICAnMCc6ICfgp6YnXG4gICAgfSxcbiAgICBudW1iZXJNYXAgPSB7XG4gICAgICAgICfgp6cnOiAnMScsXG4gICAgICAgICfgp6gnOiAnMicsXG4gICAgICAgICfgp6knOiAnMycsXG4gICAgICAgICfgp6onOiAnNCcsXG4gICAgICAgICfgp6snOiAnNScsXG4gICAgICAgICfgp6wnOiAnNicsXG4gICAgICAgICfgp60nOiAnNycsXG4gICAgICAgICfgp64nOiAnOCcsXG4gICAgICAgICfgp68nOiAnOScsXG4gICAgICAgICfgp6YnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGJuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYm4nLCB7XG4gICAgICAgIG1vbnRocyA6ICfgppzgpr7gpqjgp4Hgp5/gpr7gprDgp4Bf4Kar4KeH4Kas4KeB4Kef4Ka+4Kaw4KeAX+CmruCmvuCmsOCnjeCmml/gpo/gpqrgp43gprDgpr/gprJf4Kau4KeHX+CmnOCngeCmqF/gppzgp4HgprLgpr7gpodf4KaF4KaX4Ka+4Ka44KeN4KafX+CmuOCnh+CmquCnjeCmn+Cnh+CmruCnjeCmrOCmsF/gpoXgppXgp43gpp/gp4vgpqzgprBf4Kao4Kat4KeH4Kau4KeN4Kas4KawX+CmoeCmv+CmuOCnh+CmruCnjeCmrOCmsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4Kac4Ka+4Kao4KeBX+Cmq+Cnh+CmrF/gpq7gpr7gprDgp43gpppf4KaP4Kaq4KawX+CmruCnh1/gppzgp4Hgpqhf4Kac4KeB4KayX+CmheCml1/gprjgp4fgpqrgp43gpp9f4KaF4KaV4KeN4Kaf4KeLX+CmqOCmrV/gpqHgpr/gprjgp4fgpq7gp40nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+CmsOCmrOCmv+CmrOCmvuCmsF/gprjgp4vgpq7gpqzgpr7gprBf4Kau4KaZ4KeN4KaX4Kay4Kas4Ka+4KawX+CmrOCngeCmp+CmrOCmvuCmsF/gpqzgp4Pgprngprjgp43gpqrgpqTgp43gpqTgpr/gpqzgpr7gprBf4Ka24KeB4KaV4KeN4Kaw4KeB4Kas4Ka+4KawX+CmtuCmqOCmv+CmrOCmvuCmsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgprDgpqzgpr9f4Ka44KeL4KauX+CmruCmmeCnjeCml+Cmsl/gpqzgp4Hgpqdf4Kas4KeD4Ka54Ka44KeN4Kaq4Kak4KeN4Kak4Ka/X+CmtuCngeCmleCnjeCmsOCngV/gprbgpqjgpr8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CmsOCmrF/gprjgpq5f4Kau4KaZ4KeN4KaXX+CmrOCngV/gpqzgp43gprDgpr/gprlf4Ka24KeBX+CmtuCmqOCmvycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0g4Ka44Kau4KefJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4Ka44Kau4KefJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgprjgpq7gp58nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCmuOCmruCnnydcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgpobgppxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CmhuCml+CmvuCmruCngOCmleCmvuCmsl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KaX4Kak4KaV4Ka+4KayXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4KaX4KakXSBkZGRkLCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg4Kaq4Kaw4KeHJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg4KaG4KaX4KeHJyxcbiAgICAgICAgICAgIHMgOiAn4KaV4KaP4KaVIOCmuOCnh+CmleCnh+CmqOCnjeCmoScsXG4gICAgICAgICAgICBtIDogJ+Cmj+CmlSDgpq7gpr/gpqjgpr/gpp8nLFxuICAgICAgICAgICAgbW0gOiAnJWQg4Kau4Ka/4Kao4Ka/4KafJyxcbiAgICAgICAgICAgIGggOiAn4KaP4KaVIOCmmOCmqOCnjeCmn+CmvicsXG4gICAgICAgICAgICBoaCA6ICclZCDgppjgpqjgp43gpp/gpr4nLFxuICAgICAgICAgICAgZCA6ICfgpo/gppUg4Kam4Ka/4KaoJyxcbiAgICAgICAgICAgIGRkIDogJyVkIOCmpuCmv+CmqCcsXG4gICAgICAgICAgICBNIDogJ+Cmj+CmlSDgpq7gpr7gprgnLFxuICAgICAgICAgICAgTU0gOiAnJWQg4Kau4Ka+4Ka4JyxcbiAgICAgICAgICAgIHkgOiAn4KaP4KaVIOCmrOCmm+CmsCcsXG4gICAgICAgICAgICB5eSA6ICclZCDgpqzgppvgprAnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgp6fgp6jgp6ngp6rgp6vgp6zgp63gp67gp6/gp6ZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/gprDgpr7gpqR84Ka44KaV4Ka+4KayfOCmpuCngeCmquCngeCmsHzgpqzgpr/gppXgp4fgprJ84Kaw4Ka+4KakLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o4Kam4KeB4Kaq4KeB4KawfOCmrOCmv+CmleCnh+CmsnzgprDgpr7gpqQpJC8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vQmVuZ2FsaSBpcyBhIHZhc3QgbGFuZ3VhZ2UgaXRzIHNwb2tlblxuICAgICAgICAvL2luIGRpZmZlcmVudCBmb3JtcyBpbiB2YXJpb3VzIHBhcnRzIG9mIHRoZSB3b3JsZC5cbiAgICAgICAgLy9JIGhhdmUganVzdCBnZW5lcmFsaXplZCB3aXRoIG1vc3QgY29tbW9uIG9uZSB1c2VkXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgprDgpr7gpqQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CmuOCmleCmvuCmsic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Kam4KeB4Kaq4KeB4KawJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpqzgpr/gppXgp4fgprInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CmsOCmvuCmpCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJuO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2JuLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHRpYmV0YW4gKGJvKVxuLy8hIGF1dGhvciA6IFRodXB0ZW4gTi4gQ2hha3Jpc2hhciA6IGh0dHBzOi8vZ2l0aHViLmNvbS92YWpyYWRvZ1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgICcxJzogJ+C8oScsXG4gICAgICAgICcyJzogJ+C8oicsXG4gICAgICAgICczJzogJ+C8oycsXG4gICAgICAgICc0JzogJ+C8pCcsXG4gICAgICAgICc1JzogJ+C8pScsXG4gICAgICAgICc2JzogJ+C8picsXG4gICAgICAgICc3JzogJ+C8pycsXG4gICAgICAgICc4JzogJ+C8qCcsXG4gICAgICAgICc5JzogJ+C8qScsXG4gICAgICAgICcwJzogJ+C8oCdcbiAgICB9LFxuICAgIG51bWJlck1hcCA9IHtcbiAgICAgICAgJ+C8oSc6ICcxJyxcbiAgICAgICAgJ+C8oic6ICcyJyxcbiAgICAgICAgJ+C8oyc6ICczJyxcbiAgICAgICAgJ+C8pCc6ICc0JyxcbiAgICAgICAgJ+C8pSc6ICc1JyxcbiAgICAgICAgJ+C8pic6ICc2JyxcbiAgICAgICAgJ+C8pyc6ICc3JyxcbiAgICAgICAgJ+C8qCc6ICc4JyxcbiAgICAgICAgJ+C8qSc6ICc5JyxcbiAgICAgICAgJ+C8oCc6ICcwJ1xuICAgIH07XG5cbiAgICB2YXIgYm8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdibycsIHtcbiAgICAgICAgbW9udGhzIDogJ+C9n+C+s+C8i+C9luC8i+C9keC9hOC8i+C9lOC9vF/gvZ/gvrPgvIvgvZbgvIvgvYLgvYngvbLgvabgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2C4L2m4L204L2Y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9nuC9suC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvaPgvpTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L6y4L204L2C4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9keC9tOC9k+C8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvaLgvpLgvrHgvZHgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L2C4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYXgvbLgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2C4L2J4L2y4L2m4LyL4L2UJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfgvZ/gvrPgvIvgvZbgvIvgvZHgvYTgvIvgvZTgvbxf4L2f4L6z4LyL4L2W4LyL4L2C4L2J4L2y4L2m4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9guC9puC9tOC9mOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvZ7gvbLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2j4L6U4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9keC+suC9tOC9guC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvZHgvbTgvZPgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2i4L6S4L6x4L2R4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9keC9guC9tOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2C4L2F4L2y4L2C4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9guC9ieC9suC9puC8i+C9lCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn4L2C4L2f4L2g4LyL4L2J4L2y4LyL4L2Y4LyLX+C9guC9n+C9oOC8i+C9n+C+s+C8i+C9luC8i1/gvYLgvZ/gvaDgvIvgvZjgvbLgvYLgvIvgvZHgvZjgvaLgvItf4L2C4L2f4L2g4LyL4L2j4L634L2C4LyL4L2U4LyLX+C9guC9n+C9oOC8i+C9leC9tOC9ouC8i+C9luC9tF/gvYLgvZ/gvaDgvIvgvZTgvIvgvabgvYTgvabgvItf4L2C4L2f4L2g4LyL4L2m4L6k4L264L2T4LyL4L2U4LyLJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+C9ieC9suC8i+C9mOC8i1/gvZ/gvrPgvIvgvZbgvItf4L2Y4L2y4L2C4LyL4L2R4L2Y4L2i4LyLX+C9o+C+t+C9guC8i+C9lOC8i1/gvZXgvbTgvaLgvIvgvZbgvbRf4L2U4LyL4L2m4L2E4L2m4LyLX+C9puC+pOC9uuC9k+C8i+C9lOC8iycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4L2J4L2y4LyL4L2Y4LyLX+C9n+C+s+C8i+C9luC8i1/gvZjgvbLgvYLgvIvgvZHgvZjgvaLgvItf4L2j4L634L2C4LyL4L2U4LyLX+C9leC9tOC9ouC8i+C9luC9tF/gvZTgvIvgvabgvYTgvabgvItf4L2m4L6k4L264L2T4LyL4L2U4LyLJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0EgaDptbScsXG4gICAgICAgICAgICBMVFMgOiAnQSBoOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4L2R4L2y4LyL4L2i4L2y4L2EXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgvabgvYTgvIvgvYngvbLgvZNdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vgvZbgvZHgvbTgvZPgvIvgvZXgvrLgvYLgvIvgvaLgvpfgvbrgvabgvIvgvZhdLCBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vgvYHgvIvgvabgvYRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vgvZbgvZHgvbTgvZPgvIvgvZXgvrLgvYLgvIvgvZjgvZDgvaDgvIvgvZhdIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDgvaPgvIsnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDgvabgvpTgvZPgvIvgvaMnLFxuICAgICAgICAgICAgcyA6ICfgvaPgvZjgvIvgvabgvYQnLFxuICAgICAgICAgICAgbSA6ICfgvabgvpDgvaLgvIvgvZjgvIvgvYLgvYXgvbLgvYInLFxuICAgICAgICAgICAgbW0gOiAnJWQg4L2m4L6Q4L2i4LyL4L2YJyxcbiAgICAgICAgICAgIGggOiAn4L2G4L204LyL4L2a4L284L2R4LyL4L2C4L2F4L2y4L2CJyxcbiAgICAgICAgICAgIGhoIDogJyVkIOC9huC9tOC8i+C9muC9vOC9kScsXG4gICAgICAgICAgICBkIDogJ+C9ieC9suC9k+C8i+C9guC9heC9suC9gicsXG4gICAgICAgICAgICBkZCA6ICclZCDgvYngvbLgvZPgvIsnLFxuICAgICAgICAgICAgTSA6ICfgvZ/gvrPgvIvgvZbgvIvgvYLgvYXgvbLgvYInLFxuICAgICAgICAgICAgTU0gOiAnJWQg4L2f4L6z4LyL4L2WJyxcbiAgICAgICAgICAgIHkgOiAn4L2j4L284LyL4L2C4L2F4L2y4L2CJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOC9o+C9vCdcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+C8oeC8ouC8o+C8pOC8peC8puC8p+C8qOC8qeC8oF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+C9mOC9muC9k+C8i+C9mOC9vHzgvZ7gvbzgvYLgvabgvIvgvYDgvaZ84L2J4L2y4L2T4LyL4L2C4L204L2EfOC9keC9guC9vOC9hOC8i+C9keC9gnzgvZjgvZrgvZPgvIvgvZjgvbwvLFxuICAgICAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXijgvYngvbLgvZPgvIvgvYLgvbTgvYR84L2R4L2C4L284L2E4LyL4L2R4L2CfOC9mOC9muC9k+C8i+C9mOC9vCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C9mOC9muC9k+C8i+C9mOC9vCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4L2e4L284L2C4L2m4LyL4L2A4L2mJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgvYngvbLgvZPgvIvgvYLgvbTgvYQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C9keC9guC9vOC9hOC8i+C9keC9gic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4L2Y4L2a4L2T4LyL4L2Y4L28JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm87XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvYm8uanNcbiAqKiBtb2R1bGUgaWQgPSAyMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogYnJldG9uIChicilcbi8vISBhdXRob3IgOiBKZWFuLUJhcHRpc3RlIExlIER1aWdvdSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYmxlZHVpZ291XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB7XG4gICAgICAgICAgICAnbW0nOiAnbXVudXRlbm4nLFxuICAgICAgICAgICAgJ01NJzogJ21peicsXG4gICAgICAgICAgICAnZGQnOiAnZGV2ZXpoJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgbXV0YXRpb24oZm9ybWF0W2tleV0sIG51bWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwZWNpYWxNdXRhdGlvbkZvclllYXJzKG51bWJlcikge1xuICAgICAgICBzd2l0Y2ggKGxhc3ROdW1iZXIobnVtYmVyKSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnIGJsb2F6JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnIHZsb2F6JztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYXN0TnVtYmVyKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3ROdW1iZXIobnVtYmVyICUgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11dGF0aW9uKHRleHQsIG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gc29mdE11dGF0aW9uKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzb2Z0TXV0YXRpb24odGV4dCkge1xuICAgICAgICB2YXIgbXV0YXRpb25UYWJsZSA9IHtcbiAgICAgICAgICAgICdtJzogJ3YnLFxuICAgICAgICAgICAgJ2InOiAndicsXG4gICAgICAgICAgICAnZCc6ICd6J1xuICAgICAgICB9O1xuICAgICAgICBpZiAobXV0YXRpb25UYWJsZVt0ZXh0LmNoYXJBdCgwKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11dGF0aW9uVGFibGVbdGV4dC5jaGFyQXQoMCldICsgdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgdmFyIGJyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYnInLCB7XG4gICAgICAgIG1vbnRocyA6ICdHZW52ZXJfQ1xcJ2h3ZXZyZXJfTWV1cnpoX0VicmVsX01hZV9NZXpoZXZlbl9Hb3VlcmVfRW9zdF9Hd2VuZ29sb19IZXJlX0R1X0tlcnp1Jy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdHZW5fQ1xcJ2h3ZV9NZXVfRWJyX01hZV9FdmVfR291X0Vvc19Hd2VfSGVyX0R1X0tlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnU3VsX0x1bl9NZXVyemhfTWVyY1xcJ2hlcl9ZYW91X0d3ZW5lcl9TYWRvcm4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU3VsX0x1bl9NZXVfTWVyX1lhb19Hd2VfU2FkJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTdV9MdV9NZV9NZXJfWWFfR3dfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaFtlXW1tIEEnLFxuICAgICAgICAgICAgTFRTIDogJ2hbZV1tbTpzcyBBJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFthIHZpel0gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIFthIHZpel0gTU1NTSBZWVlZIGhbZV1tbSBBJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBbYSB2aXpdIE1NTU0gWVlZWSBoW2VdbW0gQSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tIaXppdiBkYV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbV2FyY1xcJ2hvYXpoIGRhXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtkYV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbRGVjXFwnaCBkYV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbcGFzZXQgZGFdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdhLWJlbm4gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBcXCd6bycsXG4gICAgICAgICAgICBzIDogJ3VuIG5lYmV1ZCBzZWdvbmRlbm5vw7knLFxuICAgICAgICAgICAgbSA6ICd1ciB2dW51dGVubicsXG4gICAgICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhNdXRhdGlvbixcbiAgICAgICAgICAgIGggOiAndW4gZXVyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGV1cicsXG4gICAgICAgICAgICBkIDogJ3VuIGRldmV6aCcsXG4gICAgICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhNdXRhdGlvbixcbiAgICAgICAgICAgIE0gOiAndXIgbWl6JyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uLFxuICAgICAgICAgICAgeSA6ICd1ciBibG9heicsXG4gICAgICAgICAgICB5eSA6IHNwZWNpYWxNdXRhdGlvbkZvclllYXJzXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGHDsXx2ZXQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdhw7EnIDogJ3ZldCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBicjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9ici5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBib3NuaWFuIChicylcbi8vISBhdXRob3IgOiBOZWRpbSBDaG9saWNoIDogaHR0cHM6Ly9naXRodWIuY29tL2Zyb250eWFyZFxuLy8hIGJhc2VkIG9uIChocikgdHJhbnNsYXRpb24gYnkgQm9qYW4gTWFya292acSHXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkbmEgbWludXRhJyA6ICdqZWRuZSBtaW51dGUnO1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdqZWRhbiBzYXQnIDogJ2plZG5vZyBzYXRhJztcbiAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGEnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZGFuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdkYW5hJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlYyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWNhJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWNpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgJ3l5JzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYnMnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW51YXJfZmVicnVhcl9tYXJ0X2FwcmlsX21hal9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW4uX2ZlYi5fbWFyLl9hcHIuX21hai5fanVuLl9qdWwuX2F1Zy5fc2VwLl9va3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnbmVkamVsamFfcG9uZWRqZWxqYWtfdXRvcmFrX3NyaWplZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICduZWQuX3Bvbi5fdXRvLl9zcmkuX8SNZXQuX3BldC5fc3ViLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC4gTU0uIFlZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgIDogJ1tkYW5hcyB1XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5ICA6ICdbc3V0cmEgdV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkamVsanVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3JpamVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZXIgdV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbGldIGRkZGQgW3VdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXG4gICAgICAgICAgICBzICAgICAgOiAncGFyIHNla3VuZGknLFxuICAgICAgICAgICAgbSAgICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaCAgICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZCAgICAgIDogJ2RhbicsXG4gICAgICAgICAgICBkZCAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNICAgICAgOiAnbWplc2VjJyxcbiAgICAgICAgICAgIE1NICAgICA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxuICAgICAgICAgICAgeXkgICAgIDogdHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBicztcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9icy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBjYXRhbGFuIChjYSlcbi8vISBhdXRob3IgOiBKdWFuIEcuIEh1cnRhZG8gOiBodHRwczovL2dpdGh1Yi5jb20vanVhbmdodXJ0YWRvXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY2EnLCB7XG4gICAgICAgIG1vbnRocyA6ICdnZW5lcl9mZWJyZXJfbWFyw6dfYWJyaWxfbWFpZ19qdW55X2p1bGlvbF9hZ29zdF9zZXRlbWJyZV9vY3R1YnJlX25vdmVtYnJlX2Rlc2VtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdnZW4uX2ZlYnIuX21hci5fYWJyLl9tYWkuX2p1bi5fanVsLl9hZy5fc2V0Ll9vY3QuX25vdi5fZGVzLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnZGl1bWVuZ2VfZGlsbHVuc19kaW1hcnRzX2RpbWVjcmVzX2Rpam91c19kaXZlbmRyZXNfZGlzc2FidGUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnZGcuX2RsLl9kdC5fZGMuX2RqLl9kdi5fZHMuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdEZ19EbF9EdF9EY19Eal9Edl9Ecycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdMVDpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1thdnVpIGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tkZW3DoCBhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGRkZCBbYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW2FoaXIgYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzc2F0IGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2VuICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnZmEgJXMnLFxuICAgICAgICAgICAgcyA6ICd1bnMgc2Vnb25zJyxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRzJyxcbiAgICAgICAgICAgIGggOiAndW5hIGhvcmEnLFxuICAgICAgICAgICAgaGggOiAnJWQgaG9yZXMnLFxuICAgICAgICAgICAgZCA6ICd1biBkaWEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGllcycsXG4gICAgICAgICAgICBNIDogJ3VuIG1lcycsXG4gICAgICAgICAgICBNTSA6ICclZCBtZXNvcycsXG4gICAgICAgICAgICB5IDogJ3VuIGFueScsXG4gICAgICAgICAgICB5eSA6ICclZCBhbnlzJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShyfG58dHzDqHxhKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdyJyA6XG4gICAgICAgICAgICAgICAgKG51bWJlciA9PT0gMikgPyAnbicgOlxuICAgICAgICAgICAgICAgIChudW1iZXIgPT09IDMpID8gJ3InIDpcbiAgICAgICAgICAgICAgICAobnVtYmVyID09PSA0KSA/ICd0JyA6ICfDqCc7XG4gICAgICAgICAgICBpZiAocGVyaW9kID09PSAndycgfHwgcGVyaW9kID09PSAnVycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnYSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9jYS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBjemVjaCAoY3MpXG4vLyEgYXV0aG9yIDogcGV0cmJlbGEgOiBodHRwczovL2dpdGh1Yi5jb20vcGV0cmJlbGFcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gJ2xlZGVuX8O6bm9yX2LFmWV6ZW5fZHViZW5fa3bEm3Rlbl/EjWVydmVuX8SNZXJ2ZW5lY19zcnBlbl96w6HFmcOtX8WZw61qZW5fbGlzdG9wYWRfcHJvc2luZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0ID0gJ2xlZF/Dum5vX2LFmWVfZHViX2t2xJtfxI12bl/EjXZjX3NycF96w6HFmV/FmcOtal9saXNfcHJvJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIHBsdXJhbChuKSB7XG4gICAgICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSkgJiYgKH5+KG4gLyAxMCkgIT09IDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ3MnOiAgLy8gYSBmZXcgc2Vjb25kcyAvIGluIGEgZmV3IHNlY29uZHMgLyBhIGZldyBzZWNvbmRzIGFnb1xuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdww6FyIHNla3VuZCcgOiAncMOhciBzZWt1bmRhbWknO1xuICAgICAgICBjYXNlICdtJzogIC8vIGEgbWludXRlIC8gaW4gYSBtaW51dGUgLyBhIG1pbnV0ZSBhZ29cbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ21pbnV0YScgOiAoaXNGdXR1cmUgPyAnbWludXR1JyA6ICdtaW51dG91Jyk7XG4gICAgICAgIGNhc2UgJ21tJzogLy8gOSBtaW51dGVzIC8gaW4gOSBtaW51dGVzIC8gOSBtaW51dGVzIGFnb1xuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbnV0eScgOiAnbWludXQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtaW51dGFtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaCc6ICAvLyBhbiBob3VyIC8gaW4gYW4gaG91ciAvIGFuIGhvdXIgYWdvXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdob2RpbmEnIDogKGlzRnV0dXJlID8gJ2hvZGludScgOiAnaG9kaW5vdScpO1xuICAgICAgICBjYXNlICdoaCc6IC8vIDkgaG91cnMgLyBpbiA5IGhvdXJzIC8gOSBob3VycyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdob2RpbnknIDogJ2hvZGluJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnaG9kaW5hbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2QnOiAgLy8gYSBkYXkgLyBpbiBhIGRheSAvIGEgZGF5IGFnb1xuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdkZW4nIDogJ2RuZW0nO1xuICAgICAgICBjYXNlICdkZCc6IC8vIDkgZGF5cyAvIGluIDkgZGF5cyAvIDkgZGF5cyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdkbnknIDogJ2Ruw60nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkbnknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ00nOiAgLy8gYSBtb250aCAvIGluIGEgbW9udGggLyBhIG1vbnRoIGFnb1xuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdtxJtzw61jJyA6ICdtxJtzw61jZW0nO1xuICAgICAgICBjYXNlICdNTSc6IC8vIDkgbW9udGhzIC8gaW4gOSBtb250aHMgLyA5IG1vbnRocyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtxJtzw61jZScgOiAnbcSbc8OtY8WvJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcSbc8OtY2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3knOiAgLy8gYSB5ZWFyIC8gaW4gYSB5ZWFyIC8gYSB5ZWFyIGFnb1xuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdyb2snIDogJ3Jva2VtJztcbiAgICAgICAgY2FzZSAneXknOiAvLyA5IHllYXJzIC8gaW4gOSB5ZWFycyAvIDkgeWVhcnMgYWdvXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAncm9reScgOiAnbGV0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbGV0eSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2NzJywge1xuICAgICAgICBtb250aHMgOiBtb250aHMsXG4gICAgICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnQsXG4gICAgICAgIG1vbnRoc1BhcnNlIDogKGZ1bmN0aW9uIChtb250aHMsIG1vbnRoc1Nob3J0KSB7XG4gICAgICAgICAgICB2YXIgaSwgX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gcGFyc2VyIHRvIHNvbHZlIHByb2JsZW0gd2l0aCBKdWx5ICjEjWVydmVuZWMpXG4gICAgICAgICAgICAgICAgX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyBtb250aHNbaV0gKyAnJHxeJyArIG1vbnRoc1Nob3J0W2ldICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9tb250aHNQYXJzZTtcbiAgICAgICAgfShtb250aHMsIG1vbnRoc1Nob3J0KSksXG4gICAgICAgIHdlZWtkYXlzIDogJ25lZMSbbGVfcG9uZMSbbMOtX8O6dGVyw71fc3TFmWVkYV/EjXR2cnRla19ww6F0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ25lX3BvX8O6dF9zdF/EjXRfcMOhX3NvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICduZV9wb1/DunRfc3RfxI10X3DDoV9zbycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbZG5lcyB2XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW3rDrXRyYSB2XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBuZWTEm2xpIHZdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFt2XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2ZSBzdMWZZWR1IHZdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZlIMSNdHZydGVrIHZdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgcMOhdGVrIHZdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc29ib3R1IHZdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheTogJ1t2xI1lcmEgdl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsb3UgbmVkxJtsaSB2XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDqV0gZGRkZCBbdl0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWxvdSBzdMWZZWR1IHZdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFt2XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bG91IHNvYm90dSB2XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAncMWZZWQgJXMnLFxuICAgICAgICAgICAgcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2UgOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNzO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2NzLmpzXG4gKiogbW9kdWxlIGlkID0gMjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGNodXZhc2ggKGN2KVxuLy8hIGF1dGhvciA6IEFuYXRvbHkgTWlyb25vdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taXJvbnRvbGlcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgY3YgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdjdicsIHtcbiAgICAgICAgbW9udGhzIDogJ9C605HRgNC70LDRh1/QvdCw0YDTkdGBX9C/0YPRiF/QsNC60LBf0LzQsNC5X9Kr05fRgNGC0LzQtV/Rg9GC05Ff0qvRg9GA0LvQsF/QsNCy05HQvV/RjtC/0LBf0YfTs9C6X9GA0LDRiNGC0LDQsicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn0LrTkdGAX9C90LDRgF/Qv9GD0Yhf0LDQutCwX9C80LDQuV/Sq9OX0YBf0YPRgtORX9Kr0YPRgF/QsNCy0L1f0Y7Qv9CwX9GH07PQul/RgNCw0YgnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ9Cy0YvRgNGB0LDRgNC90LjQutGD0L1f0YLRg9C90YLQuNC60YPQvV/Ri9GC0LvQsNGA0LjQutGD0L1f0Y7QvdC60YPQvV/QutOX0qvQvdC10YDQvdC40LrRg9C9X9GN0YDQvdC10LrRg9C9X9GI05HQvNCw0YLQutGD0L0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn0LLRi9GAX9GC0YPQvV/Ri9GC0Ltf0Y7QvV/QutOX0qtf0Y3RgNC9X9GI05HQvCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0LLRgF/RgtC9X9GL0YJf0Y7QvV/QutKrX9GN0YBf0YjQvCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC1NTS1ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVkgW9Kr0YPQu9GF0LhdIE1NTU0gW9GD0LnTkdGF05fQvV0gRFst0LzTl9GI05ddJyxcbiAgICAgICAgICAgIExMTCA6ICdZWVlZIFvSq9GD0LvRhdC4XSBNTU1NIFvRg9C505HRhdOX0L1dIERbLdC805fRiNOXXSwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBZWVlZIFvSq9GD0LvRhdC4XSBNTU1NIFvRg9C505HRhdOX0L1dIERbLdC805fRiNOXXSwgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vQn9Cw0Y/QvV0gTFQgW9GB0LXRhdC10YLRgNC1XScsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9Cr0YDQsNC9XSBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdb05bQvdC10YBdIExUIFvRgdC10YXQtdGC0YDQtV0nLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdb0qrQuNGC0LXRgV0gZGRkZCBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW9CY0YDRgtC905ddIGRkZGQgTFQgW9GB0LXRhdC10YLRgNC1XScsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWZmaXggPSAv0YHQtdGF0LXRgiQvaS5leGVjKG91dHB1dCkgPyAn0YDQtdC9JyA6IC/Sq9GD0LskL2kuZXhlYyhvdXRwdXQpID8gJ9GC0LDQvScgOiAn0YDQsNC9JztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0ICsgYWZmaXg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdCA6ICclcyDQutCw0Y/Qu9C70LAnLFxuICAgICAgICAgICAgcyA6ICfQv9OX0YAt0LjQuiDSq9C10LrQutGD0L3RgicsXG4gICAgICAgICAgICBtIDogJ9C/05fRgCDQvNC40L3Rg9GCJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC80LjQvdGD0YInLFxuICAgICAgICAgICAgaCA6ICfQv9OX0YAg0YHQtdGF0LXRgicsXG4gICAgICAgICAgICBoaCA6ICclZCDRgdC10YXQtdGCJyxcbiAgICAgICAgICAgIGQgOiAn0L/Tl9GAINC60YPQvScsXG4gICAgICAgICAgICBkZCA6ICclZCDQutGD0L0nLFxuICAgICAgICAgICAgTSA6ICfQv9OX0YAg0YPQudOR0YUnLFxuICAgICAgICAgICAgTU0gOiAnJWQg0YPQudOR0YUnLFxuICAgICAgICAgICAgeSA6ICfQv9OX0YAg0qvRg9C7JyxcbiAgICAgICAgICAgIHl5IDogJyVkINKr0YPQuydcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0t0LzTl9GILyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC3QvNOX0YgnLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjdjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9jdi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBXZWxzaCAoY3kpXG4vLyEgYXV0aG9yIDogUm9iZXJ0IEFsbGVuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGN5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY3knLCB7XG4gICAgICAgIG1vbnRoczogJ0lvbmF3cl9DaHdlZnJvcl9NYXdydGhfRWJyaWxsX01haV9NZWhlZmluX0dvcmZmZW5uYWZfQXdzdF9NZWRpX0h5ZHJlZl9UYWNod2VkZF9SaGFnZnlyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydDogJ0lvbl9DaHdlX01hd19FYnJfTWFpX01laF9Hb3JfQXdzX01lZF9IeWRfVGFjaF9SaGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5czogJ0R5ZGQgU3VsX0R5ZGQgTGx1bl9EeWRkIE1hd3J0aF9EeWRkIE1lcmNoZXJfRHlkZCBJYXVfRHlkZCBHd2VuZXJfRHlkZCBTYWR3cm4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICdTdWxfTGx1bl9NYXdfTWVyX0lhdV9Hd2VfU2FkJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ1N1X0xsX01hX01lX0lhX0d3X1NhJy5zcGxpdCgnXycpLFxuICAgICAgICAvLyB0aW1lIGZvcm1hdHMgYXJlIHRoZSBzYW1lIGFzIGVuLWdiXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXI6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSGVkZGl3IGFtXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW1lmb3J5IGFtXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2FtXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0Rkb2UgYW1dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbZGl3ZXRoYWYgYW1dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiB7XG4gICAgICAgICAgICBmdXR1cmU6ICdtZXduICVzJyxcbiAgICAgICAgICAgIHBhc3Q6ICclcyB5biDDtGwnLFxuICAgICAgICAgICAgczogJ3ljaHlkaWcgZWlsaWFkYXUnLFxuICAgICAgICAgICAgbTogJ211bnVkJyxcbiAgICAgICAgICAgIG1tOiAnJWQgbXVudWQnLFxuICAgICAgICAgICAgaDogJ2F3cicsXG4gICAgICAgICAgICBoaDogJyVkIGF3cicsXG4gICAgICAgICAgICBkOiAnZGl3cm5vZCcsXG4gICAgICAgICAgICBkZDogJyVkIGRpd3Jub2QnLFxuICAgICAgICAgICAgTTogJ21pcycsXG4gICAgICAgICAgICBNTTogJyVkIG1pcycsXG4gICAgICAgICAgICB5OiAnYmx3eWRkeW4nLFxuICAgICAgICAgICAgeXk6ICclZCBmbHluZWRkJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShmZWR8YWlufGFmfGlsfHlkZHxlZHxlZykvLFxuICAgICAgICAvLyB0cmFkaXRpb25hbCBvcmRpbmFsIG51bWJlcnMgYWJvdmUgMzEgYXJlIG5vdCBjb21tb25seSB1c2VkIGluIGNvbGxvcXVpYWwgV2Vsc2hcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICAgICAgbG9va3VwID0gW1xuICAgICAgICAgICAgICAgICAgICAnJywgJ2FmJywgJ2lsJywgJ3lkZCcsICd5ZGQnLCAnZWQnLCAnZWQnLCAnZWQnLCAnZmVkJywgJ2ZlZCcsICdmZWQnLCAvLyAxYWYgdG8gMTBmZWRcbiAgICAgICAgICAgICAgICAgICAgJ2VnJywgJ2ZlZCcsICdlZycsICdlZycsICdmZWQnLCAnZWcnLCAnZWcnLCAnZmVkJywgJ2VnJywgJ2ZlZCcgLy8gMTFlZyB0byAyMGZlZFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoYiA+IDIwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGIgPT09IDQwIHx8IGIgPT09IDUwIHx8IGIgPT09IDYwIHx8IGIgPT09IDgwIHx8IGIgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSAnZmVkJzsgLy8gbm90IDMwYWluLCA3MGFpbiBvciA5MGFpblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICdhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsb29rdXBbYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjeTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9jeS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBkYW5pc2ggKGRhKVxuLy8hIGF1dGhvciA6IFVscmlrIE5pZWxzZW4gOiBodHRwczovL2dpdGh1Yi5jb20vbXJiYXNlXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGRhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZGEnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW51YXJfZmVicnVhcl9tYXJ0c19hcHJpbF9tYWpfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ3PDuG5kYWdfbWFuZGFnX3RpcnNkYWdfb25zZGFnX3RvcnNkYWdfZnJlZGFnX2zDuHJkYWcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnc8O4bl9tYW5fdGlyX29uc190b3JfZnJlX2zDuHInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ3PDuF9tYV90aV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgW2QuXSBELiBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbSSBkYWcga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tJIG1vcmdlbiBrbC5dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2tsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbSSBnw6VyIGtsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW3NpZHN0ZV0gZGRkZCBba2xdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdvbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHNpZGVuJyxcbiAgICAgICAgICAgIHMgOiAnZsOlIHNla3VuZGVyJyxcbiAgICAgICAgICAgIG0gOiAnZXQgbWludXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXR0ZXInLFxuICAgICAgICAgICAgaCA6ICdlbiB0aW1lJyxcbiAgICAgICAgICAgIGhoIDogJyVkIHRpbWVyJyxcbiAgICAgICAgICAgIGQgOiAnZW4gZGFnJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2UnLFxuICAgICAgICAgICAgTSA6ICdlbiBtw6VuZWQnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbcOlbmVkZXInLFxuICAgICAgICAgICAgeSA6ICdldCDDpXInLFxuICAgICAgICAgICAgeXkgOiAnJWQgw6VyJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGE7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogZ2VybWFuIChkZSlcbi8vISBhdXRob3IgOiBsbHVjaHMgOiBodHRwczovL2dpdGh1Yi5jb20vbGx1Y2hzXG4vLyEgYXV0aG9yOiBNZW5lbGlvbiBFbGVuc8O6bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICdtJzogWydlaW5lIE1pbnV0ZScsICdlaW5lciBNaW51dGUnXSxcbiAgICAgICAgICAgICdoJzogWydlaW5lIFN0dW5kZScsICdlaW5lciBTdHVuZGUnXSxcbiAgICAgICAgICAgICdkJzogWydlaW4gVGFnJywgJ2VpbmVtIFRhZyddLFxuICAgICAgICAgICAgJ2RkJzogW251bWJlciArICcgVGFnZScsIG51bWJlciArICcgVGFnZW4nXSxcbiAgICAgICAgICAgICdNJzogWydlaW4gTW9uYXQnLCAnZWluZW0gTW9uYXQnXSxcbiAgICAgICAgICAgICdNTSc6IFtudW1iZXIgKyAnIE1vbmF0ZScsIG51bWJlciArICcgTW9uYXRlbiddLFxuICAgICAgICAgICAgJ3knOiBbJ2VpbiBKYWhyJywgJ2VpbmVtIEphaHInXSxcbiAgICAgICAgICAgICd5eSc6IFtudW1iZXIgKyAnIEphaHJlJywgbnVtYmVyICsgJyBKYWhyZW4nXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XG4gICAgfVxuXG4gICAgdmFyIGRlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZGUnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJfRmVicnVhcl9Nw6Ryel9BcHJpbF9NYWlfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuLl9GZWJyLl9NcnouX0Fwci5fTWFpX0p1bi5fSnVsLl9BdWcuX1NlcHQuX09rdC5fTm92Ll9EZXouJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdTb25udGFnX01vbnRhZ19EaWVuc3RhZ19NaXR0d29jaF9Eb25uZXJzdGFnX0ZyZWl0YWdfU2Ftc3RhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdTby5fTW8uX0RpLl9NaS5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSGV1dGUgdW1dIExUIFtVaHJdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW01vcmdlbiB1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1tHZXN0ZXJuIHVtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ZvciAlcycsXG4gICAgICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxuICAgICAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkZTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBhdXN0cmlhbiBnZXJtYW4gKGRlLWF0KVxuLy8hIGF1dGhvciA6IGxsdWNocyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9sbHVjaHNcbi8vISBhdXRob3I6IE1lbmVsaW9uIEVsZW5zw7psZTogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcbi8vISBhdXRob3IgOiBNYXJ0aW4gR3JvbGxlciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYWRNR1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB7XG4gICAgICAgICAgICAnbSc6IFsnZWluZSBNaW51dGUnLCAnZWluZXIgTWludXRlJ10sXG4gICAgICAgICAgICAnaCc6IFsnZWluZSBTdHVuZGUnLCAnZWluZXIgU3R1bmRlJ10sXG4gICAgICAgICAgICAnZCc6IFsnZWluIFRhZycsICdlaW5lbSBUYWcnXSxcbiAgICAgICAgICAgICdkZCc6IFtudW1iZXIgKyAnIFRhZ2UnLCBudW1iZXIgKyAnIFRhZ2VuJ10sXG4gICAgICAgICAgICAnTSc6IFsnZWluIE1vbmF0JywgJ2VpbmVtIE1vbmF0J10sXG4gICAgICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBNb25hdGUnLCBudW1iZXIgKyAnIE1vbmF0ZW4nXSxcbiAgICAgICAgICAgICd5JzogWydlaW4gSmFocicsICdlaW5lbSBKYWhyJ10sXG4gICAgICAgICAgICAneXknOiBbbnVtYmVyICsgJyBKYWhyZScsIG51bWJlciArICcgSmFocmVuJ11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xuICAgIH1cblxuICAgIHZhciBkZV9hdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlLWF0Jywge1xuICAgICAgICBtb250aHMgOiAnSsOkbm5lcl9GZWJydWFyX03DpHJ6X0FwcmlsX01haV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKw6RuLl9GZWJyLl9NcnouX0Fwci5fTWFpX0p1bi5fSnVsLl9BdWcuX1NlcHQuX09rdC5fTm92Ll9EZXouJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdTb25udGFnX01vbnRhZ19EaWVuc3RhZ19NaXR0d29jaF9Eb25uZXJzdGFnX0ZyZWl0YWdfU2Ftc3RhZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdTby5fTW8uX0RpLl9NaS5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSGV1dGUgdW1dIExUIFtVaHJdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW01vcmdlbiB1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1tHZXN0ZXJuIHVtXSBMVCBbVWhyXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ZvciAlcycsXG4gICAgICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxuICAgICAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkZV9hdDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9kZS1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBtb2Rlcm4gZ3JlZWsgKGVsKVxuLy8hIGF1dGhvciA6IEFnZ2Vsb3MgS2FyYWxpYXMgOiBodHRwczovL2dpdGh1Yi5jb20vbWVoaWVsXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGVsID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZWwnLCB7XG4gICAgICAgIG1vbnRoc05vbWluYXRpdmVFbCA6ICfOmc6xzr3Ov8+FzqzPgc65zr/Pgl/Ops61zrLPgc6/z4XOrM+BzrnOv8+CX86czqzPgc+EzrnOv8+CX86Rz4DPgc6vzrvOuc6/z4JfzpzOrM65zr/Pgl/Omc6/z43Ovc65zr/Pgl/Omc6/z43Ou865zr/Pgl/Okc+NzrPOv8+Fz4PPhM6/z4JfzqPOtc+Az4TOrc68zrLPgc65zr/Pgl/On866z4TPjs6yz4HOuc6/z4Jfzp3Ov86tzrzOss+BzrnOv8+CX86UzrXOus6tzrzOss+BzrnOv8+CJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNHZW5pdGl2ZUVsIDogJ86ZzrHOvc6/z4XOsc+Bzq/Ov8+FX86mzrXOss+Bzr/Phc6xz4HOr86/z4VfzpzOsc+Bz4TOr86/z4VfzpHPgM+BzrnOu86vzr/PhV/OnM6xzpDOv8+FX86Zzr/Phc69zq/Ov8+FX86Zzr/Phc67zq/Ov8+FX86Rz4XOs86/z43Pg8+Ezr/PhV/Oo861z4DPhM61zrzOss+Bzq/Ov8+FX86fzrrPhM+JzrLPgc6vzr/PhV/Onc6/zrXOvM6yz4HOr86/z4VfzpTOtc66zrXOvM6yz4HOr86/z4UnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtb21lbnRUb0Zvcm1hdCwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoL0QvLnRlc3QoZm9ybWF0LnN1YnN0cmluZygwLCBmb3JtYXQuaW5kZXhPZignTU1NTScpKSkpIHsgLy8gaWYgdGhlcmUgaXMgYSBkYXkgbnVtYmVyIGJlZm9yZSAnTU1NTSdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzR2VuaXRpdmVFbFttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc05vbWluYXRpdmVFbFttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnzpnOsc69X86mzrXOsl/OnM6xz4FfzpHPgM+BX86czrHPil/Omc6/z4XOvV/Omc6/z4XOu1/Okc+FzrNfzqPOtc+AX86fzrrPhF/Onc6/zrVfzpTOtc66Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfOms+Fz4HOuc6xzrrOrl/OlM61z4XPhM6tz4HOsV/OpM+Bzq/PhM63X86kzrXPhM6sz4HPhM63X86gzq3OvM+Az4TOt1/OoM6xz4HOsc+DzrrOtc+Fzq5fzqPOrM6yzrLOsc+Ezr8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnzprPhc+BX86UzrXPhV/OpM+BzrlfzqTOtc+EX86gzrXOvF/OoM6xz4FfzqPOsc6yJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfOms+FX86UzrVfzqTPgV/OpM61X86gzrVfzqDOsV/Oo86xJy5zcGxpdCgnXycpLFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfOvM68JyA6ICfOnM6cJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnz4DOvCcgOiAnzqDOnCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKClbMF0gPT09ICfOvCcpO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlIDogL1vOoM6cXVxcLj/OnD9cXC4/L2ksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyRWwgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vOo86uzrzOtc+BzrEge31dIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW86Rz43Pgc65zr8ge31dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3t9XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vOp864zrXPgiB7fV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW8+Ezr8gz4DPgc6/zrfOs86/z43OvM61zr3Ov10gZGRkZCBbe31dIExUJztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW8+EzrfOvSDPgM+Bzr/Ot86zzr/Pjc68zrXOvc63XSBkZGRkIFt7fV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IGZ1bmN0aW9uIChrZXksIG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyRWxba2V5XSxcbiAgICAgICAgICAgICAgICBob3VycyA9IG1vbSAmJiBtb20uaG91cnMoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmFwcGx5KG1vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnJlcGxhY2UoJ3t9JywgKGhvdXJzICUgMTIgPT09IDEgPyAnz4PPhM63JyA6ICfPg8+EzrnPgicpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ8+DzrUgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDPgM+BzrnOvScsXG4gICAgICAgICAgICBzIDogJ867zq/Os86xIM60zrXPhc+EzrXPgc+MzrvOtc+Az4TOsScsXG4gICAgICAgICAgICBtIDogJ86tzr3OsSDOu861z4DPhM+MJyxcbiAgICAgICAgICAgIG1tIDogJyVkIM67zrXPgM+EzqwnLFxuICAgICAgICAgICAgaCA6ICfOvM6vzrEgz47Pgc6xJyxcbiAgICAgICAgICAgIGhoIDogJyVkIM+Oz4HOtc+CJyxcbiAgICAgICAgICAgIGQgOiAnzrzOr86xIM68zq3Pgc6xJyxcbiAgICAgICAgICAgIGRkIDogJyVkIM68zq3Pgc61z4InLFxuICAgICAgICAgICAgTSA6ICfOrc69zrHPgiDOvM6uzr3Osc+CJyxcbiAgICAgICAgICAgIE1NIDogJyVkIM68zq7Ovc61z4InLFxuICAgICAgICAgICAgeSA6ICfOrc69zrHPgiDPh8+Bz4zOvc6/z4InLFxuICAgICAgICAgICAgeXkgOiAnJWQgz4fPgc+Mzr3Ouc6xJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfc63LyxcbiAgICAgICAgb3JkaW5hbDogJyVkzrcnLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0c3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9lbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBhdXN0cmFsaWFuIGVuZ2xpc2ggKGVuLWF1KVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlbl9hdSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWF1Jywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgICAgbSA6ICdhIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAnYW4gaG91cicsXG4gICAgICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgICAgICBkIDogJ2EgZGF5JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICAgICAgTSA6ICdhIG1vbnRoJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgICAgICB5IDogJ2EgeWVhcicsXG4gICAgICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVuX2F1O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGNhbmFkaWFuIGVuZ2xpc2ggKGVuLWNhKVxuLy8hIGF1dGhvciA6IEpvbmF0aGFuIEFib3VyYmloIDogaHR0cHM6Ly9naXRodWIuY29tL2pvbmJjYVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlbl9jYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWNhJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSwgWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NLCBZWVlZIGg6bW0gQScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSwgWVlZWSBoOm1tIEEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIGFnbycsXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICAgICAgbSA6ICdhIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAnYW4gaG91cicsXG4gICAgICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgICAgICBkIDogJ2EgZGF5JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICAgICAgTSA6ICdhIG1vbnRoJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgICAgICB5IDogJ2EgeWVhcicsXG4gICAgICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbl9jYTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9lbi1jYS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBncmVhdCBicml0YWluIGVuZ2xpc2ggKGVuLWdiKVxuLy8hIGF1dGhvciA6IENocmlzIEdlZHJpbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc2dlZHJpbVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlbl9nYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWdiJywge1xuICAgICAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcbiAgICAgICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICAgIGQgOiAnYSBkYXknLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW5fZ2I7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZW4tZ2IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogZXNwZXJhbnRvIChlbylcbi8vISBhdXRob3IgOiBDb2xpbiBEZWFuIDogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluZGVhblxuLy8hIGtvbWVudG86IE1pIGVzdGFzIG1hbGNlcnRhIHNlIG1pIGtvcmVrdGUgdHJha3RpcyBha3V6YXRpdm9qbiBlbiB0aXUgdHJhZHVrby5cbi8vISAgICAgICAgICBTZSBuZSwgYm9udm9sdSBrb3Jla3RpIGthaiBhdml6aSBtaW4gcG9yIGtlIG1pIHBvdmFzIGxlcm5pIVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBlbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VvJywge1xuICAgICAgICBtb250aHMgOiAnamFudWFyb19mZWJydWFyb19tYXJ0b19hcHJpbG9fbWFqb19qdW5pb19qdWxpb19hxa1ndXN0b19zZXB0ZW1icm9fb2t0b2Jyb19ub3ZlbWJyb19kZWNlbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2HFrWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdEaW1hbsSJb19MdW5kb19NYXJkb19NZXJrcmVkb1/EtGHFrWRvX1ZlbmRyZWRvX1NhYmF0bycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdEaW1fTHVuX01hcmRfTWVya1/EtGHFrV9WZW5fU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdEaV9MdV9NYV9NZV/EtGFfVmVfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICBMTCA6ICdEWy1hbiBkZV0gTU1NTSwgWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRFstYW4gZGVdIE1NTU0sIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBbbGFdIERbLWFuIGRlXSBNTU1NLCBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvW2FwXVxcLnRcXC5tL2ksXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09PSAncCc7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3AudC5tLicgOiAnUC5ULk0uJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYS50Lm0uJyA6ICdBLlQuTS4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW0hvZGlhxa0gamVdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW01vcmdhxa0gamVdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2plXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tIaWVyYcWtIGplXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbcGFzaW50YV0gZGRkZCBbamVdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdqZSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2FudGHFrSAlcycsXG4gICAgICAgICAgICBzIDogJ3Nla3VuZG9qJyxcbiAgICAgICAgICAgIG0gOiAnbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0b2onLFxuICAgICAgICAgICAgaCA6ICdob3JvJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcm9qJyxcbiAgICAgICAgICAgIGQgOiAndGFnbycsLy9uZSAnZGl1cm5vJywgxIlhciBlc3RhcyB1eml0YSBwb3IgcHJva3NpbXVtb1xuICAgICAgICAgICAgZGQgOiAnJWQgdGFnb2onLFxuICAgICAgICAgICAgTSA6ICdtb25hdG8nLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9uYXRvaicsXG4gICAgICAgICAgICB5IDogJ2phcm8nLFxuICAgICAgICAgICAgeXkgOiAnJWQgamFyb2onXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9YS8sXG4gICAgICAgIG9yZGluYWwgOiAnJWRhJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZW87XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZW8uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogc3BhbmlzaCAoZXMpXG4vLyEgYXV0aG9yIDogSnVsaW8gTmFwdXLDrSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpb25jXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG1vbnRoc1Nob3J0RG90ID0gJ0VuZS5fRmViLl9NYXIuX0Fici5fTWF5Ll9KdW4uX0p1bC5fQWdvLl9TZXAuX09jdC5fTm92Ll9EaWMuJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA9ICdFbmVfRmViX01hcl9BYnJfTWF5X0p1bl9KdWxfQWdvX1NlcF9PY3RfTm92X0RpYycuc3BsaXQoJ18nKTtcblxuICAgIHZhciBlcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VzJywge1xuICAgICAgICBtb250aHMgOiAnRW5lcm9fRmVicmVyb19NYXJ6b19BYnJpbF9NYXlvX0p1bmlvX0p1bGlvX0Fnb3N0b19TZXB0aWVtYnJlX09jdHVicmVfTm92aWVtYnJlX0RpY2llbWJyZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90W20ubW9udGgoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtkYXlzIDogJ0RvbWluZ29fTHVuZXNfTWFydGVzX01pw6lyY29sZXNfSnVldmVzX1ZpZXJuZXNfU8OhYmFkbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdEb20uX0x1bi5fTWFyLl9NacOpLl9KdWUuX1ZpZS5fU8OhYi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RvX0x1X01hX01pX0p1X1ZpX1PDoScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tob3kgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ttYcOxYW5hIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGRkZCBbYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1theWVyIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW2VsXSBkZGRkIFtwYXNhZG8gYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2VuICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnaGFjZSAlcycsXG4gICAgICAgICAgICBzIDogJ3Vub3Mgc2VndW5kb3MnLFxuICAgICAgICAgICAgbSA6ICd1biBtaW51dG8nLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXG4gICAgICAgICAgICBoIDogJ3VuYSBob3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcmFzJyxcbiAgICAgICAgICAgIGQgOiAndW4gZMOtYScsXG4gICAgICAgICAgICBkZCA6ICclZCBkw61hcycsXG4gICAgICAgICAgICBNIDogJ3VuIG1lcycsXG4gICAgICAgICAgICBNTSA6ICclZCBtZXNlcycsXG4gICAgICAgICAgICB5IDogJ3VuIGHDsW8nLFxuICAgICAgICAgICAgeXkgOiAnJWQgYcOxb3MnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcbiAgICAgICAgb3JkaW5hbCA6ICclZMK6JyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXM7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogZXN0b25pYW4gKGV0KVxuLy8hIGF1dGhvciA6IEhlbnJ5IEtlaGxtYW5uIDogaHR0cHM6Ly9naXRodWIuY29tL21hZGhlbnJ5XG4vLyEgaW1wcm92ZW1lbnRzIDogSWxsaW1hciBUYW1iZWsgOiBodHRwczovL2dpdGh1Yi5jb20vcmFndWxrYVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB7XG4gICAgICAgICAgICAncycgOiBbJ23DtW5lIHNla3VuZGknLCAnbcO1bmkgc2VrdW5kJywgJ3BhYXIgc2VrdW5kaXQnXSxcbiAgICAgICAgICAgICdtJyA6IFsnw7xoZSBtaW51dGknLCAnw7xrcyBtaW51dCddLFxuICAgICAgICAgICAgJ21tJzogW251bWJlciArICcgbWludXRpJywgbnVtYmVyICsgJyBtaW51dGl0J10sXG4gICAgICAgICAgICAnaCcgOiBbJ8O8aGUgdHVubmknLCAndHVuZCBhZWdhJywgJ8O8a3MgdHVuZCddLFxuICAgICAgICAgICAgJ2hoJzogW251bWJlciArICcgdHVubmknLCBudW1iZXIgKyAnIHR1bmRpJ10sXG4gICAgICAgICAgICAnZCcgOiBbJ8O8aGUgcMOkZXZhJywgJ8O8a3MgcMOkZXYnXSxcbiAgICAgICAgICAgICdNJyA6IFsna3V1IGFqYScsICdrdXUgYWVnYScsICfDvGtzIGt1dSddLFxuICAgICAgICAgICAgJ01NJzogW251bWJlciArICcga3V1JywgbnVtYmVyICsgJyBrdXVkJ10sXG4gICAgICAgICAgICAneScgOiBbJ8O8aGUgYWFzdGEnLCAnYWFzdGEnLCAnw7xrcyBhYXN0YSddLFxuICAgICAgICAgICAgJ3l5JzogW251bWJlciArICcgYWFzdGEnLCBudW1iZXIgKyAnIGFhc3RhdCddXG4gICAgICAgIH07XG4gICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0W2tleV1bMl0gPyBmb3JtYXRba2V5XVsyXSA6IGZvcm1hdFtrZXldWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Z1dHVyZSA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XG4gICAgfVxuXG4gICAgdmFyIGV0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZXQnLCB7XG4gICAgICAgIG1vbnRocyAgICAgICAgOiAnamFhbnVhcl92ZWVicnVhcl9tw6RydHNfYXByaWxsX21haV9qdXVuaV9qdXVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9vYmVyX25vdmVtYmVyX2RldHNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgICA6ICdqYWFuX3ZlZWJyX23DpHJ0c19hcHJfbWFpX2p1dW5pX2p1dWxpX2F1Z19zZXB0X29rdF9ub3ZfZGV0cycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgICAgICA6ICdww7xoYXDDpGV2X2VzbWFzcMOkZXZfdGVpc2lww6Rldl9rb2xtYXDDpGV2X25lbGphcMOkZXZfcmVlZGVfbGF1cMOkZXYnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnUF9FX1RfS19OX1JfTCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gICA6ICdQX0VfVF9LX05fUl9MJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUICAgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMICAgIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgICA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMICA6ICdELiBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgIDogJ1tUw6RuYSxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgIDogJ1tIb21tZSxdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1tKw6RyZ21pbmVdIGRkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSAgOiAnW0VpbGUsXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbRWVsbWluZV0gZGRkZCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgcMOkcmFzdCcsXG4gICAgICAgICAgICBwYXN0ICAgOiAnJXMgdGFnYXNpJyxcbiAgICAgICAgICAgIHMgICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGggICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoaCAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGRkICAgICA6ICclZCBww6RldmEnLFxuICAgICAgICAgICAgTSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5ICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgeXkgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXQ7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogZXVza2FyYSAoZXUpXG4vLyEgYXV0aG9yIDogRW5la28gSWxsYXJyYW1lbmRpIDogaHR0cHM6Ly9naXRodWIuY29tL2VpbGxhcnJhXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGV1ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZXUnLCB7XG4gICAgICAgIG1vbnRocyA6ICd1cnRhcnJpbGFfb3RzYWlsYV9tYXJ0eG9hX2FwaXJpbGFfbWFpYXR6YV9la2FpbmFfdXp0YWlsYV9hYnV6dHVhX2lyYWlsYV91cnJpYV9hemFyb2FfYWJlbmR1YScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAndXJ0Ll9vdHMuX21hci5fYXBpLl9tYWkuX2VrYS5fdXp0Ll9hYnUuX2lyYS5fdXJyLl9hemEuX2FiZS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ2lnYW5kZWFfYXN0ZWxlaGVuYV9hc3RlYXJ0ZWFfYXN0ZWF6a2VuYV9vc3RlZ3VuYV9vc3RpcmFsYV9sYXJ1bmJhdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnaWcuX2FsLl9hci5fYXouX29nLl9vbC5fbHIuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdpZ19hbF9hcl9hel9vZ19vbF9scicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVlba29dIE1NTU1bcmVuXSBEW2FdJyxcbiAgICAgICAgICAgIExMTCA6ICdZWVlZW2tvXSBNTU1NW3Jlbl0gRFthXSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIFlZWVlba29dIE1NTU1bcmVuXSBEW2FdIEhIOm1tJyxcbiAgICAgICAgICAgIGwgOiAnWVlZWS1NLUQnLFxuICAgICAgICAgICAgbGwgOiAnWVlZWVtrb10gTU1NIERbYV0nLFxuICAgICAgICAgICAgbGxsIDogJ1lZWVlba29dIE1NTSBEW2FdIEhIOm1tJyxcbiAgICAgICAgICAgIGxsbGwgOiAnZGRkLCBZWVlZW2tvXSBNTU0gRFthXSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tnYXVyXSBMVFtldGFuXScsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tiaWhhcl0gTFRbZXRhbl0nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVFtldGFuXScsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1thdHpvXSBMVFtldGFuXScsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbYXVycmVrb10gZGRkZCBMVFtldGFuXScsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMgYmFycnUnLFxuICAgICAgICAgICAgcGFzdCA6ICdkdWVsYSAlcycsXG4gICAgICAgICAgICBzIDogJ3NlZ3VuZG8gYmF0enVrJyxcbiAgICAgICAgICAgIG0gOiAnbWludXR1IGJhdCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHUnLFxuICAgICAgICAgICAgaCA6ICdvcmR1IGJhdCcsXG4gICAgICAgICAgICBoaCA6ICclZCBvcmR1JyxcbiAgICAgICAgICAgIGQgOiAnZWd1biBiYXQnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZWd1bicsXG4gICAgICAgICAgICBNIDogJ2hpbGFiZXRlIGJhdCcsXG4gICAgICAgICAgICBNTSA6ICclZCBoaWxhYmV0ZScsXG4gICAgICAgICAgICB5IDogJ3VydGUgYmF0JyxcbiAgICAgICAgICAgIHl5IDogJyVkIHVydGUnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBldTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9ldS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBQZXJzaWFuIChmYSlcbi8vISBhdXRob3IgOiBFYnJhaGltIEJ5YWdvd2kgOiBodHRwczovL2dpdGh1Yi5jb20vZWJyYW1pbmlvXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn27EnLFxuICAgICAgICAnMic6ICfbsicsXG4gICAgICAgICczJzogJ9uzJyxcbiAgICAgICAgJzQnOiAn27QnLFxuICAgICAgICAnNSc6ICfbtScsXG4gICAgICAgICc2JzogJ9u2JyxcbiAgICAgICAgJzcnOiAn27cnLFxuICAgICAgICAnOCc6ICfbuCcsXG4gICAgICAgICc5JzogJ9u5JyxcbiAgICAgICAgJzAnOiAn27AnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn27EnOiAnMScsXG4gICAgICAgICfbsic6ICcyJyxcbiAgICAgICAgJ9uzJzogJzMnLFxuICAgICAgICAn27QnOiAnNCcsXG4gICAgICAgICfbtSc6ICc1JyxcbiAgICAgICAgJ9u2JzogJzYnLFxuICAgICAgICAn27cnOiAnNycsXG4gICAgICAgICfbuCc6ICc4JyxcbiAgICAgICAgJ9u5JzogJzknLFxuICAgICAgICAn27AnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGZhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZmEnLCB7XG4gICAgICAgIG1vbnRocyA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfbjNqpXFx1MjAwY9i02YbYqNmHX9iv2YjYtNmG2KjZh1/Ys9mHXFx1MjAwY9i02YbYqNmHX9qG2YfYp9ix2LTZhtio2Ydf2b7ZhtisXFx1MjAwY9i02YbYqNmHX9is2YXYudmHX9i02YbYqNmHJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9uM2qlcXHUyMDBj2LTZhtio2Ydf2K/ZiNi02YbYqNmHX9iz2YdcXHUyMDBj2LTZhtio2Ydf2obZh9in2LHYtNmG2KjZh1/ZvtmG2KxcXHUyMDBj2LTZhtio2Ydf2KzZhdi52Ydf2LTZhtio2YcnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9uMX9ivX9izX9qGX9m+X9isX9i0Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/Zgtio2YQg2KfYsiDYuNmH2LF82KjYudivINin2LIg2LjZh9ixLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL9io2LnYryDYp9iyINi42YfYsS8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn2YLYqNmEINin2LIg2LjZh9ixJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfYqNi52K8g2KfYsiDYuNmH2LEnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW9in2YXYsdmI2LIg2LPYp9i52KpdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW9mB2LHYr9inINiz2KfYudiqXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvYs9in2LnYql0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb2K/bjNix2YjYsiDYs9in2LnYql0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBb2b7bjNi0XSBb2LPYp9i52KpdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfYr9ixICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg2b7bjNi0JyxcbiAgICAgICAgICAgIHMgOiAn2obZhtiv24zZhiDYq9in2YbbjNmHJyxcbiAgICAgICAgICAgIG0gOiAn24zaqSDYr9mC24zZgtmHJyxcbiAgICAgICAgICAgIG1tIDogJyVkINiv2YLbjNmC2YcnLFxuICAgICAgICAgICAgaCA6ICfbjNqpINiz2KfYudiqJyxcbiAgICAgICAgICAgIGhoIDogJyVkINiz2KfYudiqJyxcbiAgICAgICAgICAgIGQgOiAn24zaqSDYsdmI2LInLFxuICAgICAgICAgICAgZGQgOiAnJWQg2LHZiNiyJyxcbiAgICAgICAgICAgIE0gOiAn24zaqSDZhdin2YcnLFxuICAgICAgICAgICAgTU0gOiAnJWQg2YXYp9mHJyxcbiAgICAgICAgICAgIHkgOiAn24zaqSDYs9in2YQnLFxuICAgICAgICAgICAgeXkgOiAnJWQg2LPYp9mEJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b27At27ldL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgv2IwvZywgJywnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfdmFLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZNmFJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiAxMiAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmYTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9mYS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBmaW5uaXNoIChmaSlcbi8vISBhdXRob3IgOiBUYXJtbyBBaWRhbnRhdXN0YSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ibGVhZG9mXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG51bWJlcnNQYXN0ID0gJ25vbGxhIHlrc2kga2Frc2kga29sbWUgbmVsasOkIHZpaXNpIGt1dXNpIHNlaXRzZW3DpG4ga2FoZGVrc2FuIHloZGVrc8Okbicuc3BsaXQoJyAnKSxcbiAgICAgICAgbnVtYmVyc0Z1dHVyZSA9IFtcbiAgICAgICAgICAgICdub2xsYScsICd5aGRlbicsICdrYWhkZW4nLCAna29sbWVuJywgJ25lbGrDpG4nLCAndmlpZGVuJywgJ2t1dWRlbicsXG4gICAgICAgICAgICBudW1iZXJzUGFzdFs3XSwgbnVtYmVyc1Bhc3RbOF0sIG51bWJlcnNQYXN0WzldXG4gICAgICAgIF07XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ211dXRhbWFuIHNla3VubmluJyA6ICdtdXV0YW1hIHNla3VudGknO1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdtaW51dXRpbicgOiAnbWludXV0dGknO1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICByZXN1bHQgPSBpc0Z1dHVyZSA/ICdtaW51dXRpbicgOiAnbWludXV0dGlhJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICd0dW5uaW4nIDogJ3R1bnRpJztcbiAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAndHVubmluJyA6ICd0dW50aWEnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3DDpGl2w6RuJyA6ICdww6RpdsOkJztcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAncMOkaXbDpG4nIDogJ3DDpGl2w6TDpCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAna3V1a2F1ZGVuJyA6ICdrdXVrYXVzaSc7XG4gICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ2t1dWthdWRlbicgOiAna3V1a2F1dHRhJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICd2dW9kZW4nIDogJ3Z1b3NpJztcbiAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAndnVvZGVuJyA6ICd2dW90dGEnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmVyYmFsTnVtYmVyKG51bWJlciwgaXNGdXR1cmUpICsgJyAnICsgcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZXJiYWxOdW1iZXIobnVtYmVyLCBpc0Z1dHVyZSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyIDwgMTAgPyAoaXNGdXR1cmUgPyBudW1iZXJzRnV0dXJlW251bWJlcl0gOiBudW1iZXJzUGFzdFtudW1iZXJdKSA6IG51bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZmkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmaScsIHtcbiAgICAgICAgbW9udGhzIDogJ3RhbW1pa3V1X2hlbG1pa3V1X21hYWxpc2t1dV9odWh0aWt1dV90b3Vrb2t1dV9rZXPDpGt1dV9oZWluw6RrdXVfZWxva3V1X3N5eXNrdXVfbG9rYWt1dV9tYXJyYXNrdXVfam91bHVrdXUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ3RhbW1pX2hlbG1pX21hYWxpc19odWh0aV90b3Vrb19rZXPDpF9oZWluw6RfZWxvX3N5eXNfbG9rYV9tYXJyYXNfam91bHUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ3N1bm51bnRhaV9tYWFuYW50YWlfdGlpc3RhaV9rZXNraXZpaWtrb190b3JzdGFpX3BlcmphbnRhaV9sYXVhbnRhaScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdzdV9tYV90aV9rZV90b19wZV9sYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnc3VfbWFfdGlfa2VfdG9fcGVfbGEnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEgubW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEbyBNTU1NW3RhXSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEbyBNTU1NW3RhXSBZWVlZLCBba2xvXSBISC5tbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIERvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tJyxcbiAgICAgICAgICAgIGwgOiAnRC5NLllZWVknLFxuICAgICAgICAgICAgbGwgOiAnRG8gTU1NIFlZWVknLFxuICAgICAgICAgICAgbGxsIDogJ0RvIE1NTSBZWVlZLCBba2xvXSBISC5tbScsXG4gICAgICAgICAgICBsbGxsIDogJ2RkZCwgRG8gTU1NIFlZWVksIFtrbG9dIEhILm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW3TDpG7DpMOkbl0gW2tsb10gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbaHVvbWVubmFdIFtrbG9dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2tsb10gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbZWlsZW5dIFtrbG9dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1t2aWltZV0gZGRkZFtuYV0gW2tsb10gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIHDDpMOkc3TDpCcsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHNpdHRlbicsXG4gICAgICAgICAgICBzIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG1tIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGhoIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGRkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE1NIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHl5IDogdHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmaTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9maS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBmYXJvZXNlIChmbylcbi8vISBhdXRob3IgOiBSYWduYXIgSm9oYW5uZXNlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWduYXIxMjNcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZm8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmbycsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByw61sX21haV9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2Rlc2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc3VubnVkYWd1cl9tw6FuYWRhZ3VyX3TDvXNkYWd1cl9taWt1ZGFndXJfaMOzc2RhZ3VyX2Zyw61nZ2phZGFndXJfbGV5Z2FyZGFndXInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnc3VuX23DoW5fdMO9c19taWtfaMOzc19mcsOtX2xleScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnc3VfbcOhX3TDvV9taV9ow7NfZnJfbGUnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQuIE1NTU0sIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbw40gZGFnIGtsLl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbw40gbW9yZ2luIGtsLl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBba2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vDjSBnasOhciBrbC5dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tzw63DsHN0dV0gZGRkZCBba2xdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICd1bSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHPDrcOwYW5pJyxcbiAgICAgICAgICAgIHMgOiAnZsOhIHNla3VuZCcsXG4gICAgICAgICAgICBtIDogJ2VpbiBtaW51dHQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXR0aXInLFxuICAgICAgICAgICAgaCA6ICdlaW4gdMOtbWknLFxuICAgICAgICAgICAgaGggOiAnJWQgdMOtbWFyJyxcbiAgICAgICAgICAgIGQgOiAnZWluIGRhZ3VyJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2FyJyxcbiAgICAgICAgICAgIE0gOiAnZWluIG3DoW5hw7BpJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DoW5hw7BpcicsXG4gICAgICAgICAgICB5IDogJ2VpdHQgw6FyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIMOhcidcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2ZvLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGZyZW5jaCAoZnIpXG4vLyEgYXV0aG9yIDogSm9obiBGaXNjaGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2pmcm9mZmljZVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZyJywge1xuICAgICAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW52Ll9mw6l2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2Fvw7t0X3NlcHQuX29jdC5fbm92Ll9kw6ljLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnZGltYW5jaGVfbHVuZGlfbWFyZGlfbWVyY3JlZGlfamV1ZGlfdmVuZHJlZGlfc2FtZWRpJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RpX0x1X01hX01lX0plX1ZlX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0F1am91cmRcXCdodWkgw6BdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbRGVtYWluIMOgXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW8OgXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0hpZXIgw6BdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbZGVybmllciDDoF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZGFucyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXG4gICAgICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcbiAgICAgICAgICAgIG0gOiAndW5lIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAndW5lIGhldXJlJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhldXJlcycsXG4gICAgICAgICAgICBkIDogJ3VuIGpvdXInLFxuICAgICAgICAgICAgZGQgOiAnJWQgam91cnMnLFxuICAgICAgICAgICAgTSA6ICd1biBtb2lzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vaXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhbicsXG4gICAgICAgICAgICB5eSA6ICclZCBhbnMnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGVyfCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAnZXInIDogJycpO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmcjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9mci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBjYW5hZGlhbiBmcmVuY2ggKGZyLWNhKVxuLy8hIGF1dGhvciA6IEpvbmF0aGFuIEFib3VyYmloIDogaHR0cHM6Ly9naXRodWIuY29tL2pvbmJjYVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmcl9jYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZyLWNhJywge1xuICAgICAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW52Ll9mw6l2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2Fvw7t0X3NlcHQuX29jdC5fbm92Ll9kw6ljLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnZGltYW5jaGVfbHVuZGlfbWFyZGlfbWVyY3JlZGlfamV1ZGlfdmVuZHJlZGlfc2FtZWRpJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RpX0x1X01hX01lX0plX1ZlX1NhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0F1am91cmRcXCdodWkgw6BdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbRGVtYWluIMOgXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW8OgXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0hpZXIgw6BdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbZGVybmllciDDoF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZGFucyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXG4gICAgICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcbiAgICAgICAgICAgIG0gOiAndW5lIG1pbnV0ZScsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgICAgIGggOiAndW5lIGhldXJlJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhldXJlcycsXG4gICAgICAgICAgICBkIDogJ3VuIGpvdXInLFxuICAgICAgICAgICAgZGQgOiAnJWQgam91cnMnLFxuICAgICAgICAgICAgTSA6ICd1biBtb2lzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1vaXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhbicsXG4gICAgICAgICAgICB5eSA6ICclZCBhbnMnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGVyfGUpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICdlJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmcl9jYTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9mci1jYS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBmcmlzaWFuIChmeSlcbi8vISBhdXRob3IgOiBSb2JpbiB2YW4gZGVyIFZsaWV0IDogaHR0cHM6Ly9naXRodWIuY29tL3JvYmluMHZhbjBkZXIwdlxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWFpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2Rlcy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0V2l0aG91dERvdHMgPSAnamFuX2ZlYl9tcnRfYXByX21haV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZXMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgZnkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmeScsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbm5ld2FyaXNfZmVicmV3YXJpc19tYWFydF9hcHJpbF9tYWFpZV9qdW55X2p1bHlfYXVndXN0dXNfc2VwdGltYmVyX29rdG9iZXJfbm92aW1iZXJfZGVzaW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aG91dERvdHNbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHNbbS5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2Vla2RheXMgOiAnc25laW5fbW9hbmRlaV90aWlzZGVpX3dvYW5zZGVpX3RvbmdlcnNkZWlfZnJlZWRfc25lb24nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnc2kuX21vLl90aS5fd28uX3RvLl9mci5fc28uJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTaV9Nb19UaV9Xb19Ub19Gcl9Tbycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC1NTS1ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1toam9lZCBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1ttb2FybiBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtvbV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tqdXN0ZXIgb21dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW8O0ZnLDu25lXSBkZGRkIFtvbV0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnb2VyICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgbHluJyxcbiAgICAgICAgICAgIHMgOiAnaW4gcGVhciBzZWtvbmRlbicsXG4gICAgICAgICAgICBtIDogJ2llbiBtaW7DunQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXG4gICAgICAgICAgICBoIDogJ2llbiBvZXJlJyxcbiAgICAgICAgICAgIGhoIDogJyVkIG9lcmVuJyxcbiAgICAgICAgICAgIGQgOiAnaWVuIGRlaScsXG4gICAgICAgICAgICBkZCA6ICclZCBkYWdlbicsXG4gICAgICAgICAgICBNIDogJ2llbiBtb2FubmUnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9hbm5lbicsXG4gICAgICAgICAgICB5IDogJ2llbiBqaWVyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGppZXJyZW4nXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICgobnVtYmVyID09PSAxIHx8IG51bWJlciA9PT0gOCB8fCBudW1iZXIgPj0gMjApID8gJ3N0ZScgOiAnZGUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnk7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogZ2FsaWNpYW4gKGdsKVxuLy8hIGF1dGhvciA6IEp1YW4gRy4gSHVydGFkbyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qdWFuZ2h1cnRhZG9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgZ2wgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdnbCcsIHtcbiAgICAgICAgbW9udGhzIDogJ1hhbmVpcm9fRmVicmVpcm9fTWFyem9fQWJyaWxfTWFpb19YdcOxb19YdWxsb19BZ29zdG9fU2V0ZW1icm9fT3V0dWJyb19Ob3ZlbWJyb19EZWNlbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnWGFuLl9GZWIuX01hci5fQWJyLl9NYWkuX1h1w7EuX1h1bC5fQWdvLl9TZXQuX091dC5fTm92Ll9EZWMuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdEb21pbmdvX0x1bnNfTWFydGVzX03DqXJjb3Jlc19Yb3Zlc19WZW5yZXNfU8OhYmFkbycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdEb20uX0x1bi5fTWFyLl9Nw6lyLl9Yb3YuX1Zlbi5fU8OhYi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RvX0x1X01hX03DqV9Yb19WZV9Tw6EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tob3hlICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6FzJyA6ICfDoScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbbWHDscOhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6FzJyA6ICfDoScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGRkZCBbJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoXMnIDogJ2EnKSArICddIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW29udGUgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoScgOiAnYScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW29dIGRkZGQgW3Bhc2FkbyAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnYScpICsgJ10gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAndW5zIHNlZ3VuZG9zJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bnMgc2VndW5kb3MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VuICcgKyBzdHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdCA6ICdoYWkgJXMnLFxuICAgICAgICAgICAgcyA6ICd1bnMgc2VndW5kb3MnLFxuICAgICAgICAgICAgbSA6ICd1biBtaW51dG8nLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXG4gICAgICAgICAgICBoIDogJ3VuaGEgaG9yYScsXG4gICAgICAgICAgICBoaCA6ICclZCBob3JhcycsXG4gICAgICAgICAgICBkIDogJ3VuIGTDrWEnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZMOtYXMnLFxuICAgICAgICAgICAgTSA6ICd1biBtZXMnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxuICAgICAgICAgICAgeSA6ICd1biBhbm8nLFxuICAgICAgICAgICAgeXkgOiAnJWQgYW5vcydcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBnbDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9nbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBIZWJyZXcgKGhlKVxuLy8hIGF1dGhvciA6IFRvbWVyIENvaGVuIDogaHR0cHM6Ly9naXRodWIuY29tL3RvbWVyXG4vLyEgYXV0aG9yIDogTW9zaGUgU2ltYW50b3YgOiBodHRwczovL2dpdGh1Yi5jb20vRGV2ZWxvcG1lbnRJTFxuLy8hIGF1dGhvciA6IFRhbCBBdGVyIDogaHR0cHM6Ly9naXRodWIuY29tL1RhbEF0ZXJcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgaGUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdoZScsIHtcbiAgICAgICAgbW9udGhzIDogJ9eZ16DXldeQ16hf16TXkdeo15XXkNeoX9ee16jXpV/XkNek16jXmdecX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXldeh15hf16HXpNeY157XkdeoX9eQ15XXp9eY15XXkdeoX9eg15XXkdee15HXqF/Xk9em157XkdeoJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfXmdeg15XXs1/XpNeR16jXs1/Xnteo16Vf15DXpNeo17Nf157XkNeZX9eZ15XXoNeZX9eZ15XXnNeZX9eQ15XXktezX9eh16TXmNezX9eQ15XXp9ezX9eg15XXkdezX9eT16bXntezJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfXqNeQ16nXldefX9ep16DXmV/Xqdec15nXqdeZX9eo15HXmdei15lf15fXnteZ16nXmV/XqdeZ16nXmV/XqdeR16onLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn15DXs1/XkdezX9eS17Nf15PXs1/XlNezX9eV17Nf16nXsycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn15Bf15Ff15Jf15Nf15Rf15Vf16knLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFvXkV1NTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgW9eRXU1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW9eRXU1NTU0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBsIDogJ0QvTS9ZWVlZJyxcbiAgICAgICAgICAgIGxsIDogJ0QgTU1NIFlZWVknLFxuICAgICAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgbGxsbCA6ICdkZGQsIEQgTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb15TXmdeV150g15HWvl1MVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vXnteX16gg15HWvl1MVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvXkdep16LXlF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb15DXqtee15XXnCDXkda+XUxUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vXkdeZ15XXnV0gZGRkZCBb15TXkNeX16jXldefINeR16nXoteUXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn15HXoteV15MgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfXnNek16DXmSAlcycsXG4gICAgICAgICAgICBzIDogJ9ee16HXpNeoINep16DXmdeV16onLFxuICAgICAgICAgICAgbSA6ICfXk9en15QnLFxuICAgICAgICAgICAgbW0gOiAnJWQg15PXp9eV16onLFxuICAgICAgICAgICAgaCA6ICfXqdei15QnLFxuICAgICAgICAgICAgaGggOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ9ep16LXqteZ15nXnSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINep16LXldeqJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkIDogJ9eZ15XXnScsXG4gICAgICAgICAgICBkZCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAn15nXldee15nXmdedJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg15nXnteZ150nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE0gOiAn15fXldeT16knLFxuICAgICAgICAgICAgTU0gOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ9eX15XXk9ep15nXmdedJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg15fXldeT16nXmdedJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5IDogJ9ep16DXlCcsXG4gICAgICAgICAgICB5eSA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAn16nXoNeq15nXmdedJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciAlIDEwID09PSAwICYmIG51bWJlciAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg16nXoNeUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg16nXoNeZ150nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGU7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogaGluZGkgKGhpKVxuLy8hIGF1dGhvciA6IE1heWFuayBTaW5naGFsIDogaHR0cHM6Ly9naXRodWIuY29tL21heWFua3NpbmdoYWxcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfgpacnLFxuICAgICAgICAnMic6ICfgpagnLFxuICAgICAgICAnMyc6ICfgpaknLFxuICAgICAgICAnNCc6ICfgpaonLFxuICAgICAgICAnNSc6ICfgpasnLFxuICAgICAgICAnNic6ICfgpawnLFxuICAgICAgICAnNyc6ICfgpa0nLFxuICAgICAgICAnOCc6ICfgpa4nLFxuICAgICAgICAnOSc6ICfgpa8nLFxuICAgICAgICAnMCc6ICfgpaYnXG4gICAgfSxcbiAgICBudW1iZXJNYXAgPSB7XG4gICAgICAgICfgpacnOiAnMScsXG4gICAgICAgICfgpagnOiAnMicsXG4gICAgICAgICfgpaknOiAnMycsXG4gICAgICAgICfgpaonOiAnNCcsXG4gICAgICAgICfgpasnOiAnNScsXG4gICAgICAgICfgpawnOiAnNicsXG4gICAgICAgICfgpa0nOiAnNycsXG4gICAgICAgICfgpa4nOiAnOCcsXG4gICAgICAgICfgpa8nOiAnOScsXG4gICAgICAgICfgpaYnOiAnMCdcbiAgICB9O1xuXG4gICAgdmFyIGhpID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaGknLCB7XG4gICAgICAgIG1vbnRocyA6ICfgpJzgpKjgpLXgpLDgpYBf4KSr4KS84KSw4KS14KSw4KWAX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYjgpLJf4KSu4KSIX+CknOClguCkqF/gpJzgpYHgpLLgpL7gpIhf4KSF4KSX4KS44KWN4KSkX+CkuOCkv+CkpOCkruCljeCkrOCksF/gpIXgpJXgpY3gpJ/gpYLgpKzgpLBf4KSo4KS14KSu4KWN4KSs4KSwX+CkpuCkv+CkuOCkruCljeCkrOCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4KSc4KSoLl/gpKvgpLzgpLAuX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYguX+CkruCkiF/gpJzgpYLgpKhf4KSc4KWB4KSyLl/gpIXgpJcuX+CkuOCkv+CkpC5f4KSF4KSV4KWN4KSf4KWCLl/gpKjgpLUuX+CkpuCkv+CkuC4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+CksOCkteCkv+CkteCkvuCksF/gpLjgpYvgpK7gpLXgpL7gpLBf4KSu4KSC4KSX4KSy4KS14KS+4KSwX+CkrOClgeCkp+CkteCkvuCksF/gpJfgpYHgpLDgpYLgpLXgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwX+CktuCkqOCkv+CkteCkvuCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cksl/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CksF/gpLjgpYtf4KSu4KSCX+CkrOClgV/gpJfgpYFf4KS24KWBX+Ckticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0g4KSs4KSc4KWHJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4KSs4KSc4KWHJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgpKzgpJzgpYcnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCkrOCknOClhydcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CkleCksl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KSV4KSyXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4KSq4KS/4KSb4KSy4KWHXSBkZGRkLCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXMg4KSu4KWH4KSCJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMg4KSq4KS54KSy4KWHJyxcbiAgICAgICAgICAgIHMgOiAn4KSV4KWB4KSbIOCkueClgCDgpJXgpY3gpLfgpKMnLFxuICAgICAgICAgICAgbSA6ICfgpI/gpJUg4KSu4KS/4KSo4KSfJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOCkruCkv+CkqOCknycsXG4gICAgICAgICAgICBoIDogJ+Ckj+CklSDgpJjgpILgpJ/gpL4nLFxuICAgICAgICAgICAgaGggOiAnJWQg4KSY4KSC4KSf4KWHJyxcbiAgICAgICAgICAgIGQgOiAn4KSP4KSVIOCkpuCkv+CkqCcsXG4gICAgICAgICAgICBkZCA6ICclZCDgpKbgpL/gpKgnLFxuICAgICAgICAgICAgTSA6ICfgpI/gpJUg4KSu4KS54KWA4KSo4KWHJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOCkruCkueClgOCkqOClhycsXG4gICAgICAgICAgICB5IDogJ+Ckj+CklSDgpLXgpLDgpY3gpLcnLFxuICAgICAgICAgICAgeXkgOiAnJWQg4KS14KSw4KWN4KS3J1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4KWn4KWo4KWp4KWq4KWr4KWs4KWt4KWu4KWv4KWmXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBIaW5kaSBub3RhdGlvbiBmb3IgbWVyaWRpZW1zIGFyZSBxdWl0ZSBmdXp6eSBpbiBwcmFjdGljZS4gV2hpbGUgdGhlcmUgZXhpc3RzXG4gICAgICAgIC8vIGEgcmlnaWQgbm90aW9uIG9mIGEgJ1BhaGFyJyBpdCBpcyBub3QgdXNlZCBhcyByaWdpZGx5IGluIG1vZGVybiBIaW5kaS5cbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpHzgpLjgpYHgpKzgpLl84KSm4KWL4KSq4KS54KSwfOCktuCkvuCkri8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpYHgpKzgpLknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KWL4KSq4KS54KSwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLbgpL7gpK4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KS44KWB4KSs4KS5JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpKbgpYvgpKrgpLngpLAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CktuCkvuCkric7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGk7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaGkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogaHJ2YXRza2kgKGhyKVxuLy8hIGF1dGhvciA6IEJvamFuIE1hcmtvdmnEhyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ibWFya292aWNcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdqZWRuYSBtaW51dGEnIDogJ2plZG5lIG1pbnV0ZSc7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2plZGFuIHNhdCcgOiAnamVkbm9nIHNhdGEnO1xuICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0YSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0aSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdkYW4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2RhbmEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2EnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaHIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdocicsIHtcbiAgICAgICAgbW9udGhzIDogJ3NpamXEjWFual92ZWxqYcSNYV9vxb51amFrX3RyYXZhbmpfc3ZpYmFual9saXBhbmpfc3JwYW5qX2tvbG92b3pfcnVqYW5fbGlzdG9wYWRfc3R1ZGVuaV9wcm9zaW5hYycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnc2lqLl92ZWxqLl9vxb51Ll90cmEuX3N2aS5fbGlwLl9zcnAuX2tvbC5fcnVqLl9saXMuX3N0dS5fcHJvLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnbmVkamVsamFfcG9uZWRqZWxqYWtfdXRvcmFrX3NyaWplZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICduZWQuX3Bvbi5fdXRvLl9zcmkuX8SNZXQuX3BldC5fc3ViLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC4gTU0uIFlZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgIDogJ1tkYW5hcyB1XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5ICA6ICdbc3V0cmEgdV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkamVsanVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3JpamVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZXIgdV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbGldIGRkZGQgW3VdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXG4gICAgICAgICAgICBzICAgICAgOiAncGFyIHNla3VuZGknLFxuICAgICAgICAgICAgbSAgICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaCAgICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggICAgIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZCAgICAgIDogJ2RhbicsXG4gICAgICAgICAgICBkZCAgICAgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNICAgICAgOiAnbWplc2VjJyxcbiAgICAgICAgICAgIE1NICAgICA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxuICAgICAgICAgICAgeXkgICAgIDogdHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBocjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9oci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBodW5nYXJpYW4gKGh1KVxuLy8hIGF1dGhvciA6IEFkYW0gQnJ1bm5lciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZGFtYnJ1bm5lclxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB3ZWVrRW5kaW5ncyA9ICd2YXPDoXJuYXAgaMOpdGbFkW4ga2VkZGVuIHN6ZXJkw6FuIGNzw7x0w7ZydMO2a8O2biBww6ludGVrZW4gc3pvbWJhdG9uJy5zcGxpdCgnICcpO1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG51bSA9IG51bWJlcixcbiAgICAgICAgICAgIHN1ZmZpeDtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXgpID8gJ27DqWjDoW55IG3DoXNvZHBlcmMnIDogJ27DqWjDoW55IG3DoXNvZHBlcmNlJztcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgcGVyYycgOiAnIHBlcmNlJyk7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgcGVyYycgOiAnIHBlcmNlJyk7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgcmV0dXJuICdlZ3knICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIMOzcmEnIDogJyDDs3LDoWphJyk7XG4gICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw7NyYScgOiAnIMOzcsOhamEnKTtcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgbmFwJyA6ICcgbmFwamEnKTtcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICAgICAgcmV0dXJuIG51bSArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyBuYXAnIDogJyBuYXBqYScpO1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHJldHVybiAnZWd5JyArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyBow7NuYXAnIDogJyBow7NuYXBqYScpO1xuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIGjDs25hcCcgOiAnIGjDs25hcGphJyk7XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgcmV0dXJuICdlZ3knICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIMOpdicgOiAnIMOpdmUnKTtcbiAgICAgICAgY2FzZSAneXknOlxuICAgICAgICAgICAgcmV0dXJuIG51bSArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyDDqXYnIDogJyDDqXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZWVrKGlzRnV0dXJlKSB7XG4gICAgICAgIHJldHVybiAoaXNGdXR1cmUgPyAnJyA6ICdbbcO6bHRdICcpICsgJ1snICsgd2Vla0VuZGluZ3NbdGhpcy5kYXkoKV0gKyAnXSBMVFsta29yXSc7XG4gICAgfVxuXG4gICAgdmFyIGh1ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaHUnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW51w6FyX2ZlYnJ1w6FyX23DoXJjaXVzX8OhcHJpbGlzX23DoWp1c19qw7puaXVzX2rDumxpdXNfYXVndXN6dHVzX3N6ZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbcOhcmNfw6Fwcl9tw6FqX2rDum5fasO6bF9hdWdfc3plcHRfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ3Zhc8Ohcm5hcF9ow6l0ZsWRX2tlZGRfc3plcmRhX2Nzw7x0w7ZydMO2a19ww6ludGVrX3N6b21iYXQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAndmFzX2jDqXRfa2VkZF9zemVfY3PDvHRfcMOpbl9zem8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ3ZfaF9rX3N6ZV9jc19wX3N6bycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS5NTS5ERC4nLFxuICAgICAgICAgICAgTEwgOiAnWVlZWS4gTU1NTSBELicsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWS4gTU1NTSBELiBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWS4gTU1NTSBELiwgZGRkZCBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvZGV8ZHUvaSxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd1JztcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPT09IHRydWUgPyAnZGUnIDogJ0RFJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPT09IHRydWUgPyAnZHUnIDogJ0RVJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1ttYV0gTFRbLWtvcl0nLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbaG9sbmFwXSBMVFsta29yXScsXG4gICAgICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Vlay5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW3RlZ25hcF0gTFRbLWtvcl0nLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlZWsuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIG3Dumx2YScsXG4gICAgICAgICAgICBwYXN0IDogJyVzJyxcbiAgICAgICAgICAgIHMgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGh1O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2h1LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IEFybWVuaWFuIChoeS1hbSlcbi8vISBhdXRob3IgOiBBcm1lbmRhcmFieWFuIDogaHR0cHM6Ly9naXRodWIuY29tL2FybWVuZGFyYWJ5YW5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBtb250aHNDYXNlUmVwbGFjZShtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIG1vbnRocyA9IHtcbiAgICAgICAgICAgICdub21pbmF0aXZlJzogJ9Ww1bjWgtW21b7VodaAX9aD1aXVv9aA1b7VodaAX9W01aHWgNW/X9Wh1brWgNWr1axf1bTVodW11avVvV/VsNW41oLVttWr1b1f1bDVuNaC1azVq9W9X9aF1aPVuNW91b/VuNW9X9W91aXVutW/1aXVtNWi1aXWgF/VsNW41a/Vv9Wl1bTVotWl1oBf1bbVuNW11aXVtNWi1aXWgF/VpNWl1a/Vv9Wl1bTVotWl1oAnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICfVsNW41oLVttW+1aHWgNWrX9aD1aXVv9aA1b7VodaA1atf1bTVodaA1b/Vq1/VodW61oDVq9Ws1atf1bTVodW11avVvdWrX9Ww1bjWgtW21avVvdWrX9Ww1bjWgtWs1avVvdWrX9aF1aPVuNW91b/VuNW91atf1b3VpdW61b/VpdW01aLVpdaA1atf1bDVuNWv1b/VpdW01aLVpdaA1atf1bbVuNW11aXVtNWi1aXWgNWrX9Wk1aXVr9W/1aXVtNWi1aXWgNWrJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdW5DYXNlID0gKC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgJ25vbWluYXRpdmUnO1xuICAgICAgICByZXR1cm4gbW9udGhzW25vdW5DYXNlXVttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydENhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgbW9udGhzU2hvcnQgPSAn1bDVttW+X9aD1b/WgF/VtNaA1b9f1aHVutaAX9W01bXVvV/VsNW21b1f1bDVrNW9X9aF1aPVvV/VvdW61b9f1bDVr9W/X9W21bTVol/VpNWv1b8nLnNwbGl0KCdfJyk7XG4gICAgICAgIHJldHVybiBtb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSAn1a/Vq9aA1aHVr9WrX9Wl1oDVr9W41oLVt9Wh1aLVqdWrX9Wl1oDVpdaE1bfVodWi1anVq1/VudW41oDVpdaE1bfVodWi1anVq1/VsNWr1bbVo9W31aHVotWp1atf1bjWgtaA1aLVodWpX9W31aHVotWh1aknLnNwbGl0KCdfJyk7XG4gICAgICAgIHJldHVybiB3ZWVrZGF5c1ttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgaHlfYW0gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdoeS1hbScsIHtcbiAgICAgICAgbW9udGhzIDogbW9udGhzQ2FzZVJlcGxhY2UsXG4gICAgICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnRDYXNlUmVwbGFjZSxcbiAgICAgICAgd2Vla2RheXMgOiB3ZWVrZGF5c0Nhc2VSZXBsYWNlLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9Wv1oDVr1/VpdaA1a9f1aXWgNaEX9W51oDWhF/VsNW21aNf1bjWgtaA1aJf1bfVotWpJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfVr9aA1a9f1aXWgNWvX9Wl1oDWhF/VudaA1oRf1bDVttWjX9W41oLWgNWiX9W31aLVqScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZINWpLicsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg1akuLCBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZINWpLiwgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vVodW11b3WhdaAXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW9W+1aHVstWoXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9Wl1oDVpdWvXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGRkZCBb1oXWgNWoINWq1aHVtNWoXSBMVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1vVodW21oHVodWuXSBkZGRkIFvWhdaA1agg1arVodW01ahdIExUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDVsNWl1b/VuCcsXG4gICAgICAgICAgICBwYXN0IDogJyVzINWh1bzVodW7JyxcbiAgICAgICAgICAgIHMgOiAn1bTVqyDWhNWh1bbVqyDVvtWh1bXWgNWv1bXVodW2JyxcbiAgICAgICAgICAgIG0gOiAn1oDVuNW61aUnLFxuICAgICAgICAgICAgbW0gOiAnJWQg1oDVuNW61aUnLFxuICAgICAgICAgICAgaCA6ICfVqtWh1bQnLFxuICAgICAgICAgICAgaGggOiAnJWQg1arVodW0JyxcbiAgICAgICAgICAgIGQgOiAn1oXWgCcsXG4gICAgICAgICAgICBkZCA6ICclZCDWhdaAJyxcbiAgICAgICAgICAgIE0gOiAn1aHVtNWr1b0nLFxuICAgICAgICAgICAgTU0gOiAnJWQg1aHVtNWr1b0nLFxuICAgICAgICAgICAgeSA6ICfVv9Wh1oDVqycsXG4gICAgICAgICAgICB5eSA6ICclZCDVv9Wh1oDVqydcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL9Wj1avVt9Wl1oDVvtWhfNWh1bzVodW+1bjVv9W+1aF81oHVpdaA1aXVr9W+1aF81aXWgNWl1a/VuNW11aHVti8sXG4gICAgICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKNaB1aXWgNWl1a/VvtWhfNWl1oDVpdWv1bjVtdWh1bYpJC8udGVzdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn1aPVq9W31aXWgNW+1aEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Wh1bzVodW+1bjVv9W+1aEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9aB1aXWgNWl1a/VvtWhJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfVpdaA1aXVr9W41bXVodW2JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn18XFxkezEsMn0tKNWr1bZ81oDVpCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgIGNhc2UgJ0RERG8nOlxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct1avVtic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdaA1aQnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoeV9hbTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9oeS1hbS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBCYWhhc2EgSW5kb25lc2lhIChpZClcbi8vISBhdXRob3IgOiBNb2hhbW1hZCBTYXRyaW8gVXRvbW8gOiBodHRwczovL2dpdGh1Yi5jb20vdHlva1xuLy8hIHJlZmVyZW5jZTogaHR0cDovL2lkLndpa2lzb3VyY2Uub3JnL3dpa2kvUGVkb21hbl9VbXVtX0VqYWFuX0JhaGFzYV9JbmRvbmVzaWFfeWFuZ19EaXNlbXB1cm5ha2FuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGlkID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaWQnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hcmV0X0FwcmlsX01laV9KdW5pX0p1bGlfQWd1c3R1c19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01laV9KdW5fSnVsX0Fnc19TZXBfT2t0X05vdl9EZXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ01pbmdndV9TZW5pbl9TZWxhc2FfUmFidV9LYW1pc19KdW1hdF9TYWJ0dScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdNaW5fU2VuX1NlbF9SYWJfS2FtX0p1bV9TYWInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ01nX1NuX1NsX1JiX0ttX0ptX1NiJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hILm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISC5tbS5zcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvcGFnaXxzaWFuZ3xzb3JlfG1hbGFtLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ3BhZ2knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc2lhbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NvcmUnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc2lhbmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzb3JlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0Jlc29rIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbS2VtYXJpbiBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbbGFsdSBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2RhbGFtICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgeWFuZyBsYWx1JyxcbiAgICAgICAgICAgIHMgOiAnYmViZXJhcGEgZGV0aWsnLFxuICAgICAgICAgICAgbSA6ICdzZW1lbml0JyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1lbml0JyxcbiAgICAgICAgICAgIGggOiAnc2VqYW0nLFxuICAgICAgICAgICAgaGggOiAnJWQgamFtJyxcbiAgICAgICAgICAgIGQgOiAnc2VoYXJpJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGhhcmknLFxuICAgICAgICAgICAgTSA6ICdzZWJ1bGFuJyxcbiAgICAgICAgICAgIE1NIDogJyVkIGJ1bGFuJyxcbiAgICAgICAgICAgIHkgOiAnc2V0YWh1bicsXG4gICAgICAgICAgICB5eSA6ICclZCB0YWh1bidcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaWQ7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvaWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogaWNlbGFuZGljIChpcylcbi8vISBhdXRob3IgOiBIaW5yaWsgw5ZybiBTaWd1csOwc3NvbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9oaW5yaWtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwobikge1xuICAgICAgICBpZiAobiAlIDEwMCA9PT0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG4gJSAxMCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbm9ra3JhciBzZWvDum5kdXInIDogJ25va2tydW0gc2Vrw7puZHVtJztcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtw61uw7p0YScgOiAnbcOtbsO6dHUnO1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbcOtbsO6dHVyJyA6ICdtw61uw7p0dW0nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcOtbsO6dGEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw61uw7p0dSc7XG4gICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdrbHVra3VzdHVuZGlyJyA6ICdrbHVra3VzdHVuZHVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2tsdWtrdXN0dW5kJztcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGFndXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ2RhZycgOiAnZGVnaSc7XG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZGFnYXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ2RhZ2EnIDogJ2TDtmd1bScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkYWd1cic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ2RhZycgOiAnZGVnaScpO1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtw6FudcOwdXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ23DoW51w7AnIDogJ23DoW51w7BpJztcbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgaWYgKHBsdXJhbChudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw6FudcOwaXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ23DoW51w7BpJyA6ICdtw6FudcOwdW0nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcOhbnXDsHVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnbcOhbnXDsCcgOiAnbcOhbnXDsGknKTtcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICfDoXInIDogJ8OhcmknO1xuICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnw6FyJyA6ICfDoXJ1bScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ8OhcicgOiAnw6FyaScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaXMnLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW7DumFyX2ZlYnLDumFyX21hcnNfYXByw61sX21hw61fasO6bsOtX2rDumzDrV/DoWfDunN0X3NlcHRlbWJlcl9va3TDs2Jlcl9uw7N2ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYcOtX2rDum5fasO6bF/DoWfDul9zZXBfb2t0X27Ds3ZfZGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzdW5udWRhZ3VyX23DoW51ZGFndXJfw75yacOwanVkYWd1cl9tacOwdmlrdWRhZ3VyX2ZpbW10dWRhZ3VyX2bDtnN0dWRhZ3VyX2xhdWdhcmRhZ3VyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3N1bl9tw6FuX8O+cmlfbWnDsF9maW1fZsO2c19sYXUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ1N1X03DoV/DnnJfTWlfRmlfRsO2X0xhJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIFtrbC5dIEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBELiBNTU1NIFlZWVkgW2tsLl0gSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vDrSBkYWcga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vDoSBtb3JndW4ga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtrbC5dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW8OtIGfDpnIga2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbc8Otw7Bhc3RhXSBkZGRkIFtrbC5dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdlZnRpciAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2Z5cmlyICVzIHPDrcOwYW4nLFxuICAgICAgICAgICAgcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiAna2x1a2t1c3R1bmQnLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgZGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgTU0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5IDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2lzLmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGl0YWxpYW4gKGl0KVxuLy8hIGF1dGhvciA6IExvcmVuem8gOiBodHRwczovL2dpdGh1Yi5jb20vYWxpZW1cbi8vISBhdXRob3I6IE1hdHRpYSBMYXJlbnRpczogaHR0cHM6Ly9naXRodWIuY29tL25vc3RhbGdpYXpcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgaXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdpdCcsIHtcbiAgICAgICAgbW9udGhzIDogJ2dlbm5haW9fZmViYnJhaW9fbWFyem9fYXByaWxlX21hZ2dpb19naXVnbm9fbHVnbGlvX2Fnb3N0b19zZXR0ZW1icmVfb3R0b2JyZV9ub3ZlbWJyZV9kaWNlbWJyZScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnZ2VuX2ZlYl9tYXJfYXByX21hZ19naXVfbHVnX2Fnb19zZXRfb3R0X25vdl9kaWMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0RvbWVuaWNhX0x1bmVkw6xfTWFydGVkw6xfTWVyY29sZWTDrF9HaW92ZWTDrF9WZW5lcmTDrF9TYWJhdG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnRG9tX0x1bl9NYXJfTWVyX0dpb19WZW5fU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdEX0xfTWFfTWVfR19WX1MnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW09nZ2kgYWxsZV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tEb21hbmkgYWxsZV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthbGxlXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0llcmkgYWxsZV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbGEgc2NvcnNhXSBkZGRkIFthbGxlXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tsbyBzY29yc29dIGRkZGQgW2FsbGVdIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKC9eWzAtOV0uKyQvKS50ZXN0KHMpID8gJ3RyYScgOiAnaW4nKSArICcgJyArIHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdCA6ICclcyBmYScsXG4gICAgICAgICAgICBzIDogJ2FsY3VuaSBzZWNvbmRpJyxcbiAgICAgICAgICAgIG0gOiAndW4gbWludXRvJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0aScsXG4gICAgICAgICAgICBoIDogJ3VuXFwnb3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIG9yZScsXG4gICAgICAgICAgICBkIDogJ3VuIGdpb3JubycsXG4gICAgICAgICAgICBkZCA6ICclZCBnaW9ybmknLFxuICAgICAgICAgICAgTSA6ICd1biBtZXNlJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc2knLFxuICAgICAgICAgICAgeSA6ICd1biBhbm5vJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFubmknXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcbiAgICAgICAgb3JkaW5hbDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpdDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9pdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBqYXBhbmVzZSAoamEpXG4vLyEgYXV0aG9yIDogTEkgTG9uZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJ5b25cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgamEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdqYScsIHtcbiAgICAgICAgbW9udGhzIDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn5pel5puc5pelX+aciOabnOaXpV/ngavmm5zml6Vf5rC05puc5pelX+acqOabnOaXpV/ph5Hmm5zml6Vf5Zyf5puc5pelJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+aXpV/mnIhf54GrX+awtF/mnKhf6YeRX+Wcnycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn5pelX+aciF/ngatf5rC0X+acqF/ph5Ff5ZyfJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0Fo5pmCbeWIhicsXG4gICAgICAgICAgICBMVFMgOiAnQWjmmYJt5YiGc+enkicsXG4gICAgICAgICAgICBMIDogJ1lZWVkvTU0vREQnLFxuICAgICAgICAgICAgTEwgOiAnWVlZWeW5tE3mnIhE5pelJyxcbiAgICAgICAgICAgIExMTCA6ICdZWVlZ5bm0TeaciETml6VBaOaZgm3liIYnLFxuICAgICAgICAgICAgTExMTCA6ICdZWVlZ5bm0TeaciETml6VBaOaZgm3liIYgZGRkZCdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+WNiOWJjXzljYjlvowvaSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09PSAn5Y2I5b6MJztcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfljYjliY0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+WNiOW+jCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb5LuK5pelXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vmmI7ml6VdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vmnaXpgLFdZGRkZCBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vmmKjml6VdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vliY3pgLFdZGRkZCBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXPlvownLFxuICAgICAgICAgICAgcGFzdCA6ICclc+WJjScsXG4gICAgICAgICAgICBzIDogJ+aVsOenkicsXG4gICAgICAgICAgICBtIDogJzHliIYnLFxuICAgICAgICAgICAgbW0gOiAnJWTliIYnLFxuICAgICAgICAgICAgaCA6ICcx5pmC6ZaTJyxcbiAgICAgICAgICAgIGhoIDogJyVk5pmC6ZaTJyxcbiAgICAgICAgICAgIGQgOiAnMeaXpScsXG4gICAgICAgICAgICBkZCA6ICclZOaXpScsXG4gICAgICAgICAgICBNIDogJzHjg7bmnIgnLFxuICAgICAgICAgICAgTU0gOiAnJWTjg7bmnIgnLFxuICAgICAgICAgICAgeSA6ICcx5bm0JyxcbiAgICAgICAgICAgIHl5IDogJyVk5bm0J1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gamE7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvamEuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogQm9zbyBKb3dvIChqdilcbi8vISBhdXRob3IgOiBSb255IExhbnRpcCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9sYW50aXBcbi8vISByZWZlcmVuY2U6IGh0dHA6Ly9qdi53aWtpcGVkaWEub3JnL3dpa2kvQmFzYV9KYXdhXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGp2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnanYnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hcmV0X0FwcmlsX01laV9KdW5pX0p1bGlfQWd1c3R1c19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3BlbWJlcl9EZXNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01laV9KdW5fSnVsX0Fnc19TZXBfT2t0X05vcF9EZXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ01pbmdndV9TZW5lbl9TZWxvc29fUmVidV9LZW1pc19KZW11d2FoX1NlcHR1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ01pbl9TZW5fU2VsX1JlYl9LZW1fSmVtX1NlcCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnTWdfU25fU2xfUmJfS21fSm1fU3AnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEgubW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC9lbmppbmd8c2l5YW5nfHNvbnRlbnxuZGFsdS8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdlbmppbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc2l5YW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzb250ZW4nIHx8IG1lcmlkaWVtID09PSAnbmRhbHUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdlbmppbmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzaXlhbmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzb250ZW4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25kYWx1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tEaW50ZW4gcHVuaWtvIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tNYmVuamFuZyBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0thbGEgd2luZ2kgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2tlcGVuZ2tlciBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3dvbnRlbiBpbmcgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBpbmdrYW5nIGtlcGVuZ2tlcicsXG4gICAgICAgICAgICBzIDogJ3Nhd2V0YXdpcyBkZXRpaycsXG4gICAgICAgICAgICBtIDogJ3NldHVuZ2dhbCBtZW5pdCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtZW5pdCcsXG4gICAgICAgICAgICBoIDogJ3NldHVuZ2dhbCBqYW0nLFxuICAgICAgICAgICAgaGggOiAnJWQgamFtJyxcbiAgICAgICAgICAgIGQgOiAnc2VkaW50ZW4nLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGludGVuJyxcbiAgICAgICAgICAgIE0gOiAnc2V3dWxhbicsXG4gICAgICAgICAgICBNTSA6ICclZCB3dWxhbicsXG4gICAgICAgICAgICB5IDogJ3NldGF1bicsXG4gICAgICAgICAgICB5eSA6ICclZCB0YXVuJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBqdjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9qdi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBHZW9yZ2lhbiAoa2EpXG4vLyEgYXV0aG9yIDogSXJha2xpIEphbmlhc2h2aWxpIDogaHR0cHM6Ly9naXRodWIuY29tL2lyYWtsaS1qYW5pYXNodmlsaVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIG1vbnRoc0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgbW9udGhzID0ge1xuICAgICAgICAgICAgJ25vbWluYXRpdmUnOiAn4YOY4YOQ4YOc4YOV4YOQ4YOg4YOYX+GDl+GDlOGDkeGDlOGDoOGDleGDkOGDmuGDmF/hg5vhg5Dhg6Dhg6Lhg5hf4YOQ4YOe4YOg4YOY4YOa4YOYX+GDm+GDkOGDmOGDoeGDmF/hg5jhg5Xhg5zhg5jhg6Hhg5hf4YOY4YOV4YOa4YOY4YOh4YOYX+GDkOGDkuGDleGDmOGDoeGDouGDnV/hg6Hhg5Thg6Xhg6Lhg5Thg5vhg5Hhg5Thg6Dhg5hf4YOd4YOl4YOi4YOd4YOb4YOR4YOU4YOg4YOYX+GDnOGDneGDlOGDm+GDkeGDlOGDoOGDmF/hg5Phg5Thg5nhg5Thg5vhg5Hhg5Thg6Dhg5gnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICfhg5jhg5Dhg5zhg5Xhg5Dhg6Dhg6Ff4YOX4YOU4YOR4YOU4YOg4YOV4YOQ4YOa4YOhX+GDm+GDkOGDoOGDouGDoV/hg5Dhg57hg6Dhg5jhg5rhg5jhg6Ff4YOb4YOQ4YOY4YOh4YOhX+GDmOGDleGDnOGDmOGDoeGDoV/hg5jhg5Xhg5rhg5jhg6Hhg6Ff4YOQ4YOS4YOV4YOY4YOh4YOi4YOhX+GDoeGDlOGDpeGDouGDlOGDm+GDkeGDlOGDoOGDoV/hg53hg6Xhg6Lhg53hg5vhg5Hhg5Thg6Dhg6Ff4YOc4YOd4YOU4YOb4YOR4YOU4YOg4YOhX+GDk+GDlOGDmeGDlOGDm+GDkeGDlOGDoOGDoScuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBub3VuQ2FzZSA9ICgvRFtvRF0gKk1NTU0/LykudGVzdChmb3JtYXQpID9cbiAgICAgICAgICAgICdhY2N1c2F0aXZlJyA6XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc7XG4gICAgICAgIHJldHVybiBtb250aHNbbm91bkNhc2VdW20ubW9udGgoKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzQ2FzZVJlcGxhY2UobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IHtcbiAgICAgICAgICAgICdub21pbmF0aXZlJzogJ+GDmeGDleGDmOGDoOGDkF/hg53hg6Dhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOh4YOQ4YOb4YOo4YOQ4YOR4YOQ4YOX4YOYX+GDneGDl+GDruGDqOGDkOGDkeGDkOGDl+GDmF/hg67hg6Phg5fhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOe4YOQ4YOg4YOQ4YOh4YOZ4YOU4YOV4YOYX+GDqOGDkOGDkeGDkOGDl+GDmCcuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgICdhY2N1c2F0aXZlJzogJ+GDmeGDleGDmOGDoOGDkOGDoV/hg53hg6Dhg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOh4YOQ4YOb4YOo4YOQ4YOR4YOQ4YOX4YOhX+GDneGDl+GDruGDqOGDkOGDkeGDkOGDl+GDoV/hg67hg6Phg5fhg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOe4YOQ4YOg4YOQ4YOh4YOZ4YOU4YOV4YOhX+GDqOGDkOGDkeGDkOGDl+GDoScuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBub3VuQ2FzZSA9ICgvKOGDrOGDmOGDnOGDkHzhg6jhg5Thg5vhg5Phg5Thg5IpLykudGVzdChmb3JtYXQpID9cbiAgICAgICAgICAgICdhY2N1c2F0aXZlJyA6XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc7XG4gICAgICAgIHJldHVybiB3ZWVrZGF5c1tub3VuQ2FzZV1bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGthID0gbW9tZW50LmRlZmluZUxvY2FsZSgna2EnLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRoc0Nhc2VSZXBsYWNlLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfhg5jhg5Dhg5xf4YOX4YOU4YORX+GDm+GDkOGDoF/hg5Dhg57hg6Bf4YOb4YOQ4YOYX+GDmOGDleGDnF/hg5jhg5Xhg5pf4YOQ4YOS4YOVX+GDoeGDlOGDpV/hg53hg6Xhg6Jf4YOc4YOd4YOUX+GDk+GDlOGDmScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiB3ZWVrZGF5c0Nhc2VSZXBsYWNlLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+GDmeGDleGDmF/hg53hg6Dhg6hf4YOh4YOQ4YObX+GDneGDl+GDrl/hg67hg6Phg5df4YOe4YOQ4YOgX+GDqOGDkOGDkScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4YOZ4YOVX+GDneGDoF/hg6Hhg5Bf4YOd4YOXX+GDruGDo1/hg57hg5Bf4YOo4YOQJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ2g6bW0gQScsXG4gICAgICAgICAgICBMVFMgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgaDptbSBBJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW+GDk+GDpuGDlOGDoV0gTFRbLeGDluGDlF0nLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb4YOu4YOV4YOQ4YOaXSBMVFst4YOW4YOUXScsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vhg5Lhg6Phg6jhg5jhg5xdIExUWy3hg5bhg5RdJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vhg6jhg5Thg5vhg5Phg5Thg5JdIGRkZGQgTFRbLeGDluGDlF0nLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+GDrOGDmOGDnOGDkF0gZGRkZCBMVC3hg5bhg5QnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKC8o4YOs4YOQ4YOb4YOYfOGDrOGDo+GDl+GDmHzhg6Hhg5Dhg5Dhg5fhg5h84YOs4YOU4YOa4YOYKS8pLnRlc3QocykgP1xuICAgICAgICAgICAgICAgICAgICBzLnJlcGxhY2UoL+GDmCQvLCAn4YOo4YOYJykgOlxuICAgICAgICAgICAgICAgICAgICBzICsgJ+GDqOGDmCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFzdCA6IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgvKOGDrOGDkOGDm+GDmHzhg6zhg6Phg5fhg5h84YOh4YOQ4YOQ4YOX4YOYfOGDk+GDpuGDlHzhg5fhg5Xhg5QpLykudGVzdChzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC8o4YOYfOGDlCkkLywgJ+GDmOGDoSDhg6zhg5jhg5wnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgv4YOs4YOU4YOa4YOYLykudGVzdChzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC/hg6zhg5Thg5rhg5gkLywgJ+GDrOGDmuGDmOGDoSDhg6zhg5jhg5wnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcyA6ICfhg6Dhg5Dhg5vhg5Phg5Thg5zhg5jhg5vhg5Qg4YOs4YOQ4YOb4YOYJyxcbiAgICAgICAgICAgIG0gOiAn4YOs4YOj4YOX4YOYJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOGDrOGDo+GDl+GDmCcsXG4gICAgICAgICAgICBoIDogJ+GDoeGDkOGDkOGDl+GDmCcsXG4gICAgICAgICAgICBoaCA6ICclZCDhg6Hhg5Dhg5Dhg5fhg5gnLFxuICAgICAgICAgICAgZCA6ICfhg5Phg6bhg5QnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4YOT4YOm4YOUJyxcbiAgICAgICAgICAgIE0gOiAn4YOX4YOV4YOUJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOGDl+GDleGDlCcsXG4gICAgICAgICAgICB5IDogJ+GDrOGDlOGDmuGDmCcsXG4gICAgICAgICAgICB5eSA6ICclZCDhg6zhg5Thg5rhg5gnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogLzB8MS3hg5rhg5h84YOb4YOULVxcZHsxLDJ9fFxcZHsxLDJ9LeGDlC8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3hg5rhg5gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChudW1iZXIgPCAyMCkgfHwgKG51bWJlciA8PSAxMDAgJiYgKG51bWJlciAlIDIwID09PSAwKSkgfHwgKG51bWJlciAlIDEwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+GDm+GDlC0nICsgbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct4YOUJztcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsXG4gICAgICAgICAgICBkb3kgOiA3XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBrYTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9rYS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBraG1lciAoa20pXG4vLyEgYXV0aG9yIDogS3J1eSBWYW5uYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcnV5dmFubmFcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIga20gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbScsIHtcbiAgICAgICAgbW9udGhzOiAn4Z6Y4Z6A4Z6a4Z62X+GegOGeu+GemOGfkuGel+GfiF/hnpjhnrfhnpPhnrZf4Z6Y4Z+B4Z6f4Z62X+Gep+Gen+Gel+Getl/hnpjhnrfhnpDhnrvhnpPhnrZf4Z6A4Z6A4Z+S4Z6A4Z6K4Z62X+Gen+GeuOGeoOGetl/hnoDhnonhn5LhnonhnrZf4Z6P4Z674Z6b4Z62X+GenOGet+GeheGfkuGehuGet+GegOGetl/hnpLhn5LhnpPhnrwnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0OiAn4Z6Y4Z6A4Z6a4Z62X+GegOGeu+GemOGfkuGel+GfiF/hnpjhnrfhnpPhnrZf4Z6Y4Z+B4Z6f4Z62X+Gep+Gen+Gel+Getl/hnpjhnrfhnpDhnrvhnpPhnrZf4Z6A4Z6A4Z+S4Z6A4Z6K4Z62X+Gen+GeuOGeoOGetl/hnoDhnonhn5LhnonhnrZf4Z6P4Z674Z6b4Z62X+GenOGet+GeheGfkuGehuGet+GegOGetl/hnpLhn5LhnpPhnrwnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzOiAn4Z6i4Z624Z6R4Z634Z6P4Z+S4Z6ZX+GeheGfkOGek+GfkuGekV/hnqLhnoThn5LhnoLhnrbhnppf4Z6W4Z674Z6SX+GeluGfkuGemuGeoOGen+GfkuGelOGej+Get+GfjV/hnp/hnrvhnoDhn5Lhnppf4Z6f4Z+F4Z6a4Z+NJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiAn4Z6i4Z624Z6R4Z634Z6P4Z+S4Z6ZX+GeheGfkOGek+GfkuGekV/hnqLhnoThn5LhnoLhnrbhnppf4Z6W4Z674Z6SX+GeluGfkuGemuGeoOGen+GfkuGelOGej+Get+GfjV/hnp/hnrvhnoDhn5Lhnppf4Z6f4Z+F4Z6a4Z+NJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ+GeouGetuGekeGet+Gej+GfkuGemV/hnoXhn5DhnpPhn5LhnpFf4Z6i4Z6E4Z+S4Z6C4Z624Z6aX+GeluGeu+Gekl/hnpbhn5LhnprhnqDhnp/hn5LhnpThno/hnrfhn41f4Z6f4Z674Z6A4Z+S4Z6aX+Gen+GfheGemuGfjScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1vhnpDhn5LhnoThn4PhnpPhn4gg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW+Gen+GfkuGeouGfguGegCDhnpjhn4nhn4ThnoRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBb4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW+GemOGfkuGen+Get+Gem+GemOGet+GeiSDhnpjhn4nhn4ThnoRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb4Z6f4Z6U4Z+S4Z6P4Z624Z6g4Z+N4Z6Y4Z674Z6TXSBb4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZToge1xuICAgICAgICAgICAgZnV0dXJlOiAnJXPhnpHhn4Dhno8nLFxuICAgICAgICAgICAgcGFzdDogJyVz4Z6Y4Z674Z6TJyxcbiAgICAgICAgICAgIHM6ICfhnpThn4nhnrvhnpPhn5LhnpjhnrbhnpPhnpzhnrfhnpPhnrbhnpHhnrgnLFxuICAgICAgICAgICAgbTogJ+GemOGeveGemeGek+GetuGekeGeuCcsXG4gICAgICAgICAgICBtbTogJyVkIOGek+GetuGekeGeuCcsXG4gICAgICAgICAgICBoOiAn4Z6Y4Z694Z6Z4Z6Y4Z+J4Z+E4Z6EJyxcbiAgICAgICAgICAgIGhoOiAnJWQg4Z6Y4Z+J4Z+E4Z6EJyxcbiAgICAgICAgICAgIGQ6ICfhnpjhnr3hnpnhnpDhn5LhnoThn4MnLFxuICAgICAgICAgICAgZGQ6ICclZCDhnpDhn5LhnoThn4MnLFxuICAgICAgICAgICAgTTogJ+GemOGeveGemeGegeGfgicsXG4gICAgICAgICAgICBNTTogJyVkIOGegeGfgicsXG4gICAgICAgICAgICB5OiAn4Z6Y4Z694Z6Z4Z6G4Z+S4Z6T4Z624Z+GJyxcbiAgICAgICAgICAgIHl5OiAnJWQg4Z6G4Z+S4Z6T4Z624Z+GJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95OiA0IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGttO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2ttLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGtvcmVhbiAoa28pXG4vLyFcbi8vISBhdXRob3JzXG4vLyFcbi8vISAtIEt5dW5nd29vaywgUGFyayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9reXVuZ3cwMGtcbi8vISAtIEplZWV5dWwgTGVlIDxqZWVleXVsQGdtYWlsLmNvbT5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIga28gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbycsIHtcbiAgICAgICAgbW9udGhzIDogJzHsm5RfMuyblF8z7JuUXzTsm5RfNeyblF827JuUXzfsm5RfOOyblF857JuUXzEw7JuUXzEx7JuUXzEy7JuUJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICcx7JuUXzLsm5RfM+yblF807JuUXzXsm5RfNuyblF837JuUXzjsm5RfOeyblF8xMOyblF8xMeyblF8xMuyblCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn7J287JqU7J28X+yblOyalOydvF/tmZTsmpTsnbxf7IiY7JqU7J28X+uqqeyalOydvF/quIjsmpTsnbxf7Yag7JqU7J28Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+ydvF/sm5Rf7ZmUX+yImF/rqqlf6riIX+2GoCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn7J28X+yblF/tmZRf7IiYX+uqqV/quIhf7YagJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0EgaOyLnCBt67aEJyxcbiAgICAgICAgICAgIExUUyA6ICdBIGjsi5wgbeu2hCBz7LSIJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS5NTS5ERCcsXG4gICAgICAgICAgICBMTCA6ICdZWVlZ64WEIE1NTU0gROydvCcsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwgQSBo7IucIG3rtoQnLFxuICAgICAgICAgICAgTExMTCA6ICdZWVlZ64WEIE1NTU0gROydvCBkZGRkIEEgaOyLnCBt67aEJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAn7Jik64qYIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAn64K07J28IExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICfslrTsoJwgTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAn7KeA64Kc7KO8IGRkZGQgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIO2bhCcsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOyghCcsXG4gICAgICAgICAgICBzIDogJ+uqh+y0iCcsXG4gICAgICAgICAgICBzcyA6ICclZOy0iCcsXG4gICAgICAgICAgICBtIDogJ+ydvOu2hCcsXG4gICAgICAgICAgICBtbSA6ICclZOu2hCcsXG4gICAgICAgICAgICBoIDogJ+2VnOyLnOqwhCcsXG4gICAgICAgICAgICBoaCA6ICclZOyLnOqwhCcsXG4gICAgICAgICAgICBkIDogJ+2VmOujqCcsXG4gICAgICAgICAgICBkZCA6ICclZOydvCcsXG4gICAgICAgICAgICBNIDogJ+2VnOuLrCcsXG4gICAgICAgICAgICBNTSA6ICclZOuLrCcsXG4gICAgICAgICAgICB5IDogJ+ydvOuFhCcsXG4gICAgICAgICAgICB5eSA6ICclZOuFhCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ97J28LyxcbiAgICAgICAgb3JkaW5hbCA6ICclZOydvCcsXG4gICAgICAgIG1lcmlkaWVtUGFyc2UgOiAv7Jik7KCEfOyYpO2bhC8sXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ+yYpO2bhCc7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCAxMiA/ICfsmKTsoIQnIDogJ+yYpO2bhCc7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBrbztcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9rby5qc1xuICoqIG1vZHVsZSBpZCA9IDI1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBMdXhlbWJvdXJnaXNoIChsYilcbi8vISBhdXRob3IgOiBtd2VpbWVyc2tpcmNoIDogaHR0cHM6Ly9naXRodWIuY29tL213ZWltZXJza2lyY2gsIERhdmlkIFJhaXNvbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rd2lzYXR6XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHtcbiAgICAgICAgICAgICdtJzogWydlbmcgTWludXR0JywgJ2VuZ2VyIE1pbnV0dCddLFxuICAgICAgICAgICAgJ2gnOiBbJ2VuZyBTdG9ubicsICdlbmdlciBTdG9ubiddLFxuICAgICAgICAgICAgJ2QnOiBbJ2VlbiBEYWcnLCAnZW5nZW0gRGFnJ10sXG4gICAgICAgICAgICAnTSc6IFsnZWUgTW91bnQnLCAnZW5nZW0gTW91bnQnXSxcbiAgICAgICAgICAgICd5JzogWydlZSBKb2VyJywgJ2VuZ2VtIEpvZXInXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NGdXR1cmVUaW1lKHN0cmluZykge1xuICAgICAgICB2YXIgbnVtYmVyID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZignICcpKTtcbiAgICAgICAgaWYgKGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2EgJyArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2FuICcgKyBzdHJpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQYXN0VGltZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YoJyAnKSk7XG4gICAgICAgIGlmIChlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuICd2aXJ1ICcgKyBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd2aXJ1biAnICsgc3RyaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdvcmQgYmVmb3JlIHRoZSBnaXZlbiBudW1iZXIgbG9zZXMgdGhlICctbicgZW5kaW5nLlxuICAgICAqIGUuZy4gJ2FuIDEwIERlZWcnIGJ1dCAnYSA1IERlZWcnXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHtpbnRlZ2VyfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIE51bWJlciAtLT4gYWx3YXlzIHRydWVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDEwKSB7XG4gICAgICAgICAgICAvLyBPbmx5IDEgZGlnaXRcbiAgICAgICAgICAgIGlmICg0IDw9IG51bWJlciAmJiBudW1iZXIgPD0gNykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDEwMCkge1xuICAgICAgICAgICAgLy8gMiBkaWdpdHNcbiAgICAgICAgICAgIHZhciBsYXN0RGlnaXQgPSBudW1iZXIgJSAxMCwgZmlyc3REaWdpdCA9IG51bWJlciAvIDEwO1xuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIoZmlyc3REaWdpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKGxhc3REaWdpdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMTAwMDApIHtcbiAgICAgICAgICAgIC8vIDMgb3IgNCBkaWdpdHMgLS0+IHJlY3Vyc2l2ZWx5IGNoZWNrIGZpcnN0IGRpZ2l0XG4gICAgICAgICAgICB3aGlsZSAobnVtYmVyID49IDEwKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyIC8gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbnl0aGluZyBsYXJnZXIgdGhhbiA0IGRpZ2l0czogcmVjdXJzaXZlbHkgY2hlY2sgZmlyc3Qgbi0zIGRpZ2l0c1xuICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyIC8gMTAwMDtcbiAgICAgICAgICAgIHJldHVybiBlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2xiJywge1xuICAgICAgICBtb250aHM6ICdKYW51YXJfRmVicnVhcl9Nw6RlcnpfQWJyw6tsbF9NZWVfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICdKYW4uX0ZlYnIuX01yei5fQWJyLl9NZWVfSnVuLl9KdWwuX0F1Zy5fU2VwdC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzOiAnU29ubmRlZ19Nw6lpbmRlZ19Ew6tuc2NoZGVnX03Dq3R0d29jaF9Eb25uZXNjaGRlZ19GcmVpZGVnX1NhbXNjaGRlZycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogJ1NvLl9Nw6kuX0TDqy5fTcOrLl9Eby5fRnIuX1NhLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW46ICdTb19Nw6lfRMOrX03Dq19Eb19Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSDptbSBbQXVlcl0nLFxuICAgICAgICAgICAgTFRTOiAnSDptbTpzcyBbQXVlcl0nLFxuICAgICAgICAgICAgTDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0gW0F1ZXJdJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSBbQXVlcl0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0hhdXQgdW1dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW011ZXIgdW1dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdW1dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbR8Orc2NodGVyIHVtXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVudCBkYXRlIHN0cmluZyBmb3IgJ0TDq25zY2hkZWcnIChUdWVzZGF5KSBhbmQgJ0Rvbm5lc2NoZGVnJyAoVGh1cnNkYXkpIGR1ZSB0byBwaG9ub2xvZ2ljYWwgcnVsZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW0xlc2NodGVuXSBkZGRkIFt1bV0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbTGVzY2h0ZV0gZGRkZCBbdW1dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IHByb2Nlc3NGdXR1cmVUaW1lLFxuICAgICAgICAgICAgcGFzdCA6IHByb2Nlc3NQYXN0VGltZSxcbiAgICAgICAgICAgIHMgOiAnZSBwdWVyIFNla29ubmVuJyxcbiAgICAgICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gOiAnJWQgTWludXR0ZW4nLFxuICAgICAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoaCA6ICclZCBTdG9ubmVuJyxcbiAgICAgICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZGQgOiAnJWQgRGVlZycsXG4gICAgICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIE1NIDogJyVkIE3DqWludCcsXG4gICAgICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHl5IDogJyVkIEpvZXInXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbDogJyVkLicsXG4gICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3k6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxiO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2xiLmpzXG4gKiogbW9kdWxlIGlkID0gMjU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IExpdGh1YW5pYW4gKGx0KVxuLy8hIGF1dGhvciA6IE1pbmRhdWdhcyBNb3rFq3JhcyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tbW96dXJhc1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB1bml0cyA9IHtcbiAgICAgICAgJ20nIDogJ21pbnV0xJdfbWludXTEl3NfbWludXTEmScsXG4gICAgICAgICdtbSc6ICdtaW51dMSXc19taW51xI1pxbNfbWludXRlcycsXG4gICAgICAgICdoJyA6ICd2YWxhbmRhX3ZhbGFuZG9zX3ZhbGFuZMSFJyxcbiAgICAgICAgJ2hoJzogJ3ZhbGFuZG9zX3ZhbGFuZMWzX3ZhbGFuZGFzJyxcbiAgICAgICAgJ2QnIDogJ2RpZW5hX2RpZW5vc19kaWVuxIUnLFxuICAgICAgICAnZGQnOiAnZGllbm9zX2RpZW7Fs19kaWVuYXMnLFxuICAgICAgICAnTScgOiAnbcSXbnVvX23El25lc2lvX23El25lc8SvJyxcbiAgICAgICAgJ01NJzogJ23El25lc2lhaV9txJduZXNpxbNfbcSXbmVzaXVzJyxcbiAgICAgICAgJ3knIDogJ21ldGFpX21ldMWzX21ldHVzJyxcbiAgICAgICAgJ3l5JzogJ21ldGFpX21ldMWzX21ldHVzJ1xuICAgIH0sXG4gICAgd2Vla0RheXMgPSAnc2VrbWFkaWVuaXNfcGlybWFkaWVuaXNfYW50cmFkaWVuaXNfdHJlxI1pYWRpZW5pc19rZXR2aXJ0YWRpZW5pc19wZW5rdGFkaWVuaXNfxaFlxaF0YWRpZW5pcycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVTZWNvbmRzKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuICdrZWxpb3Mgc2VrdW5kxJdzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdrZWxpxbMgc2VrdW5kxb5pxbMnIDogJ2tlbGlhcyBzZWt1bmRlcyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW9udGhzQ2FzZVJlcGxhY2UobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBtb250aHMgPSB7XG4gICAgICAgICAgICAgICAgJ25vbWluYXRpdmUnOiAnc2F1c2lzX3Zhc2FyaXNfa292YXNfYmFsYW5kaXNfZ2VndcW+xJdfYmlyxb5lbGlzX2xpZXBhX3J1Z3Bqxat0aXNfcnVnc8SXamlzX3NwYWxpc19sYXBrcml0aXNfZ3J1b2Rpcycuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICdzYXVzaW9fdmFzYXJpb19rb3ZvX2JhbGFuZMW+aW9fZ2VndcW+xJdzX2JpcsW+ZWxpb19saWVwb3NfcnVncGrFq8SNaW9fcnVnc8SXam9fc3BhbGlvX2xhcGtyacSNaW9fZ3J1b2TFvmlvJy5zcGxpdCgnXycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm91bkNhc2UgPSAoL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LykudGVzdChmb3JtYXQpID9cbiAgICAgICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgICAgICdub21pbmF0aXZlJztcbiAgICAgICAgcmV0dXJuIG1vbnRoc1tub3VuQ2FzZV1bbS5tb250aCgpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybXMoa2V5KVswXSA6IChpc0Z1dHVyZSA/IGZvcm1zKGtleSlbMV0gOiBmb3JtcyhrZXkpWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BlY2lhbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAwIHx8IChudW1iZXIgPiAxMCAmJiBudW1iZXIgPCAyMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1zKGtleSkge1xuICAgICAgICByZXR1cm4gdW5pdHNba2V5XS5zcGxpdCgnXycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XG4gICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyB0cmFuc2xhdGVTaW5ndWxhcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleVswXSwgaXNGdXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoc3BlY2lhbChudW1iZXIpID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1zKGtleSlbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoc3BlY2lhbChudW1iZXIpID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlV2Vla0RheShtb21lbnQsIGZvcm1hdCkge1xuICAgICAgICB2YXIgbm9taW5hdGl2ZSA9IGZvcm1hdC5pbmRleE9mKCdkZGRkIEhIOm1tJykgPT09IC0xLFxuICAgICAgICAgICAgd2Vla0RheSA9IHdlZWtEYXlzW21vbWVudC5kYXkoKV07XG4gICAgICAgIHJldHVybiBub21pbmF0aXZlID8gd2Vla0RheSA6IHdlZWtEYXkuc3Vic3RyaW5nKDAsIHdlZWtEYXkubGVuZ3RoIC0gMikgKyAnxK8nO1xuICAgIH1cblxuICAgIHZhciBsdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2x0Jywge1xuICAgICAgICBtb250aHMgOiBtb250aHNDYXNlUmVwbGFjZSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnc2F1X3Zhc19rb3ZfYmFsX2dlZ19iaXJfbGllX3JncF9yZ3Nfc3BhX2xhcF9ncmQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogcmVsYXRpdmVXZWVrRGF5LFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1Nla19QaXJfQW50X1RyZV9LZXRfUGVuX8WgZcWhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTX1BfQV9UX0tfUG5fxaAnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICBMTCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0nLFxuICAgICAgICAgICAgTExMIDogJ1lZWVkgW20uXSBNTU1NIEQgW2QuXSwgSEg6bW0gW3ZhbC5dJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBkZGRkLCBISDptbSBbdmFsLl0nLFxuICAgICAgICAgICAgbCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVkgW20uXSBNTU1NIEQgW2QuXScsXG4gICAgICAgICAgICBsbGwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBISDptbSBbdmFsLl0nLFxuICAgICAgICAgICAgbGxsbCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIGRkZCwgSEg6bW0gW3ZhbC5dJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW8WgaWFuZGllbl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbUnl0b2pdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbVmFrYXJdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tQcmHEl2p1c8SvXSBkZGRkIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdwbyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ByaWXFoSAlcycsXG4gICAgICAgICAgICBzIDogdHJhbnNsYXRlU2Vjb25kcyxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGVTaW5ndWxhcixcbiAgICAgICAgICAgIG1tIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaCA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogdHJhbnNsYXRlU2luZ3VsYXIsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGVTaW5ndWxhcixcbiAgICAgICAgICAgIE1NIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tb2ppLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLW9qaSc7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGx0O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL2x0LmpzXG4gKiogbW9kdWxlIGlkID0gMjYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IGxhdHZpYW4gKGx2KVxuLy8hIGF1dGhvciA6IEtyaXN0YXBzIEthcmxzb25zIDogaHR0cHM6Ly9naXRodWIuY29tL3NrYWtyaVxuLy8hIGF1dGhvciA6IErEgW5pcyBFbG1lcmlzIDogaHR0cHM6Ly9naXRodWIuY29tL0phbmlzRVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB1bml0cyA9IHtcbiAgICAgICAgJ20nOiAnbWluxat0ZXNfbWluxat0xJNtX21pbsWrdGVfbWluxat0ZXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdtbSc6ICdtaW7Fq3Rlc19taW7Fq3TEk21fbWluxat0ZV9taW7Fq3Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgJ2gnOiAnc3R1bmRhc19zdHVuZMSBbV9zdHVuZGFfc3R1bmRhcycuc3BsaXQoJ18nKSxcbiAgICAgICAgJ2hoJzogJ3N0dW5kYXNfc3R1bmTEgW1fc3R1bmRhX3N0dW5kYXMnLnNwbGl0KCdfJyksXG4gICAgICAgICdkJzogJ2RpZW5hc19kaWVuxIFtX2RpZW5hX2RpZW5hcycuc3BsaXQoJ18nKSxcbiAgICAgICAgJ2RkJzogJ2RpZW5hc19kaWVuxIFtX2RpZW5hX2RpZW5hcycuc3BsaXQoJ18nKSxcbiAgICAgICAgJ00nOiAnbcSTbmXFoWFfbcSTbmXFoWllbV9txJNuZXNpc19txJNuZcWhaScuc3BsaXQoJ18nKSxcbiAgICAgICAgJ01NJzogJ23Ek25lxaFhX23Ek25lxaFpZW1fbcSTbmVzaXNfbcSTbmXFoWknLnNwbGl0KCdfJyksXG4gICAgICAgICd5JzogJ2dhZGFfZ2FkaWVtX2dhZHNfZ2FkaScuc3BsaXQoJ18nKSxcbiAgICAgICAgJ3l5JzogJ2dhZGFfZ2FkaWVtX2dhZHNfZ2FkaScuc3BsaXQoJ18nKVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHdpdGhvdXRTdWZmaXggYm9vbGVhbiB0cnVlID0gYSBsZW5ndGggb2YgdGltZTsgZmFsc2UgPSBiZWZvcmUvYWZ0ZXIgYSBwZXJpb2Qgb2YgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXQoZm9ybXMsIG51bWJlciwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgLy8gRS5nLiBcIjIxIG1pbsWrdGVcIiwgXCIzIG1pbsWrdGVzXCIuXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICUgMTAgPT09IDEgJiYgbnVtYmVyICE9PSAxMSA/IGZvcm1zWzJdIDogZm9ybXNbM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFLmcuIFwiMjEgbWluxat0ZXNcIiBhcyBpbiBcInDEk2MgMjEgbWluxat0ZXNcIi5cbiAgICAgICAgICAgIC8vIEUuZy4gXCIzIG1pbsWrdMSTbVwiIGFzIGluIFwicMSTYyAzIG1pbsWrdMSTbVwiLlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAxICYmIG51bWJlciAhPT0gMTEgPyBmb3Jtc1swXSA6IGZvcm1zWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIGZvcm1hdCh1bml0c1trZXldLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCh1bml0c1trZXldLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVNlY29uZHMobnVtYmVyLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2Rhxb5hcyBzZWt1bmRlcycgOiAnZGHFvsSBbSBzZWt1bmTEk20nO1xuICAgIH1cblxuICAgIHZhciBsdiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2x2Jywge1xuICAgICAgICBtb250aHMgOiAnamFudsSBcmlzX2ZlYnJ1xIFyaXNfbWFydHNfYXByxKtsaXNfbWFpanNfasWrbmlqc19qxatsaWpzX2F1Z3VzdHNfc2VwdGVtYnJpc19va3RvYnJpc19ub3ZlbWJyaXNfZGVjZW1icmlzJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2rFq25fasWrbF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzdsSTdGRpZW5hX3Bpcm1kaWVuYV9vdHJkaWVuYV90cmXFoWRpZW5hX2NldHVydGRpZW5hX3BpZWt0ZGllbmFfc2VzdGRpZW5hJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ1N2X1BfT19UX0NfUGtfUycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnU3ZfUF9PX1RfQ19Qa19TJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVkuJyxcbiAgICAgICAgICAgIExMIDogJ1lZWVkuIFtnYWRhXSBELiBNTU1NJyxcbiAgICAgICAgICAgIExMTCA6ICdZWVlZLiBbZ2FkYV0gRC4gTU1NTSwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdZWVlZLiBbZ2FkYV0gRC4gTU1NTSwgZGRkZCwgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbxaBvZGllbiBwdWxrc3Rlbl0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbUsSrdCBwdWxrc3Rlbl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVsa3N0ZW5dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW1Zha2FyIHB1bGtzdGVuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbUGFnxIFqdcWhxIFdIGRkZGQgW3B1bGtzdGVuXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAncMSTYyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3Bpcm1zICVzJyxcbiAgICAgICAgICAgIHMgOiByZWxhdGl2ZVNlY29uZHMsXG4gICAgICAgICAgICBtIDogcmVsYXRpdmVUaW1lV2l0aFNpbmd1bGFyLFxuICAgICAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgaCA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcbiAgICAgICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGQgOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXG4gICAgICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBNIDogcmVsYXRpdmVUaW1lV2l0aFNpbmd1bGFyLFxuICAgICAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgeSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbHY7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbHYuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogTW9udGVuZWdyaW4gKG1lKVxuLy8hIGF1dGhvciA6IE1pb2RyYWcgTmlrYcSNIDxtaW9kcmFnQHJlc3RhcnRpdC5tZT4gOiBodHRwczovL2dpdGh1Yi5jb20vbWlvZHJhZ25pa2FjXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRyYW5zbGF0b3IgPSB7XG4gICAgICAgIHdvcmRzOiB7IC8vRGlmZmVyZW50IGdyYW1tYXRpY2FsIGNhc2VzXG4gICAgICAgICAgICBtOiBbJ2plZGFuIG1pbnV0JywgJ2plZG5vZyBtaW51dGEnXSxcbiAgICAgICAgICAgIG1tOiBbJ21pbnV0JywgJ21pbnV0YScsICdtaW51dGEnXSxcbiAgICAgICAgICAgIGg6IFsnamVkYW4gc2F0JywgJ2plZG5vZyBzYXRhJ10sXG4gICAgICAgICAgICBoaDogWydzYXQnLCAnc2F0YScsICdzYXRpJ10sXG4gICAgICAgICAgICBkZDogWydkYW4nLCAnZGFuYScsICdkYW5hJ10sXG4gICAgICAgICAgICBNTTogWydtamVzZWMnLCAnbWplc2VjYScsICdtamVzZWNpJ10sXG4gICAgICAgICAgICB5eTogWydnb2RpbmEnLCAnZ29kaW5lJywgJ2dvZGluYSddXG4gICAgICAgIH0sXG4gICAgICAgIGNvcnJlY3RHcmFtbWF0aWNhbENhc2U6IGZ1bmN0aW9uIChudW1iZXIsIHdvcmRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgPT09IDEgPyB3b3JkS2V5WzBdIDogKG51bWJlciA+PSAyICYmIG51bWJlciA8PSA0ID8gd29yZEtleVsxXSA6IHdvcmRLZXlbMl0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICAgICAgdmFyIHdvcmRLZXkgPSB0cmFuc2xhdG9yLndvcmRzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gd29yZEtleVswXSA6IHdvcmRLZXlbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtZScsIHtcbiAgICAgICAgbW9udGhzOiBbJ2phbnVhcicsICdmZWJydWFyJywgJ21hcnQnLCAnYXByaWwnLCAnbWFqJywgJ2p1bicsICdqdWwnLCAnYXZndXN0JywgJ3NlcHRlbWJhcicsICdva3RvYmFyJywgJ25vdmVtYmFyJywgJ2RlY2VtYmFyJ10sXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbJ2phbi4nLCAnZmViLicsICdtYXIuJywgJ2Fwci4nLCAnbWFqJywgJ2p1bicsICdqdWwnLCAnYXZnLicsICdzZXAuJywgJ29rdC4nLCAnbm92LicsICdkZWMuJ10sXG4gICAgICAgIHdlZWtkYXlzOiBbJ25lZGplbGphJywgJ3BvbmVkamVsamFrJywgJ3V0b3JhaycsICdzcmlqZWRhJywgJ8SNZXR2cnRhaycsICdwZXRhaycsICdzdWJvdGEnXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWyduZWQuJywgJ3Bvbi4nLCAndXRvLicsICdzcmkuJywgJ8SNZXQuJywgJ3BldC4nLCAnc3ViLiddLFxuICAgICAgICB3ZWVrZGF5c01pbjogWyduZScsICdwbycsICd1dCcsICdzcicsICfEjWUnLCAncGUnLCAnc3UnXSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMOiAnREQuIE1NLiBZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXI6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbZGFuYXMgdV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tzanV0cmEgdV0gTFQnLFxuXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3NyaWplZHVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3Vib3R1XSBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWUgdV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RXZWVrRGF5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbbmVkamVsamVdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFtwb25lZGplbGprYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3V0b3JrYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbc3JpamVkZV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW8SNZXR2cnRrYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3BldGthXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtzdWJvdGVdIFt1XSBMVCdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0V2Vla0RheXNbdGhpcy5kYXkoKV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXG4gICAgICAgICAgICBzICAgICAgOiAnbmVrb2xpa28gc2VrdW5kaScsXG4gICAgICAgICAgICBtICAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG1tICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgaCAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgICAgICA6ICdkYW4nLFxuICAgICAgICAgICAgZGQgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBNICAgICAgOiAnbWplc2VjJyxcbiAgICAgICAgICAgIE1NICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgeSAgICAgIDogJ2dvZGludScsXG4gICAgICAgICAgICB5eSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWU7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogbWFjZWRvbmlhbiAobWspXG4vLyEgYXV0aG9yIDogQm9yaXNsYXYgTWlja292IDogaHR0cHM6Ly9naXRodWIuY29tL0IwazBcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbWsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtaycsIHtcbiAgICAgICAgbW9udGhzIDogJ9GY0LDQvdGD0LDRgNC4X9GE0LXQstGA0YPQsNGA0Lhf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Zhf0ZjRg9C90Lhf0ZjRg9C70Lhf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCy0YDQuF/QvtC60YLQvtC80LLRgNC4X9C90L7QtdC80LLRgNC4X9C00LXQutC10LzQstGA0LgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GY0LDQvV/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Zhf0ZjRg9C9X9GY0YPQu1/QsNCy0LNf0YHQtdC/X9C+0LrRgl/QvdC+0LVf0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQvdC10LTQtdC70LBf0L/QvtC90LXQtNC10LvQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstGA0YLQvtC6X9C/0LXRgtC+0Lpf0YHQsNCx0L7RgtCwJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9C90LXQtF/Qv9C+0L1f0LLRgtC+X9GB0YDQtV/Rh9C10YJf0L/QtdGCX9GB0LDQsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn0L1lX9C/b1/QstGCX9GB0YBf0YfQtV/Qv9C1X9GBYScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnRC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vQlNC10L3QtdGBINCy0L5dIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW9Cj0YLRgNC1INCy0L5dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9Cy0L5dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW9CS0YfQtdGA0LAg0LLQvl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CS0L4g0LjQt9C80LjQvdCw0YLQsNGC0LBdIGRkZGQgW9Cy0L5dIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CS0L4g0LjQt9C80LjQvdCw0YLQuNC+0YJdIGRkZGQgW9Cy0L5dIExUJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9C/0L7RgdC70LUgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfQv9GA0LXQtCAlcycsXG4gICAgICAgICAgICBzIDogJ9C90LXQutC+0LvQutGDINGB0LXQutGD0L3QtNC4JyxcbiAgICAgICAgICAgIG0gOiAn0LzQuNC90YPRgtCwJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC80LjQvdGD0YLQuCcsXG4gICAgICAgICAgICBoIDogJ9GH0LDRgScsXG4gICAgICAgICAgICBoaCA6ICclZCDRh9Cw0YHQsCcsXG4gICAgICAgICAgICBkIDogJ9C00LXQvScsXG4gICAgICAgICAgICBkZCA6ICclZCDQtNC10L3QsCcsXG4gICAgICAgICAgICBNIDogJ9C80LXRgdC10YYnLFxuICAgICAgICAgICAgTU0gOiAnJWQg0LzQtdGB0LXRhtC4JyxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC00LjQvdCwJyxcbiAgICAgICAgICAgIHl5IDogJyVkINCz0L7QtNC40L3QuCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNC10LJ80LXQvXzRgtC4fNCy0Lh80YDQuHzQvNC4KS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdERpZ2l0ID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgbGFzdDJEaWdpdHMgPSBudW1iZXIgJSAxMDA7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQsic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQvSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID4gMTAgJiYgbGFzdDJEaWdpdHMgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGC0LgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QstC4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YDQuCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNyB8fCBsYXN0RGlnaXQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QvNC4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1rO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL21rLmpzXG4gKiogbW9kdWxlIGlkID0gMjYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IG1hbGF5YWxhbSAobWwpXG4vLyEgYXV0aG9yIDogRmxveWQgUGluayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG95ZHBpbmtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbWwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtbCcsIHtcbiAgICAgICAgbW9udGhzIDogJ+C0nOC0qOC1geC0teC0sOC0v1/gtKvgtYbgtKzgtY3gtLDgtYHgtLXgtLDgtL9f4LSu4LS+4LW84LSa4LWN4LSa4LWNX+C0j+C0quC1jeC0sOC0v+C1vV/gtK7gtYfgtK/gtY1f4LSc4LWC4LW6X+C0nOC1guC0suC1iF/gtJPgtJfgtLjgtY3gtLHgtY3gtLHgtY1f4LS44LWG4LSq4LWN4LSx4LWN4LSx4LSC4LSs4LW8X+C0kuC0leC1jeC0n+C1i+C0rOC1vF/gtKjgtLXgtILgtKzgtbxf4LSh4LS/4LS44LSC4LSs4LW8Jy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfgtJzgtKjgtYEuX+C0q+C1huC0rOC1jeC0sOC1gS5f4LSu4LS+4LW8Ll/gtI/gtKrgtY3gtLDgtL8uX+C0ruC1h+C0r+C1jV/gtJzgtYLgtbpf4LSc4LWC4LSy4LWILl/gtJPgtJcuX+C0uOC1huC0quC1jeC0seC1jeC0sS5f4LSS4LSV4LWN4LSf4LWLLl/gtKjgtLXgtIIuX+C0oeC0v+C0uOC0gi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+C0nuC0vuC0r+C0seC0vuC0tOC1jeC0ml/gtKTgtL/gtJngtY3gtJXgtLPgtL7gtLTgtY3gtJpf4LSa4LWK4LS14LWN4LS14LS+4LS04LWN4LSaX+C0rOC1geC0p+C0qOC0vuC0tOC1jeC0ml/gtLXgtY3gtK/gtL7gtLTgtL7gtLTgtY3gtJpf4LS14LWG4LSz4LWN4LSz4LS/4LSv4LS+4LS04LWN4LSaX+C0tuC0qOC0v+C0r+C0vuC0tOC1jeC0micuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgtJ7gtL7gtK/gtbxf4LSk4LS/4LSZ4LWN4LSV4LW+X+C0muC1iuC0teC1jeC0tV/gtKzgtYHgtKfgtbtf4LS14LWN4LSv4LS+4LS04LSCX+C0teC1huC0s+C1jeC0s+C0v1/gtLbgtKjgtL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+C0nuC0vl/gtKTgtL9f4LSa4LWKX+C0rOC1gV/gtLXgtY3gtK/gtL5f4LS14LWGX+C0ticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0gLeC0qOC1gScsXG4gICAgICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIC3gtKjgtYEnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tIC3gtKjgtYEnLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIC3gtKjgtYEnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4LSH4LSo4LWN4LSo4LWNXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgtKjgtL7gtLPgtYZdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+C0h+C0qOC1jeC0qOC0suC1hl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+C0leC0tOC0v+C0nuC1jeC0nl0gZGRkZCwgTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIOC0leC0tOC0v+C0nuC1jeC0nuC1jScsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOC0ruC1geC1u+C0quC1jScsXG4gICAgICAgICAgICBzIDogJ+C0heC1veC0qiDgtKjgtL/gtK7gtL/gtLfgtJngtY3gtJngtb4nLFxuICAgICAgICAgICAgbSA6ICfgtJLgtLDgtYEg4LSu4LS/4LSo4LS/4LSx4LWN4LSx4LWNJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOC0ruC0v+C0qOC0v+C0seC1jeC0seC1jScsXG4gICAgICAgICAgICBoIDogJ+C0kuC0sOC1gSDgtK7gtKPgtL/gtJXgtY3gtJXgtYLgtbwnLFxuICAgICAgICAgICAgaGggOiAnJWQg4LSu4LSj4LS/4LSV4LWN4LSV4LWC4LW8JyxcbiAgICAgICAgICAgIGQgOiAn4LSS4LSw4LWBIOC0puC0v+C0teC0uOC0gicsXG4gICAgICAgICAgICBkZCA6ICclZCDgtKbgtL/gtLXgtLjgtIInLFxuICAgICAgICAgICAgTSA6ICfgtJLgtLDgtYEg4LSu4LS+4LS44LSCJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOC0ruC0vuC0uOC0gicsXG4gICAgICAgICAgICB5IDogJ+C0kuC0sOC1gSDgtLXgtbzgtLfgtIInLFxuICAgICAgICAgICAgeXkgOiAnJWQg4LS14LW84LS34LSCJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4LSw4LS+4LSk4LWN4LSw4LS/fOC0sOC0vuC0teC0v+C0suC1hnzgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNfOC0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gnzgtLDgtL7gtKTgtY3gtLDgtL8vaSxcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKOC0ieC0muC1jeC0miDgtJXgtLTgtL/gtJ7gtY3gtJ7gtY184LS14LWI4LSV4LWB4LSo4LWN4LSo4LWH4LSw4LSCfOC0sOC0vuC0pOC1jeC0sOC0vykkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0pOC1jeC0sOC0vyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4LSw4LS+4LS14LS/4LSy4LWGJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgtLXgtYjgtJXgtYHgtKjgtY3gtKjgtYfgtLDgtIInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0pOC1jeC0sOC0vyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtbDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9tbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBNYXJhdGhpIChtcilcbi8vISBhdXRob3IgOiBIYXJzaGFkIEthbGUgOiBodHRwczovL2dpdGh1Yi5jb20va2FsZWh2XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4KWnJyxcbiAgICAgICAgJzInOiAn4KWoJyxcbiAgICAgICAgJzMnOiAn4KWpJyxcbiAgICAgICAgJzQnOiAn4KWqJyxcbiAgICAgICAgJzUnOiAn4KWrJyxcbiAgICAgICAgJzYnOiAn4KWsJyxcbiAgICAgICAgJzcnOiAn4KWtJyxcbiAgICAgICAgJzgnOiAn4KWuJyxcbiAgICAgICAgJzknOiAn4KWvJyxcbiAgICAgICAgJzAnOiAn4KWmJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4KWnJzogJzEnLFxuICAgICAgICAn4KWoJzogJzInLFxuICAgICAgICAn4KWpJzogJzMnLFxuICAgICAgICAn4KWqJzogJzQnLFxuICAgICAgICAn4KWrJzogJzUnLFxuICAgICAgICAn4KWsJzogJzYnLFxuICAgICAgICAn4KWtJzogJzcnLFxuICAgICAgICAn4KWuJzogJzgnLFxuICAgICAgICAn4KWvJzogJzknLFxuICAgICAgICAn4KWmJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBtciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21yJywge1xuICAgICAgICBtb250aHMgOiAn4KSc4KS+4KSo4KWH4KS14KS+4KSw4KWAX+Ckq+Clh+CkrOCljeCksOClgeCkteCkvuCksOClgF/gpK7gpL7gpLDgpY3gpJpf4KSP4KSq4KWN4KSw4KS/4KSyX+CkruClh1/gpJzgpYLgpKhf4KSc4KWB4KSy4KWIX+CkkeCkl+CkuOCljeCkn1/gpLjgpKrgpY3gpJ/gpYfgpILgpKzgpLBf4KSR4KSV4KWN4KSf4KWL4KSs4KSwX+CkqOCli+CkteCljeCkueClh+CkguCkrOCksF/gpKHgpL/gpLjgpYfgpILgpKzgpLAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0OiAn4KSc4KS+4KSo4KWHLl/gpKvgpYfgpKzgpY3gpLDgpYEuX+CkruCkvuCksOCljeCkmi5f4KSP4KSq4KWN4KSw4KS/Ll/gpK7gpYcuX+CknOClguCkqC5f4KSc4KWB4KSy4KWILl/gpJHgpJcuX+CkuOCkquCljeCkn+Clh+Ckgi5f4KSR4KSV4KWN4KSf4KWLLl/gpKjgpYvgpLXgpY3gpLngpYfgpIIuX+CkoeCkv+CkuOClh+Ckgi4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+CksOCkteCkv+CkteCkvuCksF/gpLjgpYvgpK7gpLXgpL7gpLBf4KSu4KSC4KSX4KSz4KS14KS+4KSwX+CkrOClgeCkp+CkteCkvuCksF/gpJfgpYHgpLDgpYLgpLXgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwX+CktuCkqOCkv+CkteCkvuCksCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cks1/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CksF/gpLjgpYtf4KSu4KSCX+CkrOClgV/gpJfgpYFf4KS24KWBX+Ckticuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdBIGg6bW0g4KS14KS+4KSc4KSk4KS+JyxcbiAgICAgICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4KS14KS+4KSc4KSk4KS+JyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgpLXgpL7gpJzgpKTgpL4nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCkteCkvuCknOCkpOCkvidcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+CkieCkpuCljeCkr+Ckvl0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KSV4KS+4KSyXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vgpK7gpL7gpJfgpYDgpLJdIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDgpKjgpILgpKTgpLAnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDgpKrgpYLgpLDgpY3gpLXgpYAnLFxuICAgICAgICAgICAgcyA6ICfgpLjgpYfgpJXgpILgpKYnLFxuICAgICAgICAgICAgbTogJ+Ckj+CklSDgpK7gpL/gpKjgpL/gpJ8nLFxuICAgICAgICAgICAgbW06ICclZCDgpK7gpL/gpKjgpL/gpJ/gpYcnLFxuICAgICAgICAgICAgaCA6ICfgpI/gpJUg4KSk4KS+4KS4JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOCkpOCkvuCkuCcsXG4gICAgICAgICAgICBkIDogJ+Ckj+CklSDgpKbgpL/gpLXgpLgnLFxuICAgICAgICAgICAgZGQgOiAnJWQg4KSm4KS/4KS14KS4JyxcbiAgICAgICAgICAgIE0gOiAn4KSP4KSVIOCkruCkueCkv+CkqOCkvicsXG4gICAgICAgICAgICBNTSA6ICclZCDgpK7gpLngpL/gpKjgpYcnLFxuICAgICAgICAgICAgeSA6ICfgpI/gpJUg4KS14KSw4KWN4KS3JyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCkteCksOCljeCkt+ClhydcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpOCljeCksOClgHzgpLjgpJXgpL7gpLPgpYB84KSm4KWB4KSq4KS+4KSw4KWAfOCkuOCkvuCkr+CkguCkleCkvuCks+ClgC8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKTgpY3gpLDgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpJXgpL7gpLPgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KWB4KSq4KS+4KSw4KWAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpL7gpK/gpILgpJXgpL7gpLPgpYAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KWN4KSw4KWAJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLjgpJXgpL7gpLPgpYAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CkpuClgeCkquCkvuCksOClgCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KS44KS+4KSv4KSC4KSV4KS+4KSz4KWAJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKTgpY3gpLDgpYAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtcjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9tci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBCYWhhc2EgTWFsYXlzaWEgKG1zLU1ZKVxuLy8hIGF1dGhvciA6IFdlbGRhbiBKYW1pbGkgOiBodHRwczovL2dpdGh1Yi5jb20vd2VsZGFuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG1zID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXMnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hY19BcHJpbF9NZWlfSnVuX0p1bGFpX09nb3NfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGlzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFjX0Fwcl9NZWlfSnVuX0p1bF9PZ3NfU2VwX09rdF9Ob3ZfRGlzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdBaGFkX0lzbmluX1NlbGFzYV9SYWJ1X0toYW1pc19KdW1hYXRfU2FidHUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnQWhkX0lzbl9TZWxfUmFiX0toYV9KdW1fU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdBaF9Jc19TbF9SYl9LbV9KbV9TYicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISC5tbScsXG4gICAgICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL3BhZ2l8dGVuZ2FoYXJpfHBldGFuZ3xtYWxhbS8sXG4gICAgICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ3BhZ2knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAndGVuZ2FoYXJpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdwZXRhbmcnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA8IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndGVuZ2FoYXJpJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGV0YW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW0Vzb2sgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tLZWxtYXJpbiBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbbGVwYXMgcHVrdWxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdkYWxhbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGVwYXMnLFxuICAgICAgICAgICAgcyA6ICdiZWJlcmFwYSBzYWF0JyxcbiAgICAgICAgICAgIG0gOiAnc2VtaW5pdCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW5pdCcsXG4gICAgICAgICAgICBoIDogJ3NlamFtJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGphbScsXG4gICAgICAgICAgICBkIDogJ3NlaGFyaScsXG4gICAgICAgICAgICBkZCA6ICclZCBoYXJpJyxcbiAgICAgICAgICAgIE0gOiAnc2VidWxhbicsXG4gICAgICAgICAgICBNTSA6ICclZCBidWxhbicsXG4gICAgICAgICAgICB5IDogJ3NldGFodW4nLFxuICAgICAgICAgICAgeXkgOiAnJWQgdGFodW4nXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1zO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL21zLmpzXG4gKiogbW9kdWxlIGlkID0gMjY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IEJhaGFzYSBNYWxheXNpYSAobXMtTVkpXG4vLyEgYXV0aG9yIDogV2VsZGFuIEphbWlsaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWxkYW5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbXNfbXkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtcy1teScsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFjX0FwcmlsX01laV9KdW5fSnVsYWlfT2dvc19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EaXNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYWNfQXByX01laV9KdW5fSnVsX09nc19TZXBfT2t0X05vdl9EaXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0FoYWRfSXNuaW5fU2VsYXNhX1JhYnVfS2hhbWlzX0p1bWFhdF9TYWJ0dScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICdBaGRfSXNuX1NlbF9SYWJfS2hhX0p1bV9TYWInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0FoX0lzX1NsX1JiX0ttX0ptX1NiJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hILm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISC5tbS5zcycsXG4gICAgICAgICAgICBMIDogJ0REL01NL1lZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvcGFnaXx0ZW5nYWhhcml8cGV0YW5nfG1hbGFtLyxcbiAgICAgICAgbWVyaWRpZW1Ib3VyOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAncGFnaScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICd0ZW5nYWhhcmknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3BldGFuZycgfHwgbWVyaWRpZW0gPT09ICdtYWxhbScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzIDwgMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3BhZ2knO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZW5nYWhhcmknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwZXRhbmcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21hbGFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tIYXJpIGluaSBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbRXNvayBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVrdWxdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0tlbG1hcmluIHB1a3VsXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtsZXBhcyBwdWt1bF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2RhbGFtICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgeWFuZyBsZXBhcycsXG4gICAgICAgICAgICBzIDogJ2JlYmVyYXBhIHNhYXQnLFxuICAgICAgICAgICAgbSA6ICdzZW1pbml0JyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbml0JyxcbiAgICAgICAgICAgIGggOiAnc2VqYW0nLFxuICAgICAgICAgICAgaGggOiAnJWQgamFtJyxcbiAgICAgICAgICAgIGQgOiAnc2VoYXJpJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGhhcmknLFxuICAgICAgICAgICAgTSA6ICdzZWJ1bGFuJyxcbiAgICAgICAgICAgIE1NIDogJyVkIGJ1bGFuJyxcbiAgICAgICAgICAgIHkgOiAnc2V0YWh1bicsXG4gICAgICAgICAgICB5eSA6ICclZCB0YWh1bidcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbXNfbXk7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvbXMtbXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogQnVybWVzZSAobXkpXG4vLyEgYXV0aG9yIDogU3F1YXIgdGVhbSwgbXlzcXVhci5jb21cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3ltYm9sTWFwID0ge1xuICAgICAgICAnMSc6ICfhgYEnLFxuICAgICAgICAnMic6ICfhgYInLFxuICAgICAgICAnMyc6ICfhgYMnLFxuICAgICAgICAnNCc6ICfhgYQnLFxuICAgICAgICAnNSc6ICfhgYUnLFxuICAgICAgICAnNic6ICfhgYYnLFxuICAgICAgICAnNyc6ICfhgYcnLFxuICAgICAgICAnOCc6ICfhgYgnLFxuICAgICAgICAnOSc6ICfhgYknLFxuICAgICAgICAnMCc6ICfhgYAnXG4gICAgfSwgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4YGBJzogJzEnLFxuICAgICAgICAn4YGCJzogJzInLFxuICAgICAgICAn4YGDJzogJzMnLFxuICAgICAgICAn4YGEJzogJzQnLFxuICAgICAgICAn4YGFJzogJzUnLFxuICAgICAgICAn4YGGJzogJzYnLFxuICAgICAgICAn4YGHJzogJzcnLFxuICAgICAgICAn4YGIJzogJzgnLFxuICAgICAgICAn4YGJJzogJzknLFxuICAgICAgICAn4YGAJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBteSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ215Jywge1xuICAgICAgICBtb250aHM6ICfhgIfhgJThgLrhgJThgJ3hgKvhgJvhgK5f4YCW4YCx4YCW4YCx4YCs4YC64YCd4YCr4YCb4YCuX+GAmeGAkOGAul/hgKfhgJXhgLzhgK5f4YCZ4YCxX+GAh+GAveGAlOGAul/hgIfhgLDhgJzhgK3hgK/hgIThgLpf4YCe4YC84YCC4YCv4YCQ4YC6X+GAheGAgOGAuuGAkOGAhOGAuuGAmOGArF/hgKHhgLHhgKzhgIDhgLrhgJDhgK3hgK/hgJjhgKxf4YCU4YCt4YCv4YCd4YCE4YC64YCY4YCsX+GAkuGAruGAh+GAhOGAuuGAmOGArCcuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQ6ICfhgIfhgJThgLpf4YCW4YCxX+GAmeGAkOGAul/hgJXhgLzhgK5f4YCZ4YCxX+GAh+GAveGAlOGAul/hgJzhgK3hgK/hgIThgLpf4YCe4YC8X+GAheGAgOGAul/hgKHhgLHhgKzhgIDhgLpf4YCU4YCt4YCvX+GAkuGAricuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXM6ICfhgJDhgJThgIThgLrhgLnhgILhgJThgL3hgLFf4YCQ4YCU4YCE4YC64YC54YCc4YCsX+GAoeGAhOGAuuGAueGAguGAq1/hgJfhgK/hgJLhgLnhgJPhgJ/hgLDhgLhf4YCA4YC84YCs4YCe4YCV4YCQ4YCx4YC4X+GAnuGAseGArOGAgOGAvOGArF/hgIXhgJThgLEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6ICfhgJThgL3hgLFf4YCc4YCsX+GAguGAq1/hgJ/hgLDhgLhf4YCA4YC84YCsX+GAnuGAseGArF/hgJThgLEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluOiAn4YCU4YC94YCxX+GAnOGArF/hgILhgKtf4YCf4YCw4YC4X+GAgOGAvOGArF/hgJ7hgLHhgKxf4YCU4YCxJy5zcGxpdCgnXycpLFxuXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiB7XG4gICAgICAgICAgICBMVDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW+GAmuGAlOGAsS5dIExUIFvhgJnhgL7hgKxdJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb4YCZ4YCU4YCA4YC64YCW4YC84YCU4YC6XSBMVCBb4YCZ4YC+4YCsXScsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgTFQgW+GAmeGAvuGArF0nLFxuICAgICAgICAgICAgbGFzdERheTogJ1vhgJnhgJThgLEu4YCAXSBMVCBb4YCZ4YC+4YCsXScsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1vhgJXhgLzhgK7hgLjhgIHhgLLhgLfhgJ7hgLHhgKxdIGRkZGQgTFQgW+GAmeGAvuGArF0nLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWU6IHtcbiAgICAgICAgICAgIGZ1dHVyZTogJ+GAnOGArOGAmeGAiuGAuuGAtyAlcyDhgJnhgL7hgKwnLFxuICAgICAgICAgICAgcGFzdDogJ+GAnOGAveGAlOGAuuGAgeGAsuGAt+GAnuGAseGArCAlcyDhgIAnLFxuICAgICAgICAgICAgczogJ+GAheGAgOGAueGAgOGAlOGAui7hgKHhgJThgIrhgLrhgLjhgIThgJrhgLonLFxuICAgICAgICAgICAgbTogJ+GAkOGAheGAuuGAmeGAreGAlOGAheGAuicsXG4gICAgICAgICAgICBtbTogJyVkIOGAmeGAreGAlOGAheGAuicsXG4gICAgICAgICAgICBoOiAn4YCQ4YCF4YC64YCU4YCs4YCb4YCuJyxcbiAgICAgICAgICAgIGhoOiAnJWQg4YCU4YCs4YCb4YCuJyxcbiAgICAgICAgICAgIGQ6ICfhgJDhgIXhgLrhgJvhgIDhgLonLFxuICAgICAgICAgICAgZGQ6ICclZCDhgJvhgIDhgLonLFxuICAgICAgICAgICAgTTogJ+GAkOGAheGAuuGAnCcsXG4gICAgICAgICAgICBNTTogJyVkIOGAnCcsXG4gICAgICAgICAgICB5OiAn4YCQ4YCF4YC64YCU4YC+4YCF4YC6JyxcbiAgICAgICAgICAgIHl5OiAnJWQg4YCU4YC+4YCF4YC6J1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4YGB4YGC4YGD4YGE4YGF4YGG4YGH4YGI4YGJ4YGAXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95OiA0IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG15O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL215LmpzXG4gKiogbW9kdWxlIGlkID0gMjY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IG5vcndlZ2lhbiBib2ttw6VsIChuYilcbi8vISBhdXRob3JzIDogRXNwZW4gSG92bGFuZHNkYWwgOiBodHRwczovL2dpdGh1Yi5jb20vcmV4eGFyc1xuLy8hICAgICAgICAgICBTaWd1cmQgR2FydG1hbm4gOiBodHRwczovL2dpdGh1Yi5jb20vc2lndXJkZ2FcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbmIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCduYicsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByaWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzw7huZGFnX21hbmRhZ190aXJzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7hyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3PDuG5fbWFuX3RpcnNfb25zX3RvcnNfZnJlX2zDuHInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ3PDuF9tYV90aV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSC5tbScsXG4gICAgICAgICAgICBMVFMgOiAnSC5tbS5zcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgW2tsLl0gSC5tbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSBZWVlZIFtrbC5dIEgubW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tpIGRhZyBrbC5dIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbaSBtb3JnZW4ga2wuXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2tsLl0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tpIGfDpXIga2wuXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ1tmb3JyaWdlXSBkZGRkIFtrbC5dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnZm9yICVzIHNpZGVuJyxcbiAgICAgICAgICAgIHMgOiAnbm9lbiBzZWt1bmRlcicsXG4gICAgICAgICAgICBtIDogJ2V0dCBtaW51dHQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXR0ZXInLFxuICAgICAgICAgICAgaCA6ICdlbiB0aW1lJyxcbiAgICAgICAgICAgIGhoIDogJyVkIHRpbWVyJyxcbiAgICAgICAgICAgIGQgOiAnZW4gZGFnJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2VyJyxcbiAgICAgICAgICAgIE0gOiAnZW4gbcOlbmVkJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DpW5lZGVyJyxcbiAgICAgICAgICAgIHkgOiAnZXR0IMOlcicsXG4gICAgICAgICAgICB5eSA6ICclZCDDpXInXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuYjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9uYi5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBuZXBhbGkvbmVwYWxlc2Vcbi8vISBhdXRob3IgOiBzdXZhc2ggOiBodHRwczovL2dpdGh1Yi5jb20vc3V2YXNoXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN5bWJvbE1hcCA9IHtcbiAgICAgICAgJzEnOiAn4KWnJyxcbiAgICAgICAgJzInOiAn4KWoJyxcbiAgICAgICAgJzMnOiAn4KWpJyxcbiAgICAgICAgJzQnOiAn4KWqJyxcbiAgICAgICAgJzUnOiAn4KWrJyxcbiAgICAgICAgJzYnOiAn4KWsJyxcbiAgICAgICAgJzcnOiAn4KWtJyxcbiAgICAgICAgJzgnOiAn4KWuJyxcbiAgICAgICAgJzknOiAn4KWvJyxcbiAgICAgICAgJzAnOiAn4KWmJ1xuICAgIH0sXG4gICAgbnVtYmVyTWFwID0ge1xuICAgICAgICAn4KWnJzogJzEnLFxuICAgICAgICAn4KWoJzogJzInLFxuICAgICAgICAn4KWpJzogJzMnLFxuICAgICAgICAn4KWqJzogJzQnLFxuICAgICAgICAn4KWrJzogJzUnLFxuICAgICAgICAn4KWsJzogJzYnLFxuICAgICAgICAn4KWtJzogJzcnLFxuICAgICAgICAn4KWuJzogJzgnLFxuICAgICAgICAn4KWvJzogJzknLFxuICAgICAgICAn4KWmJzogJzAnXG4gICAgfTtcblxuICAgIHZhciBuZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25lJywge1xuICAgICAgICBtb250aHMgOiAn4KSc4KSo4KS14KSw4KWAX+Ckq+Clh+CkrOCljeCksOClgeCkteCksOClgF/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KS/4KSyX+CkruCkiF/gpJzgpYHgpKhf4KSc4KWB4KSy4KS+4KSIX+CkheCkl+Ckt+CljeCkn1/gpLjgpYfgpKrgpY3gpJ/gpYfgpK7gpY3gpKzgpLBf4KSF4KSV4KWN4KSf4KWL4KSs4KSwX+CkqOCli+CkreClh+CkruCljeCkrOCksF/gpKHgpL/gpLjgpYfgpK7gpY3gpKzgpLAnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ+CknOCkqC5f4KSr4KWH4KSs4KWN4KSw4KWBLl/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KS/Ll/gpK7gpIhf4KSc4KWB4KSoX+CknOClgeCksuCkvuCkiC5f4KSF4KSXLl/gpLjgpYfgpKrgpY3gpJ8uX+CkheCkleCljeCkn+Cliy5f4KSo4KWL4KSt4KWHLl/gpKHgpL/gpLjgpYcuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfgpIbgpIfgpKTgpKzgpL7gpLBf4KS44KWL4KSu4KSs4KS+4KSwX+CkruCkmeCljeCkl+CksuCkrOCkvuCksF/gpKzgpYHgpKfgpKzgpL7gpLBf4KSs4KS/4KS54KS/4KSs4KS+4KSwX+CktuClgeCkleCljeCksOCkrOCkvuCksF/gpLbgpKjgpL/gpKzgpL7gpLAnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn4KSG4KSH4KSkLl/gpLjgpYvgpK4uX+CkruCkmeCljeCkl+Cksi5f4KSs4KWB4KSnLl/gpKzgpL/gpLngpL8uX+CktuClgeCkleCljeCksC5f4KS24KSo4KS/Licuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4KSG4KSHLl/gpLjgpYsuX+CkruCkmeCljV/gpKzgpYEuX+CkrOCkvy5f4KS24KWBLl/gpLYuJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0HgpJXgpYsgaDptbSDgpKzgpJzgpYcnLFxuICAgICAgICAgICAgTFRTIDogJ0HgpJXgpYsgaDptbTpzcyDgpKzgpJzgpYcnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQeCkleCliyBoOm1tIOCkrOCknOClhycsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBB4KSV4KWLIGg6bW0g4KSs4KSc4KWHJ1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4KWn4KWo4KWp4KWq4KWr4KWs4KWt4KWu4KWv4KWmXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv4KSw4KS+4KSk4KWAfOCkrOCkv+CkueCkvuCkqHzgpKbgpL/gpIngpIHgpLjgpYt84KSs4KWH4KSy4KWB4KSV4KS+fOCkuOCkvuCkgeCknXzgpLDgpL7gpKTgpYAvLFxuICAgICAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4KSw4KS+4KSk4KWAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyIDwgMyA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSs4KS/4KS54KS+4KSoJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuCkv+CkieCkgeCkuOCliycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSs4KWH4KSy4KWB4KSV4KS+JyB8fCBtZXJpZGllbSA9PT0gJ+CkuOCkvuCkgeCknScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KWAJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpKzgpL/gpLngpL7gpKgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CkpuCkv+CkieCkgeCkuOCliyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4KSs4KWH4KSy4KWB4KSV4KS+JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfgpLjgpL7gpIHgpJ0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpOClgCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4KSG4KScXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgpK3gpYvgpLLgpYBdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vgpIbgpIngpIHgpKbgpYtdIGRkZGRbLF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4KS54KS/4KSc4KWLXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb4KSX4KSP4KSV4KWLXSBkZGRkWyxdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclc+CkruCkvicsXG4gICAgICAgICAgICBwYXN0IDogJyVzIOCkheCkl+CkvuCkoeClgCcsXG4gICAgICAgICAgICBzIDogJ+CkleClh+CkueClgCDgpLjgpK7gpK8nLFxuICAgICAgICAgICAgbSA6ICfgpI/gpJUg4KSu4KS/4KSo4KWH4KSfJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOCkruCkv+CkqOClh+CknycsXG4gICAgICAgICAgICBoIDogJ+Ckj+CklSDgpJjgpKPgpY3gpJ/gpL4nLFxuICAgICAgICAgICAgaGggOiAnJWQg4KSY4KSj4KWN4KSf4KS+JyxcbiAgICAgICAgICAgIGQgOiAn4KSP4KSVIOCkpuCkv+CkqCcsXG4gICAgICAgICAgICBkZCA6ICclZCDgpKbgpL/gpKgnLFxuICAgICAgICAgICAgTSA6ICfgpI/gpJUg4KSu4KS54KS/4KSo4KS+JyxcbiAgICAgICAgICAgIE1NIDogJyVkIOCkruCkueCkv+CkqOCkvicsXG4gICAgICAgICAgICB5IDogJ+Ckj+CklSDgpKzgpLDgpY3gpLcnLFxuICAgICAgICAgICAgeXkgOiAnJWQg4KSs4KSw4KWN4KS3J1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBkdXRjaCAobmwpXG4vLyEgYXV0aG9yIDogSm9yaXMgUsO2bGluZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qanVwaXRlclxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWVpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0V2l0aG91dERvdHMgPSAnamFuX2ZlYl9tcnRfYXByX21laV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyk7XG5cbiAgICB2YXIgbmwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdubCcsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcmlfZmVicnVhcmlfbWFhcnRfYXByaWxfbWVpX2p1bmlfanVsaV9hdWd1c3R1c19zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRob3V0RG90c1ttLm1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRoRG90c1ttLm1vbnRoKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrZGF5cyA6ICd6b25kYWdfbWFhbmRhZ19kaW5zZGFnX3dvZW5zZGFnX2RvbmRlcmRhZ192cmlqZGFnX3phdGVyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3pvLl9tYS5fZGkuX3dvLl9kby5fdnIuX3phLicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnWm9fTWFfRGlfV29fRG9fVnJfWmEnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQtTU0tWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbdmFuZGFhZyBvbV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1ttb3JnZW4gb21dIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbb21dIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbZ2lzdGVyZW4gb21dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnW2FmZ2Vsb3Blbl0gZGRkZCBbb21dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ292ZXIgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBnZWxlZGVuJyxcbiAgICAgICAgICAgIHMgOiAnZWVuIHBhYXIgc2Vjb25kZW4nLFxuICAgICAgICAgICAgbSA6ICfDqcOpbiBtaW51dXQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXG4gICAgICAgICAgICBoIDogJ8Opw6luIHV1cicsXG4gICAgICAgICAgICBoaCA6ICclZCB1dXInLFxuICAgICAgICAgICAgZCA6ICfDqcOpbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnZW4nLFxuICAgICAgICAgICAgTSA6ICfDqcOpbiBtYWFuZCcsXG4gICAgICAgICAgICBNTSA6ICclZCBtYWFuZGVuJyxcbiAgICAgICAgICAgIHkgOiAnw6nDqW4gamFhcicsXG4gICAgICAgICAgICB5eSA6ICclZCBqYWFyJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdGV8ZGUpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAoKG51bWJlciA9PT0gMSB8fCBudW1iZXIgPT09IDggfHwgbnVtYmVyID49IDIwKSA/ICdzdGUnIDogJ2RlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5sO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL25sLmpzXG4gKiogbW9kdWxlIGlkID0gMjcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IG5vcndlZ2lhbiBueW5vcnNrIChubilcbi8vISBhdXRob3IgOiBodHRwczovL2dpdGh1Yi5jb20vbWVjaHV3aW5kXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIG5uID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbm4nLCB7XG4gICAgICAgIG1vbnRocyA6ICdqYW51YXJfZmVicnVhcl9tYXJzX2FwcmlsX21haV9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2Rlc2VtYmVyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2Rlcycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnc3VuZGFnX23DpW5kYWdfdHlzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sYXVyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3N1bl9tw6VuX3R5c19vbnNfdG9yX2ZyZV9sYXUnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ3N1X23DpV90eV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSSBkYWcga2xva2thXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW0kgbW9yZ29uIGtsb2trYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtrbG9ra2FdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbSSBnw6VyIGtsb2trYV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbRsO4cmVnw6VhbmRlXSBkZGRkIFtrbG9ra2FdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnZm9yICVzIHNpZGFuJyxcbiAgICAgICAgICAgIHMgOiAnbm9rcmUgc2VrdW5kJyxcbiAgICAgICAgICAgIG0gOiAnZWl0IG1pbnV0dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dHQnLFxuICAgICAgICAgICAgaCA6ICdlaW4gdGltZScsXG4gICAgICAgICAgICBoaCA6ICclZCB0aW1hcicsXG4gICAgICAgICAgICBkIDogJ2VpbiBkYWcnLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxuICAgICAgICAgICAgTSA6ICdlaW4gbcOlbmFkJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DpW5hZGVyJyxcbiAgICAgICAgICAgIHkgOiAnZWl0IMOlcicsXG4gICAgICAgICAgICB5eSA6ICclZCDDpXInXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBubjtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9ubi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBwb2xpc2ggKHBsKVxuLy8hIGF1dGhvciA6IFJhZmFsIEhpcnN6IDogaHR0cHM6Ly9naXRodWIuY29tL2V2b0xcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzTm9taW5hdGl2ZSA9ICdzdHljemXFhF9sdXR5X21hcnplY19rd2llY2llxYRfbWFqX2N6ZXJ3aWVjX2xpcGllY19zaWVycGllxYRfd3J6ZXNpZcWEX3Bhxbpkemllcm5pa19saXN0b3BhZF9ncnVkemllxYQnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1N1YmplY3RpdmUgPSAnc3R5Y3puaWFfbHV0ZWdvX21hcmNhX2t3aWV0bmlhX21hamFfY3plcndjYV9saXBjYV9zaWVycG5pYV93cnplxZtuaWFfcGHFumR6aWVybmlrYV9saXN0b3BhZGFfZ3J1ZG5pYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBwbHVyYWwobikge1xuICAgICAgICByZXR1cm4gKG4gJSAxMCA8IDUpICYmIChuICUgMTAgPiAxKSAmJiAoKH5+KG4gLyAxMCkgJSAxMCkgIT09IDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtaW51dGEnIDogJ21pbnV0xJknO1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbnV0eScgOiAnbWludXQnKTtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCAgPyAnZ29kemluYScgIDogJ2dvZHppbsSZJztcbiAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdnb2R6aW55JyA6ICdnb2R6aW4nKTtcbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtaWVzacSFY2UnIDogJ21pZXNpxJljeScpO1xuICAgICAgICBjYXNlICd5eSc6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2xhdGEnIDogJ2xhdCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBsID0gbW9tZW50LmRlZmluZUxvY2FsZSgncGwnLCB7XG4gICAgICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtb21lbnRUb0Zvcm1hdCwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIEhhY2s6IGlmIGZvcm1hdCBlbXB0eSB3ZSBrbm93IHRoaXMgaXMgdXNlZCB0byBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIFJlZ0V4cCBieSBtb21lbnQuIEdpdmUgdGhlbiBiYWNrIGJvdGggdmFsaWQgZm9ybXMgb2YgbW9udGhzXG4gICAgICAgICAgICAgICAgLy8gaW4gUmVnRXhwIHJlYWR5IGZvcm1hdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgbW9udGhzU3ViamVjdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXSArICd8JyArIG1vbnRoc05vbWluYXRpdmVbbW9tZW50VG9Gb3JtYXQubW9udGgoKV0gKyAnKSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9EIE1NTU0vLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb250aHNTdWJqZWN0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzTm9taW5hdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnc3R5X2x1dF9tYXJfa3dpX21hal9jemVfbGlwX3NpZV93cnpfcGHFul9saXNfZ3J1Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICduaWVkemllbGFfcG9uaWVkemlhxYJla193dG9yZWtfxZtyb2RhX2N6d2FydGVrX3BpxIV0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ25pZV9wb25fd3RfxZtyX2N6d19wdF9zYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnTl9Qbl9XdF/FmnJfQ3pfUHRfU28nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0R6acWbIG9dIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbSnV0cm8gb10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdbV10gZGRkZCBbb10gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tXY3pvcmFqIG9dIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIG5pZWR6aWVsxJkgb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyB6ZXN6xYLEhSDFm3JvZMSZIG9dIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgemVzesWCxIUgc29ib3TEmSBvXSBMVCc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyB6ZXN6xYJ5XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgdGVtdScsXG4gICAgICAgICAgICBzIDogJ2tpbGthIHNla3VuZCcsXG4gICAgICAgICAgICBtIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkIDogJzEgZHppZcWEJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRuaScsXG4gICAgICAgICAgICBNIDogJ21pZXNpxIVjJyxcbiAgICAgICAgICAgIE1NIDogdHJhbnNsYXRlLFxuICAgICAgICAgICAgeSA6ICdyb2snLFxuICAgICAgICAgICAgeXkgOiB0cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBsO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3BsLmpzXG4gKiogbW9kdWxlIGlkID0gMjczXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHBvcnR1Z3Vlc2UgKHB0KVxuLy8hIGF1dGhvciA6IEplZmZlcnNvbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWxleDc5XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHB0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgncHQnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW5laXJvX0ZldmVyZWlyb19NYXLDp29fQWJyaWxfTWFpb19KdW5ob19KdWxob19BZ29zdG9fU2V0ZW1icm9fT3V0dWJyb19Ob3ZlbWJyb19EZXplbWJybycuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX0Zldl9NYXJfQWJyX01haV9KdW5fSnVsX0Fnb19TZXRfT3V0X05vdl9EZXonLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ0RvbWluZ29fU2VndW5kYS1GZWlyYV9UZXLDp2EtRmVpcmFfUXVhcnRhLUZlaXJhX1F1aW50YS1GZWlyYV9TZXh0YS1GZWlyYV9Tw6FiYWRvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9TZWdfVGVyX1F1YV9RdWlfU2V4X1PDoWInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RvbV8ywqpfM8KqXzTCql81wqpfNsKqX1PDoWInLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBISDptbScsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW0hvamUgw6BzXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW0FtYW5ow6Mgw6BzXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW8Ogc10gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tPbnRlbSDDoHNdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRheSgpID09PSAwIHx8IHRoaXMuZGF5KCkgPT09IDYpID9cbiAgICAgICAgICAgICAgICAgICAgJ1vDmmx0aW1vXSBkZGRkIFvDoHNdIExUJyA6IC8vIFNhdHVyZGF5ICsgU3VuZGF5XG4gICAgICAgICAgICAgICAgICAgICdbw5psdGltYV0gZGRkZCBbw6BzXSBMVCc7IC8vIE1vbmRheSAtIEZyaWRheVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2VtICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnaMOhICVzJyxcbiAgICAgICAgICAgIHMgOiAnc2VndW5kb3MnLFxuICAgICAgICAgICAgbSA6ICd1bSBtaW51dG8nLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXG4gICAgICAgICAgICBoIDogJ3VtYSBob3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcmFzJyxcbiAgICAgICAgICAgIGQgOiAndW0gZGlhJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRpYXMnLFxuICAgICAgICAgICAgTSA6ICd1bSBtw6pzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc2VzJyxcbiAgICAgICAgICAgIHkgOiAndW0gYW5vJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFub3MnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwdDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9wdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBicmF6aWxpYW4gcG9ydHVndWVzZSAocHQtYnIpXG4vLyEgYXV0aG9yIDogQ2FpbyBSaWJlaXJvIFBlcmVpcmEgOiBodHRwczovL2dpdGh1Yi5jb20vY2Fpby1yaWJlaXJvLXBlcmVpcmFcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgcHRfYnIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdwdC1icicsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbmVpcm9fRmV2ZXJlaXJvX01hcsOnb19BYnJpbF9NYWlvX0p1bmhvX0p1bGhvX0Fnb3N0b19TZXRlbWJyb19PdXR1YnJvX05vdmVtYnJvX0RlemVtYnJvJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdKYW5fRmV2X01hcl9BYnJfTWFpX0p1bl9KdWxfQWdvX1NldF9PdXRfTm92X0Rleicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnRG9taW5nb19TZWd1bmRhLUZlaXJhX1RlcsOnYS1GZWlyYV9RdWFydGEtRmVpcmFfUXVpbnRhLUZlaXJhX1NleHRhLUZlaXJhX1PDoWJhZG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnRG9tX1NlZ19UZXJfUXVhX1F1aV9TZXhfU8OhYicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnRG9tXzLCql8zwqpfNMKqXzXCql82wqpfU8OhYicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIFvDoHNdIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIFvDoHNdIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSG9qZSDDoHNdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdbQW1hbmjDoyDDoHNdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbw6BzXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW09udGVtIMOgc10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZGF5KCkgPT09IDAgfHwgdGhpcy5kYXkoKSA9PT0gNikgP1xuICAgICAgICAgICAgICAgICAgICAnW8OabHRpbW9dIGRkZGQgW8Ogc10gTFQnIDogLy8gU2F0dXJkYXkgKyBTdW5kYXlcbiAgICAgICAgICAgICAgICAgICAgJ1vDmmx0aW1hXSBkZGRkIFvDoHNdIExUJzsgLy8gTW9uZGF5IC0gRnJpZGF5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnZW0gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBhdHLDoXMnLFxuICAgICAgICAgICAgcyA6ICdwb3Vjb3Mgc2VndW5kb3MnLFxuICAgICAgICAgICAgbSA6ICd1bSBtaW51dG8nLFxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXG4gICAgICAgICAgICBoIDogJ3VtYSBob3JhJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvcmFzJyxcbiAgICAgICAgICAgIGQgOiAndW0gZGlhJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRpYXMnLFxuICAgICAgICAgICAgTSA6ICd1bSBtw6pzJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG1lc2VzJyxcbiAgICAgICAgICAgIHkgOiAndW0gYW5vJyxcbiAgICAgICAgICAgIHl5IDogJyVkIGFub3MnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxuICAgICAgICBvcmRpbmFsIDogJyVkwronXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHRfYnI7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvcHQtYnIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogcm9tYW5pYW4gKHJvKVxuLy8hIGF1dGhvciA6IFZsYWQgR3VyZGlnYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ndXJkaWdhXG4vLyEgYXV0aG9yIDogVmFsZW50aW4gQWdhY2hpIDogaHR0cHM6Ly9naXRodWIuY29tL2F2YWx5XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgICAgICdtbSc6ICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdoaCc6ICdvcmUnLFxuICAgICAgICAgICAgICAgICdkZCc6ICd6aWxlJyxcbiAgICAgICAgICAgICAgICAnTU0nOiAnbHVuaScsXG4gICAgICAgICAgICAgICAgJ3l5JzogJ2FuaSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAnICc7XG4gICAgICAgIGlmIChudW1iZXIgJSAxMDAgPj0gMjAgfHwgKG51bWJlciA+PSAxMDAgJiYgbnVtYmVyICUgMTAwID09PSAwKSkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gJyBkZSAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBzZXBhcmF0b3IgKyBmb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgcm8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdybycsIHtcbiAgICAgICAgbW9udGhzIDogJ2lhbnVhcmllX2ZlYnJ1YXJpZV9tYXJ0aWVfYXByaWxpZV9tYWlfaXVuaWVfaXVsaWVfYXVndXN0X3NlcHRlbWJyaWVfb2N0b21icmllX25vaWVtYnJpZV9kZWNlbWJyaWUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2lhbi5fZmVici5fbWFydC5fYXByLl9tYWlfaXVuLl9pdWwuX2F1Zy5fc2VwdC5fb2N0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ2R1bWluaWPEg19sdW5pX21hcsibaV9taWVyY3VyaV9qb2lfdmluZXJpX3PDom1ixIN0xIMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnRHVtX0x1bl9NYXJfTWllX0pvaV9WaW5fU8OibScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnRHVfTHVfTWFfTWlfSm9fVmlfU8OiJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0g6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW2F6aSBsYV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1ttw6JpbmUgbGFdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbbGFdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXk6ICdbaWVyaSBsYV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbZm9zdGFdIGRkZGQgW2xhXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdwZXN0ZSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIMOubiB1cm3EgycsXG4gICAgICAgICAgICBzIDogJ2PDonRldmEgc2VjdW5kZScsXG4gICAgICAgICAgICBtIDogJ3VuIG1pbnV0JyxcbiAgICAgICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGggOiAnbyBvcsSDJyxcbiAgICAgICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGQgOiAnbyB6aScsXG4gICAgICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBNIDogJ28gbHVuxIMnLFxuICAgICAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgeSA6ICd1biBhbicsXG4gICAgICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm87XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvcm8uanNcbiAqKiBtb2R1bGUgaWQgPSAyNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogcnVzc2lhbiAocnUpXG4vLyEgYXV0aG9yIDogVmlrdG9ybWluYXRvciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9WaWt0b3JtaW5hdG9yXG4vLyEgQXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XG4gICAgICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ21tJzogd2l0aG91dFN1ZmZpeCA/ICfQvNC40L3Rg9GC0LBf0LzQuNC90YPRgtGLX9C80LjQvdGD0YInIDogJ9C80LjQvdGD0YLRg1/QvNC40L3Rg9GC0Ytf0LzQuNC90YPRgicsXG4gICAgICAgICAgICAnaGgnOiAn0YfQsNGBX9GH0LDRgdCwX9GH0LDRgdC+0LInLFxuICAgICAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rj1/QtNC90LXQuScsXG4gICAgICAgICAgICAnTU0nOiAn0LzQtdGB0Y/Rhl/QvNC10YHRj9GG0LBf0LzQtdGB0Y/RhtC10LInLFxuICAgICAgICAgICAgJ3l5JzogJ9Cz0L7QtF/Qs9C+0LTQsF/Qu9C10YInXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgPT09ICdtJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LzQuNC90YPRgtCwJyA6ICfQvNC40L3Rg9GC0YMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHBsdXJhbChmb3JtYXRba2V5XSwgK251bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW9udGhzQ2FzZVJlcGxhY2UobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBtb250aHMgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfRj9C90LLQsNGA0Yxf0YTQtdCy0YDQsNC70Yxf0LzQsNGA0YJf0LDQv9GA0LXQu9GMX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YDRjF/QvtC60YLRj9Cx0YDRjF/QvdC+0Y/QsdGA0Yxf0LTQtdC60LDQsdGA0YwnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICfRj9C90LLQsNGA0Y9f0YTQtdCy0YDQsNC70Y9f0LzQsNGA0YLQsF/QsNC/0YDQtdC70Y9f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQs9GD0YHRgtCwX9GB0LXQvdGC0Y/QsdGA0Y9f0L7QutGC0Y/QsdGA0Y9f0L3QvtGP0LHRgNGPX9C00LXQutCw0LHRgNGPJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdW5DYXNlID0gKC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgJ25vbWluYXRpdmUnO1xuICAgICAgICByZXR1cm4gbW9udGhzW25vdW5DYXNlXVttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydENhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgbW9udGhzU2hvcnQgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfRj9C90LJf0YTQtdCyX9C80LDRgNGCX9Cw0L/RgF/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCzX9GB0LXQvV/QvtC60YJf0L3QvtGPX9C00LXQuicuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgICdhY2N1c2F0aXZlJzogJ9GP0L3Qsl/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Y9f0LjRjtC90Y9f0LjRjtC70Y9f0LDQstCzX9GB0LXQvV/QvtC60YJf0L3QvtGPX9C00LXQuicuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBub3VuQ2FzZSA9ICgvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKykrTU1NTT8vKS50ZXN0KGZvcm1hdCkgP1xuICAgICAgICAgICAgJ2FjY3VzYXRpdmUnIDpcbiAgICAgICAgICAgICdub21pbmF0aXZlJztcbiAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0W25vdW5DYXNlXVttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1X9C/0L7QvdC10LTQtdC70YzQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstC10YDQs1/Qv9GP0YLQvdC40YbQsF/RgdGD0LHQsdC+0YLQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgICAgICdhY2N1c2F0aXZlJzogJ9Cy0L7RgdC60YDQtdGB0LXQvdGM0LVf0L/QvtC90LXQtNC10LvRjNC90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNGDX9GH0LXRgtCy0LXRgNCzX9C/0Y/RgtC90LjRhtGDX9GB0YPQsdCx0L7RgtGDJy5zcGxpdCgnXycpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdW5DYXNlID0gKC9cXFsgP1vQktCyXSA/KD860L/RgNC+0YjQu9GD0Y580YHQu9C10LTRg9GO0YnRg9GOfNGN0YLRgyk/ID9cXF0gP2RkZGQvKS50ZXN0KGZvcm1hdCkgP1xuICAgICAgICAgICAgJ2FjY3VzYXRpdmUnIDpcbiAgICAgICAgICAgICdub21pbmF0aXZlJztcbiAgICAgICAgcmV0dXJuIHdlZWtkYXlzW25vdW5DYXNlXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgcnUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdydScsIHtcbiAgICAgICAgbW9udGhzIDogbW9udGhzQ2FzZVJlcGxhY2UsXG4gICAgICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnRDYXNlUmVwbGFjZSxcbiAgICAgICAgd2Vla2RheXMgOiB3ZWVrZGF5c0Nhc2VSZXBsYWNlLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ9Cy0YFf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9Cy0YFf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1BhcnNlIDogWy9e0Y/QvdCyL2ksIC9e0YTQtdCyL2ksIC9e0LzQsNGAL2ksIC9e0LDQv9GAL2ksIC9e0LzQsFvQuXzRj10vaSwgL17QuNGO0L0vaSwgL17QuNGO0LsvaSwgL17QsNCy0LMvaSwgL17RgdC10L0vaSwgL17QvtC60YIvaSwgL17QvdC+0Y8vaSwgL17QtNC10LovaV0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDQsy4nLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINCzLiwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDQsy4sIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb0KHQtdCz0L7QtNC90Y8g0LJdIExUJyxcbiAgICAgICAgICAgIG5leHREYXk6ICdb0JfQsNCy0YLRgNCwINCyXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW9CS0YfQtdGA0LAg0LJdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgPT09IDIgPyAnW9CS0L5dIGRkZGQgW9CyXSBMVCcgOiAnW9CSXSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdy53ZWVrKCkgIT09IHRoaXMud2VlaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDQv9GA0L7RiNC70L7QtV0gZGRkZCBb0LJdIExUJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC/0YDQvtGI0LvRi9C5XSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9GD0Y5dIGRkZGQgW9CyXSBMVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXkoKSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JLQvl0gZGRkZCBb0LJdIExUJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSXSBkZGRkIFvQsl0gTFQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ9GH0LXRgNC10LcgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDQvdCw0LfQsNC0JyxcbiAgICAgICAgICAgIHMgOiAn0L3QtdGB0LrQvtC70YzQutC+INGB0LXQutGD0L3QtCcsXG4gICAgICAgICAgICBtIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGggOiAn0YfQsNGBJyxcbiAgICAgICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIGQgOiAn0LTQtdC90YwnLFxuICAgICAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxuICAgICAgICAgICAgTSA6ICfQvNC10YHRj9GGJyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiAn0LPQvtC0JyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0Lh80YPRgtGA0LB80LTQvdGPfNCy0LXRh9C10YDQsC9pLFxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C10YDQsCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9C4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRg9GC0YDQsCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xuICAgICAgICAgICAgICAgIHJldHVybiAn0LTQvdGPJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQstC10YfQtdGA0LAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0Ll80LPQvnzRjykvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QuSc7XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Qs9C+JztcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0Y8nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBydTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9ydS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBTaW5oYWxlc2UgKHNpKVxuLy8hIGF1dGhvciA6IFNhbXBhdGggU2l0aW5hbWFsdXdhIDogaHR0cHM6Ly9naXRodWIuY29tL3NhbXBhdGhzcmlzXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHNpID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc2knLCB7XG4gICAgICAgIG1vbnRocyA6ICfgtqLgtrHgt4Dgt4/gtrvgt5Jf4La04LeZ4La24La74LeA4LeP4La74LeSX+C2uOC3j+C2u+C3iuC2reC3lF/gtoXgtrTgt4rigI3gtrvgt5rgtr3gt4pf4La44LeQ4La64LeSX+C2ouC3luC2seC3kl/gtqLgt5bgtr3gt5Jf4LaF4Lac4Led4LeD4LeK4Lat4LeUX+C3g+C3kOC2tOC3iuC2reC3kOC2uOC3iuC2tuC2u+C3il/gtpTgtprgt4rgtq3gt53gtrbgtrvgt4pf4Lax4Lec4LeA4LeQ4La44LeK4La24La74LeKX+C2r+C3meC3g+C3kOC2uOC3iuC2tuC2u+C3iicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4Lai4LaxX+C2tOC3meC2tl/gtrjgt4/gtrvgt4pf4LaF4La04LeKX+C2uOC3kOC2uuC3kl/gtqLgt5bgtrHgt5Jf4Lai4LeW4La94LeSX+C2heC2nOC3nV/gt4Pgt5DgtrTgt4pf4LaU4Laa4LeKX+C2seC3nOC3gOC3kF/gtq/gt5ngt4Pgt5AnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+C2ieC2u+C3kuC2r+C3j1/gt4PgtrPgt5Tgtq/gt49f4LaF4Laf4LeE4La74LeU4LeA4LeP4Lav4LePX+C2tuC2r+C3j+C2r+C3j1/gtrbgt4rigI3gtrvgt4Tgt4Pgt4rgtrTgtq3gt5LgtrHgt4rgtq/gt49f4LeD4LeS4Laa4LeU4La74LeP4Lav4LePX+C3g+C3meC2seC3g+C3lOC2u+C3j+C2r+C3jycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgtongtrvgt5Jf4LeD4Laz4LeUX+C2heC2n1/gtrbgtq/gt49f4La24LeK4oCN4La74LeEX+C3g+C3kuC2muC3lF/gt4Pgt5ngtrEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+C2iV/gt4Nf4LaFX+C2tl/gtrbgt4rigI3gtrtf4LeD4LeSX+C3g+C3mScuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdhIGg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ2EgaDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ1lZWVkvTU0vREQnLFxuICAgICAgICAgICAgTEwgOiAnWVlZWSBNTU1NIEQnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVkgTU1NTSBELCBhIGg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdZWVlZIE1NTU0gRCBb4LeA4LeQ4Lax4LeSXSBkZGRkLCBhIGg6bW06c3MnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4LaF4LavXSBMVFvgtqddJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW+C3hOC3meC2p10gTFRb4LanXScsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIExUW+C2p10nLFxuICAgICAgICAgICAgbGFzdERheSA6ICdb4LaK4La64LeaXSBMVFvgtqddJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vgtrTgt4Pgt5Tgtpzgt5LgtrpdIGRkZGQgTFRb4LanXScsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXPgtprgt5LgtrHgt4onLFxuICAgICAgICAgICAgcGFzdCA6ICclc+C2muC2pyDgtrTgt5ngtrsnLFxuICAgICAgICAgICAgcyA6ICfgtq3gtq3gt4rgtrTgtrsg4Laa4LeS4LeE4LeS4La04La6JyxcbiAgICAgICAgICAgIG0gOiAn4La44LeS4Lax4LeS4Lat4LeK4Lat4LeU4LeAJyxcbiAgICAgICAgICAgIG1tIDogJ+C2uOC3kuC2seC3kuC2reC3iuC2reC3lCAlZCcsXG4gICAgICAgICAgICBoIDogJ+C2tOC3kOC2uicsXG4gICAgICAgICAgICBoaCA6ICfgtrTgt5DgtrogJWQnLFxuICAgICAgICAgICAgZCA6ICfgtq/gt5LgtrHgtronLFxuICAgICAgICAgICAgZGQgOiAn4Lav4LeS4LaxICVkJyxcbiAgICAgICAgICAgIE0gOiAn4La44LeP4LeD4La6JyxcbiAgICAgICAgICAgIE1NIDogJ+C2uOC3j+C3gyAlZCcsXG4gICAgICAgICAgICB5IDogJ+C3gOC3g+C2uycsXG4gICAgICAgICAgICB5eSA6ICfgt4Dgt4PgtrsgJWQnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9IOC3gOC3kOC2seC3ki8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDgt4Dgt5DgtrHgt5InO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfgtrQu4LeALicgOiAn4La04LeD4LeKIOC3gOC2u+C3lCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ+C2tOC3mS7gt4AuJyA6ICfgtrTgt5ngtrsg4LeA4La74LeUJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3NpLmpzXG4gKiogbW9kdWxlIGlkID0gMjc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHNsb3ZhayAoc2spXG4vLyEgYXV0aG9yIDogTWFydGluIE1pbmthIDogaHR0cHM6Ly9naXRodWIuY29tL2syc1xuLy8hIGJhc2VkIG9uIHdvcmsgb2YgcGV0cmJlbGEgOiBodHRwczovL2dpdGh1Yi5jb20vcGV0cmJlbGFcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgbW9udGhzID0gJ2phbnXDoXJfZmVicnXDoXJfbWFyZWNfYXByw61sX23DoWpfasO6bl9qw7psX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0ID0gJ2phbl9mZWJfbWFyX2Fwcl9tw6FqX2rDum5fasO6bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIHBsdXJhbChuKSB7XG4gICAgICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAncyc6ICAvLyBhIGZldyBzZWNvbmRzIC8gaW4gYSBmZXcgc2Vjb25kcyAvIGEgZmV3IHNlY29uZHMgYWdvXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3DDoXIgc2Vrw7puZCcgOiAncMOhciBzZWt1bmRhbWknO1xuICAgICAgICBjYXNlICdtJzogIC8vIGEgbWludXRlIC8gaW4gYSBtaW51dGUgLyBhIG1pbnV0ZSBhZ29cbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ21pbsO6dGEnIDogKGlzRnV0dXJlID8gJ21pbsO6dHUnIDogJ21pbsO6dG91Jyk7XG4gICAgICAgIGNhc2UgJ21tJzogLy8gOSBtaW51dGVzIC8gaW4gOSBtaW51dGVzIC8gOSBtaW51dGVzIGFnb1xuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbsO6dHknIDogJ21pbsO6dCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ21pbsO6dGFtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaCc6ICAvLyBhbiBob3VyIC8gaW4gYW4gaG91ciAvIGFuIGhvdXIgYWdvXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdob2RpbmEnIDogKGlzRnV0dXJlID8gJ2hvZGludScgOiAnaG9kaW5vdScpO1xuICAgICAgICBjYXNlICdoaCc6IC8vIDkgaG91cnMgLyBpbiA5IGhvdXJzIC8gOSBob3VycyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdob2RpbnknIDogJ2hvZMOtbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2hvZGluYW1pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkJzogIC8vIGEgZGF5IC8gaW4gYSBkYXkgLyBhIGRheSBhZ29cbiAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAnZGXFiCcgOiAnZMWIb20nO1xuICAgICAgICBjYXNlICdkZCc6IC8vIDkgZGF5cyAvIGluIDkgZGF5cyAvIDkgZGF5cyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdkbmknIDogJ2Ruw60nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkxYhhbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ00nOiAgLy8gYSBtb250aCAvIGluIGEgbW9udGggLyBhIG1vbnRoIGFnb1xuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdtZXNpYWMnIDogJ21lc2lhY29tJztcbiAgICAgICAgY2FzZSAnTU0nOiAvLyA5IG1vbnRocyAvIGluIDkgbW9udGhzIC8gOSBtb250aHMgYWdvXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWVzaWFjZScgOiAnbWVzaWFjb3YnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtZXNpYWNtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneSc6ICAvLyBhIHllYXIgLyBpbiBhIHllYXIgLyBhIHllYXIgYWdvXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3JvaycgOiAncm9rb20nO1xuICAgICAgICBjYXNlICd5eSc6IC8vIDkgeWVhcnMgLyBpbiA5IHllYXJzIC8gOSB5ZWFycyBhZ29cbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdyb2t5JyA6ICdyb2tvdicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ3Jva21pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNrID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc2snLCB7XG4gICAgICAgIG1vbnRocyA6IG1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcbiAgICAgICAgbW9udGhzUGFyc2UgOiAoZnVuY3Rpb24gKG1vbnRocywgbW9udGhzU2hvcnQpIHtcbiAgICAgICAgICAgIHZhciBpLCBfbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSBwYXJzZXIgdG8gc29sdmUgcHJvYmxlbSB3aXRoIEp1bHkgKMSNZXJ2ZW5lYylcbiAgICAgICAgICAgICAgICBfbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIG1vbnRoc1tpXSArICckfF4nICsgbW9udGhzU2hvcnRbaV0gKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX21vbnRoc1BhcnNlO1xuICAgICAgICB9KG1vbnRocywgbW9udGhzU2hvcnQpKSxcbiAgICAgICAgd2Vla2RheXMgOiAnbmVkZcS+YV9wb25kZWxva191dG9yb2tfc3RyZWRhX8WhdHZydG9rX3BpYXRva19zb2JvdGEnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVfcG9fdXRfc3RfxaF0X3BpX3NvJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICduZV9wb191dF9zdF/FoXRfcGlfc28nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQ6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW2RuZXMgb10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1t6YWp0cmEgb10gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgbmVkZcS+dSBvXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gZGRkZCBbb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBzdHJlZHUgb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdm8gxaF0dnJ0b2sgb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBwaWF0b2sgb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBzb2JvdHUgb10gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5OiAnW3bEjWVyYSBvXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBuZWRlxL51IG9dIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFtvXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO6IHN0cmVkdSBvXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDvV0gZGRkZCBbb10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBzb2JvdHUgb10gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3ByZWQgJXMnLFxuICAgICAgICAgICAgcyA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGQgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgOiB0cmFuc2xhdGUsXG4gICAgICAgICAgICB5eSA6IHRyYW5zbGF0ZVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2s7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogc2xvdmVuaWFuIChzbClcbi8vISBhdXRob3IgOiBSb2JlcnQgU2Vkb3bFoWVrIDogaHR0cHM6Ly9naXRodWIuY29tL3NlZG92c2VrXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICduZWthaiBzZWt1bmQnIDogJ25la2FqIHNla3VuZGFtaSc7XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnZW5hIG1pbnV0YScgOiAnZW5vIG1pbnV0byc7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCA/ICdtaW51dGEnIDogJ21pbnV0byc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21pbnV0aScgOiAnbWludXRhbWEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPCA1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWludXRlJyA6ICdtaW51dGFtaSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21pbnV0JyA6ICdtaW51dGFtaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2VuYSB1cmEnIDogJ2VubyB1cm8nO1xuICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggPyAndXJhJyA6ICd1cm8nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICd1cmknIDogJ3VyYW1hJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3VyZScgOiAndXJhbWknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICd1cicgOiAndXJhbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbiBkYW4nIDogJ2VuaW0gZG5lbSc7XG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkYW4nIDogJ2RuZW0nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkbmknIDogJ2RuZXZvbWEnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkbmknIDogJ2RuZXZpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnZW4gbWVzZWMnIDogJ2VuaW0gbWVzZWNlbSc7XG4gICAgICAgIGNhc2UgJ01NJzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlYycgOiAnbWVzZWNlbSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21lc2VjYScgOiAnbWVzZWNlbWEnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPCA1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWNlJyA6ICdtZXNlY2knO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlY2V2JyA6ICdtZXNlY2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbm8gbGV0bycgOiAnZW5pbSBsZXRvbSc7XG4gICAgICAgIGNhc2UgJ3l5JzpcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXRvJyA6ICdsZXRvbSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2xldGknIDogJ2xldG9tYSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXRhJyA6ICdsZXRpJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0JyA6ICdsZXRpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2wgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzbCcsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcmVjX2FwcmlsX21hal9qdW5pal9qdWxpal9hdmd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbi5fZmViLl9tYXIuX2Fwci5fbWFqLl9qdW4uX2p1bC5fYXZnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICduZWRlbGphX3BvbmVkZWxqZWtfdG9yZWtfc3JlZGFfxI1ldHJ0ZWtfcGV0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ25lZC5fcG9uLl90b3IuX3NyZS5fxI1ldC5fcGV0Ll9zb2IuJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICduZV9wb190b19zcl/EjWVfcGVfc28nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELiBNTS4gWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSAgOiAnW2RhbmVzIG9iXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5ICA6ICdbanV0cmkgb2JdIExUJyxcblxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBbbmVkZWxqb10gW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBbc3JlZG9dIFtvYl0gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gW3NvYm90b10gW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFtvYl0gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdbdsSNZXJhaiBvYl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuam9dIFtuZWRlbGpvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qb10gW3NyZWRvXSBbb2JdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qb10gW3NvYm90b10gW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuamldIGRkZGQgW29iXSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfEjWV6ICVzJyxcbiAgICAgICAgICAgIHBhc3QgICA6ICdwcmVkICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbW0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGggICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoaCAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGRkICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgTU0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHkgICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5eSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzbDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9zbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBBbGJhbmlhbiAoc3EpXG4vLyEgYXV0aG9yIDogRmxha8OrcmltIElzbWFuaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbGFrZXJpbWlcbi8vISBhdXRob3I6IE1lbmVsaW9uIEVsZW5zw7psZTogaHR0cHM6Ly9naXRodWIuY29tL09pcmUgKHRlc3RzKVxuLy8hIGF1dGhvciA6IE9lcmQgQ3VrYWxsYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9vZXJkIChmaXhlcylcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3EgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzcScsIHtcbiAgICAgICAgbW9udGhzIDogJ0phbmFyX1Noa3VydF9NYXJzX1ByaWxsX01hal9RZXJzaG9yX0tvcnJpa19HdXNodF9TaHRhdG9yX1RldG9yX07Dq250b3JfRGhqZXRvcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAnSmFuX1Noa19NYXJfUHJpX01hal9RZXJfS29yX0d1c19TaHRfVGV0X07Dq25fRGhqJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdFIERpZWxfRSBIw6tuw6tfRSBNYXJ0w6tfRSBNw6tya3Vyw6tfRSBFbmp0ZV9FIFByZW10ZV9FIFNodHVuw6snLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnRGllX0jDq25fTWFyX03Dq3JfRW5qX1ByZV9TaHQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ0RfSF9NYV9Nw6tfRV9QX1NoJy5zcGxpdCgnXycpLFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAvUER8TUQvLFxuICAgICAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQoMCkgPT09ICdNJztcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBob3VycyA8IDEyID8gJ1BEJyA6ICdNRCc7XG4gICAgICAgIH0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tTb3QgbsOrXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tOZXPDq3IgbsOrXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtuw6tdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW0RqZSBuw6tdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2Uga2FsdWFyIG7Dq10gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ27DqyAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzIG3DqyBwYXLDqycsXG4gICAgICAgICAgICBzIDogJ2Rpc2Egc2Vrb25kYScsXG4gICAgICAgICAgICBtIDogJ25qw6sgbWludXTDqycsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGEnLFxuICAgICAgICAgICAgaCA6ICduasOrIG9yw6snLFxuICAgICAgICAgICAgaGggOiAnJWQgb3LDqycsXG4gICAgICAgICAgICBkIDogJ25qw6sgZGl0w6snLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGl0w6snLFxuICAgICAgICAgICAgTSA6ICduasOrIG11YWonLFxuICAgICAgICAgICAgTU0gOiAnJWQgbXVhaicsXG4gICAgICAgICAgICB5IDogJ25qw6sgdml0JyxcbiAgICAgICAgICAgIHl5IDogJyVkIHZpdGUnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzcTtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS9zcS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBTZXJiaWFuLWxhdGluIChzcilcbi8vISBhdXRob3IgOiBNaWxhbiBKYW5hxI1rb3ZpxIc8bWlsYW5qYW5hY2tvdmljQGdtYWlsLmNvbT4gOiBodHRwczovL2dpdGh1Yi5jb20vbWlsYW4talxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB0cmFuc2xhdG9yID0ge1xuICAgICAgICB3b3JkczogeyAvL0RpZmZlcmVudCBncmFtbWF0aWNhbCBjYXNlc1xuICAgICAgICAgICAgbTogWydqZWRhbiBtaW51dCcsICdqZWRuZSBtaW51dGUnXSxcbiAgICAgICAgICAgIG1tOiBbJ21pbnV0JywgJ21pbnV0ZScsICdtaW51dGEnXSxcbiAgICAgICAgICAgIGg6IFsnamVkYW4gc2F0JywgJ2plZG5vZyBzYXRhJ10sXG4gICAgICAgICAgICBoaDogWydzYXQnLCAnc2F0YScsICdzYXRpJ10sXG4gICAgICAgICAgICBkZDogWydkYW4nLCAnZGFuYScsICdkYW5hJ10sXG4gICAgICAgICAgICBNTTogWydtZXNlYycsICdtZXNlY2EnLCAnbWVzZWNpJ10sXG4gICAgICAgICAgICB5eTogWydnb2RpbmEnLCAnZ29kaW5lJywgJ2dvZGluYSddXG4gICAgICAgIH0sXG4gICAgICAgIGNvcnJlY3RHcmFtbWF0aWNhbENhc2U6IGZ1bmN0aW9uIChudW1iZXIsIHdvcmRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgPT09IDEgPyB3b3JkS2V5WzBdIDogKG51bWJlciA+PSAyICYmIG51bWJlciA8PSA0ID8gd29yZEtleVsxXSA6IHdvcmRLZXlbMl0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICAgICAgdmFyIHdvcmRLZXkgPSB0cmFuc2xhdG9yLndvcmRzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gd29yZEtleVswXSA6IHdvcmRLZXlbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3IgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzcicsIHtcbiAgICAgICAgbW9udGhzOiBbJ2phbnVhcicsICdmZWJydWFyJywgJ21hcnQnLCAnYXByaWwnLCAnbWFqJywgJ2p1bicsICdqdWwnLCAnYXZndXN0JywgJ3NlcHRlbWJhcicsICdva3RvYmFyJywgJ25vdmVtYmFyJywgJ2RlY2VtYmFyJ10sXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbJ2phbi4nLCAnZmViLicsICdtYXIuJywgJ2Fwci4nLCAnbWFqJywgJ2p1bicsICdqdWwnLCAnYXZnLicsICdzZXAuJywgJ29rdC4nLCAnbm92LicsICdkZWMuJ10sXG4gICAgICAgIHdlZWtkYXlzOiBbJ25lZGVsamEnLCAncG9uZWRlbGphaycsICd1dG9yYWsnLCAnc3JlZGEnLCAnxI1ldHZydGFrJywgJ3BldGFrJywgJ3N1Ym90YSddLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBbJ25lZC4nLCAncG9uLicsICd1dG8uJywgJ3NyZS4nLCAnxI1ldC4nLCAncGV0LicsICdzdWIuJ10sXG4gICAgICAgIHdlZWtkYXlzTWluOiBbJ25lJywgJ3BvJywgJ3V0JywgJ3NyJywgJ8SNZScsICdwZScsICdzdSddLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgTFQ6ICdIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdIOm1tOnNzJyxcbiAgICAgICAgICAgIEw6ICdERC4gTU0uIFlZWVknLFxuICAgICAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxuICAgICAgICAgICAgTExMTDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhcjoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tkYW5hcyB1XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW3N1dHJhIHVdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkZWxqdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmVkdV0gW3VdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZSB1XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtuZWRlbGplXSBbdV0gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcG9uZWRlbGprYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3V0b3JrYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbc3JlZGVdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFvEjWV0dnJ0a2FdIFt1XSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFtwZXRrYV0gW3VdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbc3Vib3RlXSBbdV0gTFQnXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFdlZWtEYXlzW3RoaXMuZGF5KCldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXG4gICAgICAgICAgICBwYXN0ICAgOiAncHJlICVzJyxcbiAgICAgICAgICAgIHMgICAgICA6ICduZWtvbGlrbyBzZWt1bmRpJyxcbiAgICAgICAgICAgIG0gICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgbW0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBoICAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGhoICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgZCAgICAgIDogJ2RhbicsXG4gICAgICAgICAgICBkZCAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIE0gICAgICA6ICdtZXNlYycsXG4gICAgICAgICAgICBNTSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxuICAgICAgICAgICAgeXkgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxuICAgICAgICBvcmRpbmFsIDogJyVkLicsXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNyO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3NyLmpzXG4gKiogbW9kdWxlIGlkID0gMjgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IFNlcmJpYW4tY3lyaWxsaWMgKHNyLWN5cmwpXG4vLyEgYXV0aG9yIDogTWlsYW4gSmFuYcSNa292acSHPG1pbGFuamFuYWNrb3ZpY0BnbWFpbC5jb20+IDogaHR0cHM6Ly9naXRodWIuY29tL21pbGFuLWpcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgdHJhbnNsYXRvciA9IHtcbiAgICAgICAgd29yZHM6IHsgLy9EaWZmZXJlbnQgZ3JhbW1hdGljYWwgY2FzZXNcbiAgICAgICAgICAgIG06IFsn0ZjQtdC00LDQvSDQvNC40L3Rg9GCJywgJ9GY0LXQtNC90LUg0LzQuNC90YPRgtC1J10sXG4gICAgICAgICAgICBtbTogWyfQvNC40L3Rg9GCJywgJ9C80LjQvdGD0YLQtScsICfQvNC40L3Rg9GC0LAnXSxcbiAgICAgICAgICAgIGg6IFsn0ZjQtdC00LDQvSDRgdCw0YInLCAn0ZjQtdC00L3QvtCzINGB0LDRgtCwJ10sXG4gICAgICAgICAgICBoaDogWyfRgdCw0YInLCAn0YHQsNGC0LAnLCAn0YHQsNGC0LgnXSxcbiAgICAgICAgICAgIGRkOiBbJ9C00LDQvScsICfQtNCw0L3QsCcsICfQtNCw0L3QsCddLFxuICAgICAgICAgICAgTU06IFsn0LzQtdGB0LXRhicsICfQvNC10YHQtdGG0LAnLCAn0LzQtdGB0LXRhtC4J10sXG4gICAgICAgICAgICB5eTogWyfQs9C+0LTQuNC90LAnLCAn0LPQvtC00LjQvdC1JywgJ9Cz0L7QtNC40L3QsCddXG4gICAgICAgIH0sXG4gICAgICAgIGNvcnJlY3RHcmFtbWF0aWNhbENhc2U6IGZ1bmN0aW9uIChudW1iZXIsIHdvcmRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgPT09IDEgPyB3b3JkS2V5WzBdIDogKG51bWJlciA+PSAyICYmIG51bWJlciA8PSA0ID8gd29yZEtleVsxXSA6IHdvcmRLZXlbMl0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xuICAgICAgICAgICAgdmFyIHdvcmRLZXkgPSB0cmFuc2xhdG9yLndvcmRzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gd29yZEtleVswXSA6IHdvcmRLZXlbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3JfY3lybCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NyLWN5cmwnLCB7XG4gICAgICAgIG1vbnRoczogWyfRmNCw0L3Rg9Cw0YAnLCAn0YTQtdCx0YDRg9Cw0YAnLCAn0LzQsNGA0YInLCAn0LDQv9GA0LjQuycsICfQvNCw0ZgnLCAn0ZjRg9C9JywgJ9GY0YPQuycsICfQsNCy0LPRg9GB0YInLCAn0YHQtdC/0YLQtdC80LHQsNGAJywgJ9C+0LrRgtC+0LHQsNGAJywgJ9C90L7QstC10LzQsdCw0YAnLCAn0LTQtdGG0LXQvNCx0LDRgCddLFxuICAgICAgICBtb250aHNTaG9ydDogWyfRmNCw0L0uJywgJ9GE0LXQsS4nLCAn0LzQsNGALicsICfQsNC/0YAuJywgJ9C80LDRmCcsICfRmNGD0L0nLCAn0ZjRg9C7JywgJ9Cw0LLQsy4nLCAn0YHQtdC/LicsICfQvtC60YIuJywgJ9C90L7Qsi4nLCAn0LTQtdGGLiddLFxuICAgICAgICB3ZWVrZGF5czogWyfQvdC10LTQtdGZ0LAnLCAn0L/QvtC90LXQtNC10ZnQsNC6JywgJ9GD0YLQvtGA0LDQuicsICfRgdGA0LXQtNCwJywgJ9GH0LXRgtCy0YDRgtCw0LonLCAn0L/QtdGC0LDQuicsICfRgdGD0LHQvtGC0LAnXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWyfQvdC10LQuJywgJ9C/0L7QvS4nLCAn0YPRgtC+LicsICfRgdGA0LUuJywgJ9GH0LXRgi4nLCAn0L/QtdGCLicsICfRgdGD0LEuJ10sXG4gICAgICAgIHdlZWtkYXlzTWluOiBbJ9C90LUnLCAn0L/QvicsICfRg9GCJywgJ9GB0YAnLCAn0YfQtScsICfQv9C1JywgJ9GB0YMnXSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IHtcbiAgICAgICAgICAgIExUOiAnSDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSDptbTpzcycsXG4gICAgICAgICAgICBMOiAnREQuIE1NLiBZWVlZJyxcbiAgICAgICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcbiAgICAgICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXI6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb0LTQsNC90LDRgSDRg10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vRgdGD0YLRgNCwINGDXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvQvdC10LTQtdGZ0YNdIFvRg10gTFQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvRgdGA0LXQtNGDXSBb0YNdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9GDXSBb0YHRg9Cx0L7RgtGDXSBb0YNdIExUJztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9GDXSBkZGRkIFvRg10gTFQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXN0RGF5ICA6ICdb0ZjRg9GH0LUg0YNdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0V2Vla0RheXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C1XSBb0L3QtdC00LXRmdC1XSBb0YNdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9C/0L7QvdC10LTQtdGZ0LrQsF0gW9GDXSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C+0LNdIFvRg9GC0L7RgNC60LBdIFvRg10gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQtV0gW9GB0YDQtdC00LVdIFvRg10gTFQnLFxuICAgICAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0YfQtdGC0LLRgNGC0LrQsF0gW9GDXSBMVCcsXG4gICAgICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C+0LNdIFvQv9C10YLQutCwXSBb0YNdIExUJyxcbiAgICAgICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70LVdIFvRgdGD0LHQvtGC0LVdIFvRg10gTFQnXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFdlZWtEYXlzW3RoaXMuZGF5KCldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfQt9CwICVzJyxcbiAgICAgICAgICAgIHBhc3QgICA6ICfQv9GA0LUgJXMnLFxuICAgICAgICAgICAgcyAgICAgIDogJ9C90LXQutC+0LvQuNC60L4g0YHQtdC60YPQvdC00LgnLFxuICAgICAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBtbSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcbiAgICAgICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICBkICAgICAgOiAn0LTQsNC9JyxcbiAgICAgICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxuICAgICAgICAgICAgTSAgICAgIDogJ9C80LXRgdC10YYnLFxuICAgICAgICAgICAgTU0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXG4gICAgICAgICAgICB5ICAgICAgOiAn0LPQvtC00LjQvdGDJyxcbiAgICAgICAgICAgIHl5ICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcbiAgICAgICAgb3JkaW5hbCA6ICclZC4nLFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzcl9jeXJsO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanNcbiAqKiBtb2R1bGUgaWQgPSAyODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogc3dlZGlzaCAoc3YpXG4vLyEgYXV0aG9yIDogSmVucyBBbG0gOiBodHRwczovL2dpdGh1Yi5jb20vdWxtdXNcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgc3YgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzdicsIHtcbiAgICAgICAgbW9udGhzIDogJ2phbnVhcmlfZmVicnVhcmlfbWFyc19hcHJpbF9tYWpfanVuaV9qdWxpX2F1Z3VzdGlfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWpfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdzw7ZuZGFnX23DpW5kYWdfdGlzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7ZyZGFnJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ3PDtm5fbcOlbl90aXNfb25zX3Rvcl9mcmVfbMO2cicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnc8O2X23DpV90aV9vbl90b19mcl9sw7YnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbSWRhZ10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tJbW9yZ29uXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0lnw6VyXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ1tQw6VdIGRkZGQgTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdbSV0gZGRkZFtzXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdvbSAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ2bDtnIgJXMgc2VkYW4nLFxuICAgICAgICAgICAgcyA6ICduw6VncmEgc2VrdW5kZXInLFxuICAgICAgICAgICAgbSA6ICdlbiBtaW51dCcsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dGVyJyxcbiAgICAgICAgICAgIGggOiAnZW4gdGltbWUnLFxuICAgICAgICAgICAgaGggOiAnJWQgdGltbWFyJyxcbiAgICAgICAgICAgIGQgOiAnZW4gZGFnJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGRhZ2FyJyxcbiAgICAgICAgICAgIE0gOiAnZW4gbcOlbmFkJyxcbiAgICAgICAgICAgIE1NIDogJyVkIG3DpW5hZGVyJyxcbiAgICAgICAgICAgIHkgOiAnZXR0IMOlcicsXG4gICAgICAgICAgICB5eSA6ICclZCDDpXInXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGV8YSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICdlJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ2EnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnYScgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdlJyA6ICdlJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN2O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3N2LmpzXG4gKiogbW9kdWxlIGlkID0gMjg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHRhbWlsICh0YSlcbi8vISBhdXRob3IgOiBBcmp1bmt1bWFyIEtyaXNobmFtb29ydGh5IDogaHR0cHM6Ly9naXRodWIuY29tL3RrMTIwNDA0XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRhID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGEnLCB7XG4gICAgICAgIG1vbnRocyA6ICfgrpzgrqngrrXgrrDgrr9f4K6q4K6/4K6q4K+N4K6w4K614K6w4K6/X+CuruCuvuCusOCvjeCumuCvjV/gro/grqrgr43grrDgrrLgr41f4K6u4K+HX+CunOCvguCuqeCvjV/grpzgr4LgrrLgr4hf4K6G4K6V4K644K+N4K6f4K+NX+CumuCvhuCuquCvjeCun+CvhuCuruCvjeCuquCusOCvjV/groXgrpXgr43grp/gr4fgrr7grqrgrrDgr41f4K6o4K614K6u4K+N4K6q4K6w4K+NX+Cun+Cuv+CumuCuruCvjeCuquCusOCvjScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4K6c4K6p4K614K6w4K6/X+CuquCuv+CuquCvjeCusOCuteCusOCuv1/grq7grr7grrDgr43grprgr41f4K6P4K6q4K+N4K6w4K6y4K+NX+CuruCvh1/grpzgr4Lgrqngr41f4K6c4K+C4K6y4K+IX+CuhuCuleCuuOCvjeCun+CvjV/grprgr4bgrqrgr43grp/gr4bgrq7gr43grqrgrrDgr41f4K6F4K6V4K+N4K6f4K+H4K6+4K6q4K6w4K+NX+CuqOCuteCuruCvjeCuquCusOCvjV/grp/grr/grprgrq7gr43grqrgrrDgr40nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+CunuCuvuCur+Cuv+CuseCvjeCuseCvgeCuleCvjeCuleCuv+CutOCuruCviF/grqTgrr/grpngr43grpXgrp/gr43grpXgrr/grrTgrq7gr4hf4K6a4K+G4K614K+N4K614K6+4K6v4K+N4K6V4K6/4K604K6u4K+IX+CuquCvgeCupOCuqeCvjeCuleCuv+CutOCuruCviF/grrXgrr/grq/grr7grrTgrpXgr43grpXgrr/grrTgrq7gr4hf4K614K+G4K6z4K+N4K6z4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IX+CumuCuqeCuv+CuleCvjeCuleCuv+CutOCuruCviCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfgrp7grr7grq/grr/grrHgr4Ff4K6k4K6/4K6Z4K+N4K6V4K6z4K+NX+CumuCvhuCuteCvjeCuteCuvuCur+CvjV/grqrgr4HgrqTgrqngr41f4K614K6/4K6v4K6+4K604K6p4K+NX+CuteCvhuCus+CvjeCus+Cuv1/grprgrqngrr8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+CunuCuvl/grqTgrr9f4K6a4K+GX+CuquCvgV/grrXgrr9f4K614K+GX+Cumicuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdb4K6H4K6p4K+N4K6x4K+BXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vgrqjgrr7grrPgr4hdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+CuqOCvh+CuseCvjeCuseCvgV0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW+CuleCun+CuqOCvjeCupCDgrrXgrr7grrDgrq7gr41dIGRkZGQsIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICclcyDgrofgrrLgr40nLFxuICAgICAgICAgICAgcGFzdCA6ICclcyDgrq7gr4Hgrqngr40nLFxuICAgICAgICAgICAgcyA6ICfgrpLgrrDgr4Eg4K6a4K6/4K6yIOCuteCuv+CuqOCuvuCun+Cuv+CuleCus+CvjScsXG4gICAgICAgICAgICBtIDogJ+CukuCusOCvgSDgrqjgrr/grq7grr/grp/grq7gr40nLFxuICAgICAgICAgICAgbW0gOiAnJWQg4K6o4K6/4K6u4K6/4K6f4K6Z4K+N4K6V4K6z4K+NJyxcbiAgICAgICAgICAgIGggOiAn4K6S4K6w4K+BIOCuruCuo+CuvyDgrqjgr4fgrrDgrq7gr40nLFxuICAgICAgICAgICAgaGggOiAnJWQg4K6u4K6j4K6/IOCuqOCvh+CusOCuruCvjScsXG4gICAgICAgICAgICBkIDogJ+CukuCusOCvgSDgrqjgrr7grrPgr40nLFxuICAgICAgICAgICAgZGQgOiAnJWQg4K6o4K6+4K6f4K+N4K6V4K6z4K+NJyxcbiAgICAgICAgICAgIE0gOiAn4K6S4K6w4K+BIOCuruCuvuCupOCuruCvjScsXG4gICAgICAgICAgICBNTSA6ICclZCDgrq7grr7grqTgrpngr43grpXgrrPgr40nLFxuICAgICAgICAgICAgeSA6ICfgrpLgrrDgr4Eg4K614K6w4K+B4K6f4K6u4K+NJyxcbiAgICAgICAgICAgIHl5IDogJyVkIOCuhuCuo+CvjeCun+CvgeCuleCus+CvjSdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn3grrXgrqTgr4EvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfgrrXgrqTgr4EnO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZWZlciBodHRwOi8vdGEud2lraXBlZGlhLm9yZy9zLzFlcjFcbiAgICAgICAgbWVyaWRpZW1QYXJzZTogL+Cur+CuvuCuruCuruCvjXzgrrXgr4jgrpXgrrHgr4h84K6V4K6+4K6y4K+IfOCuqOCuo+CvjeCuquCuleCusuCvjXzgro7grrHgr43grqrgrr7grp/gr4F84K6u4K6+4K6y4K+ILyxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyDgrq/grr7grq7grq7gr40nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgNikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnIOCuteCviOCuleCuseCviCc7ICAvLyDgrrXgr4jgrpXgrrHgr4hcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcg4K6V4K6+4K6y4K+IJzsgLy8g4K6V4K6+4K6y4K+IXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnIOCuqOCuo+CvjeCuquCuleCusuCvjSc7IC8vIOCuqOCuo+CvjeCuquCuleCusuCvjVxuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyDgro7grrHgr43grqrgrr7grp/gr4EnOyAvLyDgro7grrHgr43grqrgrr7grp/gr4FcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcg4K6u4K6+4K6y4K+IJzsgLy8g4K6u4K6+4K6y4K+IXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnIOCur+CuvuCuruCuruCvjSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgrq/grr7grq7grq7gr40nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCAyID8gaG91ciA6IGhvdXIgKyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgrrXgr4jgrpXgrrHgr4gnIHx8IG1lcmlkaWVtID09PSAn4K6V4K6+4K6y4K+IJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CuqOCuo+CvjeCuquCuleCusuCvjScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3RhLmpzXG4gKiogbW9kdWxlIGlkID0gMjg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHRoYWkgKHRoKVxuLy8hIGF1dGhvciA6IEtyaWRzYWRhIFRoYW5hYnVscG9uZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaXJuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRoID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGgnLCB7XG4gICAgICAgIG1vbnRocyA6ICfguKHguIHguKPguLLguITguKFf4LiB4Li44Lih4Lig4Liy4Lie4Lix4LiZ4LiY4LmMX+C4oeC4teC4meC4suC4hOC4oV/guYDguKHguKnguLLguKLguJlf4Lie4Lik4Lip4Lig4Liy4LiE4LihX+C4oeC4tOC4luC4uOC4meC4suC4ouC4mV/guIHguKPguIHguI7guLLguITguKFf4Liq4Li04LiH4Lir4Liy4LiE4LihX+C4geC4seC4meC4ouC4suC4ouC4mV/guJXguLjguKXguLLguITguKFf4Lie4Lik4Lio4LiI4Li04LiB4Liy4Lii4LiZX+C4mOC4seC4meC4p+C4suC4hOC4oScuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiAn4Lih4LiB4Lij4LiyX+C4geC4uOC4oeC4oOC4sl/guKHguLXguJnguLJf4LmA4Lih4Lip4LiyX+C4nuC4pOC4qeC4oOC4sl/guKHguLTguJbguLjguJnguLJf4LiB4Lij4LiB4LiO4LiyX+C4quC4tOC4h+C4q+C4sl/guIHguLHguJnguKLguLJf4LiV4Li44Lil4LiyX+C4nuC4pOC4qOC4iOC4tOC4geC4sl/guJjguLHguJnguKfguLInLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogJ+C4reC4suC4l+C4tOC4leC4ouC5jF/guIjguLHguJnguJfguKPguYxf4Lit4Lix4LiH4LiE4Liy4LijX+C4nuC4uOC4mF/guJ7guKTguKvguLHguKrguJrguJTguLVf4Lio4Li44LiB4Lij4LmMX+C5gOC4quC4suC4o+C5jCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfguK3guLLguJfguLTguJXguKLguYxf4LiI4Lix4LiZ4LiX4Lij4LmMX+C4reC4seC4h+C4hOC4suC4o1/guJ7guLjguJhf4Lie4Lik4Lir4Lix4LiqX+C4qOC4uOC4geC4o+C5jF/guYDguKrguLLguKPguYwnLnNwbGl0KCdfJyksIC8vIHllcywgdGhyZWUgY2hhcmFjdGVycyBkaWZmZXJlbmNlXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ+C4reC4si5f4LiILl/guK0uX+C4ni5f4Lie4LikLl/guKguX+C4qi4nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSCDguJnguLLguKzguLTguIHguLIgbSDguJnguLLguJfguLUnLFxuICAgICAgICAgICAgTFRTIDogJ0gg4LiZ4Liy4Lis4Li04LiB4LiyIG0g4LiZ4Liy4LiX4Li1IHMg4Lin4Li04LiZ4Liy4LiX4Li1JyxcbiAgICAgICAgICAgIEwgOiAnWVlZWS9NTS9ERCcsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg4LmA4Lin4Lil4LiyIEgg4LiZ4Liy4Lis4Li04LiB4LiyIG0g4LiZ4Liy4LiX4Li1JyxcbiAgICAgICAgICAgIExMTEwgOiAn4Lin4Lix4LiZZGRkZOC4l+C4teC5iCBEIE1NTU0gWVlZWSDguYDguKfguKXguLIgSCDguJnguLLguKzguLTguIHguLIgbSDguJnguLLguJfguLUnXG4gICAgICAgIH0sXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IC/guIHguYjguK3guJnguYDguJfguLXguYjguKLguId84Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfguKvguKXguLHguIfguYDguJfguLXguYjguKLguIcnO1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+C4geC5iOC4reC4meC5gOC4l+C4teC5iOC4ouC4hyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn4Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vguKfguLHguJnguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1vguJ7guKPguLjguYjguIfguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkW+C4q+C4meC5ieC4siDguYDguKfguKXguLJdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+C5gOC4oeC4t+C5iOC4reC4p+C4suC4meC4meC4teC5iSDguYDguKfguKXguLJdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vguKfguLHguJldZGRkZFvguJfguLXguYjguYHguKXguYnguKcg4LmA4Lin4Lil4LiyXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn4Lit4Li14LiBICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXPguJfguLXguYjguYHguKXguYnguKcnLFxuICAgICAgICAgICAgcyA6ICfguYTguKHguYjguIHguLXguYjguKfguLTguJnguLLguJfguLUnLFxuICAgICAgICAgICAgbSA6ICcxIOC4meC4suC4l+C4tScsXG4gICAgICAgICAgICBtbSA6ICclZCDguJnguLLguJfguLUnLFxuICAgICAgICAgICAgaCA6ICcxIOC4iuC4seC5iOC4p+C5guC4oeC4hycsXG4gICAgICAgICAgICBoaCA6ICclZCDguIrguLHguYjguKfguYLguKHguIcnLFxuICAgICAgICAgICAgZCA6ICcxIOC4p+C4seC4mScsXG4gICAgICAgICAgICBkZCA6ICclZCDguKfguLHguJknLFxuICAgICAgICAgICAgTSA6ICcxIOC5gOC4lOC4t+C4reC4mScsXG4gICAgICAgICAgICBNTSA6ICclZCDguYDguJTguLfguK3guJknLFxuICAgICAgICAgICAgeSA6ICcxIOC4m+C4tScsXG4gICAgICAgICAgICB5eSA6ICclZCDguJvguLUnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90aC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiBUYWdhbG9nL0ZpbGlwaW5vICh0bC1waClcbi8vISBhdXRob3IgOiBEYW4gSGFnbWFuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHRsX3BoID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGwtcGgnLCB7XG4gICAgICAgIG1vbnRocyA6ICdFbmVyb19QZWJyZXJvX01hcnNvX0FicmlsX01heW9fSHVueW9fSHVseW9fQWdvc3RvX1NldHllbWJyZV9Pa3R1YnJlX05vYnllbWJyZV9EaXN5ZW1icmUnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0VuZV9QZWJfTWFyX0Ficl9NYXlfSHVuX0h1bF9BZ29fU2V0X09rdF9Ob2JfRGlzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdMaW5nZ29fTHVuZXNfTWFydGVzX01peWVya3VsZXNfSHV3ZWJlc19CaXllcm5lc19TYWJhZG8nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnTGluX0x1bl9NYXJfTWl5X0h1d19CaXlfU2FiJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdMaV9MdV9NYV9NaV9IdV9CaV9TYWInLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnTU0vRC9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnTU1NTSBELCBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBERCwgWVlZWSBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiAnW05nYXlvbiBzYV0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1tCdWthcyBzYV0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtzYV0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1tLYWhhcG9uIHNhXSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW2h1bGluZyBsaW5nZ29dIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ3NhIGxvb2IgbmcgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICclcyBhbmcgbmFrYWxpcGFzJyxcbiAgICAgICAgICAgIHMgOiAnaWxhbmcgc2VndW5kbycsXG4gICAgICAgICAgICBtIDogJ2lzYW5nIG1pbnV0bycsXG4gICAgICAgICAgICBtbSA6ICclZCBtaW51dG8nLFxuICAgICAgICAgICAgaCA6ICdpc2FuZyBvcmFzJyxcbiAgICAgICAgICAgIGhoIDogJyVkIG9yYXMnLFxuICAgICAgICAgICAgZCA6ICdpc2FuZyBhcmF3JyxcbiAgICAgICAgICAgIGRkIDogJyVkIGFyYXcnLFxuICAgICAgICAgICAgTSA6ICdpc2FuZyBidXdhbicsXG4gICAgICAgICAgICBNTSA6ICclZCBidXdhbicsXG4gICAgICAgICAgICB5IDogJ2lzYW5nIHRhb24nLFxuICAgICAgICAgICAgeXkgOiAnJWQgdGFvbidcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGxfcGg7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdGwtcGguanNcbiAqKiBtb2R1bGUgaWQgPSAyODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogdHVya2lzaCAodHIpXG4vLyEgYXV0aG9ycyA6IEVyaGFuIEd1bmRvZ2FuIDogaHR0cHM6Ly9naXRodWIuY29tL2VyaGFuZ3VuZG9nYW4sXG4vLyEgICAgICAgICAgIEJ1cmFrIFlpxJ9pdCBLYXlhOiBodHRwczovL2dpdGh1Yi5jb20vQllLXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHN1ZmZpeGVzID0ge1xuICAgICAgICAxOiAnXFwnaW5jaScsXG4gICAgICAgIDU6ICdcXCdpbmNpJyxcbiAgICAgICAgODogJ1xcJ2luY2knLFxuICAgICAgICA3MDogJ1xcJ2luY2knLFxuICAgICAgICA4MDogJ1xcJ2luY2knLFxuICAgICAgICAyOiAnXFwnbmNpJyxcbiAgICAgICAgNzogJ1xcJ25jaScsXG4gICAgICAgIDIwOiAnXFwnbmNpJyxcbiAgICAgICAgNTA6ICdcXCduY2knLFxuICAgICAgICAzOiAnXFwnw7xuY8O8JyxcbiAgICAgICAgNDogJ1xcJ8O8bmPDvCcsXG4gICAgICAgIDEwMDogJ1xcJ8O8bmPDvCcsXG4gICAgICAgIDY6ICdcXCduY8SxJyxcbiAgICAgICAgOTogJ1xcJ3VuY3UnLFxuICAgICAgICAxMDogJ1xcJ3VuY3UnLFxuICAgICAgICAzMDogJ1xcJ3VuY3UnLFxuICAgICAgICA2MDogJ1xcJ8SxbmPEsScsXG4gICAgICAgIDkwOiAnXFwnxLFuY8SxJ1xuICAgIH07XG5cbiAgICB2YXIgdHIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0cicsIHtcbiAgICAgICAgbW9udGhzIDogJ09jYWtfxZ51YmF0X01hcnRfTmlzYW5fTWF5xLFzX0hhemlyYW5fVGVtbXV6X0HEn3VzdG9zX0V5bMO8bF9Fa2ltX0thc8SxbV9BcmFsxLFrJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdPY2FfxZ51Yl9NYXJfTmlzX01heV9IYXpfVGVtX0HEn3VfRXlsX0VraV9LYXNfQXJhJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdQYXphcl9QYXphcnRlc2lfU2FsxLFfw4dhcsWfYW1iYV9QZXLFn2VtYmVfQ3VtYV9DdW1hcnRlc2knLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnUGF6X1B0c19TYWxfw4dhcl9QZXJfQ3VtX0N0cycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAnUHpfUHRfU2Ffw4dhX1BlX0N1X0N0Jy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbYnVnw7xuIHNhYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW3lhcsSxbiBzYWF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdbaGFmdGF5YV0gZGRkZCBbc2FhdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbZMO8bl0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW2dlw6dlbiBoYWZ0YV0gZGRkZCBbc2FhdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIHNvbnJhJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgw7ZuY2UnLFxuICAgICAgICAgICAgcyA6ICdiaXJrYcOnIHNhbml5ZScsXG4gICAgICAgICAgICBtIDogJ2JpciBkYWtpa2EnLFxuICAgICAgICAgICAgbW0gOiAnJWQgZGFraWthJyxcbiAgICAgICAgICAgIGggOiAnYmlyIHNhYXQnLFxuICAgICAgICAgICAgaGggOiAnJWQgc2FhdCcsXG4gICAgICAgICAgICBkIDogJ2JpciBnw7xuJyxcbiAgICAgICAgICAgIGRkIDogJyVkIGfDvG4nLFxuICAgICAgICAgICAgTSA6ICdiaXIgYXknLFxuICAgICAgICAgICAgTU0gOiAnJWQgYXknLFxuICAgICAgICAgICAgeSA6ICdiaXIgecSxbCcsXG4gICAgICAgICAgICB5eSA6ICclZCB5xLFsJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfScoaW5jaXxuY2l8w7xuY8O8fG5jxLF8dW5jdXzEsW5jxLEpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDApIHsgIC8vIHNwZWNpYWwgY2FzZSBmb3IgemVyb1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnXFwnxLFuY8SxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXG4gICAgICAgICAgICAgICAgYyA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSB8fCBzdWZmaXhlc1tjXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3RyLmpzXG4gKiogbW9kdWxlIGlkID0gMjg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHRhbG9zc2FuICh0emwpXG4vLyEgYXV0aG9yIDogUm9iaW4gdmFuIGRlciBWbGlldCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yb2JpbjB2YW4wZGVyMHYgd2l0aCB0aGUgaGVscCBvZiBJdXN0w6wgQ2FudW5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cblxuICAgIHZhciB0emwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0emwnLCB7XG4gICAgICAgIG1vbnRocyA6ICdKYW51YXJfRmV2cmFnbGhfTWFyw6dfQXZyw691X01haV9Hw7xuX0p1bGlhX0d1c2NodF9TZXRlbXZhcl9MaXN0b3DDpHRzX05vZW12YXJfWmVjZW12YXInLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZXZfTWFyX0F2cl9NYWlfR8O8bl9KdWxfR3VzX1NldF9MaXNfTm9lX1plYycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnU8O6bGFkaV9Mw7puZcOnaV9NYWl0emlfTcOhcmN1cmlfWGjDumFkaV9WacOpbmVyw6dpX1PDoXR1cmknLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAnU8O6bF9Mw7puX01haV9Nw6FyX1how7pfVmnDqV9Tw6F0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdTw7pfTMO6X01hX03DoV9YaF9WaV9Tw6EnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEgubW0nLFxuICAgICAgICAgICAgTFRTIDogJ0xULnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQuTU0uWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdELiBNTU1NIFtkYWxsYXNdIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ0QuIE1NTU0gW2RhbGxhc10gWVlZWSBMVCcsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIFtsaV0gRC4gTU1NTSBbZGFsbGFzXSBZWVlZIExUJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdkXFwnbycgOiAnRFxcJ08nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdkXFwnYScgOiAnRFxcJ0EnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW294aGkgw6BdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW2RlbcOgIMOgXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbaWVpcmkgw6BdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tzw7xyIGVsXSBkZGRkIFtsYXN0ZXUgw6BdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdvc3ByZWkgJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICdqYSVzJyxcbiAgICAgICAgICAgIHMgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBtbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGhoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgZGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxuICAgICAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXG4gICAgICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcbiAgICAgICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXG4gICAgICAgIG9yZGluYWwgOiAnJWQuJyxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0ge1xuICAgICAgICAgICAgJ3MnOiBbJ3ZpZW5zYXMgc2VjdW5kcycsICdcXCdpZW5zYXMgc2VjdW5kcyddLFxuICAgICAgICAgICAgJ20nOiBbJ1xcJ24gbcOtdXQnLCAnXFwnaWVucyBtw611dCddLFxuICAgICAgICAgICAgJ21tJzogW251bWJlciArICcgbcOtdXRzJywgJyAnICsgbnVtYmVyICsgJyBtw611dHMnXSxcbiAgICAgICAgICAgICdoJzogWydcXCduIMO+b3JhJywgJ1xcJ2llbnNhIMO+b3JhJ10sXG4gICAgICAgICAgICAnaGgnOiBbbnVtYmVyICsgJyDDvm9yYXMnLCAnICcgKyBudW1iZXIgKyAnIMO+b3JhcyddLFxuICAgICAgICAgICAgJ2QnOiBbJ1xcJ24geml1YScsICdcXCdpZW5zYSB6aXVhJ10sXG4gICAgICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyB6aXVhcycsICcgJyArIG51bWJlciArICcgeml1YXMnXSxcbiAgICAgICAgICAgICdNJzogWydcXCduIG1lcycsICdcXCdpZW5zIG1lcyddLFxuICAgICAgICAgICAgJ01NJzogW251bWJlciArICcgbWVzZW4nLCAnICcgKyBudW1iZXIgKyAnIG1lc2VuJ10sXG4gICAgICAgICAgICAneSc6IFsnXFwnbiBhcicsICdcXCdpZW5zIGFyJ10sXG4gICAgICAgICAgICAneXknOiBbbnVtYmVyICsgJyBhcnMnLCAnICcgKyBudW1iZXIgKyAnIGFycyddXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0Z1dHVyZSA/IGZvcm1hdFtrZXldWzBdIDogKHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdLnRyaW0oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR6bDtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS90emwuanNcbiAqKiBtb2R1bGUgaWQgPSAyODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogTW9yb2NjbyBDZW50cmFsIEF0bGFzIFRhbWF6acmjdCAodHptKVxuLy8hIGF1dGhvciA6IEFiZGVsIFNhaWQgOiBodHRwczovL2dpdGh1Yi5jb20vYWJkZWxzYWlkXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHR6bSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3R6bScsIHtcbiAgICAgICAgbW9udGhzIDogJ+K1ieK1j+K1j+K0sOK1ouK1lF/itLHitZXitLDitaLitZVf4rWO4rSw4rWV4rWaX+K1ieK0seK1lOK1ieK1lF/itY7itLDitaLitaLitZNf4rWi4rWT4rWP4rWi4rWTX+K1ouK1k+K1jeK1ouK1k+K1o1/itZbitZPitZvitZxf4rWb4rWT4rWc4rSw4rWP4rSx4rWJ4rWUX+K0veK1n+K1k+K0seK1lV/itY/itZPitaHitLDitY/itLHitYnitZRf4rS34rWT4rWK4rWP4rSx4rWJ4rWUJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICfitYnitY/itY/itLDitaLitZRf4rSx4rWV4rSw4rWi4rWVX+K1juK0sOK1leK1ml/itYnitLHitZTitYnitZRf4rWO4rSw4rWi4rWi4rWTX+K1ouK1k+K1j+K1ouK1k1/itaLitZPitY3itaLitZPitaNf4rWW4rWT4rWb4rWcX+K1m+K1k+K1nOK0sOK1j+K0seK1ieK1lF/itL3itZ/itZPitLHitZVf4rWP4rWT4rWh4rSw4rWP4rSx4rWJ4rWUX+K0t+K1k+K1iuK1j+K0seK1ieK1lCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn4rSw4rWZ4rSw4rWO4rSw4rWZX+K0sOK1ouK1j+K0sOK1mV/itLDitZnitYnitY/itLDitZlf4rSw4rS94rWU4rSw4rWZX+K0sOK0veK1oeK0sOK1mV/itLDitZnitYnitY7itaHitLDitZlf4rSw4rWZ4rWJ4rS54rWi4rSw4rWZJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+K0sOK1meK0sOK1juK0sOK1mV/itLDitaLitY/itLDitZlf4rSw4rWZ4rWJ4rWP4rSw4rWZX+K0sOK0veK1lOK0sOK1mV/itLDitL3itaHitLDitZlf4rSw4rWZ4rWJ4rWO4rWh4rSw4rWZX+K0sOK1meK1ieK0ueK1ouK0sOK1mScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn4rSw4rWZ4rSw4rWO4rSw4rWZX+K0sOK1ouK1j+K0sOK1mV/itLDitZnitYnitY/itLDitZlf4rSw4rS94rWU4rSw4rWZX+K0sOK0veK1oeK0sOK1mV/itLDitZnitYnitY7itaHitLDitZlf4rSw4rWZ4rWJ4rS54rWi4rSw4rWZJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUzogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdb4rSw4rWZ4rS34rWFIOK0tF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1vitLDitZnitL3itLAg4rS0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW+K0tF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1vitLDitZritLDitY/itZwg4rS0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlazogJ2RkZGQgW+K0tF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn4rS34rSw4rS34rWFIOK1mSDitaLitLDitY8gJXMnLFxuICAgICAgICAgICAgcGFzdCA6ICfitaLitLDitY8gJXMnLFxuICAgICAgICAgICAgcyA6ICfitYnitY7itYnitL0nLFxuICAgICAgICAgICAgbSA6ICfitY7itYnitY/itZPitLonLFxuICAgICAgICAgICAgbW0gOiAnJWQg4rWO4rWJ4rWP4rWT4rS6JyxcbiAgICAgICAgICAgIGggOiAn4rWZ4rSw4rWE4rSwJyxcbiAgICAgICAgICAgIGhoIDogJyVkIOK1nOK0sOK1meK1meK0sOK1hOK1ieK1jycsXG4gICAgICAgICAgICBkIDogJ+K0sOK1meK1mScsXG4gICAgICAgICAgICBkZCA6ICclZCBv4rWZ4rWZ4rSw4rWPJyxcbiAgICAgICAgICAgIE0gOiAn4rSw4rWib+K1k+K1lCcsXG4gICAgICAgICAgICBNTSA6ICclZCDitYnitaLitaLitYnitZTitY8nLFxuICAgICAgICAgICAgeSA6ICfitLDitZnitLPitLDitZknLFxuICAgICAgICAgICAgeXkgOiAnJWQg4rWJ4rWZ4rSz4rSw4rWZ4rWPJ1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0em07XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdHptLmpzXG4gKiogbW9kdWxlIGlkID0gMjkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IE1vcm9jY28gQ2VudHJhbCBBdGxhcyBUYW1hemnJo3QgaW4gTGF0aW4gKHR6bS1sYXRuKVxuLy8hIGF1dGhvciA6IEFiZGVsIFNhaWQgOiBodHRwczovL2dpdGh1Yi5jb20vYWJkZWxzYWlkXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHR6bV9sYXRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgndHptLWxhdG4nLCB7XG4gICAgICAgIG1vbnRocyA6ICdpbm5heXJfYnLLpGF5csukX21hcsukc8ukX2licmlyX21heXl3X3l3bnl3X3l3bHl3el/Jo3fFoXRfxaF3dGFuYmlyX2t0y6R3YnLLpF9ud3dhbmJpcl9kd2puYmlyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdpbm5heXJfYnLLpGF5csukX21hcsukc8ukX2licmlyX21heXl3X3l3bnl3X3l3bHl3el/Jo3fFoXRfxaF3dGFuYmlyX2t0y6R3YnLLpF9ud3dhbmJpcl9kd2puYmlyJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICdhc2FtYXNfYXluYXNfYXNpbmFzX2FrcmFzX2Frd2FzX2FzaW13YXNfYXNp4biNeWFzJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ2FzYW1hc19heW5hc19hc2luYXNfYWtyYXNfYWt3YXNfYXNpbXdhc19hc2nhuI15YXMnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ2FzYW1hc19heW5hc19hc2luYXNfYWtyYXNfYWt3YXNfYXNpbXdhc19hc2nhuI15YXMnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXk6ICdbYXNka2ggZ10gTFQnLFxuICAgICAgICAgICAgbmV4dERheTogJ1thc2thIGddIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrOiAnZGRkZCBbZ10gTFQnLFxuICAgICAgICAgICAgbGFzdERheTogJ1thc3NhbnQgZ10gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFtnXSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZTogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICdkYWRraCBzIHlhbiAlcycsXG4gICAgICAgICAgICBwYXN0IDogJ3lhbiAlcycsXG4gICAgICAgICAgICBzIDogJ2ltaWsnLFxuICAgICAgICAgICAgbSA6ICdtaW514biNJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnXhuI0nLFxuICAgICAgICAgICAgaCA6ICdzYcmbYScsXG4gICAgICAgICAgICBoaCA6ICclZCB0YXNzYcmbaW4nLFxuICAgICAgICAgICAgZCA6ICdhc3MnLFxuICAgICAgICAgICAgZGQgOiAnJWQgb3NzYW4nLFxuICAgICAgICAgICAgTSA6ICdheW93cicsXG4gICAgICAgICAgICBNTSA6ICclZCBpeXlpcm4nLFxuICAgICAgICAgICAgeSA6ICdhc2dhcycsXG4gICAgICAgICAgICB5eSA6ICclZCBpc2dhc24nXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHR6bV9sYXRuO1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3R6bS1sYXRuLmpzXG4gKiogbW9kdWxlIGlkID0gMjkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8hIGxvY2FsZSA6IHVrcmFpbmlhbiAodWspXG4vLyEgYXV0aG9yIDogemVtbGFuaW4gOiBodHRwczovL2dpdGh1Yi5jb20vemVtbGFuaW5cbi8vISBBdXRob3IgOiBNZW5lbGlvbiBFbGVuc8O6bGUgOiBodHRwczovL2dpdGh1Yi5jb20vT2lyZVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIGZ1bmN0aW9uIHBsdXJhbCh3b3JkLCBudW0pIHtcbiAgICAgICAgdmFyIGZvcm1zID0gd29yZC5zcGxpdCgnXycpO1xuICAgICAgICByZXR1cm4gbnVtICUgMTAgPT09IDEgJiYgbnVtICUgMTAwICE9PSAxMSA/IGZvcm1zWzBdIDogKG51bSAlIDEwID49IDIgJiYgbnVtICUgMTAgPD0gNCAmJiAobnVtICUgMTAwIDwgMTAgfHwgbnVtICUgMTAwID49IDIwKSA/IGZvcm1zWzFdIDogZm9ybXNbMl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB7XG4gICAgICAgICAgICAnbW0nOiAn0YXQstC40LvQuNC90LBf0YXQstC40LvQuNC90Lhf0YXQstC40LvQuNC9JyxcbiAgICAgICAgICAgICdoaCc6ICfQs9C+0LTQuNC90LBf0LPQvtC00LjQvdC4X9Cz0L7QtNC40L0nLFxuICAgICAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rll/QtNC90ZbQsicsXG4gICAgICAgICAgICAnTU0nOiAn0LzRltGB0Y/RhtGMX9C80ZbRgdGP0YbRll/QvNGW0YHRj9GG0ZbQsicsXG4gICAgICAgICAgICAneXknOiAn0YDRltC6X9GA0L7QutC4X9GA0L7QutGW0LInXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgPT09ICdtJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0YXQstC40LvQuNC90LAnIDogJ9GF0LLQuNC70LjQvdGDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdoJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LPQvtC00LjQvdCwJyA6ICfQs9C+0LTQuNC90YMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHBsdXJhbChmb3JtYXRba2V5XSwgK251bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW9udGhzQ2FzZVJlcGxhY2UobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBtb250aHMgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfRgdGW0YfQtdC90Yxf0LvRjtGC0LjQuV/QsdC10YDQtdC30LXQvdGMX9C60LLRltGC0LXQvdGMX9GC0YDQsNCy0LXQvdGMX9GH0LXRgNCy0LXQvdGMX9C70LjQv9C10L3RjF/RgdC10YDQv9C10L3RjF/QstC10YDQtdGB0LXQvdGMX9C20L7QstGC0LXQvdGMX9C70LjRgdGC0L7Qv9Cw0LRf0LPRgNGD0LTQtdC90YwnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICfRgdGW0YfQvdGPX9C70Y7RgtC+0LPQvl/QsdC10YDQtdC30L3Rj1/QutCy0ZbRgtC90Y9f0YLRgNCw0LLQvdGPX9GH0LXRgNCy0L3Rj1/Qu9C40L/QvdGPX9GB0LXRgNC/0L3Rj1/QstC10YDQtdGB0L3Rj1/QttC+0LLRgtC90Y9f0LvQuNGB0YLQvtC/0LDQtNCwX9Cz0YDRg9C00L3Rjycuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBub3VuQ2FzZSA9ICgvRFtvRF0/ICpNTU1NPy8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAnYWNjdXNhdGl2ZScgOlxuICAgICAgICAgICAgJ25vbWluYXRpdmUnO1xuICAgICAgICByZXR1cm4gbW9udGhzW25vdW5DYXNlXVttLm1vbnRoKCldO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSB7XG4gICAgICAgICAgICAnbm9taW5hdGl2ZSc6ICfQvdC10LTRltC70Y9f0L/QvtC90LXQtNGW0LvQvtC6X9Cy0ZbQstGC0L7RgNC+0Lpf0YHQtdGA0LXQtNCwX9GH0LXRgtCy0LXRgF/Qv+KAmdGP0YLQvdC40YbRj1/RgdGD0LHQvtGC0LAnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnYWNjdXNhdGl2ZSc6ICfQvdC10LTRltC70Y5f0L/QvtC90LXQtNGW0LvQvtC6X9Cy0ZbQstGC0L7RgNC+0Lpf0YHQtdGA0LXQtNGDX9GH0LXRgtCy0LXRgF/Qv+KAmdGP0YLQvdC40YbRjl/RgdGD0LHQvtGC0YMnLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAnZ2VuaXRpdmUnOiAn0L3QtdC00ZbQu9GWX9C/0L7QvdC10LTRltC70LrQsF/QstGW0LLRgtC+0YDQutCwX9GB0LXRgNC10LTQuF/Rh9C10YLQstC10YDQs9CwX9C/4oCZ0Y/RgtC90LjRhtGWX9GB0YPQsdC+0YLQuCcuc3BsaXQoJ18nKVxuICAgICAgICB9LFxuICAgICAgICBub3VuQ2FzZSA9ICgvKFxcW1vQktCy0KPRg11cXF0pID9kZGRkLykudGVzdChmb3JtYXQpID9cbiAgICAgICAgICAgICdhY2N1c2F0aXZlJyA6XG4gICAgICAgICAgICAoKC9cXFs/KD860LzQuNC90YPQu9C+0Zd80L3QsNGB0YLRg9C/0L3QvtGXKT8gP1xcXSA/ZGRkZC8pLnRlc3QoZm9ybWF0KSA/XG4gICAgICAgICAgICAgICAgJ2dlbml0aXZlJyA6XG4gICAgICAgICAgICAgICAgJ25vbWluYXRpdmUnKTtcbiAgICAgICAgcmV0dXJuIHdlZWtkYXlzW25vdW5DYXNlXVttLmRheSgpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0hvdXJzRnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJ9C+JyArICh0aGlzLmhvdXJzKCkgPT09IDExID8gJ9CxJyA6ICcnKSArICddIExUJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdWsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd1aycsIHtcbiAgICAgICAgbW9udGhzIDogbW9udGhzQ2FzZVJlcGxhY2UsXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GB0ZbRh1/Qu9GO0YJf0LHQtdGAX9C60LLRltGCX9GC0YDQsNCyX9GH0LXRgNCyX9C70LjQv1/RgdC10YDQv1/QstC10YBf0LbQvtCy0YJf0LvQuNGB0YJf0LPRgNGD0LQnLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzIDogd2Vla2RheXNDYXNlUmVwbGFjZSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgICAgIExUUyA6ICdISDptbTpzcycsXG4gICAgICAgICAgICBMIDogJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVkg0YAuJyxcbiAgICAgICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDRgC4sIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkg0YAuLCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9Ch0YzQvtCz0L7QtNC90ZYgJyksXG4gICAgICAgICAgICBuZXh0RGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CX0LDQstGC0YDQsCAnKSxcbiAgICAgICAgICAgIGxhc3REYXk6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JLRh9C+0YDQsCAnKSxcbiAgICAgICAgICAgIG5leHRXZWVrOiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CjXSBkZGRkIFsnKSxcbiAgICAgICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0hvdXJzRnVuY3Rpb24oJ1vQnNC40L3Rg9C70L7Rl10gZGRkZCBbJykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JzQuNC90YPQu9C+0LPQvl0gZGRkZCBbJykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FtZUVsc2U6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAn0LfQsCAlcycsXG4gICAgICAgICAgICBwYXN0IDogJyVzINGC0L7QvNGDJyxcbiAgICAgICAgICAgIHMgOiAn0LTQtdC60ZbQu9GM0LrQsCDRgdC10LrRg9C90LQnLFxuICAgICAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBoIDogJ9Cz0L7QtNC40L3RgycsXG4gICAgICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXG4gICAgICAgICAgICBkIDogJ9C00LXQvdGMJyxcbiAgICAgICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIE0gOiAn0LzRltGB0Y/RhtGMJyxcbiAgICAgICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcbiAgICAgICAgICAgIHkgOiAn0YDRltC6JyxcbiAgICAgICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxuICAgICAgICB9LFxuICAgICAgICAvLyBNLiBFLjogdGhvc2UgdHdvIGFyZSB2aXJ0dWFsbHkgdW51c2VkIGJ1dCBhIHVzZXIgbWlnaHQgd2FudCB0byBpbXBsZW1lbnQgdGhlbSBmb3IgaGlzL2hlciB3ZWJzaXRlIGZvciBzb21lIHJlYXNvblxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0ZZ80YDQsNC90LrRg3zQtNC90Y980LLQtdGH0L7RgNCwLyxcbiAgICAgICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C+0YDQsCkkLy50ZXN0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9GWJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfRgNCw0L3QutGDJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfQtNC90Y8nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9Cy0LXRh9C+0YDQsCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjQuXzQs9C+KS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QuSc7XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Qs9C+JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdWs7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdWsuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogdXpiZWsgKHV6KVxuLy8hIGF1dGhvciA6IFNhcmRvciBNdW1pbm92IDogaHR0cHM6Ly9naXRodWIuY29tL211bWlub2ZmXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydtb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHV6ID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXonLCB7XG4gICAgICAgIG1vbnRocyA6ICfRj9C90LLQsNGA0Yxf0YTQtdCy0YDQsNC70Yxf0LzQsNGA0YJf0LDQv9GA0LXQu9GMX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YDRjF/QvtC60YLRj9Cx0YDRjF/QvdC+0Y/QsdGA0Yxf0LTQtdC60LDQsdGA0YwnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJ9GP0L3Qsl/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Llf0LjRjtC9X9C40Y7Qu1/QsNCy0LNf0YHQtdC9X9C+0LrRgl/QvdC+0Y9f0LTQtdC6Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfQr9C60YjQsNC90LHQsF/QlNGD0YjQsNC90LHQsF/QodC10YjQsNC90LHQsF/Qp9C+0YDRiNCw0L3QsdCwX9Cf0LDQudGI0LDQvdCx0LBf0JbRg9C80LBf0KjQsNC90LHQsCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6ICfQr9C60Yhf0JTRg9GIX9Ch0LXRiF/Qp9C+0YBf0J/QsNC5X9CW0YPQvF/QqNCw0L0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzTWluIDogJ9Cv0Lpf0JTRg1/QodC1X9Cn0L5f0J/QsF/QltGDX9Co0LAnLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnSEg6bW0nLFxuICAgICAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgICAgIEwgOiAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgTExMTCA6ICdEIE1NTU0gWVlZWSwgZGRkZCBISDptbSdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vQkdGD0LPRg9C9INGB0L7QsNGCXSBMVCBb0LTQsF0nLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb0K3RgNGC0LDQs9CwXSBMVCBb0LTQsF0nLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0LrRg9C90Lgg0YHQvtCw0YJdIExUIFvQtNCwXScsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YfQsCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1vQo9GC0LPQsNC9XSBkZGRkIFvQutGD0L3QuCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6ICfQr9C60LjQvSAlcyDQuNGH0LjQtNCwJyxcbiAgICAgICAgICAgIHBhc3QgOiAn0JHQuNGAINC90LXRh9CwICVzINC+0LvQtNC40L0nLFxuICAgICAgICAgICAgcyA6ICfRhNGD0YDRgdCw0YInLFxuICAgICAgICAgICAgbSA6ICfQsdC40YAg0LTQsNC60LjQutCwJyxcbiAgICAgICAgICAgIG1tIDogJyVkINC00LDQutC40LrQsCcsXG4gICAgICAgICAgICBoIDogJ9Cx0LjRgCDRgdC+0LDRgicsXG4gICAgICAgICAgICBoaCA6ICclZCDRgdC+0LDRgicsXG4gICAgICAgICAgICBkIDogJ9Cx0LjRgCDQutGD0L0nLFxuICAgICAgICAgICAgZGQgOiAnJWQg0LrRg9C9JyxcbiAgICAgICAgICAgIE0gOiAn0LHQuNGAINC+0LknLFxuICAgICAgICAgICAgTU0gOiAnJWQg0L7QuScsXG4gICAgICAgICAgICB5IDogJ9Cx0LjRgCDQudC40LsnLFxuICAgICAgICAgICAgeXkgOiAnJWQg0LnQuNC7J1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrIDoge1xuICAgICAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB1ejtcblxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vbW9tZW50L2xvY2FsZS91ei5qc1xuICoqIG1vZHVsZSBpZCA9IDI5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgM1xuICoqLyIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vISBsb2NhbGUgOiB2aWV0bmFtZXNlICh2aSlcbi8vISBhdXRob3IgOiBCYW5nIE5ndXllbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYW5nbmtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgdmkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd2aScsIHtcbiAgICAgICAgbW9udGhzIDogJ3Row6FuZyAxX3Row6FuZyAyX3Row6FuZyAzX3Row6FuZyA0X3Row6FuZyA1X3Row6FuZyA2X3Row6FuZyA3X3Row6FuZyA4X3Row6FuZyA5X3Row6FuZyAxMF90aMOhbmcgMTFfdGjDoW5nIDEyJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICdUaDAxX1RoMDJfVGgwM19UaDA0X1RoMDVfVGgwNl9UaDA3X1RoMDhfVGgwOV9UaDEwX1RoMTFfVGgxMicuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAnY2jhu6cgbmjhuq10X3Ro4bupIGhhaV90aOG7qSBiYV90aOG7qSB0xrBfdGjhu6kgbsSDbV90aOG7qSBzw6F1X3Ro4bupIGLhuqN5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ0NOX1QyX1QzX1Q0X1Q1X1Q2X1Q3Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICdDTl9UMl9UM19UNF9UNV9UNl9UNycuc3BsaXQoJ18nKSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgICAgICBMVCA6ICdISDptbScsXG4gICAgICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxuICAgICAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgICAgIExMIDogJ0QgTU1NTSBbbsSDbV0gWVlZWScsXG4gICAgICAgICAgICBMTEwgOiAnRCBNTU1NIFtuxINtXSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFtuxINtXSBZWVlZIEhIOm1tJyxcbiAgICAgICAgICAgIGwgOiAnREQvTS9ZWVlZJyxcbiAgICAgICAgICAgIGxsIDogJ0QgTU1NIFlZWVknLFxuICAgICAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICAgICAgbGxsbCA6ICdkZGQsIEQgTU1NIFlZWVkgSEg6bW0nXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheTogJ1tIw7RtIG5heSBsw7pjXSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5OiAnW05nw6B5IG1haSBsw7pjXSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3R14bqnbiB04bubaSBsw7pjXSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5OiAnW0jDtG0gcXVhIGzDumNdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbdHXhuqduIHLhu5NpIGzDumNdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJyVzIHThu5tpJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgdHLGsOG7m2MnLFxuICAgICAgICAgICAgcyA6ICd2w6BpIGdpw6J5JyxcbiAgICAgICAgICAgIG0gOiAnbeG7mXQgcGjDunQnLFxuICAgICAgICAgICAgbW0gOiAnJWQgcGjDunQnLFxuICAgICAgICAgICAgaCA6ICdt4buZdCBnaeG7nScsXG4gICAgICAgICAgICBoaCA6ICclZCBnaeG7nScsXG4gICAgICAgICAgICBkIDogJ23hu5l0IG5nw6B5JyxcbiAgICAgICAgICAgIGRkIDogJyVkIG5nw6B5JyxcbiAgICAgICAgICAgIE0gOiAnbeG7mXQgdGjDoW5nJyxcbiAgICAgICAgICAgIE1NIDogJyVkIHRow6FuZycsXG4gICAgICAgICAgICB5IDogJ23hu5l0IG7Eg20nLFxuICAgICAgICAgICAgeXkgOiAnJWQgbsSDbSdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmk7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvdmkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogY2hpbmVzZSAoemgtY24pXG4vLyEgYXV0aG9yIDogc3V1cGljIDogaHR0cHM6Ly9naXRodWIuY29tL3N1dXBpY1xuLy8hIGF1dGhvciA6IFplbm8gWmVuZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5vemVuZ1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnbW9tZW50J10sIGZhY3RvcnkpIDpcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6aF9jbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3poLWNuJywge1xuICAgICAgICBtb250aHMgOiAn5LiA5pyIX+S6jOaciF/kuInmnIhf5Zub5pyIX+S6lOaciF/lha3mnIhf5LiD5pyIX+WFq+aciF/kuZ3mnIhf5Y2B5pyIX+WNgeS4gOaciF/ljYHkuozmnIgnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiAn5ZGo5pelX+WRqOS4gF/lkajkuoxf5ZGo5LiJX+WRqOWbm1/lkajkupRf5ZGo5YWtJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5LiAX+S6jF/kuIlf5ZubX+S6lF/lha0nLnNwbGl0KCdfJyksXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiAnQWjngrltbeWIhicsXG4gICAgICAgICAgICBMVFMgOiAnQWjngrlt5YiGc+enkicsXG4gICAgICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxuICAgICAgICAgICAgTEwgOiAnWVlZWeW5tE1NTUTml6UnLFxuICAgICAgICAgICAgTExMIDogJ1lZWVnlubRNTU1E5pelQWjngrltbeWIhicsXG4gICAgICAgICAgICBMTExMIDogJ1lZWVnlubRNTU1E5pelZGRkZEFo54K5bW3liIYnLFxuICAgICAgICAgICAgbCA6ICdZWVlZLU1NLUREJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVnlubRNTU1E5pelJyxcbiAgICAgICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpUFo54K5bW3liIYnLFxuICAgICAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGRBaOeCuW1t5YiGJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv5YeM5pmofOaXqeS4inzkuIrljYh85Lit5Y2IfOS4i+WNiHzmmZrkuIovLFxuICAgICAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICflh4zmmagnIHx8IG1lcmlkaWVtID09PSAn5pep5LiKJyB8fFxuICAgICAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+S4iuWNiCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuIvljYgnIHx8IG1lcmlkaWVtID09PSAn5pma5LiKJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICfkuK3ljYgnXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XG4gICAgICAgICAgICBpZiAoaG0gPCA2MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+WHjOaZqCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgOTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+S4iuWNiCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5Lit5Y2IJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxODAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aZmuS4iic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taW51dGVzKCkgPT09IDAgPyAnW+S7iuWkqV1BaFvngrnmlbRdJyA6ICdb5LuK5aSpXUxUJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0RGF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKSA9PT0gMCA/ICdb5piO5aSpXUFoW+eCueaVtF0nIDogJ1vmmI7lpKldTFQnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpID09PSAwID8gJ1vmmKjlpKldQWhb54K55pW0XScgOiAnW+aYqOWkqV1MVCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrLCBwcmVmaXg7XG4gICAgICAgICAgICAgICAgc3RhcnRPZldlZWsgPSBtb21lbnQoKS5zdGFydE9mKCd3ZWVrJyk7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy51bml4KCkgLSBzdGFydE9mV2Vlay51bml4KCkgPj0gNyAqIDI0ICogMzYwMCA/ICdb5LiLXScgOiAnW+acrF0nO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKSA9PT0gMCA/IHByZWZpeCArICdkZGRBaOeCueaVtCcgOiBwcmVmaXggKyAnZGRkQWjngrltbSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrLCBwcmVmaXg7XG4gICAgICAgICAgICAgICAgc3RhcnRPZldlZWsgPSBtb21lbnQoKS5zdGFydE9mKCd3ZWVrJyk7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy51bml4KCkgPCBzdGFydE9mV2Vlay51bml4KCkgID8gJ1vkuIpdJyA6ICdb5pysXSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpID09PSAwID8gcHJlZml4ICsgJ2RkZEFo54K55pW0JyA6IHByZWZpeCArICdkZGRBaOeCuW1tJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMTCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0o5pelfOaciHzlkagpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pelJztcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pyIJztcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICflkagnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXPlhoUnLFxuICAgICAgICAgICAgcGFzdCA6ICclc+WJjScsXG4gICAgICAgICAgICBzIDogJ+WHoOenkicsXG4gICAgICAgICAgICBtIDogJzEg5YiG6ZKfJyxcbiAgICAgICAgICAgIG1tIDogJyVkIOWIhumSnycsXG4gICAgICAgICAgICBoIDogJzEg5bCP5pe2JyxcbiAgICAgICAgICAgIGhoIDogJyVkIOWwj+aXticsXG4gICAgICAgICAgICBkIDogJzEg5aSpJyxcbiAgICAgICAgICAgIGRkIDogJyVkIOWkqScsXG4gICAgICAgICAgICBNIDogJzEg5Liq5pyIJyxcbiAgICAgICAgICAgIE1NIDogJyVkIOS4quaciCcsXG4gICAgICAgICAgICB5IDogJzEg5bm0JyxcbiAgICAgICAgICAgIHl5IDogJyVkIOW5tCdcbiAgICAgICAgfSxcbiAgICAgICAgd2VlayA6IHtcbiAgICAgICAgICAgIC8vIEdCL1QgNzQwOC0xOTk044CK5pWw5o2u5YWD5ZKM5Lqk5o2i5qC85byPwrfkv6Hmga/kuqTmjaLCt+aXpeacn+WSjOaXtumXtOihqOekuuazleOAi+S4jklTTyA4NjAxOjE5ODjnrYnmlYhcbiAgICAgICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gemhfY247XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L21vbWVudC9sb2NhbGUvemgtY24uanNcbiAqKiBtb2R1bGUgaWQgPSAyOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMSAyIDNcbiAqKi8iLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogdHJhZGl0aW9uYWwgY2hpbmVzZSAoemgtdHcpXG4vLyEgYXV0aG9yIDogQmVuIDogaHR0cHM6Ly9naXRodWIuY29tL2Jlbi1saW5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ21vbWVudCddLCBmYWN0b3J5KSA6XG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgemhfdHcgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd6aC10dycsIHtcbiAgICAgICAgbW9udGhzIDogJ+S4gOaciF/kuozmnIhf5LiJ5pyIX+Wbm+aciF/kupTmnIhf5YWt5pyIX+S4g+aciF/lhavmnIhf5Lmd5pyIX+WNgeaciF/ljYHkuIDmnIhf5Y2B5LqM5pyIJy5zcGxpdCgnXycpLFxuICAgICAgICBtb250aHNTaG9ydCA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXMgOiAn5pif5pyf5pelX+aYn+acn+S4gF/mmJ/mnJ/kuoxf5pif5pyf5LiJX+aYn+acn+Wbm1/mmJ/mnJ/kupRf5pif5pyf5YWtJy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogJ+mAseaXpV/pgLHkuIBf6YCx5LqMX+mAseS4iV/pgLHlm5tf6YCx5LqUX+mAseWFrScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiAn5pelX+S4gF/kuoxf5LiJX+Wbm1/kupRf5YWtJy5zcGxpdCgnXycpLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogJ0Fo6buebW3liIYnLFxuICAgICAgICAgICAgTFRTIDogJ0Fo6buebeWIhnPnp5InLFxuICAgICAgICAgICAgTCA6ICdZWVlZ5bm0TU1NROaXpScsXG4gICAgICAgICAgICBMTCA6ICdZWVlZ5bm0TU1NROaXpScsXG4gICAgICAgICAgICBMTEwgOiAnWVlZWeW5tE1NTUTml6VBaOm7nm1t5YiGJyxcbiAgICAgICAgICAgIExMTEwgOiAnWVlZWeW5tE1NTUTml6VkZGRkQWjpu55tbeWIhicsXG4gICAgICAgICAgICBsIDogJ1lZWVnlubRNTU1E5pelJyxcbiAgICAgICAgICAgIGxsIDogJ1lZWVnlubRNTU1E5pelJyxcbiAgICAgICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpUFo6buebW3liIYnLFxuICAgICAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGRBaOm7nm1t5YiGJ1xuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbVBhcnNlOiAv5pep5LiKfOS4iuWNiHzkuK3ljYh85LiL5Y2IfOaZmuS4ii8sXG4gICAgICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfml6nkuIonIHx8IG1lcmlkaWVtID09PSAn5LiK5Y2IJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+S4reWNiCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XG4gICAgICAgICAgICBpZiAoaG0gPCA5MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+aXqeS4iic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTEzMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5LiK5Y2IJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMjMwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICfkuK3ljYgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChobSA8IDE4MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ+S4i+WNiCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAn5pma5LiKJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1vku4rlpKldTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdb5piO5aSpXUxUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ1vkuItdZGRkZExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW+aYqOWkqV1MVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdb5LiKXWRkZGRMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOmAsSkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgICAgY2FzZSAnZCcgOlxuICAgICAgICAgICAgY2FzZSAnRCcgOlxuICAgICAgICAgICAgY2FzZSAnREREJyA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xuICAgICAgICAgICAgY2FzZSAnTScgOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pyIJztcbiAgICAgICAgICAgIGNhc2UgJ3cnIDpcbiAgICAgICAgICAgIGNhc2UgJ1cnIDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+mAsSc7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiAnJXPlhacnLFxuICAgICAgICAgICAgcGFzdCA6ICclc+WJjScsXG4gICAgICAgICAgICBzIDogJ+W5vuenkicsXG4gICAgICAgICAgICBtIDogJ+S4gOWIhumQmCcsXG4gICAgICAgICAgICBtbSA6ICclZOWIhumQmCcsXG4gICAgICAgICAgICBoIDogJ+S4gOWwj+aZgicsXG4gICAgICAgICAgICBoaCA6ICclZOWwj+aZgicsXG4gICAgICAgICAgICBkIDogJ+S4gOWkqScsXG4gICAgICAgICAgICBkZCA6ICclZOWkqScsXG4gICAgICAgICAgICBNIDogJ+S4gOWAi+aciCcsXG4gICAgICAgICAgICBNTSA6ICclZOWAi+aciCcsXG4gICAgICAgICAgICB5IDogJ+S4gOW5tCcsXG4gICAgICAgICAgICB5eSA6ICclZOW5tCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHpoX3R3O1xuXG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9tb21lbnQvbG9jYWxlL3poLXR3LmpzXG4gKiogbW9kdWxlIGlkID0gMjk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzXG4gKiovIiwiLyohXG4gKiBCb290c3RyYXAgdjMuMy42IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuaWYgKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeScpXG59XG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGlmICgodmVyc2lvblswXSA8IDIgJiYgdmVyc2lvblsxXSA8IDkpIHx8ICh2ZXJzaW9uWzBdID09IDEgJiYgdmVyc2lvblsxXSA9PSA5ICYmIHZlcnNpb25bMl0gPCAxKSB8fCAodmVyc2lvblswXSA+IDIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5IHZlcnNpb24gMS45LjEgb3IgaGlnaGVyLCBidXQgbG93ZXIgdGhhbiB2ZXJzaW9uIDMnKVxuICB9XG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFsZXJ0LmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWxlcnRzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUxFUlQgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGRpc21pc3MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuICB2YXIgQWxlcnQgICA9IGZ1bmN0aW9uIChlbCkge1xuICAgICQoZWwpLm9uKCdjbGljaycsIGRpc21pc3MsIHRoaXMuY2xvc2UpXG4gIH1cblxuICBBbGVydC5WRVJTSU9OID0gJzMuMy42J1xuXG4gIEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gJChzZWxlY3RvcilcblxuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICRwYXJlbnQgPSAkdGhpcy5jbG9zZXN0KCcuYWxlcnQnKVxuICAgIH1cblxuICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnY2xvc2UuYnMuYWxlcnQnKSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBwYXJlbnQsIGZpcmUgZXZlbnQgdGhlbiBjbGVhbiB1cCBkYXRhXG4gICAgICAkcGFyZW50LmRldGFjaCgpLnRyaWdnZXIoJ2Nsb3NlZC5icy5hbGVydCcpLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHBhcmVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgcmVtb3ZlRWxlbWVudClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEFsZXJ0LlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHJlbW92ZUVsZW1lbnQoKVxuICB9XG5cblxuICAvLyBBTEVSVCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hbGVydCcsIChkYXRhID0gbmV3IEFsZXJ0KHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWxlcnRcblxuICAkLmZuLmFsZXJ0ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWxlcnQuQ29uc3RydWN0b3IgPSBBbGVydFxuXG5cbiAgLy8gQUxFUlQgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFsZXJ0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hbGVydCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFMRVJUIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpJywgZGlzbWlzcywgQWxlcnQucHJvdG90eXBlLmNsb3NlKVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBidXR0b24uanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNidXR0b25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQlVUVE9OIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBCdXR0b24gPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gJC5leHRlbmQoe30sIEJ1dHRvbi5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gIH1cblxuICBCdXR0b24uVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgQnV0dG9uLkRFRkFVTFRTID0ge1xuICAgIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZCAgICA9ICdkaXNhYmxlZCdcbiAgICB2YXIgJGVsICA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgdmFsICA9ICRlbC5pcygnaW5wdXQnKSA/ICd2YWwnIDogJ2h0bWwnXG4gICAgdmFyIGRhdGEgPSAkZWwuZGF0YSgpXG5cbiAgICBzdGF0ZSArPSAnVGV4dCdcblxuICAgIGlmIChkYXRhLnJlc2V0VGV4dCA9PSBudWxsKSAkZWwuZGF0YSgncmVzZXRUZXh0JywgJGVsW3ZhbF0oKSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gPT0gbnVsbCA/IHRoaXMub3B0aW9uc1tzdGF0ZV0gOiBkYXRhW3N0YXRlXSlcblxuICAgICAgaWYgKHN0YXRlID09ICdsb2FkaW5nVGV4dCcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICAgIH1cbiAgICB9LCB0aGlzKSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZVxuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKVxuICAgICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgICBpZiAoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSkgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICRwYXJlbnQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgfSBlbHNlIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdjaGVja2JveCcpIHtcbiAgICAgICAgaWYgKCgkaW5wdXQucHJvcCgnY2hlY2tlZCcpKSAhPT0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgfVxuICAgICAgJGlucHV0LnByb3AoJ2NoZWNrZWQnLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSlcbiAgICAgIGlmIChjaGFuZ2VkKSAkaW5wdXQudHJpZ2dlcignY2hhbmdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLXByZXNzZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQlVUVE9OIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5idXR0b24nKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicsIChkYXRhID0gbmV3IEJ1dHRvbih0aGlzLCBvcHRpb25zKSkpXG5cbiAgICAgIGlmIChvcHRpb24gPT0gJ3RvZ2dsZScpIGRhdGEudG9nZ2xlKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmJ1dHRvblxuXG4gICQuZm4uYnV0dG9uICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuICAvLyBCVVRUT04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5idXR0b24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmJ1dHRvbiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICRidG4gPSAkKGUudGFyZ2V0KVxuICAgICAgaWYgKCEkYnRuLmhhc0NsYXNzKCdidG4nKSkgJGJ0biA9ICRidG4uY2xvc2VzdCgnLmJ0bicpXG4gICAgICBQbHVnaW4uY2FsbCgkYnRuLCAndG9nZ2xlJylcbiAgICAgIGlmICghKCQoZS50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSB8fCAkKGUudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykpKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZS50eXBlKSlcbiAgICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjYXJvdXNlbC5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Nhcm91c2VsXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ0FST1VTRUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENhcm91c2VsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGluZGljYXRvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5jYXJvdXNlbC1pbmRpY2F0b3JzJylcbiAgICB0aGlzLm9wdGlvbnMgICAgID0gb3B0aW9uc1xuICAgIHRoaXMucGF1c2VkICAgICAgPSBudWxsXG4gICAgdGhpcy5zbGlkaW5nICAgICA9IG51bGxcbiAgICB0aGlzLmludGVydmFsICAgID0gbnVsbFxuICAgIHRoaXMuJGFjdGl2ZSAgICAgPSBudWxsXG4gICAgdGhpcy4kaXRlbXMgICAgICA9IG51bGxcblxuICAgIHRoaXMub3B0aW9ucy5rZXlib2FyZCAmJiB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpKVxuXG4gICAgdGhpcy5vcHRpb25zLnBhdXNlID09ICdob3ZlcicgJiYgISgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICYmIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbignbW91c2VlbnRlci5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5wYXVzZSwgdGhpcykpXG4gICAgICAub24oJ21vdXNlbGVhdmUuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMuY3ljbGUsIHRoaXMpKVxuICB9XG5cbiAgQ2Fyb3VzZWwuVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDYwMFxuXG4gIENhcm91c2VsLkRFRkFVTFRTID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWVcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSkgcmV0dXJuXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICBjYXNlIDM3OiB0aGlzLnByZXYoKTsgYnJlYWtcbiAgICAgIGNhc2UgMzk6IHRoaXMubmV4dCgpOyBicmVha1xuICAgICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gZmFsc2UpXG5cbiAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbFxuICAgICAgJiYgIXRoaXMucGF1c2VkXG4gICAgICAmJiAodGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcy5uZXh0LCB0aGlzKSwgdGhpcy5vcHRpb25zLmludGVydmFsKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLiRpdGVtcyA9IGl0ZW0ucGFyZW50KCkuY2hpbGRyZW4oJy5pdGVtJylcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuaW5kZXgoaXRlbSB8fCB0aGlzLiRhY3RpdmUpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFjdGl2ZSkge1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KGFjdGl2ZSlcbiAgICB2YXIgd2lsbFdyYXAgPSAoZGlyZWN0aW9uID09ICdwcmV2JyAmJiBhY3RpdmVJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICB8fCAoZGlyZWN0aW9uID09ICduZXh0JyAmJiBhY3RpdmVJbmRleCA9PSAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkpXG4gICAgaWYgKHdpbGxXcmFwICYmICF0aGlzLm9wdGlvbnMud3JhcCkgcmV0dXJuIGFjdGl2ZVxuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAncHJldicgPyAtMSA6IDFcbiAgICB2YXIgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy4kaXRlbXMubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGl0ZW1JbmRleClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgPSB0aGlzXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKSlcblxuICAgIGlmIChwb3MgPiAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkgfHwgcG9zIDwgMCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC5vbmUoJ3NsaWQuYnMuY2Fyb3VzZWwnLCBmdW5jdGlvbiAoKSB7IHRoYXQudG8ocG9zKSB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IHBvcykgcmV0dXJuIHRoaXMucGF1c2UoKS5jeWNsZSgpXG5cbiAgICByZXR1cm4gdGhpcy5zbGlkZShwb3MgPiBhY3RpdmVJbmRleCA/ICduZXh0JyA6ICdwcmV2JywgdGhpcy4kaXRlbXMuZXEocG9zKSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSB0cnVlKVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnLm5leHQsIC5wcmV2JykubGVuZ3RoICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ25leHQnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ3ByZXYnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24gKHR5cGUsIG5leHQpIHtcbiAgICB2YXIgJGFjdGl2ZSAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKVxuICAgIHZhciAkbmV4dCAgICAgPSBuZXh0IHx8IHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbih0eXBlLCAkYWN0aXZlKVxuICAgIHZhciBpc0N5Y2xpbmcgPSB0aGlzLmludGVydmFsXG4gICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUgPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIHZhciB0aGF0ICAgICAgPSB0aGlzXG5cbiAgICBpZiAoJG5leHQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm4gKHRoaXMuc2xpZGluZyA9IGZhbHNlKVxuXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSAkbmV4dFswXVxuICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudCgnc2xpZGUuYnMuY2Fyb3VzZWwnLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkZUV2ZW50KVxuICAgIGlmIChzbGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuc2xpZGluZyA9IHRydWVcblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLnBhdXNlKClcblxuICAgIGlmICh0aGlzLiRpbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB2YXIgJG5leHRJbmRpY2F0b3IgPSAkKHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oKVt0aGlzLmdldEl0ZW1JbmRleCgkbmV4dCldKVxuICAgICAgJG5leHRJbmRpY2F0b3IgJiYgJG5leHRJbmRpY2F0b3IuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoJ3NsaWQuYnMuY2Fyb3VzZWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0pIC8vIHllcywgXCJzbGlkXCJcbiAgICBpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xpZGUnKSkge1xuICAgICAgJG5leHQuYWRkQ2xhc3ModHlwZSlcbiAgICAgICRuZXh0WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgJGFjdGl2ZS5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkbmV4dC5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkbmV4dC5yZW1vdmVDbGFzcyhbdHlwZSwgZGlyZWN0aW9uXS5qb2luKCcgJykpLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoWydhY3RpdmUnLCBkaXJlY3Rpb25dLmpvaW4oJyAnKSlcbiAgICAgICAgICB0aGF0LnNsaWRpbmcgPSBmYWxzZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKHNsaWRFdmVudClcbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICB9IGVsc2Uge1xuICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICRuZXh0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaXNDeWNsaW5nICYmIHRoaXMuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ2Fyb3VzZWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG4gICAgICB2YXIgYWN0aW9uICA9IHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgPyBvcHRpb24gOiBvcHRpb25zLnNsaWRlXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnLCAoZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnbnVtYmVyJykgZGF0YS50byhvcHRpb24pXG4gICAgICBlbHNlIGlmIChhY3Rpb24pIGRhdGFbYWN0aW9uXSgpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLmludGVydmFsKSBkYXRhLnBhdXNlKCkuY3ljbGUoKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jYXJvdXNlbFxuXG4gICQuZm4uY2Fyb3VzZWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jYXJvdXNlbC5Db25zdHJ1Y3RvciA9IENhcm91c2VsXG5cblxuICAvLyBDQVJPVVNFTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY2Fyb3VzZWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNhcm91c2VsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmID0gJHRoaXMuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnY2Fyb3VzZWwnKSkgcmV0dXJuXG4gICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcbiAgICB2YXIgc2xpZGVJbmRleCA9ICR0aGlzLmF0dHIoJ2RhdGEtc2xpZGUtdG8nKVxuICAgIGlmIChzbGlkZUluZGV4KSBvcHRpb25zLmludGVydmFsID0gZmFsc2VcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbnMpXG5cbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgJHRhcmdldC5kYXRhKCdicy5jYXJvdXNlbCcpLnRvKHNsaWRlSW5kZXgpXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGVdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGUtdG9dJywgY2xpY2tIYW5kbGVyKVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2Fyb3VzZWwgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkY2Fyb3VzZWwsICRjYXJvdXNlbC5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY29sbGFwc2UuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjb2xsYXBzZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENPTExBUFNFIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENvbGxhcHNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuJHRyaWdnZXIgICAgICA9ICQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXScpXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gbnVsbFxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCwgdGhpcy4kdHJpZ2dlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRvZ2dsZSkgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgQ29sbGFwc2UuVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTiA9IDM1MFxuXG4gIENvbGxhcHNlLkRFRkFVTFRTID0ge1xuICAgIHRvZ2dsZTogdHJ1ZVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmRpbWVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzV2lkdGggPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCd3aWR0aCcpXG4gICAgcmV0dXJuIGhhc1dpZHRoID8gJ3dpZHRoJyA6ICdoZWlnaHQnXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIGFjdGl2ZXNEYXRhXG4gICAgdmFyIGFjdGl2ZXMgPSB0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50LmNoaWxkcmVuKCcucGFuZWwnKS5jaGlsZHJlbignLmluLCAuY29sbGFwc2luZycpXG5cbiAgICBpZiAoYWN0aXZlcyAmJiBhY3RpdmVzLmxlbmd0aCkge1xuICAgICAgYWN0aXZlc0RhdGEgPSBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS50cmFuc2l0aW9uaW5nKSByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMuY29sbGFwc2UnKVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBQbHVnaW4uY2FsbChhY3RpdmVzLCAnaGlkZScpXG4gICAgICBhY3RpdmVzRGF0YSB8fCBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJywgbnVsbClcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVtkaW1lbnNpb25dKDApXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAxXG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UgaW4nKVtkaW1lbnNpb25dKCcnKVxuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB2YXIgc2Nyb2xsU2l6ZSA9ICQuY2FtZWxDYXNlKFsnc2Nyb2xsJywgZGltZW5zaW9uXS5qb2luKCctJykpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbMF1bc2Nyb2xsU2l6ZV0pXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8ICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uKClcblxuICAgIHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSh0aGlzLiRlbGVtZW50W2RpbWVuc2lvbl0oKSlbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZSBpbicpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy4kdHJpZ2dlclxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZWQnKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDBcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICBbZGltZW5zaW9uXSgwKVxuICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eShjb21wbGV0ZSwgdGhpcykpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpID8gJ2hpZGUnIDogJ3Nob3cnXSgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkKHRoaXMub3B0aW9ucy5wYXJlbnQpXG4gICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInICsgdGhpcy5vcHRpb25zLnBhcmVudCArICdcIl0nKVxuICAgICAgLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICAgIHRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGdldFRhcmdldEZyb21UcmlnZ2VyKCRlbGVtZW50KSwgJGVsZW1lbnQpXG4gICAgICB9LCB0aGlzKSlcbiAgICAgIC5lbmQoKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uICgkZWxlbWVudCwgJHRyaWdnZXIpIHtcbiAgICB2YXIgaXNPcGVuID0gJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJylcblxuICAgICRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gICAgJHRyaWdnZXJcbiAgICAgIC50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzT3BlbilcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRyaWdnZXIpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciB0YXJnZXQgPSAkdHJpZ2dlci5hdHRyKCdkYXRhLXRhcmdldCcpXG4gICAgICB8fCAoaHJlZiA9ICR0cmlnZ2VyLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuXG4gICAgcmV0dXJuICQodGFyZ2V0KVxuICB9XG5cblxuICAvLyBDT0xMQVBTRSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbnMudG9nZ2xlICYmIC9zaG93fGhpZGUvLnRlc3Qob3B0aW9uKSkgb3B0aW9ucy50b2dnbGUgPSBmYWxzZVxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScsIChkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jb2xsYXBzZVxuXG4gICQuZm4uY29sbGFwc2UgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jb2xsYXBzZS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlXG5cblxuICAvLyBDT0xMQVBTRSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY29sbGFwc2Uubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNvbGxhcHNlID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ09MTEFQU0UgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuXG4gICAgaWYgKCEkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHZhciAkdGFyZ2V0ID0gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRoaXMpXG4gICAgdmFyIGRhdGEgICAgPSAkdGFyZ2V0LmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICB2YXIgb3B0aW9uICA9IGRhdGEgPyAndG9nZ2xlJyA6ICR0aGlzLmRhdGEoKVxuXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uKVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuNidcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgaWYgKGUgJiYgZS50eXBlID09ICdjbGljaycgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSAmJiAkLmNvbnRhaW5zKCRwYXJlbnRbMF0sIGUudGFyZ2V0KSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJC5FdmVudCgnaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfSlcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBjbGVhck1lbnVzKClcblxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgISRwYXJlbnQuY2xvc2VzdCgnLm5hdmJhci1uYXYnKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgLmFkZENsYXNzKCdkcm9wZG93bi1iYWNrZHJvcCcpXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQodGhpcykpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSB8fCAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpKSByZXR1cm5cblxuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBpZiAoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcgfHwgaXNBY3RpdmUgJiYgZS53aGljaCA9PSAyNykge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCcuZHJvcGRvd24tbWVudScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93bi1tZW51JywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBNb2RhbC5WRVJTSU9OICA9ICczLjMuNidcblxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBNb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICh0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXG5cbiAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLiRkaWFsb2cub24oJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kZWxlbWVudC5vbmUoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGF0LiRlbGVtZW50KSkgdGhhdC5pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIHRoYXQuYWRqdXN0RGlhbG9nKClcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRkaWFsb2cgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZVxuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxuICAgICAgLm9mZignbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGRpYWxvZy5vZmYoJ21vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkodGhpcy5oaWRlTW9kYWwsIHRoaXMpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKCdmb2N1c2luLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudFswXSAhPT0gZS50YXJnZXQgJiYgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcykpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUud2hpY2ggPT0gMjcgJiYgdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5icy5tb2RhbCcsICQucHJveHkodGhpcy5oYW5kbGVVcGRhdGUsIHRoaXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoYXQucmVzZXRTY3JvbGxiYXIoKVxuICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4uYnMubW9kYWwnKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYmFja2Ryb3AgJiYgdGhpcy4kYmFja2Ryb3AucmVtb3ZlKClcbiAgICB0aGlzLiRiYWNrZHJvcCA9IG51bGxcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5iYWNrZHJvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBhbmltYXRlID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID8gJ2ZhZGUnIDogJydcblxuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICB2YXIgZG9BbmltYXRlID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgYW5pbWF0ZVxuXG4gICAgICB0aGlzLiRiYWNrZHJvcCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgIC5hZGRDbGFzcygnbW9kYWwtYmFja2Ryb3AgJyArIGFuaW1hdGUpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLiRib2R5KVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkgcmV0dXJuXG4gICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgID8gdGhpcy4kZWxlbWVudFswXS5mb2N1cygpXG4gICAgICAgICAgOiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBNb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLm1vZGFsXG5cbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLm1vZGFsLkNvbnN0cnVjdG9yID0gTW9kYWxcblxuXG4gIC8vIE1PREFMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5tb2RhbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ubW9kYWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBNT0RBTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5tb2RhbC5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB2YXIgb3B0aW9uICA9ICR0YXJnZXQuZGF0YSgnYnMubW9kYWwnKSA/ICd0b2dnbGUnIDogJC5leHRlbmQoeyByZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmIH0sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG5cbiAgICBpZiAoJHRoaXMuaXMoJ2EnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVybiAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAkdGFyZ2V0Lm9uZSgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICB9KVxuICAgIH0pXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0b29sdGlwLmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdG9vbHRpcFxuICogSW5zcGlyZWQgYnkgdGhlIG9yaWdpbmFsIGpRdWVyeS50aXBzeSBieSBKYXNvbiBGcmFtZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRPT0xUSVAgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcHRpb25zICAgID0gbnVsbFxuICAgIHRoaXMuZW5hYmxlZCAgICA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXQgICAgPSBudWxsXG4gICAgdGhpcy5ob3ZlclN0YXRlID0gbnVsbFxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcbiAgICB0aGlzLmluU3RhdGUgICAgPSBudWxsXG5cbiAgICB0aGlzLmluaXQoJ3Rvb2x0aXAnLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgVG9vbHRpcC5WRVJTSU9OICA9ICczLjMuNidcblxuICBUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUb29sdGlwLkRFRkFVTFRTID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+JyxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBkZWxheTogMCxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgICAgcGFkZGluZzogMFxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodHlwZSwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCAgID0gdHJ1ZVxuICAgIHRoaXMudHlwZSAgICAgID0gdHlwZVxuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gdGhpcy5nZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy4kdmlld3BvcnQgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgJCgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnZpZXdwb3J0KSA/IHRoaXMub3B0aW9ucy52aWV3cG9ydC5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQpIDogKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpKVxuICAgIHRoaXMuaW5TdGF0ZSAgID0geyBjbGljazogZmFsc2UsIGhvdmVyOiBmYWxzZSwgZm9jdXM6IGZhbHNlIH1cblxuICAgIGlmICh0aGlzLiRlbGVtZW50WzBdIGluc3RhbmNlb2YgZG9jdW1lbnQuY29uc3RydWN0b3IgJiYgIXRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgc2VsZWN0b3JgIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemluZyAnICsgdGhpcy50eXBlICsgJyBvbiB0aGUgd2luZG93LmRvY3VtZW50IG9iamVjdCEnKVxuICAgIH1cblxuICAgIHZhciB0cmlnZ2VycyA9IHRoaXMub3B0aW9ucy50cmlnZ2VyLnNwbGl0KCcgJylcblxuICAgIGZvciAodmFyIGkgPSB0cmlnZ2Vycy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gdHJpZ2dlcnNbaV1cblxuICAgICAgaWYgKHRyaWdnZXIgPT0gJ2NsaWNrJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy50b2dnbGUsIHRoaXMpKVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9ICdtYW51YWwnKSB7XG4gICAgICAgIHZhciBldmVudEluICA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWVudGVyJyA6ICdmb2N1c2luJ1xuICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VsZWF2ZScgOiAnZm9jdXNvdXQnXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudEluICArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMuZW50ZXIsIHRoaXMpKVxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50T3V0ICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5sZWF2ZSwgdGhpcykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnNlbGVjdG9yID9cbiAgICAgICh0aGlzLl9vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgeyB0cmlnZ2VyOiAnbWFudWFsJywgc2VsZWN0b3I6ICcnIH0pKSA6XG4gICAgICB0aGlzLmZpeFRpdGxlKClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUb29sdGlwLkRFRkFVTFRTXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMuZ2V0RGVmYXVsdHMoKSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpXG5cbiAgICBpZiAob3B0aW9ucy5kZWxheSAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSA9PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogb3B0aW9ucy5kZWxheSxcbiAgICAgICAgaGlkZTogb3B0aW9ucy5kZWxheVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgID0ge31cbiAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmdldERlZmF1bHRzKClcblxuICAgIHRoaXMuX29wdGlvbnMgJiYgJC5lYWNoKHRoaXMuX29wdGlvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoZGVmYXVsdHNba2V5XSAhPSB2YWx1ZSkgb3B0aW9uc1trZXldID0gdmFsdWVcbiAgICB9KVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiAkLkV2ZW50KSB7XG4gICAgICBzZWxmLmluU3RhdGVbb2JqLnR5cGUgPT0gJ2ZvY3VzaW4nID8gJ2ZvY3VzJyA6ICdob3ZlciddID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzZWxmLnRpcCgpLmhhc0NsYXNzKCdpbicpIHx8IHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSB7XG4gICAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaXNJblN0YXRlVHJ1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pblN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5pblN0YXRlW2tleV0pIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgJC5FdmVudCkge1xuICAgICAgc2VsZi5pblN0YXRlW29iai50eXBlID09ICdmb2N1c291dCcgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzZWxmLmlzSW5TdGF0ZVRydWUoKSkgcmV0dXJuXG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ291dCdcblxuICAgIGlmICghc2VsZi5vcHRpb25zLmRlbGF5IHx8ICFzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSkgcmV0dXJuIHNlbGYuaGlkZSgpXG5cbiAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmhvdmVyU3RhdGUgPT0gJ291dCcpIHNlbGYuaGlkZSgpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gJC5FdmVudCgnc2hvdy5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKHRoaXMuaGFzQ29udGVudCgpICYmIHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIHZhciBpbkRvbSA9ICQuY29udGFpbnModGhpcy4kZWxlbWVudFswXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy4kZWxlbWVudFswXSlcbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpbkRvbSkgcmV0dXJuXG4gICAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgICAgdmFyICR0aXAgPSB0aGlzLnRpcCgpXG5cbiAgICAgIHZhciB0aXBJZCA9IHRoaXMuZ2V0VUlEKHRoaXMudHlwZSlcblxuICAgICAgdGhpcy5zZXRDb250ZW50KClcbiAgICAgICR0aXAuYXR0cignaWQnLCB0aXBJZClcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRpcElkKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikgJHRpcC5hZGRDbGFzcygnZmFkZScpXG5cbiAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudC5jYWxsKHRoaXMsICR0aXBbMF0sIHRoaXMuJGVsZW1lbnRbMF0pIDpcbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudFxuXG4gICAgICB2YXIgYXV0b1Rva2VuID0gL1xccz9hdXRvP1xccz8vaVxuICAgICAgdmFyIGF1dG9QbGFjZSA9IGF1dG9Ub2tlbi50ZXN0KHBsYWNlbWVudClcbiAgICAgIGlmIChhdXRvUGxhY2UpIHBsYWNlbWVudCA9IHBsYWNlbWVudC5yZXBsYWNlKGF1dG9Ub2tlbiwgJycpIHx8ICd0b3AnXG5cbiAgICAgICR0aXBcbiAgICAgICAgLmRldGFjaCgpXG4gICAgICAgIC5jc3MoeyB0b3A6IDAsIGxlZnQ6IDAsIGRpc3BsYXk6ICdibG9jaycgfSlcbiAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgICAgLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHRoaXMpXG5cbiAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkdGlwLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogJHRpcC5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KVxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnNlcnRlZC5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgICB2YXIgcG9zICAgICAgICAgID0gdGhpcy5nZXRQb3NpdGlvbigpXG4gICAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgICAgdmFyIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgdmFyIG9yZ1BsYWNlbWVudCA9IHBsYWNlbWVudFxuICAgICAgICB2YXIgdmlld3BvcnREaW0gPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gdmlld3BvcnREaW0uYm90dG9tID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3RvcCcgICAgJiYgcG9zLnRvcCAgICAtIGFjdHVhbEhlaWdodCA8IHZpZXdwb3J0RGltLnRvcCAgICA/ICdib3R0b20nIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCAgKyBhY3R1YWxXaWR0aCAgPiB2aWV3cG9ydERpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgdmlld3BvcnREaW0ubGVmdCAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRcblxuICAgICAgICAkdGlwXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKG9yZ1BsYWNlbWVudClcbiAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgfVxuXG4gICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChjYWxjdWxhdGVkT2Zmc2V0LCBwbGFjZW1lbnQpXG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZIb3ZlclN0YXRlID0gdGhhdC5ob3ZlclN0YXRlXG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvd24uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgICAgdGhhdC5ob3ZlclN0YXRlID0gbnVsbFxuXG4gICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PSAnb3V0JykgdGhhdC5sZWF2ZSh0aGF0KVxuICAgICAgfVxuXG4gICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgICR0aXBcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcHBseVBsYWNlbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQsIHBsYWNlbWVudCkge1xuICAgIHZhciAkdGlwICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIC8vIG1hbnVhbGx5IHJlYWQgbWFyZ2lucyBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpbmNsdWRlcyBkaWZmZXJlbmNlXG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tdG9wJyksIDEwKVxuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi1sZWZ0JyksIDEwKVxuXG4gICAgLy8gd2UgbXVzdCBjaGVjayBmb3IgTmFOIGZvciBpZSA4LzlcbiAgICBpZiAoaXNOYU4obWFyZ2luVG9wKSkgIG1hcmdpblRvcCAgPSAwXG4gICAgaWYgKGlzTmFOKG1hcmdpbkxlZnQpKSBtYXJnaW5MZWZ0ID0gMFxuXG4gICAgb2Zmc2V0LnRvcCAgKz0gbWFyZ2luVG9wXG4gICAgb2Zmc2V0LmxlZnQgKz0gbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNWZXJ0aWNhbCkge1xuICAgIHRoaXMuYXJyb3coKVxuICAgICAgLmNzcyhpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCcsIDUwICogKDEgLSBkZWx0YSAvIGRpbWVuc2lvbikgKyAnJScpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gJCh0aGlzLiR0aXApXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdoaWRlLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICh0aGF0LmhvdmVyU3RhdGUgIT0gJ2luJykgJHRpcC5kZXRhY2goKVxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykgIT0gJ3N0cmluZycpIHtcbiAgICAgICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCAkZS5hdHRyKCd0aXRsZScpIHx8ICcnKS5hdHRyKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAkZWxlbWVudCAgID0gJGVsZW1lbnQgfHwgdGhpcy4kZWxlbWVudFxuXG4gICAgdmFyIGVsICAgICA9ICRlbGVtZW50WzBdXG4gICAgdmFyIGlzQm9keSA9IGVsLnRhZ05hbWUgPT0gJ0JPRFknXG5cbiAgICB2YXIgZWxSZWN0ICAgID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoZWxSZWN0LndpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG1pc3NpbmcgaW4gSUU4LCBzbyBjb21wdXRlIHRoZW0gbWFudWFsbHk7IHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzE0MDkzXG4gICAgICBlbFJlY3QgPSAkLmV4dGVuZCh7fSwgZWxSZWN0LCB7IHdpZHRoOiBlbFJlY3QucmlnaHQgLSBlbFJlY3QubGVmdCwgaGVpZ2h0OiBlbFJlY3QuYm90dG9tIC0gZWxSZWN0LnRvcCB9KVxuICAgIH1cbiAgICB2YXIgZWxPZmZzZXQgID0gaXNCb2R5ID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6ICRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHNjcm9sbCAgICA9IHsgc2Nyb2xsOiBpc0JvZHkgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIDogJGVsZW1lbnQuc2Nyb2xsVG9wKCkgfVxuICAgIHZhciBvdXRlckRpbXMgPSBpc0JvZHkgPyB7IHdpZHRoOiAkKHdpbmRvdykud2lkdGgoKSwgaGVpZ2h0OiAkKHdpbmRvdykuaGVpZ2h0KCkgfSA6IG51bGxcblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZWxSZWN0LCBzY3JvbGwsIG91dGVyRGltcywgZWxPZmZzZXQpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudCA9PSAnYm90dG9tJyA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgICBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRoIH0gOlxuICAgICAgICAvKiBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAqLyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLnJpZ2h0KSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkge1xuICAgICAgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgICBpZiAodGhpcy4kdGlwLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnR5cGUgKyAnIGB0ZW1wbGF0ZWAgb3B0aW9uIG11c3QgY29uc2lzdCBvZiBleGFjdGx5IDEgdG9wLWxldmVsIGVsZW1lbnQhJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLnRvb2x0aXAtYXJyb3cnKSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWRcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKGUpIHtcbiAgICAgIHNlbGYgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcbiAgICAgIGlmICghc2VsZikge1xuICAgICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZS5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgc2VsZi5pblN0YXRlLmNsaWNrID0gIXNlbGYuaW5TdGF0ZS5jbGlja1xuICAgICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSBzZWxmLmVudGVyKHNlbGYpXG4gICAgICBlbHNlIHNlbGYubGVhdmUoc2VsZilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50aXAoKS5oYXNDbGFzcygnaW4nKSA/IHNlbGYubGVhdmUoc2VsZikgOiBzZWxmLmVudGVyKHNlbGYpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgICBpZiAodGhhdC4kdGlwKSB7XG4gICAgICAgIHRoYXQuJHRpcC5kZXRhY2goKVxuICAgICAgfVxuICAgICAgdGhhdC4kdGlwID0gbnVsbFxuICAgICAgdGhhdC4kYXJyb3cgPSBudWxsXG4gICAgICB0aGF0LiR2aWV3cG9ydCA9IG51bGxcbiAgICB9KVxuICB9XG5cblxuICAvLyBUT09MVElQIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGVzdHJveXxoaWRlLy50ZXN0KG9wdGlvbikpIHJldHVyblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy42J1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG5cbiAgLy8gUE9QT1ZFUiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChvcHRpb24pKSByZXR1cm5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnBvcG92ZXJcblxuICAkLmZuLnBvcG92ZXIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG5cbiAgLy8gUE9QT1ZFUiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5wb3BvdmVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5wb3BvdmVyID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBzY3JvbGxzcHkuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNzY3JvbGxzcHlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBTQ1JPTExTUFkgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kYm9keSAgICAgICAgICA9ICQoZG9jdW1lbnQuYm9keSlcbiAgICB0aGlzLiRzY3JvbGxFbGVtZW50ID0gJChlbGVtZW50KS5pcyhkb2N1bWVudC5ib2R5KSA/ICQod2luZG93KSA6ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gJC5leHRlbmQoe30sIFNjcm9sbFNweS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLnNlbGVjdG9yICAgICAgID0gKHRoaXMub3B0aW9ucy50YXJnZXQgfHwgJycpICsgJyAubmF2IGxpID4gYSdcbiAgICB0aGlzLm9mZnNldHMgICAgICAgID0gW11cbiAgICB0aGlzLnRhcmdldHMgICAgICAgID0gW11cbiAgICB0aGlzLmFjdGl2ZVRhcmdldCAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ICAgPSAwXG5cbiAgICB0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKCdzY3JvbGwuYnMuc2Nyb2xsc3B5JywgJC5wcm94eSh0aGlzLnByb2Nlc3MsIHRoaXMpKVxuICAgIHRoaXMucmVmcmVzaCgpXG4gICAgdGhpcy5wcm9jZXNzKClcbiAgfVxuXG4gIFNjcm9sbFNweS5WRVJTSU9OICA9ICczLjMuNidcblxuICBTY3JvbGxTcHkuREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAxMFxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KHRoaXMuJGJvZHlbMF0uc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ICAgICAgICAgID0gdGhpc1xuICAgIHZhciBvZmZzZXRNZXRob2QgID0gJ29mZnNldCdcbiAgICB2YXIgb2Zmc2V0QmFzZSAgICA9IDBcblxuICAgIHRoaXMub2Zmc2V0cyAgICAgID0gW11cbiAgICB0aGlzLnRhcmdldHMgICAgICA9IFtdXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEhlaWdodCgpXG5cbiAgICBpZiAoISQuaXNXaW5kb3codGhpcy4kc2Nyb2xsRWxlbWVudFswXSkpIHtcbiAgICAgIG9mZnNldE1ldGhvZCA9ICdwb3NpdGlvbidcbiAgICAgIG9mZnNldEJhc2UgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKClcbiAgICB9XG5cbiAgICB0aGlzLiRib2R5XG4gICAgICAuZmluZCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWwgICA9ICQodGhpcylcbiAgICAgICAgdmFyIGhyZWYgID0gJGVsLmRhdGEoJ3RhcmdldCcpIHx8ICRlbC5hdHRyKCdocmVmJylcbiAgICAgICAgdmFyICRocmVmID0gL14jLi8udGVzdChocmVmKSAmJiAkKGhyZWYpXG5cbiAgICAgICAgcmV0dXJuICgkaHJlZlxuICAgICAgICAgICYmICRocmVmLmxlbmd0aFxuICAgICAgICAgICYmICRocmVmLmlzKCc6dmlzaWJsZScpXG4gICAgICAgICAgJiYgW1skaHJlZltvZmZzZXRNZXRob2RdKCkudG9wICsgb2Zmc2V0QmFzZSwgaHJlZl1dKSB8fCBudWxsXG4gICAgICB9KVxuICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdIH0pXG4gICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQub2Zmc2V0cy5wdXNoKHRoaXNbMF0pXG4gICAgICAgIHRoYXQudGFyZ2V0cy5wdXNoKHRoaXNbMV0pXG4gICAgICB9KVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JvbGxUb3AgICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpICsgdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEhlaWdodCgpXG4gICAgdmFyIG1heFNjcm9sbCAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLiRzY3JvbGxFbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldHMgICAgICA9IHRoaXMub2Zmc2V0c1xuICAgIHZhciB0YXJnZXRzICAgICAgPSB0aGlzLnRhcmdldHNcbiAgICB2YXIgYWN0aXZlVGFyZ2V0ID0gdGhpcy5hY3RpdmVUYXJnZXRcbiAgICB2YXIgaVxuXG4gICAgaWYgKHRoaXMuc2Nyb2xsSGVpZ2h0ICE9IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5yZWZyZXNoKClcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZVRhcmdldCAhPSAoaSA9IHRhcmdldHNbdGFyZ2V0cy5sZW5ndGggLSAxXSkgJiYgdGhpcy5hY3RpdmF0ZShpKVxuICAgIH1cblxuICAgIGlmIChhY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgb2Zmc2V0c1swXSkge1xuICAgICAgdGhpcy5hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgICByZXR1cm4gdGhpcy5jbGVhcigpXG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGFjdGl2ZVRhcmdldCAhPSB0YXJnZXRzW2ldXG4gICAgICAgICYmIHNjcm9sbFRvcCA+PSBvZmZzZXRzW2ldXG4gICAgICAgICYmIChvZmZzZXRzW2kgKyAxXSA9PT0gdW5kZWZpbmVkIHx8IHNjcm9sbFRvcCA8IG9mZnNldHNbaSArIDFdKVxuICAgICAgICAmJiB0aGlzLmFjdGl2YXRlKHRhcmdldHNbaV0pXG4gICAgfVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IHRhcmdldFxuXG4gICAgdGhpcy5jbGVhcigpXG5cbiAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICtcbiAgICAgICdbZGF0YS10YXJnZXQ9XCInICsgdGFyZ2V0ICsgJ1wiXSwnICtcbiAgICAgIHRoaXMuc2VsZWN0b3IgKyAnW2hyZWY9XCInICsgdGFyZ2V0ICsgJ1wiXSdcblxuICAgIHZhciBhY3RpdmUgPSAkKHNlbGVjdG9yKVxuICAgICAgLnBhcmVudHMoJ2xpJylcbiAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcblxuICAgIGlmIChhY3RpdmUucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgYWN0aXZlID0gYWN0aXZlXG4gICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICBhY3RpdmUudHJpZ2dlcignYWN0aXZhdGUuYnMuc2Nyb2xsc3B5JylcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LCAnLmFjdGl2ZScpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknLCAoZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnNjcm9sbHNweVxuXG4gICQuZm4uc2Nyb2xsc3B5ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uc2Nyb2xsc3B5LkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG5cblxuICAvLyBTQ1JPTExTUFkgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5zY3JvbGxzcHkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnNjcm9sbHNweSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQuYnMuc2Nyb2xsc3B5LmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVEFCIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBqc2NzOmRpc2FibGUgcmVxdWlyZURvbGxhckJlZm9yZWpRdWVyeUFzc2lnbm1lbnRcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgLy8ganNjczplbmFibGUgcmVxdWlyZURvbGxhckJlZm9yZWpRdWVyeUFzc2lnbm1lbnRcbiAgfVxuXG4gIFRhYi5WRVJTSU9OID0gJzMuMy42J1xuXG4gIFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGhpcyAgICA9IHRoaXMuZWxlbWVudFxuICAgIHZhciAkdWwgICAgICA9ICR0aGlzLmNsb3Nlc3QoJ3VsOm5vdCguZHJvcGRvd24tbWVudSknKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmRhdGEoJ3RhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIGlmICgkdGhpcy5wYXJlbnQoJ2xpJykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm5cblxuICAgIHZhciAkcHJldmlvdXMgPSAkdWwuZmluZCgnLmFjdGl2ZTpsYXN0IGEnKVxuICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgfSlcbiAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudCgnc2hvdy5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICB9KVxuXG4gICAgJHByZXZpb3VzLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICR0aGlzLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyICR0YXJnZXQgPSAkKHNlbGVjdG9yKVxuXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGhpcy5jbG9zZXN0KCdsaScpLCAkdWwpXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGFyZ2V0LCAkdGFyZ2V0LnBhcmVudCgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkcHJldmlvdXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdoaWRkZW4uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICAgIH0pXG4gICAgICAkdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ3Nob3duLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgVGFiLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyICRhY3RpdmUgICAgPSBjb250YWluZXIuZmluZCgnPiAuYWN0aXZlJylcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGNhbGxiYWNrXG4gICAgICAmJiAkLnN1cHBvcnQudHJhbnNpdGlvblxuICAgICAgJiYgKCRhY3RpdmUubGVuZ3RoICYmICRhY3RpdmUuaGFzQ2xhc3MoJ2ZhZGUnKSB8fCAhIWNvbnRhaW5lci5maW5kKCc+IC5mYWRlJykubGVuZ3RoKVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmUnKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgIGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2ZhZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgJGFjdGl2ZS5sZW5ndGggJiYgdHJhbnNpdGlvbiA/XG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIG5leHQpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUYWIuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgbmV4dCgpXG5cbiAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKCdpbicpXG4gIH1cblxuXG4gIC8vIFRBQiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy50YWInKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRhYicsIChkYXRhID0gbmV3IFRhYih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udGFiXG5cbiAgJC5mbi50YWIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi50YWIuQ29uc3RydWN0b3IgPSBUYWJcblxuXG4gIC8vIFRBQiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkLmZuLnRhYi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udGFiID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gVEFCIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PVxuXG4gIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIFBsdWdpbi5jYWxsKCQodGhpcyksICdzaG93JylcbiAgfVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInBpbGxcIl0nLCBjbGlja0hhbmRsZXIpXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGFmZml4LmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYWZmaXhcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBRkZJWCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQWZmaXggPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBZmZpeC5ERUZBVUxUUywgb3B0aW9ucylcblxuICAgIHRoaXMuJHRhcmdldCA9ICQodGhpcy5vcHRpb25zLnRhcmdldClcbiAgICAgIC5vbignc2Nyb2xsLmJzLmFmZml4LmRhdGEtYXBpJywgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpKVxuICAgICAgLm9uKCdjbGljay5icy5hZmZpeC5kYXRhLWFwaScsICAkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AsIHRoaXMpKVxuXG4gICAgdGhpcy4kZWxlbWVudCAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5hZmZpeGVkICAgICAgPSBudWxsXG4gICAgdGhpcy51bnBpbiAgICAgICAgPSBudWxsXG4gICAgdGhpcy5waW5uZWRPZmZzZXQgPSBudWxsXG5cbiAgICB0aGlzLmNoZWNrUG9zaXRpb24oKVxuICB9XG5cbiAgQWZmaXguVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgQWZmaXguUkVTRVQgICAgPSAnYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbSdcblxuICBBZmZpeC5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgdGFyZ2V0OiB3aW5kb3dcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICAgICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy4kdGFyZ2V0LmhlaWdodCgpXG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgdGhpcy5hZmZpeGVkID09ICd0b3AnKSByZXR1cm4gc2Nyb2xsVG9wIDwgb2Zmc2V0VG9wID8gJ3RvcCcgOiBmYWxzZVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCA9PSAnYm90dG9tJykge1xuICAgICAgaWYgKG9mZnNldFRvcCAhPSBudWxsKSByZXR1cm4gKHNjcm9sbFRvcCArIHRoaXMudW5waW4gPD0gcG9zaXRpb24udG9wKSA/IGZhbHNlIDogJ2JvdHRvbSdcbiAgICAgIHJldHVybiAoc2Nyb2xsVG9wICsgdGFyZ2V0SGVpZ2h0IDw9IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxpemluZyAgID0gdGhpcy5hZmZpeGVkID09IG51bGxcbiAgICB2YXIgY29sbGlkZXJUb3AgICAgPSBpbml0aWFsaXppbmcgPyBzY3JvbGxUb3AgOiBwb3NpdGlvbi50b3BcbiAgICB2YXIgY29sbGlkZXJIZWlnaHQgPSBpbml0aWFsaXppbmcgPyB0YXJnZXRIZWlnaHQgOiBoZWlnaHRcblxuICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCAmJiBzY3JvbGxUb3AgPD0gb2Zmc2V0VG9wKSByZXR1cm4gJ3RvcCdcbiAgICBpZiAob2Zmc2V0Qm90dG9tICE9IG51bGwgJiYgKGNvbGxpZGVyVG9wICsgY29sbGlkZXJIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0Qm90dG9tKSkgcmV0dXJuICdib3R0b20nXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGlubmVkT2Zmc2V0KSByZXR1cm4gdGhpcy5waW5uZWRPZmZzZXRcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKS5hZGRDbGFzcygnYWZmaXgnKVxuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKClcbiAgICB2YXIgcG9zaXRpb24gID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVxuICAgIHJldHVybiAodGhpcy5waW5uZWRPZmZzZXQgPSBwb3NpdGlvbi50b3AgLSBzY3JvbGxUb3ApXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dCgkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcyksIDEpXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHJldHVyblxuXG4gICAgdmFyIGhlaWdodCAgICAgICA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0ICAgICAgID0gdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wXG4gICAgdmFyIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b21cbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gTWF0aC5tYXgoJChkb2N1bWVudCkuaGVpZ2h0KCksICQoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KCkpXG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAnb2JqZWN0JykgICAgICAgICBvZmZzZXRCb3R0b20gPSBvZmZzZXRUb3AgPSBvZmZzZXRcbiAgICBpZiAodHlwZW9mIG9mZnNldFRvcCA9PSAnZnVuY3Rpb24nKSAgICBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wKHRoaXMuJGVsZW1lbnQpXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRCb3R0b20gPT0gJ2Z1bmN0aW9uJykgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0LmJvdHRvbSh0aGlzLiRlbGVtZW50KVxuXG4gICAgdmFyIGFmZml4ID0gdGhpcy5nZXRTdGF0ZShzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pXG5cbiAgICBpZiAodGhpcy5hZmZpeGVkICE9IGFmZml4KSB7XG4gICAgICBpZiAodGhpcy51bnBpbiAhPSBudWxsKSB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgJycpXG5cbiAgICAgIHZhciBhZmZpeFR5cGUgPSAnYWZmaXgnICsgKGFmZml4ID8gJy0nICsgYWZmaXggOiAnJylcbiAgICAgIHZhciBlICAgICAgICAgPSAkLkV2ZW50KGFmZml4VHlwZSArICcuYnMuYWZmaXgnKVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICB0aGlzLmFmZml4ZWQgPSBhZmZpeFxuICAgICAgdGhpcy51bnBpbiA9IGFmZml4ID09ICdib3R0b20nID8gdGhpcy5nZXRQaW5uZWRPZmZzZXQoKSA6IG51bGxcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoQWZmaXguUkVTRVQpXG4gICAgICAgIC5hZGRDbGFzcyhhZmZpeFR5cGUpXG4gICAgICAgIC50cmlnZ2VyKGFmZml4VHlwZS5yZXBsYWNlKCdhZmZpeCcsICdhZmZpeGVkJykgKyAnLmJzLmFmZml4JylcbiAgICB9XG5cbiAgICBpZiAoYWZmaXggPT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KHtcbiAgICAgICAgdG9wOiBzY3JvbGxIZWlnaHQgLSBoZWlnaHQgLSBvZmZzZXRCb3R0b21cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cblxuICAvLyBBRkZJWCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5hZmZpeCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYWZmaXgnLCAoZGF0YSA9IG5ldyBBZmZpeCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWZmaXhcblxuICAkLmZuLmFmZml4ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWZmaXguQ29uc3RydWN0b3IgPSBBZmZpeFxuXG5cbiAgLy8gQUZGSVggTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFmZml4Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hZmZpeCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFGRklYIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhID0gJHNweS5kYXRhKClcblxuICAgICAgZGF0YS5vZmZzZXQgPSBkYXRhLm9mZnNldCB8fCB7fVxuXG4gICAgICBpZiAoZGF0YS5vZmZzZXRCb3R0b20gIT0gbnVsbCkgZGF0YS5vZmZzZXQuYm90dG9tID0gZGF0YS5vZmZzZXRCb3R0b21cbiAgICAgIGlmIChkYXRhLm9mZnNldFRvcCAgICAhPSBudWxsKSBkYXRhLm9mZnNldC50b3AgICAgPSBkYXRhLm9mZnNldFRvcFxuXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCBkYXRhKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDEgMiAzIDQgNSA2IDdcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFsnZ2V0dGV4dENhdGFsb2cnLCAnJHEnLCAnZ2V0dGV4dCcsZnVuY3Rpb24gKGdldHRleHRDYXRhbG9nLCAkcSxnZXR0ZXh0KSB7XG4gICAgdmFyIGdldExhbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IG51bGw7XG4gICAgICAgIGdrQ2xpZW50SW50ZXJmYWNlLmdldExhbmd1YWdlKGZ1bmN0aW9uKGNsaWVudExhblR5cGUpIHtcbiAgICAgICAgICAgIGxhbmd1YWdlID0gZ2tDbGllbnRJbnRlcmZhY2UuZ2V0TGFuZ3VhZ2VLZXkoY2xpZW50TGFuVHlwZS50eXBlKTtcblxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3poX2NuJykgPj0gMCB8fCBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3poLWNuJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxhbmd1YWdlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShsYW5ndWFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy9nZXRMYW5nKCkudGhlbihmdW5jdGlvbihsYW5nKSB7XG4gICAgLy8gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAgLy8gICAgICAgIGhlYWRlcnM6IHtcbiAgICAvLyAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiBsYW5nXG4gICAgLy8gICAgICAgIH1cbiAgICAvLyAgICB9KTtcbiAgICAvL30pO1xuXG4gICAgdmFyIGdrSTE4TiA9IHtcbiAgICAgICAgZ2V0VGV4dDogZnVuY3Rpb24gKHN0clRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXh0Q2F0YWxvZy5nZXRTdHJpbmcoc3RyVGV4dClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVwbGFjZVRleHQ6IGZ1bmN0aW9uIChzdHJUZXh0LCByZXBsYWNlU3RyQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0dGV4dENhdGFsb2cuZ2V0U3RyaW5nKHN0clRleHQsIHJlcGxhY2VTdHJBcnIpXG4gICAgICAgIH0sXG4gICAgICAgIGdldExhbmc6IGdldExhbmcsXG4gICAgICAgIHNldExvY2FsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL2dldHRleHRDYXRhbG9nLmRlYnVnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGFuZygpLnRoZW4oZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldHRleHRDYXRhbG9nLmN1cnJlbnRMYW5ndWFnZSA9IGxhbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZTpmdW5jdGlvbihzdHJUZXh0KXtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dChnZXR0ZXh0KHN0clRleHQpKVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBna0kxOE47XG59XVxuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zZXJ2aWNlL2drSTE4Ti5qc1xuICoqIG1vZHVsZSBpZCA9IDMwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAxIDIgMyA1IDZcbiAqKi8iLCJcbm1vZHVsZS5leHBvcnRzID0gXCJnb2t1YWkuaHRtbFwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9nb2t1YWkuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDMwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAyXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL3NyYy9jc3MvZGF0ZXRpbWVwaWNrZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMzA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDIgM1xuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9zdHlsZXMvaW5kZXguc2Nzc1xuICoqIG1vZHVsZSBpZCA9IDMwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAyXG4gKiovIiwiLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMS40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wb3NpdGlvbi9cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59KGZ1bmN0aW9uKCAkICkge1xuKGZ1bmN0aW9uKCkge1xuXG4kLnVpID0gJC51aSB8fCB7fTtcblxudmFyIGNhY2hlZFNjcm9sbGJhcldpZHRoLCBzdXBwb3J0c09mZnNldEZyYWN0aW9ucyxcblx0bWF4ID0gTWF0aC5tYXgsXG5cdGFicyA9IE1hdGguYWJzLFxuXHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdHJob3Jpem9udGFsID0gL2xlZnR8Y2VudGVyfHJpZ2h0Lyxcblx0cnZlcnRpY2FsID0gL3RvcHxjZW50ZXJ8Ym90dG9tLyxcblx0cm9mZnNldCA9IC9bXFwrXFwtXVxcZCsoXFwuW1xcZF0rKT8lPy8sXG5cdHJwb3NpdGlvbiA9IC9eXFx3Ky8sXG5cdHJwZXJjZW50ID0gLyUkLyxcblx0X3Bvc2l0aW9uID0gJC5mbi5wb3NpdGlvbjtcblxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyggb2Zmc2V0cywgd2lkdGgsIGhlaWdodCApIHtcblx0cmV0dXJuIFtcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAwIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMCBdICkgPyB3aWR0aCAvIDEwMCA6IDEgKSxcblx0XHRwYXJzZUZsb2F0KCBvZmZzZXRzWyAxIF0gKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMSBdICkgPyBoZWlnaHQgLyAxMDAgOiAxIClcblx0XTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3MoIGVsZW1lbnQsIHByb3BlcnR5ICkge1xuXHRyZXR1cm4gcGFyc2VJbnQoICQuY3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApLCAxMCApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoIGVsZW0gKSB7XG5cdHZhciByYXcgPSBlbGVtWzBdO1xuXHRpZiAoIHJhdy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IDAsIGxlZnQ6IDAgfVxuXHRcdH07XG5cdH1cblx0aWYgKCAkLmlzV2luZG93KCByYXcgKSApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdG9mZnNldDogeyB0b3A6IGVsZW0uc2Nyb2xsVG9wKCksIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpIH1cblx0XHR9O1xuXHR9XG5cdGlmICggcmF3LnByZXZlbnREZWZhdWx0ICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdG9mZnNldDogeyB0b3A6IHJhdy5wYWdlWSwgbGVmdDogcmF3LnBhZ2VYIH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0d2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdGhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdG9mZnNldDogZWxlbS5vZmZzZXQoKVxuXHR9O1xufVxuXG4kLnBvc2l0aW9uID0ge1xuXHRzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHRcdH1cblx0XHR2YXIgdzEsIHcyLFxuXHRcdFx0ZGl2ID0gJCggXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6aGlkZGVuOyc+PGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVswXTtcblxuXHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCBkaXYgKTtcblx0XHR3MSA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXHRcdGRpdi5jc3MoIFwib3ZlcmZsb3dcIiwgXCJzY3JvbGxcIiApO1xuXG5cdFx0dzIgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblxuXHRcdGlmICggdzEgPT09IHcyICkge1xuXHRcdFx0dzIgPSBkaXZbMF0uY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0ZGl2LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHcxIC0gdzIpO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbMF0uc2Nyb2xsV2lkdGggKSxcblx0XHRcdGhhc092ZXJmbG93WSA9IG92ZXJmbG93WSA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WSA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLmhlaWdodCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbEhlaWdodCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogaGFzT3ZlcmZsb3dYID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMFxuXHRcdH07XG5cdH0sXG5cdGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB3aXRoaW5FbGVtZW50ID0gJCggZWxlbWVudCB8fCB3aW5kb3cgKSxcblx0XHRcdGlzV2luZG93ID0gJC5pc1dpbmRvdyggd2l0aGluRWxlbWVudFswXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IHdpdGhpbkVsZW1lbnQub2Zmc2V0KCkgfHwgeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXG5cdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgMS42Lnhcblx0XHRcdC8vIGpRdWVyeSAxLjYgZG9lc24ndCBzdXBwb3J0IC5vdXRlcldpZHRoL0hlaWdodCgpIG9uIGRvY3VtZW50cyBvciB3aW5kb3dzXG5cdFx0XHR3aWR0aDogaXNXaW5kb3cgfHwgaXNEb2N1bWVudCA/IHdpdGhpbkVsZW1lbnQud2lkdGgoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiBpc1dpbmRvdyB8fCBpc0RvY3VtZW50ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdH1cbn07XG5cbiQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0aWYgKCAhb3B0aW9ucyB8fCAhb3B0aW9ucy5vZiApIHtcblx0XHRyZXR1cm4gX3Bvc2l0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdC8vIG1ha2UgYSBjb3B5LCB3ZSBkb24ndCB3YW50IHRvIG1vZGlmeSBhcmd1bWVudHNcblx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciBhdE9mZnNldCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0T2Zmc2V0LCBiYXNlUG9zaXRpb24sIGRpbWVuc2lvbnMsXG5cdFx0dGFyZ2V0ID0gJCggb3B0aW9ucy5vZiApLFxuXHRcdHdpdGhpbiA9ICQucG9zaXRpb24uZ2V0V2l0aGluSW5mbyggb3B0aW9ucy53aXRoaW4gKSxcblx0XHRzY3JvbGxJbmZvID0gJC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKCB3aXRoaW4gKSxcblx0XHRjb2xsaXNpb24gPSAoIG9wdGlvbnMuY29sbGlzaW9uIHx8IFwiZmxpcFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0b2Zmc2V0cyA9IHt9O1xuXG5cdGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKCB0YXJnZXQgKTtcblx0aWYgKCB0YXJnZXRbMF0ucHJldmVudERlZmF1bHQgKSB7XG5cdFx0Ly8gZm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXHQvLyBjbG9uZSB0byByZXVzZSBvcmlnaW5hbCB0YXJnZXRPZmZzZXQgbGF0ZXJcblx0YmFzZVBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCB0YXJnZXRPZmZzZXQgKTtcblxuXHQvLyBmb3JjZSBteSBhbmQgYXQgdG8gaGF2ZSB2YWxpZCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbnNcblx0Ly8gaWYgYSB2YWx1ZSBpcyBtaXNzaW5nIG9yIGludmFsaWQsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGNlbnRlclxuXHQkLmVhY2goIFsgXCJteVwiLCBcImF0XCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9ICggb3B0aW9uc1sgdGhpcyBdIHx8IFwiXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRcdGhvcml6b250YWxPZmZzZXQsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldDtcblxuXHRcdGlmICggcG9zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyByZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0pO1xuXG5cdC8vIG5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xsaXNpb25Qb3NpdGlvbiwgdXNpbmcsXG5cdFx0XHRlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0ZWxlbVdpZHRoID0gZWxlbS5vdXRlcldpZHRoKCksXG5cdFx0XHRlbGVtSGVpZ2h0ID0gZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdFx0bWFyZ2luTGVmdCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0bWFyZ2luVG9wID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luVG9wXCIgKSxcblx0XHRcdGNvbGxpc2lvbldpZHRoID0gZWxlbVdpZHRoICsgbWFyZ2luTGVmdCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblJpZ2h0XCIgKSArIHNjcm9sbEluZm8ud2lkdGgsXG5cdFx0XHRjb2xsaXNpb25IZWlnaHQgPSBlbGVtSGVpZ2h0ICsgbWFyZ2luVG9wICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luQm90dG9tXCIgKSArIHNjcm9sbEluZm8uaGVpZ2h0LFxuXHRcdFx0cG9zaXRpb24gPSAkLmV4dGVuZCgge30sIGJhc2VQb3NpdGlvbiApLFxuXHRcdFx0bXlPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLm15LCBlbGVtLm91dGVyV2lkdGgoKSwgZWxlbS5vdXRlckhlaWdodCgpICk7XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJyaWdodFwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGg7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGggLyAyO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5teVsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdFx0cG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXRbIDAgXTtcblx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXRbIDEgXTtcblxuXHRcdC8vIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBmcmFjdGlvbnMsIHRoZW4gcm91bmQgZm9yIGNvbnNpc3RlbnQgcmVzdWx0c1xuXHRcdGlmICggIXN1cHBvcnRzT2Zmc2V0RnJhY3Rpb25zICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCA9IHJvdW5kKCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHRwb3NpdGlvbi50b3AgPSByb3VuZCggcG9zaXRpb24udG9wICk7XG5cdFx0fVxuXG5cdFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XG5cdFx0XHRtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuXHRcdFx0bWFyZ2luVG9wOiBtYXJnaW5Ub3Bcblx0XHR9O1xuXG5cdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBkaXIgKSB7XG5cdFx0XHRpZiAoICQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF0gKSB7XG5cdFx0XHRcdCQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF1bIGRpciBdKCBwb3NpdGlvbiwge1xuXHRcdFx0XHRcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcblx0XHRcdFx0XHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcblx0XHRcdFx0XHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXG5cdFx0XHRcdFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXG5cdFx0XHRcdFx0b2Zmc2V0OiBbIGF0T2Zmc2V0WyAwIF0gKyBteU9mZnNldFsgMCBdLCBhdE9mZnNldCBbIDEgXSArIG15T2Zmc2V0WyAxIF0gXSxcblx0XHRcdFx0XHRteTogb3B0aW9ucy5teSxcblx0XHRcdFx0XHRhdDogb3B0aW9ucy5hdCxcblx0XHRcdFx0XHR3aXRoaW46IHdpdGhpbixcblx0XHRcdFx0XHRlbGVtOiBlbGVtXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCBvcHRpb25zLnVzaW5nICkge1xuXHRcdFx0Ly8gYWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcblx0XHRcdHVzaW5nID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcblx0XHRcdFx0XHR0b3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHRhcmdldEhlaWdodCAtIGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0ZmVlZGJhY2sgPSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0YXJnZXRPZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogdGFyZ2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtSGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXCJsZWZ0XCIgOiBsZWZ0ID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFwidG9wXCIgOiB0b3AgPiAwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyggbGVmdCArIHJpZ2h0ICkgPCB0YXJnZXRXaWR0aCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5ob3Jpem9udGFsID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRhcmdldEhlaWdodCA8IGVsZW1IZWlnaHQgJiYgYWJzKCB0b3AgKyBib3R0b20gKSA8IHRhcmdldEhlaWdodCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXgoIGFicyggbGVmdCApLCBhYnMoIHJpZ2h0ICkgKSA+IG1heCggYWJzKCB0b3AgKSwgYWJzKCBib3R0b20gKSApICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwiaG9yaXpvbnRhbFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwidmVydGljYWxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIHRoaXMsIHByb3BzLCBmZWVkYmFjayApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbGVtLm9mZnNldCggJC5leHRlbmQoIHBvc2l0aW9uLCB7IHVzaW5nOiB1c2luZyB9ICkgKTtcblx0fSk7XG59O1xuXG4kLnVpLnBvc2l0aW9uID0ge1xuXHRmaXQ6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcblx0XHRcdFx0b3ZlckxlZnQgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJSaWdodDtcblxuXHRcdFx0Ly8gZWxlbWVudCBpcyB3aWRlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbldpZHRoID4gb3V0ZXJXaWR0aCApIHtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgbGVmdCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgb3ZlckxlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0IC0gbmV3T3ZlclJpZ2h0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgJiYgb3ZlckxlZnQgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgbGVmdCAtPiBhbGlnbiB3aXRoIGxlZnQgZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckxlZnQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0O1xuXHRcdFx0Ly8gdG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gb3ZlclJpZ2h0O1xuXHRcdFx0Ly8gYWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBlbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSB0b3Agb2Ygd2l0aGluXG5cdFx0XHRcdGlmICggb3ZlclRvcCA+IDAgJiYgb3ZlckJvdHRvbSA8PSAwICkge1xuXHRcdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBvdmVyVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCAmJiBvdmVyVG9wIDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggdG9wIGFuZCBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyVG9wID4gb3ZlckJvdHRvbSApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIHRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblx0XHRcdC8vIHRvbyBmYXIgZG93biAtPiBhbGlnbiB3aXRoIGJvdHRvbSBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24udG9wIC09IG92ZXJCb3R0b207XG5cdFx0XHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24udG9wID0gbWF4KCBwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG15T2Zmc2V0ID0gZGF0YS5teVsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLm15WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDAgXSxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0LFxuXHRcdFx0XHRuZXdPdmVyTGVmdDtcblxuXHRcdFx0aWYgKCBvdmVyTGVmdCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0IC0gb2Zmc2V0TGVmdDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyTGVmdCA+IDAgfHwgYWJzKCBuZXdPdmVyTGVmdCApIDwgb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQudG9wICsgd2l0aGluLnNjcm9sbFRvcCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQgPSB3aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRvZmZzZXRUb3AgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxuXHRcdFx0XHRvdmVyVG9wID0gY29sbGlzaW9uUG9zVG9wIC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHRvdmVyQm90dG9tID0gY29sbGlzaW9uUG9zVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIG9mZnNldFRvcCxcblx0XHRcdFx0dG9wID0gZGF0YS5teVsgMSBdID09PSBcInRvcFwiLFxuXHRcdFx0XHRteU9mZnNldCA9IHRvcCA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdGRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDEgXSA9PT0gXCJ0b3BcIiA/XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0b2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsgMSBdLFxuXHRcdFx0XHRuZXdPdmVyVG9wLFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXHRcdFx0aWYgKCBvdmVyVG9wIDwgMCApIHtcblx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMoIG92ZXJUb3AgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggbmV3T3ZlclRvcCA+IDAgfHwgYWJzKCBuZXdPdmVyVG9wICkgPCBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwZml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBmcmFjdGlvbiBzdXBwb3J0IHRlc3RcbihmdW5jdGlvbigpIHtcblx0dmFyIHRlc3RFbGVtZW50LCB0ZXN0RWxlbWVudFBhcmVudCwgdGVzdEVsZW1lbnRTdHlsZSwgb2Zmc2V0TGVmdCwgaSxcblx0XHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYm9keVwiIClbIDAgXSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly9DcmVhdGUgYSBcImZha2UgYm9keVwiIGZvciB0ZXN0aW5nIGJhc2VkIG9uIG1ldGhvZCB1c2VkIGluIGpRdWVyeS5zdXBwb3J0XG5cdHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggYm9keSA/IFwiZGl2XCIgOiBcImJvZHlcIiApO1xuXHR0ZXN0RWxlbWVudFN0eWxlID0ge1xuXHRcdHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG5cdFx0d2lkdGg6IDAsXG5cdFx0aGVpZ2h0OiAwLFxuXHRcdGJvcmRlcjogMCxcblx0XHRtYXJnaW46IDAsXG5cdFx0YmFja2dyb3VuZDogXCJub25lXCJcblx0fTtcblx0aWYgKCBib2R5ICkge1xuXHRcdCQuZXh0ZW5kKCB0ZXN0RWxlbWVudFN0eWxlLCB7XG5cdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0bGVmdDogXCItMTAwMHB4XCIsXG5cdFx0XHR0b3A6IFwiLTEwMDBweFwiXG5cdFx0fSk7XG5cdH1cblx0Zm9yICggaSBpbiB0ZXN0RWxlbWVudFN0eWxlICkge1xuXHRcdHRlc3RFbGVtZW50LnN0eWxlWyBpIF0gPSB0ZXN0RWxlbWVudFN0eWxlWyBpIF07XG5cdH1cblx0dGVzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHR0ZXN0RWxlbWVudFBhcmVudCA9IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHR0ZXN0RWxlbWVudFBhcmVudC5pbnNlcnRCZWZvcmUoIHRlc3RFbGVtZW50LCB0ZXN0RWxlbWVudFBhcmVudC5maXJzdENoaWxkICk7XG5cblx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMTAuNzQzMjIyMnB4O1wiO1xuXG5cdG9mZnNldExlZnQgPSAkKCBkaXYgKS5vZmZzZXQoKS5sZWZ0O1xuXHRzdXBwb3J0c09mZnNldEZyYWN0aW9ucyA9IG9mZnNldExlZnQgPiAxMCAmJiBvZmZzZXRMZWZ0IDwgMTE7XG5cblx0dGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcblx0dGVzdEVsZW1lbnRQYXJlbnQucmVtb3ZlQ2hpbGQoIHRlc3RFbGVtZW50ICk7XG59KSgpO1xuXG59KSgpO1xuXG5yZXR1cm4gJC51aS5wb3NpdGlvbjtcblxufSkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9qcXVlcnktY29udGV4dG1lbnUvZGlzdC9qcXVlcnkudWkucG9zaXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyIsIi8qIVxyXG4gKiBqUXVlcnkgY29udGV4dE1lbnUgdjEuMTAuMiAtIFBsdWdpbiBmb3Igc2ltcGxlIGNvbnRleHRNZW51IGhhbmRsaW5nXHJcbiAqXHJcbiAqIFZlcnNpb246IHYxLjEwLjJcclxuICpcclxuICogQXV0aG9yczogQmrDtnJuIEJyYWxhIChTV0lTLm5sKSwgUm9kbmV5IFJlaG0sIEFkZHkgT3NtYW5pIChwYXRjaGVzIGZvciBGRilcclxuICogV2ViOiBodHRwOi8vc3dpc25sLmdpdGh1Yi5pby9qUXVlcnktY29udGV4dE1lbnUvXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE1IFNXSVMgQlYgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlclxyXG4gKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcclxuICogICBHUEwgdjMgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0dQTC0zLjBcclxuICpcclxuICogRGF0ZTogMjAxNS0xMC0yOFQxNToxNTowMC4zMzhaXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gTm9kZSAvIENvbW1vbkpTXHJcbiAgICAgICAgZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscy5cclxuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XHJcbiAgICB9XHJcbn0pKGZ1bmN0aW9uICgkKSB7XHJcblxyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8vIFRPRE86IC1cclxuICAgIC8vIEFSSUEgc3R1ZmY6IG1lbnVpdGVtLCBtZW51aXRlbWNoZWNrYm94IHVuZCBtZW51aXRlbXJhZGlvXHJcbiAgICAvLyBjcmVhdGUgPG1lbnU+IHN0cnVjdHVyZSBpZiAkLnN1cHBvcnRbaHRtbENvbW1hbmQgfHwgaHRtbE1lbnVpdGVtXSBhbmQgIW9wdC5kaXNhYmxlTmF0aXZlXHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIGh0bWw1IGNvbXBhdGliaWxpdHlcclxuICAgICQuc3VwcG9ydC5odG1sTWVudWl0ZW0gPSAoJ0hUTUxNZW51SXRlbUVsZW1lbnQnIGluIHdpbmRvdyk7XHJcbiAgICAkLnN1cHBvcnQuaHRtbENvbW1hbmQgPSAoJ0hUTUxDb21tYW5kRWxlbWVudCcgaW4gd2luZG93KTtcclxuICAgICQuc3VwcG9ydC5ldmVudFNlbGVjdHN0YXJ0ID0gKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xyXG4gICAgLyogLy8gc2hvdWxkIHRoZSBuZWVkIGFyaXNlLCB0ZXN0IGZvciBjc3MgdXNlci1zZWxlY3RcclxuICAgICAkLnN1cHBvcnQuY3NzVXNlclNlbGVjdCA9IChmdW5jdGlvbigpe1xyXG4gICAgIHZhciB0ID0gZmFsc2UsXHJcbiAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAkLmVhY2goJ01venxXZWJraXR8S2h0bWx8T3xtc3xJY2FifCcuc3BsaXQoJ3wnKSwgZnVuY3Rpb24oaSwgcHJlZml4KSB7XHJcbiAgICAgdmFyIHByb3BDQyA9IHByZWZpeCArIChwcmVmaXggPyAnVScgOiAndScpICsgJ3NlclNlbGVjdCcsXHJcbiAgICAgcHJvcCA9IChwcmVmaXggPyAoJy0nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkgKyAnLScpIDogJycpICsgJ3VzZXItc2VsZWN0JztcclxuXHJcbiAgICAgZS5zdHlsZS5jc3NUZXh0ID0gcHJvcCArICc6IHRleHQ7JztcclxuICAgICBpZiAoZS5zdHlsZVtwcm9wQ0NdID09ICd0ZXh0Jykge1xyXG4gICAgIHQgPSB0cnVlO1xyXG4gICAgIHJldHVybiBmYWxzZTtcclxuICAgICB9XHJcblxyXG4gICAgIHJldHVybiB0cnVlO1xyXG4gICAgIH0pO1xyXG5cclxuICAgICByZXR1cm4gdDtcclxuICAgICB9KSgpO1xyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCEkLnVpIHx8ICEkLndpZGdldCkge1xyXG4gICAgICAgIC8vIGR1Y2sgcHVuY2ggJC5jbGVhbkRhdGEgbGlrZSBqUXVlcnlVSSBkb2VzIHRvIGdldCB0aGF0IHJlbW92ZSBldmVudFxyXG4gICAgICAgICQuY2xlYW5EYXRhID0gKGZ1bmN0aW9uIChvcmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudHMsIGVsZW0sIGk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSAkLl9kYXRhKGVsZW0sICdldmVudHMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMucmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGVsZW0pLnRyaWdnZXJIYW5kbGVyKCdyZW1vdmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcmlnKGVsZW1zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgkLmNsZWFuRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIC8vIGN1cnJlbnRseSBhY3RpdmUgY29udGV4dE1lbnUgdHJpZ2dlclxyXG4gICAgICAgICRjdXJyZW50VHJpZ2dlciA9IG51bGwsXHJcbiAgICAvLyBpcyBjb250ZXh0TWVudSBpbml0aWFsaXplZCB3aXRoIGF0IGxlYXN0IG9uZSBtZW51P1xyXG4gICAgICAgIGluaXRpYWxpemVkID0gZmFsc2UsXHJcbiAgICAvLyB3aW5kb3cgaGFuZGxlXHJcbiAgICAgICAgJHdpbiA9ICQod2luZG93KSxcclxuICAgIC8vIG51bWJlciBvZiByZWdpc3RlcmVkIG1lbnVzXHJcbiAgICAgICAgY291bnRlciA9IDAsXHJcbiAgICAvLyBtYXBwaW5nIHNlbGVjdG9yIHRvIG5hbWVzcGFjZVxyXG4gICAgICAgIG5hbWVzcGFjZXMgPSB7fSxcclxuICAgIC8vIG1hcHBpbmcgbmFtZXNwYWNlIHRvIG9wdGlvbnNcclxuICAgICAgICBtZW51cyA9IHt9LFxyXG4gICAgLy8gY3VzdG9tIGNvbW1hbmQgdHlwZSBoYW5kbGVyc1xyXG4gICAgICAgIHR5cGVzID0ge30sXHJcbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICAvLyBzZWxlY3RvciBvZiBjb250ZXh0TWVudSB0cmlnZ2VyXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiBudWxsLFxyXG4gICAgICAgICAgICAvLyB3aGVyZSB0byBhcHBlbmQgdGhlIG1lbnUgdG9cclxuICAgICAgICAgICAgYXBwZW5kVG86IG51bGwsXHJcbiAgICAgICAgICAgIC8vIG1ldGhvZCB0byB0cmlnZ2VyIGNvbnRleHQgbWVudSBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJob3ZlclwiXVxyXG4gICAgICAgICAgICB0cmlnZ2VyOiAncmlnaHQnLFxyXG4gICAgICAgICAgICAvLyBoaWRlIG1lbnUgd2hlbiBtb3VzZSBsZWF2ZXMgdHJpZ2dlciAvIG1lbnUgZWxlbWVudHNcclxuICAgICAgICAgICAgYXV0b0hpZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBtcyB0byB3YWl0IGJlZm9yZSBzaG93aW5nIGEgaG92ZXItdHJpZ2dlcmVkIGNvbnRleHQgbWVudVxyXG4gICAgICAgICAgICBkZWxheTogMjAwLFxyXG4gICAgICAgICAgICAvLyBmbGFnIGRlbm90aW5nIGlmIGEgc2Vjb25kIHRyaWdnZXIgc2hvdWxkIHNpbXBseSBtb3ZlICh0cnVlKSBvciByZWJ1aWxkIChmYWxzZSkgYW4gb3BlbiBtZW51XHJcbiAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlIHRyaWdnZXIgaGFwcGVuZWQgb24gb25lIG9mIHRoZSB0cmlnZ2VyLWVsZW1lbnQncyBjaGlsZCBub2Rlc1xyXG4gICAgICAgICAgICByZXBvc2l0aW9uOiB0cnVlLFxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCBjbGFzc25hbWUgY29uZmlndXJhdGlvbiB0byBiZSBhYmxlIGF2b2lkIGNvbmZsaWN0cyBpbiBmcmFtZXdvcmtzXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMgOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgaG92ZXI6ICdob3ZlcicsIC8vIEl0ZW0gaG92ZXJcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnLCAvLyBJdGVtIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAndmlzaWJsZScsIC8vIEl0ZW0gdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgbm90U2VsZWN0YWJsZTogJ25vdC1zZWxlY3RhYmxlJywgLy8gSXRlbSBub3Qgc2VsZWN0YWJsZVxyXG5cclxuICAgICAgICAgICAgICAgIGljb246ICdpY29uJyxcclxuICAgICAgICAgICAgICAgIGljb25FZGl0OiAnaWNvbi1lZGl0JyxcclxuICAgICAgICAgICAgICAgIGljb25DdXQ6ICdpY29uLWN1dCcsXHJcbiAgICAgICAgICAgICAgICBpY29uQ29weTogJ2ljb24tY29weScsXHJcbiAgICAgICAgICAgICAgICBpY29uUGFzdGU6ICdpY29uLXBhc3RlJyxcclxuICAgICAgICAgICAgICAgIGljb25EZWxldGU6ICdpY29uLWRlbGV0ZScsXHJcbiAgICAgICAgICAgICAgICBpY29uQWRkOiAnaWNvbi1hZGQnLFxyXG4gICAgICAgICAgICAgICAgaWNvblF1aXQ6ICdpY29uLXF1aXQnXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgcG9zaXRpb24gdG8gc2hvdyBtZW51IGF0XHJcbiAgICAgICAgICAgIGRldGVybWluZVBvc2l0aW9uOiBmdW5jdGlvbiAoJG1lbnUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBsb3dlciBtaWRkbGUgb2YgdGhlIHRyaWdnZXIgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCQudWkgJiYgJC51aS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC5wb3NpdGlvbigpIGlzIHByb3ZpZGVkIGFzIGEgalF1ZXJ5IFVJIHV0aWxpdHlcclxuICAgICAgICAgICAgICAgICAgICAvLyAoLi4uYW5kIGl0IHdvbid0IHdvcmsgb24gaGlkZGVuIGVsZW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICRtZW51LmNzcygnZGlzcGxheScsICdibG9jaycpLnBvc2l0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXk6ICdjZW50ZXIgdG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXQ6ICdjZW50ZXIgYm90dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Y6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogJzAgNScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogJ2ZpdCdcclxuICAgICAgICAgICAgICAgICAgICB9KS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgY29udGV4dE1lbnUgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQudG9wICs9IHRoaXMub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQubGVmdCArPSB0aGlzLm91dGVyV2lkdGgoKSAvIDIgLSAkbWVudS5vdXRlcldpZHRoKCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICRtZW51LmNzcyhvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtZW51XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAob3B0LCB4LCB5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGNvbnRleHRNZW51IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXggJiYgIXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHQuZGV0ZXJtaW5lUG9zaXRpb24uY2FsbCh0aGlzLCBvcHQuJG1lbnUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gJ21haW50YWluJyAmJiB5ID09PSAnbWFpbnRhaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8geCBhbmQgeSBtdXN0IG5vdCBiZSBjaGFuZ2VkIChhZnRlciByZS1zaG93IG9uIGNvbW1hbmQgY2xpY2spXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0LiRtZW51LnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHggYW5kIHkgYXJlIGdpdmVuIChieSBtb3VzZSBldmVudClcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB7dG9wOiB5LCBsZWZ0OiB4fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IG9mZnNldCBpZiB2aWV3cG9ydCBkZW1hbmRzIGl0XHJcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gJHdpbi5zY3JvbGxUb3AoKSArICR3aW4uaGVpZ2h0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAkd2luLnNjcm9sbExlZnQoKSArICR3aW4ud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHQuJG1lbnUub3V0ZXJIZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdC4kbWVudS5vdXRlcldpZHRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldC50b3AgKyBoZWlnaHQgPiBib3R0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQudG9wIC09IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0LnRvcCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQudG9wID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0LmxlZnQgKyB3aWR0aCA+IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LmxlZnQgLT0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldC5sZWZ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldC5sZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBvcHQuJG1lbnUuY3NzKG9mZnNldCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzdWItbWVudVxyXG4gICAgICAgICAgICBwb3NpdGlvblN1Ym1lbnU6IGZ1bmN0aW9uICgkbWVudSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCQudWkgJiYgJC51aS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC5wb3NpdGlvbigpIGlzIHByb3ZpZGVkIGFzIGEgalF1ZXJ5IFVJIHV0aWxpdHlcclxuICAgICAgICAgICAgICAgICAgICAvLyAoLi4uYW5kIGl0IHdvbid0IHdvcmsgb24gaGlkZGVuIGVsZW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICRtZW51LmNzcygnZGlzcGxheScsICdibG9jaycpLnBvc2l0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXk6ICdsZWZ0IHRvcCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0OiAncmlnaHQgdG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Y6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogJ2ZsaXBmaXQgZml0J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNzcygnZGlzcGxheScsICcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGNvbnRleHRNZW51IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLm91dGVyV2lkdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgJG1lbnUuY3NzKG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIG9mZnNldCB0byBhZGQgdG8gekluZGV4XHJcbiAgICAgICAgICAgIHpJbmRleDogMSxcclxuICAgICAgICAgICAgLy8gc2hvdyBoaWRlIGFuaW1hdGlvbiBzZXR0aW5nc1xyXG4gICAgICAgICAgICBhbmltYXRpb246IHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MCxcclxuICAgICAgICAgICAgICAgIHNob3c6ICdzbGlkZURvd24nLFxyXG4gICAgICAgICAgICAgICAgaGlkZTogJ3NsaWRlVXAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGV2ZW50c1xyXG4gICAgICAgICAgICBldmVudHM6IHtcclxuICAgICAgICAgICAgICAgIHNob3c6ICQubm9vcCxcclxuICAgICAgICAgICAgICAgIGhpZGU6ICQubm9vcFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxyXG4gICAgICAgICAgICAvLyBsaXN0IG9mIGNvbnRleHRNZW51IGl0ZW1zXHJcbiAgICAgICAgICAgIGl0ZW1zOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAvLyBtb3VzZSBwb3NpdGlvbiBmb3IgaG92ZXIgYWN0aXZhdGlvblxyXG4gICAgICAgIGhvdmVyYWN0ID0ge1xyXG4gICAgICAgICAgICB0aW1lcjogbnVsbCxcclxuICAgICAgICAgICAgcGFnZVg6IG51bGwsXHJcbiAgICAgICAgICAgIHBhZ2VZOiBudWxsXHJcbiAgICAgICAgfSxcclxuICAgIC8vIGRldGVybWluZSB6SW5kZXhcclxuICAgICAgICB6aW5kZXggPSBmdW5jdGlvbiAoJHQpIHtcclxuICAgICAgICAgICAgdmFyIHppbiA9IDAsXHJcbiAgICAgICAgICAgICAgICAkdHQgPSAkdDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB6aW4gPSBNYXRoLm1heCh6aW4sIHBhcnNlSW50KCR0dC5jc3MoJ3otaW5kZXgnKSwgMTApIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgJHR0ID0gJHR0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEkdHQgfHwgISR0dC5sZW5ndGggfHwgJ2h0bWwgYm9keScuaW5kZXhPZigkdHQucHJvcCgnbm9kZU5hbWUnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHppbjtcclxuICAgICAgICB9LFxyXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICBoYW5kbGUgPSB7XHJcbiAgICAgICAgICAgIC8vIGFib3J0IGFueXRoaW5nXHJcbiAgICAgICAgICAgIGFib3J0ZXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBjb250ZXh0bWVudSBzaG93IGRpc3BhdGNoZXJcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgYWN0dWFsIGNvbnRleHQtbWVudSBpZiB3ZSBhcmUgdXNpbmcgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBhcyB0aGUgdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50cmlnZ2VyID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWJvcnQgbmF0aXZlLXRyaWdnZXJlZCBldmVudHMgdW5sZXNzIHdlJ3JlIHRyaWdnZXJpbmcgb24gcmlnaHQgY2xpY2tcclxuICAgICAgICAgICAgICAgIGlmICgoZS5kYXRhLnRyaWdnZXIgIT09ICdyaWdodCcgJiYgZS5kYXRhLnRyaWdnZXIgIT09ICdkZW1hbmQnKSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWJvcnQgZXZlbnQgaWYgbWVudSBpcyB2aXNpYmxlIGZvciB0aGlzIHRyaWdnZXJcclxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy5oYXNDbGFzcygnY29udGV4dC1tZW51LWFjdGl2ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghJHRoaXMuaGFzQ2xhc3MoJ2NvbnRleHQtbWVudS1kaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlb3JldGljYWxseSBuZWVkIHRvIGZpcmUgYSBzaG93IGV2ZW50IGF0IDxtZW51PlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2ludGVyYWN0aXZlLWVsZW1lbnRzLmh0bWwjY29udGV4dC1tZW51c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBldnQgPSBqUXVlcnkuRXZlbnQoXCJzaG93XCIsIHsgZGF0YTogZGF0YSwgcGFnZVg6IGUucGFnZVgsIHBhZ2VZOiBlLnBhZ2VZLCByZWxhdGVkVGFyZ2V0OiB0aGlzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZGF0YS4kbWVudS50cmlnZ2VyKGV2dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICRjdXJyZW50VHJpZ2dlciA9ICR0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuYnVpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWx0ID0gZS5kYXRhLmJ1aWxkKCRjdXJyZW50VHJpZ2dlciwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IGlmIGJ1aWxkKCkgcmV0dXJuZWQgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1aWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljYWxseSBidWlsZCBtZW51IG9uIGludm9jYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBlLmRhdGEsIGJ1aWx0IHx8IHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IGlmIHRoZXJlIGFyZSBubyBpdGVtcyB0byBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5kYXRhLml0ZW1zIHx8ICQuaXNFbXB0eU9iamVjdChlLmRhdGEuaXRlbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBqUXVlcnkgY2FwdHVyZXMgYW5kIGlnbm9yZXMgZXJyb3JzIGZyb20gZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsICdObyBpdGVtcyBzcGVjaWZpZWQgdG8gc2hvdyBpbiBjb250ZXh0TWVudScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gSXRlbXMgc3BlY2lmaWVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2tyZWZlcmVuY2UgZm9yIGN1c3RvbSBjb21tYW5kIHR5cGUgY3JlYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLiR0cmlnZ2VyID0gJGN1cnJlbnRUcmlnZ2VyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3AuY3JlYXRlKGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG93TWVudSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gZS5kYXRhLml0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihlLmRhdGEuaXRlbXNbaXRlbV0udmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gZS5kYXRhLml0ZW1zW2l0ZW1dLnZpc2libGUuY2FsbCgkKGUuY3VycmVudFRhcmdldCksIGl0ZW0sIGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLnZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9IGUuZGF0YS5pdGVtc1tpdGVtXS52aXNpYmxlID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01lbnUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93TWVudSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IG1lbnVcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2hvdy5jYWxsKCR0aGlzLCBlLmRhdGEsIGUucGFnZVgsIGUucGFnZVkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gY29udGV4dE1lbnUgbGVmdC1jbGljayB0cmlnZ2VyXHJcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICQodGhpcykudHJpZ2dlcigkLkV2ZW50KCdjb250ZXh0bWVudScsIHtkYXRhOiBlLmRhdGEsIHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWX0pKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gY29udGV4dE1lbnUgcmlnaHQtY2xpY2sgdHJpZ2dlclxyXG4gICAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBtb3VzZSBkb3duXHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGhpZGUgYW55IHByZXZpb3VzIG1lbnVzXHJcbiAgICAgICAgICAgICAgICBpZiAoJGN1cnJlbnRUcmlnZ2VyICYmICRjdXJyZW50VHJpZ2dlci5sZW5ndGggJiYgISRjdXJyZW50VHJpZ2dlci5pcygkdGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAkY3VycmVudFRyaWdnZXIuZGF0YSgnY29udGV4dE1lbnUnKS4kbWVudS50cmlnZ2VyKCdjb250ZXh0bWVudTpoaWRlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZhdGUgb24gcmlnaHQgY2xpY2tcclxuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICRjdXJyZW50VHJpZ2dlciA9ICR0aGlzLmRhdGEoJ2NvbnRleHRNZW51QWN0aXZlJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGNvbnRleHRNZW51IHJpZ2h0LWNsaWNrIHRyaWdnZXJcclxuICAgICAgICAgICAgbW91c2V1cDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNob3cgbWVudVxyXG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy5kYXRhKCdjb250ZXh0TWVudUFjdGl2ZScpICYmICRjdXJyZW50VHJpZ2dlciAmJiAkY3VycmVudFRyaWdnZXIubGVuZ3RoICYmICRjdXJyZW50VHJpZ2dlci5pcygkdGhpcykgJiYgISR0aGlzLmhhc0NsYXNzKCdjb250ZXh0LW1lbnUtZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICRjdXJyZW50VHJpZ2dlciA9ICR0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJC5FdmVudCgnY29udGV4dG1lbnUnLCB7ZGF0YTogZS5kYXRhLCBwYWdlWDogZS5wYWdlWCwgcGFnZVk6IGUucGFnZVl9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnY29udGV4dE1lbnVBY3RpdmUnKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gY29udGV4dE1lbnUgaG92ZXIgdHJpZ2dlclxyXG4gICAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAkcmVsYXRlZCA9ICQoZS5yZWxhdGVkVGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBpZiB3ZSdyZSBjb21pbmcgZnJvbSBhIG1lbnVcclxuICAgICAgICAgICAgICAgIGlmICgkcmVsYXRlZC5pcygnLmNvbnRleHQtbWVudS1saXN0JykgfHwgJHJlbGF0ZWQuY2xvc2VzdCgnLmNvbnRleHQtbWVudS1saXN0JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFib3J0IGlmIGEgbWVudSBpcyBzaG93blxyXG4gICAgICAgICAgICAgICAgaWYgKCRjdXJyZW50VHJpZ2dlciAmJiAkY3VycmVudFRyaWdnZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGhvdmVyYWN0LnBhZ2VYID0gZS5wYWdlWDtcclxuICAgICAgICAgICAgICAgIGhvdmVyYWN0LnBhZ2VZID0gZS5wYWdlWTtcclxuICAgICAgICAgICAgICAgIGhvdmVyYWN0LmRhdGEgPSBlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAkZG9jdW1lbnQub24oJ21vdXNlbW92ZS5jb250ZXh0TWVudVNob3cnLCBoYW5kbGUubW91c2Vtb3ZlKTtcclxuICAgICAgICAgICAgICAgIGhvdmVyYWN0LnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJhY3QudGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICRkb2N1bWVudC5vZmYoJ21vdXNlbW92ZS5jb250ZXh0TWVudVNob3cnKTtcclxuICAgICAgICAgICAgICAgICAgICAkY3VycmVudFRyaWdnZXIgPSAkdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCQuRXZlbnQoJ2NvbnRleHRtZW51Jywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBob3ZlcmFjdC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWDogaG92ZXJhY3QucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBob3ZlcmFjdC5wYWdlWVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5kZWxheSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGNvbnRleHRNZW51IGhvdmVyIHRyaWdnZXJcclxuICAgICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaG92ZXJhY3QucGFnZVggPSBlLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgaG92ZXJhY3QucGFnZVkgPSBlLnBhZ2VZO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBjb250ZXh0TWVudSBob3ZlciB0cmlnZ2VyXHJcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBpZiB3ZSdyZSBsZWF2aW5nIGZvciBhIG1lbnVcclxuICAgICAgICAgICAgICAgIHZhciAkcmVsYXRlZCA9ICQoZS5yZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICgkcmVsYXRlZC5pcygnLmNvbnRleHQtbWVudS1saXN0JykgfHwgJHJlbGF0ZWQuY2xvc2VzdCgnLmNvbnRleHQtbWVudS1saXN0JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyYWN0LnRpbWVyKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBob3ZlcmFjdC50aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGNsaWNrIG9uIGxheWVyIHRvIGhpZGUgY29udGV4dE1lbnVcclxuICAgICAgICAgICAgbGF5ZXJDbGljazogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9ICR0aGlzLmRhdGEoJ2NvbnRleHRNZW51Um9vdCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IGUuYnV0dG9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSBlLnBhZ2VYLFxyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBlLnBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgJHdpbmRvdztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlckFjdGlvbiA9ICgocm9vdC50cmlnZ2VyID09PSAnbGVmdCcgJiYgYnV0dG9uID09PSAwKSB8fCAocm9vdC50cmlnZ2VyID09PSAncmlnaHQnICYmIGJ1dHRvbiA9PT0gMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBlbGVtZW50IHRoYXQgd291bGQndmUgYmVlbiBjbGlja2VkLCB3YXNuJ3QgdGhlIGxheWVyIGluIHRoZSB3YXlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290LiRsYXllci5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCAtICR3aW4uc2Nyb2xsTGVmdCgpLCB5IC0gJHdpbi5zY3JvbGxUb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuJGxheWVyLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290LnJlcG9zaXRpb24gJiYgdHJpZ2dlckFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QuJHRyaWdnZXIuaXModGFyZ2V0KSB8fCByb290LiR0cmlnZ2VyLmhhcyh0YXJnZXQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QucG9zaXRpb24uY2FsbChyb290LiR0cmlnZ2VyLCByb290LCB4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSByb290LiR0cmlnZ2VyLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHRoaXMgbG9va3Mga2luZGEgYXdmdWwsIGl0J3MgdGhlIGJlc3Qgd2F5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyaWx5IGNhbGN1bGF0aW5nIGFueSBwb3NpdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldC50b3AgKz0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQudG9wIDw9IGUucGFnZVkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQubGVmdCArPSAkd2luZG93LnNjcm9sbExlZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0LmxlZnQgPD0gZS5wYWdlWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQuYm90dG9tID0gb2Zmc2V0LnRvcCArIHJvb3QuJHRyaWdnZXIub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldC5ib3R0b20gPj0gZS5wYWdlWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LnJpZ2h0ID0gb2Zmc2V0LmxlZnQgKyByb290LiR0cmlnZ2VyLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQucmlnaHQgPj0gZS5wYWdlWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LnBvc2l0aW9uLmNhbGwocm9vdC4kdHJpZ2dlciwgcm9vdCwgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRyaWdnZXJBY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC4kdHJpZ2dlci5vbmUoJ2NvbnRleHRtZW51OmhpZGRlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGFyZ2V0KS5jb250ZXh0TWVudSh7eDogeCwgeTogeX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuJG1lbnUudHJpZ2dlcignY29udGV4dG1lbnU6aGlkZScpO1xyXG4gICAgICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBrZXkgaGFuZGxlZCA6aG92ZXJcclxuICAgICAgICAgICAga2V5U3RvcDogZnVuY3Rpb24gKGUsIG9wdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBrZXk6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgZ2V0IHRoZSBkYXRhIGZyb20gJGN1cnJlbnRUcmlnZ2VyIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKCRjdXJyZW50VHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdCA9ICRjdXJyZW50VHJpZ2dlci5kYXRhKCdjb250ZXh0TWVudScpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6IC8vIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZS5rZXlTdG9wKGUsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGtleUNvZGUgaXMgWzM4ICh1cCldIG9yIFs5ICh0YWIpIHdpdGggc2hpZnRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gOSAmJiBlLnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQgJiYgb3B0LiRzZWxlY3RlZC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpLmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHQuJG1lbnUudHJpZ2dlcigncHJldmNvbW1hbmQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzggJiYgb3B0LiRzZWxlY3RlZC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpLnByb3AoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrYm94ZXMgZG9uJ3QgY2FwdHVyZSB0aGlzIGtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlICE9PSA5IHx8IGUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdC4kbWVudS50cmlnZ2VyKCdwcmV2Y29tbWFuZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb21pdHRpbmcgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSA5OiAvLyB0YWIgLSByZWFjaGVkIHRocm91Z2ggb21pdHRlZCBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOiAvLyBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZS5rZXlTdG9wKGUsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHQuJHNlbGVjdGVkICYmIG9wdC4kc2VsZWN0ZWQuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKS5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LiRtZW51LnRyaWdnZXIoJ25leHRjb21tYW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDQwICYmIG9wdC4kc2VsZWN0ZWQuZmluZCgnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnKS5wcm9wKCd0eXBlJykgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVja2JveGVzIGRvbid0IGNhcHR1cmUgdGhpcyBrZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LiRtZW51LnRyaWdnZXIoJ25leHRjb21tYW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6IC8vIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmtleVN0b3AoZSwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5pc0lucHV0IHx8ICFvcHQuJHNlbGVjdGVkIHx8ICFvcHQuJHNlbGVjdGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0LiRzZWxlY3RlZC5wYXJlbnQoKS5oYXNDbGFzcygnY29udGV4dC1tZW51LXJvb3QnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRwYXJlbnQgPSBvcHQuJHNlbGVjdGVkLnBhcmVudCgpLnBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LiRzZWxlY3RlZC50cmlnZ2VyKCdjb250ZXh0bWVudTpibHVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHQuJHNlbGVjdGVkID0gJHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTogLy8gcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmtleVN0b3AoZSwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5pc0lucHV0IHx8ICFvcHQuJHNlbGVjdGVkIHx8ICFvcHQuJHNlbGVjdGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtZGF0YSA9IG9wdC4kc2VsZWN0ZWQuZGF0YSgnY29udGV4dE1lbnUnKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1kYXRhLiRtZW51ICYmIG9wdC4kc2VsZWN0ZWQuaGFzQ2xhc3MoJ2NvbnRleHQtbWVudS1zdWJtZW51JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbWRhdGEuJHNlbGVjdGVkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1kYXRhLiRtZW51LnRyaWdnZXIoJ25leHRjb21tYW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhvbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC4kc2VsZWN0ZWQgJiYgb3B0LiRzZWxlY3RlZC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdC4kc2VsZWN0ZWQgJiYgb3B0LiRzZWxlY3RlZC5wYXJlbnQoKSB8fCBvcHQuJG1lbnUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKCc6bm90KC4nICsgb3B0LmNsYXNzTmFtZXMuZGlzYWJsZWQgKyAnLCAuJyArIG9wdC5jbGFzc05hbWVzLm5vdFNlbGVjdGFibGUgKyAnKScpW2Uua2V5Q29kZSA9PT0gMzYgPyAnZmlyc3QnIDogJ2xhc3QnXSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaWdnZXIoJ2NvbnRleHRtZW51OmZvY3VzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IC8vIGVudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZS5rZXlTdG9wKGUsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC4kc2VsZWN0ZWQgJiYgIW9wdC4kc2VsZWN0ZWQuaXMoJ3RleHRhcmVhLCBzZWxlY3QnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdC4kc2VsZWN0ZWQgIT09ICd1bmRlZmluZWQnICYmIG9wdC4kc2VsZWN0ZWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQudHJpZ2dlcignbW91c2V1cCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzMjogLy8gc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDMzOiAvLyBwYWdlIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gcGFnZSBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgYnJvd3NlciBmcm9tIHNjcm9sbGluZyBkb3duIHdoaWxlIG1lbnUgaXMgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUua2V5U3RvcChlLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGVzY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUua2V5U3RvcChlLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHQuJG1lbnUudHJpZ2dlcignY29udGV4dG1lbnU6aGlkZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIDAtOSwgYS16XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gKFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKSkudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5hY2Nlc3NrZXlzICYmIG9wdC5hY2Nlc3NrZXlzW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNzIGFjY2Vzc2tleXMgbXVzdCBiZSBpbnZva2VkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHQuYWNjZXNza2V5c1trXS4kbm9kZS50cmlnZ2VyKG9wdC5hY2Nlc3NrZXlzW2tdLiRtZW51ID8gJ2NvbnRleHRtZW51OmZvY3VzJyA6ICdtb3VzZXVwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzIGV2ZW50IHRvIHNlbGVjdGVkIGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIHByb3BhZ2F0aW9uIHRvIGF2b2lkIGVuZGxlc3MgcmVjdXJzaW9uXHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuJHNlbGVjdGVkICE9PSAndW5kZWZpbmVkJyAmJiBvcHQuJHNlbGVjdGVkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0LiRzZWxlY3RlZC50cmlnZ2VyKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBzZWxlY3QgcHJldmlvdXMgcG9zc2libGUgY29tbWFuZCBpbiBtZW51XHJcbiAgICAgICAgICAgIHByZXZJdGVtOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcHQgPSAkKHRoaXMpLmRhdGEoJ2NvbnRleHRNZW51JykgfHwge307XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9ICQodGhpcykuZGF0YSgnY29udGV4dE1lbnVSb290JykgfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gb2J0YWluIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0LiRzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkcyA9IG9wdC4kc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gb3B0LiRzZWxlY3RlZC5wYXJlbnQoKS5kYXRhKCdjb250ZXh0TWVudScpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQgPSAkcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgJGNoaWxkcmVuID0gb3B0LiRtZW51LmNoaWxkcmVuKCksXHJcbiAgICAgICAgICAgICAgICAgICAgJHByZXYgPSAhb3B0LiRzZWxlY3RlZCB8fCAhb3B0LiRzZWxlY3RlZC5wcmV2KCkubGVuZ3RoID8gJGNoaWxkcmVuLmxhc3QoKSA6IG9wdC4kc2VsZWN0ZWQucHJldigpLFxyXG4gICAgICAgICAgICAgICAgICAgICRyb3VuZCA9ICRwcmV2O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNraXAgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgIHdoaWxlICgkcHJldi5oYXNDbGFzcyhyb290LmNsYXNzTmFtZXMuZGlzYWJsZWQpIHx8ICRwcmV2Lmhhc0NsYXNzKHJvb3QuY2xhc3NOYW1lcy5ub3RTZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkcHJldi5wcmV2KCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRwcmV2ID0gJHByZXYucHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRwcmV2ID0gJGNoaWxkcmVuLmxhc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRwcmV2LmlzKCRyb3VuZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgZW5kbGVzcyBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbGVhdmUgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdC4kc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuaXRlbU1vdXNlbGVhdmUuY2FsbChvcHQuJHNlbGVjdGVkLmdldCgwKSwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZhdGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlLml0ZW1Nb3VzZWVudGVyLmNhbGwoJHByZXYuZ2V0KDApLCBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmb2N1cyBpbnB1dFxyXG4gICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICRwcmV2LmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRpbnB1dC5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBzZWxlY3QgbmV4dCBwb3NzaWJsZSBjb21tYW5kIGluIG1lbnVcclxuICAgICAgICAgICAgbmV4dEl0ZW06IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9ICQodGhpcykuZGF0YSgnY29udGV4dE1lbnUnKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciByb290ID0gJCh0aGlzKS5kYXRhKCdjb250ZXh0TWVudVJvb3QnKSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBvYnRhaW4gY3VycmVudGx5IHNlbGVjdGVkIG1lbnVcclxuICAgICAgICAgICAgICAgIGlmIChvcHQuJHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRzID0gb3B0LiRzZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgPSBvcHQuJHNlbGVjdGVkLnBhcmVudCgpLmRhdGEoJ2NvbnRleHRNZW51JykgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0LiRzZWxlY3RlZCA9ICRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciAkY2hpbGRyZW4gPSBvcHQuJG1lbnUuY2hpbGRyZW4oKSxcclxuICAgICAgICAgICAgICAgICAgICAkbmV4dCA9ICFvcHQuJHNlbGVjdGVkIHx8ICFvcHQuJHNlbGVjdGVkLm5leHQoKS5sZW5ndGggPyAkY2hpbGRyZW4uZmlyc3QoKSA6IG9wdC4kc2VsZWN0ZWQubmV4dCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICRyb3VuZCA9ICRuZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNraXAgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgIHdoaWxlICgkbmV4dC5oYXNDbGFzcyhyb290LmNsYXNzTmFtZXMuZGlzYWJsZWQpIHx8ICRuZXh0Lmhhc0NsYXNzKHJvb3QuY2xhc3NOYW1lcy5ub3RTZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkbmV4dC5uZXh0KCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRuZXh0ID0gJG5leHQubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRuZXh0ID0gJGNoaWxkcmVuLmZpcnN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkbmV4dC5pcygkcm91bmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIGVuZGxlc3MgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGxlYXZlIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgIGlmIChvcHQuJHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLml0ZW1Nb3VzZWxlYXZlLmNhbGwob3B0LiRzZWxlY3RlZC5nZXQoMCksIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2YXRlIG5leHRcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5pdGVtTW91c2VlbnRlci5jYWxsKCRuZXh0LmdldCgwKSwgZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgaW5wdXRcclxuICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkbmV4dC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAkaW5wdXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZmxhZyB0aGF0IHdlJ3JlIGluc2lkZSBhbiBpbnB1dCBzbyB0aGUga2V5IGhhbmRsZXIgY2FuIGFjdCBhY2NvcmRpbmdseVxyXG4gICAgICAgICAgICBmb2N1c0lucHV0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLmNsb3Nlc3QoJy5jb250ZXh0LW1lbnUtaXRlbScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gZGF0YS5jb250ZXh0TWVudSxcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gZGF0YS5jb250ZXh0TWVudVJvb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgcm9vdC4kc2VsZWN0ZWQgPSBvcHQuJHNlbGVjdGVkID0gJHRoaXM7XHJcbiAgICAgICAgICAgICAgICByb290LmlzSW5wdXQgPSBvcHQuaXNJbnB1dCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGZsYWcgdGhhdCB3ZSdyZSBpbnNpZGUgYW4gaW5wdXQgc28gdGhlIGtleSBoYW5kbGVyIGNhbiBhY3QgYWNjb3JkaW5nbHlcclxuICAgICAgICAgICAgYmx1cklucHV0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLmNsb3Nlc3QoJy5jb250ZXh0LW1lbnUtaXRlbScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gZGF0YS5jb250ZXh0TWVudSxcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gZGF0YS5jb250ZXh0TWVudVJvb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgcm9vdC5pc0lucHV0ID0gb3B0LmlzSW5wdXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gOmhvdmVyIG9uIG1lbnVcclxuICAgICAgICAgICAgbWVudU1vdXNlZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb290ID0gJCh0aGlzKS5kYXRhKCkuY29udGV4dE1lbnVSb290O1xyXG4gICAgICAgICAgICAgICAgcm9vdC5ob3ZlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIDpob3ZlciBvbiBtZW51XHJcbiAgICAgICAgICAgIG1lbnVNb3VzZWxlYXZlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSAkKHRoaXMpLmRhdGEoKS5jb250ZXh0TWVudVJvb3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdC4kbGF5ZXIgJiYgcm9vdC4kbGF5ZXIuaXMoZS5yZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuaG92ZXJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gOmhvdmVyIGRvbmUgbWFudWFsbHkgc28ga2V5IGhhbmRsaW5nIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIGl0ZW1Nb3VzZWVudGVyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdCA9IGRhdGEuY29udGV4dE1lbnUsXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGRhdGEuY29udGV4dE1lbnVSb290O1xyXG5cclxuICAgICAgICAgICAgICAgIHJvb3QuaG92ZXJpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFib3J0IGlmIHdlJ3JlIHJlLWVudGVyaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiByb290LiRsYXllciAmJiByb290LiRsYXllci5pcyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIGl0ZW0gaXMgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIChvcHQuJG1lbnUgPyBvcHQgOiByb290KS4kbWVudVxyXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbignLmhvdmVyJykudHJpZ2dlcignY29udGV4dG1lbnU6Ymx1cicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy5oYXNDbGFzcyhyb290LmNsYXNzTmFtZXMuZGlzYWJsZWQpIHx8ICR0aGlzLmhhc0NsYXNzKHJvb3QuY2xhc3NOYW1lcy5ub3RTZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdjb250ZXh0bWVudTpmb2N1cycpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyA6aG92ZXIgZG9uZSBtYW51YWxseSBzbyBrZXkgaGFuZGxpbmcgaXMgcG9zc2libGVcclxuICAgICAgICAgICAgaXRlbU1vdXNlbGVhdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gZGF0YS5jb250ZXh0TWVudSxcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gZGF0YS5jb250ZXh0TWVudVJvb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgIT09IG9wdCAmJiByb290LiRsYXllciAmJiByb290LiRsYXllci5pcyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByb290LiRzZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgJiYgcm9vdC4kc2VsZWN0ZWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC4kc2VsZWN0ZWQudHJpZ2dlcignY29udGV4dG1lbnU6Ymx1cicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICByb290LiRzZWxlY3RlZCA9IG9wdC4kc2VsZWN0ZWQgPSBvcHQuJG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2NvbnRleHRtZW51OmJsdXInKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gY29udGV4dE1lbnUgaXRlbSBjbGlja1xyXG4gICAgICAgICAgICBpdGVtQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gZGF0YS5jb250ZXh0TWVudSxcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gZGF0YS5jb250ZXh0TWVudVJvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZGF0YS5jb250ZXh0TWVudUtleSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGUga2V5IGlzIHVua25vd24gb3IgZGlzYWJsZWQgb3IgaXMgYSBtZW51XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5pdGVtc1trZXldIHx8ICR0aGlzLmlzKCcuJyArIHJvb3QuY2xhc3NOYW1lcy5kaXNhYmxlZCArICcsIC5jb250ZXh0LW1lbnUtc3VibWVudSwgLmNvbnRleHQtbWVudS1zZXBhcmF0b3IsIC4nICsgcm9vdC5jbGFzc05hbWVzLm5vdFNlbGVjdGFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihyb290LmNhbGxiYWNrc1trZXldKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocm9vdC5jYWxsYmFja3MsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtLXNwZWNpZmljIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByb290LmNhbGxiYWNrc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzRnVuY3Rpb24ocm9vdC5jYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByb290LmNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjYWxsYmFjaywgbm8gYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGhpZGUgbWVudSBpZiBjYWxsYmFjayBkb2Vzbid0IHN0b3AgdGhhdFxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwocm9vdC4kdHJpZ2dlciwga2V5LCByb290KSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290LiRtZW51LnRyaWdnZXIoJ2NvbnRleHRtZW51OmhpZGUnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocm9vdC4kbWVudS5wYXJlbnQoKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcC51cGRhdGUuY2FsbChyb290LiR0cmlnZ2VyLCByb290KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaWdub3JlIGNsaWNrIGV2ZW50cyBvbiBpbnB1dCBlbGVtZW50c1xyXG4gICAgICAgICAgICBpbnB1dENsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaGlkZSA8bWVudT5cclxuICAgICAgICAgICAgaGlkZU1lbnU6IGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9ICQodGhpcykuZGF0YSgnY29udGV4dE1lbnVSb290Jyk7XHJcbiAgICAgICAgICAgICAgICBvcC5oaWRlLmNhbGwocm9vdC4kdHJpZ2dlciwgcm9vdCwgZGF0YSAmJiBkYXRhLmZvcmNlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZm9jdXMgPGNvbW1hbmQ+XHJcbiAgICAgICAgICAgIGZvY3VzSXRlbTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gZGF0YS5jb250ZXh0TWVudSxcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gZGF0YS5jb250ZXh0TWVudVJvb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgJHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoW3Jvb3QuY2xhc3NOYW1lcy5ob3Zlciwgcm9vdC5jbGFzc05hbWVzLnZpc2libGVdLmpvaW4oJyAnKSlcclxuICAgICAgICAgICAgICAgICAgICAuc2libGluZ3MoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhyb290LmNsYXNzTmFtZXMudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJvb3QuY2xhc3NOYW1lcy5ob3ZlcilcclxuICAgICAgICAgICAgICAgICAgICAudHJpZ2dlcignY29udGV4dG1lbnU6Ymx1cicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICBvcHQuJHNlbGVjdGVkID0gcm9vdC4kc2VsZWN0ZWQgPSAkdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBzdWItbWVudSAtIGRvIGFmdGVyIHNob3cgc28gZHVtYiAkLnVpLnBvc2l0aW9uIGNhbiBrZWVwIHVwXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0LiRub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5wb3NpdGlvblN1Ym1lbnUuY2FsbChvcHQuJG5vZGUsIG9wdC4kbWVudSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGJsdXIgPGNvbW1hbmQ+XHJcbiAgICAgICAgICAgIGJsdXJJdGVtOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICBvcHQgPSBkYXRhLmNvbnRleHRNZW51LFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBkYXRhLmNvbnRleHRNZW51Um9vdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0LmF1dG9IaWRlKSB7IC8vIGZvciB0YWJsZXRzIGFuZCB0b3VjaCBzY3JlZW5zIHRoaXMgbmVlZHMgdG8gcmVtYWluXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlQ2xhc3Mocm9vdC5jbGFzc05hbWVzLnZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlQ2xhc3Mocm9vdC5jbGFzc05hbWVzLmhvdmVyKTtcclxuICAgICAgICAgICAgICAgIG9wdC4kc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIC8vIG9wZXJhdGlvbnNcclxuICAgICAgICBvcCA9IHtcclxuICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24gKG9wdCwgeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0cmlnZ2VyID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBjc3MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBoaWRlIGFueSBvcGVuIG1lbnVzXHJcbiAgICAgICAgICAgICAgICAkKCcjY29udGV4dC1tZW51LWxheWVyJykudHJpZ2dlcignbW91c2Vkb3duJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYmFja3JlZmVyZW5jZSBmb3IgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAgICBvcHQuJHRyaWdnZXIgPSAkdHJpZ2dlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzaG93IGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0LmV2ZW50cy5zaG93LmNhbGwoJHRyaWdnZXIsIG9wdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnRUcmlnZ2VyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG9yIHVwZGF0ZSBjb250ZXh0IG1lbnVcclxuICAgICAgICAgICAgICAgIG9wLnVwZGF0ZS5jYWxsKCR0cmlnZ2VyLCBvcHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1lbnVcclxuICAgICAgICAgICAgICAgIG9wdC5wb3NpdGlvbi5jYWxsKCR0cmlnZ2VyLCBvcHQsIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSdyZSBpbiBmcm9udFxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdC56SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjc3MuekluZGV4ID0gemluZGV4KCR0cmlnZ2VyKSArIG9wdC56SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIGxheWVyXHJcbiAgICAgICAgICAgICAgICBvcC5sYXllci5jYWxsKG9wdC4kbWVudSwgb3B0LCBjc3MuekluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgc3ViLW1lbnUgekluZGV4ZXNcclxuICAgICAgICAgICAgICAgIG9wdC4kbWVudS5maW5kKCd1bCcpLmNzcygnekluZGV4JywgY3NzLnpJbmRleCArIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIGFuZCBzaG93IGNvbnRleHQgbWVudVxyXG4gICAgICAgICAgICAgICAgb3B0LiRtZW51LmNzcyhjc3MpW29wdC5hbmltYXRpb24uc2hvd10ob3B0LmFuaW1hdGlvbi5kdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0cmlnZ2VyLnRyaWdnZXIoJ2NvbnRleHRtZW51OnZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBvcHRpb25zIGF2YWlsYWJsZSBhbmQgc2V0IHN0YXRlXHJcbiAgICAgICAgICAgICAgICAkdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKCdjb250ZXh0TWVudScsIG9wdClcclxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbnRleHQtbWVudS1hY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBrZXkgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdrZXlkb3duLmNvbnRleHRNZW51Jykub24oJ2tleWRvd24uY29udGV4dE1lbnUnLCBoYW5kbGUua2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGF1dG9IaWRlIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGlmIChvcHQuYXV0b0hpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBwb3NpdGlvbiBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ21vdXNlbW92ZS5jb250ZXh0TWVudUF1dG9IaWRlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjYXB0dXJlIHRoZSBvZmZzZXQgb24gbW91c2Vtb3ZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgcGFnZSBtaWdodCd2ZSBiZWVuIHNjcm9sbGVkIHNpbmNlIGFjdGl2YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9ICR0cmlnZ2VyLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MucmlnaHQgPSBwb3MubGVmdCArICR0cmlnZ2VyLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmJvdHRvbSA9IHBvcy50b3AgKyAkdHJpZ2dlci5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC4kbGF5ZXIgJiYgIW9wdC5ob3ZlcmluZyAmJiAoIShlLnBhZ2VYID49IHBvcy5sZWZ0ICYmIGUucGFnZVggPD0gcG9zLnJpZ2h0KSB8fCAhKGUucGFnZVkgPj0gcG9zLnRvcCAmJiBlLnBhZ2VZIDw9IHBvcy5ib3R0b20pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbW91c2UgaW4gbWVudS4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LiRtZW51LnRyaWdnZXIoJ2NvbnRleHRtZW51OmhpZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAob3B0LCBmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0cmlnZ2VyID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0ID0gJHRyaWdnZXIuZGF0YSgnY29udGV4dE1lbnUnKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBoaWRlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlICYmIG9wdC5ldmVudHMgJiYgb3B0LmV2ZW50cy5oaWRlLmNhbGwoJHRyaWdnZXIsIG9wdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvcHRpb25zIGFuZCByZXZlcnQgc3RhdGVcclxuICAgICAgICAgICAgICAgICR0cmlnZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZURhdGEoJ2NvbnRleHRNZW51JylcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbnRleHQtbWVudS1hY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0LiRsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgbGF5ZXIgZm9yIGEgYml0IHNvIHRoZSBjb250ZXh0bWVudSBldmVudCBjYW4gYmUgYWJvcnRlZCBwcm9wZXJseSBieSBvcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uICgkbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRsYXllci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KShvcHQuJGxheWVyKSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0LiRsYXllcjtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdC4kbGF5ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaGFuZGxlXHJcbiAgICAgICAgICAgICAgICAkY3VycmVudFRyaWdnZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICBvcHQuJG1lbnUuZmluZCgnLicgKyBvcHQuY2xhc3NOYW1lcy5ob3ZlcikudHJpZ2dlcignY29udGV4dG1lbnU6Ymx1cicpO1xyXG4gICAgICAgICAgICAgICAgb3B0LiRzZWxlY3RlZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIGtleSBhbmQgbW91c2UgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIC8vICQoZG9jdW1lbnQpLm9mZignLmNvbnRleHRNZW51QXV0b0hpZGUga2V5ZG93bi5jb250ZXh0TWVudScpOyAvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMDcwNVxyXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCcuY29udGV4dE1lbnVBdXRvSGlkZScpLm9mZigna2V5ZG93bi5jb250ZXh0TWVudScpO1xyXG4gICAgICAgICAgICAgICAgLy8gaGlkZSBtZW51XHJcbiAgICAgICAgICAgICAgICBvcHQuJG1lbnUgJiYgb3B0LiRtZW51W29wdC5hbmltYXRpb24uaGlkZV0ob3B0LmFuaW1hdGlvbi5kdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlYXIgZG93biBkeW5hbWljYWxseSBidWlsdCBtZW51IGFmdGVyIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5idWlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHQuJG1lbnUucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChvcHQsIGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdidWlsZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJpZ2dlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdHJpZ2dlci50cmlnZ2VyKCdjb250ZXh0bWVudTpoaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAob3B0LCByb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG9wdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjb250ZXh0TWVudVxyXG4gICAgICAgICAgICAgICAgb3B0LiRtZW51ID0gJCgnPHVsIGNsYXNzPVwiY29udGV4dC1tZW51LWxpc3RcIj48L3VsPicpLmFkZENsYXNzKG9wdC5jbGFzc05hbWUgfHwgJycpLmRhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgICdjb250ZXh0TWVudSc6IG9wdCxcclxuICAgICAgICAgICAgICAgICAgICAnY29udGV4dE1lbnVSb290Jzogcm9vdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgJC5lYWNoKFsnY2FsbGJhY2tzJywgJ2NvbW1hbmRzJywgJ2lucHV0cyddLCBmdW5jdGlvbiAoaSwgaykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdFtrXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcm9vdFtrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290W2tdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcm9vdC5hY2Nlc3NrZXlzIHx8IChyb290LmFjY2Vzc2tleXMgPSB7fSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlTmFtZU5vZGUoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkbmFtZSA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5fYWNjZXNza2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLl9iZWZvcmVBY2Nlc3NrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRuYW1lLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpdGVtLl9iZWZvcmVBY2Nlc3NrZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8c3Bhbj48L3NwYW4+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnY29udGV4dC1tZW51LWFjY2Vzc2tleScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dChpdGVtLl9hY2Nlc3NrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5fYWZ0ZXJBY2Nlc3NrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRuYW1lLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpdGVtLl9hZnRlckFjY2Vzc2tleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWUudGV4dChpdGVtLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJG5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNvbnRleHRNZW51IGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAkLmVhY2gob3B0Lml0ZW1zLCBmdW5jdGlvbiAoa2V5LCBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0ID0gJCgnPGxpIGNsYXNzPVwiY29udGV4dC1tZW51LWl0ZW1cIj48L2xpPicpLmFkZENsYXNzKGl0ZW0uY2xhc3NOYW1lIHx8ICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGxhYmVsID0gbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaU9TIG5lZWRzIHRvIHNlZSBhIGNsaWNrLWV2ZW50IGJvdW5kIHRvIGFuIGVsZW1lbnQgdG8gYWN0dWFsbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHRoZSBUb3VjaEV2ZW50cyBpbmZyYXN0cnVjdHVyZSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICR0Lm9uKCdjbGljaycsICQubm9vcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugb2xkIHNjaG9vbCBzdHJpbmcgc2VwZXJhdG9yIGEgcmVhbCBpdGVtIHNvIGNoZWNrcyB3b250IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWt3YXJkIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHsgdHlwZSA6ICdjbV9zZXBlcmF0b3InIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpdGVtLiRub2RlID0gJHQuZGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0TWVudSc6IG9wdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHRNZW51Um9vdCc6IHJvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0TWVudUtleSc6IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBhY2Nlc3NrZXlcclxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgYWNjZXNza2V5IGF0dHJpYnV0ZSBzaG91bGQgYmUgYXBwbGljYWJsZSB0byBhbnkgZWxlbWVudCwgYnV0IFNhZmFyaTUgYW5kIENocm9tZTEzIHN0aWxsIGNhbid0IGRvIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0uYWNjZXNza2V5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWtzID0gc3BsaXRBY2Nlc3NrZXkoaXRlbS5hY2Nlc3NrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYWs7IGFrID0gYWtzW2ldOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm9vdC5hY2Nlc3NrZXlzW2FrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuYWNjZXNza2V5c1tha10gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gaXRlbS5uYW1lLm1hdGNoKG5ldyBSZWdFeHAoJ14oLio/KSgnICsgYWsgKyAnKSguKikkJywgJ2knKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fYmVmb3JlQWNjZXNza2V5ID0gbWF0Y2hlZFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fYWNjZXNza2V5ID0gbWF0Y2hlZFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fYWZ0ZXJBY2Nlc3NrZXkgPSBtYXRjaGVkWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSAmJiB0eXBlc1tpdGVtLnR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBjdXN0b20gdHlwZSBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2l0ZW0udHlwZV0uY2FsbCgkdCwgaXRlbSwgb3B0LCByb290KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgY29tbWFuZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKFtvcHQsIHJvb3RdLCBmdW5jdGlvbiAoaSwgaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgay5jb21tYW5kc1trZXldID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oaXRlbS5jYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLmNhbGxiYWNrc1trZXldID0gaXRlbS5jYWxsYmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGxhYmVsIGZvciBpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnY21fc2VwZXJhdG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHQuYWRkQ2xhc3MoJ2NvbnRleHQtbWVudS1zZXBhcmF0b3IgJyArIHJvb3QuY2xhc3NOYW1lcy5ub3RTZWxlY3RhYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdodG1sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHQuYWRkQ2xhc3MoJ2NvbnRleHQtbWVudS1odG1sICcgKyByb290LmNsYXNzTmFtZXMubm90U2VsZWN0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbGFiZWwgPSAkKCc8bGFiZWw+PC9sYWJlbD4nKS5hcHBlbmRUbygkdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVOYW1lTm9kZShpdGVtKS5hcHBlbmRUbygkdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHQuYWRkQ2xhc3MoJ2NvbnRleHQtbWVudS1pbnB1dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0Lmhhc1R5cGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChbb3B0LCByb290XSwgZnVuY3Rpb24gKGksIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrLmNvbW1hbmRzW2tleV0gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsuaW5wdXRzW2tleV0gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50eXBlID0gJ3N1Yic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXBlcmF0b3InOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPVwiMVwiIG5hbWU9XCJcIiB2YWx1ZT1cIlwiPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCduYW1lJywgJ2NvbnRleHQtbWVudS1pbnB1dC0nICsga2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKGl0ZW0udmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygkbGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQgPSAkKCc8dGV4dGFyZWEgbmFtZT1cIlwiPjwvdGV4dGFyZWE+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ25hbWUnLCAnY29udGV4dC1tZW51LWlucHV0LScgKyBrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwoaXRlbS52YWx1ZSB8fCAnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCRsYWJlbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQuaGVpZ2h0KGl0ZW0uaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIjFcIiBuYW1lPVwiXCIgdmFsdWU9XCJcIj4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignbmFtZScsICdjb250ZXh0LW1lbnUtaW5wdXQtJyArIGtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbChpdGVtLnZhbHVlIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJvcCgnY2hlY2tlZCcsICEhaXRlbS5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXBlbmRUbygkbGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCIxXCIgbmFtZT1cIlwiIHZhbHVlPVwiXCI+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ25hbWUnLCAnY29udGV4dC1tZW51LWlucHV0LScgKyBpdGVtLnJhZGlvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKGl0ZW0udmFsdWUgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9wKCdjaGVja2VkJywgISFpdGVtLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJlcGVuZFRvKCRsYWJlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQgPSAkKCc8c2VsZWN0IG5hbWU9XCJcIj4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignbmFtZScsICdjb250ZXh0LW1lbnUtaW5wdXQtJyArIGtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCRsYWJlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goaXRlbS5vcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzxvcHRpb24+PC9vcHRpb24+JykudmFsKHZhbHVlKS50ZXh0KHRleHQpLmFwcGVuZFRvKCRpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQudmFsKGl0ZW0uc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdWInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZU5hbWVOb2RlKGl0ZW0pLmFwcGVuZFRvKCR0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hcHBlbmRUbyA9IGl0ZW0uJG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AuY3JlYXRlKGl0ZW0sIHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0LmRhdGEoJ2NvbnRleHRNZW51JywgaXRlbSkuYWRkQ2xhc3MoJ2NvbnRleHQtbWVudS1zdWJtZW51Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChpdGVtLmh0bWwpLmFwcGVuZFRvKCR0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChbb3B0LCByb290XSwgZnVuY3Rpb24gKGksIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgay5jb21tYW5kc1trZXldID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihpdGVtLmNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgay5jYWxsYmFja3Nba2V5XSA9IGl0ZW0uY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVOYW1lTm9kZShpdGVtKS5hcHBlbmRUbygkdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUga2V5IGxpc3RlbmVyIGluIDxpbnB1dD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSAmJiBpdGVtLnR5cGUgIT09ICdzdWInICYmIGl0ZW0udHlwZSAhPT0gJ2h0bWwnICYmIGl0ZW0udHlwZSAhPT0gJ2NtX3NlcGVyYXRvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignZm9jdXMnLCBoYW5kbGUuZm9jdXNJbnB1dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ2JsdXInLCBoYW5kbGUuYmx1cklucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQub24oaXRlbS5ldmVudHMsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpY29uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGl0ZW0uaWNvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9pY29uID0gaXRlbS5pY29uLmNhbGwodGhpcywgJHQsIGtleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX2ljb24gPSByb290LmNsYXNzTmFtZXMuaWNvbiArICcgJyArIHJvb3QuY2xhc3NOYW1lcy5pY29uICsgJy0nICsgaXRlbS5pY29uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0LmFkZENsYXNzKGl0ZW0uX2ljb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBjb250YWluZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLiRpbnB1dCA9ICRpbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLiRsYWJlbCA9ICRsYWJlbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIGl0ZW0gdG8gbWVudVxyXG4gICAgICAgICAgICAgICAgICAgICR0LmFwcGVuZFRvKG9wdC4kbWVudSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgdGV4dCBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdC5oYXNUeXBlcyAmJiAkLnN1cHBvcnQuZXZlbnRTZWxlY3RzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IHVzZXItc2VsZWN0OiBub25lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSBoYXMgYSBzcGVjaWFsIGV2ZW50IGZvciB0ZXh0LXNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0aW5nIG5laXRoZXIgd2lsbCBub3QgYmUgcHJldmVudGluZyB0ZXh0LXNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdC5vbignc2VsZWN0c3RhcnQuZGlzYWJsZVRleHRTZWxlY3QnLCBoYW5kbGUuYWJvcnRldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggY29udGV4dE1lbnUgdG8gPGJvZHk+ICh0byBieXBhc3MgYW55IHBvc3NpYmxlIG92ZXJmbG93OmhpZGRlbiBpc3N1ZXMgb24gcGFyZW50cyBvZiB0aGUgdHJpZ2dlciBlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuJG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHQuJG1lbnUuY3NzKCdkaXNwbGF5JywgJ25vbmUnKS5hZGRDbGFzcygnY29udGV4dC1tZW51LXJvb3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wdC4kbWVudS5hcHBlbmRUbyhvcHQuYXBwZW5kVG8gfHwgZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKCRtZW51LCBuZXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB3aWR0aHMgb2Ygc3VibWVudXMsIGFzIENTUyB3b24ndCBncm93IHRoZW0gYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb246YWJzb2x1dGUgd2l0aGluIHBvc2l0aW9uOmFic29sdXRlOyBtaW4td2lkdGg6MTAwOyBtYXgtd2lkdGg6MjAwOyByZXN1bHRzIGluIHdpZHRoOiAxMDA7XHJcbiAgICAgICAgICAgICAgICAvLyBraW5kYSBzdWNrcyBoYXJkLi4uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdpZHRoIG9mIGFic29sdXRlbHkgcG9zaXRpb25lZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAkbWVudS5jc3Moe3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBkaXNwbGF5OiAnYmxvY2snfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhcHBseSB5ZXQsIGJlY2F1c2UgdGhhdCB3b3VsZCBicmVhayBuZXN0ZWQgZWxlbWVudHMnIHdpZHRoc1xyXG4gICAgICAgICAgICAgICAgJG1lbnUuZGF0YSgnd2lkdGgnLCBNYXRoLmNlaWwoJG1lbnUud2lkdGgoKSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgc3R5bGVzIHNvIHRoZXkgYWxsb3cgbmVzdGVkIGVsZW1lbnRzIHRvIGdyb3cvc2hyaW5rIG5hdHVyYWxseVxyXG4gICAgICAgICAgICAgICAgJG1lbnUuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXRpYycsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICcwcHgnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwMDAwcHgnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGlkZW50aWZ5IHdpZHRoIG9mIG5lc3RlZCBtZW51c1xyXG4gICAgICAgICAgICAgICAgJG1lbnUuZmluZCgnPiBsaSA+IHVsJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3AucmVzaXplKCQodGhpcyksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBhbmQgYXBwbHkgY2hhbmdlcyBpbiB0aGUgZW5kIGJlY2F1c2UgbmVzdGVkXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cycgd2lkdGhzIHdvdWxkbid0IGJlIGNhbGN1bGF0YWJsZSBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIGlmICghbmVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJG1lbnUuZmluZCgndWwnKS5hZGRCYWNrKCkuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogJydcclxuICAgICAgICAgICAgICAgICAgICB9KS53aWR0aChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRhdGEoJ3dpZHRoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdCwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyICR0cmlnZ2VyID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gb3B0O1xyXG4gICAgICAgICAgICAgICAgICAgIG9wLnJlc2l6ZShvcHQuJG1lbnUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmUtY2hlY2sgZGlzYWJsZWQgZm9yIGVhY2ggaXRlbVxyXG4gICAgICAgICAgICAgICAgb3B0LiRtZW51LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRpdGVtID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJGl0ZW0uZGF0YSgnY29udGV4dE1lbnVLZXknKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IG9wdC5pdGVtc1trZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9ICgkLmlzRnVuY3Rpb24oaXRlbS5kaXNhYmxlZCkgJiYgaXRlbS5kaXNhYmxlZC5jYWxsKCR0cmlnZ2VyLCBrZXksIHJvb3QpKSB8fCBpdGVtLmRpc2FibGVkID09PSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oaXRlbS52aXNpYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gaXRlbS52aXNpYmxlLmNhbGwoJHRyaWdnZXIsIGtleSwgcm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS52aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gaXRlbS52aXNpYmxlID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAkaXRlbVt2aXNpYmxlID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkaXMtIC8gZW5hYmxlIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAkaXRlbVtkaXNhYmxlZCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShyb290LmNsYXNzTmFtZXMuZGlzYWJsZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGl0ZW0uaWNvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoaXRlbS5faWNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX2ljb24gPSBpdGVtLmljb24uY2FsbCh0aGlzLCAkdHJpZ2dlciwga2V5LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoaXRlbS5faWNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpcy0gLyBlbmFibGUgaW5wdXQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGl0ZW0uZmluZCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKS5wcm9wKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpbnB1dCBzdGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uJGlucHV0LnZhbChpdGVtLnZhbHVlIHx8ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kaW5wdXQudmFsKGl0ZW0udmFsdWUgfHwgJycpLnByb3AoJ2NoZWNrZWQnLCAhIWl0ZW0uc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kaW5wdXQudmFsKGl0ZW0uc2VsZWN0ZWQgfHwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS4kbWVudSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc3ViLW1lbnVcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3AudXBkYXRlLmNhbGwoJHRyaWdnZXIsIGl0ZW0sIHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsYXllcjogZnVuY3Rpb24gKG9wdCwgekluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgdHJhbnNwYXJlbnQgbGF5ZXIgZm9yIGNsaWNrIGFyZWFcclxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBhbmQgYmFja2dyb3VuZCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIsIElzc3VlICMyM1xyXG4gICAgICAgICAgICAgICAgdmFyICRsYXllciA9IG9wdC4kbGF5ZXIgPSAkKCc8ZGl2IGlkPVwiY29udGV4dC1tZW51LWxheWVyXCIgc3R5bGU9XCJwb3NpdGlvbjpmaXhlZDsgei1pbmRleDonICsgekluZGV4ICsgJzsgdG9wOjA7IGxlZnQ6MDsgb3BhY2l0eTogMDsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApOyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1wiPjwvZGl2PicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNzcyh7aGVpZ2h0OiAkd2luLmhlaWdodCgpLCB3aWR0aDogJHdpbi53aWR0aCgpLCBkaXNwbGF5OiAnYmxvY2snfSlcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YSgnY29udGV4dE1lbnVSb290Jywgb3B0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnRCZWZvcmUodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2NvbnRleHRtZW51JywgaGFuZGxlLmFib3J0ZXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBoYW5kbGUubGF5ZXJDbGljayk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUU2IGRvZXNuJ3Qga25vdyBwb3NpdGlvbjpmaXhlZDtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5ib2R5LnN0eWxlLm1heFdpZHRoID09PSB1bmRlZmluZWQpIHsgLy8gSUU2IGRvZXNuJ3Qgc3VwcG9ydCBtYXhXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICRsYXllci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJChkb2N1bWVudCkuaGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJGxheWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBzcGxpdCBhY2Nlc3NrZXkgYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2VkaXRpbmcuaHRtbCNhc3NpZ25lZC1hY2Nlc3Mta2V5XHJcbiAgICBmdW5jdGlvbiBzcGxpdEFjY2Vzc2tleSh2YWwpIHtcclxuICAgICAgICB2YXIgdCA9IHZhbC5zcGxpdCgvXFxzKy8pLFxyXG4gICAgICAgICAgICBrZXlzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrOyBrID0gdFtpXTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGsgPSBrLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpOyAvLyBmaXJzdCBjaGFyYWN0ZXIgb25seVxyXG4gICAgICAgICAgICAvLyB0aGVvcmV0aWNhbGx5IG5vbi1hY2Nlc3NpYmxlIGNoYXJhY3RlcnMgc2hvdWxkIGJlIGlnbm9yZWQsIGJ1dCBkaWZmZXJlbnQgc3lzdGVtcywgZGlmZmVyZW50IGtleWJvYXJkIGxheW91dHMsIC4uLiBzY3JldyBpdC5cclxuICAgICAgICAgICAgLy8gYSBtYXAgdG8gbG9vayB1cCBhbHJlYWR5IHVzZWQgYWNjZXNzIGtleXMgd291bGQgYmUgbmljZVxyXG4gICAgICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuXHJcbi8vIGhhbmRsZSBjb250ZXh0TWVudSB0cmlnZ2Vyc1xyXG4gICAgJC5mbi5jb250ZXh0TWVudSA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuICAgICAgICB2YXIgJHQgPSB0aGlzLCAkbyA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7ICAvLyB0aGlzIGlzIG5vdCBhIGJ1aWxkIG9uIGRlbWFuZCBtZW51XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdCgpLnRyaWdnZXIoJ2NvbnRleHRtZW51Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBvcGVyYXRpb24ueSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0KCkudHJpZ2dlcigkLkV2ZW50KCdjb250ZXh0bWVudScsIHtwYWdlWDogb3BlcmF0aW9uLngsIHBhZ2VZOiBvcGVyYXRpb24ueX0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdoaWRlJykge1xyXG4gICAgICAgICAgICAgICAgdmFyICRtZW51ID0gdGhpcy5maXJzdCgpLmRhdGEoJ2NvbnRleHRNZW51JykgPyB0aGlzLmZpcnN0KCkuZGF0YSgnY29udGV4dE1lbnUnKS4kbWVudSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAkbWVudSAmJiAkbWVudS50cmlnZ2VyKCdjb250ZXh0bWVudTpoaWRlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgICQuY29udGV4dE1lbnUoJ2Rlc3Ryb3knLCB7Y29udGV4dDogdGhpc30pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChvcGVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAkLmNvbnRleHRNZW51KCdjcmVhdGUnLCBvcGVyYXRpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygnY29udGV4dC1tZW51LWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDbGFzcygnY29udGV4dC1tZW51LWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkLmVhY2gobWVudXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yID09PSAkdC5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICRvLmRhdGEgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCgkby5kYXRhLCB7dHJpZ2dlcjogJ2RlbWFuZCd9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBoYW5kbGUuY29udGV4dG1lbnUuY2FsbCgkby50YXJnZXQsICRvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBtYW5hZ2UgY29udGV4dE1lbnUgaW5zdGFuY2VzXHJcbiAgICAkLmNvbnRleHRNZW51ID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gb3BlcmF0aW9uO1xyXG4gICAgICAgICAgICBvcGVyYXRpb24gPSAnY3JlYXRlJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHtzZWxlY3Rvcjogb3B0aW9uc307XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWVyZ2Ugd2l0aCBkZWZhdWx0IG9wdGlvbnNcclxuICAgICAgICB2YXIgbyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgICAgdmFyICRkb2N1bWVudCA9ICQoZG9jdW1lbnQpO1xyXG4gICAgICAgIHZhciAkY29udGV4dCA9ICRkb2N1bWVudDtcclxuICAgICAgICB2YXIgX2hhc0NvbnRleHQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKCFvLmNvbnRleHQgfHwgIW8uY29udGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgby5jb250ZXh0ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8geW91IG5ldmVyIGtub3cgd2hhdCB0aGV5IHRocm93IGF0IHlvdS4uLlxyXG4gICAgICAgICAgICAkY29udGV4dCA9ICQoby5jb250ZXh0KS5maXJzdCgpO1xyXG4gICAgICAgICAgICBvLmNvbnRleHQgPSAkY29udGV4dC5nZXQoMCk7XHJcbiAgICAgICAgICAgIF9oYXNDb250ZXh0ID0gby5jb250ZXh0ICE9PSBkb2N1bWVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6XHJcbiAgICAgICAgICAgICAgICAvLyBubyBzZWxlY3RvciBubyBqb3lcclxuICAgICAgICAgICAgICAgIGlmICghby5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VsZWN0b3Igc3BlY2lmaWVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgaW50ZXJuYWwgY2xhc3NlcyBhcmUgbm90IGJvdW5kIHRvXHJcbiAgICAgICAgICAgICAgICBpZiAoby5zZWxlY3Rvci5tYXRjaCgvLmNvbnRleHQtbWVudS0obGlzdHxpdGVtfGlucHV0KSgkfFxccykvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGJpbmQgdG8gc2VsZWN0b3IgXCInICsgby5zZWxlY3RvciArICdcIiBhcyBpdCBjb250YWlucyBhIHJlc2VydmVkIGNsYXNzTmFtZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFvLmJ1aWxkICYmICghby5pdGVtcyB8fCAkLmlzRW1wdHlPYmplY3Qoby5pdGVtcykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBJdGVtcyBzcGVjaWZpZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIG8ubnMgPSAnLmNvbnRleHRNZW51JyArIGNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9oYXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlc1tvLnNlbGVjdG9yXSA9IG8ubnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtZW51c1tvLm5zXSA9IG87XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byByaWdodCBjbGlja1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvLnRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLnRyaWdnZXIgPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgaXRlbSBjbGljayBpcyByZWdpc3RlcmVkIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dG1lbnU6aGlkZS5jb250ZXh0TWVudSc6IGhhbmRsZS5oaWRlTWVudSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmV2Y29tbWFuZC5jb250ZXh0TWVudSc6IGhhbmRsZS5wcmV2SXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICduZXh0Y29tbWFuZC5jb250ZXh0TWVudSc6IGhhbmRsZS5uZXh0SXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0bWVudS5jb250ZXh0TWVudSc6IGhhbmRsZS5hYm9ydGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21vdXNlZW50ZXIuY29udGV4dE1lbnUnOiBoYW5kbGUubWVudU1vdXNlZW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW91c2VsZWF2ZS5jb250ZXh0TWVudSc6IGhhbmRsZS5tZW51TW91c2VsZWF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnLmNvbnRleHQtbWVudS1saXN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZXVwLmNvbnRleHRNZW51JywgJy5jb250ZXh0LW1lbnUtaW5wdXQnLCBoYW5kbGUuaW5wdXRDbGljaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtb3VzZXVwLmNvbnRleHRNZW51JzogaGFuZGxlLml0ZW1DbGljayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0bWVudTpmb2N1cy5jb250ZXh0TWVudSc6IGhhbmRsZS5mb2N1c0l0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dG1lbnU6Ymx1ci5jb250ZXh0TWVudSc6IGhhbmRsZS5ibHVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0bWVudS5jb250ZXh0TWVudSc6IGhhbmRsZS5hYm9ydGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21vdXNlZW50ZXIuY29udGV4dE1lbnUnOiBoYW5kbGUuaXRlbU1vdXNlZW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW91c2VsZWF2ZS5jb250ZXh0TWVudSc6IGhhbmRsZS5pdGVtTW91c2VsZWF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnLmNvbnRleHQtbWVudS1pdGVtJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlbmdhZ2UgbmF0aXZlIGNvbnRleHRtZW51IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAkY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnICsgby5ucywgby5zZWxlY3RvciwgbywgaGFuZGxlLmNvbnRleHRtZW51KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2hhc0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcmVtb3ZlIGhvb2ssIGp1c3QgaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICRjb250ZXh0Lm9uKCdyZW1vdmUnICsgby5ucywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNvbnRleHRNZW51KCdkZXN0cm95Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvLnRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdob3Zlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlZW50ZXInICsgby5ucywgby5zZWxlY3RvciwgbywgaGFuZGxlLm1vdXNlZW50ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbGVhdmUnICsgby5ucywgby5zZWxlY3RvciwgbywgaGFuZGxlLm1vdXNlbGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250ZXh0Lm9uKCdjbGljaycgKyBvLm5zLCBvLnNlbGVjdG9yLCBvLCBoYW5kbGUuY2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvY29udGV4dG1lbnUuaHRtbFxyXG4gICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nICsgby5ucywgby5zZWxlY3RvciwgbywgaGFuZGxlLm1vdXNlZG93bilcclxuICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZXVwJyArIG8ubnMsIG8uc2VsZWN0b3IsIG8sIGhhbmRsZS5tb3VzZXVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG1lbnVcclxuICAgICAgICAgICAgICAgIGlmICghby5idWlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wLmNyZWF0ZShvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnZGVzdHJveSc6XHJcbiAgICAgICAgICAgICAgICB2YXIgJHZpc2libGVNZW51O1xyXG4gICAgICAgICAgICAgICAgaWYgKF9oYXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHByb3BlciBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBvLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG1lbnVzLCBmdW5jdGlvbiAobnMsIG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uY29udGV4dCAhPT0gY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR2aXNpYmxlTWVudSA9ICQoJy5jb250ZXh0LW1lbnUtbGlzdCcpLmZpbHRlcignOnZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR2aXNpYmxlTWVudS5sZW5ndGggJiYgJHZpc2libGVNZW51LmRhdGEoKS5jb250ZXh0TWVudVJvb3QuJHRyaWdnZXIuaXMoJChvLmNvbnRleHQpLmZpbmQoby5zZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmlzaWJsZU1lbnUudHJpZ2dlcignY29udGV4dG1lbnU6aGlkZScsIHtmb3JjZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVzW28ubnNdLiRtZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudXNbby5uc10uJG1lbnUucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lbnVzW28ubnNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51c1tvLm5zXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoby5jb250ZXh0KS5vZmYoby5ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW8uc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnQub2ZmKCcuY29udGV4dE1lbnUgLmNvbnRleHRNZW51QXV0b0hpZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2gobWVudXMsIGZ1bmN0aW9uIChucywgbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKG8uY29udGV4dCkub2ZmKG8ubnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgbWVudXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkKCcjY29udGV4dC1tZW51LWxheWVyLCAuY29udGV4dC1tZW51LWxpc3QnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlc1tvLnNlbGVjdG9yXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR2aXNpYmxlTWVudSA9ICQoJy5jb250ZXh0LW1lbnUtbGlzdCcpLmZpbHRlcignOnZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJHZpc2libGVNZW51Lmxlbmd0aCAmJiAkdmlzaWJsZU1lbnUuZGF0YSgpLmNvbnRleHRNZW51Um9vdC4kdHJpZ2dlci5pcyhvLnNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdmlzaWJsZU1lbnUudHJpZ2dlcignY29udGV4dG1lbnU6aGlkZScsIHtmb3JjZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVzW25hbWVzcGFjZXNbby5zZWxlY3Rvcl1dLiRtZW51KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51c1tuYW1lc3BhY2VzW28uc2VsZWN0b3JdXS4kbWVudS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lbnVzW25hbWVzcGFjZXNbby5zZWxlY3Rvcl1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudXNbbmFtZXNwYWNlc1tvLnNlbGVjdG9yXV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Lm9mZihuYW1lc3BhY2VzW28uc2VsZWN0b3JdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnaHRtbDUnOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgPGNvbW1hbmQ+IG9yIDxtZW51aXRlbT4gYXJlIG5vdCBoYW5kbGVkIGJ5IHRoZSBicm93c2VyLFxyXG4gICAgICAgICAgICAgICAgLy8gb3Igb3B0aW9ucyB3YXMgYSBib29sIHRydWUsXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplICQuY29udGV4dE1lbnUgZm9yIHRoZW1cclxuICAgICAgICAgICAgICAgIGlmICgoISQuc3VwcG9ydC5odG1sQ29tbWFuZCAmJiAhJC5zdXBwb3J0Lmh0bWxNZW51aXRlbSkgfHwgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKCdtZW51W3R5cGU9XCJjb250ZXh0XCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmNvbnRleHRNZW51KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjb250ZXh0bWVudT0nICsgdGhpcy5pZCArICddJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogJC5jb250ZXh0TWVudS5mcm9tTWVudSh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9wZXJhdGlvbiBcIicgKyBvcGVyYXRpb24gKyAnXCInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbi8vIGltcG9ydCB2YWx1ZXMgaW50byA8aW5wdXQ+IGNvbW1hbmRzXHJcbiAgICAkLmNvbnRleHRNZW51LnNldElucHV0VmFsdWVzID0gZnVuY3Rpb24gKG9wdCwgZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJC5lYWNoKG9wdC5pbnB1dHMsIGZ1bmN0aW9uIChrZXksIGl0ZW0pIHtcclxuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgPSBkYXRhW2tleV0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBkYXRhW2tleV0gPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSAoZGF0YVtpdGVtLnJhZGlvXSB8fCAnJykgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gZGF0YVtrZXldIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuLy8gZXhwb3J0IHZhbHVlcyBmcm9tIDxpbnB1dD4gY29tbWFuZHNcclxuICAgICQuY29udGV4dE1lbnUuZ2V0SW5wdXRWYWx1ZXMgPSBmdW5jdGlvbiAob3B0LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkLmVhY2gob3B0LmlucHV0cywgZnVuY3Rpb24gKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IGl0ZW0uJGlucHV0LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBpdGVtLiRpbnB1dC5wcm9wKCdjaGVja2VkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLiRpbnB1dC5wcm9wKCdjaGVja2VkJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpdGVtLnJhZGlvXSA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuXHJcbi8vIGZpbmQgPGxhYmVsIGZvcj1cInh5elwiPlxyXG4gICAgZnVuY3Rpb24gaW5wdXRMYWJlbChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIChub2RlLmlkICYmICQoJ2xhYmVsW2Zvcj1cIicgKyBub2RlLmlkICsgJ1wiXScpLnZhbCgpKSB8fCBub2RlLm5hbWU7XHJcbiAgICB9XHJcblxyXG4vLyBjb252ZXJ0IDxtZW51PiB0byBpdGVtcyBvYmplY3RcclxuICAgIGZ1bmN0aW9uIG1lbnVDaGlsZHJlbihpdGVtcywgJGNoaWxkcmVuLCBjb3VudGVyKSB7XHJcbiAgICAgICAgaWYgKCFjb3VudGVyKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXIgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGNoaWxkcmVuLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgJG5vZGUgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgaXRlbTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgPGxhYmVsPjxpbnB1dD5cclxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnbGFiZWwnICYmICRub2RlLmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9ICRub2RlLnRleHQoKTtcclxuICAgICAgICAgICAgICAgICRub2RlID0gJG5vZGUuY2hpbGRyZW4oKS5maXJzdCgpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9ICRub2RlLmdldCgwKTtcclxuICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiA8bWVudT4gYWNjZXB0cyBmbG93LWNvbnRlbnQgYXMgY2hpbGRyZW4uIHRoYXQgbWVhbnMgPGVtYmVkPiwgPGNhbnZhcz4gYW5kIHN1Y2ggYXJlIHZhbGlkIG1lbnUgaXRlbXMuXHJcbiAgICAgICAgICAgICAqIE5vdCBiZWluZyB0aGUgc2FkaXN0aWMga2luZCwgJC5jb250ZXh0TWVudSBvbmx5IGFjY2VwdHM6XHJcbiAgICAgICAgICAgICAqIDxjb21tYW5kPiwgPG1lbnVpdGVtPiwgPGhyPiwgPHNwYW4+LCA8cD4gPGlucHV0IFt0ZXh0LCByYWRpbywgY2hlY2tib3hdPiwgPHRleHRhcmVhPiwgPHNlbGVjdD4gYW5kIG9mIGNvdXJzZSA8bWVudT4uXHJcbiAgICAgICAgICAgICAqIEV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGJlIGltcG9ydGVkIGFzIGFuIGh0bWwgbm9kZSwgd2hpY2ggaXMgbm90IGludGVyZmFjZWQgd2l0aCBjb250ZXh0TWVudS5cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tYW5kcy5odG1sI2NvbmNlcHQtY29tbWFuZFxyXG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9pbnRlcmFjdGl2ZS1lbGVtZW50cy5odG1sI3RoZS1tZW51LWVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21lbnUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7bmFtZTogJG5vZGUuYXR0cignbGFiZWwnKSwgaXRlbXM6IHt9fTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyID0gbWVudUNoaWxkcmVuKGl0ZW0uaXRlbXMsICRub2RlLmNoaWxkcmVuKCksIGNvdW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1hbmRzLmh0bWwjdXNpbmctdGhlLWEtZWxlbWVudC10by1kZWZpbmUtYS1jb21tYW5kXHJcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1hbmRzLmh0bWwjdXNpbmctdGhlLWJ1dHRvbi1lbGVtZW50LXRvLWRlZmluZS1hLWNvbW1hbmRcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2J1dHRvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJG5vZGUudGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogISEkbm9kZS5hdHRyKCdkaXNhYmxlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGUuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1hbmRzLmh0bWwjdXNpbmctdGhlLWNvbW1hbmQtZWxlbWVudC10by1kZWZpbmUtYS1jb21tYW5kXHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWVudWl0ZW0nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgkbm9kZS5hdHRyKCd0eXBlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZW51aXRlbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICRub2RlLmF0dHIoJ2xhYmVsJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhJG5vZGUuYXR0cignZGlzYWJsZWQnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAkbm9kZS5hdHRyKCdpY29uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbm9kZS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogISEkbm9kZS5hdHRyKCdkaXNhYmxlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICRub2RlLmF0dHIoJ2xhYmVsJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6ICEhJG5vZGUuYXR0cignY2hlY2tlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JhZGlvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogISEkbm9kZS5hdHRyKCdkaXNhYmxlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICRub2RlLmF0dHIoJ2xhYmVsJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaW86ICRub2RlLmF0dHIoJ3JhZGlvZ3JvdXAnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJG5vZGUuYXR0cignaWQnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogISEkbm9kZS5hdHRyKCdjaGVja2VkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdocic6XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9ICctLS0tLS0tJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgkbm9kZS5hdHRyKCd0eXBlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYWJlbCB8fCBpbnB1dExhYmVsKG5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAhISRub2RlLmF0dHIoJ2Rpc2FibGVkJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICRub2RlLnZhbCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGFiZWwgfHwgaW5wdXRMYWJlbChub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogISEkbm9kZS5hdHRyKCdkaXNhYmxlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiAhISRub2RlLmF0dHIoJ2NoZWNrZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhYmVsIHx8IGlucHV0TGFiZWwobm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhJG5vZGUuYXR0cignZGlzYWJsZWQnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpbzogISEkbm9kZS5hdHRyKCduYW1lJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICRub2RlLnZhbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiAhISRub2RlLmF0dHIoJ2NoZWNrZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VsZWN0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGFiZWwgfHwgaW5wdXRMYWJlbChub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhJG5vZGUuYXR0cignZGlzYWJsZWQnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6ICRub2RlLnZhbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7fVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgJG5vZGUuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcHRpb25zW3RoaXMudmFsdWVdID0gJCh0aGlzKS50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhYmVsIHx8IGlucHV0TGFiZWwobm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAhISRub2RlLmF0dHIoJ2Rpc2FibGVkJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAkbm9kZS52YWwoKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHt0eXBlOiAnaHRtbCcsIGh0bWw6ICRub2RlLmNsb25lKHRydWUpfTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIGl0ZW1zWydrZXknICsgY291bnRlcl0gPSBpdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb3VudGVyO1xyXG4gICAgfVxyXG5cclxuLy8gY29udmVydCBodG1sNSBtZW51XHJcbiAgICAkLmNvbnRleHRNZW51LmZyb21NZW51ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgJHRoaXMgPSAkKGVsZW1lbnQpLFxyXG4gICAgICAgICAgICBpdGVtcyA9IHt9O1xyXG5cclxuICAgICAgICBtZW51Q2hpbGRyZW4oaXRlbXMsICR0aGlzLmNoaWxkcmVuKCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9O1xyXG5cclxuLy8gbWFrZSBkZWZhdWx0cyBhY2Nlc3NpYmxlXHJcbiAgICAkLmNvbnRleHRNZW51LmRlZmF1bHRzID0gZGVmYXVsdHM7XHJcbiAgICAkLmNvbnRleHRNZW51LnR5cGVzID0gdHlwZXM7XHJcbi8vIGV4cG9ydCBpbnRlcm5hbCBmdW5jdGlvbnMgLSB1bmRvY3VtZW50ZWQsIGZvciBoYWNraW5nIG9ubHkhXHJcbiAgICAkLmNvbnRleHRNZW51LmhhbmRsZSA9IGhhbmRsZTtcclxuICAgICQuY29udGV4dE1lbnUub3AgPSBvcDtcclxuICAgICQuY29udGV4dE1lbnUubWVudXMgPSBtZW51cztcclxuXHJcblxyXG59KTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9qcXVlcnktY29udGV4dG1lbnUvZGlzdC9qcXVlcnkuY29udGV4dE1lbnUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyIsIi8qZ2xvYmFscyBkZWZpbmUsIGpRdWVyeSwgbW9kdWxlLCByZXF1aXJlICovXG4vKmpzbGludCB2YXJzOnRydWUgKi9cblxuLyoqXG4gKiBAbGljZW5zZSBhbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlciAgdmVyc2lvbjogMC4zLjE1XG4gKiBDb3B5cmlnaHQgMjAxNSBLbmlnaHQgUmlkZXIgQ29uc3VsdGluZywgSW5jLiBodHRwOi8vd3d3LmtuaWdodHJpZGVyLmNvbVxuICogTGljZW5zZTogTUlUXG4gKi9cblxuLyoqXG4gKlxuICogICAgQGF1dGhvciAgICAgICAgRGFsZSBcIkR1Y2t5XCIgTG90dHNcbiAqICAgIEBzaW5jZSAgICAgICAgMjAxMy1KdWwtOFxuICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnYW5ndWxhcicsICdtb21lbnQnXSwgZmFjdG9yeSk7IC8vIEFNRFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2FuZ3VsYXInKSwgcmVxdWlyZSgnbW9tZW50JykpOyAvLyBDb21tb25KU1xuICB9IGVsc2Uge1xuICAgIGZhY3Rvcnkod2luZG93LmFuZ3VsYXIsIHdpbmRvdy5tb21lbnQpOyAvLyBCcm93c2VyIGdsb2JhbFxuICB9XG59KGZ1bmN0aW9uIChhbmd1bGFyLCBtb21lbnQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBhbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGV0aW1lcGlja2VyJywgW10pXG4gICAgLmNvbnN0YW50KCdkYXRlVGltZVBpY2tlckNvbmZpZycsIHtcbiAgICAgIGRyb3Bkb3duU2VsZWN0b3I6IG51bGwsXG4gICAgICBtaW51dGVTdGVwOiA1LFxuICAgICAgbWluVmlldzogJ21pbnV0ZScsXG4gICAgICBzdGFydFZpZXc6ICdkYXknXG4gICAgfSlcbiAgICAuZGlyZWN0aXZlKCdkYXRldGltZXBpY2tlcicsIFsnJGxvZycsICdkYXRlVGltZVBpY2tlckNvbmZpZycsIGZ1bmN0aW9uIGRhdGV0aW1lcGlja2VyRGlyZWN0aXZlKCRsb2csIGRlZmF1bHRDb25maWcpIHtcblxuICAgICAgZnVuY3Rpb24gRGF0ZU9iamVjdCgpIHtcblxuICAgICAgICB2YXIgdGVtcERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgbG9jYWxPZmZzZXQgPSB0ZW1wRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgIHRoaXMudXRjRGF0ZVZhbHVlID0gdGVtcERhdGUuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubG9jYWxEYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXRjRGF0ZVZhbHVlICsgbG9jYWxPZmZzZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHZhbGlkUHJvcGVydGllcyA9IFsndXRjRGF0ZVZhbHVlJywgJ2xvY2FsRGF0ZVZhbHVlJywgJ2Rpc3BsYXknLCAnYWN0aXZlJywgJ3NlbGVjdGFibGUnLCAncGFzdCcsICdmdXR1cmUnXTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXG4gICAgICAgICAgaWYgKHZhbGlkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgICAgICAgdGhpc1twcm9wXSA9IGFyZ3VtZW50c1swXVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbGlkYXRlQ29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciB2YWxpZE9wdGlvbnMgPSBbJ3N0YXJ0VmlldycsICdtaW5WaWV3JywgJ21pbnV0ZVN0ZXAnLCAnZHJvcGRvd25TZWxlY3RvciddO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY29uZmlndXJhdGlvbikge1xuICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgICAgIGlmICh2YWxpZE9wdGlvbnMuaW5kZXhPZihwcm9wKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93ICgnaW52YWxpZCBvcHRpb246ICcgKyBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcmRlciBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHZhbGlkVmlld3MgYXJyYXkgaXMgc2lnbmlmaWNhbnQuXG4gICAgICAgIHZhciB2YWxpZFZpZXdzID0gWydtaW51dGUnLCAnaG91cicsICdkYXknLCAnbW9udGgnLCAneWVhciddO1xuXG4gICAgICAgIGlmICh2YWxpZFZpZXdzLmluZGV4T2YoY29uZmlndXJhdGlvbi5zdGFydFZpZXcpIDwgMCkge1xuICAgICAgICAgIHRocm93ICgnaW52YWxpZCBzdGFydFZpZXcgdmFsdWU6ICcgKyBjb25maWd1cmF0aW9uLnN0YXJ0Vmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWRWaWV3cy5pbmRleE9mKGNvbmZpZ3VyYXRpb24ubWluVmlldykgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgKCdpbnZhbGlkIG1pblZpZXcgdmFsdWU6ICcgKyBjb25maWd1cmF0aW9uLm1pblZpZXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkVmlld3MuaW5kZXhPZihjb25maWd1cmF0aW9uLm1pblZpZXcpID4gdmFsaWRWaWV3cy5pbmRleE9mKGNvbmZpZ3VyYXRpb24uc3RhcnRWaWV3KSkge1xuICAgICAgICAgIHRocm93ICgnc3RhcnRWaWV3IG11c3QgYmUgZ3JlYXRlciB0aGFuIG1pblZpZXcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihjb25maWd1cmF0aW9uLm1pbnV0ZVN0ZXApKSB7XG4gICAgICAgICAgdGhyb3cgKCdtaW51dGVTdGVwIG11c3QgYmUgbnVtZXJpYycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLm1pbnV0ZVN0ZXAgPD0gMCB8fCBjb25maWd1cmF0aW9uLm1pbnV0ZVN0ZXAgPj0gNjApIHtcbiAgICAgICAgICB0aHJvdyAoJ21pbnV0ZVN0ZXAgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybyBhbmQgbGVzcyB0aGFuIDYwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uZHJvcGRvd25TZWxlY3RvciAhPT0gbnVsbCAmJiAhYW5ndWxhci5pc1N0cmluZyhjb25maWd1cmF0aW9uLmRyb3Bkb3duU2VsZWN0b3IpKSB7XG4gICAgICAgICAgdGhyb3cgKCdkcm9wZG93blNlbGVjdG9yIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLmRyb3Bkb3duU2VsZWN0b3IgIT09IG51bGwgJiYgKCh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykgfHwgKHR5cGVvZiBqUXVlcnkoKS5kcm9wZG93biAhPT0gJ2Z1bmN0aW9uJykpKSB7XG4gICAgICAgICAgJGxvZy5lcnJvcignUGxlYXNlIERPIE5PVCBzcGVjaWZ5IHRoZSBkcm9wZG93blNlbGVjdG9yIG9wdGlvbiB1bmxlc3MgeW91IGFyZSB1c2luZyBqUXVlcnkgQU5EIEJvb3RzdHJhcC5qcy4gJyArXG4gICAgICAgICAgJ1BsZWFzZSBpbmNsdWRlIGpRdWVyeSBBTkQgQm9vdHN0cmFwLmpzLCBvciB3cml0ZSBjb2RlIHRvIGNsb3NlIHRoZSBkcm9wZG93biBpbiB0aGUgb24tc2V0LXRpbWUgY2FsbGJhY2suIFxcblxcbicgK1xuICAgICAgICAgICdUaGUgZHJvcGRvd25TZWxlY3RvciBjb25maWd1cmF0aW9uIG9wdGlvbiBpcyBiZWluZyByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkuJyk7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZ3VyYXRpb24uZHJvcGRvd25TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJkYXRldGltZXBpY2tlciB0YWJsZS1yZXNwb25zaXZlXCI+JyArXG4gICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1jb25kZW5zZWQgIHt7IGRhdGEuY3VycmVudFZpZXcgfX0tdmlld1wiPicgK1xuICAgICAgICAnICAgPHRoZWFkPicgK1xuICAgICAgICAnICAgICAgIDx0cj4nICtcbiAgICAgICAgJyAgICAgICAgICAgPHRoIGNsYXNzPVwibGVmdFwiIGRhdGEtbmctY2xpY2s9XCJjaGFuZ2VWaWV3KGRhdGEuY3VycmVudFZpZXcsIGRhdGEubGVmdERhdGUsICRldmVudClcIiBkYXRhLW5nLXNob3c9XCJkYXRhLmxlZnREYXRlLnNlbGVjdGFibGVcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tYXJyb3ctbGVmdFwiLz48L3RoPicgK1xuICAgICAgICAnICAgICAgICAgICA8dGggY2xhc3M9XCJzd2l0Y2hcIiBjb2xzcGFuPVwiNVwiIGRhdGEtbmctc2hvdz1cImRhdGEucHJldmlvdXNWaWV3RGF0ZS5zZWxlY3RhYmxlXCIgZGF0YS1uZy1jbGljaz1cImNoYW5nZVZpZXcoZGF0YS5wcmV2aW91c1ZpZXcsIGRhdGEucHJldmlvdXNWaWV3RGF0ZSwgJGV2ZW50KVwiPnt7IGRhdGEucHJldmlvdXNWaWV3RGF0ZS5kaXNwbGF5IH19PC90aD4nICtcbiAgICAgICAgJyAgICAgICAgICAgPHRoIGNsYXNzPVwicmlnaHRcIiBkYXRhLW5nLWNsaWNrPVwiY2hhbmdlVmlldyhkYXRhLmN1cnJlbnRWaWV3LCBkYXRhLnJpZ2h0RGF0ZSwgJGV2ZW50KVwiIGRhdGEtbmctc2hvdz1cImRhdGEucmlnaHREYXRlLnNlbGVjdGFibGVcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tYXJyb3ctcmlnaHRcIi8+PC90aD4nICtcbiAgICAgICAgJyAgICAgICA8L3RyPicgK1xuICAgICAgICAnICAgICAgIDx0cj4nICtcbiAgICAgICAgJyAgICAgICAgICAgPHRoIGNsYXNzPVwiZG93XCIgZGF0YS1uZy1yZXBlYXQ9XCJkYXkgaW4gZGF0YS5kYXlOYW1lc1wiID57eyBkYXkgfX08L3RoPicgK1xuICAgICAgICAnICAgICAgIDwvdHI+JyArXG4gICAgICAgICcgICA8L3RoZWFkPicgK1xuICAgICAgICAnICAgPHRib2R5PicgK1xuICAgICAgICAnICAgICAgIDx0ciBkYXRhLW5nLWlmPVwiZGF0YS5jdXJyZW50VmlldyAhPT0gXFwnZGF5XFwnXCIgPicgK1xuICAgICAgICAnICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjdcIiA+JyArXG4gICAgICAgICcgICAgICAgICAgICAgIDxzcGFuICAgIGNsYXNzPVwie3sgZGF0YS5jdXJyZW50VmlldyB9fVwiICcgK1xuICAgICAgICAnICAgICAgICAgICAgICAgICAgICAgICBkYXRhLW5nLXJlcGVhdD1cImRhdGVPYmplY3QgaW4gZGF0YS5kYXRlc1wiICAnICtcbiAgICAgICAgJyAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1uZy1jbGFzcz1cInthY3RpdmU6IGRhdGVPYmplY3QuYWN0aXZlLCBwYXN0OiBkYXRlT2JqZWN0LnBhc3QsIGZ1dHVyZTogZGF0ZU9iamVjdC5mdXR1cmUsIGRpc2FibGVkOiAhZGF0ZU9iamVjdC5zZWxlY3RhYmxlfVwiICcgK1xuICAgICAgICAnICAgICAgICAgICAgICAgICAgICAgICBkYXRhLW5nLWNsaWNrPVwiY2hhbmdlVmlldyhkYXRhLm5leHRWaWV3LCBkYXRlT2JqZWN0LCAkZXZlbnQpXCI+e3sgZGF0ZU9iamVjdC5kaXNwbGF5IH19PC9zcGFuPiAnICtcbiAgICAgICAgJyAgICAgICAgICAgPC90ZD4nICtcbiAgICAgICAgJyAgICAgICA8L3RyPicgK1xuICAgICAgICAnICAgICAgIDx0ciBkYXRhLW5nLWlmPVwiZGF0YS5jdXJyZW50VmlldyA9PT0gXFwnZGF5XFwnXCIgZGF0YS1uZy1yZXBlYXQ9XCJ3ZWVrIGluIGRhdGEud2Vla3NcIj4nICtcbiAgICAgICAgJyAgICAgICAgICAgPHRkIGRhdGEtbmctcmVwZWF0PVwiZGF0ZU9iamVjdCBpbiB3ZWVrLmRhdGVzXCIgJyArXG4gICAgICAgICcgICAgICAgICAgICAgICBkYXRhLW5nLWNsaWNrPVwiY2hhbmdlVmlldyhkYXRhLm5leHRWaWV3LCBkYXRlT2JqZWN0LCAkZXZlbnQpXCInICtcbiAgICAgICAgJyAgICAgICAgICAgICAgIGNsYXNzPVwiZGF5XCIgJyArXG4gICAgICAgICcgICAgICAgICAgICAgICBkYXRhLW5nLWNsYXNzPVwie2FjdGl2ZTogZGF0ZU9iamVjdC5hY3RpdmUsIHBhc3Q6IGRhdGVPYmplY3QucGFzdCwgZnV0dXJlOiBkYXRlT2JqZWN0LmZ1dHVyZSwgZGlzYWJsZWQ6ICFkYXRlT2JqZWN0LnNlbGVjdGFibGV9XCIgPnt7IGRhdGVPYmplY3QuZGlzcGxheSB9fTwvdGQ+JyArXG4gICAgICAgICcgICAgICAgPC90cj4nICtcbiAgICAgICAgJyAgIDwvdGJvZHk+JyArXG4gICAgICAgICc8L3RhYmxlPjwvZGl2PicsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgb25TZXRUaW1lOiAnJicsXG4gICAgICAgICAgYmVmb3JlUmVuZGVyOiAnJidcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDb250cm9sbGVyKSB7XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aXZlQ29uZmlnID0ge307XG5cbiAgICAgICAgICBpZiAoYXR0cnMuZGF0ZXRpbWVwaWNrZXJDb25maWcpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZUNvbmZpZyA9IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuZGF0ZXRpbWVwaWNrZXJDb25maWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge307XG5cbiAgICAgICAgICBhbmd1bGFyLmV4dGVuZChjb25maWd1cmF0aW9uLCBkZWZhdWx0Q29uZmlnLCBkaXJlY3RpdmVDb25maWcpO1xuXG4gICAgICAgICAgdmFsaWRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0T2ZEZWNhZGUgPSBmdW5jdGlvbiBzdGFydE9mRGVjYWRlKHVuaXhEYXRlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRZZWFyID0gKHBhcnNlSW50KG1vbWVudC51dGModW5peERhdGUpLnllYXIoKSAvIDEwLCAxMCkgKiAxMCk7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LnV0Yyh1bml4RGF0ZSkueWVhcihzdGFydFllYXIpLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGRhdGFGYWN0b3J5ID0ge1xuICAgICAgICAgICAgeWVhcjogZnVuY3Rpb24geWVhcih1bml4RGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gbW9tZW50LnV0Yyh1bml4RGF0ZSkuc3RhcnRPZigneWVhcicpO1xuICAgICAgICAgICAgICAvLyBWaWV3IHN0YXJ0cyBvbmUgeWVhciBiZWZvcmUgdGhlIGRlY2FkZSBzdGFydHMgYW5kIGVuZHMgb25lIHllYXIgYWZ0ZXIgdGhlIGRlY2FkZSBlbmRzXG4gICAgICAgICAgICAgIC8vIGkuZS4gcGFzc2luZyBpbiBhIGRhdGUgb2YgMS8xLzIwMTMgd2lsbCBnaXZlIGEgcmFuZ2Ugb2YgMjAwOSB0byAyMDIwXG4gICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBsYXN0IGRpZ2l0IGZyb20gdGhlIGN1cnJlbnQgeWVhciBhbmQgc3VidHJhY3QgMSB0byBnZXQgdGhlIHN0YXJ0IG9mIHRoZSBkZWNhZGVcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0RGVjYWRlID0gKHBhcnNlSW50KHNlbGVjdGVkRGF0ZS55ZWFyKCkgLyAxMCwgMTApICogMTApO1xuICAgICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50LnV0YyhzdGFydE9mRGVjYWRlKHVuaXhEYXRlKSkuc3VidHJhY3QoMSwgJ3llYXInKS5zdGFydE9mKCd5ZWFyJyk7XG5cbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZVllYXIgPSBuZ01vZGVsQ29udHJvbGxlci4kbW9kZWxWYWx1ZSA/IG1vbWVudChuZ01vZGVsQ29udHJvbGxlci4kbW9kZWxWYWx1ZSkueWVhcigpIDogMDtcblxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICdjdXJyZW50Vmlldyc6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAnbmV4dFZpZXcnOiBjb25maWd1cmF0aW9uLm1pblZpZXcgPT09ICd5ZWFyJyA/ICdzZXRUaW1lJyA6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlld0RhdGUnOiBuZXcgRGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB1dGNEYXRlVmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBzdGFydERlY2FkZSArICctJyArIChzdGFydERlY2FkZSArIDkpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgJ2xlZnREYXRlJzogbmV3IERhdGVPYmplY3Qoe3V0Y0RhdGVWYWx1ZTogbW9tZW50LnV0YyhzdGFydERhdGUpLnN1YnRyYWN0KDksICd5ZWFyJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ3JpZ2h0RGF0ZSc6IG5ldyBEYXRlT2JqZWN0KHt1dGNEYXRlVmFsdWU6IG1vbWVudC51dGMoc3RhcnREYXRlKS5hZGQoMTEsICd5ZWFyJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ2RhdGVzJzogW11cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgeWVhck1vbWVudCA9IG1vbWVudC51dGMoc3RhcnREYXRlKS5hZGQoaSwgJ3llYXJzJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICd1dGNEYXRlVmFsdWUnOiB5ZWFyTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogeWVhck1vbWVudC5mb3JtYXQoJ1lZWVknKSxcbiAgICAgICAgICAgICAgICAgICdwYXN0JzogeWVhck1vbWVudC55ZWFyKCkgPCBzdGFydERlY2FkZSxcbiAgICAgICAgICAgICAgICAgICdmdXR1cmUnOiB5ZWFyTW9tZW50LnllYXIoKSA+IHN0YXJ0RGVjYWRlICsgOSxcbiAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiB5ZWFyTW9tZW50LnllYXIoKSA9PT0gYWN0aXZlWWVhclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0ZXMucHVzaChuZXcgRGF0ZU9iamVjdChkYXRlVmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtb250aDogZnVuY3Rpb24gbW9udGgodW5peERhdGUpIHtcblxuICAgICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50LnV0Yyh1bml4RGF0ZSkuc3RhcnRPZigneWVhcicpO1xuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWaWV3RGF0ZSA9IHN0YXJ0T2ZEZWNhZGUodW5peERhdGUpO1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlRGF0ZSA9IG5nTW9kZWxDb250cm9sbGVyLiRtb2RlbFZhbHVlID8gbW9tZW50KG5nTW9kZWxDb250cm9sbGVyLiRtb2RlbFZhbHVlKS5mb3JtYXQoJ1lZWVktTU1NJykgOiAwO1xuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlldyc6ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAnY3VycmVudFZpZXcnOiAnbW9udGgnLFxuICAgICAgICAgICAgICAgICduZXh0Vmlldyc6IGNvbmZpZ3VyYXRpb24ubWluVmlldyA9PT0gJ21vbnRoJyA/ICdzZXRUaW1lJyA6ICdkYXknLFxuICAgICAgICAgICAgICAgICdwcmV2aW91c1ZpZXdEYXRlJzogbmV3IERhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgdXRjRGF0ZVZhbHVlOiBwcmV2aW91c1ZpZXdEYXRlLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHN0YXJ0RGF0ZS5mb3JtYXQoJ1lZWVknKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICdsZWZ0RGF0ZSc6IG5ldyBEYXRlT2JqZWN0KHt1dGNEYXRlVmFsdWU6IG1vbWVudC51dGMoc3RhcnREYXRlKS5zdWJ0cmFjdCgxLCAneWVhcicpLnZhbHVlT2YoKX0pLFxuICAgICAgICAgICAgICAgICdyaWdodERhdGUnOiBuZXcgRGF0ZU9iamVjdCh7dXRjRGF0ZVZhbHVlOiBtb21lbnQudXRjKHN0YXJ0RGF0ZSkuYWRkKDEsICd5ZWFyJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ2RhdGVzJzogW11cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhNb21lbnQgPSBtb21lbnQudXRjKHN0YXJ0RGF0ZSkuYWRkKGksICdtb250aHMnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgJ3V0Y0RhdGVWYWx1ZSc6IG1vbnRoTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogbW9udGhNb21lbnQuZm9ybWF0KCdNTU0nKSxcbiAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiBtb250aE1vbWVudC5mb3JtYXQoJ1lZWVktTU1NJykgPT09IGFjdGl2ZURhdGVcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGVzLnB1c2gobmV3IERhdGVPYmplY3QoZGF0ZVZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGF5OiBmdW5jdGlvbiBkYXkodW5peERhdGUpIHtcblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gbW9tZW50LnV0Yyh1bml4RGF0ZSk7XG4gICAgICAgICAgICAgIHZhciBzdGFydE9mTW9udGggPSBtb21lbnQudXRjKHNlbGVjdGVkRGF0ZSkuc3RhcnRPZignbW9udGgnKTtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzVmlld0RhdGUgPSBtb21lbnQudXRjKHNlbGVjdGVkRGF0ZSkuc3RhcnRPZigneWVhcicpO1xuICAgICAgICAgICAgICB2YXIgZW5kT2ZNb250aCA9IG1vbWVudC51dGMoc2VsZWN0ZWREYXRlKS5lbmRPZignbW9udGgnKTtcblxuICAgICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbW9tZW50LnV0YyhzdGFydE9mTW9udGgpLnN1YnRyYWN0KE1hdGguYWJzKHN0YXJ0T2ZNb250aC53ZWVrZGF5KCkpLCAnZGF5cycpO1xuXG4gICAgICAgICAgICAgIHZhciBhY3RpdmVEYXRlID0gbmdNb2RlbENvbnRyb2xsZXIuJG1vZGVsVmFsdWUgPyBtb21lbnQobmdNb2RlbENvbnRyb2xsZXIuJG1vZGVsVmFsdWUpLmZvcm1hdCgnWVlZWS1NTU0tREQnKSA6ICcnO1xuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlldyc6ICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ2N1cnJlbnRWaWV3JzogJ2RheScsXG4gICAgICAgICAgICAgICAgJ25leHRWaWV3JzogY29uZmlndXJhdGlvbi5taW5WaWV3ID09PSAnZGF5JyA/ICdzZXRUaW1lJyA6ICdob3VyJyxcbiAgICAgICAgICAgICAgICAncHJldmlvdXNWaWV3RGF0ZSc6IG5ldyBEYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgIHV0Y0RhdGVWYWx1ZTogcHJldmlvdXNWaWV3RGF0ZS52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBzdGFydE9mTW9udGguZm9ybWF0KCdZWVlZLU1NTScpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgJ2xlZnREYXRlJzogbmV3IERhdGVPYmplY3Qoe3V0Y0RhdGVWYWx1ZTogbW9tZW50LnV0YyhzdGFydE9mTW9udGgpLnN1YnRyYWN0KDEsICdtb250aHMnKS52YWx1ZU9mKCl9KSxcbiAgICAgICAgICAgICAgICAncmlnaHREYXRlJzogbmV3IERhdGVPYmplY3Qoe3V0Y0RhdGVWYWx1ZTogbW9tZW50LnV0YyhzdGFydE9mTW9udGgpLmFkZCgxLCAnbW9udGhzJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ2RheU5hbWVzJzogW10sXG4gICAgICAgICAgICAgICAgJ3dlZWtzJzogW11cbiAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgIGZvciAodmFyIGRheU51bWJlciA9IDA7IGRheU51bWJlciA8IDc7IGRheU51bWJlciArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRheU5hbWVzLnB1c2gobW9tZW50LnV0YygpLndlZWtkYXkoZGF5TnVtYmVyKS5mb3JtYXQoJ2RkJykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2VlayA9IHtkYXRlczogW119O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbW9udGhNb21lbnQgPSBtb21lbnQudXRjKHN0YXJ0RGF0ZSkuYWRkKChpICogNykgKyBqLCAnZGF5cycpO1xuICAgICAgICAgICAgICAgICAgdmFyIGRhdGVWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ3V0Y0RhdGVWYWx1ZSc6IG1vbnRoTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiBtb250aE1vbWVudC5mb3JtYXQoJ0QnKSxcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IG1vbnRoTW9tZW50LmZvcm1hdCgnWVlZWS1NTU0tREQnKSA9PT0gYWN0aXZlRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bhc3QnOiBtb250aE1vbWVudC5pc0JlZm9yZShzdGFydE9mTW9udGgpLFxuICAgICAgICAgICAgICAgICAgICAnZnV0dXJlJzogbW9udGhNb21lbnQuaXNBZnRlcihlbmRPZk1vbnRoKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHdlZWsuZGF0ZXMucHVzaChuZXcgRGF0ZU9iamVjdChkYXRlVmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LndlZWtzLnB1c2god2Vlayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaG91cjogZnVuY3Rpb24gaG91cih1bml4RGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gbW9tZW50LnV0Yyh1bml4RGF0ZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c1ZpZXdEYXRlID0gbW9tZW50LnV0YyhzZWxlY3RlZERhdGUpLnN0YXJ0T2YoJ21vbnRoJyk7XG5cbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUZvcm1hdCA9IG5nTW9kZWxDb250cm9sbGVyLiRtb2RlbFZhbHVlID8gbW9tZW50KG5nTW9kZWxDb250cm9sbGVyLiRtb2RlbFZhbHVlKS5mb3JtYXQoJ1lZWVktTU0tREQgSCcpIDogJyc7XG5cbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAncHJldmlvdXNWaWV3JzogJ2RheScsXG4gICAgICAgICAgICAgICAgJ2N1cnJlbnRWaWV3JzogJ2hvdXInLFxuICAgICAgICAgICAgICAgICduZXh0Vmlldyc6IGNvbmZpZ3VyYXRpb24ubWluVmlldyA9PT0gJ2hvdXInID8gJ3NldFRpbWUnIDogJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlld0RhdGUnOiBuZXcgRGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB1dGNEYXRlVmFsdWU6IHByZXZpb3VzVmlld0RhdGUudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogc2VsZWN0ZWREYXRlLmZvcm1hdCgnbGwnKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICdsZWZ0RGF0ZSc6IG5ldyBEYXRlT2JqZWN0KHt1dGNEYXRlVmFsdWU6IG1vbWVudC51dGMoc2VsZWN0ZWREYXRlKS5zdWJ0cmFjdCgxLCAnZGF5cycpLnZhbHVlT2YoKX0pLFxuICAgICAgICAgICAgICAgICdyaWdodERhdGUnOiBuZXcgRGF0ZU9iamVjdCh7dXRjRGF0ZVZhbHVlOiBtb21lbnQudXRjKHNlbGVjdGVkRGF0ZSkuYWRkKDEsICdkYXlzJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ2RhdGVzJzogW11cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG91ck1vbWVudCA9IG1vbWVudC51dGMoc2VsZWN0ZWREYXRlKS5hZGQoaSwgJ2hvdXJzJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICd1dGNEYXRlVmFsdWUnOiBob3VyTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICdkaXNwbGF5JzogaG91ck1vbWVudC5mb3JtYXQoJ0xUJyksXG4gICAgICAgICAgICAgICAgICAnYWN0aXZlJzogaG91ck1vbWVudC5mb3JtYXQoJ1lZWVktTU0tREQgSCcpID09PSBhY3RpdmVGb3JtYXRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGVzLnB1c2gobmV3IERhdGVPYmplY3QoZGF0ZVZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWludXRlOiBmdW5jdGlvbiBtaW51dGUodW5peERhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IG1vbWVudC51dGModW5peERhdGUpLnN0YXJ0T2YoJ2hvdXInKTtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzVmlld0RhdGUgPSBtb21lbnQudXRjKHNlbGVjdGVkRGF0ZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVGb3JtYXQgPSBuZ01vZGVsQ29udHJvbGxlci4kbW9kZWxWYWx1ZSA/IG1vbWVudChuZ01vZGVsQ29udHJvbGxlci4kbW9kZWxWYWx1ZSkuZm9ybWF0KCdZWVlZLU1NLUREIEg6bW0nKSA6ICcnO1xuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlldyc6ICdob3VyJyxcbiAgICAgICAgICAgICAgICAnY3VycmVudFZpZXcnOiAnbWludXRlJyxcbiAgICAgICAgICAgICAgICAnbmV4dFZpZXcnOiAnc2V0VGltZScsXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzVmlld0RhdGUnOiBuZXcgRGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB1dGNEYXRlVmFsdWU6IHByZXZpb3VzVmlld0RhdGUudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogc2VsZWN0ZWREYXRlLmZvcm1hdCgnbGxsJylcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAnbGVmdERhdGUnOiBuZXcgRGF0ZU9iamVjdCh7dXRjRGF0ZVZhbHVlOiBtb21lbnQudXRjKHNlbGVjdGVkRGF0ZSkuc3VidHJhY3QoMSwgJ2hvdXJzJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ3JpZ2h0RGF0ZSc6IG5ldyBEYXRlT2JqZWN0KHt1dGNEYXRlVmFsdWU6IG1vbWVudC51dGMoc2VsZWN0ZWREYXRlKS5hZGQoMSwgJ2hvdXJzJykudmFsdWVPZigpfSksXG4gICAgICAgICAgICAgICAgJ2RhdGVzJzogW11cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgbGltaXQgPSA2MCAvIGNvbmZpZ3VyYXRpb24ubWludXRlU3RlcDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG91ck1vbWVudCA9IG1vbWVudC51dGMoc2VsZWN0ZWREYXRlKS5hZGQoaSAqIGNvbmZpZ3VyYXRpb24ubWludXRlU3RlcCwgJ21pbnV0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAndXRjRGF0ZVZhbHVlJzogaG91ck1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAnZGlzcGxheSc6IGhvdXJNb21lbnQuZm9ybWF0KCdMVCcpLFxuICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGhvdXJNb21lbnQuZm9ybWF0KCdZWVlZLU1NLUREIEg6bW0nKSA9PT0gYWN0aXZlRm9ybWF0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRlcy5wdXNoKG5ldyBEYXRlT2JqZWN0KGRhdGVWYWx1ZSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFRpbWU6IGZ1bmN0aW9uIHNldFRpbWUodW5peERhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXBEYXRlID0gbmV3IERhdGUodW5peERhdGUpO1xuICAgICAgICAgICAgICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKHRlbXBEYXRlLmdldFRpbWUoKSArICh0ZW1wRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApKTtcblxuICAgICAgICAgICAgICB2YXIgb2xkRGF0ZSA9IG5nTW9kZWxDb250cm9sbGVyLiRtb2RlbFZhbHVlO1xuICAgICAgICAgICAgICBuZ01vZGVsQ29udHJvbGxlci4kc2V0Vmlld1ZhbHVlKG5ld0RhdGUpO1xuXG4gICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmRyb3Bkb3duU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoY29uZmlndXJhdGlvbi5kcm9wZG93blNlbGVjdG9yKS5kcm9wZG93bigndG9nZ2xlJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzY29wZS5vblNldFRpbWUoe25ld0RhdGU6IG5ld0RhdGUsIG9sZERhdGU6IG9sZERhdGV9KTtcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YUZhY3RvcnlbY29uZmlndXJhdGlvbi5zdGFydFZpZXddKHVuaXhEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGdldFVUQ1RpbWUgPSBmdW5jdGlvbiBnZXRVVENUaW1lKG1vZGVsVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wRGF0ZSA9IChtb2RlbFZhbHVlID8gbW9tZW50KG1vZGVsVmFsdWUpLnRvRGF0ZSgpIDogbmV3IERhdGUoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGVtcERhdGUuZ2V0VGltZSgpIC0gKHRlbXBEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNjb3BlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiBjaGFuZ2VWaWV3KHZpZXdOYW1lLCBkYXRlT2JqZWN0LCBldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlld05hbWUgJiYgKGRhdGVPYmplY3QudXRjRGF0ZVZhbHVlID4gLUluZmluaXR5KSAmJiBkYXRlT2JqZWN0LnNlbGVjdGFibGUgJiYgZGF0YUZhY3Rvcnlbdmlld05hbWVdKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRhRmFjdG9yeVt2aWV3TmFtZV0oZGF0ZU9iamVjdC51dGNEYXRlVmFsdWUpO1xuXG4gICAgICAgICAgICAgIHZhciB3ZWVrRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC53ZWVrcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LndlZWtzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgd2VlayA9IHJlc3VsdC53ZWVrc1tpXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2Vlay5kYXRlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2Vla0RhdGUgPSB3ZWVrLmRhdGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB3ZWVrRGF0ZXMucHVzaCh3ZWVrRGF0ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2NvcGUuYmVmb3JlUmVuZGVyKHtcbiAgICAgICAgICAgICAgICAkdmlldzogcmVzdWx0LmN1cnJlbnRWaWV3LFxuICAgICAgICAgICAgICAgICRkYXRlczogcmVzdWx0LmRhdGVzIHx8IHdlZWtEYXRlcyxcbiAgICAgICAgICAgICAgICAkbGVmdERhdGU6IHJlc3VsdC5sZWZ0RGF0ZSxcbiAgICAgICAgICAgICAgICAkdXBEYXRlOiByZXN1bHQucHJldmlvdXNWaWV3RGF0ZSxcbiAgICAgICAgICAgICAgICAkcmlnaHREYXRlOiByZXN1bHQucmlnaHREYXRlXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHNjb3BlLmRhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5nTW9kZWxDb250cm9sbGVyLiRyZW5kZXIgPSBmdW5jdGlvbiAkcmVuZGVyKCkge1xuICAgICAgICAgICAgc2NvcGUuY2hhbmdlVmlldyhjb25maWd1cmF0aW9uLnN0YXJ0VmlldywgbmV3IERhdGVPYmplY3Qoe3V0Y0RhdGVWYWx1ZTogZ2V0VVRDVGltZShuZ01vZGVsQ29udHJvbGxlci4kdmlld1ZhbHVlKX0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1dKTtcbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvc3JjL2pzL2RhdGV0aW1lcGlja2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDIgM1xuICoqLyIsIi8qKlxuICogbmctY29udGV4dC1tZW51IC0gdjEuMC4xIC0gQW4gQW5ndWxhckpTIGRpcmVjdGl2ZSB0byBkaXNwbGF5IGEgY29udGV4dCBtZW51XG4gKiB3aGVuIGEgcmlnaHQtY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gKlxuICogQGF1dGhvciBJYW4gS2VubmluZ3RvbiBXYWx0ZXIgKGh0dHA6Ly9pYW52b253YWx0ZXIuY29tKVxuICovXG5hbmd1bGFyXG4gIC5tb2R1bGUoJ25nLWNvbnRleHQtbWVudScsIFtdKVxuICAuZmFjdG9yeSgnQ29udGV4dE1lbnVTZXJ2aWNlJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICBtZW51RWxlbWVudDogbnVsbFxuICAgIH07XG4gIH0pXG4gIC5kaXJlY3RpdmUoJ2NvbnRleHRNZW51JywgW1xuICAgICckZG9jdW1lbnQnLFxuICAgICdDb250ZXh0TWVudVNlcnZpY2UnLFxuICAgIGZ1bmN0aW9uKCRkb2N1bWVudCwgQ29udGV4dE1lbnVTZXJ2aWNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICdjYWxsYmFjayc6ICcmY29udGV4dE1lbnUnLFxuICAgICAgICAgICdkaXNhYmxlZCc6ICcmY29udGV4dE1lbnVEaXNhYmxlZCcsXG4gICAgICAgICAgJ2Nsb3NlQ2FsbGJhY2snOiAnJmNvbnRleHRNZW51Q2xvc2UnXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuICAgICAgICAgIHZhciBvcGVuZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9wZW4oZXZlbnQsIG1lbnVFbGVtZW50KSB7XG4gICAgICAgICAgICBtZW51RWxlbWVudC5hZGRDbGFzcygnb3BlbicpO1xuXG4gICAgICAgICAgICB2YXIgZG9jID0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBkb2NMZWZ0ID0gKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2Muc2Nyb2xsTGVmdCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jLmNsaWVudExlZnQgfHwgMCksXG4gICAgICAgICAgICAgICAgZG9jVG9wID0gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2Muc2Nyb2xsVG9wKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGRvYy5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgICAgICAgICAgZWxlbWVudFdpZHRoID0gbWVudUVsZW1lbnRbMF0uc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICAgICAgZWxlbWVudEhlaWdodCA9IG1lbnVFbGVtZW50WzBdLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIHZhciBkb2NXaWR0aCA9IGRvYy5jbGllbnRXaWR0aCArIGRvY0xlZnQsXG4gICAgICAgICAgICAgIGRvY0hlaWdodCA9IGRvYy5jbGllbnRIZWlnaHQgKyBkb2NUb3AsXG4gICAgICAgICAgICAgIHRvdGFsV2lkdGggPSBlbGVtZW50V2lkdGggKyBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgdG90YWxIZWlnaHQgPSBlbGVtZW50SGVpZ2h0ICsgZXZlbnQucGFnZVksXG4gICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChldmVudC5wYWdlWCAtIGRvY0xlZnQsIDApLFxuICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heChldmVudC5wYWdlWSAtIGRvY1RvcCwgMCk7XG5cbiAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gZG9jV2lkdGgpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgLSAodG90YWxXaWR0aCAtIGRvY1dpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvdGFsSGVpZ2h0ID4gZG9jSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHRvcCA9IHRvcCAtICh0b3RhbEhlaWdodCAtIGRvY0hlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbnVFbGVtZW50LmNzcygndG9wJywgdG9wICsgJ3B4Jyk7XG4gICAgICAgICAgICBtZW51RWxlbWVudC5jc3MoJ2xlZnQnLCBsZWZ0ICsgJ3B4Jyk7XG4gICAgICAgICAgICBvcGVuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlKG1lbnVFbGVtZW50KSB7XG4gICAgICAgICAgICBtZW51RWxlbWVudC5yZW1vdmVDbGFzcygnb3BlbicpO1xuXG4gICAgICAgICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgICAgICAgICRzY29wZS5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZW5lZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRlbGVtZW50LmJpbmQoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLmRpc2FibGVkKCkpIHtcbiAgICAgICAgICAgICAgaWYgKENvbnRleHRNZW51U2VydmljZS5tZW51RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsb3NlKENvbnRleHRNZW51U2VydmljZS5tZW51RWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgQ29udGV4dE1lbnVTZXJ2aWNlLm1lbnVFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCRhdHRycy50YXJnZXQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIENvbnRleHRNZW51U2VydmljZS5lbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzZXQnLCBDb250ZXh0TWVudVNlcnZpY2UuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmNhbGxiYWNrKHsgJGV2ZW50OiBldmVudCB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3BlbihldmVudCwgQ29udGV4dE1lbnVTZXJ2aWNlLm1lbnVFbGVtZW50KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVLZXlVcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdrZXl1cCcpO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuZGlzYWJsZWQoKSAmJiBvcGVuZWQgJiYgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjbG9zZShDb250ZXh0TWVudVNlcnZpY2UubWVudUVsZW1lbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVDbGlja0V2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS5kaXNhYmxlZCgpICYmXG4gICAgICAgICAgICAgIG9wZW5lZCAmJlxuICAgICAgICAgICAgICAoZXZlbnQuYnV0dG9uICE9PSAyIHx8XG4gICAgICAgICAgICAgICBldmVudC50YXJnZXQgIT09IENvbnRleHRNZW51U2VydmljZS5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNsb3NlKENvbnRleHRNZW51U2VydmljZS5tZW51RWxlbWVudCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgICRkb2N1bWVudC5iaW5kKCdrZXl1cCcsIGhhbmRsZUtleVVwRXZlbnQpO1xuICAgICAgICAgIC8vIEZpcmVmb3ggdHJlYXRzIGEgcmlnaHQtY2xpY2sgYXMgYSBjbGljayBhbmQgYSBjb250ZXh0bWVudSBldmVudFxuICAgICAgICAgIC8vIHdoaWxlIG90aGVyIGJyb3dzZXJzIGp1c3QgdHJlYXQgaXQgYXMgYSBjb250ZXh0bWVudSBldmVudFxuICAgICAgICAgICRkb2N1bWVudC5iaW5kKCdjbGljaycsIGhhbmRsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICRkb2N1bWVudC5iaW5kKCdjb250ZXh0bWVudScsIGhhbmRsZUNsaWNrRXZlbnQpO1xuXG4gICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Rlc3Ryb3knKTtcbiAgICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2tleXVwJywgaGFuZGxlS2V5VXBFdmVudCk7XG4gICAgICAgICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGhhbmRsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY29udGV4dG1lbnUnLCBoYW5kbGVDbGlja0V2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIF0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMveHVnZS9wcm9qZWN0L3F1YW5zaGktdWkvfi9uZy1jb250ZXh0LW1lbnUvZGlzdC9uZy1jb250ZXh0LW1lbnUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyohIGpRdWVyeSBVSSAtIHYxLjEwLjMgLSAyMDEzLTA1LTAzXG4qIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiogSW5jbHVkZXM6IGpxdWVyeS51aS5jb3JlLmpzLCBqcXVlcnkudWkud2lkZ2V0LmpzLCBqcXVlcnkudWkubW91c2UuanMsIGpxdWVyeS51aS5kcmFnZ2FibGUuanMsIGpxdWVyeS51aS5kcm9wcGFibGUuanMsIGpxdWVyeS51aS5yZXNpemFibGUuanMsIGpxdWVyeS51aS5zZWxlY3RhYmxlLmpzLCBqcXVlcnkudWkuc29ydGFibGUuanMsIGpxdWVyeS51aS5lZmZlY3QuanMsIGpxdWVyeS51aS5hY2NvcmRpb24uanMsIGpxdWVyeS51aS5hdXRvY29tcGxldGUuanMsIGpxdWVyeS51aS5idXR0b24uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLmpzLCBqcXVlcnkudWkuZGlhbG9nLmpzLCBqcXVlcnkudWkuZWZmZWN0LWJsaW5kLmpzLCBqcXVlcnkudWkuZWZmZWN0LWJvdW5jZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1jbGlwLmpzLCBqcXVlcnkudWkuZWZmZWN0LWRyb3AuanMsIGpxdWVyeS51aS5lZmZlY3QtZXhwbG9kZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1mYWRlLmpzLCBqcXVlcnkudWkuZWZmZWN0LWZvbGQuanMsIGpxdWVyeS51aS5lZmZlY3QtaGlnaGxpZ2h0LmpzLCBqcXVlcnkudWkuZWZmZWN0LXB1bHNhdGUuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2NhbGUuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2hha2UuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2xpZGUuanMsIGpxdWVyeS51aS5lZmZlY3QtdHJhbnNmZXIuanMsIGpxdWVyeS51aS5tZW51LmpzLCBqcXVlcnkudWkucG9zaXRpb24uanMsIGpxdWVyeS51aS5wcm9ncmVzc2Jhci5qcywganF1ZXJ5LnVpLnNsaWRlci5qcywganF1ZXJ5LnVpLnNwaW5uZXIuanMsIGpxdWVyeS51aS50YWJzLmpzLCBqcXVlcnkudWkudG9vbHRpcC5qc1xuKiBDb3B5cmlnaHQgMjAxMyBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyAkLnVpIG1pZ2h0IGV4aXN0IGZyb20gY29tcG9uZW50cyB3aXRoIG5vIGRlcGVuZGVuY2llcywgZS5nLiwgJC51aS5wb3NpdGlvblxuJC51aSA9ICQudWkgfHwge307XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0Zm9jdXM6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkKCBlbGVtICkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmZvY3VzICksXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkgfHwgKC9hYnNvbHV0ZS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcyxcInBvc2l0aW9uXCIpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0ekluZGV4OiBmdW5jdGlvbiggekluZGV4ICkge1xuXHRcdGlmICggekluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiekluZGV4XCIsIHpJbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXNbIDAgXSApLCBwb3NpdGlvbiwgdmFsdWU7XG5cdFx0XHR3aGlsZSAoIGVsZW0ubGVuZ3RoICYmIGVsZW1bIDAgXSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnNcblx0XHRcdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHRcdC8vIG90aGVyIGJyb3dzZXJzIHJldHVybiBhIHN0cmluZ1xuXHRcdFx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KCBlbGVtLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHR1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCsrdXVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bmlxdWVJZC50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIHNlbGVjdG9yc1xuZnVuY3Rpb24gZm9jdXNhYmxlKCBlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9I1wiICsgbWFwTmFtZSArIFwiXVwiIClbMF07XG5cdFx0cmV0dXJuICEhaW1nICYmIHZpc2libGUoIGltZyApO1xuXHR9XG5cdHJldHVybiAoIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbiQuc3VwcG9ydC5zZWxlY3RzdGFydCA9IFwib25zZWxlY3RzdGFydFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1dWlkID0gMCxcblx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdF9jbGVhbkRhdGEgPSAkLmNsZWFuRGF0YTtcbiQuY2xlYW5EYXRhID0gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHR0cnkge1xuXHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdH0gY2F0Y2goIGUgKSB7fVxuXHR9XG5cdF9jbGVhbkRhdGEoIGVsZW1zICk7XG59O1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBmdWxsTmFtZSwgZXhpc3RpbmdDb25zdHJ1Y3RvciwgY29uc3RydWN0b3IsIGJhc2VQcm90b3R5cGUsXG5cdFx0Ly8gcHJveGllZFByb3RvdHlwZSBhbGxvd3MgdGhlIHByb3ZpZGVkIHByb3RvdHlwZSB0byByZW1haW4gdW5tb2RpZmllZFxuXHRcdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdFx0cHJveGllZFByb3RvdHlwZSA9IHt9LFxuXHRcdG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblxuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHRmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFwiLVwiICsgbmFtZTtcblxuXHRpZiAoICFwcm90b3R5cGUgKSB7XG5cdFx0cHJvdG90eXBlID0gYmFzZTtcblx0XHRiYXNlID0gJC5XaWRnZXQ7XG5cdH1cblxuXHQvLyBjcmVhdGUgc2VsZWN0b3IgZm9yIHBsdWdpblxuXHQkLmV4cHJbIFwiOlwiIF1bIGZ1bGxOYW1lLnRvTG93ZXJDYXNlKCkgXSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZnVsbE5hbWUgKTtcblx0fTtcblxuXHQkWyBuYW1lc3BhY2UgXSA9ICRbIG5hbWVzcGFjZSBdIHx8IHt9O1xuXHRleGlzdGluZ0NvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXTtcblx0Y29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cdC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblx0XHQvLyBjb3B5IHRoZSBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhlIHByb3RvdHlwZSBpbiBjYXNlIHdlIG5lZWQgdG9cblx0XHQvLyByZWRlZmluZSB0aGUgd2lkZ2V0IGxhdGVyXG5cdFx0X3Byb3RvOiAkLmV4dGVuZCgge30sIHByb3RvdHlwZSApLFxuXHRcdC8vIHRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9KTtcblxuXHRiYXNlUHJvdG90eXBlID0gbmV3IGJhc2UoKTtcblx0Ly8gd2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgX3N1cGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc3VwZXJBcHBseSA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0X19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseSxcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsdWUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX19zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9fc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cdH0pO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyBiYXNlUHJvdG90eXBlLndpZGdldEV2ZW50UHJlZml4IDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0pO1xuXG5cdC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XG5cdC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cblx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcblx0Ly8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cblx0aWYgKCBleGlzdGluZ0NvbnN0cnVjdG9yICkge1xuXHRcdCQuZWFjaCggZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uKCBpLCBjaGlsZCApIHtcblx0XHRcdHZhciBjaGlsZFByb3RvdHlwZSA9IGNoaWxkLnByb3RvdHlwZTtcblxuXHRcdFx0Ly8gcmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcblx0XHRcdC8vIG9yaWdpbmFsbHkgdXNlZCwgYnV0IGluaGVyaXQgZnJvbSB0aGUgbmV3IHZlcnNpb24gb2YgdGhlIGJhc2Vcblx0XHRcdCQud2lkZ2V0KCBjaGlsZFByb3RvdHlwZS5uYW1lc3BhY2UgKyBcIi5cIiArIGNoaWxkUHJvdG90eXBlLndpZGdldE5hbWUsIGNvbnN0cnVjdG9yLCBjaGlsZC5fcHJvdG8gKTtcblx0XHR9KTtcblx0XHQvLyByZW1vdmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2hpbGQgY29uc3RydWN0b3JzIGZyb20gdGhlIG9sZCBjb25zdHJ1Y3RvclxuXHRcdC8vIHNvIHRoZSBvbGQgY2hpbGQgY29uc3RydWN0b3JzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycztcblx0fSBlbHNlIHtcblx0XHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKCBjb25zdHJ1Y3RvciApO1xuXHR9XG5cblx0JC53aWRnZXQuYnJpZGdlKCBuYW1lLCBjb25zdHJ1Y3RvciApO1xufTtcblxuJC53aWRnZXQuZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0dmFyIGlucHV0ID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGFsbG93IG11bHRpcGxlIGhhc2hlcyB0byBiZSBwYXNzZWQgb24gaW5pdFxuXHRcdG9wdGlvbnMgPSAhaXNNZXRob2RDYWxsICYmIGFyZ3MubGVuZ3RoID9cblx0XHRcdCQud2lkZ2V0LmV4dGVuZC5hcHBseSggbnVsbCwgWyBvcHRpb25zIF0uY29uY2F0KGFyZ3MpICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdGlmICggaXNNZXRob2RDYWxsICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWV0aG9kVmFsdWUsXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBuYW1lICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICtcblx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2Vbb3B0aW9uc10gKSB8fCBvcHRpb25zLmNoYXJBdCggMCApID09PSBcIl9cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJubyBzdWNoIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInIGZvciBcIiArIG5hbWUgKyBcIiB3aWRnZXQgaW5zdGFuY2VcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2VbIG9wdGlvbnMgXS5hcHBseSggaW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdFx0aWYgKCBtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IG1ldGhvZFZhbHVlICYmIG1ldGhvZFZhbHVlLmpxdWVyeSA/XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0bWV0aG9kVmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICkuX2luaXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KCBvcHRpb25zLCB0aGlzICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xufTtcblxuJC5XaWRnZXQgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgZWxlbWVudCAqLyApIHt9O1xuJC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XG5cbiQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcblx0d2lkZ2V0TmFtZTogXCJ3aWRnZXRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjcmVhdGU6IG51bGxcblx0fSxcblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoKTtcblx0XHR0aGlzLmhvdmVyYWJsZSA9ICQoKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoKTtcblxuXHRcdGlmICggZWxlbWVudCAhPT0gdGhpcyApIHtcblx0XHRcdCQuZGF0YSggZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyApO1xuXHRcdFx0dGhpcy5fb24oIHRydWUsIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZWxlbWVudCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cdFx0XHRcdC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxuXHRcdFx0XHQvLyBlbGVtZW50IGlzIHdpbmRvdyBvciBkb2N1bWVudFxuXHRcdFx0XHRlbGVtZW50LmRvY3VtZW50IHx8IGVsZW1lbnQgKTtcblx0XHRcdHRoaXMud2luZG93ID0gJCggdGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY3JlYXRlXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpICk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9LFxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cdF9jcmVhdGU6ICQubm9vcCxcblx0X2luaXQ6ICQubm9vcCxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9kZXN0cm95KCk7XG5cdFx0Ly8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxuXHRcdC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC8vIDEuOSBCQyBmb3IgIzc4MTBcblx0XHRcdC8vIFRPRE8gcmVtb3ZlIGR1YWwgc3RvcmFnZVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0TmFtZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApXG5cdFx0XHQvLyBzdXBwb3J0OiBqcXVlcnkgPDEuNi4zXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzXG5cdFx0XHQucmVtb3ZlRGF0YSggJC5jYW1lbENhc2UoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0dGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3MudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0fSxcblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleSxcblx0XHRcdHBhcnRzLFxuXHRcdFx0Y3VyT3B0aW9uLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIGRvbid0IHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgaGFzaFxuXHRcdFx0cmV0dXJuICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdC8vIGhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXCJmb28uYmFyXCIgPT4geyBmb286IHsgYmFyOiBfX18gfSB9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRwYXJ0cyA9IGtleS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyT3B0aW9uID0gb3B0aW9uc1sga2V5IF0gPSAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnNbIGtleSBdICk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0XHRcdGN1ck9wdGlvblsgcGFydHNbIGkgXSBdID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gfHwge307XG5cdFx0XHRcdFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VyT3B0aW9uWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN1ck9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyT3B0aW9uWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnMoIG9wdGlvbnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHRcdC50b2dnbGVDbGFzcyggdGhpcy53aWRnZXRGdWxsTmFtZSArIFwiLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdH0sXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudCxcblx0XHRcdGluc3RhbmNlID0gdGhpcztcblxuXHRcdC8vIG5vIHN1cHByZXNzRGlzYWJsZWRDaGVjayBmbGFnLCBzaHVmZmxlIGFyZ3VtZW50c1xuXHRcdGlmICggdHlwZW9mIHN1cHByZXNzRGlzYWJsZWRDaGVjayAhPT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gc3VwcHJlc3NEaXNhYmxlZENoZWNrO1xuXHRcdFx0c3VwcHJlc3NEaXNhYmxlZENoZWNrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbm8gZWxlbWVudCBhcmd1bWVudCwgc2h1ZmZsZSBhbmQgdXNlIHRoaXMuZWxlbWVudFxuXHRcdGlmICggIWhhbmRsZXJzICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGRlbGVnYXRlRWxlbWVudCA9IHRoaXMud2lkZ2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGFjY2VwdCBzZWxlY3RvcnMsIERPTSBlbGVtZW50c1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdFx0Ly8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgYXMgYW4gYXJyYXkgaW5zdGVhZCBvZiBib29sZWFuXG5cdFx0XHRcdC8vIC0gZGlzYWJsZWQgY2xhc3MgYXMgbWV0aG9kIGZvciBkaXNhYmxpbmcgaW5kaXZpZHVhbCBwYXJ0c1xuXHRcdFx0XHRpZiAoICFzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgJiZcblx0XHRcdFx0XHRcdCggaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fFxuXHRcdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihcXHcrKVxccyooLiopJC8gKSxcblx0XHRcdFx0ZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcblx0XHRcdFx0c2VsZWN0b3IgPSBtYXRjaFsyXTtcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGRlbGVnYXRlRWxlbWVudC5kZWxlZ2F0ZSggc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LmJpbmQoIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFwiXCIpLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICsgdGhpcy5ldmVudE5hbWVzcGFjZTtcblx0XHRlbGVtZW50LnVuYmluZCggZXZlbnROYW1lICkudW5kZWxlZ2F0ZSggZXZlbnROYW1lICk7XG5cdH0sXG5cblx0X2RlbGF5OiBmdW5jdGlvbiggaGFuZGxlciwgZGVsYXkgKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KCBoYW5kbGVyUHJveHksIGRlbGF5IHx8IDAgKTtcblx0fSxcblxuXHRfaG92ZXJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmhvdmVyYWJsZSA9IHRoaXMuaG92ZXJhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRtb3VzZWVudGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9LFxuXHRcdFx0bW91c2VsZWF2ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9mb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdGZvY3VzaW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1c291dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0dmFyIHByb3AsIG9yaWcsXG5cdFx0XHRjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0Ly8gdGhlIG9yaWdpbmFsIGV2ZW50IG1heSBjb21lIGZyb20gYW55IGVsZW1lbnRcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB0YXJnZXQgb24gdGhlIG5ldyBldmVudFxuXHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuZWxlbWVudFsgMCBdO1xuXG5cdFx0Ly8gY29weSBvcmlnaW5hbCBldmVudCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIG5ldyBldmVudFxuXHRcdG9yaWcgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXHRcdGlmICggb3JpZyApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0aWYgKCAhKCBwcm9wIGluIGV2ZW50ICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBldmVudCwgZGF0YSApO1xuXHRcdHJldHVybiAhKCAkLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgJiZcblx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLmVsZW1lbnRbMF0sIFsgZXZlbnQgXS5jb25jYXQoIGRhdGEgKSApID09PSBmYWxzZSB8fFxuXHRcdFx0ZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKTtcblx0fVxufTtcblxuJC5lYWNoKCB7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIGRlZmF1bHRFZmZlY3QgKSB7XG5cdCQuV2lkZ2V0LnByb3RvdHlwZVsgXCJfXCIgKyBtZXRob2QgXSA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZWZmZWN0OiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdHZhciBoYXNPcHRpb25zLFxuXHRcdFx0ZWZmZWN0TmFtZSA9ICFvcHRpb25zID9cblx0XHRcdFx0bWV0aG9kIDpcblx0XHRcdFx0b3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdFx0ZGVmYXVsdEVmZmVjdCA6XG5cdFx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3QoIG9wdGlvbnMgKTtcblx0XHRvcHRpb25zLmNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblx0XHRpZiAoIGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIG1ldGhvZCBdKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbIGVmZmVjdE5hbWUgXSApIHtcblx0XHRcdGVsZW1lbnRbIGVmZmVjdE5hbWUgXSggb3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5tb3VzZXVwKCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59KTtcblxuJC53aWRnZXQoXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjYW5jZWw6IFwiaW5wdXQsdGV4dGFyZWEsYnV0dG9uLHNlbGVjdCxvcHRpb25cIixcblx0XHRkaXN0YW5jZTogMSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfbW91c2VJbml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKFwibW91c2Vkb3duLlwiK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoXCJjbGljay5cIit0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUT0RPOiBtYWtlIHN1cmUgZGVzdHJveWluZyBvbmUgaW5zdGFuY2Ugb2YgbW91c2UgZG9lc24ndCBtZXNzIHdpdGhcblx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXG5cdF9tb3VzZURlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC51bmJpbmQoXCIuXCIrdGhpcy53aWRnZXROYW1lKTtcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlICkge1xuXHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG5cdFx0aWYoIG1vdXNlSGFuZGxlZCApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQodGhpcy5fbW91c2VTdGFydGVkICYmIHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblxuXHRcdHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidG5Jc0xlZnQgPSAoZXZlbnQud2hpY2ggPT09IDEpLFxuXHRcdFx0Ly8gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBJRSA4IHdpdGhcblx0XHRcdC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXG5cdFx0XHRlbElzQ2FuY2VsID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aCA6IGZhbHNlKTtcblx0XHRpZiAoIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoZXZlbnQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICghdGhpcy5tb3VzZURlbGF5TWV0KSB7XG5cdFx0XHR0aGlzLl9tb3VzZURlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9ICh0aGlzLl9tb3VzZVN0YXJ0KGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXG5cdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpKSB7XG5cdFx0XHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtcblx0XHR9XG5cblx0XHQvLyB0aGVzZSBkZWxlZ2F0ZXMgYXJlIHJlcXVpcmVkIHRvIGtlZXAgY29udGV4dFxuXHRcdHRoaXMuX21vdXNlTW92ZURlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoZXZlbnQpO1xuXHRcdH07XG5cdFx0dGhpcy5fbW91c2VVcERlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcblx0XHR9O1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LmJpbmQoXCJtb3VzZXVwLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRtb3VzZUhhbmRsZWQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZU1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdGlmICgkLnVpLmllICYmICggIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5ICkgJiYgIWV2ZW50LmJ1dHRvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRyZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9XG5cdFx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgPyB0aGlzLl9tb3VzZURyYWcoZXZlbnQpIDogdGhpcy5fbW91c2VVcChldmVudCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQudW5iaW5kKFwibW91c2Vtb3ZlLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdCQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gKE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWCAtIGV2ZW50LnBhZ2VYKSxcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVkgLSBldmVudC5wYWdlWSlcblx0XHRcdCkgPj0gdGhpcy5vcHRpb25zLmRpc3RhbmNlXG5cdFx0KTtcblx0fSxcblxuXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xuXHR9LFxuXG5cdC8vIFRoZXNlIGFyZSBwbGFjZWhvbGRlciBtZXRob2RzLCB0byBiZSBvdmVycmlkZW4gYnkgZXh0ZW5kaW5nIHBsdWdpblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHsgcmV0dXJuIHRydWU7IH1cbn0pO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5kcmFnZ2FibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcmFnXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhZGRDbGFzc2VzOiB0cnVlLFxuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RUb1NvcnRhYmxlOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpZnJhbWVGaXg6IGZhbHNlLFxuXHRcdG9wYWNpdHk6IGZhbHNlLFxuXHRcdHJlZnJlc2hQb3NpdGlvbnM6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0cmV2ZXJ0RHVyYXRpb246IDUwMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c25hcDogZmFsc2UsXG5cdFx0c25hcE1vZGU6IFwiYm90aFwiLFxuXHRcdHNuYXBUb2xlcmFuY2U6IDIwLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHR6SW5kZXg6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0ZHJhZzogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiAmJiAhKC9eKD86cnxhfGYpLykudGVzdCh0aGlzLmVsZW1lbnQuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYWRkQ2xhc3Nlcyl7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGVcIik7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlLWRpc2FibGVkXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1kcmFnZ2FibGUgdWktZHJhZ2dhYmxlLWRyYWdnaW5nIHVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiICk7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gYW1vbmcgb3RoZXJzLCBwcmV2ZW50IGEgZHJhZyBvbiBhIHJlc2l6YWJsZS1oYW5kbGVcblx0XHRpZiAodGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcIi51aS1yZXNpemFibGUtaGFuZGxlXCIpLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvL1F1aXQgaWYgd2UncmUgbm90IG9uIGEgdmFsaWQgaGFuZGxlXG5cdFx0dGhpcy5oYW5kbGUgPSB0aGlzLl9nZXRIYW5kbGUoZXZlbnQpO1xuXHRcdGlmICghdGhpcy5oYW5kbGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQkKG8uaWZyYW1lRml4ID09PSB0cnVlID8gXCJpZnJhbWVcIiA6IG8uaWZyYW1lRml4KS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0JChcIjxkaXYgY2xhc3M9J3VpLWRyYWdnYWJsZS1pZnJhbWVGaXgnIHN0eWxlPSdiYWNrZ3JvdW5kOiAjZmZmOyc+PC9kaXY+XCIpXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0d2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgrXCJweFwiLCBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0K1wicHhcIixcblx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgb3BhY2l0eTogXCIwLjAwMVwiLCB6SW5kZXg6IDEwMDBcblx0XHRcdH0pXG5cdFx0XHQuY3NzKCQodGhpcykub2Zmc2V0KCkpXG5cdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XG5cblx0XHR0aGlzLmhlbHBlci5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKTtcblxuXHRcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9JZiBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgc2V0IHRoZSBnbG9iYWwgZHJhZ2dhYmxlXG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBnZW5lcmF0aW9uIC1cblx0XHQgKiBUaGlzIGJsb2NrIGdlbmVyYXRlcyBldmVyeXRoaW5nIHBvc2l0aW9uIHJlbGF0ZWQgLSBpdCdzIHRoZSBjb3JlIG9mIGRyYWdnYWJsZXMuXG5cdFx0ICovXG5cblx0XHQvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XG5cdFx0dGhpcy5fY2FjaGVNYXJnaW5zKCk7XG5cblx0XHQvL1N0b3JlIHRoZSBoZWxwZXIncyBjc3MgcG9zaXRpb25cblx0XHR0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHR0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO1xuXHRcdHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XG5cdFx0dGhpcy5vZmZzZXRQYXJlbnRDc3NQb3NpdGlvbiA9IHRoaXMub2Zmc2V0UGFyZW50LmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHQvL1RoZSBlbGVtZW50J3MgYWJzb2x1dGUgcG9zaXRpb24gb24gdGhlIHBhZ2UgbWludXMgbWFyZ2luc1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblx0XHR0aGlzLm9mZnNldCA9IHtcblx0XHRcdHRvcDogdGhpcy5vZmZzZXQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdFxuXHRcdH07XG5cblx0XHQvL1Jlc2V0IHNjcm9sbCBjYWNoZVxuXHRcdHRoaXMub2Zmc2V0LnNjcm9sbCA9IGZhbHNlO1xuXG5cdFx0JC5leHRlbmQodGhpcy5vZmZzZXQsIHtcblx0XHRcdGNsaWNrOiB7IC8vV2hlcmUgdGhlIGNsaWNrIGhhcHBlbmVkLCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHRcdH0sXG5cdFx0XHRwYXJlbnQ6IHRoaXMuX2dldFBhcmVudE9mZnNldCgpLFxuXHRcdFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCkgLy9UaGlzIGlzIGEgcmVsYXRpdmUgdG8gYWJzb2x1dGUgcG9zaXRpb24gbWludXMgdGhlIGFjdHVhbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIG9ubHkgdXNlZCBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBoZWxwZXJcblx0XHR9KTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFwiY3Vyc29yQXRcIiBpcyBzdXBwbGllZFxuXHRcdChvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCkpO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XG5cblx0XHQvL1RyaWdnZXIgZXZlbnQgKyBjYWxsYmFja3Ncblx0XHRpZih0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvL1JlY2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9QcmVwYXJlIHRoZSBkcm9wcGFibGUgb2Zmc2V0c1xuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQsIHRydWUpOyAvL0V4ZWN1dGUgdGhlIGRyYWcgb25jZSAtIHRoaXMgY2F1c2VzIHRoZSBoZWxwZXIgbm90IHRvIGJlIHZpc2libGUgYmVmb3JlIGdldHRpbmcgaXRzIGNvcnJlY3QgcG9zaXRpb25cblxuXHRcdC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZCAoc2VlICM1MDAzKVxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnU3RhcnQodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cdFx0Ly8gcmVzZXQgYW55IG5lY2Vzc2FyeSBjYWNoZWQgcHJvcGVydGllcyAoc2VlICM1MDA5KVxuXHRcdGlmICggdGhpcy5vZmZzZXRQYXJlbnRDc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0dGhpcy5vZmZzZXQucGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0Ly9DYWxsIHBsdWdpbnMgYW5kIGNhbGxiYWNrcyBhbmQgdXNlIHRoZSByZXN1bHRpbmcgcG9zaXRpb24gaWYgc29tZXRoaW5nIGlzIHJldHVybmVkXG5cdFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHR2YXIgdWkgPSB0aGlzLl91aUhhc2goKTtcblx0XHRcdGlmKHRoaXMuX3RyaWdnZXIoXCJkcmFnXCIsIGV2ZW50LCB1aSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcInlcIikge1xuXHRcdFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCtcInB4XCI7XG5cdFx0fVxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXCJ4XCIpIHtcblx0XHRcdHRoaXMuaGVscGVyWzBdLnN0eWxlLnRvcCA9IHRoaXMucG9zaXRpb24udG9wK1wicHhcIjtcblx0XHR9XG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0ZHJvcHBlZCA9IGZhbHNlO1xuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdGRyb3BwZWQgPSAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvL2lmIGEgZHJvcCBjb21lcyBmcm9tIG91dHNpZGUgKGEgc29ydGFibGUpXG5cdFx0aWYodGhpcy5kcm9wcGVkKSB7XG5cdFx0XHRkcm9wcGVkID0gdGhpcy5kcm9wcGVkO1xuXHRcdFx0dGhpcy5kcm9wcGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9pZiB0aGUgb3JpZ2luYWwgZWxlbWVudCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSBkb24ndCBib3RoZXIgdG8gY29udGludWUgKHNlZSAjODI2OSlcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiAmJiAhJC5jb250YWlucyggdGhpcy5lbGVtZW50WyAwIF0ub3duZXJEb2N1bWVudCwgdGhpcy5lbGVtZW50WyAwIF0gKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZigodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJpbnZhbGlkXCIgJiYgIWRyb3BwZWQpIHx8ICh0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSBcInZhbGlkXCIgJiYgZHJvcHBlZCkgfHwgdGhpcy5vcHRpb25zLnJldmVydCA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5yZXZlcnQpICYmIHRoaXMub3B0aW9ucy5yZXZlcnQuY2FsbCh0aGlzLmVsZW1lbnQsIGRyb3BwZWQpKSkge1xuXHRcdFx0JCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh0aGlzLm9yaWdpbmFsUG9zaXRpb24sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbiwgMTApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYodGhhdC5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoYXQuX2NsZWFyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZih0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vUmVtb3ZlIGZyYW1lIGhlbHBlcnNcblx0XHQkKFwiZGl2LnVpLWRyYWdnYWJsZS1pZnJhbWVGaXhcIikuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHR9KTtcblxuXHRcdC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RvcHBlZCAoc2VlICM1MDAzKVxuXHRcdGlmKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdG9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJC51aS5tb3VzZS5wcm90b3R5cGUuX21vdXNlVXAuY2FsbCh0aGlzLCBldmVudCk7XG5cdH0sXG5cblx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuaGVscGVyLmlzKFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKSkge1xuXHRcdFx0dGhpcy5fbW91c2VVcCh7fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfZ2V0SGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaGFuZGxlID9cblx0XHRcdCEhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSApLmxlbmd0aCA6XG5cdFx0XHR0cnVlO1xuXHR9LFxuXG5cdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGhlbHBlciA9ICQuaXNGdW5jdGlvbihvLmhlbHBlcikgPyAkKG8uaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50XSkpIDogKG8uaGVscGVyID09PSBcImNsb25lXCIgPyB0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKFwiaWRcIikgOiB0aGlzLmVsZW1lbnQpO1xuXG5cdFx0aWYoIWhlbHBlci5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGgpIHtcblx0XHRcdGhlbHBlci5hcHBlbmRUbygoby5hcHBlbmRUbyA9PT0gXCJwYXJlbnRcIiA/IHRoaXMuZWxlbWVudFswXS5wYXJlbnROb2RlIDogby5hcHBlbmRUbykpO1xuXHRcdH1cblxuXHRcdGlmKGhlbHBlclswXSAhPT0gdGhpcy5lbGVtZW50WzBdICYmICEoLyhmaXhlZHxhYnNvbHV0ZSkvKS50ZXN0KGhlbHBlci5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdGhlbHBlci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWxwZXI7XG5cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdChcIiBcIik7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKFwibGVmdFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChcInJpZ2h0XCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJ0b3BcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoXCJib3R0b21cIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXG5cdFx0dmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZSBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBwb3NpdGlvbmVkIHBhcmVudFxuXHRcdC8vIDIuIFRoZSBhY3R1YWwgb2Zmc2V0IHBhcmVudCBpcyBhIGNoaWxkIG9mIHRoZSBzY3JvbGwgcGFyZW50LCBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXNuJ3QgdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0XG5cdFx0Ly8gICAgdGhlIHNjcm9sbCBpcyBpbmNsdWRlZCBpbiB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXG5cdFx0aWYodGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcblx0XHRcdHBvLmxlZnQgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuXHRcdH1cblxuXHRcdC8vVGhpcyBuZWVkcyB0byBiZSBhY3R1YWxseSBkb25lIGZvciBhbGwgYnJvd3NlcnMsIHNpbmNlIHBhZ2VYL3BhZ2VZIGluY2x1ZGVzIHRoaXMgaW5mb3JtYXRpb25cblx0XHQvL1VnbHkgSUUgZml4XG5cdFx0aWYoKHRoaXMub2Zmc2V0UGFyZW50WzBdID09PSBkb2N1bWVudC5ib2R5KSB8fFxuXHRcdFx0KHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUgJiYgdGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiAmJiAkLnVpLmllKSkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwidG9wXCIpLDEwKSB8fCAwKSArIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiBwLmxlZnQgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwibGVmdFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWFyZ2lucyA9IHtcblx0XHRcdGxlZnQ6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwxMCkgfHwgMCksXG5cdFx0XHR0b3A6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKSxcblx0XHRcdHJpZ2h0OiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpblJpZ2h0XCIpLDEwKSB8fCAwKSxcblx0XHRcdGJvdHRvbTogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIiksMTApIHx8IDApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgb3ZlciwgYywgY2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCAhby5jb250YWlubWVudCApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJ3aW5kb3dcIiApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbExlZnQoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wLFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgKyAkKCB3aW5kb3cgKS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxUb3AoKSArICggJCggd2luZG93ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJkb2N1bWVudFwiKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQwLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHQkKCBkb2N1bWVudCApLndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRcdCggJCggZG9jdW1lbnQgKS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0ICkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRcdF07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50LmNvbnN0cnVjdG9yID09PSBBcnJheSApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBvLmNvbnRhaW5tZW50O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJwYXJlbnRcIiApIHtcblx0XHRcdG8uY29udGFpbm1lbnQgPSB0aGlzLmhlbHBlclsgMCBdLnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0YyA9ICQoIG8uY29udGFpbm1lbnQgKTtcblx0XHRjZSA9IGNbIDAgXTtcblxuXHRcdGlmKCAhY2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3ZlciA9IGMuY3NzKCBcIm92ZXJmbG93XCIgKSAhPT0gXCJoaWRkZW5cIjtcblxuXHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApLCAxMCApIHx8IDAgKSArICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdMZWZ0XCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJUb3BXaWR0aFwiICksIDEwICkgfHwgMCApICsgKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1RvcFwiICksIDEwICkgfHwgMCApICxcblx0XHRcdCggb3ZlciA/IE1hdGgubWF4KCBjZS5zY3JvbGxXaWR0aCwgY2Uub2Zmc2V0V2lkdGggKSA6IGNlLm9mZnNldFdpZHRoICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJSaWdodFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nUmlnaHRcIiApLCAxMCApIHx8IDAgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCAtIHRoaXMubWFyZ2lucy5yaWdodCxcblx0XHRcdCggb3ZlciA/IE1hdGgubWF4KCBjZS5zY3JvbGxIZWlnaHQsIGNlLm9mZnNldEhlaWdodCApIDogY2Uub2Zmc2V0SGVpZ2h0ICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJCb3R0b21XaWR0aFwiICksIDEwICkgfHwgMCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ0JvdHRvbVwiICksIDEwICkgfHwgMCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wICAtIHRoaXMubWFyZ2lucy5ib3R0b21cblx0XHRdO1xuXHRcdHRoaXMucmVsYXRpdmVfY29udGFpbmVyID0gYztcblx0fSxcblxuXHRfY29udmVydFBvc2l0aW9uVG86IGZ1bmN0aW9uKGQsIHBvcykge1xuXG5cdFx0aWYoIXBvcykge1xuXHRcdFx0cG9zID0gdGhpcy5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHR2YXIgbW9kID0gZCA9PT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudDtcblxuXHRcdC8vQ2FjaGUgdGhlIHNjcm9sbFxuXHRcdGlmICghdGhpcy5vZmZzZXQuc2Nyb2xsKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5zY3JvbGwgPSB7dG9wIDogc2Nyb2xsLnNjcm9sbFRvcCgpLCBsZWZ0IDogc2Nyb2xsLnNjcm9sbExlZnQoKX07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwb3MudG9wXHQrXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kICtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kIC1cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wICkgKiBtb2QgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cG9zLmxlZnQgK1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2QgK1x0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kXHQtXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0ICkgKiBtb2QgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBjb250YWlubWVudCwgY28sIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiYgISggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSwgdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxuXHRcdFx0cGFnZVggPSBldmVudC5wYWdlWCxcblx0XHRcdHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0NhY2hlIHRoZSBzY3JvbGxcblx0XHRpZiAoIXRoaXMub2Zmc2V0LnNjcm9sbCkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge3RvcCA6IHNjcm9sbC5zY3JvbGxUb3AoKSwgbGVmdCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCl9O1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxuXHRcdCAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXG5cdFx0ICovXG5cblx0XHQvLyBJZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcblx0XHRpZiAoIHRoaXMub3JpZ2luYWxQb3NpdGlvbiApIHtcblx0XHRcdGlmICggdGhpcy5jb250YWlubWVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbGF0aXZlX2NvbnRhaW5lciApe1xuXHRcdFx0XHRcdGNvID0gdGhpcy5yZWxhdGl2ZV9jb250YWluZXIub2Zmc2V0KCk7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAwIF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMSBdICsgY28udG9wLFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMiBdICsgY28ubGVmdCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDMgXSArIGNvLnRvcFxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSB0aGlzLmNvbnRhaW5tZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0pIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFsxXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkge1xuXHRcdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnRbMl0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10pIHtcblx0XHRcdFx0XHRwYWdlWSA9IGNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uZ3JpZCkge1xuXHRcdFx0XHQvL0NoZWNrIGZvciBncmlkIGVsZW1lbnRzIHNldCB0byAwIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDAgZXJyb3IgY2F1c2luZyBpbnZhbGlkIGFyZ3VtZW50IGVycm9ycyBpbiBJRSAoc2VlIHRpY2tldCAjNjk1MClcblx0XHRcdFx0dG9wID0gby5ncmlkWzFdID8gdGhpcy5vcmlnaW5hbFBhZ2VZICsgTWF0aC5yb3VuZCgocGFnZVkgLSB0aGlzLm9yaWdpbmFsUGFnZVkpIC8gby5ncmlkWzFdKSAqIG8uZ3JpZFsxXSA6IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudCA/ICgodG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IGNvbnRhaW5tZW50WzFdIHx8IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSA/IHRvcCA6ICgodG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IGNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdGxlZnQgPSBvLmdyaWRbMF0gPyB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdIDogdGhpcy5vcmlnaW5hbFBhZ2VYO1xuXHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50ID8gKChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSB8fCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WzJdKSA/IGxlZnQgOiAoKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IGNvbnRhaW5tZW50WzBdKSA/IGxlZnQgLSBvLmdyaWRbMF0gOiBsZWZ0ICsgby5ncmlkWzBdKSkgOiBsZWZ0O1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwYWdlWSAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3BcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3AgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cGFnZVggLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXIucmVtb3ZlQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cdFx0aWYodGhpcy5oZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhdGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dGhpcy5oZWxwZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIEZyb20gbm93IG9uIGJ1bGsgc3R1ZmYgLSBtYWlubHkgaGVscGVyc1xuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBldmVudCwgdWkpIHtcblx0XHR1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xuXHRcdCQudWkucGx1Z2luLmNhbGwodGhpcywgdHlwZSwgW2V2ZW50LCB1aV0pO1xuXHRcdC8vVGhlIGFic29sdXRlIHBvc2l0aW9uIGhhcyB0byBiZSByZWNhbGN1bGF0ZWQgYWZ0ZXIgcGx1Z2luc1xuXHRcdGlmKHR5cGUgPT09IFwiZHJhZ1wiKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblx0XHR9XG5cdFx0cmV0dXJuICQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5jYWxsKHRoaXMsIHR5cGUsIGV2ZW50LCB1aSk7XG5cdH0sXG5cblx0cGx1Z2luczoge30sXG5cblx0X3VpSGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogdGhpcy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcblx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdG9mZnNldDogdGhpcy5wb3NpdGlvbkFic1xuXHRcdH07XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImNvbm5lY3RUb1NvcnRhYmxlXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksIG8gPSBpbnN0Lm9wdGlvbnMsXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblx0XHRpbnN0LnNvcnRhYmxlcyA9IFtdO1xuXHRcdCQoby5jb25uZWN0VG9Tb3J0YWJsZSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9ICQuZGF0YSh0aGlzLCBcInVpLXNvcnRhYmxlXCIpO1xuXHRcdFx0aWYgKHNvcnRhYmxlICYmICFzb3J0YWJsZS5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdGluc3Quc29ydGFibGVzLnB1c2goe1xuXHRcdFx0XHRcdGluc3RhbmNlOiBzb3J0YWJsZSxcblx0XHRcdFx0XHRzaG91bGRSZXZlcnQ6IHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb3J0YWJsZS5yZWZyZXNoUG9zaXRpb25zKCk7XHQvLyBDYWxsIHRoZSBzb3J0YWJsZSdzIHJlZnJlc2hQb3NpdGlvbnMgYXQgZHJhZyBzdGFydCB0byByZWZyZXNoIHRoZSBjb250YWluZXJDYWNoZSBzaW5jZSB0aGUgc29ydGFibGUgY29udGFpbmVyIGNhY2hlIGlzIHVzZWQgaW4gZHJhZyBhbmQgbmVlZHMgdG8gYmUgdXAgdG8gZGF0ZSAodGhpcyB3aWxsIGVuc3VyZSBpdCdzIGluaXRpYWxpc2VkIGFzIHdlbGwgYXMgYmVpbmcga2VwdCBpbiBzdGVwIHdpdGggYW55IGNoYW5nZXMgdGhhdCBtaWdodCBoYXZlIGhhcHBlbmVkIG9uIHRoZSBwYWdlKS5cblx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHQvL0lmIHdlIGFyZSBzdGlsbCBvdmVyIHRoZSBzb3J0YWJsZSwgd2UgZmFrZSB0aGUgc3RvcCBldmVudCBvZiB0aGUgc29ydGFibGUsIGJ1dCBhbHNvIHJlbW92ZSBoZWxwZXJcblx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSxcblx0XHRcdHVpU29ydGFibGUgPSAkLmV4dGVuZCh7fSwgdWksIHsgaXRlbTogaW5zdC5lbGVtZW50IH0pO1xuXG5cdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5pc092ZXIgPSAwO1xuXG5cdFx0XHRcdGluc3QuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7IC8vRG9uJ3QgcmVtb3ZlIHRoZSBoZWxwZXIgaW4gdGhlIGRyYWdnYWJsZSBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTsgLy9SZW1vdmUgaXQgaW4gdGhlIHNvcnRhYmxlIGluc3RhbmNlIChzbyBzb3J0YWJsZSBwbHVnaW5zIGxpa2UgcmV2ZXJ0IHN0aWxsIHdvcmspXG5cblx0XHRcdFx0Ly9UaGUgc29ydGFibGUgcmV2ZXJ0IGlzIHN1cHBvcnRlZCwgYW5kIHdlIGhhdmUgdG8gc2V0IGEgdGVtcG9yYXJ5IGRyb3BwZWQgdmFyaWFibGUgb24gdGhlIGRyYWdnYWJsZSB0byBzdXBwb3J0IHJldmVydDogXCJ2YWxpZC9pbnZhbGlkXCJcblx0XHRcdFx0aWYodGhpcy5zaG91bGRSZXZlcnQpIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMucmV2ZXJ0ID0gdGhpcy5zaG91bGRSZXZlcnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1RyaWdnZXIgdGhlIHN0b3Agb2YgdGhlIHNvcnRhYmxlXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChldmVudCk7XG5cblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdC8vSWYgdGhlIGhlbHBlciBoYXMgYmVlbiB0aGUgb3JpZ2luYWwgaXRlbSwgcmVzdG9yZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHRpZihpbnN0Lm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIpIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLmNzcyh7IHRvcDogXCJhdXRvXCIsIGxlZnQ6IFwiYXV0b1wiIH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlOyAvL1JlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCB0aGF0ID0gdGhpcztcblxuXHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSBmYWxzZSxcblx0XHRcdFx0dGhpc1NvcnRhYmxlID0gdGhpcztcblxuXHRcdFx0Ly9Db3B5IG92ZXIgc29tZSB2YXJpYWJsZXMgdG8gYWxsb3cgY2FsbGluZyB0aGUgc29ydGFibGUncyBuYXRpdmUgX2ludGVyc2VjdHNXaXRoXG5cdFx0XHR0aGlzLmluc3RhbmNlLnBvc2l0aW9uQWJzID0gaW5zdC5wb3NpdGlvbkFicztcblx0XHRcdHRoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnMgPSBpbnN0LmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblxuXHRcdFx0aWYodGhpcy5pbnN0YW5jZS5faW50ZXJzZWN0c1dpdGgodGhpcy5pbnN0YW5jZS5jb250YWluZXJDYWNoZSkpIHtcblx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicyA9IGluc3QucG9zaXRpb25BYnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGluc3QuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblx0XHRcdFx0XHRpZiAodGhpcyAhPT0gdGhpc1NvcnRhYmxlICYmXG5cdFx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmluc3RhbmNlLmNvbnRhaW5lckNhY2hlKSAmJlxuXHRcdFx0XHRcdFx0JC5jb250YWlucyh0aGlzU29ydGFibGUuaW5zdGFuY2UuZWxlbWVudFswXSwgdGhpcy5pbnN0YW5jZS5lbGVtZW50WzBdKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbm5lcm1vc3RJbnRlcnNlY3Rpbmc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmKGlubmVybW9zdEludGVyc2VjdGluZykge1xuXHRcdFx0XHQvL0lmIGl0IGludGVyc2VjdHMsIHdlIHVzZSBhIGxpdHRsZSBpc092ZXIgdmFyaWFibGUgYW5kIHNldCBpdCBvbmNlLCBzbyBvdXIgbW92ZS1pbiBzdHVmZiBnZXRzIGZpcmVkIG9ubHkgb25jZVxuXHRcdFx0XHRpZighdGhpcy5pbnN0YW5jZS5pc092ZXIpIHtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMTtcblx0XHRcdFx0XHQvL05vdyB3ZSBmYWtlIHRoZSBzdGFydCBvZiBkcmFnZ2luZyBmb3IgdGhlIHNvcnRhYmxlIGluc3RhbmNlLFxuXHRcdFx0XHRcdC8vYnkgY2xvbmluZyB0aGUgbGlzdCBncm91cCBpdGVtLCBhcHBlbmRpbmcgaXQgdG8gdGhlIHNvcnRhYmxlIGFuZCB1c2luZyBpdCBhcyBpbnN0LmN1cnJlbnRJdGVtXG5cdFx0XHRcdFx0Ly9XZSBjYW4gdGhlbiBmaXJlIHRoZSBzdGFydCBldmVudCBvZiB0aGUgc29ydGFibGUgd2l0aCBvdXIgcGFzc2VkIGJyb3dzZXIgZXZlbnQsIGFuZCBvdXIgb3duIGhlbHBlciAoc28gaXQgZG9lc24ndCBjcmVhdGUgYSBuZXcgb25lKVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0gPSAkKHRoYXQpLmNsb25lKCkucmVtb3ZlQXR0cihcImlkXCIpLmFwcGVuZFRvKHRoaXMuaW5zdGFuY2UuZWxlbWVudCkuZGF0YShcInVpLXNvcnRhYmxlLWl0ZW1cIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyOyAvL1N0b3JlIGhlbHBlciBvcHRpb24gdG8gbGF0ZXIgcmVzdG9yZSBpdFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHVpLmhlbHBlclswXTsgfTtcblxuXHRcdFx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW1bMF07XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VDYXB0dXJlKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0YXJ0KGV2ZW50LCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vQmVjYXVzZSB0aGUgYnJvd3NlciBldmVudCBpcyB3YXkgb2ZmIHRoZSBuZXcgYXBwZW5kZWQgcG9ydGxldCwgd2UgbW9kaWZ5IGEgY291cGxlIG9mIHZhcmlhYmxlcyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sudG9wID0gaW5zdC5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLmxlZnQgPSBpbnN0Lm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC5sZWZ0IC09IGluc3Qub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LmxlZnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcCAtPSBpbnN0Lm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcDtcblxuXHRcdFx0XHRcdGluc3QuX3RyaWdnZXIoXCJ0b1NvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSB0aGlzLmluc3RhbmNlLmVsZW1lbnQ7IC8vZHJhZ2dhYmxlIHJldmVydCBuZWVkcyB0aGF0XG5cdFx0XHRcdFx0Ly9oYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXG5cdFx0XHRcdFx0aW5zdC5jdXJyZW50SXRlbSA9IGluc3QuZWxlbWVudDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmZyb21PdXRzaWRlID0gaW5zdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9Qcm92aWRlZCB3ZSBkaWQgYWxsIHRoZSBwcmV2aW91cyBzdGVwcywgd2UgY2FuIGZpcmUgdGhlIGRyYWcgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIG9uIGV2ZXJ5IGRyYWdnYWJsZSBkcmFnLCB3aGVuIGl0IGludGVyc2VjdHMgd2l0aCB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbSkge1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnRhYmxlLCBhbmQgaXQgaW50ZXJzZWN0ZWQgYmVmb3JlLFxuXHRcdFx0XHQvL3dlIGZha2UgdGhlIGRyYWcgc3RvcCBvZiB0aGUgc29ydGFibGUsIGJ1dCBtYWtlIHN1cmUgaXQgZG9lc24ndCByZW1vdmUgdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsXG5cdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDA7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vUHJldmVudCByZXZlcnRpbmcgb24gdGhpcyBmb3JjZWQgc3RvcFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5yZXZlcnQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIFRoZSBvdXQgZXZlbnQgbmVlZHMgdG8gYmUgdHJpZ2dlcmVkIGluZGVwZW5kZW50bHlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLmluc3RhbmNlLl91aUhhc2godGhpcy5pbnN0YW5jZSkpO1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdG9wKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXI7XG5cblx0XHRcdFx0XHQvL05vdyB3ZSByZW1vdmUgb3VyIGN1cnJlbnRJdGVtLCB0aGUgbGlzdCBncm91cCBjbG9uZSBhZ2FpbiwgYW5kIHRoZSBwbGFjZWhvbGRlciwgYW5kIGFuaW1hdGUgdGhlIGhlbHBlciBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgc2l6ZVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlci5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnN0Ll90cmlnZ2VyKFwiZnJvbVNvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSBmYWxzZTsgLy9kcmFnZ2FibGUgcmV2ZXJ0IG5lZWRzIHRoYXRcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwiY3Vyc29yXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ID0gJChcImJvZHlcIiksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZiAodC5jc3MoXCJjdXJzb3JcIikpIHtcblx0XHRcdG8uX2N1cnNvciA9IHQuY3NzKFwiY3Vyc29yXCIpO1xuXHRcdH1cblx0XHR0LmNzcyhcImN1cnNvclwiLCBvLmN1cnNvcik7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYgKG8uX2N1cnNvcikge1xuXHRcdFx0JChcImJvZHlcIikuY3NzKFwiY3Vyc29yXCIsIG8uX2N1cnNvcik7XG5cdFx0fVxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwib3BhY2l0eVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwib3BhY2l0eVwiKSkge1xuXHRcdFx0by5fb3BhY2l0eSA9IHQuY3NzKFwib3BhY2l0eVwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJvcGFjaXR5XCIsIG8ub3BhY2l0eSk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYoby5fb3BhY2l0eSkge1xuXHRcdFx0JCh1aS5oZWxwZXIpLmNzcyhcIm9wYWNpdHlcIiwgby5fb3BhY2l0eSk7XG5cdFx0fVxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic2Nyb2xsXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpO1xuXHRcdGlmKGkuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiBpLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9PSBcIkhUTUxcIikge1xuXHRcdFx0aS5vdmVyZmxvd09mZnNldCA9IGkuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHRcdH1cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksIG8gPSBpLm9wdGlvbnMsIHNjcm9sbGVkID0gZmFsc2U7XG5cblx0XHRpZihpLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPT0gXCJIVE1MXCIpIHtcblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieFwiKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LnRvcCArIGkuc2Nyb2xsUGFyZW50WzBdLm9mZnNldEhlaWdodCkgLSBldmVudC5wYWdlWSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZihldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wIC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdFx0aWYoKGkub3ZlcmZsb3dPZmZzZXQubGVmdCArIGkuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoKSAtIGV2ZW50LnBhZ2VYIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVggLSBpLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIikge1xuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYoc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGksIGV2ZW50KTtcblx0XHR9XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInNuYXBcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSxcblx0XHRcdG8gPSBpLm9wdGlvbnM7XG5cblx0XHRpLnNuYXBFbGVtZW50cyA9IFtdO1xuXG5cdFx0JChvLnNuYXAuY29uc3RydWN0b3IgIT09IFN0cmluZyA/ICggby5zbmFwLml0ZW1zIHx8IFwiOmRhdGEodWktZHJhZ2dhYmxlKVwiICkgOiBvLnNuYXApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHQgPSAkKHRoaXMpLFxuXHRcdFx0XHQkbyA9ICR0Lm9mZnNldCgpO1xuXHRcdFx0aWYodGhpcyAhPT0gaS5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdGkuc25hcEVsZW1lbnRzLnB1c2goe1xuXHRcdFx0XHRcdGl0ZW06IHRoaXMsXG5cdFx0XHRcdFx0d2lkdGg6ICR0Lm91dGVyV2lkdGgoKSwgaGVpZ2h0OiAkdC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHRvcDogJG8udG9wLCBsZWZ0OiAkby5sZWZ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIHRzLCBicywgbHMsIHJzLCBsLCByLCB0LCBiLCBpLCBmaXJzdCxcblx0XHRcdGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHRvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0ZCA9IG8uc25hcFRvbGVyYW5jZSxcblx0XHRcdHgxID0gdWkub2Zmc2V0LmxlZnQsIHgyID0geDEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdFx0eTEgPSB1aS5vZmZzZXQudG9wLCB5MiA9IHkxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0XHRmb3IgKGkgPSBpbnN0LnNuYXBFbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cblx0XHRcdGwgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS5sZWZ0O1xuXHRcdFx0ciA9IGwgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS53aWR0aDtcblx0XHRcdHQgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS50b3A7XG5cdFx0XHRiID0gdCArIGluc3Quc25hcEVsZW1lbnRzW2ldLmhlaWdodDtcblxuXHRcdFx0aWYgKCB4MiA8IGwgLSBkIHx8IHgxID4gciArIGQgfHwgeTIgPCB0IC0gZCB8fCB5MSA+IGIgKyBkIHx8ICEkLmNvbnRhaW5zKCBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0ub3duZXJEb2N1bWVudCwgaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtICkgKSB7XG5cdFx0XHRcdGlmKGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nKSB7XG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiYgaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uc25hcE1vZGUgIT09IFwiaW5uZXJcIikge1xuXHRcdFx0XHR0cyA9IE1hdGguYWJzKHQgLSB5MikgPD0gZDtcblx0XHRcdFx0YnMgPSBNYXRoLmFicyhiIC0geTEpIDw9IGQ7XG5cdFx0XHRcdGxzID0gTWF0aC5hYnMobCAtIHgyKSA8PSBkO1xuXHRcdFx0XHRycyA9IE1hdGguYWJzKHIgLSB4MSkgPD0gZDtcblx0XHRcdFx0aWYodHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiB0IC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihscykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiAwLCBsZWZ0OiBsIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QgPSAodHMgfHwgYnMgfHwgbHMgfHwgcnMpO1xuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9PSBcIm91dGVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTEpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkyKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MSkgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDIpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCwgbGVmdDogMCB9KS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogYiAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyAmJiAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpKSB7XG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMuc25hcC5zbmFwICYmIGluc3Qub3B0aW9ucy5zbmFwLnNuYXAuY2FsbChpbnN0LmVsZW1lbnQsIGV2ZW50LCAkLmV4dGVuZChpbnN0Ll91aUhhc2goKSwgeyBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSB9KSkpO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpO1xuXG5cdFx0fVxuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzdGFja1wiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWluLFxuXHRcdFx0byA9IHRoaXMuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zLFxuXHRcdFx0Z3JvdXAgPSAkLm1ha2VBcnJheSgkKG8uc3RhY2spKS5zb3J0KGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0XHRyZXR1cm4gKHBhcnNlSW50KCQoYSkuY3NzKFwiekluZGV4XCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICghZ3JvdXAubGVuZ3RoKSB7IHJldHVybjsgfVxuXG5cdFx0bWluID0gcGFyc2VJbnQoJChncm91cFswXSkuY3NzKFwiekluZGV4XCIpLCAxMCkgfHwgMDtcblx0XHQkKGdyb3VwKS5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdCQodGhpcykuY3NzKFwiekluZGV4XCIsIG1pbiArIGkpO1xuXHRcdH0pO1xuXHRcdHRoaXMuY3NzKFwiekluZGV4XCIsIChtaW4gKyBncm91cC5sZW5ndGgpKTtcblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInpJbmRleFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwiekluZGV4XCIpKSB7XG5cdFx0XHRvLl96SW5kZXggPSB0LmNzcyhcInpJbmRleFwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJ6SW5kZXhcIiwgby56SW5kZXgpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKG8uX3pJbmRleCkge1xuXHRcdFx0JCh1aS5oZWxwZXIpLmNzcyhcInpJbmRleFwiLCBvLl96SW5kZXgpO1xuXHRcdH1cblx0fVxufSk7XG5cbn0pKGpRdWVyeSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG5mdW5jdGlvbiBpc092ZXJBeGlzKCB4LCByZWZlcmVuY2UsIHNpemUgKSB7XG5cdHJldHVybiAoIHggPiByZWZlcmVuY2UgKSAmJiAoIHggPCAoIHJlZmVyZW5jZSArIHNpemUgKSApO1xufVxuXG4kLndpZGdldChcInVpLmRyb3BwYWJsZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcImRyb3BcIixcblx0b3B0aW9uczoge1xuXHRcdGFjY2VwdDogXCIqXCIsXG5cdFx0YWN0aXZlQ2xhc3M6IGZhbHNlLFxuXHRcdGFkZENsYXNzZXM6IHRydWUsXG5cdFx0Z3JlZWR5OiBmYWxzZSxcblx0XHRob3ZlckNsYXNzOiBmYWxzZSxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0dG9sZXJhbmNlOiBcImludGVyc2VjdFwiLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0YWN0aXZhdGU6IG51bGwsXG5cdFx0ZGVhY3RpdmF0ZTogbnVsbCxcblx0XHRkcm9wOiBudWxsLFxuXHRcdG91dDogbnVsbCxcblx0XHRvdmVyOiBudWxsXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRhY2NlcHQgPSBvLmFjY2VwdDtcblxuXHRcdHRoaXMuaXNvdmVyID0gZmFsc2U7XG5cdFx0dGhpcy5pc291dCA9IHRydWU7XG5cblx0XHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0IDogZnVuY3Rpb24oZCkge1xuXHRcdFx0cmV0dXJuIGQuaXMoYWNjZXB0KTtcblx0XHR9O1xuXG5cdFx0Ly9TdG9yZSB0aGUgZHJvcHBhYmxlJ3MgcHJvcG9ydGlvbnNcblx0XHR0aGlzLnByb3BvcnRpb25zID0geyB3aWR0aDogdGhpcy5lbGVtZW50WzBdLm9mZnNldFdpZHRoLCBoZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5vZmZzZXRIZWlnaHQgfTtcblxuXHRcdC8vIEFkZCB0aGUgcmVmZXJlbmNlIGFuZCBwb3NpdGlvbnMgdG8gdGhlIG1hbmFnZXJcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW28uc2NvcGVdID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tvLnNjb3BlXSB8fCBbXTtcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW28uc2NvcGVdLnB1c2godGhpcyk7XG5cblx0XHQoby5hZGRDbGFzc2VzICYmIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyb3BwYWJsZVwiKSk7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0ZHJvcCA9ICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbdGhpcy5vcHRpb25zLnNjb3BlXTtcblxuXHRcdGZvciAoIDsgaSA8IGRyb3AubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIGRyb3BbaV0gPT09IHRoaXMgKSB7XG5cdFx0XHRcdGRyb3Auc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLWRyb3BwYWJsZSB1aS1kcm9wcGFibGUtZGlzYWJsZWRcIik7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXG5cdFx0aWYoa2V5ID09PSBcImFjY2VwdFwiKSB7XG5cdFx0XHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0cmV0dXJuIGQuaXModmFsdWUpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdFx0aWYoZHJhZ2dhYmxlKXtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X2RlYWN0aXZhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdFx0aWYoZHJhZ2dhYmxlKXtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb3ZlcjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBkcmFnZ2FibGUgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xuXG5cdFx0Ly8gQmFpbCBpZiBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBhcmUgc2FtZSBlbGVtZW50XG5cdFx0aWYgKCFkcmFnZ2FibGUgfHwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudClbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkpIHtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKFwib3ZlclwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcblx0XHR9XG5cblx0fSxcblxuXHRfb3V0OiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cblx0XHQvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcblx0XHRpZiAoIWRyYWdnYWJsZSB8fCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KVswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJvdXRcIiwgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSk7XG5cdFx0fVxuXG5cdH0sXG5cblx0X2Ryb3A6IGZ1bmN0aW9uKGV2ZW50LGN1c3RvbSkge1xuXG5cdFx0dmFyIGRyYWdnYWJsZSA9IGN1c3RvbSB8fCAkLnVpLmRkbWFuYWdlci5jdXJyZW50LFxuXHRcdFx0Y2hpbGRyZW5JbnRlcnNlY3Rpb24gPSBmYWxzZTtcblxuXHRcdC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXHRcdGlmICghZHJhZ2dhYmxlIHx8IChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQuZmluZChcIjpkYXRhKHVpLWRyb3BwYWJsZSlcIikubm90KFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluc3QgPSAkLmRhdGEodGhpcywgXCJ1aS1kcm9wcGFibGVcIik7XG5cdFx0XHRpZihcblx0XHRcdFx0aW5zdC5vcHRpb25zLmdyZWVkeSAmJlxuXHRcdFx0XHQhaW5zdC5vcHRpb25zLmRpc2FibGVkICYmXG5cdFx0XHRcdGluc3Qub3B0aW9ucy5zY29wZSA9PT0gZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGUgJiZcblx0XHRcdFx0aW5zdC5hY2NlcHQuY2FsbChpbnN0LmVsZW1lbnRbMF0sIChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSAmJlxuXHRcdFx0XHQkLnVpLmludGVyc2VjdChkcmFnZ2FibGUsICQuZXh0ZW5kKGluc3QsIHsgb2Zmc2V0OiBpbnN0LmVsZW1lbnQub2Zmc2V0KCkgfSksIGluc3Qub3B0aW9ucy50b2xlcmFuY2UpXG5cdFx0XHQpIHsgY2hpbGRyZW5JbnRlcnNlY3Rpb24gPSB0cnVlOyByZXR1cm4gZmFsc2U7IH1cblx0XHR9KTtcblx0XHRpZihjaGlsZHJlbkludGVyc2VjdGlvbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJkcm9wXCIsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHR1aTogZnVuY3Rpb24oYykge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkcmFnZ2FibGU6IChjLmN1cnJlbnRJdGVtIHx8IGMuZWxlbWVudCksXG5cdFx0XHRoZWxwZXI6IGMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IGMucG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IGMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLmludGVyc2VjdCA9IGZ1bmN0aW9uKGRyYWdnYWJsZSwgZHJvcHBhYmxlLCB0b2xlcmFuY2VNb2RlKSB7XG5cblx0aWYgKCFkcm9wcGFibGUub2Zmc2V0KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGRyYWdnYWJsZUxlZnQsIGRyYWdnYWJsZVRvcCxcblx0XHR4MSA9IChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS5sZWZ0LCB4MiA9IHgxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdHkxID0gKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLnRvcCwgeTIgPSB5MSArIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsXG5cdFx0bCA9IGRyb3BwYWJsZS5vZmZzZXQubGVmdCwgciA9IGwgKyBkcm9wcGFibGUucHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0dCA9IGRyb3BwYWJsZS5vZmZzZXQudG9wLCBiID0gdCArIGRyb3BwYWJsZS5wcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0c3dpdGNoICh0b2xlcmFuY2VNb2RlKSB7XG5cdFx0Y2FzZSBcImZpdFwiOlxuXHRcdFx0cmV0dXJuIChsIDw9IHgxICYmIHgyIDw9IHIgJiYgdCA8PSB5MSAmJiB5MiA8PSBiKTtcblx0XHRjYXNlIFwiaW50ZXJzZWN0XCI6XG5cdFx0XHRyZXR1cm4gKGwgPCB4MSArIChkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSAmJiAvLyBSaWdodCBIYWxmXG5cdFx0XHRcdHgyIC0gKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIpIDwgciAmJiAvLyBMZWZ0IEhhbGZcblx0XHRcdFx0dCA8IHkxICsgKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyKSAmJiAvLyBCb3R0b20gSGFsZlxuXHRcdFx0XHR5MiAtIChkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMikgPCBiICk7IC8vIFRvcCBIYWxmXG5cdFx0Y2FzZSBcInBvaW50ZXJcIjpcblx0XHRcdGRyYWdnYWJsZUxlZnQgPSAoKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQgKyAoZHJhZ2dhYmxlLmNsaWNrT2Zmc2V0IHx8IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2spLmxlZnQpO1xuXHRcdFx0ZHJhZ2dhYmxlVG9wID0gKChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS50b3AgKyAoZHJhZ2dhYmxlLmNsaWNrT2Zmc2V0IHx8IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2spLnRvcCk7XG5cdFx0XHRyZXR1cm4gaXNPdmVyQXhpcyggZHJhZ2dhYmxlVG9wLCB0LCBkcm9wcGFibGUucHJvcG9ydGlvbnMuaGVpZ2h0ICkgJiYgaXNPdmVyQXhpcyggZHJhZ2dhYmxlTGVmdCwgbCwgZHJvcHBhYmxlLnByb3BvcnRpb25zLndpZHRoICk7XG5cdFx0Y2FzZSBcInRvdWNoXCI6XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQoeTEgPj0gdCAmJiB5MSA8PSBiKSB8fFx0Ly8gVG9wIGVkZ2UgdG91Y2hpbmdcblx0XHRcdFx0KHkyID49IHQgJiYgeTIgPD0gYikgfHxcdC8vIEJvdHRvbSBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdCh5MSA8IHQgJiYgeTIgPiBiKVx0XHQvLyBTdXJyb3VuZGVkIHZlcnRpY2FsbHlcblx0XHRcdCkgJiYgKFxuXHRcdFx0XHQoeDEgPj0gbCAmJiB4MSA8PSByKSB8fFx0Ly8gTGVmdCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdCh4MiA+PSBsICYmIHgyIDw9IHIpIHx8XHQvLyBSaWdodCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdCh4MSA8IGwgJiYgeDIgPiByKVx0XHQvLyBTdXJyb3VuZGVkIGhvcml6b250YWxseVxuXHRcdFx0KTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxufTtcblxuLypcblx0VGhpcyBtYW5hZ2VyIHRyYWNrcyBvZmZzZXRzIG9mIGRyYWdnYWJsZXMgYW5kIGRyb3BwYWJsZXNcbiovXG4kLnVpLmRkbWFuYWdlciA9IHtcblx0Y3VycmVudDogbnVsbCxcblx0ZHJvcHBhYmxlczogeyBcImRlZmF1bHRcIjogW10gfSxcblx0cHJlcGFyZU9mZnNldHM6IGZ1bmN0aW9uKHQsIGV2ZW50KSB7XG5cblx0XHR2YXIgaSwgaixcblx0XHRcdG0gPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3Qub3B0aW9ucy5zY29wZV0gfHwgW10sXG5cdFx0XHR0eXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbCwgLy8gd29ya2Fyb3VuZCBmb3IgIzIzMTdcblx0XHRcdGxpc3QgPSAodC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQpLmZpbmQoXCI6ZGF0YSh1aS1kcm9wcGFibGUpXCIpLmFkZEJhY2soKTtcblxuXHRcdGRyb3BwYWJsZXNMb29wOiBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHQvL05vIGRpc2FibGVkIGFuZCBub24tYWNjZXB0ZWRcblx0XHRcdGlmKG1baV0ub3B0aW9ucy5kaXNhYmxlZCB8fCAodCAmJiAhbVtpXS5hY2NlcHQuY2FsbChtW2ldLmVsZW1lbnRbMF0sKHQuY3VycmVudEl0ZW0gfHwgdC5lbGVtZW50KSkpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGRyYWdnZWQgaXRlbVxuXHRcdFx0Zm9yIChqPTA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmKGxpc3Rbal0gPT09IG1baV0uZWxlbWVudFswXSkge1xuXHRcdFx0XHRcdG1baV0ucHJvcG9ydGlvbnMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0XHRjb250aW51ZSBkcm9wcGFibGVzTG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRtW2ldLnZpc2libGUgPSBtW2ldLmVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSAhPT0gXCJub25lXCI7XG5cdFx0XHRpZighbVtpXS52aXNpYmxlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0FjdGl2YXRlIHRoZSBkcm9wcGFibGUgaWYgdXNlZCBkaXJlY3RseSBmcm9tIGRyYWdnYWJsZXNcblx0XHRcdGlmKHR5cGUgPT09IFwibW91c2Vkb3duXCIpIHtcblx0XHRcdFx0bVtpXS5fYWN0aXZhdGUuY2FsbChtW2ldLCBldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdG1baV0ub2Zmc2V0ID0gbVtpXS5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0bVtpXS5wcm9wb3J0aW9ucyA9IHsgd2lkdGg6IG1baV0uZWxlbWVudFswXS5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBtW2ldLmVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0IH07XG5cblx0XHR9XG5cblx0fSxcblx0ZHJvcDogZnVuY3Rpb24oZHJhZ2dhYmxlLCBldmVudCkge1xuXG5cdFx0dmFyIGRyb3BwZWQgPSBmYWxzZTtcblx0XHQvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBkcm9wcGFibGVzIGluIGNhc2UgdGhlIGxpc3QgY2hhbmdlcyBkdXJpbmcgdGhlIGRyb3AgKCM5MTE2KVxuXHRcdCQuZWFjaCgoJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tkcmFnZ2FibGUub3B0aW9ucy5zY29wZV0gfHwgW10pLnNsaWNlKCksIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZighdGhpcy5vcHRpb25zKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiAkLnVpLmludGVyc2VjdChkcmFnZ2FibGUsIHRoaXMsIHRoaXMub3B0aW9ucy50b2xlcmFuY2UpKSB7XG5cdFx0XHRcdGRyb3BwZWQgPSB0aGlzLl9kcm9wLmNhbGwodGhpcywgZXZlbnQpIHx8IGRyb3BwZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiB0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkpIHtcblx0XHRcdFx0dGhpcy5pc291dCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuaXNvdmVyID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGUuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0XHRyZXR1cm4gZHJvcHBlZDtcblxuXHR9LFxuXHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKCBkcmFnZ2FibGUsIGV2ZW50ICkge1xuXHRcdC8vTGlzdGVuIGZvciBzY3JvbGxpbmcgc28gdGhhdCBpZiB0aGUgZHJhZ2dpbmcgY2F1c2VzIHNjcm9sbGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGRyb3BwYWJsZXMgY2FuIGJlIHJlY2FsY3VsYXRlZCAoc2VlICM1MDAzKVxuXHRcdGRyYWdnYWJsZS5lbGVtZW50LnBhcmVudHNVbnRpbCggXCJib2R5XCIgKS5iaW5kKCBcInNjcm9sbC5kcm9wcGFibGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiggIWRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBkcmFnZ2FibGUsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGRyYWdnYWJsZSwgZXZlbnQpIHtcblxuXHRcdC8vSWYgeW91IGhhdmUgYSBoaWdobHkgZHluYW1pYyBwYWdlLCB5b3UgbWlnaHQgdHJ5IHRoaXMgb3B0aW9uLiBJdCByZW5kZXJzIHBvc2l0aW9ucyBldmVyeSB0aW1lIHlvdSBtb3ZlIHRoZSBtb3VzZS5cblx0XHRpZihkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhkcmFnZ2FibGUsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvL1J1biB0aHJvdWdoIGFsbCBkcm9wcGFibGVzIGFuZCBjaGVjayB0aGVpciBwb3NpdGlvbnMgYmFzZWQgb24gc3BlY2lmaWMgdG9sZXJhbmNlIG9wdGlvbnNcblx0XHQkLmVhY2goJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tkcmFnZ2FibGUub3B0aW9ucy5zY29wZV0gfHwgW10sIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5ncmVlZHlDaGlsZCB8fCAhdGhpcy52aXNpYmxlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcmVudEluc3RhbmNlLCBzY29wZSwgcGFyZW50LFxuXHRcdFx0XHRpbnRlcnNlY3RzID0gJC51aS5pbnRlcnNlY3QoZHJhZ2dhYmxlLCB0aGlzLCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlKSxcblx0XHRcdFx0YyA9ICFpbnRlcnNlY3RzICYmIHRoaXMuaXNvdmVyID8gXCJpc291dFwiIDogKGludGVyc2VjdHMgJiYgIXRoaXMuaXNvdmVyID8gXCJpc292ZXJcIiA6IG51bGwpO1xuXHRcdFx0aWYoIWMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmdyZWVkeSkge1xuXHRcdFx0XHQvLyBmaW5kIGRyb3BwYWJsZSBwYXJlbnRzIHdpdGggc2FtZSBzY29wZVxuXHRcdFx0XHRzY29wZSA9IHRoaXMub3B0aW9ucy5zY29wZTtcblx0XHRcdFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudHMoXCI6ZGF0YSh1aS1kcm9wcGFibGUpXCIpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0YSh0aGlzLCBcInVpLWRyb3BwYWJsZVwiKS5vcHRpb25zLnNjb3BlID09PSBzY29wZTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHBhcmVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXJlbnRJbnN0YW5jZSA9ICQuZGF0YShwYXJlbnRbMF0sIFwidWktZHJvcHBhYmxlXCIpO1xuXHRcdFx0XHRcdHBhcmVudEluc3RhbmNlLmdyZWVkeUNoaWxkID0gKGMgPT09IFwiaXNvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGp1c3QgbW92ZWQgaW50byBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT09IFwiaXNvdmVyXCIpIHtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UuaXNvdmVyID0gZmFsc2U7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLmlzb3V0ID0gdHJ1ZTtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UuX291dC5jYWxsKHBhcmVudEluc3RhbmNlLCBldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXNbY10gPSB0cnVlO1xuXHRcdFx0dGhpc1tjID09PSBcImlzb3V0XCIgPyBcImlzb3ZlclwiIDogXCJpc291dFwiXSA9IGZhbHNlO1xuXHRcdFx0dGhpc1tjID09PSBcImlzb3ZlclwiID8gXCJfb3ZlclwiIDogXCJfb3V0XCJdLmNhbGwodGhpcywgZXZlbnQpO1xuXG5cdFx0XHQvLyB3ZSBqdXN0IG1vdmVkIG91dCBvZiBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT09IFwiaXNvdXRcIikge1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5pc291dCA9IGZhbHNlO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5pc292ZXIgPSB0cnVlO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5fb3Zlci5jYWxsKHBhcmVudEluc3RhbmNlLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblx0ZHJhZ1N0b3A6IGZ1bmN0aW9uKCBkcmFnZ2FibGUsIGV2ZW50ICkge1xuXHRcdGRyYWdnYWJsZS5lbGVtZW50LnBhcmVudHNVbnRpbCggXCJib2R5XCIgKS51bmJpbmQoIFwic2Nyb2xsLmRyb3BwYWJsZVwiICk7XG5cdFx0Ly9DYWxsIHByZXBhcmVPZmZzZXRzIG9uZSBmaW5hbCB0aW1lIHNpbmNlIElFIGRvZXMgbm90IGZpcmUgcmV0dXJuIHNjcm9sbCBldmVudHMgd2hlbiBvdmVyZmxvdyB3YXMgY2F1c2VkIGJ5IGRyYWcgKHNlZSAjNTAwMylcblx0XHRpZiggIWRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyggZHJhZ2dhYmxlLCBldmVudCApO1xuXHRcdH1cblx0fVxufTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbmZ1bmN0aW9uIG51bSh2KSB7XG5cdHJldHVybiBwYXJzZUludCh2LCAxMCkgfHwgMDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcblx0cmV0dXJuICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKTtcbn1cblxuJC53aWRnZXQoXCJ1aS5yZXNpemFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJyZXNpemVcIixcblx0b3B0aW9uczoge1xuXHRcdGFsc29SZXNpemU6IGZhbHNlLFxuXHRcdGFuaW1hdGU6IGZhbHNlLFxuXHRcdGFuaW1hdGVEdXJhdGlvbjogXCJzbG93XCIsXG5cdFx0YW5pbWF0ZUVhc2luZzogXCJzd2luZ1wiLFxuXHRcdGFzcGVjdFJhdGlvOiBmYWxzZSxcblx0XHRhdXRvSGlkZTogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGdob3N0OiBmYWxzZSxcblx0XHRncmlkOiBmYWxzZSxcblx0XHRoYW5kbGVzOiBcImUscyxzZVwiLFxuXHRcdGhlbHBlcjogZmFsc2UsXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxuXHRcdG1heFdpZHRoOiBudWxsLFxuXHRcdG1pbkhlaWdodDogMTAsXG5cdFx0bWluV2lkdGg6IDEwLFxuXHRcdC8vIFNlZSAjNzk2MFxuXHRcdHpJbmRleDogOTAsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRyZXNpemU6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBuLCBpLCBoYW5kbGUsIGF4aXMsIGhuYW1lLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZVwiKTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdF9hc3BlY3RSYXRpbzogISEoby5hc3BlY3RSYXRpbyksXG5cdFx0XHRhc3BlY3RSYXRpbzogby5hc3BlY3RSYXRpbyxcblx0XHRcdG9yaWdpbmFsRWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0X3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHM6IFtdLFxuXHRcdFx0X2hlbHBlcjogby5oZWxwZXIgfHwgby5naG9zdCB8fCBvLmFuaW1hdGUgPyBvLmhlbHBlciB8fCBcInVpLXJlc2l6YWJsZS1oZWxwZXJcIiA6IG51bGxcblx0XHR9KTtcblxuXHRcdC8vV3JhcCB0aGUgZWxlbWVudCBpZiBpdCBjYW5ub3QgaG9sZCBjaGlsZCBub2Rlc1xuXHRcdGlmKHRoaXMuZWxlbWVudFswXS5ub2RlTmFtZS5tYXRjaCgvY2FudmFzfHRleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b258aW1nL2kpKSB7XG5cblx0XHRcdC8vQ3JlYXRlIGEgd3JhcHBlciBlbGVtZW50IGFuZCBzZXQgdGhlIHdyYXBwZXIgdG8gdGhlIG5ldyBjdXJyZW50IGludGVybmFsIGVsZW1lbnRcblx0XHRcdHRoaXMuZWxlbWVudC53cmFwKFxuXHRcdFx0XHQkKFwiPGRpdiBjbGFzcz0ndWktd3JhcHBlcicgc3R5bGU9J292ZXJmbG93OiBoaWRkZW47Jz48L2Rpdj5cIikuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogdGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpLFxuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRcdFx0dG9wOiB0aGlzLmVsZW1lbnQuY3NzKFwidG9wXCIpLFxuXHRcdFx0XHRcdGxlZnQ6IHRoaXMuZWxlbWVudC5jc3MoXCJsZWZ0XCIpXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHQvL092ZXJ3cml0ZSB0aGUgb3JpZ2luYWwgdGhpcy5lbGVtZW50XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCkuZGF0YShcblx0XHRcdFx0XCJ1aS1yZXNpemFibGVcIiwgdGhpcy5lbGVtZW50LmRhdGEoXCJ1aS1yZXNpemFibGVcIilcblx0XHRcdCk7XG5cblx0XHRcdHRoaXMuZWxlbWVudElzV3JhcHBlciA9IHRydWU7XG5cblx0XHRcdC8vTW92ZSBtYXJnaW5zIHRvIHRoZSB3cmFwcGVyXG5cdFx0XHR0aGlzLmVsZW1lbnQuY3NzKHsgbWFyZ2luTGVmdDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwgbWFyZ2luVG9wOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5Ub3BcIiksIG1hcmdpblJpZ2h0OiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwgbWFyZ2luQm90dG9tOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIikgfSk7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoeyBtYXJnaW5MZWZ0OiAwLCBtYXJnaW5Ub3A6IDAsIG1hcmdpblJpZ2h0OiAwLCBtYXJnaW5Cb3R0b206IDB9KTtcblxuXHRcdFx0Ly9QcmV2ZW50IFNhZmFyaSB0ZXh0YXJlYSByZXNpemVcblx0XHRcdHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSA9IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcInJlc2l6ZVwiKTtcblx0XHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcInJlc2l6ZVwiLCBcIm5vbmVcIik7XG5cblx0XHRcdC8vUHVzaCB0aGUgYWN0dWFsIGVsZW1lbnQgdG8gb3VyIHByb3BvcnRpb25hbGx5UmVzaXplIGludGVybmFsIGFycmF5XG5cdFx0XHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLnB1c2godGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHsgcG9zaXRpb246IFwic3RhdGljXCIsIHpvb206IDEsIGRpc3BsYXk6IFwiYmxvY2tcIiB9KSk7XG5cblx0XHRcdC8vIGF2b2lkIElFIGp1bXAgKGhhcmQgc2V0IHRoZSBtYXJnaW4pXG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoeyBtYXJnaW46IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcIm1hcmdpblwiKSB9KTtcblxuXHRcdFx0Ly8gZml4IGhhbmRsZXJzIG9mZnNldFxuXHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlcyA9IG8uaGFuZGxlcyB8fCAoISQoXCIudWktcmVzaXphYmxlLWhhbmRsZVwiLCB0aGlzLmVsZW1lbnQpLmxlbmd0aCA/IFwiZSxzLHNlXCIgOiB7IG46IFwiLnVpLXJlc2l6YWJsZS1uXCIsIGU6IFwiLnVpLXJlc2l6YWJsZS1lXCIsIHM6IFwiLnVpLXJlc2l6YWJsZS1zXCIsIHc6IFwiLnVpLXJlc2l6YWJsZS13XCIsIHNlOiBcIi51aS1yZXNpemFibGUtc2VcIiwgc3c6IFwiLnVpLXJlc2l6YWJsZS1zd1wiLCBuZTogXCIudWktcmVzaXphYmxlLW5lXCIsIG53OiBcIi51aS1yZXNpemFibGUtbndcIiB9KTtcblx0XHRpZih0aGlzLmhhbmRsZXMuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuXG5cdFx0XHRpZiAoIHRoaXMuaGFuZGxlcyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHR0aGlzLmhhbmRsZXMgPSBcIm4sZSxzLHcsc2Usc3csbmUsbndcIjtcblx0XHRcdH1cblxuXHRcdFx0biA9IHRoaXMuaGFuZGxlcy5zcGxpdChcIixcIik7XG5cdFx0XHR0aGlzLmhhbmRsZXMgPSB7fTtcblxuXHRcdFx0Zm9yKGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRcdGhhbmRsZSA9ICQudHJpbShuW2ldKTtcblx0XHRcdFx0aG5hbWUgPSBcInVpLXJlc2l6YWJsZS1cIitoYW5kbGU7XG5cdFx0XHRcdGF4aXMgPSAkKFwiPGRpdiBjbGFzcz0ndWktcmVzaXphYmxlLWhhbmRsZSBcIiArIGhuYW1lICsgXCInPjwvZGl2PlwiKTtcblxuXHRcdFx0XHQvLyBBcHBseSB6SW5kZXggdG8gYWxsIGhhbmRsZXMgLSBzZWUgIzc5NjBcblx0XHRcdFx0YXhpcy5jc3MoeyB6SW5kZXg6IG8uekluZGV4IH0pO1xuXG5cdFx0XHRcdC8vVE9ETyA6IFdoYXQncyBnb2luZyBvbiBoZXJlP1xuXHRcdFx0XHRpZiAoXCJzZVwiID09PSBoYW5kbGUpIHtcblx0XHRcdFx0XHRheGlzLmFkZENsYXNzKFwidWktaWNvbiB1aS1pY29uLWdyaXBzbWFsbC1kaWFnb25hbC1zZVwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vSW5zZXJ0IGludG8gaW50ZXJuYWwgaGFuZGxlcyBvYmplY3QgYW5kIGFwcGVuZCB0byBlbGVtZW50XG5cdFx0XHRcdHRoaXMuaGFuZGxlc1toYW5kbGVdID0gXCIudWktcmVzaXphYmxlLVwiK2hhbmRsZTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmFwcGVuZChheGlzKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbmRlckF4aXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblxuXHRcdFx0dmFyIGksIGF4aXMsIHBhZFBvcywgcGFkV3JhcHBlcjtcblxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMuZWxlbWVudDtcblxuXHRcdFx0Zm9yKGkgaW4gdGhpcy5oYW5kbGVzKSB7XG5cblx0XHRcdFx0aWYodGhpcy5oYW5kbGVzW2ldLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXNbaV0gPSAkKHRoaXMuaGFuZGxlc1tpXSwgdGhpcy5lbGVtZW50KS5zaG93KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0FwcGx5IHBhZCB0byB3cmFwcGVyIGVsZW1lbnQsIG5lZWRlZCB0byBmaXggYXhpcyBwb3NpdGlvbiAodGV4dGFyZWEsIGlucHV0cywgc2Nyb2xscylcblx0XHRcdFx0aWYgKHRoaXMuZWxlbWVudElzV3JhcHBlciAmJiB0aGlzLm9yaWdpbmFsRWxlbWVudFswXS5ub2RlTmFtZS5tYXRjaCgvdGV4dGFyZWF8aW5wdXR8c2VsZWN0fGJ1dHRvbi9pKSkge1xuXG5cdFx0XHRcdFx0YXhpcyA9ICQodGhpcy5oYW5kbGVzW2ldLCB0aGlzLmVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0Ly9DaGVja2luZyB0aGUgY29ycmVjdCBwYWQgYW5kIGJvcmRlclxuXHRcdFx0XHRcdHBhZFdyYXBwZXIgPSAvc3d8bmV8bnd8c2V8bnxzLy50ZXN0KGkpID8gYXhpcy5vdXRlckhlaWdodCgpIDogYXhpcy5vdXRlcldpZHRoKCk7XG5cblx0XHRcdFx0XHQvL1RoZSBwYWRkaW5nIHR5cGUgaSBoYXZlIHRvIGFwcGx5Li4uXG5cdFx0XHRcdFx0cGFkUG9zID0gWyBcInBhZGRpbmdcIixcblx0XHRcdFx0XHRcdC9uZXxud3xuLy50ZXN0KGkpID8gXCJUb3BcIiA6XG5cdFx0XHRcdFx0XHQvc2V8c3d8cy8udGVzdChpKSA/IFwiQm90dG9tXCIgOlxuXHRcdFx0XHRcdFx0L15lJC8udGVzdChpKSA/IFwiUmlnaHRcIiA6IFwiTGVmdFwiIF0uam9pbihcIlwiKTtcblxuXHRcdFx0XHRcdHRhcmdldC5jc3MocGFkUG9zLCBwYWRXcmFwcGVyKTtcblxuXHRcdFx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vVE9ETzogV2hhdCdzIHRoYXQgZ29vZCBmb3I/IFRoZXJlJ3Mgbm90IGFueXRoaW5nIHRvIGJlIGV4ZWN1dGVkIGxlZnRcblx0XHRcdFx0aWYoISQodGhpcy5oYW5kbGVzW2ldKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvL1RPRE86IG1ha2UgcmVuZGVyQXhpcyBhIHByb3RvdHlwZSBmdW5jdGlvblxuXHRcdHRoaXMuX3JlbmRlckF4aXModGhpcy5lbGVtZW50KTtcblxuXHRcdHRoaXMuX2hhbmRsZXMgPSAkKFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcIiwgdGhpcy5lbGVtZW50KVxuXHRcdFx0LmRpc2FibGVTZWxlY3Rpb24oKTtcblxuXHRcdC8vTWF0Y2hpbmcgYXhpcyBuYW1lXG5cdFx0dGhpcy5faGFuZGxlcy5tb3VzZW92ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoYXQucmVzaXppbmcpIHtcblx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0YXhpcyA9IHRoaXMuY2xhc3NOYW1lLm1hdGNoKC91aS1yZXNpemFibGUtKHNlfHN3fG5lfG53fG58ZXxzfHcpL2kpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vQXhpcywgZGVmYXVsdCA9IHNlXG5cdFx0XHRcdHRoYXQuYXhpcyA9IGF4aXMgJiYgYXhpc1sxXSA/IGF4aXNbMV0gOiBcInNlXCI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvL0lmIHdlIHdhbnQgdG8gYXV0byBoaWRlIHRoZSBlbGVtZW50c1xuXHRcdGlmIChvLmF1dG9IaWRlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVzLmhpZGUoKTtcblx0XHRcdCQodGhpcy5lbGVtZW50KVxuXHRcdFx0XHQuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcIilcblx0XHRcdFx0Lm1vdXNlZW50ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKG8uZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiKTtcblx0XHRcdFx0XHR0aGF0Ll9oYW5kbGVzLnNob3coKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm1vdXNlbGVhdmUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZiAoby5kaXNhYmxlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoYXQucmVzaXppbmcpIHtcblx0XHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcIik7XG5cdFx0XHRcdFx0XHR0aGF0Ll9oYW5kbGVzLmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vSW5pdGlhbGl6ZSB0aGUgbW91c2UgaW50ZXJhY3Rpb25cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXG5cdFx0dmFyIHdyYXBwZXIsXG5cdFx0XHRfZGVzdHJveSA9IGZ1bmN0aW9uKGV4cCkge1xuXHRcdFx0XHQkKGV4cCkucmVtb3ZlQ2xhc3MoXCJ1aS1yZXNpemFibGUgdWktcmVzaXphYmxlLWRpc2FibGVkIHVpLXJlc2l6YWJsZS1yZXNpemluZ1wiKVxuXHRcdFx0XHRcdC5yZW1vdmVEYXRhKFwicmVzaXphYmxlXCIpLnJlbW92ZURhdGEoXCJ1aS1yZXNpemFibGVcIikudW5iaW5kKFwiLnJlc2l6YWJsZVwiKS5maW5kKFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcIikucmVtb3ZlKCk7XG5cdFx0XHR9O1xuXG5cdFx0Ly9UT0RPOiBVbndyYXAgYXQgc2FtZSBET00gcG9zaXRpb25cblx0XHRpZiAodGhpcy5lbGVtZW50SXNXcmFwcGVyKSB7XG5cdFx0XHRfZGVzdHJveSh0aGlzLmVsZW1lbnQpO1xuXHRcdFx0d3JhcHBlciA9IHRoaXMuZWxlbWVudDtcblx0XHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiB3cmFwcGVyLmNzcyhcInBvc2l0aW9uXCIpLFxuXHRcdFx0XHR3aWR0aDogd3JhcHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRcdGhlaWdodDogd3JhcHBlci5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHR0b3A6IHdyYXBwZXIuY3NzKFwidG9wXCIpLFxuXHRcdFx0XHRsZWZ0OiB3cmFwcGVyLmNzcyhcImxlZnRcIilcblx0XHRcdH0pLmluc2VydEFmdGVyKCB3cmFwcGVyICk7XG5cdFx0XHR3cmFwcGVyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcInJlc2l6ZVwiLCB0aGlzLm9yaWdpbmFsUmVzaXplU3R5bGUpO1xuXHRcdF9kZXN0cm95KHRoaXMub3JpZ2luYWxFbGVtZW50KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGksIGhhbmRsZSxcblx0XHRcdGNhcHR1cmUgPSBmYWxzZTtcblxuXHRcdGZvciAoaSBpbiB0aGlzLmhhbmRsZXMpIHtcblx0XHRcdGhhbmRsZSA9ICQodGhpcy5oYW5kbGVzW2ldKVswXTtcblx0XHRcdGlmIChoYW5kbGUgPT09IGV2ZW50LnRhcmdldCB8fCAkLmNvbnRhaW5zKGhhbmRsZSwgZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0XHRjYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiBjYXB0dXJlO1xuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIGN1cmxlZnQsIGN1cnRvcCwgY3Vyc29yLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGluaVBvcyA9IHRoaXMuZWxlbWVudC5wb3NpdGlvbigpLFxuXHRcdFx0ZWwgPSB0aGlzLmVsZW1lbnQ7XG5cblx0XHR0aGlzLnJlc2l6aW5nID0gdHJ1ZTtcblxuXHRcdC8vIGJ1Z2ZpeCBmb3IgaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC8xNzQ5XG5cdFx0aWYgKCAoL2Fic29sdXRlLykudGVzdCggZWwuY3NzKFwicG9zaXRpb25cIikgKSApIHtcblx0XHRcdGVsLmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogZWwuY3NzKFwidG9wXCIpLCBsZWZ0OiBlbC5jc3MoXCJsZWZ0XCIpIH0pO1xuXHRcdH0gZWxzZSBpZiAoZWwuaXMoXCIudWktZHJhZ2dhYmxlXCIpKSB7XG5cdFx0XHRlbC5jc3MoeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB0b3A6IGluaVBvcy50b3AsIGxlZnQ6IGluaVBvcy5sZWZ0IH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlbmRlclByb3h5KCk7XG5cblx0XHRjdXJsZWZ0ID0gbnVtKHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIikpO1xuXHRcdGN1cnRvcCA9IG51bSh0aGlzLmhlbHBlci5jc3MoXCJ0b3BcIikpO1xuXG5cdFx0aWYgKG8uY29udGFpbm1lbnQpIHtcblx0XHRcdGN1cmxlZnQgKz0gJChvLmNvbnRhaW5tZW50KS5zY3JvbGxMZWZ0KCkgfHwgMDtcblx0XHRcdGN1cnRvcCArPSAkKG8uY29udGFpbm1lbnQpLnNjcm9sbFRvcCgpIHx8IDA7XG5cdFx0fVxuXG5cdFx0Ly9TdG9yZSBuZWVkZWQgdmFyaWFibGVzXG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcblx0XHR0aGlzLnBvc2l0aW9uID0geyBsZWZ0OiBjdXJsZWZ0LCB0b3A6IGN1cnRvcCB9O1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMuX2hlbHBlciA/IHsgd2lkdGg6IGVsLm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpIH0gOiB7IHdpZHRoOiBlbC53aWR0aCgpLCBoZWlnaHQ6IGVsLmhlaWdodCgpIH07XG5cdFx0dGhpcy5vcmlnaW5hbFNpemUgPSB0aGlzLl9oZWxwZXIgPyB7IHdpZHRoOiBlbC5vdXRlcldpZHRoKCksIGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSB9IDogeyB3aWR0aDogZWwud2lkdGgoKSwgaGVpZ2h0OiBlbC5oZWlnaHQoKSB9O1xuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHsgbGVmdDogY3VybGVmdCwgdG9wOiBjdXJ0b3AgfTtcblx0XHR0aGlzLnNpemVEaWZmID0geyB3aWR0aDogZWwub3V0ZXJXaWR0aCgpIC0gZWwud2lkdGgoKSwgaGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpIC0gZWwuaGVpZ2h0KCkgfTtcblx0XHR0aGlzLm9yaWdpbmFsTW91c2VQb3NpdGlvbiA9IHsgbGVmdDogZXZlbnQucGFnZVgsIHRvcDogZXZlbnQucGFnZVkgfTtcblxuXHRcdC8vQXNwZWN0IFJhdGlvXG5cdFx0dGhpcy5hc3BlY3RSYXRpbyA9ICh0eXBlb2Ygby5hc3BlY3RSYXRpbyA9PT0gXCJudW1iZXJcIikgPyBvLmFzcGVjdFJhdGlvIDogKCh0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCAvIHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCkgfHwgMSk7XG5cblx0XHRjdXJzb3IgPSAkKFwiLnVpLXJlc2l6YWJsZS1cIiArIHRoaXMuYXhpcykuY3NzKFwiY3Vyc29yXCIpO1xuXHRcdCQoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLCBjdXJzb3IgPT09IFwiYXV0b1wiID8gdGhpcy5heGlzICsgXCItcmVzaXplXCIgOiBjdXJzb3IpO1xuXG5cdFx0ZWwuYWRkQ2xhc3MoXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcIik7XG5cdFx0dGhpcy5fcHJvcGFnYXRlKFwic3RhcnRcIiwgZXZlbnQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHQvL0luY3JlYXNlIHBlcmZvcm1hbmNlLCBhdm9pZCByZWdleFxuXHRcdHZhciBkYXRhLFxuXHRcdFx0ZWwgPSB0aGlzLmhlbHBlciwgcHJvcHMgPSB7fSxcblx0XHRcdHNtcCA9IHRoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uLFxuXHRcdFx0YSA9IHRoaXMuYXhpcyxcblx0XHRcdHByZXZUb3AgPSB0aGlzLnBvc2l0aW9uLnRvcCxcblx0XHRcdHByZXZMZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0LFxuXHRcdFx0cHJldldpZHRoID0gdGhpcy5zaXplLndpZHRoLFxuXHRcdFx0cHJldkhlaWdodCA9IHRoaXMuc2l6ZS5oZWlnaHQsXG5cdFx0XHRkeCA9IChldmVudC5wYWdlWC1zbXAubGVmdCl8fDAsXG5cdFx0XHRkeSA9IChldmVudC5wYWdlWS1zbXAudG9wKXx8MCxcblx0XHRcdHRyaWdnZXIgPSB0aGlzLl9jaGFuZ2VbYV07XG5cblx0XHRpZiAoIXRyaWdnZXIpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIGF0dHJzIHRoYXQgd2lsbCBiZSBjaGFuZ2Vcblx0XHRkYXRhID0gdHJpZ2dlci5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pO1xuXG5cdFx0Ly8gUHV0IHRoaXMgaW4gdGhlIG1vdXNlRHJhZyBoYW5kbGVyIHNpbmNlIHRoZSB1c2VyIGNhbiBzdGFydCBwcmVzc2luZyBzaGlmdCB3aGlsZSByZXNpemluZ1xuXHRcdHRoaXMuX3VwZGF0ZVZpcnR1YWxCb3VuZGFyaWVzKGV2ZW50LnNoaWZ0S2V5KTtcblx0XHRpZiAodGhpcy5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXkpIHtcblx0XHRcdGRhdGEgPSB0aGlzLl91cGRhdGVSYXRpbyhkYXRhLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0ZGF0YSA9IHRoaXMuX3Jlc3BlY3RTaXplKGRhdGEsIGV2ZW50KTtcblxuXHRcdHRoaXMuX3VwZGF0ZUNhY2hlKGRhdGEpO1xuXG5cdFx0Ly8gcGx1Z2lucyBjYWxsYmFja3MgbmVlZCB0byBiZSBjYWxsZWQgZmlyc3Rcblx0XHR0aGlzLl9wcm9wYWdhdGUoXCJyZXNpemVcIiwgZXZlbnQpO1xuXG5cdFx0aWYgKHRoaXMucG9zaXRpb24udG9wICE9PSBwcmV2VG9wKSB7XG5cdFx0XHRwcm9wcy50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFwicHhcIjtcblx0XHR9XG5cdFx0aWYgKHRoaXMucG9zaXRpb24ubGVmdCAhPT0gcHJldkxlZnQpIHtcblx0XHRcdHByb3BzLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcInB4XCI7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnNpemUud2lkdGggIT09IHByZXZXaWR0aCkge1xuXHRcdFx0cHJvcHMud2lkdGggPSB0aGlzLnNpemUud2lkdGggKyBcInB4XCI7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnNpemUuaGVpZ2h0ICE9PSBwcmV2SGVpZ2h0KSB7XG5cdFx0XHRwcm9wcy5oZWlnaHQgPSB0aGlzLnNpemUuaGVpZ2h0ICsgXCJweFwiO1xuXHRcdH1cblx0XHRlbC5jc3MocHJvcHMpO1xuXG5cdFx0aWYgKCF0aGlzLl9oZWxwZXIgJiYgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayBpZiB0aGUgZWxlbWVudCB3YXMgcmVzaXplZFxuXHRcdGlmICggISAkLmlzRW1wdHlPYmplY3QocHJvcHMpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlcihcInJlc2l6ZVwiLCBldmVudCwgdGhpcy51aSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHRoaXMucmVzaXppbmcgPSBmYWxzZTtcblx0XHR2YXIgcHIsIGlzdGEsIHNvZmZzZXRoLCBzb2Zmc2V0dywgcywgbGVmdCwgdG9wLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucywgdGhhdCA9IHRoaXM7XG5cblx0XHRpZih0aGlzLl9oZWxwZXIpIHtcblxuXHRcdFx0cHIgPSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzO1xuXHRcdFx0aXN0YSA9IHByLmxlbmd0aCAmJiAoL3RleHRhcmVhL2kpLnRlc3QocHJbMF0ubm9kZU5hbWUpO1xuXHRcdFx0c29mZnNldGggPSBpc3RhICYmICQudWkuaGFzU2Nyb2xsKHByWzBdLCBcImxlZnRcIikgLyogVE9ETyAtIGp1bXAgaGVpZ2h0ICovID8gMCA6IHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xuXHRcdFx0c29mZnNldHcgPSBpc3RhID8gMCA6IHRoYXQuc2l6ZURpZmYud2lkdGg7XG5cblx0XHRcdHMgPSB7IHdpZHRoOiAodGhhdC5oZWxwZXIud2lkdGgoKSAgLSBzb2Zmc2V0dyksIGhlaWdodDogKHRoYXQuaGVscGVyLmhlaWdodCgpIC0gc29mZnNldGgpIH07XG5cdFx0XHRsZWZ0ID0gKHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXCJsZWZ0XCIpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQpKSB8fCBudWxsO1xuXHRcdFx0dG9wID0gKHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXCJ0b3BcIiksIDEwKSArICh0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3ApKSB8fCBudWxsO1xuXG5cdFx0XHRpZiAoIW8uYW5pbWF0ZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuY3NzKCQuZXh0ZW5kKHMsIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGF0LmhlbHBlci5oZWlnaHQodGhhdC5zaXplLmhlaWdodCk7XG5cdFx0XHR0aGF0LmhlbHBlci53aWR0aCh0aGF0LnNpemUud2lkdGgpO1xuXG5cdFx0XHRpZiAodGhpcy5faGVscGVyICYmICFvLmFuaW1hdGUpIHtcblx0XHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIiwgXCJhdXRvXCIpO1xuXG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwidWktcmVzaXphYmxlLXJlc2l6aW5nXCIpO1xuXG5cdFx0dGhpcy5fcHJvcGFnYXRlKFwic3RvcFwiLCBldmVudCk7XG5cblx0XHRpZiAodGhpcy5faGVscGVyKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRfdXBkYXRlVmlydHVhbEJvdW5kYXJpZXM6IGZ1bmN0aW9uKGZvcmNlQXNwZWN0UmF0aW8pIHtcblx0XHR2YXIgcE1pbldpZHRoLCBwTWF4V2lkdGgsIHBNaW5IZWlnaHQsIHBNYXhIZWlnaHQsIGIsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0YiA9IHtcblx0XHRcdG1pbldpZHRoOiBpc051bWJlcihvLm1pbldpZHRoKSA/IG8ubWluV2lkdGggOiAwLFxuXHRcdFx0bWF4V2lkdGg6IGlzTnVtYmVyKG8ubWF4V2lkdGgpID8gby5tYXhXaWR0aCA6IEluZmluaXR5LFxuXHRcdFx0bWluSGVpZ2h0OiBpc051bWJlcihvLm1pbkhlaWdodCkgPyBvLm1pbkhlaWdodCA6IDAsXG5cdFx0XHRtYXhIZWlnaHQ6IGlzTnVtYmVyKG8ubWF4SGVpZ2h0KSA/IG8ubWF4SGVpZ2h0IDogSW5maW5pdHlcblx0XHR9O1xuXG5cdFx0aWYodGhpcy5fYXNwZWN0UmF0aW8gfHwgZm9yY2VBc3BlY3RSYXRpbykge1xuXHRcdFx0Ly8gV2Ugd2FudCB0byBjcmVhdGUgYW4gZW5jbG9zaW5nIGJveCB3aG9zZSBhc3BlY3QgcmF0aW9uIGlzIHRoZSByZXF1ZXN0ZWQgb25lXG5cdFx0XHQvLyBGaXJzdCwgY29tcHV0ZSB0aGUgXCJwcm9qZWN0ZWRcIiBzaXplIGZvciBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiB0aGUgYXNwZWN0IHJhdGlvIGFuZCBvdGhlciBkaW1lbnNpb25cblx0XHRcdHBNaW5XaWR0aCA9IGIubWluSGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNaW5IZWlnaHQgPSBiLm1pbldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNYXhXaWR0aCA9IGIubWF4SGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcblx0XHRcdHBNYXhIZWlnaHQgPSBiLm1heFdpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcblxuXHRcdFx0aWYocE1pbldpZHRoID4gYi5taW5XaWR0aCkge1xuXHRcdFx0XHRiLm1pbldpZHRoID0gcE1pbldpZHRoO1xuXHRcdFx0fVxuXHRcdFx0aWYocE1pbkhlaWdodCA+IGIubWluSGVpZ2h0KSB7XG5cdFx0XHRcdGIubWluSGVpZ2h0ID0gcE1pbkhlaWdodDtcblx0XHRcdH1cblx0XHRcdGlmKHBNYXhXaWR0aCA8IGIubWF4V2lkdGgpIHtcblx0XHRcdFx0Yi5tYXhXaWR0aCA9IHBNYXhXaWR0aDtcblx0XHRcdH1cblx0XHRcdGlmKHBNYXhIZWlnaHQgPCBiLm1heEhlaWdodCkge1xuXHRcdFx0XHRiLm1heEhlaWdodCA9IHBNYXhIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3ZCb3VuZGFyaWVzID0gYjtcblx0fSxcblxuXHRfdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuaGVscGVyLm9mZnNldCgpO1xuXHRcdGlmIChpc051bWJlcihkYXRhLmxlZnQpKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uLmxlZnQgPSBkYXRhLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChpc051bWJlcihkYXRhLnRvcCkpIHtcblx0XHRcdHRoaXMucG9zaXRpb24udG9wID0gZGF0YS50b3A7XG5cdFx0fVxuXHRcdGlmIChpc051bWJlcihkYXRhLmhlaWdodCkpIHtcblx0XHRcdHRoaXMuc2l6ZS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcblx0XHR9XG5cdFx0aWYgKGlzTnVtYmVyKGRhdGEud2lkdGgpKSB7XG5cdFx0XHR0aGlzLnNpemUud2lkdGggPSBkYXRhLndpZHRoO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUmF0aW86IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0dmFyIGNwb3MgPSB0aGlzLnBvc2l0aW9uLFxuXHRcdFx0Y3NpemUgPSB0aGlzLnNpemUsXG5cdFx0XHRhID0gdGhpcy5heGlzO1xuXG5cdFx0aWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuXHRcdFx0ZGF0YS53aWR0aCA9IChkYXRhLmhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW8pO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkpIHtcblx0XHRcdGRhdGEuaGVpZ2h0ID0gKGRhdGEud2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvKTtcblx0XHR9XG5cblx0XHRpZiAoYSA9PT0gXCJzd1wiKSB7XG5cdFx0XHRkYXRhLmxlZnQgPSBjcG9zLmxlZnQgKyAoY3NpemUud2lkdGggLSBkYXRhLndpZHRoKTtcblx0XHRcdGRhdGEudG9wID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKGEgPT09IFwibndcIikge1xuXHRcdFx0ZGF0YS50b3AgPSBjcG9zLnRvcCArIChjc2l6ZS5oZWlnaHQgLSBkYXRhLmhlaWdodCk7XG5cdFx0XHRkYXRhLmxlZnQgPSBjcG9zLmxlZnQgKyAoY3NpemUud2lkdGggLSBkYXRhLndpZHRoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRfcmVzcGVjdFNpemU6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLl92Qm91bmRhcmllcyxcblx0XHRcdGEgPSB0aGlzLmF4aXMsXG5cdFx0XHRpc21heHcgPSBpc051bWJlcihkYXRhLndpZHRoKSAmJiBvLm1heFdpZHRoICYmIChvLm1heFdpZHRoIDwgZGF0YS53aWR0aCksIGlzbWF4aCA9IGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBvLm1heEhlaWdodCAmJiAoby5tYXhIZWlnaHQgPCBkYXRhLmhlaWdodCksXG5cdFx0XHRpc21pbncgPSBpc051bWJlcihkYXRhLndpZHRoKSAmJiBvLm1pbldpZHRoICYmIChvLm1pbldpZHRoID4gZGF0YS53aWR0aCksIGlzbWluaCA9IGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBvLm1pbkhlaWdodCAmJiAoby5taW5IZWlnaHQgPiBkYXRhLmhlaWdodCksXG5cdFx0XHRkdyA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbi5sZWZ0ICsgdGhpcy5vcmlnaW5hbFNpemUud2lkdGgsXG5cdFx0XHRkaCA9IHRoaXMucG9zaXRpb24udG9wICsgdGhpcy5zaXplLmhlaWdodCxcblx0XHRcdGN3ID0gL3N3fG53fHcvLnRlc3QoYSksIGNoID0gL253fG5lfG4vLnRlc3QoYSk7XG5cdFx0aWYgKGlzbWludykge1xuXHRcdFx0ZGF0YS53aWR0aCA9IG8ubWluV2lkdGg7XG5cdFx0fVxuXHRcdGlmIChpc21pbmgpIHtcblx0XHRcdGRhdGEuaGVpZ2h0ID0gby5taW5IZWlnaHQ7XG5cdFx0fVxuXHRcdGlmIChpc21heHcpIHtcblx0XHRcdGRhdGEud2lkdGggPSBvLm1heFdpZHRoO1xuXHRcdH1cblx0XHRpZiAoaXNtYXhoKSB7XG5cdFx0XHRkYXRhLmhlaWdodCA9IG8ubWF4SGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmIChpc21pbncgJiYgY3cpIHtcblx0XHRcdGRhdGEubGVmdCA9IGR3IC0gby5taW5XaWR0aDtcblx0XHR9XG5cdFx0aWYgKGlzbWF4dyAmJiBjdykge1xuXHRcdFx0ZGF0YS5sZWZ0ID0gZHcgLSBvLm1heFdpZHRoO1xuXHRcdH1cblx0XHRpZiAoaXNtaW5oICYmIGNoKSB7XG5cdFx0XHRkYXRhLnRvcCA9IGRoIC0gby5taW5IZWlnaHQ7XG5cdFx0fVxuXHRcdGlmIChpc21heGggJiYgY2gpIHtcblx0XHRcdGRhdGEudG9wID0gZGggLSBvLm1heEhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBmaXhpbmcganVtcCBlcnJvciBvbiB0b3AvbGVmdCAtIGJ1ZyAjMjMzMFxuXHRcdGlmICghZGF0YS53aWR0aCAmJiAhZGF0YS5oZWlnaHQgJiYgIWRhdGEubGVmdCAmJiBkYXRhLnRvcCkge1xuXHRcdFx0ZGF0YS50b3AgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoIWRhdGEud2lkdGggJiYgIWRhdGEuaGVpZ2h0ICYmICFkYXRhLnRvcCAmJiBkYXRhLmxlZnQpIHtcblx0XHRcdGRhdGEubGVmdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0X3Byb3BvcnRpb25hbGx5UmVzaXplOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICghdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgYm9yZGVycywgcGFkZGluZ3MsIHByZWwsXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5oZWxwZXIgfHwgdGhpcy5lbGVtZW50O1xuXG5cdFx0Zm9yICggaT0wOyBpIDwgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRwcmVsID0gdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50c1tpXTtcblxuXHRcdFx0aWYgKCF0aGlzLmJvcmRlckRpZikge1xuXHRcdFx0XHR0aGlzLmJvcmRlckRpZiA9IFtdO1xuXHRcdFx0XHRib3JkZXJzID0gW3ByZWwuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksIHByZWwuY3NzKFwiYm9yZGVyUmlnaHRXaWR0aFwiKSwgcHJlbC5jc3MoXCJib3JkZXJCb3R0b21XaWR0aFwiKSwgcHJlbC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIildO1xuXHRcdFx0XHRwYWRkaW5ncyA9IFtwcmVsLmNzcyhcInBhZGRpbmdUb3BcIiksIHByZWwuY3NzKFwicGFkZGluZ1JpZ2h0XCIpLCBwcmVsLmNzcyhcInBhZGRpbmdCb3R0b21cIiksIHByZWwuY3NzKFwicGFkZGluZ0xlZnRcIildO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgYm9yZGVycy5sZW5ndGg7IGorKyApIHtcblx0XHRcdFx0XHR0aGlzLmJvcmRlckRpZlsgaiBdID0gKCBwYXJzZUludCggYm9yZGVyc1sgaiBdLCAxMCApIHx8IDAgKSArICggcGFyc2VJbnQoIHBhZGRpbmdzWyBqIF0sIDEwICkgfHwgMCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHByZWwuY3NzKHtcblx0XHRcdFx0aGVpZ2h0OiAoZWxlbWVudC5oZWlnaHQoKSAtIHRoaXMuYm9yZGVyRGlmWzBdIC0gdGhpcy5ib3JkZXJEaWZbMl0pIHx8IDAsXG5cdFx0XHRcdHdpZHRoOiAoZWxlbWVudC53aWR0aCgpIC0gdGhpcy5ib3JkZXJEaWZbMV0gLSB0aGlzLmJvcmRlckRpZlszXSkgfHwgMFxuXHRcdFx0fSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRfcmVuZGVyUHJveHk6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGVsID0gdGhpcy5lbGVtZW50LCBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuZWxlbWVudE9mZnNldCA9IGVsLm9mZnNldCgpO1xuXG5cdFx0aWYodGhpcy5faGVscGVyKSB7XG5cblx0XHRcdHRoaXMuaGVscGVyID0gdGhpcy5oZWxwZXIgfHwgJChcIjxkaXYgc3R5bGU9J292ZXJmbG93OmhpZGRlbjsnPjwvZGl2PlwiKTtcblxuXHRcdFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3ModGhpcy5faGVscGVyKS5jc3Moe1xuXHRcdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSAtIDEsXG5cdFx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgLSAxLFxuXHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRsZWZ0OiB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCArXCJweFwiLFxuXHRcdFx0XHR0b3A6IHRoaXMuZWxlbWVudE9mZnNldC50b3AgK1wicHhcIixcblx0XHRcdFx0ekluZGV4OiArK28uekluZGV4IC8vVE9ETzogRG9uJ3QgbW9kaWZ5IG9wdGlvblxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuaGVscGVyXG5cdFx0XHRcdC5hcHBlbmRUbyhcImJvZHlcIilcblx0XHRcdFx0LmRpc2FibGVTZWxlY3Rpb24oKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmhlbHBlciA9IHRoaXMuZWxlbWVudDtcblx0XHR9XG5cblx0fSxcblxuXHRfY2hhbmdlOiB7XG5cdFx0ZTogZnVuY3Rpb24oZXZlbnQsIGR4KSB7XG5cdFx0XHRyZXR1cm4geyB3aWR0aDogdGhpcy5vcmlnaW5hbFNpemUud2lkdGggKyBkeCB9O1xuXHRcdH0sXG5cdFx0dzogZnVuY3Rpb24oZXZlbnQsIGR4KSB7XG5cdFx0XHR2YXIgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSwgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG5cdFx0XHRyZXR1cm4geyBsZWZ0OiBzcC5sZWZ0ICsgZHgsIHdpZHRoOiBjcy53aWR0aCAtIGR4IH07XG5cdFx0fSxcblx0XHRuOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHR2YXIgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSwgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG5cdFx0XHRyZXR1cm4geyB0b3A6IHNwLnRvcCArIGR5LCBoZWlnaHQ6IGNzLmhlaWdodCAtIGR5IH07XG5cdFx0fSxcblx0XHRzOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4geyBoZWlnaHQ6IHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCArIGR5IH07XG5cdFx0fSxcblx0XHRzZTogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS5lLmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xuXHRcdH0sXG5cdFx0c3c6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcblx0XHR9LFxuXHRcdG5lOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQodGhpcy5fY2hhbmdlLm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcy5fY2hhbmdlLmUuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKSk7XG5cdFx0fSxcblx0XHRudzogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS53LmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcHJvcGFnYXRlOiBmdW5jdGlvbihuLCBldmVudCkge1xuXHRcdCQudWkucGx1Z2luLmNhbGwodGhpcywgbiwgW2V2ZW50LCB0aGlzLnVpKCldKTtcblx0XHQobiAhPT0gXCJyZXNpemVcIiAmJiB0aGlzLl90cmlnZ2VyKG4sIGV2ZW50LCB0aGlzLnVpKCkpKTtcblx0fSxcblxuXHRwbHVnaW5zOiB7fSxcblxuXHR1aTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9yaWdpbmFsRWxlbWVudDogdGhpcy5vcmlnaW5hbEVsZW1lbnQsXG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRzaXplOiB0aGlzLnNpemUsXG5cdFx0XHRvcmlnaW5hbFNpemU6IHRoaXMub3JpZ2luYWxTaXplLFxuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogdGhpcy5vcmlnaW5hbFBvc2l0aW9uXG5cdFx0fTtcblx0fVxuXG59KTtcblxuLypcbiAqIFJlc2l6YWJsZSBFeHRlbnNpb25zXG4gKi9cblxuJC51aS5wbHVnaW4uYWRkKFwicmVzaXphYmxlXCIsIFwiYW5pbWF0ZVwiLCB7XG5cblx0c3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlXCIpLFxuXHRcdFx0byA9IHRoYXQub3B0aW9ucyxcblx0XHRcdHByID0gdGhhdC5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cyxcblx0XHRcdGlzdGEgPSBwci5sZW5ndGggJiYgKC90ZXh0YXJlYS9pKS50ZXN0KHByWzBdLm5vZGVOYW1lKSxcblx0XHRcdHNvZmZzZXRoID0gaXN0YSAmJiAkLnVpLmhhc1Njcm9sbChwclswXSwgXCJsZWZ0XCIpIC8qIFRPRE8gLSBqdW1wIGhlaWdodCAqLyA/IDAgOiB0aGF0LnNpemVEaWZmLmhlaWdodCxcblx0XHRcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoLFxuXHRcdFx0c3R5bGUgPSB7IHdpZHRoOiAodGhhdC5zaXplLndpZHRoIC0gc29mZnNldHcpLCBoZWlnaHQ6ICh0aGF0LnNpemUuaGVpZ2h0IC0gc29mZnNldGgpIH0sXG5cdFx0XHRsZWZ0ID0gKHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXCJsZWZ0XCIpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQpKSB8fCBudWxsLFxuXHRcdFx0dG9wID0gKHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXCJ0b3BcIiksIDEwKSArICh0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3ApKSB8fCBudWxsO1xuXG5cdFx0dGhhdC5lbGVtZW50LmFuaW1hdGUoXG5cdFx0XHQkLmV4dGVuZChzdHlsZSwgdG9wICYmIGxlZnQgPyB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gOiB7fSksIHtcblx0XHRcdFx0ZHVyYXRpb246IG8uYW5pbWF0ZUR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IG8uYW5pbWF0ZUVhc2luZyxcblx0XHRcdFx0c3RlcDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFwid2lkdGhcIiksIDEwKSxcblx0XHRcdFx0XHRcdGhlaWdodDogcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcyhcImhlaWdodFwiKSwgMTApLFxuXHRcdFx0XHRcdFx0dG9wOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFwidG9wXCIpLCAxMCksXG5cdFx0XHRcdFx0XHRsZWZ0OiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFwibGVmdFwiKSwgMTApXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmIChwciAmJiBwci5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdCQocHJbMF0pLmNzcyh7IHdpZHRoOiBkYXRhLndpZHRoLCBoZWlnaHQ6IGRhdGEuaGVpZ2h0IH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHByb3BhZ2F0aW5nIHJlc2l6ZSwgYW5kIHVwZGF0aW5nIHZhbHVlcyBmb3IgZWFjaCBhbmltYXRpb24gc3RlcFxuXHRcdFx0XHRcdHRoYXQuX3VwZGF0ZUNhY2hlKGRhdGEpO1xuXHRcdFx0XHRcdHRoYXQuX3Byb3BhZ2F0ZShcInJlc2l6ZVwiLCBldmVudCk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImNvbnRhaW5tZW50XCIsIHtcblxuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW1lbnQsIHAsIGNvLCBjaCwgY3csIHdpZHRoLCBoZWlnaHQsXG5cdFx0XHR0aGF0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlXCIpLFxuXHRcdFx0byA9IHRoYXQub3B0aW9ucyxcblx0XHRcdGVsID0gdGhhdC5lbGVtZW50LFxuXHRcdFx0b2MgPSBvLmNvbnRhaW5tZW50LFxuXHRcdFx0Y2UgPSAob2MgaW5zdGFuY2VvZiAkKSA/IG9jLmdldCgwKSA6ICgvcGFyZW50Ly50ZXN0KG9jKSkgPyBlbC5wYXJlbnQoKS5nZXQoMCkgOiBvYztcblxuXHRcdGlmICghY2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGF0LmNvbnRhaW5lckVsZW1lbnQgPSAkKGNlKTtcblxuXHRcdGlmICgvZG9jdW1lbnQvLnRlc3Qob2MpIHx8IG9jID09PSBkb2N1bWVudCkge1xuXHRcdFx0dGhhdC5jb250YWluZXJPZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuXHRcdFx0dGhhdC5jb250YWluZXJQb3NpdGlvbiA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG5cblx0XHRcdHRoYXQucGFyZW50RGF0YSA9IHtcblx0XHRcdFx0ZWxlbWVudDogJChkb2N1bWVudCksIGxlZnQ6IDAsIHRvcDogMCxcblx0XHRcdFx0d2lkdGg6ICQoZG9jdW1lbnQpLndpZHRoKCksIGhlaWdodDogJChkb2N1bWVudCkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBpJ20gYSBub2RlLCBzbyBjb21wdXRlIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbVxuXHRcdGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9ICQoY2UpO1xuXHRcdFx0cCA9IFtdO1xuXHRcdFx0JChbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJMZWZ0XCIsIFwiQm90dG9tXCIgXSkuZWFjaChmdW5jdGlvbihpLCBuYW1lKSB7IHBbaV0gPSBudW0oZWxlbWVudC5jc3MoXCJwYWRkaW5nXCIgKyBuYW1lKSk7IH0pO1xuXG5cdFx0XHR0aGF0LmNvbnRhaW5lck9mZnNldCA9IGVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0gZWxlbWVudC5wb3NpdGlvbigpO1xuXHRcdFx0dGhhdC5jb250YWluZXJTaXplID0geyBoZWlnaHQ6IChlbGVtZW50LmlubmVySGVpZ2h0KCkgLSBwWzNdKSwgd2lkdGg6IChlbGVtZW50LmlubmVyV2lkdGgoKSAtIHBbMV0pIH07XG5cblx0XHRcdGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQ7XG5cdFx0XHRjaCA9IHRoYXQuY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG5cdFx0XHRjdyA9IHRoYXQuY29udGFpbmVyU2l6ZS53aWR0aDtcblx0XHRcdHdpZHRoID0gKCQudWkuaGFzU2Nyb2xsKGNlLCBcImxlZnRcIikgPyBjZS5zY3JvbGxXaWR0aCA6IGN3ICk7XG5cdFx0XHRoZWlnaHQgPSAoJC51aS5oYXNTY3JvbGwoY2UpID8gY2Uuc2Nyb2xsSGVpZ2h0IDogY2gpO1xuXG5cdFx0XHR0aGF0LnBhcmVudERhdGEgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGNlLCBsZWZ0OiBjby5sZWZ0LCB0b3A6IGNvLnRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHdvc2V0LCBob3NldCwgaXNQYXJlbnQsIGlzT2Zmc2V0UmVsYXRpdmUsXG5cdFx0XHR0aGF0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlXCIpLFxuXHRcdFx0byA9IHRoYXQub3B0aW9ucyxcblx0XHRcdGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsIGNwID0gdGhhdC5wb3NpdGlvbixcblx0XHRcdHBSYXRpbyA9IHRoYXQuX2FzcGVjdFJhdGlvIHx8IGV2ZW50LnNoaWZ0S2V5LFxuXHRcdFx0Y29wID0geyB0b3A6MCwgbGVmdDowIH0sIGNlID0gdGhhdC5jb250YWluZXJFbGVtZW50O1xuXG5cdFx0aWYgKGNlWzBdICE9PSBkb2N1bWVudCAmJiAoL3N0YXRpYy8pLnRlc3QoY2UuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHRjb3AgPSBjbztcblx0XHR9XG5cblx0XHRpZiAoY3AubGVmdCA8ICh0aGF0Ll9oZWxwZXIgPyBjby5sZWZ0IDogMCkpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS53aWR0aCArICh0aGF0Ll9oZWxwZXIgPyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gY28ubGVmdCkgOiAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gY29wLmxlZnQpKTtcblx0XHRcdGlmIChwUmF0aW8pIHtcblx0XHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS53aWR0aCAvIHRoYXQuYXNwZWN0UmF0aW87XG5cdFx0XHR9XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvLmhlbHBlciA/IGNvLmxlZnQgOiAwO1xuXHRcdH1cblxuXHRcdGlmIChjcC50b3AgPCAodGhhdC5faGVscGVyID8gY28udG9wIDogMCkpIHtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUuaGVpZ2h0ICsgKHRoYXQuX2hlbHBlciA/ICh0aGF0LnBvc2l0aW9uLnRvcCAtIGNvLnRvcCkgOiB0aGF0LnBvc2l0aW9uLnRvcCk7XG5cdFx0XHRpZiAocFJhdGlvKSB7XG5cdFx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS5oZWlnaHQgKiB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSB0aGF0Ll9oZWxwZXIgPyBjby50b3AgOiAwO1xuXHRcdH1cblxuXHRcdHRoYXQub2Zmc2V0LmxlZnQgPSB0aGF0LnBhcmVudERhdGEubGVmdCt0aGF0LnBvc2l0aW9uLmxlZnQ7XG5cdFx0dGhhdC5vZmZzZXQudG9wID0gdGhhdC5wYXJlbnREYXRhLnRvcCt0aGF0LnBvc2l0aW9uLnRvcDtcblxuXHRcdHdvc2V0ID0gTWF0aC5hYnMoICh0aGF0Ll9oZWxwZXIgPyB0aGF0Lm9mZnNldC5sZWZ0IC0gY29wLmxlZnQgOiAodGhhdC5vZmZzZXQubGVmdCAtIGNvcC5sZWZ0KSkgKyB0aGF0LnNpemVEaWZmLndpZHRoICk7XG5cdFx0aG9zZXQgPSBNYXRoLmFicyggKHRoYXQuX2hlbHBlciA/IHRoYXQub2Zmc2V0LnRvcCAtIGNvcC50b3AgOiAodGhhdC5vZmZzZXQudG9wIC0gY28udG9wKSkgKyB0aGF0LnNpemVEaWZmLmhlaWdodCApO1xuXG5cdFx0aXNQYXJlbnQgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQuZ2V0KDApID09PSB0aGF0LmVsZW1lbnQucGFyZW50KCkuZ2V0KDApO1xuXHRcdGlzT2Zmc2V0UmVsYXRpdmUgPSAvcmVsYXRpdmV8YWJzb2x1dGUvLnRlc3QodGhhdC5jb250YWluZXJFbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpKTtcblxuXHRcdGlmKGlzUGFyZW50ICYmIGlzT2Zmc2V0UmVsYXRpdmUpIHtcblx0XHRcdHdvc2V0IC09IHRoYXQucGFyZW50RGF0YS5sZWZ0O1xuXHRcdH1cblxuXHRcdGlmICh3b3NldCArIHRoYXQuc2l6ZS53aWR0aCA+PSB0aGF0LnBhcmVudERhdGEud2lkdGgpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQucGFyZW50RGF0YS53aWR0aCAtIHdvc2V0O1xuXHRcdFx0aWYgKHBSYXRpbykge1xuXHRcdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLndpZHRoIC8gdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaG9zZXQgKyB0aGF0LnNpemUuaGVpZ2h0ID49IHRoYXQucGFyZW50RGF0YS5oZWlnaHQpIHtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnBhcmVudERhdGEuaGVpZ2h0IC0gaG9zZXQ7XG5cdFx0XHRpZiAocFJhdGlvKSB7XG5cdFx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS5oZWlnaHQgKiB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpe1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlXCIpLFxuXHRcdFx0byA9IHRoYXQub3B0aW9ucyxcblx0XHRcdGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsXG5cdFx0XHRjb3AgPSB0aGF0LmNvbnRhaW5lclBvc2l0aW9uLFxuXHRcdFx0Y2UgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQsXG5cdFx0XHRoZWxwZXIgPSAkKHRoYXQuaGVscGVyKSxcblx0XHRcdGhvID0gaGVscGVyLm9mZnNldCgpLFxuXHRcdFx0dyA9IGhlbHBlci5vdXRlcldpZHRoKCkgLSB0aGF0LnNpemVEaWZmLndpZHRoLFxuXHRcdFx0aCA9IGhlbHBlci5vdXRlckhlaWdodCgpIC0gdGhhdC5zaXplRGlmZi5oZWlnaHQ7XG5cblx0XHRpZiAodGhhdC5faGVscGVyICYmICFvLmFuaW1hdGUgJiYgKC9yZWxhdGl2ZS8pLnRlc3QoY2UuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHQkKHRoaXMpLmNzcyh7IGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoYXQuX2hlbHBlciAmJiAhby5hbmltYXRlICYmICgvc3RhdGljLykudGVzdChjZS5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdCQodGhpcykuY3NzKHsgbGVmdDogaG8ubGVmdCAtIGNvcC5sZWZ0IC0gY28ubGVmdCwgd2lkdGg6IHcsIGhlaWdodDogaCB9KTtcblx0XHR9XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImFsc29SZXNpemVcIiwge1xuXG5cdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJ1aS1yZXNpemFibGVcIiksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0X3N0b3JlID0gZnVuY3Rpb24gKGV4cCkge1xuXHRcdFx0XHQkKGV4cCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWwgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdGVsLmRhdGEoXCJ1aS1yZXNpemFibGUtYWxzb3Jlc2l6ZVwiLCB7XG5cdFx0XHRcdFx0XHR3aWR0aDogcGFyc2VJbnQoZWwud2lkdGgoKSwgMTApLCBoZWlnaHQ6IHBhcnNlSW50KGVsLmhlaWdodCgpLCAxMCksXG5cdFx0XHRcdFx0XHRsZWZ0OiBwYXJzZUludChlbC5jc3MoXCJsZWZ0XCIpLCAxMCksIHRvcDogcGFyc2VJbnQoZWwuY3NzKFwidG9wXCIpLCAxMClcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0aWYgKHR5cGVvZihvLmFsc29SZXNpemUpID09PSBcIm9iamVjdFwiICYmICFvLmFsc29SZXNpemUucGFyZW50Tm9kZSkge1xuXHRcdFx0aWYgKG8uYWxzb1Jlc2l6ZS5sZW5ndGgpIHsgby5hbHNvUmVzaXplID0gby5hbHNvUmVzaXplWzBdOyBfc3RvcmUoby5hbHNvUmVzaXplKTsgfVxuXHRcdFx0ZWxzZSB7ICQuZWFjaChvLmFsc29SZXNpemUsIGZ1bmN0aW9uIChleHApIHsgX3N0b3JlKGV4cCk7IH0pOyB9XG5cdFx0fWVsc2V7XG5cdFx0XHRfc3RvcmUoby5hbHNvUmVzaXplKTtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJ1aS1yZXNpemFibGVcIiksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0b3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSxcblx0XHRcdG9wID0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0ZGVsdGEgPSB7XG5cdFx0XHRcdGhlaWdodDogKHRoYXQuc2l6ZS5oZWlnaHQgLSBvcy5oZWlnaHQpIHx8IDAsIHdpZHRoOiAodGhhdC5zaXplLndpZHRoIC0gb3Mud2lkdGgpIHx8IDAsXG5cdFx0XHRcdHRvcDogKHRoYXQucG9zaXRpb24udG9wIC0gb3AudG9wKSB8fCAwLCBsZWZ0OiAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gb3AubGVmdCkgfHwgMFxuXHRcdFx0fSxcblxuXHRcdFx0X2Fsc29SZXNpemUgPSBmdW5jdGlvbiAoZXhwLCBjKSB7XG5cdFx0XHRcdCQoZXhwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbCA9ICQodGhpcyksIHN0YXJ0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlLWFsc29yZXNpemVcIiksIHN0eWxlID0ge30sXG5cdFx0XHRcdFx0XHRjc3MgPSBjICYmIGMubGVuZ3RoID8gYyA6IGVsLnBhcmVudHModWkub3JpZ2luYWxFbGVtZW50WzBdKS5sZW5ndGggPyBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSA6IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidG9wXCIsIFwibGVmdFwiXTtcblxuXHRcdFx0XHRcdCQuZWFjaChjc3MsIGZ1bmN0aW9uIChpLCBwcm9wKSB7XG5cdFx0XHRcdFx0XHR2YXIgc3VtID0gKHN0YXJ0W3Byb3BdfHwwKSArIChkZWx0YVtwcm9wXXx8MCk7XG5cdFx0XHRcdFx0XHRpZiAoc3VtICYmIHN1bSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gc3VtIHx8IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRlbC5jc3Moc3R5bGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRpZiAodHlwZW9mKG8uYWxzb1Jlc2l6ZSkgPT09IFwib2JqZWN0XCIgJiYgIW8uYWxzb1Jlc2l6ZS5ub2RlVHlwZSkge1xuXHRcdFx0JC5lYWNoKG8uYWxzb1Jlc2l6ZSwgZnVuY3Rpb24gKGV4cCwgYykgeyBfYWxzb1Jlc2l6ZShleHAsIGMpOyB9KTtcblx0XHR9ZWxzZXtcblx0XHRcdF9hbHNvUmVzaXplKG8uYWxzb1Jlc2l6ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHQkKHRoaXMpLnJlbW92ZURhdGEoXCJyZXNpemFibGUtYWxzb3Jlc2l6ZVwiKTtcblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcInJlc2l6YWJsZVwiLCBcImdob3N0XCIsIHtcblxuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInVpLXJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucywgY3MgPSB0aGF0LnNpemU7XG5cblx0XHR0aGF0Lmdob3N0ID0gdGhhdC5vcmlnaW5hbEVsZW1lbnQuY2xvbmUoKTtcblx0XHR0aGF0Lmdob3N0XG5cdFx0XHQuY3NzKHsgb3BhY2l0eTogMC4yNSwgZGlzcGxheTogXCJibG9ja1wiLCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCBoZWlnaHQ6IGNzLmhlaWdodCwgd2lkdGg6IGNzLndpZHRoLCBtYXJnaW46IDAsIGxlZnQ6IDAsIHRvcDogMCB9KVxuXHRcdFx0LmFkZENsYXNzKFwidWktcmVzaXphYmxlLWdob3N0XCIpXG5cdFx0XHQuYWRkQ2xhc3ModHlwZW9mIG8uZ2hvc3QgPT09IFwic3RyaW5nXCIgPyBvLmdob3N0IDogXCJcIik7XG5cblx0XHR0aGF0Lmdob3N0LmFwcGVuZFRvKHRoYXQuaGVscGVyKTtcblxuXHR9LFxuXG5cdHJlc2l6ZTogZnVuY3Rpb24oKXtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInVpLXJlc2l6YWJsZVwiKTtcblx0XHRpZiAodGhhdC5naG9zdCkge1xuXHRcdFx0dGhhdC5naG9zdC5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCBoZWlnaHQ6IHRoYXQuc2l6ZS5oZWlnaHQsIHdpZHRoOiB0aGF0LnNpemUud2lkdGggfSk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwidWktcmVzaXphYmxlXCIpO1xuXHRcdGlmICh0aGF0Lmdob3N0ICYmIHRoYXQuaGVscGVyKSB7XG5cdFx0XHR0aGF0LmhlbHBlci5nZXQoMCkucmVtb3ZlQ2hpbGQodGhhdC5naG9zdC5nZXQoMCkpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwicmVzaXphYmxlXCIsIFwiZ3JpZFwiLCB7XG5cblx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInVpLXJlc2l6YWJsZVwiKSxcblx0XHRcdG8gPSB0aGF0Lm9wdGlvbnMsXG5cdFx0XHRjcyA9IHRoYXQuc2l6ZSxcblx0XHRcdG9zID0gdGhhdC5vcmlnaW5hbFNpemUsXG5cdFx0XHRvcCA9IHRoYXQub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdGEgPSB0aGF0LmF4aXMsXG5cdFx0XHRncmlkID0gdHlwZW9mIG8uZ3JpZCA9PT0gXCJudW1iZXJcIiA/IFtvLmdyaWQsIG8uZ3JpZF0gOiBvLmdyaWQsXG5cdFx0XHRncmlkWCA9IChncmlkWzBdfHwxKSxcblx0XHRcdGdyaWRZID0gKGdyaWRbMV18fDEpLFxuXHRcdFx0b3ggPSBNYXRoLnJvdW5kKChjcy53aWR0aCAtIG9zLndpZHRoKSAvIGdyaWRYKSAqIGdyaWRYLFxuXHRcdFx0b3kgPSBNYXRoLnJvdW5kKChjcy5oZWlnaHQgLSBvcy5oZWlnaHQpIC8gZ3JpZFkpICogZ3JpZFksXG5cdFx0XHRuZXdXaWR0aCA9IG9zLndpZHRoICsgb3gsXG5cdFx0XHRuZXdIZWlnaHQgPSBvcy5oZWlnaHQgKyBveSxcblx0XHRcdGlzTWF4V2lkdGggPSBvLm1heFdpZHRoICYmIChvLm1heFdpZHRoIDwgbmV3V2lkdGgpLFxuXHRcdFx0aXNNYXhIZWlnaHQgPSBvLm1heEhlaWdodCAmJiAoby5tYXhIZWlnaHQgPCBuZXdIZWlnaHQpLFxuXHRcdFx0aXNNaW5XaWR0aCA9IG8ubWluV2lkdGggJiYgKG8ubWluV2lkdGggPiBuZXdXaWR0aCksXG5cdFx0XHRpc01pbkhlaWdodCA9IG8ubWluSGVpZ2h0ICYmIChvLm1pbkhlaWdodCA+IG5ld0hlaWdodCk7XG5cblx0XHRvLmdyaWQgPSBncmlkO1xuXG5cdFx0aWYgKGlzTWluV2lkdGgpIHtcblx0XHRcdG5ld1dpZHRoID0gbmV3V2lkdGggKyBncmlkWDtcblx0XHR9XG5cdFx0aWYgKGlzTWluSGVpZ2h0KSB7XG5cdFx0XHRuZXdIZWlnaHQgPSBuZXdIZWlnaHQgKyBncmlkWTtcblx0XHR9XG5cdFx0aWYgKGlzTWF4V2lkdGgpIHtcblx0XHRcdG5ld1dpZHRoID0gbmV3V2lkdGggLSBncmlkWDtcblx0XHR9XG5cdFx0aWYgKGlzTWF4SGVpZ2h0KSB7XG5cdFx0XHRuZXdIZWlnaHQgPSBuZXdIZWlnaHQgLSBncmlkWTtcblx0XHR9XG5cblx0XHRpZiAoL14oc2V8c3xlKSQvLnRlc3QoYSkpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHR9IGVsc2UgaWYgKC9eKG5lKSQvLnRlc3QoYSkpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XG5cdFx0fSBlbHNlIGlmICgvXihzdykkLy50ZXN0KGEpKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5zZWxlY3RhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEwLjNcIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcImJvZHlcIixcblx0XHRhdXRvUmVmcmVzaDogdHJ1ZSxcblx0XHRkaXN0YW5jZTogMCxcblx0XHRmaWx0ZXI6IFwiKlwiLFxuXHRcdHRvbGVyYW5jZTogXCJ0b3VjaFwiLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0c2VsZWN0ZWQ6IG51bGwsXG5cdFx0c2VsZWN0aW5nOiBudWxsLFxuXHRcdHN0YXJ0OiBudWxsLFxuXHRcdHN0b3A6IG51bGwsXG5cdFx0dW5zZWxlY3RlZDogbnVsbCxcblx0XHR1bnNlbGVjdGluZzogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0ZWVzLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RhYmxlXCIpO1xuXG5cdFx0dGhpcy5kcmFnZ2VkID0gZmFsc2U7XG5cblx0XHQvLyBjYWNoZSBzZWxlY3RlZSBjaGlsZHJlbiBiYXNlZCBvbiBmaWx0ZXJcblx0XHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGVjdGVlcyA9ICQodGhhdC5vcHRpb25zLmZpbHRlciwgdGhhdC5lbGVtZW50WzBdKTtcblx0XHRcdHNlbGVjdGVlcy5hZGRDbGFzcyhcInVpLXNlbGVjdGVlXCIpO1xuXHRcdFx0c2VsZWN0ZWVzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXG5cdFx0XHRcdFx0cG9zID0gJHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRcdCQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiLCB7XG5cdFx0XHRcdFx0ZWxlbWVudDogdGhpcyxcblx0XHRcdFx0XHQkZWxlbWVudDogJHRoaXMsXG5cdFx0XHRcdFx0bGVmdDogcG9zLmxlZnQsXG5cdFx0XHRcdFx0dG9wOiBwb3MudG9wLFxuXHRcdFx0XHRcdHJpZ2h0OiBwb3MubGVmdCArICR0aGlzLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRib3R0b206IHBvcy50b3AgKyAkdGhpcy5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHN0YXJ0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdHNlbGVjdGVkOiAkdGhpcy5oYXNDbGFzcyhcInVpLXNlbGVjdGVkXCIpLFxuXHRcdFx0XHRcdHNlbGVjdGluZzogJHRoaXMuaGFzQ2xhc3MoXCJ1aS1zZWxlY3RpbmdcIiksXG5cdFx0XHRcdFx0dW5zZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKFwidWktdW5zZWxlY3RpbmdcIilcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0dGhpcy5zZWxlY3RlZXMgPSBzZWxlY3RlZXMuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RlZVwiKTtcblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0dGhpcy5oZWxwZXIgPSAkKFwiPGRpdiBjbGFzcz0ndWktc2VsZWN0YWJsZS1oZWxwZXInPjwvZGl2PlwiKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZWxlY3RlZXNcblx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGVlXCIpXG5cdFx0XHQucmVtb3ZlRGF0YShcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGFibGUgdWktc2VsZWN0YWJsZS1kaXNhYmxlZFwiKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5vcG9zID0gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWxlY3RlZXMgPSAkKG9wdGlvbnMuZmlsdGVyLCB0aGlzLmVsZW1lbnRbMF0pO1xuXG5cdFx0dGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsIGV2ZW50KTtcblxuXHRcdCQob3B0aW9ucy5hcHBlbmRUbykuYXBwZW5kKHRoaXMuaGVscGVyKTtcblx0XHQvLyBwb3NpdGlvbiBoZWxwZXIgKGxhc3NvKVxuXHRcdHRoaXMuaGVscGVyLmNzcyh7XG5cdFx0XHRcImxlZnRcIjogZXZlbnQucGFnZVgsXG5cdFx0XHRcInRvcFwiOiBldmVudC5wYWdlWSxcblx0XHRcdFwid2lkdGhcIjogMCxcblx0XHRcdFwiaGVpZ2h0XCI6IDBcblx0XHR9KTtcblxuXHRcdGlmIChvcHRpb25zLmF1dG9SZWZyZXNoKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9XG5cblx0XHR0aGlzLnNlbGVjdGVlcy5maWx0ZXIoXCIudWktc2VsZWN0ZWRcIikuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5KSB7XG5cdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktc2VsZWN0ZWRcIik7XG5cdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gc2VsZWN0YWJsZSBVTlNFTEVDVElORyBjYWxsYmFja1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdCQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZG9TZWxlY3QsXG5cdFx0XHRcdHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIpO1xuXHRcdFx0aWYgKHNlbGVjdGVlKSB7XG5cdFx0XHRcdGRvU2VsZWN0ID0gKCFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5KSB8fCAhc2VsZWN0ZWUuJGVsZW1lbnQuaGFzQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKTtcblx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoZG9TZWxlY3QgPyBcInVpLXVuc2VsZWN0aW5nXCIgOiBcInVpLXNlbGVjdGVkXCIpXG5cdFx0XHRcdFx0LmFkZENsYXNzKGRvU2VsZWN0ID8gXCJ1aS1zZWxlY3RpbmdcIiA6IFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gIWRvU2VsZWN0O1xuXHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBkb1NlbGVjdDtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBkb1NlbGVjdDtcblx0XHRcdFx0Ly8gc2VsZWN0YWJsZSAoVU4pU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdGlmIChkb1NlbGVjdCkge1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJzZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdHNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dGhpcy5kcmFnZ2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG1wLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0eDEgPSB0aGlzLm9wb3NbMF0sXG5cdFx0XHR5MSA9IHRoaXMub3Bvc1sxXSxcblx0XHRcdHgyID0gZXZlbnQucGFnZVgsXG5cdFx0XHR5MiA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0aWYgKHgxID4geDIpIHsgdG1wID0geDI7IHgyID0geDE7IHgxID0gdG1wOyB9XG5cdFx0aWYgKHkxID4geTIpIHsgdG1wID0geTI7IHkyID0geTE7IHkxID0gdG1wOyB9XG5cdFx0dGhpcy5oZWxwZXIuY3NzKHtsZWZ0OiB4MSwgdG9wOiB5MSwgd2lkdGg6IHgyLXgxLCBoZWlnaHQ6IHkyLXkxfSk7XG5cblx0XHR0aGlzLnNlbGVjdGVlcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIpLFxuXHRcdFx0XHRoaXQgPSBmYWxzZTtcblxuXHRcdFx0Ly9wcmV2ZW50IGhlbHBlciBmcm9tIGJlaW5nIHNlbGVjdGVkIGlmIGFwcGVuZFRvOiBzZWxlY3RhYmxlXG5cdFx0XHRpZiAoIXNlbGVjdGVlIHx8IHNlbGVjdGVlLmVsZW1lbnQgPT09IHRoYXQuZWxlbWVudFswXSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLnRvbGVyYW5jZSA9PT0gXCJ0b3VjaFwiKSB7XG5cdFx0XHRcdGhpdCA9ICggIShzZWxlY3RlZS5sZWZ0ID4geDIgfHwgc2VsZWN0ZWUucmlnaHQgPCB4MSB8fCBzZWxlY3RlZS50b3AgPiB5MiB8fCBzZWxlY3RlZS5ib3R0b20gPCB5MSkgKTtcblx0XHRcdH0gZWxzZSBpZiAob3B0aW9ucy50b2xlcmFuY2UgPT09IFwiZml0XCIpIHtcblx0XHRcdFx0aGl0ID0gKHNlbGVjdGVlLmxlZnQgPiB4MSAmJiBzZWxlY3RlZS5yaWdodCA8IHgyICYmIHNlbGVjdGVlLnRvcCA+IHkxICYmIHNlbGVjdGVlLmJvdHRvbSA8IHkyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhpdCkge1xuXHRcdFx0XHQvLyBTRUxFQ1Rcblx0XHRcdFx0aWYgKHNlbGVjdGVlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKTtcblx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxlY3RlZS51bnNlbGVjdGluZykge1xuXHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXNlbGVjdGVlLnNlbGVjdGluZykge1xuXHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFwidWktc2VsZWN0aW5nXCIpO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gc2VsZWN0YWJsZSBTRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwic2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVU5TRUxFQ1Rcblx0XHRcdFx0aWYgKHNlbGVjdGVlLnNlbGVjdGluZykge1xuXHRcdFx0XHRcdGlmICgoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJiBzZWxlY3RlZS5zdGFydHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLXNlbGVjdGluZ1wiKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RpbmdcIik7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChzZWxlY3RlZS5zdGFydHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0XHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxlY3RlZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5kcmFnZ2VkID0gZmFsc2U7XG5cblx0XHQkKFwiLnVpLXVuc2VsZWN0aW5nXCIsIHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwidWktdW5zZWxlY3RpbmdcIik7XG5cdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlcihcInVuc2VsZWN0ZWRcIiwgZXZlbnQsIHtcblx0XHRcdFx0dW5zZWxlY3RlZDogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0JChcIi51aS1zZWxlY3RpbmdcIiwgdGhpcy5lbGVtZW50WzBdKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIpO1xuXHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RpbmdcIikuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RlZFwiKTtcblx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IHRydWU7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKFwic2VsZWN0ZWRcIiwgZXZlbnQsIHtcblx0XHRcdFx0c2VsZWN0ZWQ6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KTtcblxuXHRcdHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbn0pO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuZnVuY3Rpb24gaXNPdmVyQXhpcyggeCwgcmVmZXJlbmNlLCBzaXplICkge1xuXHRyZXR1cm4gKCB4ID4gcmVmZXJlbmNlICkgJiYgKCB4IDwgKCByZWZlcmVuY2UgKyBzaXplICkgKTtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdGluZyhpdGVtKSB7XG5cdHJldHVybiAoL2xlZnR8cmlnaHQvKS50ZXN0KGl0ZW0uY3NzKFwiZmxvYXRcIikpIHx8ICgvaW5saW5lfHRhYmxlLWNlbGwvKS50ZXN0KGl0ZW0uY3NzKFwiZGlzcGxheVwiKSk7XG59XG5cbiQud2lkZ2V0KFwidWkuc29ydGFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzb3J0XCIsXG5cdHJlYWR5OiBmYWxzZSxcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RXaXRoOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0ZHJvcE9uRW1wdHk6IHRydWUsXG5cdFx0Zm9yY2VQbGFjZWhvbGRlclNpemU6IGZhbHNlLFxuXHRcdGZvcmNlSGVscGVyU2l6ZTogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpdGVtczogXCI+ICpcIixcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRwbGFjZWhvbGRlcjogZmFsc2UsXG5cdFx0cmV2ZXJ0OiBmYWxzZSxcblx0XHRzY3JvbGw6IHRydWUsXG5cdFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxuXHRcdHNjcm9sbFNwZWVkOiAyMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0dG9sZXJhbmNlOiBcImludGVyc2VjdFwiLFxuXHRcdHpJbmRleDogMTAwMCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZVN0b3A6IG51bGwsXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdGRlYWN0aXZhdGU6IG51bGwsXG5cdFx0b3V0OiBudWxsLFxuXHRcdG92ZXI6IG51bGwsXG5cdFx0cmVjZWl2ZTogbnVsbCxcblx0XHRyZW1vdmU6IG51bGwsXG5cdFx0c29ydDogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsLFxuXHRcdHVwZGF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuY29udGFpbmVyQ2FjaGUgPSB7fTtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zb3J0YWJsZVwiKTtcblxuXHRcdC8vR2V0IHRoZSBpdGVtc1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0Ly9MZXQncyBkZXRlcm1pbmUgaWYgdGhlIGl0ZW1zIGFyZSBiZWluZyBkaXNwbGF5ZWQgaG9yaXpvbnRhbGx5XG5cdFx0dGhpcy5mbG9hdGluZyA9IHRoaXMuaXRlbXMubGVuZ3RoID8gby5heGlzID09PSBcInhcIiB8fCBpc0Zsb2F0aW5nKHRoaXMuaXRlbXNbMF0uaXRlbSkgOiBmYWxzZTtcblxuXHRcdC8vTGV0J3MgZGV0ZXJtaW5lIHRoZSBwYXJlbnQncyBvZmZzZXRcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdC8vSW5pdGlhbGl6ZSBtb3VzZSBldmVudHMgZm9yIGludGVyYWN0aW9uXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0XHQvL1dlJ3JlIHJlYWR5IHRvIGdvXG5cdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZSB1aS1zb3J0YWJsZS1kaXNhYmxlZFwiKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdHRoaXMuaXRlbXNbaV0uaXRlbS5yZW1vdmVEYXRhKHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMub3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy53aWRnZXQoKS50b2dnbGVDbGFzcyggXCJ1aS1zb3J0YWJsZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERvbid0IGNhbGwgd2lkZ2V0IGJhc2UgX3NldE9wdGlvbiBmb3IgZGlzYWJsZSBhcyBpdCBhZGRzIHVpLXN0YXRlLWRpc2FibGVkIGNsYXNzXG5cdFx0XHQkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCwgb3ZlcnJpZGVIYW5kbGUpIHtcblx0XHR2YXIgY3VycmVudEl0ZW0gPSBudWxsLFxuXHRcdFx0dmFsaWRIYW5kbGUgPSBmYWxzZSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMucmV2ZXJ0aW5nKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMub3B0aW9ucy50eXBlID09PSBcInN0YXRpY1wiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9XZSBoYXZlIHRvIHJlZnJlc2ggdGhlIGl0ZW1zIGRhdGEgb25jZSBmaXJzdFxuXHRcdHRoaXMuX3JlZnJlc2hJdGVtcyhldmVudCk7XG5cblx0XHQvL0ZpbmQgb3V0IGlmIHRoZSBjbGlja2VkIG5vZGUgKG9yIG9uZSBvZiBpdHMgcGFyZW50cykgaXMgYSBhY3R1YWwgaXRlbSBpbiB0aGlzLml0ZW1zXG5cdFx0JChldmVudC50YXJnZXQpLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoJC5kYXRhKHRoaXMsIHRoYXQud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIikgPT09IHRoYXQpIHtcblx0XHRcdFx0Y3VycmVudEl0ZW0gPSAkKHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYoJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCItaXRlbVwiKSA9PT0gdGhhdCkge1xuXHRcdFx0Y3VycmVudEl0ZW0gPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0fVxuXG5cdFx0aWYoIWN1cnJlbnRJdGVtKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgIW92ZXJyaWRlSGFuZGxlKSB7XG5cdFx0XHQkKHRoaXMub3B0aW9ucy5oYW5kbGUsIGN1cnJlbnRJdGVtKS5maW5kKFwiKlwiKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYodGhpcyA9PT0gZXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0dmFsaWRIYW5kbGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmKCF2YWxpZEhhbmRsZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJyZW50SXRlbSA9IGN1cnJlbnRJdGVtO1xuXHRcdHRoaXMuX3JlbW92ZUN1cnJlbnRzRnJvbUl0ZW1zKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQsIG92ZXJyaWRlSGFuZGxlLCBub0FjdGl2YXRpb24pIHtcblxuXHRcdHZhciBpLCBib2R5LFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuY3VycmVudENvbnRhaW5lciA9IHRoaXM7XG5cblx0XHQvL1dlIG9ubHkgbmVlZCB0byBjYWxsIHJlZnJlc2hQb3NpdGlvbnMsIGJlY2F1c2UgdGhlIHJlZnJlc2hJdGVtcyBjYWxsIGhhcyBiZWVuIG1vdmVkIHRvIG1vdXNlQ2FwdHVyZVxuXHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBnZW5lcmF0aW9uIC1cblx0XHQgKiBUaGlzIGJsb2NrIGdlbmVyYXRlcyBldmVyeXRoaW5nIHBvc2l0aW9uIHJlbGF0ZWQgLSBpdCdzIHRoZSBjb3JlIG9mIGRyYWdnYWJsZXMuXG5cdFx0ICovXG5cblx0XHQvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XG5cdFx0dGhpcy5fY2FjaGVNYXJnaW5zKCk7XG5cblx0XHQvL0dldCB0aGUgbmV4dCBzY3JvbGxpbmcgcGFyZW50XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoKTtcblxuXHRcdC8vVGhlIGVsZW1lbnQncyBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgcGFnZSBtaW51cyBtYXJnaW5zXG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmN1cnJlbnRJdGVtLm9mZnNldCgpO1xuXHRcdHRoaXMub2Zmc2V0ID0ge1xuXHRcdFx0dG9wOiB0aGlzLm9mZnNldC50b3AgLSB0aGlzLm1hcmdpbnMudG9wLFxuXHRcdFx0bGVmdDogdGhpcy5vZmZzZXQubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0XG5cdFx0fTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMub2Zmc2V0LCB7XG5cdFx0XHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblx0XHRcdHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpIC8vVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLSBvbmx5IHVzZWQgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgaGVscGVyXG5cdFx0fSk7XG5cblx0XHQvLyBPbmx5IGFmdGVyIHdlIGdvdCB0aGUgb2Zmc2V0LCB3ZSBjYW4gY2hhbmdlIHRoZSBoZWxwZXIncyBwb3NpdGlvbiB0byBhYnNvbHV0ZVxuXHRcdC8vIFRPRE86IFN0aWxsIG5lZWQgdG8gZmlndXJlIG91dCBhIHdheSB0byBtYWtlIHJlbGF0aXZlIHNvcnRpbmcgcG9zc2libGVcblx0XHR0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuXHRcdHRoaXMuY3NzUG9zaXRpb24gPSB0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiKTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgXCJjdXJzb3JBdFwiIGlzIHN1cHBsaWVkXG5cdFx0KG8uY3Vyc29yQXQgJiYgdGhpcy5fYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvLmN1cnNvckF0KSk7XG5cblx0XHQvL0NhY2hlIHRoZSBmb3JtZXIgRE9NIHBvc2l0aW9uXG5cdFx0dGhpcy5kb21Qb3NpdGlvbiA9IHsgcHJldjogdGhpcy5jdXJyZW50SXRlbS5wcmV2KClbMF0sIHBhcmVudDogdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKVswXSB9O1xuXG5cdFx0Ly9JZiB0aGUgaGVscGVyIGlzIG5vdCB0aGUgb3JpZ2luYWwsIGhpZGUgdGhlIG9yaWdpbmFsIHNvIGl0J3Mgbm90IHBsYXlpbmcgYW55IHJvbGUgZHVyaW5nIHRoZSBkcmFnLCB3b24ndCBjYXVzZSBhbnl0aGluZyBiYWQgdGhpcyB3YXlcblx0XHRpZih0aGlzLmhlbHBlclswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0Ly9DcmVhdGUgdGhlIHBsYWNlaG9sZGVyXG5cdFx0dGhpcy5fY3JlYXRlUGxhY2Vob2xkZXIoKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHRpZihvLmNvbnRhaW5tZW50KSB7XG5cdFx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXHRcdH1cblxuXHRcdGlmKCBvLmN1cnNvciAmJiBvLmN1cnNvciAhPT0gXCJhdXRvXCIgKSB7IC8vIGN1cnNvciBvcHRpb25cblx0XHRcdGJvZHkgPSB0aGlzLmRvY3VtZW50LmZpbmQoIFwiYm9keVwiICk7XG5cblx0XHRcdC8vIHN1cHBvcnQ6IElFXG5cdFx0XHR0aGlzLnN0b3JlZEN1cnNvciA9IGJvZHkuY3NzKCBcImN1cnNvclwiICk7XG5cdFx0XHRib2R5LmNzcyggXCJjdXJzb3JcIiwgby5jdXJzb3IgKTtcblxuXHRcdFx0dGhpcy5zdG9yZWRTdHlsZXNoZWV0ID0gJCggXCI8c3R5bGU+KnsgY3Vyc29yOiBcIitvLmN1cnNvcitcIiAhaW1wb3J0YW50OyB9PC9zdHlsZT5cIiApLmFwcGVuZFRvKCBib2R5ICk7XG5cdFx0fVxuXG5cdFx0aWYoby5vcGFjaXR5KSB7IC8vIG9wYWNpdHkgb3B0aW9uXG5cdFx0XHRpZiAodGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKSkge1xuXHRcdFx0XHR0aGlzLl9zdG9yZWRPcGFjaXR5ID0gdGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIiwgby5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHRpZihvLnpJbmRleCkgeyAvLyB6SW5kZXggb3B0aW9uXG5cdFx0XHRpZiAodGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIpKSB7XG5cdFx0XHRcdHRoaXMuX3N0b3JlZFpJbmRleCA9IHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcInpJbmRleFwiLCBvLnpJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHNjcm9sbGluZ1xuXHRcdGlmKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiB0aGlzLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9PSBcIkhUTUxcIikge1xuXHRcdFx0dGhpcy5vdmVyZmxvd09mZnNldCA9IHRoaXMuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblxuXHRcdC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHRpZighdGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9ucykge1xuXHRcdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXHRcdH1cblxuXG5cdFx0Ly9Qb3N0IFwiYWN0aXZhdGVcIiBldmVudHMgdG8gcG9zc2libGUgY29udGFpbmVyc1xuXHRcdGlmKCAhbm9BY3RpdmF0aW9uICkge1xuXHRcdFx0Zm9yICggaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uX3RyaWdnZXIoIFwiYWN0aXZhdGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9QcmVwYXJlIHBvc3NpYmxlIGRyb3BwYWJsZXNcblx0XHRpZigkLnVpLmRkbWFuYWdlcikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuY3VycmVudCA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuaGVscGVyLmFkZENsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO1xuXHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaSwgaXRlbSwgaXRlbUVsZW1lbnQsIGludGVyc2VjdGlvbixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0aWYgKCF0aGlzLmxhc3RQb3NpdGlvbkFicykge1xuXHRcdFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdH1cblxuXHRcdC8vRG8gc2Nyb2xsaW5nXG5cdFx0aWYodGhpcy5vcHRpb25zLnNjcm9sbCkge1xuXHRcdFx0aWYodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFwiSFRNTFwiKSB7XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQudG9wICsgdGhpcy5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0SGVpZ2h0KSAtIGV2ZW50LnBhZ2VZIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vdmVyZmxvd09mZnNldC50b3AgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdCArIHRoaXMuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoKSAtIGV2ZW50LnBhZ2VYIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVggLSB0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIGlmKCQod2luZG93KS53aWR0aCgpIC0gKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZihzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9SZWdlbmVyYXRlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB1c2VkIGZvciBwb3NpdGlvbiBjaGVja3Ncblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblxuXHRcdC8vU2V0IHRoZSBoZWxwZXIgcG9zaXRpb25cblx0XHRpZighdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHR0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0K1wicHhcIjtcblx0XHR9XG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcInhcIikge1xuXHRcdFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3ArXCJweFwiO1xuXHRcdH1cblxuXHRcdC8vUmVhcnJhbmdlXG5cdFx0Zm9yIChpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXG5cdFx0XHQvL0NhY2hlIHZhcmlhYmxlcyBhbmQgaW50ZXJzZWN0aW9uLCBjb250aW51ZSBpZiBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXHRcdFx0aXRlbUVsZW1lbnQgPSBpdGVtLml0ZW1bMF07XG5cdFx0XHRpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3RzV2l0aFBvaW50ZXIoaXRlbSk7XG5cdFx0XHRpZiAoIWludGVyc2VjdGlvbikge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBwdXQgdGhlIHBsYWNlaG9sZGVyIGluc2lkZSB0aGUgY3VycmVudCBDb250YWluZXIsIHNraXAgYWxsXG5cdFx0XHQvLyBpdGVtcyBmb3JtIG90aGVyIGNvbnRhaW5lcnMuIFRoaXMgd29ya3MgYmVjYXVzZSB3aGVuIG1vdmluZ1xuXHRcdFx0Ly8gYW4gaXRlbSBmcm9tIG9uZSBjb250YWluZXIgdG8gYW5vdGhlciB0aGVcblx0XHRcdC8vIGN1cnJlbnRDb250YWluZXIgaXMgc3dpdGNoZWQgYmVmb3JlIHRoZSBwbGFjZWhvbGRlciBpcyBtb3ZlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMgbW92aW5nIGl0ZW1zIGluIFwic3ViLXNvcnRhYmxlc1wiIGNhbiBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gaml0dGVyXG5cdFx0XHQvLyBiZWV0d2VlbiB0aGUgb3V0ZXIgYW5kIGlubmVyIGNvbnRhaW5lci5cblx0XHRcdGlmIChpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbm5vdCBpbnRlcnNlY3Qgd2l0aCBpdHNlbGZcblx0XHRcdC8vIG5vIHVzZWxlc3MgYWN0aW9ucyB0aGF0IGhhdmUgYmVlbiBkb25lIGJlZm9yZVxuXHRcdFx0Ly8gbm8gYWN0aW9uIGlmIHRoZSBpdGVtIG1vdmVkIGlzIHRoZSBwYXJlbnQgb2YgdGhlIGl0ZW0gY2hlY2tlZFxuXHRcdFx0aWYgKGl0ZW1FbGVtZW50ICE9PSB0aGlzLmN1cnJlbnRJdGVtWzBdICYmXG5cdFx0XHRcdHRoaXMucGxhY2Vob2xkZXJbaW50ZXJzZWN0aW9uID09PSAxID8gXCJuZXh0XCIgOiBcInByZXZcIl0oKVswXSAhPT0gaXRlbUVsZW1lbnQgJiZcblx0XHRcdFx0ISQuY29udGFpbnModGhpcy5wbGFjZWhvbGRlclswXSwgaXRlbUVsZW1lbnQpICYmXG5cdFx0XHRcdCh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXCJzZW1pLWR5bmFtaWNcIiA/ICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgaXRlbUVsZW1lbnQpIDogdHJ1ZSlcblx0XHRcdCkge1xuXG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uID0gaW50ZXJzZWN0aW9uID09PSAxID8gXCJkb3duXCIgOiBcInVwXCI7XG5cblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy50b2xlcmFuY2UgPT09IFwicG9pbnRlclwiIHx8IHRoaXMuX2ludGVyc2VjdHNXaXRoU2lkZXMoaXRlbSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIGl0ZW0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1Bvc3QgZXZlbnRzIHRvIGNvbnRhaW5lcnNcblx0XHR0aGlzLl9jb250YWN0Q29udGFpbmVycyhldmVudCk7XG5cblx0XHQvL0ludGVyY29ubmVjdCB3aXRoIGRyb3BwYWJsZXNcblx0XHRpZigkLnVpLmRkbWFuYWdlcikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZyh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0Ly9DYWxsIGNhbGxiYWNrc1xuXHRcdHRoaXMuX3RyaWdnZXIoXCJzb3J0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cblx0XHR0aGlzLmxhc3RQb3NpdGlvbkFicyA9IHRoaXMucG9zaXRpb25BYnM7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcblxuXHRcdGlmKCFldmVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vSWYgd2UgYXJlIHVzaW5nIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciBhYm91dCB0aGUgZHJvcFxuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyb3AodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMub3B0aW9ucy5yZXZlcnQpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0Y3VyID0gdGhpcy5wbGFjZWhvbGRlci5vZmZzZXQoKSxcblx0XHRcdFx0YXhpcyA9IHRoaXMub3B0aW9ucy5heGlzLFxuXHRcdFx0XHRhbmltYXRpb24gPSB7fTtcblxuXHRcdFx0aWYgKCAhYXhpcyB8fCBheGlzID09PSBcInhcIiApIHtcblx0XHRcdFx0YW5pbWF0aW9uLmxlZnQgPSBjdXIubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnQgKyAodGhpcy5vZmZzZXRQYXJlbnRbMF0gPT09IGRvY3VtZW50LmJvZHkgPyAwIDogdGhpcy5vZmZzZXRQYXJlbnRbMF0uc2Nyb2xsTGVmdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFheGlzIHx8IGF4aXMgPT09IFwieVwiICkge1xuXHRcdFx0XHRhbmltYXRpb24udG9wID0gY3VyLnRvcCAtIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgLSB0aGlzLm1hcmdpbnMudG9wICsgKHRoaXMub2Zmc2V0UGFyZW50WzBdID09PSBkb2N1bWVudC5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbFRvcCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJldmVydGluZyA9IHRydWU7XG5cdFx0XHQkKHRoaXMuaGVscGVyKS5hbmltYXRlKCBhbmltYXRpb24sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnQsIDEwKSB8fCA1MDAsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll9jbGVhcihldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2xlYXIoZXZlbnQsIG5vUHJvcGFnYXRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmRyYWdnaW5nKSB7XG5cblx0XHRcdHRoaXMuX21vdXNlVXAoeyB0YXJnZXQ6IG51bGwgfSk7XG5cblx0XHRcdGlmKHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIikge1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRJdGVtLmNzcyh0aGlzLl9zdG9yZWRDU1MpLnJlbW92ZUNsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vUG9zdCBkZWFjdGl2YXRpbmcgZXZlbnRzIHRvIGNvbnRhaW5lcnNcblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXCJkZWFjdGl2YXRlXCIsIG51bGwsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHRcdGlmKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwib3V0XCIsIG51bGwsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAodGhpcy5wbGFjZWhvbGRlcikge1xuXHRcdFx0Ly8kKHRoaXMucGxhY2Vob2xkZXJbMF0pLnJlbW92ZSgpOyB3b3VsZCBoYXZlIGJlZW4gdGhlIGpRdWVyeSB3YXkgLSB1bmZvcnR1bmF0ZWx5LCBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcblx0XHRcdGlmKHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZSkge1xuXHRcdFx0XHR0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuaGVscGVyICE9PSBcIm9yaWdpbmFsXCIgJiYgdGhpcy5oZWxwZXIgJiYgdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZSkge1xuXHRcdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0JC5leHRlbmQodGhpcywge1xuXHRcdFx0XHRoZWxwZXI6IG51bGwsXG5cdFx0XHRcdGRyYWdnaW5nOiBmYWxzZSxcblx0XHRcdFx0cmV2ZXJ0aW5nOiBmYWxzZSxcblx0XHRcdFx0X25vRmluYWxTb3J0OiBudWxsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYodGhpcy5kb21Qb3NpdGlvbi5wcmV2KSB7XG5cdFx0XHRcdCQodGhpcy5kb21Qb3NpdGlvbi5wcmV2KS5hZnRlcih0aGlzLmN1cnJlbnRJdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQodGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQpLnByZXBlbmQodGhpcy5jdXJyZW50SXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKG8pIHtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkobyAmJiBvLmNvbm5lY3RlZCksXG5cdFx0XHRzdHIgPSBbXTtcblx0XHRvID0gbyB8fCB7fTtcblxuXHRcdCQoaXRlbXMpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gKCQoby5pdGVtIHx8IHRoaXMpLmF0dHIoby5hdHRyaWJ1dGUgfHwgXCJpZFwiKSB8fCBcIlwiKS5tYXRjaChvLmV4cHJlc3Npb24gfHwgKC8oLispW1xcLT1fXSguKykvKSk7XG5cdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdHN0ci5wdXNoKChvLmtleSB8fCByZXNbMV0rXCJbXVwiKStcIj1cIisoby5rZXkgJiYgby5leHByZXNzaW9uID8gcmVzWzFdIDogcmVzWzJdKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZighc3RyLmxlbmd0aCAmJiBvLmtleSkge1xuXHRcdFx0c3RyLnB1c2goby5rZXkgKyBcIj1cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ci5qb2luKFwiJlwiKTtcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKG8pIHtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkobyAmJiBvLmNvbm5lY3RlZCksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdG8gPSBvIHx8IHt9O1xuXG5cdFx0aXRlbXMuZWFjaChmdW5jdGlvbigpIHsgcmV0LnB1c2goJChvLml0ZW0gfHwgdGhpcykuYXR0cihvLmF0dHJpYnV0ZSB8fCBcImlkXCIpIHx8IFwiXCIpOyB9KTtcblx0XHRyZXR1cm4gcmV0O1xuXG5cdH0sXG5cblx0LyogQmUgY2FyZWZ1bCB3aXRoIHRoZSBmb2xsb3dpbmcgY29yZSBmdW5jdGlvbnMgKi9cblx0X2ludGVyc2VjdHNXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHR2YXIgeDEgPSB0aGlzLnBvc2l0aW9uQWJzLmxlZnQsXG5cdFx0XHR4MiA9IHgxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcblx0XHRcdHkxID0gdGhpcy5wb3NpdGlvbkFicy50b3AsXG5cdFx0XHR5MiA9IHkxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsXG5cdFx0XHRsID0gaXRlbS5sZWZ0LFxuXHRcdFx0ciA9IGwgKyBpdGVtLndpZHRoLFxuXHRcdFx0dCA9IGl0ZW0udG9wLFxuXHRcdFx0YiA9IHQgKyBpdGVtLmhlaWdodCxcblx0XHRcdGR5Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay50b3AsXG5cdFx0XHRkeENsaWNrID0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCxcblx0XHRcdGlzT3ZlckVsZW1lbnRIZWlnaHQgPSAoIHRoaXMub3B0aW9ucy5heGlzID09PSBcInhcIiApIHx8ICggKCB5MSArIGR5Q2xpY2sgKSA+IHQgJiYgKCB5MSArIGR5Q2xpY2sgKSA8IGIgKSxcblx0XHRcdGlzT3ZlckVsZW1lbnRXaWR0aCA9ICggdGhpcy5vcHRpb25zLmF4aXMgPT09IFwieVwiICkgfHwgKCAoIHgxICsgZHhDbGljayApID4gbCAmJiAoIHgxICsgZHhDbGljayApIDwgciApLFxuXHRcdFx0aXNPdmVyRWxlbWVudCA9IGlzT3ZlckVsZW1lbnRIZWlnaHQgJiYgaXNPdmVyRWxlbWVudFdpZHRoO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlID09PSBcInBvaW50ZXJcIiB8fFxuXHRcdFx0dGhpcy5vcHRpb25zLmZvcmNlUG9pbnRlckZvckNvbnRhaW5lcnMgfHxcblx0XHRcdCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlICE9PSBcInBvaW50ZXJcIiAmJiB0aGlzLmhlbHBlclByb3BvcnRpb25zW3RoaXMuZmxvYXRpbmcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA+IGl0ZW1bdGhpcy5mbG9hdGluZyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIGlzT3ZlckVsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIChsIDwgeDEgKyAodGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIpICYmIC8vIFJpZ2h0IEhhbGZcblx0XHRcdFx0eDIgLSAodGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIpIDwgciAmJiAvLyBMZWZ0IEhhbGZcblx0XHRcdFx0dCA8IHkxICsgKHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMikgJiYgLy8gQm90dG9tIEhhbGZcblx0XHRcdFx0eTIgLSAodGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyKSA8IGIgKTsgLy8gVG9wIEhhbGZcblxuXHRcdH1cblx0fSxcblxuXHRfaW50ZXJzZWN0c1dpdGhQb2ludGVyOiBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHR2YXIgaXNPdmVyRWxlbWVudEhlaWdodCA9ICh0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXCJ4XCIpIHx8IGlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wLCBpdGVtLmhlaWdodCksXG5cdFx0XHRpc092ZXJFbGVtZW50V2lkdGggPSAodGhpcy5vcHRpb25zLmF4aXMgPT09IFwieVwiKSB8fCBpc092ZXJBeGlzKHRoaXMucG9zaXRpb25BYnMubGVmdCArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsIGl0ZW0ubGVmdCwgaXRlbS53aWR0aCksXG5cdFx0XHRpc092ZXJFbGVtZW50ID0gaXNPdmVyRWxlbWVudEhlaWdodCAmJiBpc092ZXJFbGVtZW50V2lkdGgsXG5cdFx0XHR2ZXJ0aWNhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpLFxuXHRcdFx0aG9yaXpvbnRhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uKCk7XG5cblx0XHRpZiAoIWlzT3ZlckVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5mbG9hdGluZyA/XG5cdFx0XHQoICgoaG9yaXpvbnRhbERpcmVjdGlvbiAmJiBob3Jpem9udGFsRGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHx8IHZlcnRpY2FsRGlyZWN0aW9uID09PSBcImRvd25cIikgPyAyIDogMSApXG5cdFx0XHQ6ICggdmVydGljYWxEaXJlY3Rpb24gJiYgKHZlcnRpY2FsRGlyZWN0aW9uID09PSBcImRvd25cIiA/IDIgOiAxKSApO1xuXG5cdH0sXG5cblx0X2ludGVyc2VjdHNXaXRoU2lkZXM6IGZ1bmN0aW9uKGl0ZW0pIHtcblxuXHRcdHZhciBpc092ZXJCb3R0b21IYWxmID0gaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLnRvcCArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCwgaXRlbS50b3AgKyAoaXRlbS5oZWlnaHQvMiksIGl0ZW0uaGVpZ2h0KSxcblx0XHRcdGlzT3ZlclJpZ2h0SGFsZiA9IGlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy5sZWZ0ICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdCwgaXRlbS5sZWZ0ICsgKGl0ZW0ud2lkdGgvMiksIGl0ZW0ud2lkdGgpLFxuXHRcdFx0dmVydGljYWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSxcblx0XHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0aWYgKHRoaXMuZmxvYXRpbmcgJiYgaG9yaXpvbnRhbERpcmVjdGlvbikge1xuXHRcdFx0cmV0dXJuICgoaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXCJyaWdodFwiICYmIGlzT3ZlclJpZ2h0SGFsZikgfHwgKGhvcml6b250YWxEaXJlY3Rpb24gPT09IFwibGVmdFwiICYmICFpc092ZXJSaWdodEhhbGYpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZlcnRpY2FsRGlyZWN0aW9uICYmICgodmVydGljYWxEaXJlY3Rpb24gPT09IFwiZG93blwiICYmIGlzT3ZlckJvdHRvbUhhbGYpIHx8ICh2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXCJ1cFwiICYmICFpc092ZXJCb3R0b21IYWxmKSk7XG5cdFx0fVxuXG5cdH0sXG5cblx0X2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy50b3AgLSB0aGlzLmxhc3RQb3NpdGlvbkFicy50b3A7XG5cdFx0cmV0dXJuIGRlbHRhICE9PSAwICYmIChkZWx0YSA+IDAgPyBcImRvd25cIiA6IFwidXBcIik7XG5cdH0sXG5cblx0X2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLnBvc2l0aW9uQWJzLmxlZnQgLSB0aGlzLmxhc3RQb3NpdGlvbkFicy5sZWZ0O1xuXHRcdHJldHVybiBkZWx0YSAhPT0gMCAmJiAoZGVsdGEgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5fcmVmcmVzaEl0ZW1zKGV2ZW50KTtcblx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY29ubmVjdFdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHJldHVybiBvcHRpb25zLmNvbm5lY3RXaXRoLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBbb3B0aW9ucy5jb25uZWN0V2l0aF0gOiBvcHRpb25zLmNvbm5lY3RXaXRoO1xuXHR9LFxuXG5cdF9nZXRJdGVtc0FzalF1ZXJ5OiBmdW5jdGlvbihjb25uZWN0ZWQpIHtcblxuXHRcdHZhciBpLCBqLCBjdXIsIGluc3QsXG5cdFx0XHRpdGVtcyA9IFtdLFxuXHRcdFx0cXVlcmllcyA9IFtdLFxuXHRcdFx0Y29ubmVjdFdpdGggPSB0aGlzLl9jb25uZWN0V2l0aCgpO1xuXG5cdFx0aWYoY29ubmVjdFdpdGggJiYgY29ubmVjdGVkKSB7XG5cdFx0XHRmb3IgKGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdGN1ciA9ICQoY29ubmVjdFdpdGhbaV0pO1xuXHRcdFx0XHRmb3IgKCBqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKXtcblx0XHRcdFx0XHRpbnN0ID0gJC5kYXRhKGN1cltqXSwgdGhpcy53aWRnZXRGdWxsTmFtZSk7XG5cdFx0XHRcdFx0aWYoaW5zdCAmJiBpbnN0ICE9PSB0aGlzICYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5pdGVtcykgPyBpbnN0Lm9wdGlvbnMuaXRlbXMuY2FsbChpbnN0LmVsZW1lbnQpIDogJChpbnN0Lm9wdGlvbnMuaXRlbXMsIGluc3QuZWxlbWVudCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKS5ub3QoXCIudWktc29ydGFibGUtcGxhY2Vob2xkZXJcIiksIGluc3RdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuaXRlbXMpID8gdGhpcy5vcHRpb25zLml0ZW1zLmNhbGwodGhpcy5lbGVtZW50LCBudWxsLCB7IG9wdGlvbnM6IHRoaXMub3B0aW9ucywgaXRlbTogdGhpcy5jdXJyZW50SXRlbSB9KSA6ICQodGhpcy5vcHRpb25zLml0ZW1zLCB0aGlzLmVsZW1lbnQpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIikubm90KFwiLnVpLXNvcnRhYmxlLXBsYWNlaG9sZGVyXCIpLCB0aGlzXSk7XG5cblx0XHRmb3IgKGkgPSBxdWVyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdHF1ZXJpZXNbaV1bMF0uZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXRlbXMucHVzaCh0aGlzKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiAkKGl0ZW1zKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVDdXJyZW50c0Zyb21JdGVtczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGlzdCA9IHRoaXMuY3VycmVudEl0ZW0uZmluZChcIjpkYXRhKFwiICsgdGhpcy53aWRnZXROYW1lICsgXCItaXRlbSlcIik7XG5cblx0XHR0aGlzLml0ZW1zID0gJC5ncmVwKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRmb3IgKHZhciBqPTA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmKGxpc3Rbal0gPT09IGl0ZW0uaXRlbVswXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0fSxcblxuXHRfcmVmcmVzaEl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dGhpcy5pdGVtcyA9IFtdO1xuXHRcdHRoaXMuY29udGFpbmVycyA9IFt0aGlzXTtcblxuXHRcdHZhciBpLCBqLCBjdXIsIGluc3QsIHRhcmdldERhdGEsIF9xdWVyaWVzLCBpdGVtLCBxdWVyaWVzTGVuZ3RoLFxuXHRcdFx0aXRlbXMgPSB0aGlzLml0ZW1zLFxuXHRcdFx0cXVlcmllcyA9IFtbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50KSwgdGhpc11dLFxuXHRcdFx0Y29ubmVjdFdpdGggPSB0aGlzLl9jb25uZWN0V2l0aCgpO1xuXG5cdFx0aWYoY29ubmVjdFdpdGggJiYgdGhpcy5yZWFkeSkgeyAvL1Nob3VsZG4ndCBiZSBydW4gdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCBkdWUgdG8gbWFzc2l2ZSBzbG93LWRvd25cblx0XHRcdGZvciAoaSA9IGNvbm5lY3RXaXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0Y3VyID0gJChjb25uZWN0V2l0aFtpXSk7XG5cdFx0XHRcdGZvciAoaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSl7XG5cdFx0XHRcdFx0aW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0RnVsbE5hbWUpO1xuXHRcdFx0XHRcdGlmKGluc3QgJiYgaW5zdCAhPT0gdGhpcyAmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdFx0XHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuaXRlbXMpID8gaW5zdC5vcHRpb25zLml0ZW1zLmNhbGwoaW5zdC5lbGVtZW50WzBdLCBldmVudCwgeyBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJChpbnN0Lm9wdGlvbnMuaXRlbXMsIGluc3QuZWxlbWVudCksIGluc3RdKTtcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbmVycy5wdXNoKGluc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHRhcmdldERhdGEgPSBxdWVyaWVzW2ldWzFdO1xuXHRcdFx0X3F1ZXJpZXMgPSBxdWVyaWVzW2ldWzBdO1xuXG5cdFx0XHRmb3IgKGo9MCwgcXVlcmllc0xlbmd0aCA9IF9xdWVyaWVzLmxlbmd0aDsgaiA8IHF1ZXJpZXNMZW5ndGg7IGorKykge1xuXHRcdFx0XHRpdGVtID0gJChfcXVlcmllc1tqXSk7XG5cblx0XHRcdFx0aXRlbS5kYXRhKHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIiwgdGFyZ2V0RGF0YSk7IC8vIERhdGEgZm9yIHRhcmdldCBjaGVja2luZyAobW91c2UgbWFuYWdlcilcblxuXHRcdFx0XHRpdGVtcy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRcdGluc3RhbmNlOiB0YXJnZXREYXRhLFxuXHRcdFx0XHRcdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCwgdG9wOiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9LFxuXG5cdHJlZnJlc2hQb3NpdGlvbnM6IGZ1bmN0aW9uKGZhc3QpIHtcblxuXHRcdC8vVGhpcyBoYXMgdG8gYmUgcmVkb25lIGJlY2F1c2UgZHVlIHRvIHRoZSBpdGVtIGJlaW5nIG1vdmVkIG91dC9pbnRvIHRoZSBvZmZzZXRQYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQncyBwb3NpdGlvbiB3aWxsIGNoYW5nZVxuXHRcdGlmKHRoaXMub2Zmc2V0UGFyZW50ICYmIHRoaXMuaGVscGVyKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaXRlbSwgdCwgcDtcblxuXHRcdGZvciAoaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cblx0XHRcdC8vV2UgaWdub3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9ucyBvZiBhbGwgY29ubmVjdGVkIGNvbnRhaW5lcnMgd2hlbiB3ZSdyZSBub3Qgb3ZlciB0aGVtXG5cdFx0XHRpZihpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIgJiYgdGhpcy5jdXJyZW50Q29udGFpbmVyICYmIGl0ZW0uaXRlbVswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dCA9IHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50ID8gJCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCwgaXRlbS5pdGVtKSA6IGl0ZW0uaXRlbTtcblxuXHRcdFx0aWYgKCFmYXN0KSB7XG5cdFx0XHRcdGl0ZW0ud2lkdGggPSB0Lm91dGVyV2lkdGgoKTtcblx0XHRcdFx0aXRlbS5oZWlnaHQgPSB0Lm91dGVySGVpZ2h0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHAgPSB0Lm9mZnNldCgpO1xuXHRcdFx0aXRlbS5sZWZ0ID0gcC5sZWZ0O1xuXHRcdFx0aXRlbS50b3AgPSBwLnRvcDtcblx0XHR9XG5cblx0XHRpZih0aGlzLm9wdGlvbnMuY3VzdG9tICYmIHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMuY2FsbCh0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0cCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUubGVmdCA9IHAubGVmdDtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLnRvcCA9IHAudG9wO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUud2lkdGhcdD0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKHRoYXQpIHtcblx0XHR0aGF0ID0gdGhhdCB8fCB0aGlzO1xuXHRcdHZhciBjbGFzc05hbWUsXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zO1xuXG5cdFx0aWYoIW8ucGxhY2Vob2xkZXIgfHwgby5wbGFjZWhvbGRlci5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG5cdFx0XHRjbGFzc05hbWUgPSBvLnBsYWNlaG9sZGVyO1xuXHRcdFx0by5wbGFjZWhvbGRlciA9IHtcblx0XHRcdFx0ZWxlbWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZU5hbWUgPSB0aGF0LmN1cnJlbnRJdGVtWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHRlbGVtZW50ID0gJCggXCI8XCIgKyBub2RlTmFtZSArIFwiPlwiLCB0aGF0LmRvY3VtZW50WzBdIClcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKGNsYXNzTmFtZSB8fCB0aGF0LmN1cnJlbnRJdGVtWzBdLmNsYXNzTmFtZStcIiB1aS1zb3J0YWJsZS1wbGFjZWhvbGRlclwiKVxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIik7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSBcInRyXCIgKSB7XG5cdFx0XHRcdFx0XHR0aGF0LmN1cnJlbnRJdGVtLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JCggXCI8dGQ+JiMxNjA7PC90ZD5cIiwgdGhhdC5kb2N1bWVudFswXSApXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoIFwiY29sc3BhblwiLCAkKCB0aGlzICkuYXR0ciggXCJjb2xzcGFuXCIgKSB8fCAxIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImltZ1wiICkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5hdHRyKCBcInNyY1wiLCB0aGF0LmN1cnJlbnRJdGVtLmF0dHIoIFwic3JjXCIgKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggIWNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQuY3NzKCBcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcCkge1xuXG5cdFx0XHRcdFx0Ly8gMS4gSWYgYSBjbGFzc05hbWUgaXMgc2V0IGFzICdwbGFjZWhvbGRlciBvcHRpb24sIHdlIGRvbid0IGZvcmNlIHNpemVzIC0gdGhlIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0XG5cdFx0XHRcdFx0Ly8gMi4gVGhlIG9wdGlvbiAnZm9yY2VQbGFjZWhvbGRlclNpemUgY2FuIGJlIGVuYWJsZWQgdG8gZm9yY2UgaXQgZXZlbiBpZiBhIGNsYXNzIG5hbWUgaXMgc3BlY2lmaWVkXG5cdFx0XHRcdFx0aWYoY2xhc3NOYW1lICYmICFvLmZvcmNlUGxhY2Vob2xkZXJTaXplKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9JZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBhY3R1YWwgaGVpZ2h0IGJ5IGl0c2VsZiAod2l0aG91dCBzdHlsZXMgY29taW5nIGZyb20gYSBzdHlsZXNoZWV0KSwgaXQgcmVjZWl2ZXMgdGhlIGlubGluZSBoZWlnaHQgZnJvbSB0aGUgZHJhZ2dlZCBpdGVtXG5cdFx0XHRcdFx0aWYoIXAuaGVpZ2h0KCkpIHsgcC5oZWlnaHQodGhhdC5jdXJyZW50SXRlbS5pbm5lckhlaWdodCgpIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXCJwYWRkaW5nVG9wXCIpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdCb3R0b21cIil8fDAsIDEwKSk7IH1cblx0XHRcdFx0XHRpZighcC53aWR0aCgpKSB7IHAud2lkdGgodGhhdC5jdXJyZW50SXRlbS5pbm5lcldpZHRoKCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdMZWZ0XCIpfHwwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcInBhZGRpbmdSaWdodFwiKXx8MCwgMTApKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoYXQucGxhY2Vob2xkZXIgPSAkKG8ucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKHRoYXQuZWxlbWVudCwgdGhhdC5jdXJyZW50SXRlbSkpO1xuXG5cdFx0Ly9BcHBlbmQgaXQgYWZ0ZXIgdGhlIGFjdHVhbCBjdXJyZW50IGl0ZW1cblx0XHR0aGF0LmN1cnJlbnRJdGVtLmFmdGVyKHRoYXQucGxhY2Vob2xkZXIpO1xuXG5cdFx0Ly9VcGRhdGUgdGhlIHNpemUgb2YgdGhlIHBsYWNlaG9sZGVyIChUT0RPOiBMb2dpYyB0byBmdXp6eSwgc2VlIGxpbmUgMzE2LzMxNylcblx0XHRvLnBsYWNlaG9sZGVyLnVwZGF0ZSh0aGF0LCB0aGF0LnBsYWNlaG9sZGVyKTtcblxuXHR9LFxuXG5cdF9jb250YWN0Q29udGFpbmVyczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaSwgaiwgZGlzdCwgaXRlbVdpdGhMZWFzdERpc3RhbmNlLCBwb3NQcm9wZXJ0eSwgc2l6ZVByb3BlcnR5LCBiYXNlLCBjdXIsIG5lYXJCb3R0b20sIGZsb2F0aW5nLFxuXHRcdFx0aW5uZXJtb3N0Q29udGFpbmVyID0gbnVsbCxcblx0XHRcdGlubmVybW9zdEluZGV4ID0gbnVsbDtcblxuXHRcdC8vIGdldCBpbm5lcm1vc3QgY29udGFpbmVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGl0ZW1cblx0XHRmb3IgKGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0Ly8gbmV2ZXIgY29uc2lkZXIgYSBjb250YWluZXIgdGhhdCdzIGxvY2F0ZWQgd2l0aGluIHRoZSBpdGVtIGl0c2VsZlxuXHRcdFx0aWYoJC5jb250YWlucyh0aGlzLmN1cnJlbnRJdGVtWzBdLCB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuX2ludGVyc2VjdHNXaXRoKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZSkpIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGZvdW5kIGEgY29udGFpbmVyIGFuZCBpdCdzIG1vcmUgXCJpbm5lclwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxuXHRcdFx0XHRpZihpbm5lcm1vc3RDb250YWluZXIgJiYgJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSwgaW5uZXJtb3N0Q29udGFpbmVyLmVsZW1lbnRbMF0pKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbm5lcm1vc3RDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaV07XG5cdFx0XHRcdGlubmVybW9zdEluZGV4ID0gaTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29udGFpbmVyIGRvZXNuJ3QgaW50ZXJzZWN0LiB0cmlnZ2VyIFwib3V0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGlmKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgbm8gaW50ZXJzZWN0aW5nIGNvbnRhaW5lcnMgZm91bmQsIHJldHVyblxuXHRcdGlmKCFpbm5lcm1vc3RDb250YWluZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBtb3ZlIHRoZSBpdGVtIGludG8gdGhlIGNvbnRhaW5lciBpZiBpdCdzIG5vdCB0aGVyZSBhbHJlYWR5XG5cdFx0aWYodGhpcy5jb250YWluZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0aWYgKCF0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly9XaGVuIGVudGVyaW5nIGEgbmV3IGNvbnRhaW5lciwgd2Ugd2lsbCBmaW5kIHRoZSBpdGVtIHdpdGggdGhlIGxlYXN0IGRpc3RhbmNlIGFuZCBhcHBlbmQgb3VyIGl0ZW0gbmVhciBpdFxuXHRcdFx0ZGlzdCA9IDEwMDAwO1xuXHRcdFx0aXRlbVdpdGhMZWFzdERpc3RhbmNlID0gbnVsbDtcblx0XHRcdGZsb2F0aW5nID0gaW5uZXJtb3N0Q29udGFpbmVyLmZsb2F0aW5nIHx8IGlzRmxvYXRpbmcodGhpcy5jdXJyZW50SXRlbSk7XG5cdFx0XHRwb3NQcm9wZXJ0eSA9IGZsb2F0aW5nID8gXCJsZWZ0XCIgOiBcInRvcFwiO1xuXHRcdFx0c2l6ZVByb3BlcnR5ID0gZmxvYXRpbmcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuXHRcdFx0YmFzZSA9IHRoaXMucG9zaXRpb25BYnNbcG9zUHJvcGVydHldICsgdGhpcy5vZmZzZXQuY2xpY2tbcG9zUHJvcGVydHldO1xuXHRcdFx0Zm9yIChqID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRpZighJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnRbMF0sIHRoaXMuaXRlbXNbal0uaXRlbVswXSkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLml0ZW1zW2pdLml0ZW1bMF0gPT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmxvYXRpbmcgJiYgIWlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIHRoaXMuaXRlbXNbal0udG9wLCB0aGlzLml0ZW1zW2pdLmhlaWdodCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXIgPSB0aGlzLml0ZW1zW2pdLml0ZW0ub2Zmc2V0KClbcG9zUHJvcGVydHldO1xuXHRcdFx0XHRuZWFyQm90dG9tID0gZmFsc2U7XG5cdFx0XHRcdGlmKE1hdGguYWJzKGN1ciAtIGJhc2UpID4gTWF0aC5hYnMoY3VyICsgdGhpcy5pdGVtc1tqXVtzaXplUHJvcGVydHldIC0gYmFzZSkpe1xuXHRcdFx0XHRcdG5lYXJCb3R0b20gPSB0cnVlO1xuXHRcdFx0XHRcdGN1ciArPSB0aGlzLml0ZW1zW2pdW3NpemVQcm9wZXJ0eV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihNYXRoLmFicyhjdXIgLSBiYXNlKSA8IGRpc3QpIHtcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5hYnMoY3VyIC0gYmFzZSk7IGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA9IHRoaXMuaXRlbXNbal07XG5cdFx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSBuZWFyQm90dG9tID8gXCJ1cFwiOiBcImRvd25cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL0NoZWNrIGlmIGRyb3BPbkVtcHR5IGlzIGVuYWJsZWRcblx0XHRcdGlmKCFpdGVtV2l0aExlYXN0RGlzdGFuY2UgJiYgIXRoaXMub3B0aW9ucy5kcm9wT25FbXB0eSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuY3VycmVudENvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA/IHRoaXMuX3JlYXJyYW5nZShldmVudCwgaXRlbVdpdGhMZWFzdERpc3RhbmNlLCBudWxsLCB0cnVlKSA6IHRoaXMuX3JlYXJyYW5nZShldmVudCwgbnVsbCwgdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5lbGVtZW50LCB0cnVlKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdO1xuXG5cdFx0XHQvL1VwZGF0ZSB0aGUgcGxhY2Vob2xkZXJcblx0XHRcdHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlci51cGRhdGUodGhpcy5jdXJyZW50Q29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcblxuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xuXHRcdH1cblxuXG5cdH0sXG5cblx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aGVscGVyID0gJC5pc0Z1bmN0aW9uKG8uaGVscGVyKSA/ICQoby5oZWxwZXIuYXBwbHkodGhpcy5lbGVtZW50WzBdLCBbZXZlbnQsIHRoaXMuY3VycmVudEl0ZW1dKSkgOiAoby5oZWxwZXIgPT09IFwiY2xvbmVcIiA/IHRoaXMuY3VycmVudEl0ZW0uY2xvbmUoKSA6IHRoaXMuY3VycmVudEl0ZW0pO1xuXG5cdFx0Ly9BZGQgdGhlIGhlbHBlciB0byB0aGUgRE9NIGlmIHRoYXQgZGlkbid0IGhhcHBlbiBhbHJlYWR5XG5cdFx0aWYoIWhlbHBlci5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGgpIHtcblx0XHRcdCQoby5hcHBlbmRUbyAhPT0gXCJwYXJlbnRcIiA/IG8uYXBwZW5kVG8gOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnBhcmVudE5vZGUpWzBdLmFwcGVuZENoaWxkKGhlbHBlclswXSk7XG5cdFx0fVxuXG5cdFx0aWYoaGVscGVyWzBdID09PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XG5cdFx0XHR0aGlzLl9zdG9yZWRDU1MgPSB7IHdpZHRoOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnN0eWxlLndpZHRoLCBoZWlnaHQ6IHRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUuaGVpZ2h0LCBwb3NpdGlvbjogdGhpcy5jdXJyZW50SXRlbS5jc3MoXCJwb3NpdGlvblwiKSwgdG9wOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcInRvcFwiKSwgbGVmdDogdGhpcy5jdXJyZW50SXRlbS5jc3MoXCJsZWZ0XCIpIH07XG5cdFx0fVxuXG5cdFx0aWYoIWhlbHBlclswXS5zdHlsZS53aWR0aCB8fCBvLmZvcmNlSGVscGVyU2l6ZSkge1xuXHRcdFx0aGVscGVyLndpZHRoKHRoaXMuY3VycmVudEl0ZW0ud2lkdGgoKSk7XG5cdFx0fVxuXHRcdGlmKCFoZWxwZXJbMF0uc3R5bGUuaGVpZ2h0IHx8IG8uZm9yY2VIZWxwZXJTaXplKSB7XG5cdFx0XHRoZWxwZXIuaGVpZ2h0KHRoaXMuY3VycmVudEl0ZW0uaGVpZ2h0KCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWxwZXI7XG5cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdChcIiBcIik7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKFwibGVmdFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChcInJpZ2h0XCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJ0b3BcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoXCJib3R0b21cIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cblx0XHQvL0dldCB0aGUgb2Zmc2V0UGFyZW50IGFuZCBjYWNoZSBpdHMgcG9zaXRpb25cblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGUgZm9sbG93aW5nIGhhcHBlbmVkOlxuXHRcdC8vIDEuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGlzIGFic29sdXRlLCBzbyBpdCdzIHBvc2l0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcblx0XHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0IHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdC8vICAgIHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvLyBUaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpcyBpbmZvcm1hdGlvblxuXHRcdC8vIHdpdGggYW4gdWdseSBJRSBmaXhcblx0XHRpZiggdGhpcy5vZmZzZXRQYXJlbnRbMF0gPT09IGRvY3VtZW50LmJvZHkgfHwgKHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUgJiYgdGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiAmJiAkLnVpLmllKSkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmN1cnJlbnRJdGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1hcmdpbnMgPSB7XG5cdFx0XHRsZWZ0OiAocGFyc2VJbnQodGhpcy5jdXJyZW50SXRlbS5jc3MoXCJtYXJnaW5MZWZ0XCIpLDEwKSB8fCAwKSxcblx0XHRcdHRvcDogKHBhcnNlSW50KHRoaXMuY3VycmVudEl0ZW0uY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNlLCBjbywgb3Zlcixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0aWYoby5jb250YWlubWVudCA9PT0gXCJwYXJlbnRcIikge1xuXHRcdFx0by5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdGlmKG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIiB8fCBvLmNvbnRhaW5tZW50ID09PSBcIndpbmRvd1wiKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LFxuXHRcdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JChvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgPyBkb2N1bWVudCA6IHdpbmRvdykud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0KCQoby5jb250YWlubWVudCA9PT0gXCJkb2N1bWVudFwiID8gZG9jdW1lbnQgOiB3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHRcdGlmKCEoL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLykudGVzdChvLmNvbnRhaW5tZW50KSkge1xuXHRcdFx0Y2UgPSAkKG8uY29udGFpbm1lbnQpWzBdO1xuXHRcdFx0Y28gPSAkKG8uY29udGFpbm1lbnQpLm9mZnNldCgpO1xuXHRcdFx0b3ZlciA9ICgkKGNlKS5jc3MoXCJvdmVyZmxvd1wiKSAhPT0gXCJoaWRkZW5cIik7XG5cblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdGNvLmxlZnQgKyAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCkgfHwgMCkgLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0Y28udG9wICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nVG9wXCIpLDEwKSB8fCAwKSAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRcdGNvLmxlZnQrKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxXaWR0aCxjZS5vZmZzZXRXaWR0aCkgOiBjZS5vZmZzZXRXaWR0aCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHRjby50b3ArKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxIZWlnaHQsY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oZCwgcG9zKSB7XG5cblx0XHRpZighcG9zKSB7XG5cdFx0XHRwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdH1cblx0XHR2YXIgbW9kID0gZCA9PT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxuXHRcdFx0c2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBvcy50b3BcdCtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2QgK1x0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2QgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogKCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkgKiBtb2QpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwb3MubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2RcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpICkgKiBtb2QpXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRwYWdlWCA9IGV2ZW50LnBhZ2VYLFxuXHRcdFx0cGFnZVkgPSBldmVudC5wYWdlWSxcblx0XHRcdHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCwgc2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHQvLyBUaGlzIGlzIGFub3RoZXIgdmVyeSB3ZWlyZCBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGhhcHBlbnMgZm9yIHJlbGF0aXZlIGVsZW1lbnRzOlxuXHRcdC8vIDEuIElmIHRoZSBjc3MgcG9zaXRpb24gaXMgcmVsYXRpdmVcblx0XHQvLyAyLiBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXMgdGhlIGRvY3VtZW50IG9yIHNpbWlsYXIgdG8gdGhlIG9mZnNldCBwYXJlbnRcblx0XHQvLyB3ZSBoYXZlIHRvIHJlZnJlc2ggdGhlIHJlbGF0aXZlIG9mZnNldCBkdXJpbmcgdGhlIHNjcm9sbCBzbyB0aGVyZSBhcmUgbm8ganVtcHNcblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xuXHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUgPSB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxuXHRcdCAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXG5cdFx0ICovXG5cblx0XHRpZih0aGlzLm9yaWdpbmFsUG9zaXRpb24pIHsgLy9JZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcblxuXHRcdFx0aWYodGhpcy5jb250YWlubWVudCkge1xuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCB0aGlzLmNvbnRhaW5tZW50WzBdKSB7XG5cdFx0XHRcdFx0cGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IHRoaXMuY29udGFpbm1lbnRbMV0pIHtcblx0XHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gdGhpcy5jb250YWlubWVudFsyXSkge1xuXHRcdFx0XHRcdHBhZ2VYID0gdGhpcy5jb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiB0aGlzLmNvbnRhaW5tZW50WzNdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uZ3JpZCkge1xuXHRcdFx0XHR0b3AgPSB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKChwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSkgLyBvLmdyaWRbMV0pICogby5ncmlkWzFdO1xuXHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnQgPyAoICh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gdGhpcy5jb250YWlubWVudFsxXSAmJiB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPD0gdGhpcy5jb250YWlubWVudFszXSkgPyB0b3AgOiAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSB0aGlzLmNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdGxlZnQgPSB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdO1xuXHRcdFx0XHRwYWdlWCA9IHRoaXMuY29udGFpbm1lbnQgPyAoIChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSB0aGlzLmNvbnRhaW5tZW50WzBdICYmIGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDw9IHRoaXMuY29udGFpbm1lbnRbMl0pID8gbGVmdCA6ICgobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gdGhpcy5jb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVkgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3BcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgK1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpICkgKSlcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0IC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0XHQtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCkgKSlcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X3JlYXJyYW5nZTogZnVuY3Rpb24oZXZlbnQsIGksIGEsIGhhcmRSZWZyZXNoKSB7XG5cblx0XHRhID8gYVswXS5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKSA6IGkuaXRlbVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnBsYWNlaG9sZGVyWzBdLCAodGhpcy5kaXJlY3Rpb24gPT09IFwiZG93blwiID8gaS5pdGVtWzBdIDogaS5pdGVtWzBdLm5leHRTaWJsaW5nKSk7XG5cblx0XHQvL1ZhcmlvdXMgdGhpbmdzIGRvbmUgaGVyZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZTpcblx0XHQvLyAxLiB3ZSBjcmVhdGUgYSBzZXRUaW1lb3V0LCB0aGF0IGNhbGxzIHJlZnJlc2hQb3NpdGlvbnNcblx0XHQvLyAyLiBvbiB0aGUgaW5zdGFuY2UsIHdlIGhhdmUgYSBjb3VudGVyIHZhcmlhYmxlLCB0aGF0IGdldCdzIGhpZ2hlciBhZnRlciBldmVyeSBhcHBlbmRcblx0XHQvLyAzLiBvbiB0aGUgbG9jYWwgc2NvcGUsIHdlIGNvcHkgdGhlIGNvdW50ZXIgdmFyaWFibGUsIGFuZCBjaGVjayBpbiB0aGUgdGltZW91dCwgaWYgaXQncyBzdGlsbCB0aGUgc2FtZVxuXHRcdC8vIDQuIHRoaXMgbGV0cyBvbmx5IHRoZSBsYXN0IGFkZGl0aW9uIHRvIHRoZSB0aW1lb3V0IHN0YWNrIHRocm91Z2hcblx0XHR0aGlzLmNvdW50ZXIgPSB0aGlzLmNvdW50ZXIgPyArK3RoaXMuY291bnRlciA6IDE7XG5cdFx0dmFyIGNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XG5cblx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdGlmKGNvdW50ZXIgPT09IHRoaXMuY291bnRlcikge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoIWhhcmRSZWZyZXNoKTsgLy9QcmVjb21wdXRlIGFmdGVyIGVhY2ggRE9NIGluc2VydGlvbiwgTk9UIG9uIG1vdXNlbW92ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXG5cdFx0dGhpcy5yZXZlcnRpbmcgPSBmYWxzZTtcblx0XHQvLyBXZSBkZWxheSBhbGwgZXZlbnRzIHRoYXQgaGF2ZSB0byBiZSB0cmlnZ2VyZWQgdG8gYWZ0ZXIgdGhlIHBvaW50IHdoZXJlIHRoZSBwbGFjZWhvbGRlciBoYXMgYmVlbiByZW1vdmVkIGFuZFxuXHRcdC8vIGV2ZXJ5dGhpbmcgZWxzZSBub3JtYWxpemVkIGFnYWluXG5cdFx0dmFyIGksXG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMgPSBbXTtcblxuXHRcdC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxuXHRcdC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzIHJlYXBwZW5kZWQgKHNlZSAjNDA4OClcblx0XHRpZighdGhpcy5fbm9GaW5hbFNvcnQgJiYgdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKS5sZW5ndGgpIHtcblx0XHRcdHRoaXMucGxhY2Vob2xkZXIuYmVmb3JlKHRoaXMuY3VycmVudEl0ZW0pO1xuXHRcdH1cblx0XHR0aGlzLl9ub0ZpbmFsU29ydCA9IG51bGw7XG5cblx0XHRpZih0aGlzLmhlbHBlclswXSA9PT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xuXHRcdFx0Zm9yKGkgaW4gdGhpcy5fc3RvcmVkQ1NTKSB7XG5cdFx0XHRcdGlmKHRoaXMuX3N0b3JlZENTU1tpXSA9PT0gXCJhdXRvXCIgfHwgdGhpcy5fc3RvcmVkQ1NTW2ldID09PSBcInN0YXRpY1wiKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcmVkQ1NTW2ldID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5jc3ModGhpcy5fc3RvcmVkQ1NTKS5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5mcm9tT3V0c2lkZSAmJiAhbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24oZXZlbnQpIHsgdGhpcy5fdHJpZ2dlcihcInJlY2VpdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzLmZyb21PdXRzaWRlKSk7IH0pO1xuXHRcdH1cblx0XHRpZigodGhpcy5mcm9tT3V0c2lkZSB8fCB0aGlzLmRvbVBvc2l0aW9uLnByZXYgIT09IHRoaXMuY3VycmVudEl0ZW0ucHJldigpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIilbMF0gfHwgdGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQgIT09IHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbMF0pICYmICFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbihldmVudCkgeyB0aGlzLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7IH0pOyAvL1RyaWdnZXIgdXBkYXRlIGNhbGxiYWNrIGlmIHRoZSBET00gcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgaXRlbXMgQ29udGFpbmVyIGhhcyBDaGFuZ2VkIGFuZCB0cmlnZ2VyIGFwcHJvcHJpYXRlXG5cdFx0Ly8gZXZlbnRzLlxuXHRcdGlmICh0aGlzICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcblx0XHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKGZ1bmN0aW9uKGV2ZW50KSB7IHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTsgfSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwicmVjZWl2ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfTsgIH0pLmNhbGwodGhpcywgdGhpcy5jdXJyZW50Q29udGFpbmVyKSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyAgfTsgfSkuY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdC8vUG9zdCBldmVudHMgdG8gY29udGFpbmVyc1xuXHRcdGZvciAoaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCgoZnVuY3Rpb24oYykgeyByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHsgYy5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7IH07ICB9KS5jYWxsKHRoaXMsIHRoaXMuY29udGFpbmVyc1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7IGMuX3RyaWdnZXIoXCJvdXRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7IH07ICB9KS5jYWxsKHRoaXMsIHRoaXMuY29udGFpbmVyc1tpXSkpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9EbyB3aGF0IHdhcyBvcmlnaW5hbGx5IGluIHBsdWdpbnNcblx0XHRpZiAoIHRoaXMuc3RvcmVkQ3Vyc29yICkge1xuXHRcdFx0dGhpcy5kb2N1bWVudC5maW5kKCBcImJvZHlcIiApLmNzcyggXCJjdXJzb3JcIiwgdGhpcy5zdG9yZWRDdXJzb3IgKTtcblx0XHRcdHRoaXMuc3RvcmVkU3R5bGVzaGVldC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYodGhpcy5fc3RvcmVkT3BhY2l0eSkge1xuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiLCB0aGlzLl9zdG9yZWRPcGFjaXR5KTtcblx0XHR9XG5cdFx0aWYodGhpcy5fc3RvcmVkWkluZGV4KSB7XG5cdFx0XHR0aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIiwgdGhpcy5fc3RvcmVkWkluZGV4ID09PSBcImF1dG9cIiA/IFwiXCIgOiB0aGlzLl9zdG9yZWRaSW5kZXgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRpZih0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwpIHtcblx0XHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoXCJiZWZvcmVTdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cdFx0XHRcdGZvciAoaT0wOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0XHR9IC8vVHJpZ2dlciBhbGwgZGVsYXllZCBldmVudHNcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mcm9tT3V0c2lkZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKFwiYmVmb3JlU3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdH1cblxuXHRcdC8vJCh0aGlzLnBsYWNlaG9sZGVyWzBdKS5yZW1vdmUoKTsgd291bGQgaGF2ZSBiZWVuIHRoZSBqUXVlcnkgd2F5IC0gdW5mb3J0dW5hdGVseSwgaXQgdW5iaW5kcyBBTEwgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUhXG5cdFx0dGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pO1xuXG5cdFx0aWYodGhpcy5oZWxwZXJbMF0gIT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcblx0XHRcdHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR0aGlzLmhlbHBlciA9IG51bGw7XG5cblx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0Zm9yIChpPTA7IGkgPCBkZWxheWVkVHJpZ2dlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0fSAvL1RyaWdnZXIgYWxsIGRlbGF5ZWQgZXZlbnRzXG5cdFx0XHR0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZnJvbU91dHNpZGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLmNhbmNlbCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdWlIYXNoOiBmdW5jdGlvbihfaW5zdCkge1xuXHRcdHZhciBpbnN0ID0gX2luc3QgfHwgdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVscGVyOiBpbnN0LmhlbHBlcixcblx0XHRcdHBsYWNlaG9sZGVyOiBpbnN0LnBsYWNlaG9sZGVyIHx8ICQoW10pLFxuXHRcdFx0cG9zaXRpb246IGluc3QucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiBpbnN0Lm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IGluc3QucG9zaXRpb25BYnMsXG5cdFx0XHRpdGVtOiBpbnN0LmN1cnJlbnRJdGVtLFxuXHRcdFx0c2VuZGVyOiBfaW5zdCA/IF9pbnN0LmVsZW1lbnQgOiBudWxsXG5cdFx0fTtcblx0fVxuXG59KTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCQsIHVuZGVmaW5lZCkge1xuXG52YXIgZGF0YVNwYWNlID0gXCJ1aS1lZmZlY3RzLVwiO1xuXG4kLmVmZmVjdHMgPSB7XG5cdGVmZmVjdDoge31cbn07XG5cbi8qIVxuICogalF1ZXJ5IENvbG9yIEFuaW1hdGlvbnMgdjIuMS4yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1jb2xvclxuICpcbiAqIENvcHlyaWdodCAyMDEzIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiBXZWQgSmFuIDE2IDA4OjQ3OjA5IDIwMTMgLTA2MDBcbiAqL1xuKGZ1bmN0aW9uKCBqUXVlcnksIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgc3RlcEhvb2tzID0gXCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyQm90dG9tQ29sb3IgYm9yZGVyTGVmdENvbG9yIGJvcmRlclJpZ2h0Q29sb3IgYm9yZGVyVG9wQ29sb3IgY29sb3IgY29sdW1uUnVsZUNvbG9yIG91dGxpbmVDb2xvciB0ZXh0RGVjb3JhdGlvbkNvbG9yIHRleHRFbXBoYXNpc0NvbG9yXCIsXG5cblx0Ly8gcGx1c2VxdWFscyB0ZXN0IGZvciArPSAxMDAgLT0gMTAwXG5cdHJwbHVzZXF1YWxzID0gL14oW1xcLStdKT1cXHMqKFxcZCtcXC4/XFxkKikvLFxuXHQvLyBhIHNldCBvZiBSRSdzIHRoYXQgY2FuIG1hdGNoIHN0cmluZ3MgYW5kIGdlbmVyYXRlIGNvbG9yIHR1cGxlcy5cblx0c3RyaW5nUGFyc2VycyA9IFt7XG5cdFx0XHRyZTogL3JnYmE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDIgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0cmU6IC9yZ2JhP1xcKFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqKD86LFxccyooXFxkPyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDEgXSAqIDIuNTUsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdICogMi41NSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0gKiAyLjU1LFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDQgXVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdC8vIHRoaXMgcmVnZXggaWdub3JlcyBBLUYgYmVjYXVzZSBpdCdzIGNvbXBhcmVkIGFnYWluc3QgYW4gYWxyZWFkeSBsb3dlcmNhc2VkIHN0cmluZ1xuXHRcdFx0cmU6IC8jKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMSBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAyIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDMgXSwgMTYgKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdC8vIHRoaXMgcmVnZXggaWdub3JlcyBBLUYgYmVjYXVzZSBpdCdzIGNvbXBhcmVkIGFnYWluc3QgYW4gYWxyZWFkeSBsb3dlcmNhc2VkIHN0cmluZ1xuXHRcdFx0cmU6IC8jKFthLWYwLTldKShbYS1mMC05XSkoW2EtZjAtOV0pLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMSBdICsgZXhlY1Jlc3VsdFsgMSBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAyIF0gKyBleGVjUmVzdWx0WyAyIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDMgXSArIGV4ZWNSZXN1bHRbIDMgXSwgMTYgKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdHJlOiAvaHNsYT9cXChcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKig/OixcXHMqKFxcZD8oPzpcXC5cXGQrKT8pXFxzKik/XFwpLyxcblx0XHRcdHNwYWNlOiBcImhzbGFcIixcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAxIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdIC8gMTAwLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSAvIDEwMCxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyA0IF1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9XSxcblxuXHQvLyBqUXVlcnkuQ29sb3IoIClcblx0Y29sb3IgPSBqUXVlcnkuQ29sb3IgPSBmdW5jdGlvbiggY29sb3IsIGdyZWVuLCBibHVlLCBhbHBoYSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5Db2xvci5mbi5wYXJzZSggY29sb3IsIGdyZWVuLCBibHVlLCBhbHBoYSApO1xuXHR9LFxuXHRzcGFjZXMgPSB7XG5cdFx0cmdiYToge1xuXHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0cmVkOiB7XG5cdFx0XHRcdFx0aWR4OiAwLFxuXHRcdFx0XHRcdHR5cGU6IFwiYnl0ZVwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdyZWVuOiB7XG5cdFx0XHRcdFx0aWR4OiAxLFxuXHRcdFx0XHRcdHR5cGU6IFwiYnl0ZVwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJsdWU6IHtcblx0XHRcdFx0XHRpZHg6IDIsXG5cdFx0XHRcdFx0dHlwZTogXCJieXRlXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRoc2xhOiB7XG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHRodWU6IHtcblx0XHRcdFx0XHRpZHg6IDAsXG5cdFx0XHRcdFx0dHlwZTogXCJkZWdyZWVzXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0c2F0dXJhdGlvbjoge1xuXHRcdFx0XHRcdGlkeDogMSxcblx0XHRcdFx0XHR0eXBlOiBcInBlcmNlbnRcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsaWdodG5lc3M6IHtcblx0XHRcdFx0XHRpZHg6IDIsXG5cdFx0XHRcdFx0dHlwZTogXCJwZXJjZW50XCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0cHJvcFR5cGVzID0ge1xuXHRcdFwiYnl0ZVwiOiB7XG5cdFx0XHRmbG9vcjogdHJ1ZSxcblx0XHRcdG1heDogMjU1XG5cdFx0fSxcblx0XHRcInBlcmNlbnRcIjoge1xuXHRcdFx0bWF4OiAxXG5cdFx0fSxcblx0XHRcImRlZ3JlZXNcIjoge1xuXHRcdFx0bW9kOiAzNjAsXG5cdFx0XHRmbG9vcjogdHJ1ZVxuXHRcdH1cblx0fSxcblx0c3VwcG9ydCA9IGNvbG9yLnN1cHBvcnQgPSB7fSxcblxuXHQvLyBlbGVtZW50IGZvciBzdXBwb3J0IHRlc3RzXG5cdHN1cHBvcnRFbGVtID0galF1ZXJ5KCBcIjxwPlwiIClbIDAgXSxcblxuXHQvLyBjb2xvcnMgPSBqUXVlcnkuQ29sb3IubmFtZXNcblx0Y29sb3JzLFxuXG5cdC8vIGxvY2FsIGFsaWFzZXMgb2YgZnVuY3Rpb25zIGNhbGxlZCBvZnRlblxuXHRlYWNoID0galF1ZXJ5LmVhY2g7XG5cbi8vIGRldGVybWluZSByZ2JhIHN1cHBvcnQgaW1tZWRpYXRlbHlcbnN1cHBvcnRFbGVtLnN0eWxlLmNzc1RleHQgPSBcImJhY2tncm91bmQtY29sb3I6cmdiYSgxLDEsMSwuNSlcIjtcbnN1cHBvcnQucmdiYSA9IHN1cHBvcnRFbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvci5pbmRleE9mKCBcInJnYmFcIiApID4gLTE7XG5cbi8vIGRlZmluZSBjYWNoZSBuYW1lIGFuZCBhbHBoYSBwcm9wZXJ0aWVzXG4vLyBmb3IgcmdiYSBhbmQgaHNsYSBzcGFjZXNcbmVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdHNwYWNlLmNhY2hlID0gXCJfXCIgKyBzcGFjZU5hbWU7XG5cdHNwYWNlLnByb3BzLmFscGhhID0ge1xuXHRcdGlkeDogMyxcblx0XHR0eXBlOiBcInBlcmNlbnRcIixcblx0XHRkZWY6IDFcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiBjbGFtcCggdmFsdWUsIHByb3AsIGFsbG93RW1wdHkgKSB7XG5cdHZhciB0eXBlID0gcHJvcFR5cGVzWyBwcm9wLnR5cGUgXSB8fCB7fTtcblxuXHRpZiAoIHZhbHVlID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIChhbGxvd0VtcHR5IHx8ICFwcm9wLmRlZikgPyBudWxsIDogcHJvcC5kZWY7XG5cdH1cblxuXHQvLyB+fiBpcyBhbiBzaG9ydCB3YXkgb2YgZG9pbmcgZmxvb3IgZm9yIHBvc2l0aXZlIG51bWJlcnNcblx0dmFsdWUgPSB0eXBlLmZsb29yID8gfn52YWx1ZSA6IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cblx0Ly8gSUUgd2lsbCBwYXNzIGluIGVtcHR5IHN0cmluZ3MgYXMgdmFsdWUgZm9yIGFscGhhLFxuXHQvLyB3aGljaCB3aWxsIGhpdCB0aGlzIGNhc2Vcblx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gcHJvcC5kZWY7XG5cdH1cblxuXHRpZiAoIHR5cGUubW9kICkge1xuXHRcdC8vIHdlIGFkZCBtb2QgYmVmb3JlIG1vZGRpbmcgdG8gbWFrZSBzdXJlIHRoYXQgbmVnYXRpdmVzIHZhbHVlc1xuXHRcdC8vIGdldCBjb252ZXJ0ZWQgcHJvcGVybHk6IC0xMCAtPiAzNTBcblx0XHRyZXR1cm4gKHZhbHVlICsgdHlwZS5tb2QpICUgdHlwZS5tb2Q7XG5cdH1cblxuXHQvLyBmb3Igbm93IGFsbCBwcm9wZXJ0eSB0eXBlcyB3aXRob3V0IG1vZCBoYXZlIG1pbiBhbmQgbWF4XG5cdHJldHVybiAwID4gdmFsdWUgPyAwIDogdHlwZS5tYXggPCB2YWx1ZSA/IHR5cGUubWF4IDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1BhcnNlKCBzdHJpbmcgKSB7XG5cdHZhciBpbnN0ID0gY29sb3IoKSxcblx0XHRyZ2JhID0gaW5zdC5fcmdiYSA9IFtdO1xuXG5cdHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG5cdGVhY2goIHN0cmluZ1BhcnNlcnMsIGZ1bmN0aW9uKCBpLCBwYXJzZXIgKSB7XG5cdFx0dmFyIHBhcnNlZCxcblx0XHRcdG1hdGNoID0gcGFyc2VyLnJlLmV4ZWMoIHN0cmluZyApLFxuXHRcdFx0dmFsdWVzID0gbWF0Y2ggJiYgcGFyc2VyLnBhcnNlKCBtYXRjaCApLFxuXHRcdFx0c3BhY2VOYW1lID0gcGFyc2VyLnNwYWNlIHx8IFwicmdiYVwiO1xuXG5cdFx0aWYgKCB2YWx1ZXMgKSB7XG5cdFx0XHRwYXJzZWQgPSBpbnN0WyBzcGFjZU5hbWUgXSggdmFsdWVzICk7XG5cblx0XHRcdC8vIGlmIHRoaXMgd2FzIGFuIHJnYmEgcGFyc2UgdGhlIGFzc2lnbm1lbnQgbWlnaHQgaGFwcGVuIHR3aWNlXG5cdFx0XHQvLyBvaCB3ZWxsLi4uLlxuXHRcdFx0aW5zdFsgc3BhY2VzWyBzcGFjZU5hbWUgXS5jYWNoZSBdID0gcGFyc2VkWyBzcGFjZXNbIHNwYWNlTmFtZSBdLmNhY2hlIF07XG5cdFx0XHRyZ2JhID0gaW5zdC5fcmdiYSA9IHBhcnNlZC5fcmdiYTtcblxuXHRcdFx0Ly8gZXhpdCBlYWNoKCBzdHJpbmdQYXJzZXJzICkgaGVyZSBiZWNhdXNlIHdlIG1hdGNoZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEZvdW5kIGEgc3RyaW5nUGFyc2VyIHRoYXQgaGFuZGxlZCBpdFxuXHRpZiAoIHJnYmEubGVuZ3RoICkge1xuXG5cdFx0Ly8gaWYgdGhpcyBjYW1lIGZyb20gYSBwYXJzZWQgc3RyaW5nLCBmb3JjZSBcInRyYW5zcGFyZW50XCIgd2hlbiBhbHBoYSBpcyAwXG5cdFx0Ly8gY2hyb21lLCAoYW5kIG1heWJlIG90aGVycykgcmV0dXJuIFwidHJhbnNwYXJlbnRcIiBhcyByZ2JhKDAsMCwwLDApXG5cdFx0aWYgKCByZ2JhLmpvaW4oKSA9PT0gXCIwLDAsMCwwXCIgKSB7XG5cdFx0XHRqUXVlcnkuZXh0ZW5kKCByZ2JhLCBjb2xvcnMudHJhbnNwYXJlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH1cblxuXHQvLyBuYW1lZCBjb2xvcnNcblx0cmV0dXJuIGNvbG9yc1sgc3RyaW5nIF07XG59XG5cbmNvbG9yLmZuID0galF1ZXJ5LmV4dGVuZCggY29sb3IucHJvdG90eXBlLCB7XG5cdHBhcnNlOiBmdW5jdGlvbiggcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgKSB7XG5cdFx0aWYgKCByZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX3JnYmEgPSBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHJlZC5qcXVlcnkgfHwgcmVkLm5vZGVUeXBlICkge1xuXHRcdFx0cmVkID0galF1ZXJ5KCByZWQgKS5jc3MoIGdyZWVuICk7XG5cdFx0XHRncmVlbiA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCA9IHRoaXMsXG5cdFx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIHJlZCApLFxuXHRcdFx0cmdiYSA9IHRoaXMuX3JnYmEgPSBbXTtcblxuXHRcdC8vIG1vcmUgdGhhbiAxIGFyZ3VtZW50IHNwZWNpZmllZCAtIGFzc3VtZSAoIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIClcblx0XHRpZiAoIGdyZWVuICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZWQgPSBbIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIF07XG5cdFx0XHR0eXBlID0gXCJhcnJheVwiO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlKCBzdHJpbmdQYXJzZSggcmVkICkgfHwgY29sb3JzLl9kZWZhdWx0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSBcImFycmF5XCIgKSB7XG5cdFx0XHRlYWNoKCBzcGFjZXMucmdiYS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHRcdFx0cmdiYVsgcHJvcC5pZHggXSA9IGNsYW1wKCByZWRbIHByb3AuaWR4IF0sIHByb3AgKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0aWYgKCByZWQgaW5zdGFuY2VvZiBjb2xvciApIHtcblx0XHRcdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0XHRcdFx0XHRpZiAoIHJlZFsgc3BhY2UuY2FjaGUgXSApIHtcblx0XHRcdFx0XHRcdGluc3RbIHNwYWNlLmNhY2hlIF0gPSByZWRbIHNwYWNlLmNhY2hlIF0uc2xpY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUgPSBzcGFjZS5jYWNoZTtcblx0XHRcdFx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNhY2hlIGRvZXNuJ3QgZXhpc3QsIGFuZCB3ZSBrbm93IGhvdyB0byBjb252ZXJ0XG5cdFx0XHRcdFx0XHRpZiAoICFpbnN0WyBjYWNoZSBdICYmIHNwYWNlLnRvICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSB2YWx1ZSB3YXMgbnVsbCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBrZXkgd2FzIGFscGhhLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQgZWl0aGVyXG5cdFx0XHRcdFx0XHRcdGlmICgga2V5ID09PSBcImFscGhhXCIgfHwgcmVkWyBrZXkgXSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdID0gc3BhY2UudG8oIGluc3QuX3JnYmEgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGFsbG93IG51bGxzIGZvciBBTEwgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdC8vIGNhbGwgY2xhbXAgd2l0aCBhbHdheXNBbGxvd0VtcHR5XG5cdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdWyBwcm9wLmlkeCBdID0gY2xhbXAoIHJlZFsga2V5IF0sIHByb3AsIHRydWUgKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIGV2ZXJ5dGhpbmcgZGVmaW5lZCBidXQgYWxwaGE/XG5cdFx0XHRcdFx0aWYgKCBpbnN0WyBjYWNoZSBdICYmIGpRdWVyeS5pbkFycmF5KCBudWxsLCBpbnN0WyBjYWNoZSBdLnNsaWNlKCAwLCAzICkgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHQvLyB1c2UgdGhlIGRlZmF1bHQgb2YgMVxuXHRcdFx0XHRcdFx0aW5zdFsgY2FjaGUgXVsgMyBdID0gMTtcblx0XHRcdFx0XHRcdGlmICggc3BhY2UuZnJvbSApIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5fcmdiYSA9IHNwYWNlLmZyb20oIGluc3RbIGNhY2hlIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXHRpczogZnVuY3Rpb24oIGNvbXBhcmUgKSB7XG5cdFx0dmFyIGlzID0gY29sb3IoIGNvbXBhcmUgKSxcblx0XHRcdHNhbWUgPSB0cnVlLFxuXHRcdFx0aW5zdCA9IHRoaXM7XG5cblx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBfLCBzcGFjZSApIHtcblx0XHRcdHZhciBsb2NhbENhY2hlLFxuXHRcdFx0XHRpc0NhY2hlID0gaXNbIHNwYWNlLmNhY2hlIF07XG5cdFx0XHRpZiAoaXNDYWNoZSkge1xuXHRcdFx0XHRsb2NhbENhY2hlID0gaW5zdFsgc3BhY2UuY2FjaGUgXSB8fCBzcGFjZS50byAmJiBzcGFjZS50byggaW5zdC5fcmdiYSApIHx8IFtdO1xuXHRcdFx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIF8sIHByb3AgKSB7XG5cdFx0XHRcdFx0aWYgKCBpc0NhY2hlWyBwcm9wLmlkeCBdICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzYW1lID0gKCBpc0NhY2hlWyBwcm9wLmlkeCBdID09PSBsb2NhbENhY2hlWyBwcm9wLmlkeCBdICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2FtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNhbWU7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNhbWU7XG5cdH0sXG5cdF9zcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVzZWQgPSBbXSxcblx0XHRcdGluc3QgPSB0aGlzO1xuXHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdFx0XHRpZiAoIGluc3RbIHNwYWNlLmNhY2hlIF0gKSB7XG5cdFx0XHRcdHVzZWQucHVzaCggc3BhY2VOYW1lICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHVzZWQucG9wKCk7XG5cdH0sXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKCBvdGhlciwgZGlzdGFuY2UgKSB7XG5cdFx0dmFyIGVuZCA9IGNvbG9yKCBvdGhlciApLFxuXHRcdFx0c3BhY2VOYW1lID0gZW5kLl9zcGFjZSgpLFxuXHRcdFx0c3BhY2UgPSBzcGFjZXNbIHNwYWNlTmFtZSBdLFxuXHRcdFx0c3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKCBcInRyYW5zcGFyZW50XCIgKSA6IHRoaXMsXG5cdFx0XHRzdGFydCA9IHN0YXJ0Q29sb3JbIHNwYWNlLmNhY2hlIF0gfHwgc3BhY2UudG8oIHN0YXJ0Q29sb3IuX3JnYmEgKSxcblx0XHRcdHJlc3VsdCA9IHN0YXJ0LnNsaWNlKCk7XG5cblx0XHRlbmQgPSBlbmRbIHNwYWNlLmNhY2hlIF07XG5cdFx0ZWFjaCggc3BhY2UucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBwcm9wLmlkeCxcblx0XHRcdFx0c3RhcnRWYWx1ZSA9IHN0YXJ0WyBpbmRleCBdLFxuXHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFsgaW5kZXggXSxcblx0XHRcdFx0dHlwZSA9IHByb3BUeXBlc1sgcHJvcC50eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGlmIG51bGwsIGRvbid0IG92ZXJyaWRlIHN0YXJ0IHZhbHVlXG5cdFx0XHRpZiAoIGVuZFZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBudWxsIC0gdXNlIGVuZFxuXHRcdFx0aWYgKCBzdGFydFZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXN1bHRbIGluZGV4IF0gPSBlbmRWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdHlwZS5tb2QgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUgPiB0eXBlLm1vZCAvIDIgKSB7XG5cdFx0XHRcdFx0XHRzdGFydFZhbHVlICs9IHR5cGUubW9kO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXJ0VmFsdWUgLSBlbmRWYWx1ZSA+IHR5cGUubW9kIC8gMiApIHtcblx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgLT0gdHlwZS5tb2Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdFsgaW5kZXggXSA9IGNsYW1wKCAoIGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSApICogZGlzdGFuY2UgKyBzdGFydFZhbHVlLCBwcm9wICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXNbIHNwYWNlTmFtZSBdKCByZXN1bHQgKTtcblx0fSxcblx0YmxlbmQ6IGZ1bmN0aW9uKCBvcGFxdWUgKSB7XG5cdFx0Ly8gaWYgd2UgYXJlIGFscmVhZHkgb3BhcXVlIC0gcmV0dXJuIG91cnNlbGZcblx0XHRpZiAoIHRoaXMuX3JnYmFbIDMgXSA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhciByZ2IgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG5cdFx0XHRhID0gcmdiLnBvcCgpLFxuXHRcdFx0YmxlbmQgPSBjb2xvciggb3BhcXVlICkuX3JnYmE7XG5cblx0XHRyZXR1cm4gY29sb3IoIGpRdWVyeS5tYXAoIHJnYiwgZnVuY3Rpb24oIHYsIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCAxIC0gYSApICogYmxlbmRbIGkgXSArIGEgKiB2O1xuXHRcdH0pKTtcblx0fSxcblx0dG9SZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlZml4ID0gXCJyZ2JhKFwiLFxuXHRcdFx0cmdiYSA9IGpRdWVyeS5tYXAoIHRoaXMuX3JnYmEsIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0XHRyZXR1cm4gdiA9PSBudWxsID8gKCBpID4gMiA/IDEgOiAwICkgOiB2O1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIHJnYmFbIDMgXSA9PT0gMSApIHtcblx0XHRcdHJnYmEucG9wKCk7XG5cdFx0XHRwcmVmaXggPSBcInJnYihcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlZml4ICsgcmdiYS5qb2luKCkgKyBcIilcIjtcblx0fSxcblx0dG9Ic2xhU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlZml4ID0gXCJoc2xhKFwiLFxuXHRcdFx0aHNsYSA9IGpRdWVyeS5tYXAoIHRoaXMuaHNsYSgpLCBmdW5jdGlvbiggdiwgaSApIHtcblx0XHRcdFx0aWYgKCB2ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0diA9IGkgPiAyID8gMSA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjYXRjaCAxIGFuZCAyXG5cdFx0XHRcdGlmICggaSAmJiBpIDwgMyApIHtcblx0XHRcdFx0XHR2ID0gTWF0aC5yb3VuZCggdiAqIDEwMCApICsgXCIlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggaHNsYVsgMyBdID09PSAxICkge1xuXHRcdFx0aHNsYS5wb3AoKTtcblx0XHRcdHByZWZpeCA9IFwiaHNsKFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJlZml4ICsgaHNsYS5qb2luKCkgKyBcIilcIjtcblx0fSxcblx0dG9IZXhTdHJpbmc6IGZ1bmN0aW9uKCBpbmNsdWRlQWxwaGEgKSB7XG5cdFx0dmFyIHJnYmEgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG5cdFx0XHRhbHBoYSA9IHJnYmEucG9wKCk7XG5cblx0XHRpZiAoIGluY2x1ZGVBbHBoYSApIHtcblx0XHRcdHJnYmEucHVzaCggfn4oIGFscGhhICogMjU1ICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gXCIjXCIgKyBqUXVlcnkubWFwKCByZ2JhLCBmdW5jdGlvbiggdiApIHtcblxuXHRcdFx0Ly8gZGVmYXVsdCB0byAwIHdoZW4gbnVsbHMgZXhpc3Rcblx0XHRcdHYgPSAoIHYgfHwgMCApLnRvU3RyaW5nKCAxNiApO1xuXHRcdFx0cmV0dXJuIHYubGVuZ3RoID09PSAxID8gXCIwXCIgKyB2IDogdjtcblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9LFxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JnYmFbIDMgXSA9PT0gMCA/IFwidHJhbnNwYXJlbnRcIiA6IHRoaXMudG9SZ2JhU3RyaW5nKCk7XG5cdH1cbn0pO1xuY29sb3IuZm4ucGFyc2UucHJvdG90eXBlID0gY29sb3IuZm47XG5cbi8vIGhzbGEgY29udmVyc2lvbnMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9tYWFzaGFhY2svc291cmNlL2Jyb3dzZS9wYWNrYWdlcy9ncmFwaGljcy90cnVuay9zcmMvZ3JhcGhpY3MvY29sb3JzL0hVRTJSR0IuYXM/cj01MDIxXG5cbmZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIGggKSB7XG5cdGggPSAoIGggKyAxICkgJSAxO1xuXHRpZiAoIGggKiA2IDwgMSApIHtcblx0XHRyZXR1cm4gcCArIChxIC0gcCkgKiBoICogNjtcblx0fVxuXHRpZiAoIGggKiAyIDwgMSkge1xuXHRcdHJldHVybiBxO1xuXHR9XG5cdGlmICggaCAqIDMgPCAyICkge1xuXHRcdHJldHVybiBwICsgKHEgLSBwKSAqICgoMi8zKSAtIGgpICogNjtcblx0fVxuXHRyZXR1cm4gcDtcbn1cblxuc3BhY2VzLmhzbGEudG8gPSBmdW5jdGlvbiAoIHJnYmEgKSB7XG5cdGlmICggcmdiYVsgMCBdID09IG51bGwgfHwgcmdiYVsgMSBdID09IG51bGwgfHwgcmdiYVsgMiBdID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFsgbnVsbCwgbnVsbCwgbnVsbCwgcmdiYVsgMyBdIF07XG5cdH1cblx0dmFyIHIgPSByZ2JhWyAwIF0gLyAyNTUsXG5cdFx0ZyA9IHJnYmFbIDEgXSAvIDI1NSxcblx0XHRiID0gcmdiYVsgMiBdIC8gMjU1LFxuXHRcdGEgPSByZ2JhWyAzIF0sXG5cdFx0bWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKSxcblx0XHRtaW4gPSBNYXRoLm1pbiggciwgZywgYiApLFxuXHRcdGRpZmYgPSBtYXggLSBtaW4sXG5cdFx0YWRkID0gbWF4ICsgbWluLFxuXHRcdGwgPSBhZGQgKiAwLjUsXG5cdFx0aCwgcztcblxuXHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKCByID09PSBtYXggKSB7XG5cdFx0aCA9ICggNjAgKiAoIGcgLSBiICkgLyBkaWZmICkgKyAzNjA7XG5cdH0gZWxzZSBpZiAoIGcgPT09IG1heCApIHtcblx0XHRoID0gKCA2MCAqICggYiAtIHIgKSAvIGRpZmYgKSArIDEyMDtcblx0fSBlbHNlIHtcblx0XHRoID0gKCA2MCAqICggciAtIGcgKSAvIGRpZmYgKSArIDI0MDtcblx0fVxuXG5cdC8vIGNocm9tYSAoZGlmZikgPT0gMCBtZWFucyBncmV5c2NhbGUgd2hpY2gsIGJ5IGRlZmluaXRpb24sIHNhdHVyYXRpb24gPSAwJVxuXHQvLyBvdGhlcndpc2UsIHNhdHVyYXRpb24gaXMgYmFzZWQgb24gdGhlIHJhdGlvIG9mIGNocm9tYSAoZGlmZikgdG8gbGlnaHRuZXNzIChhZGQpXG5cdGlmICggZGlmZiA9PT0gMCApIHtcblx0XHRzID0gMDtcblx0fSBlbHNlIGlmICggbCA8PSAwLjUgKSB7XG5cdFx0cyA9IGRpZmYgLyBhZGQ7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRpZmYgLyAoIDIgLSBhZGQgKTtcblx0fVxuXHRyZXR1cm4gWyBNYXRoLnJvdW5kKGgpICUgMzYwLCBzLCBsLCBhID09IG51bGwgPyAxIDogYSBdO1xufTtcblxuc3BhY2VzLmhzbGEuZnJvbSA9IGZ1bmN0aW9uICggaHNsYSApIHtcblx0aWYgKCBoc2xhWyAwIF0gPT0gbnVsbCB8fCBoc2xhWyAxIF0gPT0gbnVsbCB8fCBoc2xhWyAyIF0gPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCBoc2xhWyAzIF0gXTtcblx0fVxuXHR2YXIgaCA9IGhzbGFbIDAgXSAvIDM2MCxcblx0XHRzID0gaHNsYVsgMSBdLFxuXHRcdGwgPSBoc2xhWyAyIF0sXG5cdFx0YSA9IGhzbGFbIDMgXSxcblx0XHRxID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSBsICogcyxcblx0XHRwID0gMiAqIGwgLSBxO1xuXG5cdHJldHVybiBbXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCArICggMSAvIDMgKSApICogMjU1ICksXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCApICogMjU1ICksXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCAtICggMSAvIDMgKSApICogMjU1ICksXG5cdFx0YVxuXHRdO1xufTtcblxuXG5lYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHR2YXIgcHJvcHMgPSBzcGFjZS5wcm9wcyxcblx0XHRjYWNoZSA9IHNwYWNlLmNhY2hlLFxuXHRcdHRvID0gc3BhY2UudG8sXG5cdFx0ZnJvbSA9IHNwYWNlLmZyb207XG5cblx0Ly8gbWFrZXMgcmdiYSgpIGFuZCBoc2xhKClcblx0Y29sb3IuZm5bIHNwYWNlTmFtZSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYSBjYWNoZSBmb3IgdGhpcyBzcGFjZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0aWYgKCB0byAmJiAhdGhpc1sgY2FjaGUgXSApIHtcblx0XHRcdHRoaXNbIGNhY2hlIF0gPSB0byggdGhpcy5fcmdiYSApO1xuXHRcdH1cblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGUgXS5zbGljZSgpO1xuXHRcdH1cblxuXHRcdHZhciByZXQsXG5cdFx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG5cdFx0XHRhcnIgPSAoIHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm9iamVjdFwiICkgPyB2YWx1ZSA6IGFyZ3VtZW50cyxcblx0XHRcdGxvY2FsID0gdGhpc1sgY2FjaGUgXS5zbGljZSgpO1xuXG5cdFx0ZWFjaCggcHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHR2YXIgdmFsID0gYXJyWyB0eXBlID09PSBcIm9iamVjdFwiID8ga2V5IDogcHJvcC5pZHggXTtcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IGxvY2FsWyBwcm9wLmlkeCBdO1xuXHRcdFx0fVxuXHRcdFx0bG9jYWxbIHByb3AuaWR4IF0gPSBjbGFtcCggdmFsLCBwcm9wICk7XG5cdFx0fSk7XG5cblx0XHRpZiAoIGZyb20gKSB7XG5cdFx0XHRyZXQgPSBjb2xvciggZnJvbSggbG9jYWwgKSApO1xuXHRcdFx0cmV0WyBjYWNoZSBdID0gbG9jYWw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY29sb3IoIGxvY2FsICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIG1ha2VzIHJlZCgpIGdyZWVuKCkgYmx1ZSgpIGFscGhhKCkgaHVlKCkgc2F0dXJhdGlvbigpIGxpZ2h0bmVzcygpXG5cdGVhY2goIHByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXHRcdC8vIGFscGhhIGlzIGluY2x1ZGVkIGluIG1vcmUgdGhhbiBvbmUgc3BhY2Vcblx0XHRpZiAoIGNvbG9yLmZuWyBrZXkgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29sb3IuZm5bIGtleSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG5cdFx0XHRcdGZuID0gKCBrZXkgPT09IFwiYWxwaGFcIiA/ICggdGhpcy5faHNsYSA/IFwiaHNsYVwiIDogXCJyZ2JhXCIgKSA6IHNwYWNlTmFtZSApLFxuXHRcdFx0XHRsb2NhbCA9IHRoaXNbIGZuIF0oKSxcblx0XHRcdFx0Y3VyID0gbG9jYWxbIHByb3AuaWR4IF0sXG5cdFx0XHRcdG1hdGNoO1xuXG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuY2FsbCggdGhpcywgY3VyICk7XG5cdFx0XHRcdHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgJiYgcHJvcC5lbXB0eSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZ0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRtYXRjaCA9IHJwbHVzZXF1YWxzLmV4ZWMoIHZhbHVlICk7XG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjdXIgKyBwYXJzZUZsb2F0KCBtYXRjaFsgMiBdICkgKiAoIG1hdGNoWyAxIF0gPT09IFwiK1wiID8gMSA6IC0xICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxvY2FsWyBwcm9wLmlkeCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpc1sgZm4gXSggbG9jYWwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG4vLyBhZGQgY3NzSG9vayBhbmQgLmZ4LnN0ZXAgZnVuY3Rpb24gZm9yIGVhY2ggbmFtZWQgaG9vay5cbi8vIGFjY2VwdCBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgcHJvcGVydGllc1xuY29sb3IuaG9vayA9IGZ1bmN0aW9uKCBob29rICkge1xuXHR2YXIgaG9va3MgPSBob29rLnNwbGl0KCBcIiBcIiApO1xuXHRlYWNoKCBob29rcywgZnVuY3Rpb24oIGksIGhvb2sgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBob29rIF0gPSB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHBhcnNlZCwgY3VyRWxlbSxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBcIlwiO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IFwidHJhbnNwYXJlbnRcIiAmJiAoIGpRdWVyeS50eXBlKCB2YWx1ZSApICE9PSBcInN0cmluZ1wiIHx8ICggcGFyc2VkID0gc3RyaW5nUGFyc2UoIHZhbHVlICkgKSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29sb3IoIHBhcnNlZCB8fCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggIXN1cHBvcnQucmdiYSAmJiB2YWx1ZS5fcmdiYVsgMyBdICE9PSAxICkge1xuXHRcdFx0XHRcdFx0Y3VyRWxlbSA9IGhvb2sgPT09IFwiYmFja2dyb3VuZENvbG9yXCIgPyBlbGVtLnBhcmVudE5vZGUgOiBlbGVtO1xuXHRcdFx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdFx0XHQoYmFja2dyb3VuZENvbG9yID09PSBcIlwiIHx8IGJhY2tncm91bmRDb2xvciA9PT0gXCJ0cmFuc3BhcmVudFwiKSAmJlxuXHRcdFx0XHRcdFx0XHRjdXJFbGVtICYmIGN1ckVsZW0uc3R5bGVcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IGpRdWVyeS5jc3MoIGN1ckVsZW0sIFwiYmFja2dyb3VuZENvbG9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRjdXJFbGVtID0gY3VyRWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmJsZW5kKCBiYWNrZ3JvdW5kQ29sb3IgJiYgYmFja2dyb3VuZENvbG9yICE9PSBcInRyYW5zcGFyZW50XCIgP1xuXHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgOlxuXHRcdFx0XHRcdFx0XHRcIl9kZWZhdWx0XCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvUmdiYVN0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZVsgaG9vayBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRcdFx0Ly8gd3JhcHBlZCB0byBwcmV2ZW50IElFIGZyb20gdGhyb3dpbmcgZXJyb3JzIG9uIFwiaW52YWxpZFwiIHZhbHVlcyBsaWtlICdhdXRvJyBvciAnaW5oZXJpdCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0alF1ZXJ5LmZ4LnN0ZXBbIGhvb2sgXSA9IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRcdGlmICggIWZ4LmNvbG9ySW5pdCApIHtcblx0XHRcdFx0Znguc3RhcnQgPSBjb2xvciggZnguZWxlbSwgaG9vayApO1xuXHRcdFx0XHRmeC5lbmQgPSBjb2xvciggZnguZW5kICk7XG5cdFx0XHRcdGZ4LmNvbG9ySW5pdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRqUXVlcnkuY3NzSG9va3NbIGhvb2sgXS5zZXQoIGZ4LmVsZW0sIGZ4LnN0YXJ0LnRyYW5zaXRpb24oIGZ4LmVuZCwgZngucG9zICkgKTtcblx0XHR9O1xuXHR9KTtcblxufTtcblxuY29sb3IuaG9vayggc3RlcEhvb2tzICk7XG5cbmpRdWVyeS5jc3NIb29rcy5ib3JkZXJDb2xvciA9IHtcblx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGV4cGFuZGVkID0ge307XG5cblx0XHRlYWNoKCBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHBhcnQgKSB7XG5cdFx0XHRleHBhbmRlZFsgXCJib3JkZXJcIiArIHBhcnQgKyBcIkNvbG9yXCIgXSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdHJldHVybiBleHBhbmRlZDtcblx0fVxufTtcblxuLy8gQmFzaWMgY29sb3IgbmFtZXMgb25seS5cbi8vIFVzYWdlIG9mIGFueSBvZiB0aGUgb3RoZXIgY29sb3IgbmFtZXMgcmVxdWlyZXMgYWRkaW5nIHlvdXJzZWxmIG9yIGluY2x1ZGluZ1xuLy8ganF1ZXJ5LmNvbG9yLnN2Zy1uYW1lcy5qcy5cbmNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lcyA9IHtcblx0Ly8gNC4xLiBCYXNpYyBjb2xvciBrZXl3b3Jkc1xuXHRhcXVhOiBcIiMwMGZmZmZcIixcblx0YmxhY2s6IFwiIzAwMDAwMFwiLFxuXHRibHVlOiBcIiMwMDAwZmZcIixcblx0ZnVjaHNpYTogXCIjZmYwMGZmXCIsXG5cdGdyYXk6IFwiIzgwODA4MFwiLFxuXHRncmVlbjogXCIjMDA4MDAwXCIsXG5cdGxpbWU6IFwiIzAwZmYwMFwiLFxuXHRtYXJvb246IFwiIzgwMDAwMFwiLFxuXHRuYXZ5OiBcIiMwMDAwODBcIixcblx0b2xpdmU6IFwiIzgwODAwMFwiLFxuXHRwdXJwbGU6IFwiIzgwMDA4MFwiLFxuXHRyZWQ6IFwiI2ZmMDAwMFwiLFxuXHRzaWx2ZXI6IFwiI2MwYzBjMFwiLFxuXHR0ZWFsOiBcIiMwMDgwODBcIixcblx0d2hpdGU6IFwiI2ZmZmZmZlwiLFxuXHR5ZWxsb3c6IFwiI2ZmZmYwMFwiLFxuXG5cdC8vIDQuMi4zLiBcInRyYW5zcGFyZW50XCIgY29sb3Iga2V5d29yZFxuXHR0cmFuc3BhcmVudDogWyBudWxsLCBudWxsLCBudWxsLCAwIF0sXG5cblx0X2RlZmF1bHQ6IFwiI2ZmZmZmZlwiXG59O1xuXG59KSggalF1ZXJ5ICk7XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQ0xBU1MgQU5JTUFUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuKGZ1bmN0aW9uKCkge1xuXG52YXIgY2xhc3NBbmltYXRpb25BY3Rpb25zID0gWyBcImFkZFwiLCBcInJlbW92ZVwiLCBcInRvZ2dsZVwiIF0sXG5cdHNob3J0aGFuZFN0eWxlcyA9IHtcblx0XHRib3JkZXI6IDEsXG5cdFx0Ym9yZGVyQm90dG9tOiAxLFxuXHRcdGJvcmRlckNvbG9yOiAxLFxuXHRcdGJvcmRlckxlZnQ6IDEsXG5cdFx0Ym9yZGVyUmlnaHQ6IDEsXG5cdFx0Ym9yZGVyVG9wOiAxLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdG1hcmdpbjogMSxcblx0XHRwYWRkaW5nOiAxXG5cdH07XG5cbiQuZWFjaChbIFwiYm9yZGVyTGVmdFN0eWxlXCIsIFwiYm9yZGVyUmlnaHRTdHlsZVwiLCBcImJvcmRlckJvdHRvbVN0eWxlXCIsIFwiYm9yZGVyVG9wU3R5bGVcIiBdLCBmdW5jdGlvbiggXywgcHJvcCApIHtcblx0JC5meC5zdGVwWyBwcm9wIF0gPSBmdW5jdGlvbiggZnggKSB7XG5cdFx0aWYgKCBmeC5lbmQgIT09IFwibm9uZVwiICYmICFmeC5zZXRBdHRyIHx8IGZ4LnBvcyA9PT0gMSAmJiAhZnguc2V0QXR0ciApIHtcblx0XHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgcHJvcCwgZnguZW5kICk7XG5cdFx0XHRmeC5zZXRBdHRyID0gdHJ1ZTtcblx0XHR9XG5cdH07XG59KTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudFN0eWxlcyggZWxlbSApIHtcblx0dmFyIGtleSwgbGVuLFxuXHRcdHN0eWxlID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ID9cblx0XHRcdGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICkgOlxuXHRcdFx0ZWxlbS5jdXJyZW50U3R5bGUsXG5cdFx0c3R5bGVzID0ge307XG5cblx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggJiYgc3R5bGVbIDAgXSAmJiBzdHlsZVsgc3R5bGVbIDAgXSBdICkge1xuXHRcdGxlbiA9IHN0eWxlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGxlbi0tICkge1xuXHRcdFx0a2V5ID0gc3R5bGVbIGxlbiBdO1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRzdHlsZXNbICQuY2FtZWxDYXNlKCBrZXkgKSBdID0gc3R5bGVbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0Ly8gc3VwcG9ydDogT3BlcmEsIElFIDw5XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICgga2V5IGluIHN0eWxlICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRzdHlsZXNbIGtleSBdID0gc3R5bGVbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cblxuZnVuY3Rpb24gc3R5bGVEaWZmZXJlbmNlKCBvbGRTdHlsZSwgbmV3U3R5bGUgKSB7XG5cdHZhciBkaWZmID0ge30sXG5cdFx0bmFtZSwgdmFsdWU7XG5cblx0Zm9yICggbmFtZSBpbiBuZXdTdHlsZSApIHtcblx0XHR2YWx1ZSA9IG5ld1N0eWxlWyBuYW1lIF07XG5cdFx0aWYgKCBvbGRTdHlsZVsgbmFtZSBdICE9PSB2YWx1ZSApIHtcblx0XHRcdGlmICggIXNob3J0aGFuZFN0eWxlc1sgbmFtZSBdICkge1xuXHRcdFx0XHRpZiAoICQuZnguc3RlcFsgbmFtZSBdIHx8ICFpc05hTiggcGFyc2VGbG9hdCggdmFsdWUgKSApICkge1xuXHRcdFx0XHRcdGRpZmZbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRpZmY7XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5pZiAoICEkLmZuLmFkZEJhY2sgKSB7XG5cdCQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH07XG59XG5cbiQuZWZmZWN0cy5hbmltYXRlQ2xhc3MgPSBmdW5jdGlvbiggdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHR2YXIgbyA9ICQuc3BlZWQoIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmltYXRlZCA9ICQoIHRoaXMgKSxcblx0XHRcdGJhc2VDbGFzcyA9IGFuaW1hdGVkLmF0dHIoIFwiY2xhc3NcIiApIHx8IFwiXCIsXG5cdFx0XHRhcHBseUNsYXNzQ2hhbmdlLFxuXHRcdFx0YWxsQW5pbWF0aW9ucyA9IG8uY2hpbGRyZW4gPyBhbmltYXRlZC5maW5kKCBcIipcIiApLmFkZEJhY2soKSA6IGFuaW1hdGVkO1xuXG5cdFx0Ly8gbWFwIHRoZSBhbmltYXRlZCBvYmplY3RzIHRvIHN0b3JlIHRoZSBvcmlnaW5hbCBzdHlsZXMuXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsID0gJCggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRzdGFydDogZ2V0RWxlbWVudFN0eWxlcyggdGhpcyApXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgY2xhc3MgY2hhbmdlXG5cdFx0YXBwbHlDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC5lYWNoKCBjbGFzc0FuaW1hdGlvbkFjdGlvbnMsIGZ1bmN0aW9uKGksIGFjdGlvbikge1xuXHRcdFx0XHRpZiAoIHZhbHVlWyBhY3Rpb24gXSApIHtcblx0XHRcdFx0XHRhbmltYXRlZFsgYWN0aW9uICsgXCJDbGFzc1wiIF0oIHZhbHVlWyBhY3Rpb24gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdGFwcGx5Q2xhc3NDaGFuZ2UoKTtcblxuXHRcdC8vIG1hcCBhbGwgYW5pbWF0ZWQgb2JqZWN0cyBhZ2FpbiAtIGNhbGN1bGF0ZSBuZXcgc3R5bGVzIGFuZCBkaWZmXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5lbmQgPSBnZXRFbGVtZW50U3R5bGVzKCB0aGlzLmVsWyAwIF0gKTtcblx0XHRcdHRoaXMuZGlmZiA9IHN0eWxlRGlmZmVyZW5jZSggdGhpcy5zdGFydCwgdGhpcy5lbmQgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgb3JpZ2luYWwgY2xhc3Ncblx0XHRhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIsIGJhc2VDbGFzcyApO1xuXG5cdFx0Ly8gbWFwIGFsbCBhbmltYXRlZCBvYmplY3RzIGFnYWluIC0gdGhpcyB0aW1lIGNvbGxlY3RpbmcgYSBwcm9taXNlXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0eWxlSW5mbyA9IHRoaXMsXG5cdFx0XHRcdGRmZCA9ICQuRGVmZXJyZWQoKSxcblx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBvLCB7XG5cdFx0XHRcdFx0cXVldWU6IGZhbHNlLFxuXHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGRmZC5yZXNvbHZlKCBzdHlsZUluZm8gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmVsLmFuaW1hdGUoIHRoaXMuZGlmZiwgb3B0cyApO1xuXHRcdFx0cmV0dXJuIGRmZC5wcm9taXNlKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBvbmNlIGFsbCBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkOlxuXHRcdCQud2hlbi5hcHBseSggJCwgYWxsQW5pbWF0aW9ucy5nZXQoKSApLmRvbmUoZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIHNldCB0aGUgZmluYWwgY2xhc3Ncblx0XHRcdGFwcGx5Q2xhc3NDaGFuZ2UoKTtcblxuXHRcdFx0Ly8gZm9yIGVhY2ggYW5pbWF0ZWQgZWxlbWVudCxcblx0XHRcdC8vIGNsZWFyIGFsbCBjc3MgcHJvcGVydGllcyB0aGF0IHdlcmUgYW5pbWF0ZWRcblx0XHRcdCQuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsID0gdGhpcy5lbDtcblx0XHRcdFx0JC5lYWNoKCB0aGlzLmRpZmYsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdGVsLmNzcygga2V5LCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHRoaXMgaXMgZ3Vhcm50ZWVkIHRvIGJlIHRoZXJlIGlmIHlvdSB1c2UgalF1ZXJ5LnNwZWVkKClcblx0XHRcdC8vIGl0IGFsc28gaGFuZGxlcyBkZXF1ZXVpbmcgdGhlIG5leHQgYW5pbS4uLlxuXHRcdFx0by5jb21wbGV0ZS5jYWxsKCBhbmltYXRlZFsgMCBdICk7XG5cdFx0fSk7XG5cdH0pO1xufTtcblxuJC5mbi5leHRlbmQoe1xuXHRhZGRDbGFzczogKGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4gc3BlZWQgP1xuXHRcdFx0XHQkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0eyBhZGQ6IGNsYXNzTmFtZXMgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmFkZENsYXNzICksXG5cblx0cmVtb3ZlQ2xhc3M6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID9cblx0XHRcdFx0JC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHRcdHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgOlxuXHRcdFx0XHRvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVDbGFzcyApLFxuXG5cdHRvZ2dsZUNsYXNzOiAoZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBjbGFzc05hbWVzLCBmb3JjZSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBmb3JjZSA9PT0gXCJib29sZWFuXCIgfHwgZm9yY2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWYgKCAhc3BlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gd2l0aG91dCBzcGVlZCBwYXJhbWV0ZXJcblx0XHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcblx0XHRcdFx0XHRcdChmb3JjZSA/IHsgYWRkOiBjbGFzc05hbWVzIH0gOiB7IHJlbW92ZTogY2xhc3NOYW1lcyB9KSxcblx0XHRcdFx0XHRcdHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdpdGhvdXQgZm9yY2UgcGFyYW1ldGVyXG5cdFx0XHRcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0eyB0b2dnbGU6IGNsYXNzTmFtZXMgfSwgZm9yY2UsIHNwZWVkLCBlYXNpbmcgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi50b2dnbGVDbGFzcyApLFxuXG5cdHN3aXRjaENsYXNzOiBmdW5jdGlvbiggcmVtb3ZlLCBhZGQsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcywge1xuXHRcdFx0YWRkOiBhZGQsXG5cdFx0XHRyZW1vdmU6IHJlbW92ZVxuXHRcdH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH1cbn0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVGRkVDVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbihmdW5jdGlvbigpIHtcblxuJC5leHRlbmQoICQuZWZmZWN0cywge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXG5cdC8vIFNhdmVzIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gYSBkYXRhIHN0b3JhZ2Vcblx0c2F2ZTogZnVuY3Rpb24oIGVsZW1lbnQsIHNldCApIHtcblx0XHRmb3IoIHZhciBpPTA7IGkgPCBzZXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIHNldFsgaSBdICE9PSBudWxsICkge1xuXHRcdFx0XHRlbGVtZW50LmRhdGEoIGRhdGFTcGFjZSArIHNldFsgaSBdLCBlbGVtZW50WyAwIF0uc3R5bGVbIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gUmVzdG9yZXMgYSBzZXQgb2YgcHJldmlvdXNseSBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYSBkYXRhIHN0b3JhZ2Vcblx0cmVzdG9yZTogZnVuY3Rpb24oIGVsZW1lbnQsIHNldCApIHtcblx0XHR2YXIgdmFsLCBpO1xuXHRcdGZvciggaT0wOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSApO1xuXHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgMS42LjJcblx0XHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTkxN1xuXHRcdFx0XHQvLyBqUXVlcnkgMS42LjIgaW5jb3JyZWN0bHkgcmV0dXJucyB1bmRlZmluZWQgZm9yIGFueSBmYWxzeSB2YWx1ZS5cblx0XHRcdFx0Ly8gV2UgY2FuJ3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFwiXCIgYW5kIDAgaGVyZSwgc28gd2UganVzdCBhc3N1bWVcblx0XHRcdFx0Ly8gZW1wdHkgc3RyaW5nIHNpbmNlIGl0J3MgbGlrZWx5IHRvIGJlIGEgbW9yZSBjb21tb24gdmFsdWUuLi5cblx0XHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YWwgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQuY3NzKCBzZXRbIGkgXSwgdmFsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldE1vZGU6IGZ1bmN0aW9uKCBlbCwgbW9kZSApIHtcblx0XHRpZiAobW9kZSA9PT0gXCJ0b2dnbGVcIikge1xuXHRcdFx0bW9kZSA9IGVsLmlzKCBcIjpoaWRkZW5cIiApID8gXCJzaG93XCIgOiBcImhpZGVcIjtcblx0XHR9XG5cdFx0cmV0dXJuIG1vZGU7XG5cdH0sXG5cblx0Ly8gVHJhbnNsYXRlcyBhIFt0b3AsbGVmdF0gYXJyYXkgaW50byBhIGJhc2VsaW5lIHZhbHVlXG5cdC8vIHRoaXMgc2hvdWxkIGJlIGEgbGl0dGxlIG1vcmUgZmxleGlibGUgaW4gdGhlIGZ1dHVyZSB0byBoYW5kbGUgYSBzdHJpbmcgJiBoYXNoXG5cdGdldEJhc2VsaW5lOiBmdW5jdGlvbiggb3JpZ2luLCBvcmlnaW5hbCApIHtcblx0XHR2YXIgeSwgeDtcblx0XHRzd2l0Y2ggKCBvcmlnaW5bIDAgXSApIHtcblx0XHRcdGNhc2UgXCJ0b3BcIjogeSA9IDA7IGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1pZGRsZVwiOiB5ID0gMC41OyBicmVhaztcblx0XHRcdGNhc2UgXCJib3R0b21cIjogeSA9IDE7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogeSA9IG9yaWdpblsgMCBdIC8gb3JpZ2luYWwuaGVpZ2h0O1xuXHRcdH1cblx0XHRzd2l0Y2ggKCBvcmlnaW5bIDEgXSApIHtcblx0XHRcdGNhc2UgXCJsZWZ0XCI6IHggPSAwOyBicmVhaztcblx0XHRcdGNhc2UgXCJjZW50ZXJcIjogeCA9IDAuNTsgYnJlYWs7XG5cdFx0XHRjYXNlIFwicmlnaHRcIjogeCA9IDE7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogeCA9IG9yaWdpblsgMSBdIC8gb3JpZ2luYWwud2lkdGg7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gV3JhcHMgdGhlIGVsZW1lbnQgYXJvdW5kIGEgd3JhcHBlciB0aGF0IGNvcGllcyBwb3NpdGlvbiBwcm9wZXJ0aWVzXG5cdGNyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0Ly8gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB3cmFwcGVkLCByZXR1cm4gaXRcblx0XHRpZiAoIGVsZW1lbnQucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkpIHtcblx0XHRcdHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuXHRcdH1cblxuXHRcdC8vIHdyYXAgdGhlIGVsZW1lbnRcblx0XHR2YXIgcHJvcHMgPSB7XG5cdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm91dGVyV2lkdGgodHJ1ZSksXG5cdFx0XHRcdGhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKSxcblx0XHRcdFx0XCJmbG9hdFwiOiBlbGVtZW50LmNzcyggXCJmbG9hdFwiIClcblx0XHRcdH0sXG5cdFx0XHR3cmFwcGVyID0gJCggXCI8ZGl2PjwvZGl2PlwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtd3JhcHBlclwiIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0Zm9udFNpemU6IFwiMTAwJVwiLFxuXHRcdFx0XHRcdGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcblx0XHRcdFx0XHRib3JkZXI6IFwibm9uZVwiLFxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRwYWRkaW5nOiAwXG5cdFx0XHRcdH0pLFxuXHRcdFx0Ly8gU3RvcmUgdGhlIHNpemUgaW4gY2FzZSB3aWR0aC9oZWlnaHQgYXJlIGRlZmluZWQgaW4gJSAtIEZpeGVzICM1MjQ1XG5cdFx0XHRzaXplID0ge1xuXHRcdFx0XHR3aWR0aDogZWxlbWVudC53aWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0KClcblx0XHRcdH0sXG5cdFx0XHRhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0Ly8gc3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIEZpcmVmb3ggaW5jb3JyZWN0bHkgZXhwb3NlcyBhbm9ueW1vdXMgY29udGVudFxuXHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU2MTY2NFxuXHRcdHRyeSB7XG5cdFx0XHRhY3RpdmUuaWQ7XG5cdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdGFjdGl2ZSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0fVxuXG5cdFx0ZWxlbWVudC53cmFwKCB3cmFwcGVyICk7XG5cblx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdGlmICggZWxlbWVudFsgMCBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyggZWxlbWVudFsgMCBdLCBhY3RpdmUgKSApIHtcblx0XHRcdCQoIGFjdGl2ZSApLmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0d3JhcHBlciA9IGVsZW1lbnQucGFyZW50KCk7IC8vSG90Zml4IGZvciBqUXVlcnkgMS40IHNpbmNlIHNvbWUgY2hhbmdlIGluIHdyYXAoKSBzZWVtcyB0byBhY3R1YWxseSBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdyYXBwZWQgZWxlbWVudFxuXG5cdFx0Ly8gdHJhbnNmZXIgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgd3JhcHBlclxuXHRcdGlmICggZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0d3JhcHBlci5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuXHRcdFx0ZWxlbWVudC5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV4dGVuZCggcHJvcHMsIHtcblx0XHRcdFx0cG9zaXRpb246IGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdFx0ekluZGV4OiBlbGVtZW50LmNzcyggXCJ6LWluZGV4XCIgKVxuXHRcdFx0fSk7XG5cdFx0XHQkLmVhY2goWyBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiIF0sIGZ1bmN0aW9uKGksIHBvcykge1xuXHRcdFx0XHRwcm9wc1sgcG9zIF0gPSBlbGVtZW50LmNzcyggcG9zICk7XG5cdFx0XHRcdGlmICggaXNOYU4oIHBhcnNlSW50KCBwcm9wc1sgcG9zIF0sIDEwICkgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgcG9zIF0gPSBcImF1dG9cIjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRlbGVtZW50LmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IFwiYXV0b1wiLFxuXHRcdFx0XHRib3R0b206IFwiYXV0b1wiXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxlbWVudC5jc3Moc2l6ZSk7XG5cblx0XHRyZXR1cm4gd3JhcHBlci5jc3MoIHByb3BzICkuc2hvdygpO1xuXHR9LFxuXG5cdHJlbW92ZVdyYXBwZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0aWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuXHRcdFx0ZWxlbWVudC5wYXJlbnQoKS5yZXBsYWNlV2l0aCggZWxlbWVudCApO1xuXG5cdFx0XHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxuXHRcdFx0aWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuXHRcdFx0XHQkKCBhY3RpdmUgKS5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0c2V0VHJhbnNpdGlvbjogZnVuY3Rpb24oIGVsZW1lbnQsIGxpc3QsIGZhY3RvciwgdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSB8fCB7fTtcblx0XHQkLmVhY2goIGxpc3QsIGZ1bmN0aW9uKCBpLCB4ICkge1xuXHRcdFx0dmFyIHVuaXQgPSBlbGVtZW50LmNzc1VuaXQoIHggKTtcblx0XHRcdGlmICggdW5pdFsgMCBdID4gMCApIHtcblx0XHRcdFx0dmFsdWVbIHggXSA9IHVuaXRbIDAgXSAqIGZhY3RvciArIHVuaXRbIDEgXTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG4vLyByZXR1cm4gYW4gZWZmZWN0IG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyczpcbmZ1bmN0aW9uIF9ub3JtYWxpemVBcmd1bWVudHMoIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICkge1xuXG5cdC8vIGFsbG93IHBhc3NpbmcgYWxsIG9wdGlvbnMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggZWZmZWN0ICkgKSB7XG5cdFx0b3B0aW9ucyA9IGVmZmVjdDtcblx0XHRlZmZlY3QgPSBlZmZlY3QuZWZmZWN0O1xuXHR9XG5cblx0Ly8gY29udmVydCB0byBhbiBvYmplY3Rcblx0ZWZmZWN0ID0geyBlZmZlY3Q6IGVmZmVjdCB9O1xuXG5cdC8vIGNhdGNoIChlZmZlY3QsIG51bGwsIC4uLilcblx0aWYgKCBvcHRpb25zID09IG51bGwgKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gY2F0Y2ggKGVmZmVjdCwgY2FsbGJhY2spXG5cdGlmICggJC5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBjYXRjaCAoZWZmZWN0LCBzcGVlZCwgPylcblx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgb3B0aW9ucyBdICkge1xuXHRcdGNhbGxiYWNrID0gc3BlZWQ7XG5cdFx0c3BlZWQgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdC8vIGNhdGNoIChlZmZlY3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRpZiAoICQuaXNGdW5jdGlvbiggc3BlZWQgKSApIHtcblx0XHRjYWxsYmFjayA9IHNwZWVkO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0fVxuXG5cdC8vIGFkZCBvcHRpb25zIHRvIGVmZmVjdFxuXHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0JC5leHRlbmQoIGVmZmVjdCwgb3B0aW9ucyApO1xuXHR9XG5cblx0c3BlZWQgPSBzcGVlZCB8fCBvcHRpb25zLmR1cmF0aW9uO1xuXHRlZmZlY3QuZHVyYXRpb24gPSAkLmZ4Lm9mZiA/IDAgOlxuXHRcdHR5cGVvZiBzcGVlZCA9PT0gXCJudW1iZXJcIiA/IHNwZWVkIDpcblx0XHRzcGVlZCBpbiAkLmZ4LnNwZWVkcyA/ICQuZnguc3BlZWRzWyBzcGVlZCBdIDpcblx0XHQkLmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHRlZmZlY3QuY29tcGxldGUgPSBjYWxsYmFjayB8fCBvcHRpb25zLmNvbXBsZXRlO1xuXG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSB7XG5cdC8vIFZhbGlkIHN0YW5kYXJkIHNwZWVkcyAobm90aGluZywgbnVtYmVyLCBuYW1lZCBzcGVlZClcblx0aWYgKCAhb3B0aW9uIHx8IHR5cGVvZiBvcHRpb24gPT09IFwibnVtYmVyXCIgfHwgJC5meC5zcGVlZHNbIG9wdGlvbiBdICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW52YWxpZCBzdHJpbmdzIC0gdHJlYXQgYXMgXCJub3JtYWxcIiBzcGVlZFxuXHRpZiAoIHR5cGVvZiBvcHRpb24gPT09IFwic3RyaW5nXCIgJiYgISQuZWZmZWN0cy5lZmZlY3RbIG9wdGlvbiBdICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ29tcGxldGUgY2FsbGJhY2tcblx0aWYgKCAkLmlzRnVuY3Rpb24oIG9wdGlvbiApICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gT3B0aW9ucyBoYXNoIChidXQgbm90IG5hbWluZyBhbiBlZmZlY3QpXG5cdGlmICggdHlwZW9mIG9wdGlvbiA9PT0gXCJvYmplY3RcIiAmJiAhb3B0aW9uLmVmZmVjdCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIERpZG4ndCBtYXRjaCBhbnkgc3RhbmRhcmQgQVBJXG5cdHJldHVybiBmYWxzZTtcbn1cblxuJC5mbi5leHRlbmQoe1xuXHRlZmZlY3Q6IGZ1bmN0aW9uKCAvKiBlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjayAqLyApIHtcblx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0bW9kZSA9IGFyZ3MubW9kZSxcblx0XHRcdHF1ZXVlID0gYXJncy5xdWV1ZSxcblx0XHRcdGVmZmVjdE1ldGhvZCA9ICQuZWZmZWN0cy5lZmZlY3RbIGFyZ3MuZWZmZWN0IF07XG5cblx0XHRpZiAoICQuZngub2ZmIHx8ICFlZmZlY3RNZXRob2QgKSB7XG5cdFx0XHQvLyBkZWxlZ2F0ZSB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChlLmcuLCAuc2hvdygpKSBpZiBwb3NzaWJsZVxuXHRcdFx0aWYgKCBtb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpc1sgbW9kZSBdKCBhcmdzLmR1cmF0aW9uLCBhcmdzLmNvbXBsZXRlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGFyZ3MuY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRhcmdzLmNvbXBsZXRlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1biggbmV4dCApIHtcblx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0XHRjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXG5cdFx0XHRcdG1vZGUgPSBhcmdzLm1vZGU7XG5cblx0XHRcdGZ1bmN0aW9uIGRvbmUoKSB7XG5cdFx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjb21wbGV0ZSApICkge1xuXHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoIGVsZW1bMF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICQuaXNGdW5jdGlvbiggbmV4dCApICkge1xuXHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyB0aGUgY29ycmVjdCBmaW5hbCBzdGF0ZSwgZGVsZWdhdGUgdG9cblx0XHRcdC8vIHRoZSBjb3JlIG1ldGhvZHMgc28gdGhlIGludGVybmFsIHRyYWNraW5nIG9mIFwib2xkZGlzcGxheVwiIHdvcmtzLlxuXHRcdFx0aWYgKCBlbGVtLmlzKCBcIjpoaWRkZW5cIiApID8gbW9kZSA9PT0gXCJoaWRlXCIgOiBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRcdFx0ZWxlbVsgbW9kZSBdKCk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVmZmVjdE1ldGhvZC5jYWxsKCBlbGVtWzBdLCBhcmdzLCBkb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHF1ZXVlID09PSBmYWxzZSA/IHRoaXMuZWFjaCggcnVuICkgOiB0aGlzLnF1ZXVlKCBxdWV1ZSB8fCBcImZ4XCIsIHJ1biApO1xuXHR9LFxuXG5cdHNob3c6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLm1vZGUgPSBcInNob3dcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5zaG93ICksXG5cblx0aGlkZTogKGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0aWYgKCBzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbiggb3B0aW9uICkgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGFyZ3MubW9kZSA9IFwiaGlkZVwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pKCAkLmZuLmhpZGUgKSxcblxuXHR0b2dnbGU6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApIHx8IHR5cGVvZiBvcHRpb24gPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLm1vZGUgPSBcInRvZ2dsZVwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pKCAkLmZuLnRvZ2dsZSApLFxuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0Y3NzVW5pdDogZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5jc3MoIGtleSApLFxuXHRcdFx0dmFsID0gW107XG5cblx0XHQkLmVhY2goIFsgXCJlbVwiLCBcInB4XCIsIFwiJVwiLCBcInB0XCIgXSwgZnVuY3Rpb24oIGksIHVuaXQgKSB7XG5cdFx0XHRpZiAoIHN0eWxlLmluZGV4T2YoIHVuaXQgKSA+IDAgKSB7XG5cdFx0XHRcdHZhbCA9IFsgcGFyc2VGbG9hdCggc3R5bGUgKSwgdW5pdCBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG59KSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVBU0lORyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbihmdW5jdGlvbigpIHtcblxuLy8gYmFzZWQgb24gZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbnZhciBiYXNlRWFzaW5ncyA9IHt9O1xuXG4kLmVhY2goIFsgXCJRdWFkXCIsIFwiQ3ViaWNcIiwgXCJRdWFydFwiLCBcIlF1aW50XCIsIFwiRXhwb1wiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRiYXNlRWFzaW5nc1sgbmFtZSBdID0gZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KCBwLCBpICsgMiApO1xuXHR9O1xufSk7XG5cbiQuZXh0ZW5kKCBiYXNlRWFzaW5ncywge1xuXHRTaW5lOiBmdW5jdGlvbiAoIHAgKSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgLyAyICk7XG5cdH0sXG5cdENpcmM6IGZ1bmN0aW9uICggcCApIHtcblx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCggMSAtIHAgKiBwICk7XG5cdH0sXG5cdEVsYXN0aWM6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwID09PSAwIHx8IHAgPT09IDEgPyBwIDpcblx0XHRcdC1NYXRoLnBvdyggMiwgOCAqIChwIC0gMSkgKSAqIE1hdGguc2luKCAoIChwIC0gMSkgKiA4MCAtIDcuNSApICogTWF0aC5QSSAvIDE1ICk7XG5cdH0sXG5cdEJhY2s6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwICogcCAqICggMyAqIHAgLSAyICk7XG5cdH0sXG5cdEJvdW5jZTogZnVuY3Rpb24gKCBwICkge1xuXHRcdHZhciBwb3cyLFxuXHRcdFx0Ym91bmNlID0gNDtcblxuXHRcdHdoaWxlICggcCA8ICggKCBwb3cyID0gTWF0aC5wb3coIDIsIC0tYm91bmNlICkgKSAtIDEgKSAvIDExICkge31cblx0XHRyZXR1cm4gMSAvIE1hdGgucG93KCA0LCAzIC0gYm91bmNlICkgLSA3LjU2MjUgKiBNYXRoLnBvdyggKCBwb3cyICogMyAtIDIgKSAvIDIyIC0gcCwgMiApO1xuXHR9XG59KTtcblxuJC5lYWNoKCBiYXNlRWFzaW5ncywgZnVuY3Rpb24oIG5hbWUsIGVhc2VJbiApIHtcblx0JC5lYXNpbmdbIFwiZWFzZUluXCIgKyBuYW1lIF0gPSBlYXNlSW47XG5cdCQuZWFzaW5nWyBcImVhc2VPdXRcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAxIC0gZWFzZUluKCAxIC0gcCApO1xuXHR9O1xuXHQkLmVhc2luZ1sgXCJlYXNlSW5PdXRcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwIDwgMC41ID9cblx0XHRcdGVhc2VJbiggcCAqIDIgKSAvIDIgOlxuXHRcdFx0MSAtIGVhc2VJbiggcCAqIC0yICsgMiApIC8gMjtcblx0fTtcbn0pO1xuXG59KSgpO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHVpZCA9IDAsXG5cdGhpZGVQcm9wcyA9IHt9LFxuXHRzaG93UHJvcHMgPSB7fTtcblxuaGlkZVByb3BzLmhlaWdodCA9IGhpZGVQcm9wcy5wYWRkaW5nVG9wID0gaGlkZVByb3BzLnBhZGRpbmdCb3R0b20gPVxuXHRoaWRlUHJvcHMuYm9yZGVyVG9wV2lkdGggPSBoaWRlUHJvcHMuYm9yZGVyQm90dG9tV2lkdGggPSBcImhpZGVcIjtcbnNob3dQcm9wcy5oZWlnaHQgPSBzaG93UHJvcHMucGFkZGluZ1RvcCA9IHNob3dQcm9wcy5wYWRkaW5nQm90dG9tID1cblx0c2hvd1Byb3BzLmJvcmRlclRvcFdpZHRoID0gc2hvd1Byb3BzLmJvcmRlckJvdHRvbVdpZHRoID0gXCJzaG93XCI7XG5cbiQud2lkZ2V0KCBcInVpLmFjY29yZGlvblwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhY3RpdmU6IDAsXG5cdFx0YW5pbWF0ZToge30sXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVhZGVyOiBcIj4gbGkgPiA6Zmlyc3QtY2hpbGQsPiA6bm90KGxpKTpldmVuXCIsXG5cdFx0aGVpZ2h0U3R5bGU6IFwiYXV0b1wiLFxuXHRcdGljb25zOiB7XG5cdFx0XHRhY3RpdmVIZWFkZXI6IFwidWktaWNvbi10cmlhbmdsZS0xLXNcIixcblx0XHRcdGhlYWRlcjogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtZVwiXG5cdFx0fSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUFjdGl2YXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5wcmV2U2hvdyA9IHRoaXMucHJldkhpZGUgPSAkKCk7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0XCIgKVxuXHRcdFx0Ly8gQVJJQVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYmxpc3RcIiApO1xuXG5cdFx0Ly8gZG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlIC8gbnVsbFxuXHRcdGlmICggIW9wdGlvbnMuY29sbGFwc2libGUgJiYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSB8fCBvcHRpb25zLmFjdGl2ZSA9PSBudWxsKSApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLl9wcm9jZXNzUGFuZWxzKCk7XG5cdFx0Ly8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlc1xuXHRcdGlmICggb3B0aW9ucy5hY3RpdmUgPCAwICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgKz0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcblx0XHR9XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWFkZXI6IHRoaXMuYWN0aXZlLFxuXHRcdFx0cGFuZWw6ICF0aGlzLmFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLmFjdGl2ZS5uZXh0KCksXG5cdFx0XHRjb250ZW50OiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5hY3RpdmUubmV4dCgpXG5cdFx0fTtcblx0fSxcblxuXHRfY3JlYXRlSWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpY29ucyA9IHRoaXMub3B0aW9ucy5pY29ucztcblx0XHRpZiAoIGljb25zICkge1xuXHRcdFx0JCggXCI8c3Bhbj5cIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24taGVhZGVyLWljb24gdWktaWNvbiBcIiArIGljb25zLmhlYWRlciApXG5cdFx0XHRcdC5wcmVwZW5kVG8oIHRoaXMuaGVhZGVycyApO1xuXHRcdFx0dGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBpY29ucy5oZWFkZXIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGljb25zLmFjdGl2ZUhlYWRlciApO1xuXHRcdFx0dGhpcy5oZWFkZXJzLmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1pY29uc1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95SWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1pY29uc1wiIClcblx0XHRcdC5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKVxuXHRcdFx0XHQucmVtb3ZlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb250ZW50cztcblxuXHRcdC8vIGNsZWFuIHVwIG1haW4gZWxlbWVudFxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cblx0XHQvLyBjbGVhbiB1cCBoZWFkZXJzXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktYWNjb3JkaW9uLWhlYWRlciB1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZSB1aS1oZWxwZXItcmVzZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCB1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAvXnVpLWFjY29yZGlvbi8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cblx0XHQvLyBjbGVhbiB1cCBjb250ZW50IHBhbmVsc1xuXHRcdGNvbnRlbnRzID0gdGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0LmNzcyggXCJkaXNwbGF5XCIsIFwiXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZXhwYW5kZWRcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1oZWxwZXItcmVzZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbSB1aS1hY2NvcmRpb24tY29udGVudCB1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAvXnVpLWFjY29yZGlvbi8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0Y29udGVudHMuY3NzKCBcImhlaWdodFwiLCBcIlwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImFjdGl2ZVwiICkge1xuXHRcdFx0Ly8gX2FjdGl2YXRlKCkgd2lsbCBoYW5kbGUgaW52YWxpZCB2YWx1ZXMgYW5kIHVwZGF0ZSB0aGlzLm9wdGlvbnNcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImV2ZW50XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudCApIHtcblx0XHRcdFx0dGhpcy5fb2ZmKCB0aGlzLmhlYWRlcnMsIHRoaXMub3B0aW9ucy5ldmVudCApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0dXBFdmVudHMoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIHNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgJiYgIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJpY29uc1wiICkge1xuXHRcdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLl9jcmVhdGVJY29ucygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vICM1MzMyIC0gb3BhY2l0eSBkb2Vzbid0IGNhc2NhZGUgdG8gcG9zaXRpb25lZCBlbGVtZW50cyBpbiBJRVxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBkaXNhYmxlZCBjbGFzcyB0byB0aGUgaGVhZGVycyBhbmQgcGFuZWxzXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMuaGVhZGVycy5hZGQoIHRoaXMuaGVhZGVycy5uZXh0KCkgKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfa2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTUqL1xuXHRcdGlmICggZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGUsXG5cdFx0XHRsZW5ndGggPSB0aGlzLmhlYWRlcnMubGVuZ3RoLFxuXHRcdFx0Y3VycmVudEluZGV4ID0gdGhpcy5oZWFkZXJzLmluZGV4KCBldmVudC50YXJnZXQgKSxcblx0XHRcdHRvRm9jdXMgPSBmYWxzZTtcblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIGtleUNvZGUuUklHSFQ6XG5cdFx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgKCBjdXJyZW50SW5kZXggKyAxICkgJSBsZW5ndGggXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuTEVGVDpcblx0XHRcdGNhc2Uga2V5Q29kZS5VUDpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgKCBjdXJyZW50SW5kZXggLSAxICsgbGVuZ3RoICkgJSBsZW5ndGggXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuU1BBQ0U6XG5cdFx0XHRjYXNlIGtleUNvZGUuRU5URVI6XG5cdFx0XHRcdHRoaXMuX2V2ZW50SGFuZGxlciggZXZlbnQgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuSE9NRTpcblx0XHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgMCBdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2Uga2V5Q29kZS5FTkQ6XG5cdFx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbIGxlbmd0aCAtIDEgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKCB0b0ZvY3VzICkge1xuXHRcdFx0JCggZXZlbnQudGFyZ2V0ICkuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdFx0JCggdG9Gb2N1cyApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdFx0dG9Gb2N1cy5mb2N1cygpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblx0X3BhbmVsS2V5RG93biA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCAmJiBldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnByZXYoKS5mb2N1cygpO1xuXHRcdH1cblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR0aGlzLl9wcm9jZXNzUGFuZWxzKCk7XG5cblx0XHQvLyB3YXMgY29sbGFwc2VkIG9yIG5vIHBhbmVsXG5cdFx0aWYgKCAoIG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSAmJiBvcHRpb25zLmNvbGxhcHNpYmxlID09PSB0cnVlICkgfHwgIXRoaXMuaGVhZGVycy5sZW5ndGggKSB7XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0Ly8gYWN0aXZlIGZhbHNlIG9ubHkgd2hlbiBjb2xsYXBzaWJsZSBpcyB0cnVlXG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblx0XHQvLyB3YXMgYWN0aXZlLCBidXQgYWN0aXZlIHBhbmVsIGlzIGdvbmVcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHQvLyBhbGwgcmVtYWluaW5nIHBhbmVsIGFyZSBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0aGlzLmhlYWRlcnMubGVuZ3RoID09PSB0aGlzLmhlYWRlcnMuZmluZChcIi51aS1zdGF0ZS1kaXNhYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXHRcdFx0Ly8gYWN0aXZhdGUgcHJldmlvdXMgcGFuZWxcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCBNYXRoLm1heCggMCwgb3B0aW9ucy5hY3RpdmUgLSAxICkgKTtcblx0XHRcdH1cblx0XHQvLyB3YXMgYWN0aXZlLCBhY3RpdmUgcGFuZWwgc3RpbGwgZXhpc3RzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIG1ha2Ugc3VyZSBhY3RpdmUgaW5kZXggaXMgY29ycmVjdFxuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSB0aGlzLmhlYWRlcnMuaW5kZXgoIHRoaXMuYWN0aXZlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3Byb2Nlc3NQYW5lbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZGVycyA9IHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaGVhZGVyIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24taGVhZGVyIHVpLWhlbHBlci1yZXNldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcIiApO1xuXG5cdFx0dGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50IHVpLWhlbHBlci1yZXNldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIgKVxuXHRcdFx0LmZpbHRlcihcIjpub3QoLnVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZSlcIilcblx0XHRcdC5oaWRlKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXhIZWlnaHQsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aGVpZ2h0U3R5bGUgPSBvcHRpb25zLmhlaWdodFN0eWxlLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudCgpLFxuXHRcdFx0YWNjb3JkaW9uSWQgPSB0aGlzLmFjY29yZGlvbklkID0gXCJ1aS1hY2NvcmRpb24tXCIgK1xuXHRcdFx0XHQodGhpcy5lbGVtZW50LmF0dHIoIFwiaWRcIiApIHx8ICsrdWlkKTtcblxuXHRcdHRoaXMuYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggb3B0aW9ucy5hY3RpdmUgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiApO1xuXHRcdHRoaXMuYWN0aXZlLm5leHQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiIClcblx0XHRcdC5zaG93KCk7XG5cblx0XHR0aGlzLmhlYWRlcnNcblx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJcIiApXG5cdFx0XHQuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFyIGhlYWRlciA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRoZWFkZXJJZCA9IGhlYWRlci5hdHRyKCBcImlkXCIgKSxcblx0XHRcdFx0XHRwYW5lbCA9IGhlYWRlci5uZXh0KCksXG5cdFx0XHRcdFx0cGFuZWxJZCA9IHBhbmVsLmF0dHIoIFwiaWRcIiApO1xuXHRcdFx0XHRpZiAoICFoZWFkZXJJZCApIHtcblx0XHRcdFx0XHRoZWFkZXJJZCA9IGFjY29yZGlvbklkICsgXCItaGVhZGVyLVwiICsgaTtcblx0XHRcdFx0XHRoZWFkZXIuYXR0ciggXCJpZFwiLCBoZWFkZXJJZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXBhbmVsSWQgKSB7XG5cdFx0XHRcdFx0cGFuZWxJZCA9IGFjY29yZGlvbklkICsgXCItcGFuZWwtXCIgKyBpO1xuXHRcdFx0XHRcdHBhbmVsLmF0dHIoIFwiaWRcIiwgcGFuZWxJZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhlYWRlci5hdHRyKCBcImFyaWEtY29udHJvbHNcIiwgcGFuZWxJZCApO1xuXHRcdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiLCBoZWFkZXJJZCApO1xuXHRcdFx0fSlcblx0XHRcdC5uZXh0KClcblx0XHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYnBhbmVsXCIgKTtcblxuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0Lm5vdCggdGhpcy5hY3RpdmUgKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XHR0YWJJbmRleDogLTFcblx0XHRcdH0pXG5cdFx0XHQubmV4dCgpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0XHRcdFx0fSlcblx0XHRcdFx0LmhpZGUoKTtcblxuXHRcdC8vIG1ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgaGVhZGVyIGlzIGluIHRoZSB0YWIgb3JkZXJcblx0XHRpZiAoICF0aGlzLmFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhlYWRlcnMuZXEoIDAgKS5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hY3RpdmUuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0pXG5cdFx0XHQubmV4dCgpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlSWNvbnMoKTtcblxuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCBvcHRpb25zLmV2ZW50ICk7XG5cblx0XHRpZiAoIGhlaWdodFN0eWxlID09PSBcImZpbGxcIiApIHtcblx0XHRcdG1heEhlaWdodCA9IHBhcmVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5zaWJsaW5ncyggXCI6dmlzaWJsZVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBlbGVtLmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1heEhlaWdodCAtPSBlbGVtLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5oZWFkZXJzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1heEhlaWdodCAtPSAkKCB0aGlzICkub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmhlYWRlcnMubmV4dCgpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5oZWlnaHQoIE1hdGgubWF4KCAwLCBtYXhIZWlnaHQgLVxuXHRcdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKCBcIm92ZXJmbG93XCIsIFwiYXV0b1wiICk7XG5cdFx0fSBlbHNlIGlmICggaGVpZ2h0U3R5bGUgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0bWF4SGVpZ2h0ID0gMDtcblx0XHRcdHRoaXMuaGVhZGVycy5uZXh0KClcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0bWF4SGVpZ2h0ID0gTWF0aC5tYXgoIG1heEhlaWdodCwgJCggdGhpcyApLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApLmhlaWdodCgpICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5oZWlnaHQoIG1heEhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggaW5kZXggKVsgMCBdO1xuXG5cdFx0Ly8gdHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlID09PSB0aGlzLmFjdGl2ZVsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHRyeWluZyB0byBjb2xsYXBzZSwgc2ltdWxhdGUgYSBjbGljayBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBoZWFkZXJcblx0XHRhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5hY3RpdmVbIDAgXTtcblxuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcih7XG5cdFx0XHR0YXJnZXQ6IGFjdGl2ZSxcblx0XHRcdGN1cnJlbnRUYXJnZXQ6IGFjdGl2ZSxcblx0XHRcdHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0XHR9KTtcblx0fSxcblxuXHRfZmluZEFjdGl2ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwibnVtYmVyXCIgPyB0aGlzLmhlYWRlcnMuZXEoIHNlbGVjdG9yICkgOiAkKCk7XG5cdH0sXG5cblx0X3NldHVwRXZlbnRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdGtleWRvd246IFwiX2tleWRvd25cIlxuXHRcdH07XG5cdFx0aWYgKCBldmVudCApIHtcblx0XHRcdCQuZWFjaCggZXZlbnQuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaW5kZXgsIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0ZXZlbnRzWyBldmVudE5hbWUgXSA9IFwiX2V2ZW50SGFuZGxlclwiO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fb2ZmKCB0aGlzLmhlYWRlcnMuYWRkKCB0aGlzLmhlYWRlcnMubmV4dCgpICkgKTtcblx0XHR0aGlzLl9vbiggdGhpcy5oZWFkZXJzLCBldmVudHMgKTtcblx0XHR0aGlzLl9vbiggdGhpcy5oZWFkZXJzLm5leHQoKSwgeyBrZXlkb3duOiBcIl9wYW5lbEtleURvd25cIiB9KTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMuaGVhZGVycyApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdGhpcy5oZWFkZXJzICk7XG5cdH0sXG5cblx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmUsXG5cdFx0XHRjbGlja2VkID0gJCggZXZlbnQuY3VycmVudFRhcmdldCApLFxuXHRcdFx0Y2xpY2tlZElzQWN0aXZlID0gY2xpY2tlZFsgMCBdID09PSBhY3RpdmVbIDAgXSxcblx0XHRcdGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcblx0XHRcdHRvU2hvdyA9IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLm5leHQoKSxcblx0XHRcdHRvSGlkZSA9IGFjdGl2ZS5uZXh0KCksXG5cdFx0XHRldmVudERhdGEgPSB7XG5cdFx0XHRcdG9sZEhlYWRlcjogYWN0aXZlLFxuXHRcdFx0XHRvbGRQYW5lbDogdG9IaWRlLFxuXHRcdFx0XHRuZXdIZWFkZXI6IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLFxuXHRcdFx0XHRuZXdQYW5lbDogdG9TaG93XG5cdFx0XHR9O1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdGlmIChcblx0XHRcdFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxuXHRcdFx0XHQoIGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSApIHx8XG5cdFx0XHRcdC8vIGFsbG93IGNhbmNlbGluZyBhY3RpdmF0aW9uXG5cdFx0XHRcdCggdGhpcy5fdHJpZ2dlciggXCJiZWZvcmVBY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICkgPT09IGZhbHNlICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5hY3RpdmUgPSBjb2xsYXBzaW5nID8gZmFsc2UgOiB0aGlzLmhlYWRlcnMuaW5kZXgoIGNsaWNrZWQgKTtcblxuXHRcdC8vIHdoZW4gdGhlIGNhbGwgdG8gLl90b2dnbGUoKSBjb21lcyBhZnRlciB0aGUgY2xhc3MgY2hhbmdlc1xuXHRcdC8vIGl0IGNhdXNlcyBhIHZlcnkgb2RkIGJ1ZyBpbiBJRSA4IChzZWUgIzY3MjApXG5cdFx0dGhpcy5hY3RpdmUgPSBjbGlja2VkSXNBY3RpdmUgPyAkKCkgOiBjbGlja2VkO1xuXHRcdHRoaXMuX3RvZ2dsZSggZXZlbnREYXRhICk7XG5cblx0XHQvLyBzd2l0Y2ggY2xhc3Nlc1xuXHRcdC8vIGNvcm5lciBjbGFzc2VzIG9uIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBoZWFkZXIgc3RheSBhZnRlciB0aGUgYW5pbWF0aW9uXG5cdFx0YWN0aXZlLnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0aWYgKCBvcHRpb25zLmljb25zICkge1xuXHRcdFx0YWN0aXZlLmNoaWxkcmVuKCBcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggb3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIG9wdGlvbnMuaWNvbnMuaGVhZGVyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhY2xpY2tlZElzQWN0aXZlICkge1xuXHRcdFx0Y2xpY2tlZFxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZSB1aS1jb3JuZXItdG9wXCIgKTtcblx0XHRcdGlmICggb3B0aW9ucy5pY29ucyApIHtcblx0XHRcdFx0Y2xpY2tlZC5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggb3B0aW9ucy5pY29ucy5oZWFkZXIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggb3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Y2xpY2tlZFxuXHRcdFx0XHQubmV4dCgpXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmVcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgdG9TaG93ID0gZGF0YS5uZXdQYW5lbCxcblx0XHRcdHRvSGlkZSA9IHRoaXMucHJldlNob3cubGVuZ3RoID8gdGhpcy5wcmV2U2hvdyA6IGRhdGEub2xkUGFuZWw7XG5cblx0XHQvLyBoYW5kbGUgYWN0aXZhdGluZyBhIHBhbmVsIGR1cmluZyB0aGUgYW5pbWF0aW9uIGZvciBhbm90aGVyIGFjdGl2YXRpb25cblx0XHR0aGlzLnByZXZTaG93LmFkZCggdGhpcy5wcmV2SGlkZSApLnN0b3AoIHRydWUsIHRydWUgKTtcblx0XHR0aGlzLnByZXZTaG93ID0gdG9TaG93O1xuXHRcdHRoaXMucHJldkhpZGUgPSB0b0hpZGU7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hbmltYXRlICkge1xuXHRcdFx0dGhpcy5fYW5pbWF0ZSggdG9TaG93LCB0b0hpZGUsIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9IaWRlLmhpZGUoKTtcblx0XHRcdHRvU2hvdy5zaG93KCk7XG5cdFx0XHR0aGlzLl90b2dnbGVDb21wbGV0ZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdHRvSGlkZS5hdHRyKHtcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0fSk7XG5cdFx0dG9IaWRlLnByZXYoKS5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0Ly8gaWYgd2UncmUgc3dpdGNoaW5nIHBhbmVscywgcmVtb3ZlIHRoZSBvbGQgaGVhZGVyIGZyb20gdGhlIHRhYiBvcmRlclxuXHRcdC8vIGlmIHdlJ3JlIG9wZW5pbmcgZnJvbSBjb2xsYXBzZWQgc3RhdGUsIHJlbW92ZSB0aGUgcHJldmlvdXMgaGVhZGVyIGZyb20gdGhlIHRhYiBvcmRlclxuXHRcdC8vIGlmIHdlJ3JlIGNvbGxhcHNpbmcsIHRoZW4ga2VlcCB0aGUgY29sbGFwc2luZyBoZWFkZXIgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiB0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0dG9IaWRlLnByZXYoKS5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fSBlbHNlIGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMuaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICkgPT09IDA7XG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3dcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5wcmV2KClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0XHR9KTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24oIHRvU2hvdywgdG9IaWRlLCBkYXRhICkge1xuXHRcdHZhciB0b3RhbCwgZWFzaW5nLCBkdXJhdGlvbixcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0YWRqdXN0ID0gMCxcblx0XHRcdGRvd24gPSB0b1Nob3cubGVuZ3RoICYmXG5cdFx0XHRcdCggIXRvSGlkZS5sZW5ndGggfHwgKCB0b1Nob3cuaW5kZXgoKSA8IHRvSGlkZS5pbmRleCgpICkgKSxcblx0XHRcdGFuaW1hdGUgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZSB8fCB7fSxcblx0XHRcdG9wdGlvbnMgPSBkb3duICYmIGFuaW1hdGUuZG93biB8fCBhbmltYXRlLFxuXHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5fdG9nZ2xlQ29tcGxldGUoIGRhdGEgKTtcblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZWFzaW5nID0gb3B0aW9ucztcblx0XHR9XG5cdFx0Ly8gZmFsbCBiYWNrIGZyb20gb3B0aW9ucyB0byBhbmltYXRpb24gaW4gY2FzZSBvZiBwYXJ0aWFsIGRvd24gc2V0dGluZ3Ncblx0XHRlYXNpbmcgPSBlYXNpbmcgfHwgb3B0aW9ucy5lYXNpbmcgfHwgYW5pbWF0ZS5lYXNpbmc7XG5cdFx0ZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBvcHRpb25zLmR1cmF0aW9uIHx8IGFuaW1hdGUuZHVyYXRpb247XG5cblx0XHRpZiAoICF0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRvU2hvdy5hbmltYXRlKCBzaG93UHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlICk7XG5cdFx0fVxuXHRcdGlmICggIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdG9IaWRlLmFuaW1hdGUoIGhpZGVQcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUgKTtcblx0XHR9XG5cblx0XHR0b3RhbCA9IHRvU2hvdy5zaG93KCkub3V0ZXJIZWlnaHQoKTtcblx0XHR0b0hpZGUuYW5pbWF0ZSggaGlkZVByb3BzLCB7XG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCBub3csIGZ4ICkge1xuXHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCBub3cgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0b1Nob3dcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hbmltYXRlKCBzaG93UHJvcHMsIHtcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0Y29tcGxldGU6IGNvbXBsZXRlLFxuXHRcdFx0XHRzdGVwOiBmdW5jdGlvbiggbm93LCBmeCApIHtcblx0XHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCBub3cgKTtcblx0XHRcdFx0XHRpZiAoIGZ4LnByb3AgIT09IFwiaGVpZ2h0XCIgKSB7XG5cdFx0XHRcdFx0XHRhZGp1c3QgKz0gZngubm93O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoYXQub3B0aW9ucy5oZWlnaHRTdHlsZSAhPT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdFx0XHRmeC5ub3cgPSBNYXRoLnJvdW5kKCB0b3RhbCAtIHRvSGlkZS5vdXRlckhlaWdodCgpIC0gYWRqdXN0ICk7XG5cdFx0XHRcdFx0XHRhZGp1c3QgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cblx0X3RvZ2dsZUNvbXBsZXRlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgdG9IaWRlID0gZGF0YS5vbGRQYW5lbDtcblxuXHRcdHRvSGlkZVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiIClcblx0XHRcdC5wcmV2KClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci10b3BcIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIgKTtcblxuXHRcdC8vIFdvcmsgYXJvdW5kIGZvciByZW5kZXJpbmcgYnVnIGluIElFICgjNTQyMSlcblx0XHRpZiAoIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHR0b0hpZGUucGFyZW50KClbMF0uY2xhc3NOYW1lID0gdG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIG51bGwsIGRhdGEgKTtcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbi8vIHVzZWQgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnMgd2l0aCByZW1vdGUgZGF0YSBzb3VyY2VzXG52YXIgcmVxdWVzdEluZGV4ID0gMDtcblxuJC53aWRnZXQoIFwidWkuYXV0b2NvbXBsZXRlXCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjNcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGlucHV0PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YXBwZW5kVG86IG51bGwsXG5cdFx0YXV0b0ZvY3VzOiBmYWxzZSxcblx0XHRkZWxheTogMzAwLFxuXHRcdG1pbkxlbmd0aDogMSxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0bXk6IFwibGVmdCB0b3BcIixcblx0XHRcdGF0OiBcImxlZnQgYm90dG9tXCIsXG5cdFx0XHRjb2xsaXNpb246IFwibm9uZVwiXG5cdFx0fSxcblx0XHRzb3VyY2U6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0Zm9jdXM6IG51bGwsXG5cdFx0b3BlbjogbnVsbCxcblx0XHRyZXNwb25zZTogbnVsbCxcblx0XHRzZWFyY2g6IG51bGwsXG5cdFx0c2VsZWN0OiBudWxsXG5cdH0sXG5cblx0cGVuZGluZzogMCxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBTb21lIGJyb3dzZXJzIG9ubHkgcmVwZWF0IGtleWRvd24gZXZlbnRzLCBub3Qga2V5cHJlc3MgZXZlbnRzLFxuXHRcdC8vIHNvIHdlIHVzZSB0aGUgc3VwcHJlc3NLZXlQcmVzcyBmbGFnIHRvIGRldGVybWluZSBpZiB3ZSd2ZSBhbHJlYWR5XG5cdFx0Ly8gaGFuZGxlZCB0aGUga2V5ZG93biBldmVudC4gIzcyNjlcblx0XHQvLyBVbmZvcnR1bmF0ZWx5IHRoZSBjb2RlIGZvciAmIGluIGtleXByZXNzIGlzIHRoZSBzYW1lIGFzIHRoZSB1cCBhcnJvdyxcblx0XHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgZmxhZyB0byBhdm9pZCBoYW5kbGluZyBrZXlwcmVzc1xuXHRcdC8vIGV2ZW50cyB3aGVuIHdlIGtub3cgdGhlIGtleWRvd24gZXZlbnQgd2FzIHVzZWQgdG8gbW9kaWZ5IHRoZVxuXHRcdC8vIHNlYXJjaCB0ZXJtLiAjNzc5OVxuXHRcdHZhciBzdXBwcmVzc0tleVByZXNzLCBzdXBwcmVzc0tleVByZXNzUmVwZWF0LCBzdXBwcmVzc0lucHV0LFxuXHRcdFx0bm9kZU5hbWUgPSB0aGlzLmVsZW1lbnRbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzVGV4dGFyZWEgPSBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiLFxuXHRcdFx0aXNJbnB1dCA9IG5vZGVOYW1lID09PSBcImlucHV0XCI7XG5cblx0XHR0aGlzLmlzTXVsdGlMaW5lID1cblx0XHRcdC8vIFRleHRhcmVhcyBhcmUgYWx3YXlzIG11bHRpLWxpbmVcblx0XHRcdGlzVGV4dGFyZWEgPyB0cnVlIDpcblx0XHRcdC8vIElucHV0cyBhcmUgYWx3YXlzIHNpbmdsZS1saW5lLCBldmVuIGlmIGluc2lkZSBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG5cdFx0XHQvLyBJRSBhbHNvIHRyZWF0cyBpbnB1dHMgYXMgY29udGVudEVkaXRhYmxlXG5cdFx0XHRpc0lucHV0ID8gZmFsc2UgOlxuXHRcdFx0Ly8gQWxsIG90aGVyIGVsZW1lbnQgdHlwZXMgYXJlIGRldGVybWluZWQgYnkgd2hldGhlciBvciBub3QgdGhleSdyZSBjb250ZW50RWRpdGFibGVcblx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImlzQ29udGVudEVkaXRhYmxlXCIgKTtcblxuXHRcdHRoaXMudmFsdWVNZXRob2QgPSB0aGlzLmVsZW1lbnRbIGlzVGV4dGFyZWEgfHwgaXNJbnB1dCA/IFwidmFsXCIgOiBcInRleHRcIiBdO1xuXHRcdHRoaXMuaXNOZXdNZW51ID0gdHJ1ZTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFwiIClcblx0XHRcdC5hdHRyKCBcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTUqL1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5wcm9wKCBcInJlYWRPbmx5XCIgKSApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcblx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IGZhbHNlO1xuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHRjYXNlIGtleUNvZGUuTlVNUEFEX0VOVEVSOlxuXHRcdFx0XHRcdC8vIHdoZW4gbWVudSBpcyBvcGVuIGFuZCBoYXMgZm9jdXNcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5hY3RpdmUgKSB7XG5cdFx0XHRcdFx0XHQvLyAjNjA1NSAtIE9wZXJhIHN0aWxsIGFsbG93cyB0aGUga2V5cHJlc3MgdG8gb2NjdXJcblx0XHRcdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBmb3JtcyB0byBzdWJtaXRcblx0XHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuVEFCOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmFjdGl2ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRVNDQVBFOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWUoIHRoaXMudGVybSApO1xuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0XHRcdC8vIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBlc2NhcGVcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBwcmVzcyBjYW4gbWVhbiB1bmRvIG9yIGNsZWFyXG5cdFx0XHRcdFx0XHQvLyBEb3VibGUgcHJlc3MgaW4gSUUgbWVhbnMgY2xlYXIgdGhlIHdob2xlIGZvcm1cblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXHRcdFx0XHRcdC8vIHNlYXJjaCB0aW1lb3V0IHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGtleXByZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NLZXlQcmVzcyApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5pc011bHRpTGluZSB8fCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzdXBwcmVzc0tleVByZXNzUmVwZWF0ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlcGxpY2F0ZSBzb21lIGtleSBoYW5kbGVycyB0byBhbGxvdyB0aGVtIHRvIHJlcGVhdCBpbiBGaXJlZm94IGFuZCBPcGVyYVxuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlucHV0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NJbnB1dCApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gZmFsc2U7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuX3ZhbHVlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2FuY2VsQmx1ciApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5faW5pdFNvdXJjZSgpO1xuXHRcdHRoaXMubWVudSA9ICQoIFwiPHVsPlwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUgdWktZnJvbnRcIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKVxuXHRcdFx0Lm1lbnUoe1xuXHRcdFx0XHQvLyBkaXNhYmxlIEFSSUEgc3VwcG9ydCwgdGhlIGxpdmUgcmVnaW9uIHRha2VzIGNhcmUgb2YgdGhhdFxuXHRcdFx0XHRyb2xlOiBudWxsXG5cdFx0XHR9KVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmRhdGEoIFwidWktbWVudVwiICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5tZW51LmVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBwcmV2ZW50IG1vdmluZyBmb2N1cyBvdXQgb2YgdGhlIHRleHQgZmllbGRcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdC8vIHNvIHdlIHNldCBhIGZsYWcgdG8ga25vdyB3aGVuIHdlIHNob3VsZCBpZ25vcmUgdGhlIGJsdXIgZXZlbnRcblx0XHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gY2xpY2tpbmcgb24gdGhlIHNjcm9sbGJhciBjYXVzZXMgZm9jdXMgdG8gc2hpZnQgdG8gdGhlIGJvZHlcblx0XHRcdFx0Ly8gYnV0IHdlIGNhbid0IGRldGVjdCBhIG1vdXNldXAgb3IgYSBjbGljayBpbW1lZGlhdGVseSBhZnRlcndhcmRcblx0XHRcdFx0Ly8gc28gd2UgaGF2ZSB0byB0cmFjayB0aGUgbmV4dCBtb3VzZWRvd24gYW5kIGNsb3NlIHRoZSBtZW51IGlmXG5cdFx0XHRcdC8vIHRoZSB1c2VyIGNsaWNrcyBzb21ld2hlcmUgb3V0c2lkZSBvZiB0aGUgYXV0b2NvbXBsZXRlXG5cdFx0XHRcdHZhciBtZW51RWxlbWVudCA9IHRoaXMubWVudS5lbGVtZW50WyAwIF07XG5cdFx0XHRcdGlmICggISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5vbmUoIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgIT09IHRoYXQuZWxlbWVudFsgMCBdICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRldmVudC50YXJnZXQgIT09IG1lbnVFbGVtZW50ICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQhJC5jb250YWlucyggbWVudUVsZW1lbnQsIGV2ZW50LnRhcmdldCApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQuY2xvc2UoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtZW51Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdC8vIHN1cHBvcnQ6IEZpcmVmb3hcblx0XHRcdFx0Ly8gUHJldmVudCBhY2NpZGVudGFsIGFjdGl2YXRpb24gb2YgbWVudSBpdGVtcyBpbiBGaXJlZm94ICgjNzAyNCAjOTExOClcblx0XHRcdFx0aWYgKCB0aGlzLmlzTmV3TWVudSApIHtcblx0XHRcdFx0XHR0aGlzLmlzTmV3TWVudSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudCAmJiAvXm1vdXNlLy50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5ibHVyKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQub25lKCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkudHJpZ2dlciggZXZlbnQub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICkgKSB7XG5cdFx0XHRcdFx0Ly8gdXNlIHZhbHVlIHRvIG1hdGNoIHdoYXQgd2lsbCBlbmQgdXAgaW4gdGhlIGlucHV0LCBpZiBpdCB3YXMgYSBrZXkgZXZlbnRcblx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgL15rZXkvLnRlc3QoIGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWUoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTm9ybWFsbHkgdGhlIGlucHV0IGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBpdGVtJ3MgdmFsdWUgYXMgdGhlXG5cdFx0XHRcdFx0Ly8gbWVudSBpcyBuYXZpZ2F0ZWQsIGNhdXNpbmcgc2NyZWVuIHJlYWRlcnMgdG8gbm90aWNlIGEgY2hhbmdlIGFuZFxuXHRcdFx0XHRcdC8vIGFubm91bmNlIHRoZSBpdGVtLiBTaW5jZSB0aGUgZm9jdXMgZXZlbnQgd2FzIGNhbmNlbGVkLCB0aGlzIGRvZXNuJ3Rcblx0XHRcdFx0XHQvLyBoYXBwZW4sIHNvIHdlIHVwZGF0ZSB0aGUgbGl2ZSByZWdpb24gc28gdGhhdCBzY3JlZW4gcmVhZGVycyBjYW5cblx0XHRcdFx0XHQvLyBzdGlsbCBub3RpY2UgdGhlIGNoYW5nZSBhbmQgYW5ub3VuY2UgaXQuXG5cdFx0XHRcdFx0dGhpcy5saXZlUmVnaW9uLnRleHQoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1lbnVzZWxlY3Q6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdWkuaXRlbS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIgKSxcblx0XHRcdFx0XHRwcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG5cblx0XHRcdFx0Ly8gb25seSB0cmlnZ2VyIHdoZW4gZm9jdXMgd2FzIGxvc3QgKGNsaWNrIG9uIG1lbnUpXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdC8vICM2MTA5IC0gSUUgdHJpZ2dlcnMgdHdvIGZvY3VzIGV2ZW50cyBhbmQgdGhlIHNlY29uZFxuXHRcdFx0XHRcdC8vIGlzIGFzeW5jaHJvbm91cywgc28gd2UgbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXNcblx0XHRcdFx0XHQvLyB0ZXJtIHN5bmNocm9ub3VzbHkgYW5kIGFzeW5jaHJvbm91c2x5IDotKFxuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWUoIGl0ZW0udmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZXNldCB0aGUgdGVybSBhZnRlciB0aGUgc2VsZWN0IGV2ZW50XG5cdFx0XHRcdC8vIHRoaXMgYWxsb3dzIGN1c3RvbSBzZWxlY3QgaGFuZGxpbmcgdG8gd29yayBwcm9wZXJseVxuXHRcdFx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMubGl2ZVJlZ2lvbiA9ICQoIFwiPHNwYW4+XCIsIHtcblx0XHRcdFx0cm9sZTogXCJzdGF0dXNcIixcblx0XHRcdFx0XCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIlxuXHRcdFx0fSlcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApXG5cdFx0XHQuaW5zZXJ0QmVmb3JlKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdC8vIHR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxuXHRcdC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcblx0XHQvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMuc2VhcmNoaW5nICk7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWlucHV0XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHR0aGlzLm1lbnUuZWxlbWVudC5yZW1vdmUoKTtcblx0XHR0aGlzLmxpdmVSZWdpb24ucmVtb3ZlKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0XHRpZiAoIGtleSA9PT0gXCJzb3VyY2VcIiApIHtcblx0XHRcdHRoaXMuX2luaXRTb3VyY2UoKTtcblx0XHR9XG5cdFx0aWYgKCBrZXkgPT09IFwiYXBwZW5kVG9cIiApIHtcblx0XHRcdHRoaXMubWVudS5lbGVtZW50LmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpICk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgJiYgdmFsdWUgJiYgdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuXG5cdFx0aWYgKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgP1xuXHRcdFx0XHQkKCBlbGVtZW50ICkgOlxuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmZpbmQoIGVsZW1lbnQgKS5lcSggMCApO1xuXHRcdH1cblxuXHRcdGlmICggIWVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QoIFwiLnVpLWZyb250XCIgKTtcblx0XHR9XG5cblx0XHRpZiAoICFlbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmRvY3VtZW50WzBdLmJvZHk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0X2luaXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnJheSwgdXJsLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKCAkLmlzQXJyYXkodGhpcy5vcHRpb25zLnNvdXJjZSkgKSB7XG5cdFx0XHRhcnJheSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdFx0cmVzcG9uc2UoICQudWkuYXV0b2NvbXBsZXRlLmZpbHRlciggYXJyYXksIHJlcXVlc3QudGVybSApICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuc291cmNlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dXJsID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcblx0XHRcdHRoaXMuc291cmNlID0gZnVuY3Rpb24oIHJlcXVlc3QsIHJlc3BvbnNlICkge1xuXHRcdFx0XHRpZiAoIHRoYXQueGhyICkge1xuXHRcdFx0XHRcdHRoYXQueGhyLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhhdC54aHIgPSAkLmFqYXgoe1xuXHRcdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRcdGRhdGE6IHJlcXVlc3QsXG5cdFx0XHRcdFx0ZGF0YVR5cGU6IFwianNvblwiLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UoIGRhdGEgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBbXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWFyY2hUaW1lb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuc2VhcmNoaW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBvbmx5IHNlYXJjaCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcblx0XHRcdGlmICggdGhpcy50ZXJtICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuc2VhcmNoKCBudWxsLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSApO1xuXHR9LFxuXG5cdHNlYXJjaDogZnVuY3Rpb24oIHZhbHVlLCBldmVudCApIHtcblx0XHR2YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMuX3ZhbHVlKCk7XG5cblx0XHQvLyBhbHdheXMgc2F2ZSB0aGUgYWN0dWFsIHZhbHVlLCBub3QgdGhlIG9uZSBwYXNzZWQgYXMgYW4gYXJndW1lbnRcblx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0aWYgKCB2YWx1ZS5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWluTGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcInNlYXJjaFwiLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fc2VhcmNoKCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLnBlbmRpbmcrKztcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdHRoaXMuY2FuY2VsU2VhcmNoID0gZmFsc2U7XG5cblx0XHR0aGlzLnNvdXJjZSggeyB0ZXJtOiB2YWx1ZSB9LCB0aGlzLl9yZXNwb25zZSgpICk7XG5cdH0sXG5cblx0X3Jlc3BvbnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRpbmRleCA9ICsrcmVxdWVzdEluZGV4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gcmVxdWVzdEluZGV4ICkge1xuXHRcdFx0XHR0aGF0Ll9fcmVzcG9uc2UoIGNvbnRlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5wZW5kaW5nLS07XG5cdFx0XHRpZiAoICF0aGF0LnBlbmRpbmcgKSB7XG5cdFx0XHRcdHRoYXQuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtbG9hZGluZ1wiICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfX3Jlc3BvbnNlOiBmdW5jdGlvbiggY29udGVudCApIHtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHRjb250ZW50ID0gdGhpcy5fbm9ybWFsaXplKCBjb250ZW50ICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwicmVzcG9uc2VcIiwgbnVsbCwgeyBjb250ZW50OiBjb250ZW50IH0gKTtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCAmJiAhdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHR0aGlzLl9zdWdnZXN0KCBjb250ZW50ICk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB1c2UgLl9jbG9zZSgpIGluc3RlYWQgb2YgLmNsb3NlKCkgc28gd2UgZG9uJ3QgY2FuY2VsIGZ1dHVyZSBzZWFyY2hlc1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmNhbmNlbFNlYXJjaCA9IHRydWU7XG5cdFx0dGhpcy5fY2xvc2UoIGV2ZW50ICk7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5oaWRlKCk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHsgaXRlbTogdGhpcy5zZWxlY3RlZEl0ZW0gfSApO1xuXHRcdH1cblx0fSxcblxuXHRfbm9ybWFsaXplOiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0Ly8gYXNzdW1lIGFsbCBpdGVtcyBoYXZlIHRoZSByaWdodCBmb3JtYXQgd2hlbiB0aGUgZmlyc3QgaXRlbSBpcyBjb21wbGV0ZVxuXHRcdGlmICggaXRlbXMubGVuZ3RoICYmIGl0ZW1zWzBdLmxhYmVsICYmIGl0ZW1zWzBdLnZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5tYXAoIGl0ZW1zLCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGFiZWw6IGl0ZW0sXG5cdFx0XHRcdFx0dmFsdWU6IGl0ZW1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkLmV4dGVuZCh7XG5cdFx0XHRcdGxhYmVsOiBpdGVtLmxhYmVsIHx8IGl0ZW0udmFsdWUsXG5cdFx0XHRcdHZhbHVlOiBpdGVtLnZhbHVlIHx8IGl0ZW0ubGFiZWxcblx0XHRcdH0sIGl0ZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRfc3VnZ2VzdDogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdHZhciB1bCA9IHRoaXMubWVudS5lbGVtZW50LmVtcHR5KCk7XG5cdFx0dGhpcy5fcmVuZGVyTWVudSggdWwsIGl0ZW1zICk7XG5cdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdHRoaXMubWVudS5yZWZyZXNoKCk7XG5cblx0XHQvLyBzaXplIGFuZCBwb3NpdGlvbiBtZW51XG5cdFx0dWwuc2hvdygpO1xuXHRcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcblx0XHR1bC5wb3NpdGlvbiggJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuZWxlbWVudFxuXHRcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyApIHtcblx0XHRcdHRoaXMubWVudS5uZXh0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNpemVNZW51OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudDtcblx0XHR1bC5vdXRlcldpZHRoKCBNYXRoLm1heChcblx0XHRcdC8vIEZpcmVmb3ggd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1Zylcblx0XHRcdC8vIHNvIHdlIGFkZCAxcHggdG8gYXZvaWQgdGhlIHdyYXBwaW5nICgjNzUxMylcblx0XHRcdHVsLndpZHRoKCBcIlwiICkub3V0ZXJXaWR0aCgpICsgMSxcblx0XHRcdHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKClcblx0XHQpICk7XG5cdH0sXG5cblx0X3JlbmRlck1lbnU6IGZ1bmN0aW9uKCB1bCwgaXRlbXMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggaXRlbXMsIGZ1bmN0aW9uKCBpbmRleCwgaXRlbSApIHtcblx0XHRcdHRoYXQuX3JlbmRlckl0ZW1EYXRhKCB1bCwgaXRlbSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtRGF0YTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKCB1bCwgaXRlbSApLmRhdGEoIFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiwgaXRlbSApO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtOiBmdW5jdGlvbiggdWwsIGl0ZW0gKSB7XG5cdFx0cmV0dXJuICQoIFwiPGxpPlwiIClcblx0XHRcdC5hcHBlbmQoICQoIFwiPGE+XCIgKS50ZXh0KCBpdGVtLmxhYmVsICkgKVxuXHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm1lbnUuaXNGaXJzdEl0ZW0oKSAmJiAvXnByZXZpb3VzLy50ZXN0KCBkaXJlY3Rpb24gKSB8fFxuXHRcdFx0XHR0aGlzLm1lbnUuaXNMYXN0SXRlbSgpICYmIC9ebmV4dC8udGVzdCggZGlyZWN0aW9uICkgKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSggdGhpcy50ZXJtICk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm1lbnVbIGRpcmVjdGlvbiBdKCBldmVudCApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVudS5lbGVtZW50O1xuXHR9LFxuXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVNZXRob2QuYXBwbHkoIHRoaXMuZWxlbWVudCwgYXJndW1lbnRzICk7XG5cdH0sXG5cblx0X2tleUV2ZW50OiBmdW5jdGlvbigga2V5RXZlbnQsIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgfHwgdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5fbW92ZSgga2V5RXZlbnQsIGV2ZW50ICk7XG5cblx0XHRcdC8vIHByZXZlbnRzIG1vdmluZyBjdXJzb3IgdG8gYmVnaW5uaW5nL2VuZCBvZiB0aGUgdGV4dCBmaWVsZCBpbiBzb21lIGJyb3dzZXJzXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRlc2NhcGVSZWdleDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oYXJyYXksIHRlcm0pIHtcblx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoICQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KHRlcm0pLCBcImlcIiApO1xuXHRcdHJldHVybiAkLmdyZXAoIGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIG1hdGNoZXIudGVzdCggdmFsdWUubGFiZWwgfHwgdmFsdWUudmFsdWUgfHwgdmFsdWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuLy8gbGl2ZSByZWdpb24gZXh0ZW5zaW9uLCBhZGRpbmcgYSBgbWVzc2FnZXNgIG9wdGlvblxuLy8gTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJLiBXZSBhcmUgc3RpbGwgaW52ZXN0aWdhdGluZ1xuLy8gYSBmdWxsIHNvbHV0aW9uIGZvciBzdHJpbmcgbWFuaXB1bGF0aW9uIGFuZCBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiQud2lkZ2V0KCBcInVpLmF1dG9jb21wbGV0ZVwiLCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRvcHRpb25zOiB7XG5cdFx0bWVzc2FnZXM6IHtcblx0XHRcdG5vUmVzdWx0czogXCJObyBzZWFyY2ggcmVzdWx0cy5cIixcblx0XHRcdHJlc3VsdHM6IGZ1bmN0aW9uKCBhbW91bnQgKSB7XG5cdFx0XHRcdHJldHVybiBhbW91bnQgKyAoIGFtb3VudCA+IDEgPyBcIiByZXN1bHRzIGFyZVwiIDogXCIgcmVzdWx0IGlzXCIgKSArXG5cdFx0XHRcdFx0XCIgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cIjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0dmFyIG1lc3NhZ2U7XG5cdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMucmVzdWx0cyggY29udGVudC5sZW5ndGggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5ub1Jlc3VsdHM7XG5cdFx0fVxuXHRcdHRoaXMubGl2ZVJlZ2lvbi50ZXh0KCBtZXNzYWdlICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgbGFzdEFjdGl2ZSwgc3RhcnRYUG9zLCBzdGFydFlQb3MsIGNsaWNrRHJhZ2dlZCxcblx0YmFzZUNsYXNzZXMgPSBcInVpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIsXG5cdHN0YXRlQ2xhc3NlcyA9IFwidWktc3RhdGUtaG92ZXIgdWktc3RhdGUtYWN0aXZlIFwiLFxuXHR0eXBlQ2xhc3NlcyA9IFwidWktYnV0dG9uLWljb25zLW9ubHkgdWktYnV0dG9uLWljb24tb25seSB1aS1idXR0b24tdGV4dC1pY29ucyB1aS1idXR0b24tdGV4dC1pY29uLXByaW1hcnkgdWktYnV0dG9uLXRleHQtaWNvbi1zZWNvbmRhcnkgdWktYnV0dG9uLXRleHQtb25seVwiLFxuXHRmb3JtUmVzZXRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvcm0gPSAkKCB0aGlzICk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGZvcm0uZmluZCggXCI6dWktYnV0dG9uXCIgKS5idXR0b24oIFwicmVmcmVzaFwiICk7XG5cdFx0fSwgMSApO1xuXHR9LFxuXHRyYWRpb0dyb3VwID0gZnVuY3Rpb24oIHJhZGlvICkge1xuXHRcdHZhciBuYW1lID0gcmFkaW8ubmFtZSxcblx0XHRcdGZvcm0gPSByYWRpby5mb3JtLFxuXHRcdFx0cmFkaW9zID0gJCggW10gKTtcblx0XHRpZiAoIG5hbWUgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCAvJy9nLCBcIlxcXFwnXCIgKTtcblx0XHRcdGlmICggZm9ybSApIHtcblx0XHRcdFx0cmFkaW9zID0gJCggZm9ybSApLmZpbmQoIFwiW25hbWU9J1wiICsgbmFtZSArIFwiJ11cIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmFkaW9zID0gJCggXCJbbmFtZT0nXCIgKyBuYW1lICsgXCInXVwiLCByYWRpby5vd25lckRvY3VtZW50IClcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICF0aGlzLmZvcm07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByYWRpb3M7XG5cdH07XG5cbiQud2lkZ2V0KCBcInVpLmJ1dHRvblwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxidXR0b24+XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRkaXNhYmxlZDogbnVsbCxcblx0XHR0ZXh0OiB0cnVlLFxuXHRcdGxhYmVsOiBudWxsLFxuXHRcdGljb25zOiB7XG5cdFx0XHRwcmltYXJ5OiBudWxsLFxuXHRcdFx0c2Vjb25kYXJ5OiBudWxsXG5cdFx0fVxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCJmb3JtXCIgKVxuXHRcdFx0LnVuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQuYmluZCggXCJyZXNldFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZm9ybVJlc2V0SGFuZGxlciApO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9ICEhdGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRlcm1pbmVCdXR0b25UeXBlKCk7XG5cdFx0dGhpcy5oYXNUaXRsZSA9ICEhdGhpcy5idXR0b25FbGVtZW50LmF0dHIoIFwidGl0bGVcIiApO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRvZ2dsZUJ1dHRvbiA9IHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiLFxuXHRcdFx0YWN0aXZlQ2xhc3MgPSAhdG9nZ2xlQnV0dG9uID8gXCJ1aS1zdGF0ZS1hY3RpdmVcIiA6IFwiXCIsXG5cdFx0XHRmb2N1c0NsYXNzID0gXCJ1aS1zdGF0ZS1mb2N1c1wiO1xuXG5cdFx0aWYgKCBvcHRpb25zLmxhYmVsID09PSBudWxsICkge1xuXHRcdFx0b3B0aW9ucy5sYWJlbCA9ICh0aGlzLnR5cGUgPT09IFwiaW5wdXRcIiA/IHRoaXMuYnV0dG9uRWxlbWVudC52YWwoKSA6IHRoaXMuYnV0dG9uRWxlbWVudC5odG1sKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hvdmVyYWJsZSggdGhpcy5idXR0b25FbGVtZW50ICk7XG5cblx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggYmFzZUNsYXNzZXMgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcImJ1dHRvblwiIClcblx0XHRcdC5iaW5kKCBcIm1vdXNlZW50ZXJcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gbGFzdEFjdGl2ZSApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCBcIm1vdXNlbGVhdmVcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggYWN0aXZlQ2xhc3MgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKCBcImZvY3VzXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gbm8gbmVlZCB0byBjaGVjayBkaXNhYmxlZCwgZm9jdXMgd29uJ3QgYmUgdHJpZ2dlcmVkIGFueXdheVxuXHRcdFx0XHR0aGF0LmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoIGZvY3VzQ2xhc3MgKTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJibHVyXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKCBmb2N1c0NsYXNzICk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggdG9nZ2xlQnV0dG9uICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmJpbmQoIFwiY2hhbmdlXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjbGlja0RyYWdnZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBpZiBtb3VzZSBtb3ZlcyBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cCAoZHJhZykgc2V0IGNsaWNrRHJhZ2dlZCBmbGFnXG5cdFx0XHQvLyBwcmV2ZW50cyBpc3N1ZSB3aGVyZSBidXR0b24gc3RhdGUgY2hhbmdlcyBidXQgY2hlY2tib3gvcmFkaW8gY2hlY2tlZCBzdGF0ZVxuXHRcdFx0Ly8gZG9lcyBub3QgaW4gRmlyZWZveCAoc2VlIHRpY2tldCAjNjk3MClcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHQuYmluZCggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNsaWNrRHJhZ2dlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHN0YXJ0WFBvcyA9IGV2ZW50LnBhZ2VYO1xuXHRcdFx0XHRcdHN0YXJ0WVBvcyA9IGV2ZW50LnBhZ2VZO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJtb3VzZXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHN0YXJ0WFBvcyAhPT0gZXZlbnQucGFnZVggfHwgc3RhcnRZUG9zICE9PSBldmVudC5wYWdlWSApIHtcblx0XHRcdFx0XHRcdGNsaWNrRHJhZ2dlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiApIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKCBcImNsaWNrXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkIHx8IGNsaWNrRHJhZ2dlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmJpbmQoIFwiY2xpY2tcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgfHwgY2xpY2tEcmFnZ2VkICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdFx0dmFyIHJhZGlvID0gdGhhdC5lbGVtZW50WyAwIF07XG5cdFx0XHRcdHJhZGlvR3JvdXAoIHJhZGlvIClcblx0XHRcdFx0XHQubm90KCByYWRpbyApXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHQuYmluZCggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0bGFzdEFjdGl2ZSA9IHRoaXM7XG5cdFx0XHRcdFx0dGhhdC5kb2N1bWVudC5vbmUoIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmUgPSBudWxsO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJtb3VzZXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJrZXlkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UgfHwgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVOVEVSICkge1xuXHRcdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQvLyBzZWUgIzg1NTksIHdlIGJpbmQgdG8gYmx1ciBoZXJlIGluIGNhc2UgdGhlIGJ1dHRvbiBlbGVtZW50IGxvc2VzXG5cdFx0XHRcdC8vIGZvY3VzIGJldHdlZW4ga2V5ZG93biBhbmQga2V5dXAsIGl0IHdvdWxkIGJlIGxlZnQgaW4gYW4gXCJhY3RpdmVcIiBzdGF0ZVxuXHRcdFx0XHQuYmluZCggXCJrZXl1cFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIGJsdXJcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0aWYgKCB0aGlzLmJ1dHRvbkVsZW1lbnQuaXMoXCJhXCIpICkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQua2V5dXAoZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5TUEFDRSApIHtcblx0XHRcdFx0XHRcdC8vIFRPRE8gcGFzcyB0aHJvdWdoIG9yaWdpbmFsIGV2ZW50IGNvcnJlY3RseSAoanVzdCBhcyAybmQgYXJndW1lbnQgZG9lc24ndCB3b3JrKVxuXHRcdFx0XHRcdFx0JCggdGhpcyApLmNsaWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBwdWxsIG91dCAkLldpZGdldCdzIGhhbmRsaW5nIGZvciB0aGUgZGlzYWJsZWQgb3B0aW9uIGludG9cblx0XHQvLyAkLldpZGdldC5wcm90b3R5cGUuX3NldE9wdGlvbkRpc2FibGVkIHNvIGl0J3MgZWFzeSB0byBwcm94eSBhbmQgY2FuXG5cdFx0Ly8gYmUgb3ZlcnJpZGRlbiBieSBpbmRpdmlkdWFsIHBsdWdpbnNcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgb3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdHRoaXMuX3Jlc2V0QnV0dG9uKCk7XG5cdH0sXG5cblx0X2RldGVybWluZUJ1dHRvblR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmNlc3RvciwgbGFiZWxTZWxlY3RvciwgY2hlY2tlZDtcblxuXHRcdGlmICggdGhpcy5lbGVtZW50LmlzKFwiW3R5cGU9Y2hlY2tib3hdXCIpICkge1xuXHRcdFx0dGhpcy50eXBlID0gXCJjaGVja2JveFwiO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZWxlbWVudC5pcyhcIlt0eXBlPXJhZGlvXVwiKSApIHtcblx0XHRcdHRoaXMudHlwZSA9IFwicmFkaW9cIjtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmVsZW1lbnQuaXMoXCJpbnB1dFwiKSApIHtcblx0XHRcdHRoaXMudHlwZSA9IFwiaW5wdXRcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50eXBlID0gXCJidXR0b25cIjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0Ly8gd2UgZG9uJ3Qgc2VhcmNoIGFnYWluc3QgdGhlIGRvY3VtZW50IGluIGNhc2UgdGhlIGVsZW1lbnRcblx0XHRcdC8vIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET01cblx0XHRcdGFuY2VzdG9yID0gdGhpcy5lbGVtZW50LnBhcmVudHMoKS5sYXN0KCk7XG5cdFx0XHRsYWJlbFNlbGVjdG9yID0gXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5lbGVtZW50LmF0dHIoXCJpZFwiKSArIFwiJ11cIjtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudCA9IGFuY2VzdG9yLmZpbmQoIGxhYmVsU2VsZWN0b3IgKTtcblx0XHRcdGlmICggIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IubGVuZ3RoID8gYW5jZXN0b3Iuc2libGluZ3MoKSA6IHRoaXMuZWxlbWVudC5zaWJsaW5ncygpO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maWx0ZXIoIGxhYmVsU2VsZWN0b3IgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKCBsYWJlbFNlbGVjdG9yICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApO1xuXG5cdFx0XHRjaGVja2VkID0gdGhpcy5lbGVtZW50LmlzKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdGlmICggY2hlY2tlZCApIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQucHJvcCggXCJhcmlhLXByZXNzZWRcIiwgY2hlY2tlZCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYnV0dG9uRWxlbWVudDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKTtcblx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggYmFzZUNsYXNzZXMgKyBcIiBcIiArIHN0YXRlQ2xhc3NlcyArIFwiIFwiICsgdHlwZUNsYXNzZXMgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtcHJlc3NlZFwiIClcblx0XHRcdC5odG1sKCB0aGlzLmJ1dHRvbkVsZW1lbnQuZmluZChcIi51aS1idXR0b24tdGV4dFwiKS5odG1sKCkgKTtcblxuXHRcdGlmICggIXRoaXMuaGFzVGl0bGUgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQXR0ciggXCJ0aXRsZVwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIsIHRydWUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX3Jlc2V0QnV0dG9uKCk7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0Ly9TZWUgIzgyMzcgJiAjODgyOFxuXHRcdHZhciBpc0Rpc2FibGVkID0gdGhpcy5lbGVtZW50LmlzKCBcImlucHV0LCBidXR0b25cIiApID8gdGhpcy5lbGVtZW50LmlzKCBcIjpkaXNhYmxlZFwiICkgOiB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoIFwidWktYnV0dG9uLWRpc2FibGVkXCIgKTtcblxuXHRcdGlmICggaXNEaXNhYmxlZCAhPT0gdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIGlzRGlzYWJsZWQgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdHJhZGlvR3JvdXAoIHRoaXMuZWxlbWVudFswXSApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmlzKCBcIjpjaGVja2VkXCIgKSApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuaXMoIFwiOmNoZWNrZWRcIiApICkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5idXR0b25FbGVtZW50XG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEJ1dHRvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxhYmVsICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQudmFsKCB0aGlzLm9wdGlvbnMubGFiZWwgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGJ1dHRvbkVsZW1lbnQgPSB0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3MoIHR5cGVDbGFzc2VzICksXG5cdFx0XHRidXR0b25UZXh0ID0gJCggXCI8c3Bhbj48L3NwYW4+XCIsIHRoaXMuZG9jdW1lbnRbMF0gKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktYnV0dG9uLXRleHRcIiApXG5cdFx0XHRcdC5odG1sKCB0aGlzLm9wdGlvbnMubGFiZWwgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGJ1dHRvbkVsZW1lbnQuZW1wdHkoKSApXG5cdFx0XHRcdC50ZXh0KCksXG5cdFx0XHRpY29ucyA9IHRoaXMub3B0aW9ucy5pY29ucyxcblx0XHRcdG11bHRpcGxlSWNvbnMgPSBpY29ucy5wcmltYXJ5ICYmIGljb25zLnNlY29uZGFyeSxcblx0XHRcdGJ1dHRvbkNsYXNzZXMgPSBbXTtcblxuXHRcdGlmICggaWNvbnMucHJpbWFyeSB8fCBpY29ucy5zZWNvbmRhcnkgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy50ZXh0ICkge1xuXHRcdFx0XHRidXR0b25DbGFzc2VzLnB1c2goIFwidWktYnV0dG9uLXRleHQtaWNvblwiICsgKCBtdWx0aXBsZUljb25zID8gXCJzXCIgOiAoIGljb25zLnByaW1hcnkgPyBcIi1wcmltYXJ5XCIgOiBcIi1zZWNvbmRhcnlcIiApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpY29ucy5wcmltYXJ5ICkge1xuXHRcdFx0XHRidXR0b25FbGVtZW50LnByZXBlbmQoIFwiPHNwYW4gY2xhc3M9J3VpLWJ1dHRvbi1pY29uLXByaW1hcnkgdWktaWNvbiBcIiArIGljb25zLnByaW1hcnkgKyBcIic+PC9zcGFuPlwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaWNvbnMuc2Vjb25kYXJ5ICkge1xuXHRcdFx0XHRidXR0b25FbGVtZW50LmFwcGVuZCggXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tc2Vjb25kYXJ5IHVpLWljb24gXCIgKyBpY29ucy5zZWNvbmRhcnkgKyBcIic+PC9zcGFuPlwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy50ZXh0ICkge1xuXHRcdFx0XHRidXR0b25DbGFzc2VzLnB1c2goIG11bHRpcGxlSWNvbnMgPyBcInVpLWJ1dHRvbi1pY29ucy1vbmx5XCIgOiBcInVpLWJ1dHRvbi1pY29uLW9ubHlcIiApO1xuXG5cdFx0XHRcdGlmICggIXRoaXMuaGFzVGl0bGUgKSB7XG5cdFx0XHRcdFx0YnV0dG9uRWxlbWVudC5hdHRyKCBcInRpdGxlXCIsICQudHJpbSggYnV0dG9uVGV4dCApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YnV0dG9uQ2xhc3Nlcy5wdXNoKCBcInVpLWJ1dHRvbi10ZXh0LW9ubHlcIiApO1xuXHRcdH1cblx0XHRidXR0b25FbGVtZW50LmFkZENsYXNzKCBidXR0b25DbGFzc2VzLmpvaW4oIFwiIFwiICkgKTtcblx0fVxufSk7XG5cbiQud2lkZ2V0KCBcInVpLmJ1dHRvbnNldFwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRpdGVtczogXCJidXR0b24sIGlucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPXJlc2V0XSwgaW5wdXRbdHlwZT1jaGVja2JveF0sIGlucHV0W3R5cGU9cmFkaW9dLCBhLCA6ZGF0YSh1aS1idXR0b24pXCJcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIFwidWktYnV0dG9uc2V0XCIgKTtcblx0fSxcblxuXHRfaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMuYnV0dG9ucy5idXR0b24oIFwib3B0aW9uXCIsIGtleSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBydGwgPSB0aGlzLmVsZW1lbnQuY3NzKCBcImRpcmVjdGlvblwiICkgPT09IFwicnRsXCI7XG5cblx0XHR0aGlzLmJ1dHRvbnMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zIClcblx0XHRcdC5maWx0ZXIoIFwiOnVpLWJ1dHRvblwiIClcblx0XHRcdFx0LmJ1dHRvbiggXCJyZWZyZXNoXCIgKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQubm90KCBcIjp1aS1idXR0b25cIiApXG5cdFx0XHRcdC5idXR0b24oKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmJ1dHRvbiggXCJ3aWRnZXRcIiApWyAwIF07XG5cdFx0XHR9KVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWFsbCB1aS1jb3JuZXItbGVmdCB1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHRcdC5maWx0ZXIoIFwiOmZpcnN0XCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggcnRsID8gXCJ1aS1jb3JuZXItcmlnaHRcIiA6IFwidWktY29ybmVyLWxlZnRcIiApXG5cdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHQuZmlsdGVyKCBcIjpsYXN0XCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggcnRsID8gXCJ1aS1jb3JuZXItbGVmdFwiIDogXCJ1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHRcdC5lbmQoKVxuXHRcdFx0LmVuZCgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktYnV0dG9uc2V0XCIgKTtcblx0XHR0aGlzLmJ1dHRvbnNcblx0XHRcdC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdH0pXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItbGVmdCB1aS1jb3JuZXItcmlnaHRcIiApXG5cdFx0XHQuZW5kKClcblx0XHRcdC5idXR0b24oIFwiZGVzdHJveVwiICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5leHRlbmQoJC51aSwgeyBkYXRlcGlja2VyOiB7IHZlcnNpb246IFwiMS4xMC4zXCIgfSB9KTtcblxudmFyIFBST1BfTkFNRSA9IFwiZGF0ZXBpY2tlclwiLFxuXHRpbnN0QWN0aXZlO1xuXG4vKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxuICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cbiAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXG5cbmZ1bmN0aW9uIERhdGVwaWNrZXIoKSB7XG5cdHRoaXMuX2N1ckluc3QgPSBudWxsOyAvLyBUaGUgY3VycmVudCBpbnN0YW5jZSBpbiB1c2Vcblx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XG5cdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gW107IC8vIExpc3Qgb2YgZGF0ZSBwaWNrZXIgaW5wdXRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG5cdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIHBvcHVwIHBpY2tlciBpcyBzaG93aW5nICwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcImRpYWxvZ1wiLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5fbWFpbkRpdklkID0gXCJ1aS1kYXRlcGlja2VyLWRpdlwiOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxuXHR0aGlzLl9pbmxpbmVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1pbmxpbmVcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGlubGluZSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fYXBwZW5kQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItYXBwZW5kXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBhcHBlbmQgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3RyaWdnZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci10cmlnZ2VyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaWFsb2dDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaWFsb2dcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpYWxvZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlzYWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRpc2FibGVkXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaXNhYmxlZCBjb3ZlcmluZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdW5zZWxlY3RhYmxlXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fY3VycmVudENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5XCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGRheSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGF5T3ZlckNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkYXkgaG92ZXIgbWFya2VyIGNsYXNzXG5cdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0dGhpcy5yZWdpb25hbFtcIlwiXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xuXHRcdGNsb3NlVGV4dDogXCJEb25lXCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY2xvc2UgbGlua1xuXHRcdHByZXZUZXh0OiBcIlByZXZcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBwcmV2aW91cyBtb250aCBsaW5rXG5cdFx0bmV4dFRleHQ6IFwiTmV4dFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIG5leHQgbW9udGggbGlua1xuXHRcdGN1cnJlbnRUZXh0OiBcIlRvZGF5XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY3VycmVudCBtb250aCBsaW5rXG5cdFx0bW9udGhOYW1lczogW1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXG5cdFx0XHRcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl0sIC8vIE5hbWVzIG9mIG1vbnRocyBmb3IgZHJvcC1kb3duIGFuZCBmb3JtYXR0aW5nXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc01pbjogW1wiU3VcIixcIk1vXCIsXCJUdVwiLFwiV2VcIixcIlRoXCIsXCJGclwiLFwiU2FcIl0sIC8vIENvbHVtbiBoZWFkaW5ncyBmb3IgZGF5cyBzdGFydGluZyBhdCBTdW5kYXlcblx0XHR3ZWVrSGVhZGVyOiBcIldrXCIsIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcblx0XHRkYXRlRm9ybWF0OiBcIm1tL2RkL3l5XCIsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcblx0XHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXG5cdFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxuXHRcdHllYXJTdWZmaXg6IFwiXCIgLy8gQWRkaXRpb25hbCB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgeWVhciBpbiB0aGUgbW9udGggaGVhZGVyc1xuXHR9O1xuXHR0aGlzLl9kZWZhdWx0cyA9IHsgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGUgcGlja2VyIGluc3RhbmNlc1xuXHRcdHNob3dPbjogXCJmb2N1c1wiLCAvLyBcImZvY3VzXCIgZm9yIHBvcHVwIG9uIGZvY3VzLFxuXHRcdFx0Ly8gXCJidXR0b25cIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFwiYm90aFwiIGZvciBlaXRoZXJcblx0XHRzaG93QW5pbTogXCJmYWRlSW5cIiwgLy8gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cFxuXHRcdHNob3dPcHRpb25zOiB7fSwgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xuXHRcdGRlZmF1bHREYXRlOiBudWxsLCAvLyBVc2VkIHdoZW4gZmllbGQgaXMgYmxhbms6IGFjdHVhbCBkYXRlLFxuXHRcdFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcblx0XHRhcHBlbmRUZXh0OiBcIlwiLCAvLyBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0XG5cdFx0YnV0dG9uVGV4dDogXCIuLi5cIiwgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cblx0XHRidXR0b25JbWFnZTogXCJcIiwgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxuXHRcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cblx0XHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3Ncblx0XHRcdC8vIGlmIG5vdCBhcHBsaWNhYmxlLCBmYWxzZSB0byBqdXN0IGRpc2FibGUgdGhlbVxuXHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQ6IGZhbHNlLCAvLyBUcnVlIGlmIGRhdGUgZm9ybWF0dGluZyBhcHBsaWVkIHRvIHByZXYvdG9kYXkvbmV4dCBsaW5rc1xuXHRcdGdvdG9DdXJyZW50OiBmYWxzZSwgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXG5cdFx0Y2hhbmdlTW9udGg6IGZhbHNlLCAvLyBUcnVlIGlmIG1vbnRoIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHRjaGFuZ2VZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB5ZWFyIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHR5ZWFyUmFuZ2U6IFwiYy0xMDpjKzEwXCIsIC8vIFJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXkgaW4gZHJvcC1kb3duLFxuXHRcdFx0Ly8gZWl0aGVyIHJlbGF0aXZlIHRvIHRvZGF5J3MgeWVhciAoLW5uOitubiksIHJlbGF0aXZlIHRvIGN1cnJlbnRseSBkaXNwbGF5ZWQgeWVhclxuXHRcdFx0Ly8gKGMtbm46YytubiksIGFic29sdXRlIChubm5uOm5ubm4pLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZSAobm5ubjotbilcblx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSB0byBsZWF2ZSBibGFua1xuXHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSBmb3IgdW5zZWxlY3RhYmxlXG5cdFx0c2hvd1dlZWs6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgd2VlayBvZiB0aGUgeWVhciwgZmFsc2UgdG8gbm90IHNob3cgaXRcblx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLmlzbzg2MDFXZWVrLCAvLyBIb3cgdG8gY2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyLFxuXHRcdFx0Ly8gdGFrZXMgYSBEYXRlIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgZm9yIGl0XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmOiBcIisxMFwiLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXG5cdFx0XHQvLyA+IHRoaXMgYXJlIGluIHRoZSBwcmV2aW91cyBjZW50dXJ5LFxuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIHN0YXJ0aW5nIHdpdGggXCIrXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXG5cdFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRkdXJhdGlvbjogXCJmYXN0XCIsIC8vIER1cmF0aW9uIG9mIGRpc3BsYXkvY2xvc3VyZVxuXHRcdGJlZm9yZVNob3dEYXk6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGhcblx0XHRcdC8vIFswXSA9IHRydWUgaWYgc2VsZWN0YWJsZSwgZmFsc2UgaWYgbm90LCBbMV0gPSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUocykgb3IgXCJcIixcblx0XHRcdC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xuXHRcdGJlZm9yZVNob3c6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5wdXQgZmllbGQgYW5kXG5cdFx0XHQvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXG5cdFx0b25TZWxlY3Q6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIG1vbnRoIG9yIHllYXIgaXMgY2hhbmdlZFxuXHRcdG9uQ2xvc2U6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXG5cdFx0bnVtYmVyT2ZNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc2hvdyBhdCBhIHRpbWVcblx0XHRzaG93Q3VycmVudEF0UG9zOiAwLCAvLyBUaGUgcG9zaXRpb24gaW4gbXVsdGlwZSBtb250aHMgYXQgd2hpY2ggdG8gc2hvdyB0aGUgY3VycmVudCBtb250aCAoc3RhcnRpbmcgYXQgMClcblx0XHRzdGVwTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXG5cdFx0c3RlcEJpZ01vbnRoczogMTIsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmQgZm9yIHRoZSBiaWcgbGlua3Ncblx0XHRhbHRGaWVsZDogXCJcIiwgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXG5cdFx0YWx0Rm9ybWF0OiBcIlwiLCAvLyBUaGUgZGF0ZSBmb3JtYXQgdG8gdXNlIGZvciB0aGUgYWx0ZXJuYXRlIGZpZWxkXG5cdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsIC8vIFRoZSBpbnB1dCBpcyBjb25zdHJhaW5lZCBieSB0aGUgY3VycmVudCBkYXRlIGZvcm1hdFxuXHRcdHNob3dCdXR0b25QYW5lbDogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyBidXR0b24gcGFuZWwsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0YXV0b1NpemU6IGZhbHNlLCAvLyBUcnVlIHRvIHNpemUgdGhlIGlucHV0IGZvciB0aGUgZGF0ZSBmb3JtYXQsIGZhbHNlIHRvIGxlYXZlIGFzIGlzXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlIC8vIFRoZSBpbml0aWFsIGRpc2FibGVkIHN0YXRlXG5cdH07XG5cdCQuZXh0ZW5kKHRoaXMuX2RlZmF1bHRzLCB0aGlzLnJlZ2lvbmFsW1wiXCJdKTtcblx0dGhpcy5kcERpdiA9IGJpbmRIb3ZlcigkKFwiPGRpdiBpZD0nXCIgKyB0aGlzLl9tYWluRGl2SWQgKyBcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIikpO1xufVxuXG4kLmV4dGVuZChEYXRlcGlja2VyLnByb3RvdHlwZSwge1xuXHQvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXG5cdG1hcmtlckNsYXNzTmFtZTogXCJoYXNEYXRlcGlja2VyXCIsXG5cblx0Ly9LZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRtYXhSb3dzOiA0LFxuXG5cdC8vIFRPRE8gcmVuYW1lIHRvIFwid2lkZ2V0XCIgd2hlbiBzd2l0Y2hpbmcgdG8gd2lkZ2V0IGZhY3Rvcnlcblx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRwRGl2O1xuXHR9LFxuXG5cdC8qIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBkYXRlIHBpY2tlci5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0XHRleHRlbmRSZW1vdmUodGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgZm9yIHRoaXMgZGF0ZSBwaWNrZXIgaW5zdGFuY2UgKGFub255bW91cylcblx0ICovXG5cdF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsIGluc3Q7XG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpbmxpbmUgPSAobm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiKTtcblx0XHRpZiAoIXRhcmdldC5pZCkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHR0YXJnZXQuaWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdGluc3QgPSB0aGlzLl9uZXdJbnN0KCQodGFyZ2V0KSwgaW5saW5lKTtcblx0XHRpbnN0LnNldHRpbmdzID0gJC5leHRlbmQoe30sIHNldHRpbmdzIHx8IHt9KTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGhpcy5fY29ubmVjdERhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9IGVsc2UgaWYgKGlubGluZSkge1xuXHRcdFx0dGhpcy5faW5saW5lRGF0ZXBpY2tlcih0YXJnZXQsIGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0LiAqL1xuXHRfbmV3SW5zdDogZnVuY3Rpb24odGFyZ2V0LCBpbmxpbmUpIHtcblx0XHR2YXIgaWQgPSB0YXJnZXRbMF0uaWQucmVwbGFjZSgvKFteQS1aYS16MC05X1xcLV0pL2csIFwiXFxcXFxcXFwkMVwiKTsgLy8gZXNjYXBlIGpRdWVyeSBtZXRhIGNoYXJzXG5cdFx0cmV0dXJuIHtpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XG5cdFx0XHRzZWxlY3RlZERheTogMCwgc2VsZWN0ZWRNb250aDogMCwgc2VsZWN0ZWRZZWFyOiAwLCAvLyBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ZHJhd01vbnRoOiAwLCBkcmF3WWVhcjogMCwgLy8gbW9udGggYmVpbmcgZHJhd25cblx0XHRcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3Rcblx0XHRcdGRwRGl2OiAoIWlubGluZSA/IHRoaXMuZHBEaXYgOiAvLyBwcmVzZW50YXRpb24gZGl2XG5cdFx0XHRiaW5kSG92ZXIoJChcIjxkaXYgY2xhc3M9J1wiICsgdGhpcy5faW5saW5lQ2xhc3MgKyBcIiB1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIpKSl9O1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYW4gaW5wdXQgZmllbGQuICovXG5cdF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBpbnN0KSB7XG5cdFx0dmFyIGlucHV0ID0gJCh0YXJnZXQpO1xuXHRcdGluc3QuYXBwZW5kID0gJChbXSk7XG5cdFx0aW5zdC50cmlnZ2VyID0gJChbXSk7XG5cdFx0aWYgKGlucHV0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hdHRhY2htZW50cyhpbnB1dCwgaW5zdCk7XG5cdFx0aW5wdXQuYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmtleWRvd24odGhpcy5fZG9LZXlEb3duKS5cblx0XHRcdGtleXByZXNzKHRoaXMuX2RvS2V5UHJlc3MpLmtleXVwKHRoaXMuX2RvS2V5VXApO1xuXHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdCQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogTWFrZSBhdHRhY2htZW50cyBiYXNlZCBvbiBzZXR0aW5ncy4gKi9cblx0X2F0dGFjaG1lbnRzOiBmdW5jdGlvbihpbnB1dCwgaW5zdCkge1xuXHRcdHZhciBzaG93T24sIGJ1dHRvblRleHQsIGJ1dHRvbkltYWdlLFxuXHRcdFx0YXBwZW5kVGV4dCA9IHRoaXMuX2dldChpbnN0LCBcImFwcGVuZFRleHRcIiksXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpO1xuXG5cdFx0aWYgKGluc3QuYXBwZW5kKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZFRleHQpIHtcblx0XHRcdGluc3QuYXBwZW5kID0gJChcIjxzcGFuIGNsYXNzPSdcIiArIHRoaXMuX2FwcGVuZENsYXNzICsgXCInPlwiICsgYXBwZW5kVGV4dCArIFwiPC9zcGFuPlwiKTtcblx0XHRcdGlucHV0W2lzUlRMID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIl0oaW5zdC5hcHBlbmQpO1xuXHRcdH1cblxuXHRcdGlucHV0LnVuYmluZChcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblxuXHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRzaG93T24gPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93T25cIik7XG5cdFx0aWYgKHNob3dPbiA9PT0gXCJmb2N1c1wiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIpIHsgLy8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gaW4gdGhlIG1hcmtlZCBmaWVsZFxuXHRcdFx0aW5wdXQuZm9jdXModGhpcy5fc2hvd0RhdGVwaWNrZXIpO1xuXHRcdH1cblx0XHRpZiAoc2hvd09uID09PSBcImJ1dHRvblwiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIpIHsgLy8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gYnV0dG9uIGNsaWNrZWRcblx0XHRcdGJ1dHRvblRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJidXR0b25UZXh0XCIpO1xuXHRcdFx0YnV0dG9uSW1hZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJidXR0b25JbWFnZVwiKTtcblx0XHRcdGluc3QudHJpZ2dlciA9ICQodGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uSW1hZ2VPbmx5XCIpID9cblx0XHRcdFx0JChcIjxpbWcvPlwiKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpLlxuXHRcdFx0XHRcdGF0dHIoeyBzcmM6IGJ1dHRvbkltYWdlLCBhbHQ6IGJ1dHRvblRleHQsIHRpdGxlOiBidXR0b25UZXh0IH0pIDpcblx0XHRcdFx0JChcIjxidXR0b24gdHlwZT0nYnV0dG9uJz48L2J1dHRvbj5cIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRodG1sKCFidXR0b25JbWFnZSA/IGJ1dHRvblRleHQgOiAkKFwiPGltZy8+XCIpLmF0dHIoXG5cdFx0XHRcdFx0eyBzcmM6YnV0dG9uSW1hZ2UsIGFsdDpidXR0b25UZXh0LCB0aXRsZTpidXR0b25UZXh0IH0pKSk7XG5cdFx0XHRpbnB1dFtpc1JUTCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCJdKGluc3QudHJpZ2dlcik7XG5cdFx0XHRpbnN0LnRyaWdnZXIuY2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dFswXSkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0fSBlbHNlIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFswXSkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9hdXRvU2l6ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgXCJhdXRvU2l6ZVwiKSAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHZhciBmaW5kTWF4LCBtYXgsIG1heEksIGksXG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgyMDA5LCAxMiAtIDEsIDIwKSwgLy8gRW5zdXJlIGRvdWJsZSBkaWdpdHNcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIik7XG5cblx0XHRcdGlmIChkYXRlRm9ybWF0Lm1hdGNoKC9bRE1dLykpIHtcblx0XHRcdFx0ZmluZE1heCA9IGZ1bmN0aW9uKG5hbWVzKSB7XG5cdFx0XHRcdFx0bWF4ID0gMDtcblx0XHRcdFx0XHRtYXhJID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1heEk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGUuc2V0TW9udGgoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL01NLykgP1xuXHRcdFx0XHRcdFwibW9udGhOYW1lc1wiIDogXCJtb250aE5hbWVzU2hvcnRcIikpKSk7XG5cdFx0XHRcdGRhdGUuc2V0RGF0ZShmaW5kTWF4KHRoaXMuX2dldChpbnN0LCAoZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/XG5cdFx0XHRcdFx0XCJkYXlOYW1lc1wiIDogXCJkYXlOYW1lc1Nob3J0XCIpKSkgKyAyMCAtIGRhdGUuZ2V0RGF5KCkpO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5pbnB1dC5hdHRyKFwic2l6ZVwiLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsIGRhdGUpLmxlbmd0aCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXG5cdF9pbmxpbmVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIGluc3QpIHtcblx0XHR2YXIgZGl2U3BhbiA9ICQodGFyZ2V0KTtcblx0XHRpZiAoZGl2U3Bhbi5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGl2U3Bhbi5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuYXBwZW5kKGluc3QuZHBEaXYpO1xuXHRcdCQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBiZWZvcmUgc2hvd2luZyBpdCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cdFx0Ly8gU2V0IGRpc3BsYXk6YmxvY2sgaW4gcGxhY2Ugb2YgaW5zdC5kcERpdi5zaG93KCkgd2hpY2ggd29uJ3Qgd29yayBvbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzc1NTIgLSBBIERhdGVwaWNrZXIgY3JlYXRlZCBvbiBhIGRldGFjaGVkIGRpdiBoYXMgemVybyBoZWlnaHRcblx0XHRpbnN0LmRwRGl2LmNzcyggXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiApO1xuXHR9LFxuXG5cdC8qIFBvcC11cCB0aGUgZGF0ZSBwaWNrZXIgaW4gYSBcImRpYWxvZ1wiIGJveC5cblx0ICogQHBhcmFtICBpbnB1dCBlbGVtZW50IC0gaWdub3JlZFxuXHQgKiBAcGFyYW0gIGRhdGVcdHN0cmluZyBvciBEYXRlIC0gdGhlIGluaXRpYWwgZGF0ZSB0byBkaXNwbGF5XG5cdCAqIEBwYXJhbSAgb25TZWxlY3QgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcblx0ICogQHBhcmFtICBwb3MgaW50WzJdIC0gY29vcmRpbmF0ZXMgZm9yIHRoZSBkaWFsb2cncyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcmVlbiBvclxuXHQgKlx0XHRcdFx0XHRldmVudCAtIHdpdGggeC95IGNvb3JkaW5hdGVzIG9yXG5cdCAqXHRcdFx0XHRcdGxlYXZlIGVtcHR5IGZvciBkZWZhdWx0IChzY3JlZW4gY2VudHJlKVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0X2RpYWxvZ0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0LCBkYXRlLCBvblNlbGVjdCwgc2V0dGluZ3MsIHBvcykge1xuXHRcdHZhciBpZCwgYnJvd3NlcldpZHRoLCBicm93c2VySGVpZ2h0LCBzY3JvbGxYLCBzY3JvbGxZLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2RpYWxvZ0luc3Q7IC8vIGludGVybmFsIGluc3RhbmNlXG5cblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0aWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dCA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgaWQ9J1wiICsgaWQgK1xuXHRcdFx0XHRcIicgc3R5bGU9J3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwcHg7IHdpZHRoOiAwcHg7Jy8+XCIpO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQua2V5ZG93bih0aGlzLl9kb0tleURvd24pO1xuXHRcdFx0JChcImJvZHlcIikuYXBwZW5kKHRoaXMuX2RpYWxvZ0lucHV0KTtcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0ID0gdGhpcy5fbmV3SW5zdCh0aGlzLl9kaWFsb2dJbnB1dCwgZmFsc2UpO1xuXHRcdFx0aW5zdC5zZXR0aW5ncyA9IHt9O1xuXHRcdFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdH1cblx0XHRleHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MgfHwge30pO1xuXHRcdGRhdGUgPSAoZGF0ZSAmJiBkYXRlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKSA6IGRhdGUpO1xuXHRcdHRoaXMuX2RpYWxvZ0lucHV0LnZhbChkYXRlKTtcblxuXHRcdHRoaXMuX3BvcyA9IChwb3MgPyAocG9zLmxlbmd0aCA/IHBvcyA6IFtwb3MucGFnZVgsIHBvcy5wYWdlWV0pIDogbnVsbCk7XG5cdFx0aWYgKCF0aGlzLl9wb3MpIHtcblx0XHRcdGJyb3dzZXJXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblx0XHRcdGJyb3dzZXJIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0c2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0dGhpcy5fcG9zID0gLy8gc2hvdWxkIHVzZSBhY3R1YWwgd2lkdGgvaGVpZ2h0IGJlbG93XG5cdFx0XHRcdFsoYnJvd3NlcldpZHRoIC8gMikgLSAxMDAgKyBzY3JvbGxYLCAoYnJvd3NlckhlaWdodCAvIDIpIC0gMTUwICsgc2Nyb2xsWV07XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZSBpbnB1dCBvbiBzY3JlZW4gZm9yIGZvY3VzLCBidXQgaGlkZGVuIGJlaGluZCBkaWFsb2dcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoXCJsZWZ0XCIsICh0aGlzLl9wb3NbMF0gKyAyMCkgKyBcInB4XCIpLmNzcyhcInRvcFwiLCB0aGlzLl9wb3NbMV0gKyBcInB4XCIpO1xuXHRcdGluc3Quc2V0dGluZ3Mub25TZWxlY3QgPSBvblNlbGVjdDtcblx0XHR0aGlzLl9pbkRpYWxvZyA9IHRydWU7XG5cdFx0dGhpcy5kcERpdi5hZGRDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcyk7XG5cdFx0dGhpcy5fc2hvd0RhdGVwaWNrZXIodGhpcy5fZGlhbG9nSW5wdXRbMF0pO1xuXHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdCQuYmxvY2tVSSh0aGlzLmRwRGl2KTtcblx0XHR9XG5cdFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIERldGFjaCBhIGRhdGVwaWNrZXIgZnJvbSBpdHMgY29udHJvbC5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kZXN0cm95RGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0JC5yZW1vdmVEYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5cblx0XHRcdFx0dW5iaW5kKFwiZm9jdXNcIiwgdGhpcy5fc2hvd0RhdGVwaWNrZXIpLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRcdHVuYmluZChcImtleXByZXNzXCIsIHRoaXMuX2RvS2V5UHJlc3MpLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXl1cFwiLCB0aGlzLl9kb0tleVVwKTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuZW1wdHkoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5hYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZW5hYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsXG5cdFx0XHQkdGFyZ2V0ID0gJCh0YXJnZXQpLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKFwiYnV0dG9uXCIpLlxuXHRcdFx0XHRlYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLmRpc2FibGVkID0gZmFsc2U7IH0pLmVuZCgpLlxuXHRcdFx0XHRmaWx0ZXIoXCJpbWdcIikuY3NzKHtvcGFjaXR5OiBcIjEuMFwiLCBjdXJzb3I6IFwiXCJ9KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0aW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZGlzYWJsZWRcIik7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIGRlbGV0ZSBlbnRyeVxuXHR9LFxuXG5cdC8qIERpc2FibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsXG5cdFx0XHQkdGFyZ2V0ID0gJCh0YXJnZXQpLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoXCJidXR0b25cIikuXG5cdFx0XHRcdGVhY2goZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSB0cnVlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKFwiaW1nXCIpLmNzcyh7b3BhY2l0eTogXCIwLjVcIiwgY3Vyc29yOiBcImRlZmF1bHRcIn0pO1xuXHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiKSB7XG5cdFx0XHRpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MpO1xuXHRcdFx0aW5saW5lLmNoaWxkcmVuKCkuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiKTtcblx0XHRcdGlubGluZS5maW5kKFwic2VsZWN0LnVpLWRhdGVwaWNrZXItbW9udGgsIHNlbGVjdC51aS1kYXRlcGlja2VyLXllYXJcIikuXG5cdFx0XHRcdHByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0XHR0aGlzLl9kaXNhYmxlZElucHV0c1t0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGhdID0gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHJldHVybiBib29sZWFuIC0gdHJ1ZSBpZiBkaXNhYmxlZCwgZmFsc2UgaWYgZW5hYmxlZFxuXHQgKi9cblx0X2lzRGlzYWJsZWREYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZGlzYWJsZWRJbnB1dHNbaV0gPT09IHRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBpbnN0YW5jZSBkYXRhIGZvciB0aGUgdGFyZ2V0IGNvbnRyb2wuXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gIG9iamVjdCAtIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlIGRhdGFcblx0ICogQHRocm93cyAgZXJyb3IgaWYgYSBqUXVlcnkgcHJvYmxlbSBnZXR0aW5nIGRhdGFcblx0ICovXG5cdF9nZXRJbnN0OiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHRocm93IFwiTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXJcIjtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIG9yIHJldHJpZXZlIHRoZSBzZXR0aW5ncyBmb3IgYSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBuYW1lXHRvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVwZGF0ZSBvclxuXHQgKlx0XHRcdFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxuXHQgKlx0XHRcdFx0d2hlbiByZXRyaWV2aW5nIGFsc28gXCJhbGxcIiBmb3IgYWxsIGluc3RhbmNlIHNldHRpbmdzIG9yXG5cdCAqXHRcdFx0XHRcImRlZmF1bHRzXCIgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcblx0ICogQHBhcmFtICB2YWx1ZSAgIGFueSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG5cdCAqXHRcdFx0XHQob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSlcblx0ICovXG5cdF9vcHRpb25EYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIHNldHRpbmdzLCBkYXRlLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiZGVmYXVsdHNcIiA/ICQuZXh0ZW5kKHt9LCAkLmRhdGVwaWNrZXIuX2RlZmF1bHRzKSA6XG5cdFx0XHRcdChpbnN0ID8gKG5hbWUgPT09IFwiYWxsXCIgPyAkLmV4dGVuZCh7fSwgaW5zdC5zZXR0aW5ncykgOlxuXHRcdFx0XHR0aGlzLl9nZXQoaW5zdCwgbmFtZSkpIDogbnVsbCkpO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzID0gbmFtZSB8fCB7fTtcblx0XHRpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHNldHRpbmdzID0ge307XG5cdFx0XHRzZXR0aW5nc1tuYW1lXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHRpZiAodGhpcy5fY3VySW5zdCA9PT0gaW5zdCkge1xuXHRcdFx0XHR0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCB0cnVlKTtcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpO1xuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIik7XG5cdFx0XHRleHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MpO1xuXHRcdFx0Ly8gcmVmb3JtYXQgdGhlIG9sZCBtaW5EYXRlL21heERhdGUgdmFsdWVzIGlmIGRhdGVGb3JtYXQgY2hhbmdlcyBhbmQgYSBuZXcgbWluRGF0ZS9tYXhEYXRlIGlzbid0IHByb3ZpZGVkXG5cdFx0XHRpZiAobWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWluRGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWluRGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF4RGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWF4RGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIFwiZGlzYWJsZWRcIiBpbiBzZXR0aW5ncyApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlcih0YXJnZXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXR0YWNobWVudHMoJCh0YXJnZXQpLCBpbnN0KTtcblx0XHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNoYW5nZSBtZXRob2QgZGVwcmVjYXRlZFxuXHRfY2hhbmdlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuX29wdGlvbkRhdGVwaWNrZXIodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG5cdH0sXG5cblx0LyogUmVkcmF3IHRoZSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9yZWZyZXNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCB0aGUgZGF0ZXMgZm9yIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcGFyYW0gIGRhdGVcdERhdGUgLSB0aGUgbmV3IGRhdGVcblx0ICovXG5cdF9zZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBkYXRlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZXQgdGhlIGRhdGUocykgZm9yIHRoZSBmaXJzdCBlbnRyeSBpbiBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBub0RlZmF1bHQgYm9vbGVhbiAtIHRydWUgaWYgbm8gZGVmYXVsdCBkYXRlIGlzIHRvIGJlIHVzZWRcblx0ICogQHJldHVybiBEYXRlIC0gdGhlIGN1cnJlbnQgZGF0ZVxuXHQgKi9cblx0X2dldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5vRGVmYXVsdCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0ICYmICFpbnN0LmlubGluZSkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0LCBub0RlZmF1bHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGluc3QgPyB0aGlzLl9nZXREYXRlKGluc3QpIDogbnVsbCk7XG5cdH0sXG5cblx0LyogSGFuZGxlIGtleXN0cm9rZXMuICovXG5cdF9kb0tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIG9uU2VsZWN0LCBkYXRlU3RyLCBzZWwsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXG5cdFx0XHRoYW5kbGVkID0gdHJ1ZSxcblx0XHRcdGlzUlRMID0gaW5zdC5kcERpdi5pcyhcIi51aS1kYXRlcGlja2VyLXJ0bFwiKTtcblxuXHRcdGluc3QuX2tleUV2ZW50ID0gdHJ1ZTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZykge1xuXHRcdFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cdFx0XHRcdGNhc2UgOTogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gdGFiIG91dFxuXHRcdFx0XHRjYXNlIDEzOiBzZWwgPSAkKFwidGQuXCIgKyAkLmRhdGVwaWNrZXIuX2RheU92ZXJDbGFzcyArIFwiOm5vdCguXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9jdXJyZW50Q2xhc3MgKyBcIilcIiwgaW5zdC5kcERpdik7XG5cdFx0XHRcdFx0XHRpZiAoc2VsWzBdKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KGV2ZW50LnRhcmdldCwgaW5zdC5zZWxlY3RlZE1vbnRoLCBpbnN0LnNlbGVjdGVkWWVhciwgc2VsWzBdKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b25TZWxlY3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcIm9uU2VsZWN0XCIpO1xuXHRcdFx0XHRcdFx0aWYgKG9uU2VsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdGRhdGVTdHIgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUoaW5zdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHRcdFx0XHRcdFx0b25TZWxlY3QuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtkYXRlU3RyLCBpbnN0XSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZG9uJ3Qgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdGNhc2UgMjc6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIGVzY2FwZVxuXHRcdFx0XHRjYXNlIDMzOiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpKSwgXCJNXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIHByZXZpb3VzIG1vbnRoL3llYXIgb24gcGFnZSB1cC8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNDogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBuZXh0IG1vbnRoL3llYXIgb24gcGFnZSBkb3duLysgY3RybFxuXHRcdFx0XHRjYXNlIDM1OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGNsZWFyIG9uIGN0cmwgb3IgY29tbWFuZCArZW5kXG5cdFx0XHRcdGNhc2UgMzY6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY3VycmVudCBvbiBjdHJsIG9yIGNvbW1hbmQgK2hvbWVcblx0XHRcdFx0Y2FzZSAzNzogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoaXNSVEwgPyArMSA6IC0xKSwgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vIC0xIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK2xlZnRcblx0XHRcdFx0XHRcdGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcEJpZ01vbnRoc1wiKSA6XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK2xlZnQgb24gTWFjXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzODogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAtNywgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyAtMSB3ZWVrIG9uIGN0cmwgb3IgY29tbWFuZCArdXBcblx0XHRcdFx0Y2FzZSAzOTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoaXNSVEwgPyAtMSA6ICsxKSwgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vICsxIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtyaWdodFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDA6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKzcsIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cblx0XHRcdFx0ZGVmYXVsdDogaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzYgJiYgZXZlbnQuY3RybEtleSkgeyAvLyBkaXNwbGF5IHRoZSBkYXRlIHBpY2tlciBvbiBjdHJsK2hvbWVcblx0XHRcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXG5cdF9kb0tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBjaGFycywgY2hyLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiY29uc3RyYWluSW5wdXRcIikpIHtcblx0XHRcdGNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSk7XG5cdFx0XHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlID09IG51bGwgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCAoY2hyIDwgXCIgXCIgfHwgIWNoYXJzIHx8IGNoYXJzLmluZGV4T2YoY2hyKSA+IC0xKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU3luY2hyb25pc2UgbWFudWFsIGVudHJ5IGFuZCBmaWVsZC9hbHRlcm5hdGUgZmllbGQuICovXG5cdF9kb0tleVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXG5cdFx0aWYgKGluc3QuaW5wdXQudmFsKCkgIT09IGluc3QubGFzdFZhbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpLFxuXHRcdFx0XHRcdChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IG51bGwpLFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblxuXHRcdFx0XHRpZiAoZGF0ZSkgeyAvLyBvbmx5IGlmIHZhbGlkXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxuXHQgKiBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cblx0ICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSBpZiB0cmlnZ2VyZWQgYnkgZm9jdXNcblx0ICovXG5cdF9zaG93RGF0ZXBpY2tlcjogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHRpbnB1dCA9IGlucHV0LnRhcmdldCB8fCBpbnB1dDtcblx0XHRpZiAoaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJpbnB1dFwiKSB7IC8vIGZpbmQgZnJvbSBidXR0b24vaW1hZ2UgdHJpZ2dlclxuXHRcdFx0aW5wdXQgPSAkKFwiaW5wdXRcIiwgaW5wdXQucGFyZW50Tm9kZSlbMF07XG5cdFx0fVxuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoaW5wdXQpIHx8ICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dCkgeyAvLyBhbHJlYWR5IGhlcmVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCwgYmVmb3JlU2hvdywgYmVmb3JlU2hvd1NldHRpbmdzLCBpc0ZpeGVkLFxuXHRcdFx0b2Zmc2V0LCBzaG93QW5pbSwgZHVyYXRpb247XG5cblx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGlucHV0KTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCkge1xuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0LmRwRGl2LnN0b3AodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRpZiAoIGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlciggJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WzBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiYmVmb3JlU2hvd1wiKTtcblx0XHRiZWZvcmVTaG93U2V0dGluZ3MgPSBiZWZvcmVTaG93ID8gYmVmb3JlU2hvdy5hcHBseShpbnB1dCwgW2lucHV0LCBpbnN0XSkgOiB7fTtcblx0XHRpZihiZWZvcmVTaG93U2V0dGluZ3MgPT09IGZhbHNlKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIGJlZm9yZVNob3dTZXR0aW5ncyk7XG5cblx0XHRpbnN0Lmxhc3RWYWwgPSBudWxsO1xuXHRcdCQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID0gaW5wdXQ7XG5cdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faW5EaWFsb2cpIHsgLy8gaGlkZSBjdXJzb3Jcblx0XHRcdGlucHV0LnZhbHVlID0gXCJcIjtcblx0XHR9XG5cdFx0aWYgKCEkLmRhdGVwaWNrZXIuX3BvcykgeyAvLyBwb3NpdGlvbiBiZWxvdyBpbnB1dFxuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3MgPSAkLmRhdGVwaWNrZXIuX2ZpbmRQb3MoaW5wdXQpO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3NbMV0gKz0gaW5wdXQub2Zmc2V0SGVpZ2h0OyAvLyBhZGQgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdGlzRml4ZWQgPSBmYWxzZTtcblx0XHQkKGlucHV0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiO1xuXHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xuXHRcdH0pO1xuXG5cdFx0b2Zmc2V0ID0ge2xlZnQ6ICQuZGF0ZXBpY2tlci5fcG9zWzBdLCB0b3A6ICQuZGF0ZXBpY2tlci5fcG9zWzFdfTtcblx0XHQkLmRhdGVwaWNrZXIuX3BvcyA9IG51bGw7XG5cdFx0Ly90byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3hcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCk7XG5cdFx0Ly8gZGV0ZXJtaW5lIHNpemluZyBvZmZzY3JlZW5cblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgZGlzcGxheTogXCJibG9ja1wiLCB0b3A6IFwiLTEwMDBweFwifSk7XG5cdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdC8vIGZpeCB3aWR0aCBmb3IgZHluYW1pYyBudW1iZXIgb2YgZGF0ZSBwaWNrZXJzXG5cdFx0Ly8gYW5kIGFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xuXHRcdG9mZnNldCA9ICQuZGF0ZXBpY2tlci5fY2hlY2tPZmZzZXQoaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkKTtcblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246ICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/XG5cdFx0XHRcInN0YXRpY1wiIDogKGlzRml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCIpKSwgZGlzcGxheTogXCJub25lXCIsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCArIFwicHhcIiwgdG9wOiBvZmZzZXQudG9wICsgXCJweFwifSk7XG5cblx0XHRpZiAoIWluc3QuaW5saW5lKSB7XG5cdFx0XHRzaG93QW5pbSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic2hvd0FuaW1cIik7XG5cdFx0XHRkdXJhdGlvbiA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZHVyYXRpb25cIik7XG5cdFx0XHRpbnN0LmRwRGl2LnpJbmRleCgkKGlucHV0KS56SW5kZXgoKSsxKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdICkge1xuXHRcdFx0XHRpbnN0LmRwRGl2LnNob3coc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic2hvd09wdGlvbnNcIiksIGR1cmF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3QuZHBEaXZbc2hvd0FuaW0gfHwgXCJzaG93XCJdKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdFx0aW5zdC5pbnB1dC5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QgPSBpbnN0O1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cblx0X3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR0aGlzLm1heFJvd3MgPSA0OyAvL1Jlc2V0IHRoZSBtYXggbnVtYmVyIG9mIHJvd3MgYmVpbmcgZGlzcGxheWVkIChzZWUgIzcwNDMpXG5cdFx0aW5zdEFjdGl2ZSA9IGluc3Q7IC8vIGZvciBkZWxlZ2F0ZSBob3ZlciBldmVudHNcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuX2dlbmVyYXRlSFRNTChpbnN0KSk7XG5cdFx0dGhpcy5fYXR0YWNoSGFuZGxlcnMoaW5zdCk7XG5cdFx0aW5zdC5kcERpdi5maW5kKFwiLlwiICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgXCIgYVwiKS5tb3VzZW92ZXIoKTtcblxuXHRcdHZhciBvcmlneWVhcnNodG1sLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXG5cdFx0XHRjb2xzID0gbnVtTW9udGhzWzFdLFxuXHRcdFx0d2lkdGggPSAxNztcblxuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFwiKS53aWR0aChcIlwiKTtcblx0XHRpZiAoY29scyA+IDEpIHtcblx0XHRcdGluc3QuZHBEaXYuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLVwiICsgY29scykuY3NzKFwid2lkdGhcIiwgKHdpZHRoICogY29scykgKyBcImVtXCIpO1xuXHRcdH1cblx0XHRpbnN0LmRwRGl2WyhudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICtcblx0XHRcdFwiQ2xhc3NcIl0oXCJ1aS1kYXRlcGlja2VyLW11bHRpXCIpO1xuXHRcdGluc3QuZHBEaXZbKHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICtcblx0XHRcdFwiQ2xhc3NcIl0oXCJ1aS1kYXRlcGlja2VyLXJ0bFwiKTtcblxuXHRcdGlmIChpbnN0ID09PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTtcblx0XHR9XG5cblx0XHQvLyBkZWZmZXJlZCByZW5kZXIgb2YgdGhlIHllYXJzIHNlbGVjdCAodG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94KVxuXHRcdGlmKCBpbnN0LnllYXJzaHRtbCApe1xuXHRcdFx0b3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHQvL2Fzc3VyZSB0aGF0IGluc3QueWVhcnNodG1sIGRpZG4ndCBjaGFuZ2UuXG5cdFx0XHRcdGlmKCBvcmlneWVhcnNodG1sID09PSBpbnN0LnllYXJzaHRtbCAmJiBpbnN0LnllYXJzaHRtbCApe1xuXHRcdFx0XHRcdGluc3QuZHBEaXYuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLXllYXI6Zmlyc3RcIikucmVwbGFjZVdpdGgoaW5zdC55ZWFyc2h0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gIzY2OTQgLSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgaWYgaXQncyBhbHJlYWR5IGZvY3VzZWRcblx0Ly8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxuXHQvLyBTdXBwb3J0OiBJRSBhbmQgalF1ZXJ5IDwxLjlcblx0X3Nob3VsZEZvY3VzSW5wdXQ6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHJldHVybiBpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQuaXMoIFwiOnZpc2libGVcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpkaXNhYmxlZFwiICkgJiYgIWluc3QuaW5wdXQuaXMoIFwiOmZvY3VzXCIgKTtcblx0fSxcblxuXHQvKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gc2NyZWVuLiAqL1xuXHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgaXNGaXhlZCkge1xuXHRcdHZhciBkcFdpZHRoID0gaW5zdC5kcERpdi5vdXRlcldpZHRoKCksXG5cdFx0XHRkcEhlaWdodCA9IGluc3QuZHBEaXYub3V0ZXJIZWlnaHQoKSxcblx0XHRcdGlucHV0V2lkdGggPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlcldpZHRoKCkgOiAwLFxuXHRcdFx0aW5wdXRIZWlnaHQgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlckhlaWdodCgpIDogMCxcblx0XHRcdHZpZXdXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSksXG5cdFx0XHR2aWV3SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKTtcblxuXHRcdG9mZnNldC5sZWZ0IC09ICh0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKSA/IChkcFdpZHRoIC0gaW5wdXRXaWR0aCkgOiAwKTtcblx0XHRvZmZzZXQubGVmdCAtPSAoaXNGaXhlZCAmJiBvZmZzZXQubGVmdCA9PT0gaW5zdC5pbnB1dC5vZmZzZXQoKS5sZWZ0KSA/ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA6IDA7XG5cdFx0b2Zmc2V0LnRvcCAtPSAoaXNGaXhlZCAmJiBvZmZzZXQudG9wID09PSAoaW5zdC5pbnB1dC5vZmZzZXQoKS50b3AgKyBpbnB1dEhlaWdodCkpID8gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgOiAwO1xuXG5cdFx0Ly8gbm93IGNoZWNrIGlmIGRhdGVwaWNrZXIgaXMgc2hvd2luZyBvdXRzaWRlIHdpbmRvdyB2aWV3cG9ydCAtIG1vdmUgdG8gYSBiZXR0ZXIgcGxhY2UgaWYgc28uXG5cdFx0b2Zmc2V0LmxlZnQgLT0gTWF0aC5taW4ob2Zmc2V0LmxlZnQsIChvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCkgP1xuXHRcdFx0TWF0aC5hYnMob2Zmc2V0LmxlZnQgKyBkcFdpZHRoIC0gdmlld1dpZHRoKSA6IDApO1xuXHRcdG9mZnNldC50b3AgLT0gTWF0aC5taW4ob2Zmc2V0LnRvcCwgKG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0KSA/XG5cdFx0XHRNYXRoLmFicyhkcEhlaWdodCArIGlucHV0SGVpZ2h0KSA6IDApO1xuXG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHQvKiBGaW5kIGFuIG9iamVjdCdzIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4uICovXG5cdF9maW5kUG9zOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgcG9zaXRpb24sXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdChvYmopLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKTtcblxuXHRcdHdoaWxlIChvYmogJiYgKG9iai50eXBlID09PSBcImhpZGRlblwiIHx8IG9iai5ub2RlVHlwZSAhPT0gMSB8fCAkLmV4cHIuZmlsdGVycy5oaWRkZW4ob2JqKSkpIHtcblx0XHRcdG9iaiA9IG9ialtpc1JUTCA/IFwicHJldmlvdXNTaWJsaW5nXCIgOiBcIm5leHRTaWJsaW5nXCJdO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uID0gJChvYmopLm9mZnNldCgpO1xuXHRcdHJldHVybiBbcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wXTtcblx0fSxcblxuXHQvKiBIaWRlIHRoZSBkYXRlIHBpY2tlciBmcm9tIHZpZXcuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyXG5cdCAqL1xuXHRfaGlkZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0dmFyIHNob3dBbmltLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MsIG9uQ2xvc2UsXG5cdFx0XHRpbnN0ID0gdGhpcy5fY3VySW5zdDtcblxuXHRcdGlmICghaW5zdCB8fCAoaW5wdXQgJiYgaW5zdCAhPT0gJC5kYXRhKGlucHV0LCBQUk9QX05BTUUpKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9kYXRlcGlja2VyU2hvd2luZykge1xuXHRcdFx0c2hvd0FuaW0gPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93QW5pbVwiKTtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZ2V0KGluc3QsIFwiZHVyYXRpb25cIik7XG5cdFx0XHRwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX3RpZHlEaWFsb2coaW5zdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBERVBSRUNBVEVEOiBhZnRlciBCQyBmb3IgMS44LnggJC5lZmZlY3RzWyBzaG93QW5pbSBdIGlzIG5vdCBuZWVkZWRcblx0XHRcdGlmICggJC5lZmZlY3RzICYmICggJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSB8fCAkLmVmZmVjdHNbIHNob3dBbmltIF0gKSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5oaWRlKHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dPcHRpb25zXCIpLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zdC5kcERpdlsoc2hvd0FuaW0gPT09IFwic2xpZGVEb3duXCIgPyBcInNsaWRlVXBcIiA6XG5cdFx0XHRcdFx0KHNob3dBbmltID09PSBcImZhZGVJblwiID8gXCJmYWRlT3V0XCIgOiBcImhpZGVcIikpXSgoc2hvd0FuaW0gPyBkdXJhdGlvbiA6IG51bGwpLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2hvd0FuaW0pIHtcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7XG5cblx0XHRcdG9uQ2xvc2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJvbkNsb3NlXCIpO1xuXHRcdFx0aWYgKG9uQ2xvc2UpIHtcblx0XHRcdFx0b25DbG9zZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgWyhpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IFwiXCIpLCBpbnN0XSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5faW5EaWFsb2cpIHtcblx0XHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgbGVmdDogXCIwXCIsIHRvcDogXCItMTAwcHhcIiB9KTtcblx0XHRcdFx0aWYgKCQuYmxvY2tVSSkge1xuXHRcdFx0XHRcdCQudW5ibG9ja1VJKCk7XG5cdFx0XHRcdFx0JChcImJvZHlcIikuYXBwZW5kKHRoaXMuZHBEaXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKiBUaWR5IHVwIGFmdGVyIGEgZGlhbG9nIGRpc3BsYXkuICovXG5cdF90aWR5RGlhbG9nOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIik7XG5cdH0sXG5cblx0LyogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuICovXG5cdF9jaGVja0V4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCEkLmRhdGVwaWNrZXIuX2N1ckluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoJHRhcmdldFswXSk7XG5cblx0XHRpZiAoICggKCAkdGFyZ2V0WzBdLmlkICE9PSAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCAmJlxuXHRcdFx0XHQkdGFyZ2V0LnBhcmVudHMoXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwICYmXG5cdFx0XHRcdCEkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmXG5cdFx0XHRcdCEkdGFyZ2V0LmNsb3Nlc3QoXCIuXCIgKyAkLmRhdGVwaWNrZXIuX3RyaWdnZXJDbGFzcykubGVuZ3RoICYmXG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgISgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSkgKSApIHx8XG5cdFx0XHQoICR0YXJnZXQuaGFzQ2xhc3MoJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSkgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICkgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0RGF0ZTogZnVuY3Rpb24oaWQsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGlmICh0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QsIG9mZnNldCArXG5cdFx0XHQocGVyaW9kID09PSBcIk1cIiA/IHRoaXMuX2dldChpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIikgOiAwKSwgLy8gdW5kbyBwb3NpdGlvbmluZ1xuXHRcdFx0cGVyaW9kKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3IgY3VycmVudCBsaW5rLiAqL1xuXHRfZ290b1RvZGF5OiBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0dGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKHRoaXMuX2dldChpbnN0LCBcImdvdG9DdXJyZW50XCIpICYmIGluc3QuY3VycmVudERheSkge1xuXHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IGluc3QuY3VycmVudERheTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGg7XG5cdFx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdH1cblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSh0YXJnZXQpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgbmV3IG1vbnRoL3llYXIuICovXG5cdF9zZWxlY3RNb250aFllYXI6IGZ1bmN0aW9uKGlkLCBzZWxlY3QsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cblx0XHRpbnN0W1wic2VsZWN0ZWRcIiArIChwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIpXSA9XG5cdFx0aW5zdFtcImRyYXdcIiArIChwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIpXSA9XG5cdFx0XHRwYXJzZUludChzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRJbmRleF0udmFsdWUsMTApO1xuXG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRheS4gKi9cblx0X3NlbGVjdERheTogZnVuY3Rpb24oaWQsIG1vbnRoLCB5ZWFyLCB0ZCkge1xuXHRcdHZhciBpbnN0LFxuXHRcdFx0dGFyZ2V0ID0gJChpZCk7XG5cblx0XHRpZiAoJCh0ZCkuaGFzQ2xhc3ModGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MpIHx8IHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKHRhcmdldFswXSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKFwiYVwiLCB0ZCkuaHRtbCgpO1xuXHRcdGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbW9udGg7XG5cdFx0aW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0geWVhcjtcblx0XHR0aGlzLl9zZWxlY3REYXRlKGlkLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsXG5cdFx0XHRpbnN0LmN1cnJlbnREYXksIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnRZZWFyKSk7XG5cdH0sXG5cblx0LyogRXJhc2UgdGhlIGlucHV0IGZpZWxkIGFuZCBoaWRlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2NsZWFyRGF0ZTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZSh0YXJnZXQsIFwiXCIpO1xuXHR9LFxuXG5cdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cblx0X3NlbGVjdERhdGU6IGZ1bmN0aW9uKGlkLCBkYXRlU3RyKSB7XG5cdFx0dmFyIG9uU2VsZWN0LFxuXHRcdFx0dGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0ZGF0ZVN0ciA9IChkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0aWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKGRhdGVTdHIpO1xuXHRcdH1cblx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cblx0XHRvblNlbGVjdCA9IHRoaXMuX2dldChpbnN0LCBcIm9uU2VsZWN0XCIpO1xuXHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0b25TZWxlY3QuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtkYXRlU3RyLCBpbnN0XSk7ICAvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdH0gZWxzZSBpZiAoaW5zdC5pbnB1dCkge1xuXHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpOyAvLyBmaXJlIHRoZSBjaGFuZ2UgZXZlbnRcblx0XHR9XG5cblx0XHRpZiAoaW5zdC5pbmxpbmUpe1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IGluc3QuaW5wdXRbMF07XG5cdFx0XHRpZiAodHlwZW9mKGluc3QuaW5wdXRbMF0pICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTsgLy8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC4gKi9cblx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBhbHRGb3JtYXQsIGRhdGUsIGRhdGVTdHIsXG5cdFx0XHRhbHRGaWVsZCA9IHRoaXMuX2dldChpbnN0LCBcImFsdEZpZWxkXCIpO1xuXG5cdFx0aWYgKGFsdEZpZWxkKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXG5cdFx0XHRhbHRGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhbHRGb3JtYXRcIikgfHwgdGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKTtcblx0XHRcdGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpO1xuXHRcdFx0ZGF0ZVN0ciA9IHRoaXMuZm9ybWF0RGF0ZShhbHRGb3JtYXQsIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHQkKGFsdEZpZWxkKS5lYWNoKGZ1bmN0aW9uKCkgeyAkKHRoaXMpLnZhbChkYXRlU3RyKTsgfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCBhcyBiZWZvcmVTaG93RGF5IGZ1bmN0aW9uIHRvIHByZXZlbnQgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxuXHQgKiBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBjdXN0b21pc2Vcblx0ICogQHJldHVybiBbYm9vbGVhbiwgc3RyaW5nXSAtIGlzIHRoaXMgZGF0ZSBzZWxlY3RhYmxlPywgd2hhdCBpcyBpdHMgQ1NTIGNsYXNzP1xuXHQgKi9cblx0bm9XZWVrZW5kczogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuXHRcdHJldHVybiBbKGRheSA+IDAgJiYgZGF5IDwgNiksIFwiXCJdO1xuXHR9LFxuXG5cdC8qIFNldCBhcyBjYWxjdWxhdGVXZWVrIHRvIGRldGVybWluZSB0aGUgd2VlayBvZiB0aGUgeWVhciBiYXNlZCBvbiB0aGUgSVNPIDg2MDEgZGVmaW5pdGlvbi5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gZ2V0IHRoZSB3ZWVrIGZvclxuXHQgKiBAcmV0dXJuICBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIHdpdGhpbiB0aGUgeWVhciB0aGF0IGNvbnRhaW5zIHRoaXMgZGF0ZVxuXHQgKi9cblx0aXNvODYwMVdlZWs6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgdGltZSxcblx0XHRcdGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcblxuXHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgKyA0IC0gKGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3KSk7XG5cblx0XHR0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcblx0XHRjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKDEpO1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xuXHR9LFxuXG5cdC8qIFBhcnNlIGEgc3RyaW5nIHZhbHVlIGludG8gYSBkYXRlIG9iamVjdC5cblx0ICogU2VlIGZvcm1hdERhdGUgYmVsb3cgZm9yIHRoZSBwb3NzaWJsZSBmb3JtYXRzLlxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAqIEBwYXJhbSAgdmFsdWUgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICpcdFx0XHRcdFx0c2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1x0XHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNcdFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJuICBEYXRlIC0gdGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIG51bGwgaWYgdmFsdWUgaXMgYmxhbmtcblx0ICovXG5cdHBhcnNlRGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG5cdFx0aWYgKGZvcm1hdCA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcblx0XHRcdHRocm93IFwiSW52YWxpZCBhcmd1bWVudHNcIjtcblx0XHR9XG5cblx0XHR2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyBcIlwiKTtcblx0XHRpZiAodmFsdWUgPT09IFwiXCIpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LCBkaW0sIGV4dHJhLFxuXHRcdFx0aVZhbHVlID0gMCxcblx0XHRcdHNob3J0WWVhckN1dG9mZlRlbXAgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5zaG9ydFllYXJDdXRvZmYgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5zaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmZUZW1wIDpcblx0XHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmVGVtcCwgMTApKSxcblx0XHRcdGRheU5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydCxcblx0XHRcdGRheU5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcblx0XHRcdG1vbnRoTmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcyxcblx0XHRcdHllYXIgPSAtMSxcblx0XHRcdG1vbnRoID0gLTEsXG5cdFx0XHRkYXkgPSAtMSxcblx0XHRcdGRveSA9IC0xLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0ZGF0ZSxcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2gpO1xuXHRcdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdH0sXG5cdFx0XHQvLyBFeHRyYWN0IGEgbnVtYmVyIGZyb20gdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Z2V0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIGlzRG91YmxlZCA9IGxvb2tBaGVhZChtYXRjaCksXG5cdFx0XHRcdFx0c2l6ZSA9IChtYXRjaCA9PT0gXCJAXCIgPyAxNCA6IChtYXRjaCA9PT0gXCIhXCIgPyAyMCA6XG5cdFx0XHRcdFx0KG1hdGNoID09PSBcInlcIiAmJiBpc0RvdWJsZWQgPyA0IDogKG1hdGNoID09PSBcIm9cIiA/IDMgOiAyKSkpKSxcblx0XHRcdFx0XHRkaWdpdHMgPSBuZXcgUmVnRXhwKFwiXlxcXFxkezEsXCIgKyBzaXplICsgXCJ9XCIpLFxuXHRcdFx0XHRcdG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XG5cdFx0XHRcdGlmICghbnVtKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJNaXNzaW5nIG51bWJlciBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xuXHRcdFx0fSxcblx0XHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdFx0Z2V0TmFtZSA9IGZ1bmN0aW9uKG1hdGNoLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gLTEsXG5cdFx0XHRcdFx0bmFtZXMgPSAkLm1hcChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcywgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIFtrLCB2XSBdO1xuXHRcdFx0XHRcdH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdCQuZWFjaChuYW1lcywgZnVuY3Rpb24gKGksIHBhaXIpIHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IHBhaXJbMV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWUubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFpclswXTtcblx0XHRcdFx0XHRcdGlWYWx1ZSArPSBuYW1lLmxlbmd0aDtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gbmFtZSBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Y2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh2YWx1ZS5jaGFyQXQoaVZhbHVlKSAhPT0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdGRheSA9IGdldE51bWJlcihcImRcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0Z2V0TmFtZShcIkRcIiwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdGRveSA9IGdldE51bWJlcihcIm9cIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROdW1iZXIoXCJtXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TmFtZShcIk1cIiwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHR5ZWFyID0gZ2V0TnVtYmVyKFwieVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRkYXRlID0gbmV3IERhdGUoZ2V0TnVtYmVyKFwiQFwiKSk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiIVwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKChnZXROdW1iZXIoXCIhXCIpIC0gdGhpcy5fdGlja3NUbzE5NzApIC8gMTAwMDApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKXtcblx0XHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpVmFsdWUgPCB2YWx1ZS5sZW5ndGgpe1xuXHRcdFx0ZXh0cmEgPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKTtcblx0XHRcdGlmICghL15cXHMrLy50ZXN0KGV4dHJhKSkge1xuXHRcdFx0XHR0aHJvdyBcIkV4dHJhL3VucGFyc2VkIGNoYXJhY3RlcnMgZm91bmQgaW4gZGF0ZTogXCIgKyBleHRyYTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoeWVhciA9PT0gLTEpIHtcblx0XHRcdHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0fSBlbHNlIGlmICh5ZWFyIDwgMTAwKSB7XG5cdFx0XHR5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG5cdFx0XHRcdCh5ZWFyIDw9IHNob3J0WWVhckN1dG9mZiA/IDAgOiAtMTAwKTtcblx0XHR9XG5cblx0XHRpZiAoZG95ID4gLTEpIHtcblx0XHRcdG1vbnRoID0gMTtcblx0XHRcdGRheSA9IGRveTtcblx0XHRcdGRvIHtcblx0XHRcdFx0ZGltID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGggLSAxKTtcblx0XHRcdFx0aWYgKGRheSA8PSBkaW0pIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtb250aCsrO1xuXHRcdFx0XHRkYXkgLT0gZGltO1xuXHRcdFx0fSB3aGlsZSAodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0ZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cdFx0aWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9PSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPT0gZGF5KSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgZGF0ZVwiOyAvLyBFLmcuIDMxLzAyLzAwXG5cdFx0fVxuXHRcdHJldHVybiBkYXRlO1xuXHR9LFxuXG5cdC8qIFN0YW5kYXJkIGRhdGUgZm9ybWF0cy4gKi9cblx0QVRPTTogXCJ5eS1tbS1kZFwiLCAvLyBSRkMgMzMzOSAoSVNPIDg2MDEpXG5cdENPT0tJRTogXCJELCBkZCBNIHl5XCIsXG5cdElTT184NjAxOiBcInl5LW1tLWRkXCIsXG5cdFJGQ184MjI6IFwiRCwgZCBNIHlcIixcblx0UkZDXzg1MDogXCJERCwgZGQtTS15XCIsXG5cdFJGQ18xMDM2OiBcIkQsIGQgTSB5XCIsXG5cdFJGQ18xMTIzOiBcIkQsIGQgTSB5eVwiLFxuXHRSRkNfMjgyMjogXCJELCBkIE0geXlcIixcblx0UlNTOiBcIkQsIGQgTSB5XCIsIC8vIFJGQyA4MjJcblx0VElDS1M6IFwiIVwiLFxuXHRUSU1FU1RBTVA6IFwiQFwiLFxuXHRXM0M6IFwieXktbW0tZGRcIiwgLy8gSVNPIDg2MDFcblxuXHRfdGlja3NUbzE5NzA6ICgoKDE5NzAgLSAxKSAqIDM2NSArIE1hdGguZmxvb3IoMTk3MCAvIDQpIC0gTWF0aC5mbG9vcigxOTcwIC8gMTAwKSArXG5cdFx0TWF0aC5mbG9vcigxOTcwIC8gNDAwKSkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCksXG5cblx0LyogRm9ybWF0IGEgZGF0ZSBvYmplY3QgaW50byBhIHN0cmluZyB2YWx1ZS5cblx0ICogVGhlIGZvcm1hdCBjYW4gYmUgY29tYmluYXRpb25zIG9mIHRoZSBmb2xsb3dpbmc6XG5cdCAqIGQgIC0gZGF5IG9mIG1vbnRoIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIGRkIC0gZGF5IG9mIG1vbnRoICh0d28gZGlnaXQpXG5cdCAqIG8gIC0gZGF5IG9mIHllYXIgKG5vIGxlYWRpbmcgemVyb3MpXG5cdCAqIG9vIC0gZGF5IG9mIHllYXIgKHRocmVlIGRpZ2l0KVxuXHQgKiBEICAtIGRheSBuYW1lIHNob3J0XG5cdCAqIEREIC0gZGF5IG5hbWUgbG9uZ1xuXHQgKiBtICAtIG1vbnRoIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybylcblx0ICogbW0gLSBtb250aCBvZiB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIE0gIC0gbW9udGggbmFtZSBzaG9ydFxuXHQgKiBNTSAtIG1vbnRoIG5hbWUgbG9uZ1xuXHQgKiB5ICAtIHllYXIgKHR3byBkaWdpdClcblx0ICogeXkgLSB5ZWFyIChmb3VyIGRpZ2l0KVxuXHQgKiBAIC0gVW5peCB0aW1lc3RhbXAgKG1zIHNpbmNlIDAxLzAxLzE5NzApXG5cdCAqICEgLSBXaW5kb3dzIHRpY2tzICgxMDBucyBzaW5jZSAwMS8wMS8wMDAxKVxuXHQgKiBcIi4uLlwiIC0gbGl0ZXJhbCB0ZXh0XG5cdCAqICcnIC0gc2luZ2xlIHF1b3RlXG5cdCAqXG5cdCAqIEBwYXJhbSAgZm9ybWF0IHN0cmluZyAtIHRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgKiBAcGFyYW0gIGRhdGUgRGF0ZSAtIHRoZSBkYXRlIHZhbHVlIHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1x0XHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNcdFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJuICBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XG5cdCAqL1xuXHRmb3JtYXREYXRlOiBmdW5jdGlvbiAoZm9ybWF0LCBkYXRlLCBzZXR0aW5ncykge1xuXHRcdGlmICghZGF0ZSkge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGlGb3JtYXQsXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3Nhcnlcblx0XHRcdGZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoLCB2YWx1ZSwgbGVuKSB7XG5cdFx0XHRcdHZhciBudW0gPSBcIlwiICsgdmFsdWU7XG5cdFx0XHRcdGlmIChsb29rQWhlYWQobWF0Y2gpKSB7XG5cdFx0XHRcdFx0d2hpbGUgKG51bS5sZW5ndGggPCBsZW4pIHtcblx0XHRcdFx0XHRcdG51bSA9IFwiMFwiICsgbnVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVtO1xuXHRcdFx0fSxcblx0XHRcdC8vIEZvcm1hdCBhIG5hbWUsIHNob3J0IG9yIGxvbmcgYXMgcmVxdWVzdGVkXG5cdFx0XHRmb3JtYXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdFx0cmV0dXJuIChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzW3ZhbHVlXSA6IHNob3J0TmFtZXNbdmFsdWVdKTtcblx0XHRcdH0sXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXG5cdFx0aWYgKGRhdGUpIHtcblx0XHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcImRcIiwgZGF0ZS5nZXREYXRlKCksIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKFwiRFwiLCBkYXRlLmdldERheSgpLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcIm9cIixcblx0XHRcdFx0XHRcdFx0XHRNYXRoLnJvdW5kKChuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMCkuZ2V0VGltZSgpKSAvIDg2NDAwMDAwKSwgMyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcIm1cIiwgZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoXCJNXCIsIGRhdGUuZ2V0TW9udGgoKSwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKGxvb2tBaGVhZChcInlcIikgPyBkYXRlLmdldEZ1bGxZZWFyKCkgOlxuXHRcdFx0XHRcdFx0XHRcdChkYXRlLmdldFllYXIoKSAlIDEwMCA8IDEwID8gXCIwXCIgOiBcIlwiKSArIGRhdGUuZ2V0WWVhcigpICUgMTAwKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpICogMTAwMDAgKyB0aGlzLl90aWNrc1RvMTk3MDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9LFxuXG5cdC8qIEV4dHJhY3QgYWxsIHBvc3NpYmxlIGNoYXJhY3RlcnMgZnJvbSB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9wb3NzaWJsZUNoYXJzOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdFx0dmFyIGlGb3JtYXQsXG5cdFx0XHRjaGFycyA9IFwiXCIsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2UsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9O1xuXG5cdFx0Zm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xuXHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgXCJkXCI6IGNhc2UgXCJtXCI6IGNhc2UgXCJ5XCI6IGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRjaGFycyArPSBcIjAxMjM0NTY3ODlcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJEXCI6IGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gQWNjZXB0IGFueXRoaW5nXG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGNoYXJzICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2hhcnM7XG5cdH0sXG5cblx0LyogR2V0IGEgc2V0dGluZyB2YWx1ZSwgZGVmYXVsdGluZyBpZiBuZWNlc3NhcnkuICovXG5cdF9nZXQ6IGZ1bmN0aW9uKGluc3QsIG5hbWUpIHtcblx0XHRyZXR1cm4gaW5zdC5zZXR0aW5nc1tuYW1lXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGluc3Quc2V0dGluZ3NbbmFtZV0gOiB0aGlzLl9kZWZhdWx0c1tuYW1lXTtcblx0fSxcblxuXHQvKiBQYXJzZSBleGlzdGluZyBkYXRlIGFuZCBpbml0aWFsaXNlIGRhdGUgcGlja2VyLiAqL1xuXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24oaW5zdCwgbm9EZWZhdWx0KSB7XG5cdFx0aWYgKGluc3QuaW5wdXQudmFsKCkgPT09IGluc3QubGFzdFZhbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSxcblx0XHRcdGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsLFxuXHRcdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KSxcblx0XHRcdGRhdGUgPSBkZWZhdWx0RGF0ZSxcblx0XHRcdHNldHRpbmdzID0gdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGRhdGUgPSB0aGlzLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBkYXRlcywgc2V0dGluZ3MpIHx8IGRlZmF1bHREYXRlO1xuXHRcdH0gY2F0Y2ggKGV2ZW50KSB7XG5cdFx0XHRkYXRlcyA9IChub0RlZmF1bHQgPyBcIlwiIDogZGF0ZXMpO1xuXHRcdH1cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGluc3QuY3VycmVudERheSA9IChkYXRlcyA/IGRhdGUuZ2V0RGF0ZSgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50TW9udGggPSAoZGF0ZXMgPyBkYXRlLmdldE1vbnRoKCkgOiAwKTtcblx0XHRpbnN0LmN1cnJlbnRZZWFyID0gKGRhdGVzID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogMCk7XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xuXHRfZ2V0RGVmYXVsdERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCxcblx0XHRcdHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIFwiZGVmYXVsdERhdGVcIiksIG5ldyBEYXRlKCkpKTtcblx0fSxcblxuXHQvKiBBIGRhdGUgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBleGFjdCB2YWx1ZSBvciBhIHJlbGF0aXZlIG9uZS4gKi9cblx0X2RldGVybWluZURhdGU6IGZ1bmN0aW9uKGluc3QsIGRhdGUsIGRlZmF1bHREYXRlKSB7XG5cdFx0dmFyIG9mZnNldE51bWVyaWMgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdH0sXG5cdFx0XHRvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksXG5cdFx0XHRcdFx0XHRvZmZzZXQsICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGRhdGUgPSAob2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goL15jLykgP1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpIHx8IG5ldyBEYXRlKCksXG5cdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcblx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSxcblx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKSxcblx0XHRcdFx0XHRwYXR0ZXJuID0gLyhbK1xcLV0/WzAtOV0rKVxccyooZHxEfHd8V3xtfE18eXxZKT8vZyxcblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cblx0XHRcdFx0d2hpbGUgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKG1hdGNoZXNbMl0gfHwgXCJkXCIpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJkXCIgOiBjYXNlIFwiRFwiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ3XCIgOiBjYXNlIFwiV1wiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApICogNzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibVwiIDogY2FzZSBcIk1cIiA6XG5cdFx0XHRcdFx0XHRcdG1vbnRoICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApO1xuXHRcdFx0XHRcdFx0XHRkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOiBjYXNlIFwiWVwiIDpcblx0XHRcdFx0XHRcdFx0eWVhciArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdFx0fSxcblx0XHRcdG5ld0RhdGUgPSAoZGF0ZSA9PSBudWxsIHx8IGRhdGUgPT09IFwiXCIgPyBkZWZhdWx0RGF0ZSA6ICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIiA/IG9mZnNldFN0cmluZyhkYXRlKSA6XG5cdFx0XHRcdCh0eXBlb2YgZGF0ZSA9PT0gXCJudW1iZXJcIiA/IChpc05hTihkYXRlKSA/IGRlZmF1bHREYXRlIDogb2Zmc2V0TnVtZXJpYyhkYXRlKSkgOiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSkpKSk7XG5cblx0XHRuZXdEYXRlID0gKG5ld0RhdGUgJiYgbmV3RGF0ZS50b1N0cmluZygpID09PSBcIkludmFsaWQgRGF0ZVwiID8gZGVmYXVsdERhdGUgOiBuZXdEYXRlKTtcblx0XHRpZiAobmV3RGF0ZSkge1xuXHRcdFx0bmV3RGF0ZS5zZXRIb3VycygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWludXRlcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0U2Vjb25kcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cblx0ICogSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3Zlcjpcblx0ICogPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxuXHQgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0ICogQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcblx0ICogQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZVxuXHQgKi9cblx0X2RheWxpZ2h0U2F2aW5nQWRqdXN0OiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0aWYgKCFkYXRlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0ZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSArIDIgOiAwKTtcblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9zZXREYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBub0NoYW5nZSkge1xuXHRcdHZhciBjbGVhciA9ICFkYXRlLFxuXHRcdFx0b3JpZ01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoLFxuXHRcdFx0b3JpZ1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhcixcblx0XHRcdG5ld0RhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIGRhdGUsIG5ldyBEYXRlKCkpKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKChvcmlnTW9udGggIT09IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPT0gaW5zdC5zZWxlY3RlZFllYXIpICYmICFub0NoYW5nZSkge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0KTtcblx0XHRpZiAoaW5zdC5pbnB1dCkge1xuXHRcdFx0aW5zdC5pbnB1dC52YWwoY2xlYXIgPyBcIlwiIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfZ2V0RGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzdGFydERhdGUgPSAoIWluc3QuY3VycmVudFllYXIgfHwgKGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PT0gXCJcIikgPyBudWxsIDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKFxuXHRcdFx0aW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRcdHJldHVybiBzdGFydERhdGU7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBvbnh4eCBoYW5kbGVycy4gIFRoZXNlIGFyZSBkZWNsYXJlZCBzdGF0aWNhbGx5IHNvXG5cdCAqIHRoZXkgd29yayB3aXRoIHN0YXRpYyBjb2RlIHRyYW5zZm9ybWVycyBsaWtlIENhamEuXG5cdCAqL1xuXHRfYXR0YWNoSGFuZGxlcnM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RlcE1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIiksXG5cdFx0XHRpZCA9IFwiI1wiICsgaW5zdC5pZC5yZXBsYWNlKCAvXFxcXFxcXFwvZywgXCJcXFxcXCIgKTtcblx0XHRpbnN0LmRwRGl2LmZpbmQoXCJbZGF0YS1oYW5kbGVyXVwiKS5tYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB7XG5cdFx0XHRcdHByZXY6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsIC1zdGVwTW9udGhzLCBcIk1cIik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsICtzdGVwTW9udGhzLCBcIk1cIik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvZGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoaWQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3REYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShpZCwgK3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb250aFwiKSwgK3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS15ZWFyXCIpLCB0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFwiTVwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdFllYXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcihpZCwgdGhpcywgXCJZXCIpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdCQodGhpcykuYmluZCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtZXZlbnRcIiksIGhhbmRsZXJbdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZXJcIildKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgSFRNTCBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRfZ2VuZXJhdGVIVE1MOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG1heERyYXcsIHByZXZUZXh0LCBwcmV2LCBuZXh0VGV4dCwgbmV4dCwgY3VycmVudFRleHQsIGdvdG9EYXRlLFxuXHRcdFx0Y29udHJvbHMsIGJ1dHRvblBhbmVsLCBmaXJzdERheSwgc2hvd1dlZWssIGRheU5hbWVzLCBkYXlOYW1lc01pbixcblx0XHRcdG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCwgYmVmb3JlU2hvd0RheSwgc2hvd090aGVyTW9udGhzLFxuXHRcdFx0c2VsZWN0T3RoZXJNb250aHMsIGRlZmF1bHREYXRlLCBodG1sLCBkb3csIHJvdywgZ3JvdXAsIGNvbCwgc2VsZWN0ZWREYXRlLFxuXHRcdFx0Y29ybmVyQ2xhc3MsIGNhbGVuZGVyLCB0aGVhZCwgZGF5LCBkYXlzSW5Nb250aCwgbGVhZERheXMsIGN1clJvd3MsIG51bVJvd3MsXG5cdFx0XHRwcmludERhdGUsIGRSb3csIHRib2R5LCBkYXlTZXR0aW5ncywgb3RoZXJNb250aCwgdW5zZWxlY3RhYmxlLFxuXHRcdFx0dGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuXHRcdFx0dG9kYXkgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChcblx0XHRcdFx0bmV3IERhdGUodGVtcERhdGUuZ2V0RnVsbFllYXIoKSwgdGVtcERhdGUuZ2V0TW9udGgoKSwgdGVtcERhdGUuZ2V0RGF0ZSgpKSksIC8vIGNsZWFyIHRpbWVcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIiksXG5cdFx0XHRzaG93QnV0dG9uUGFuZWwgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93QnV0dG9uUGFuZWxcIiksXG5cdFx0XHRoaWRlSWZOb1ByZXZOZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiaGlkZUlmTm9QcmV2TmV4dFwiKSxcblx0XHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0XCIpLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXG5cdFx0XHRzaG93Q3VycmVudEF0UG9zID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiKSxcblx0XHRcdHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpLFxuXHRcdFx0aXNNdWx0aU1vbnRoID0gKG51bU1vbnRoc1swXSAhPT0gMSB8fCBudW1Nb250aHNbMV0gIT09IDEpLFxuXHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCgoIWluc3QuY3VycmVudERheSA/IG5ldyBEYXRlKDk5OTksIDksIDkpIDpcblx0XHRcdFx0bmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKSxcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpLFxuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIiksXG5cdFx0XHRkcmF3TW9udGggPSBpbnN0LmRyYXdNb250aCAtIHNob3dDdXJyZW50QXRQb3MsXG5cdFx0XHRkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XG5cblx0XHRpZiAoZHJhd01vbnRoIDwgMCkge1xuXHRcdFx0ZHJhd01vbnRoICs9IDEyO1xuXHRcdFx0ZHJhd1llYXItLTtcblx0XHR9XG5cdFx0aWYgKG1heERhdGUpIHtcblx0XHRcdG1heERyYXcgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShtYXhEYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdG1heERhdGUuZ2V0TW9udGgoKSAtIChudW1Nb250aHNbMF0gKiBudW1Nb250aHNbMV0pICsgMSwgbWF4RGF0ZS5nZXREYXRlKCkpKTtcblx0XHRcdG1heERyYXcgPSAobWluRGF0ZSAmJiBtYXhEcmF3IDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBtYXhEcmF3KTtcblx0XHRcdHdoaWxlICh0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoLCAxKSkgPiBtYXhEcmF3KSB7XG5cdFx0XHRcdGRyYXdNb250aC0tO1xuXHRcdFx0XHRpZiAoZHJhd01vbnRoIDwgMCkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDExO1xuXHRcdFx0XHRcdGRyYXdZZWFyLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aW5zdC5kcmF3TW9udGggPSBkcmF3TW9udGg7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGRyYXdZZWFyO1xuXG5cdFx0cHJldlRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJwcmV2VGV4dFwiKTtcblx0XHRwcmV2VGV4dCA9ICghbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IHByZXZUZXh0IDogdGhpcy5mb3JtYXREYXRlKHByZXZUZXh0LFxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCAtIHN0ZXBNb250aHMsIDEpKSxcblx0XHRcdHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSkpO1xuXG5cdFx0cHJldiA9ICh0aGlzLl9jYW5BZGp1c3RNb250aChpbnN0LCAtMSwgZHJhd1llYXIsIGRyYXdNb250aCkgP1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ncHJldicgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCIgdGl0bGU9J1wiICsgcHJldlRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJlXCIgOiBcIndcIikgKyBcIic+XCIgKyBwcmV2VGV4dCArIFwiPC9zcGFuPjwvYT5cIiA6XG5cdFx0XHQoaGlkZUlmTm9QcmV2TmV4dCA/IFwiXCIgOiBcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZCcgdGl0bGU9J1wiKyBwcmV2VGV4dCArXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIpICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIpKTtcblxuXHRcdG5leHRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwibmV4dFRleHRcIik7XG5cdFx0bmV4dFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBuZXh0VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShuZXh0VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggKyBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdG5leHQgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgKzEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J25leHQnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIpICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIisgbmV4dFRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJ3XCIgOiBcImVcIikgKyBcIic+XCIgKyBuZXh0VGV4dCArIFwiPC9zcGFuPjwvYT5cIikpO1xuXG5cdFx0Y3VycmVudFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJjdXJyZW50VGV4dFwiKTtcblx0XHRnb3RvRGF0ZSA9ICh0aGlzLl9nZXQoaW5zdCwgXCJnb3RvQ3VycmVudFwiKSAmJiBpbnN0LmN1cnJlbnREYXkgPyBjdXJyZW50RGF0ZSA6IHRvZGF5KTtcblx0XHRjdXJyZW50VGV4dCA9ICghbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IGN1cnJlbnRUZXh0IDpcblx0XHRcdHRoaXMuZm9ybWF0RGF0ZShjdXJyZW50VGV4dCwgZ290b0RhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSkpO1xuXG5cdFx0Y29udHJvbHMgPSAoIWluc3QuaW5saW5lID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0naGlkZScgZGF0YS1ldmVudD0nY2xpY2snPlwiICtcblx0XHRcdHRoaXMuX2dldChpbnN0LCBcImNsb3NlVGV4dFwiKSArIFwiPC9idXR0b24+XCIgOiBcIlwiKTtcblxuXHRcdGJ1dHRvblBhbmVsID0gKHNob3dCdXR0b25QYW5lbCkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCc+XCIgKyAoaXNSVEwgPyBjb250cm9scyA6IFwiXCIpICtcblx0XHRcdCh0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZ290b0RhdGUpID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY3VycmVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXNlY29uZGFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3RvZGF5JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIj5cIiArIGN1cnJlbnRUZXh0ICsgXCI8L2J1dHRvbj5cIiA6IFwiXCIpICsgKGlzUlRMID8gXCJcIiA6IGNvbnRyb2xzKSArIFwiPC9kaXY+XCIgOiBcIlwiO1xuXG5cdFx0Zmlyc3REYXkgPSBwYXJzZUludCh0aGlzLl9nZXQoaW5zdCwgXCJmaXJzdERheVwiKSwxMCk7XG5cdFx0Zmlyc3REYXkgPSAoaXNOYU4oZmlyc3REYXkpID8gMCA6IGZpcnN0RGF5KTtcblxuXHRcdHNob3dXZWVrID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd1dlZWtcIik7XG5cdFx0ZGF5TmFtZXMgPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1wiKTtcblx0XHRkYXlOYW1lc01pbiA9IHRoaXMuX2dldChpbnN0LCBcImRheU5hbWVzTWluXCIpO1xuXHRcdG1vbnRoTmFtZXMgPSB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzXCIpO1xuXHRcdG1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuX2dldChpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiKTtcblx0XHRiZWZvcmVTaG93RGF5ID0gdGhpcy5fZ2V0KGluc3QsIFwiYmVmb3JlU2hvd0RheVwiKTtcblx0XHRzaG93T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93T3RoZXJNb250aHNcIik7XG5cdFx0c2VsZWN0T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzZWxlY3RPdGhlck1vbnRoc1wiKTtcblx0XHRkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpO1xuXHRcdGh0bWwgPSBcIlwiO1xuXHRcdGRvdztcblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IG51bU1vbnRoc1swXTsgcm93KyspIHtcblx0XHRcdGdyb3VwID0gXCJcIjtcblx0XHRcdHRoaXMubWF4Um93cyA9IDQ7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sxXTsgY29sKyspIHtcblx0XHRcdFx0c2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgaW5zdC5zZWxlY3RlZERheSkpO1xuXHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1hbGxcIjtcblx0XHRcdFx0Y2FsZW5kZXIgPSBcIlwiO1xuXHRcdFx0XHRpZiAoaXNNdWx0aU1vbnRoKSB7XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWdyb3VwXCI7XG5cdFx0XHRcdFx0aWYgKG51bU1vbnRoc1sxXSA+IDEpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAoY29sKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKGlzUlRMID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBudW1Nb250aHNbMV0tMTogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1sYXN0XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItXCIgKyAoaXNSVEwgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjYWxlbmRlciArPSBcIiB1aS1kYXRlcGlja2VyLWdyb3VwLW1pZGRsZVwiOyBjb3JuZXJDbGFzcyA9IFwiXCI7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIic+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeFwiICsgY29ybmVyQ2xhc3MgKyBcIic+XCIgK1xuXHRcdFx0XHRcdCgvYWxsfGxlZnQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IChpc1JUTCA/IG5leHQgOiBwcmV2KSA6IFwiXCIpICtcblx0XHRcdFx0XHQoL2FsbHxyaWdodC8udGVzdChjb3JuZXJDbGFzcykgJiYgcm93ID09PSAwID8gKGlzUlRMID8gcHJldiA6IG5leHQpIDogXCJcIikgK1xuXHRcdFx0XHRcdHRoaXMuX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRcdFx0cm93ID4gMCB8fCBjb2wgPiAwLCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQpICsgLy8gZHJhdyBtb250aCBoZWFkZXJzXG5cdFx0XHRcdFx0XCI8L2Rpdj48dGFibGUgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2FsZW5kYXInPjx0aGVhZD5cIiArXG5cdFx0XHRcdFx0XCI8dHI+XCI7XG5cdFx0XHRcdHRoZWFkID0gKHNob3dXZWVrID8gXCI8dGggY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICsgdGhpcy5fZ2V0KGluc3QsIFwid2Vla0hlYWRlclwiKSArIFwiPC90aD5cIiA6IFwiXCIpO1xuXHRcdFx0XHRmb3IgKGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7IC8vIGRheXMgb2YgdGhlIHdlZWtcblx0XHRcdFx0XHRkYXkgPSAoZG93ICsgZmlyc3REYXkpICUgNztcblx0XHRcdFx0XHR0aGVhZCArPSBcIjx0aFwiICsgKChkb3cgKyBmaXJzdERheSArIDYpICUgNyA+PSA1ID8gXCIgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1lbmQnXCIgOiBcIlwiKSArIFwiPlwiICtcblx0XHRcdFx0XHRcdFwiPHNwYW4gdGl0bGU9J1wiICsgZGF5TmFtZXNbZGF5XSArIFwiJz5cIiArIGRheU5hbWVzTWluW2RheV0gKyBcIjwvc3Bhbj48L3RoPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IHRoZWFkICsgXCI8L3RyPjwvdGhlYWQ+PHRib2R5PlwiO1xuXHRcdFx0XHRkYXlzSW5Nb250aCA9IHRoaXMuX2dldERheXNJbk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpO1xuXHRcdFx0XHRpZiAoZHJhd1llYXIgPT09IGluc3Quc2VsZWN0ZWRZZWFyICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoKSB7XG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIGRheXNJbk1vbnRoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZWFkRGF5cyA9ICh0aGlzLl9nZXRGaXJzdERheU9mTW9udGgoZHJhd1llYXIsIGRyYXdNb250aCkgLSBmaXJzdERheSArIDcpICUgNztcblx0XHRcdFx0Y3VyUm93cyA9IE1hdGguY2VpbCgobGVhZERheXMgKyBkYXlzSW5Nb250aCkgLyA3KTsgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyB0byBnZW5lcmF0ZVxuXHRcdFx0XHRudW1Sb3dzID0gKGlzTXVsdGlNb250aCA/IHRoaXMubWF4Um93cyA+IGN1clJvd3MgPyB0aGlzLm1heFJvd3MgOiBjdXJSb3dzIDogY3VyUm93cyk7IC8vSWYgbXVsdGlwbGUgbW9udGhzLCB1c2UgdGhlIGhpZ2hlciBudW1iZXIgb2Ygcm93cyAoc2VlICM3MDQzKVxuXHRcdFx0XHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xuXHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoLCAxIC0gbGVhZERheXMpKTtcblx0XHRcdFx0Zm9yIChkUm93ID0gMDsgZFJvdyA8IG51bVJvd3M7IGRSb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPHRyPlwiO1xuXHRcdFx0XHRcdHRib2R5ID0gKCFzaG93V2VlayA/IFwiXCIgOiBcIjx0ZCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XCIgK1xuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsIFwiY2FsY3VsYXRlV2Vla1wiKShwcmludERhdGUpICsgXCI8L3RkPlwiKTtcblx0XHRcdFx0XHRmb3IgKGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7IC8vIGNyZWF0ZSBkYXRlIHBpY2tlciBkYXlzXG5cdFx0XHRcdFx0XHRkYXlTZXR0aW5ncyA9IChiZWZvcmVTaG93RGF5ID9cblx0XHRcdFx0XHRcdFx0YmVmb3JlU2hvd0RheS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgW3ByaW50RGF0ZV0pIDogW3RydWUsIFwiXCJdKTtcblx0XHRcdFx0XHRcdG90aGVyTW9udGggPSAocHJpbnREYXRlLmdldE1vbnRoKCkgIT09IGRyYXdNb250aCk7XG5cdFx0XHRcdFx0XHR1bnNlbGVjdGFibGUgPSAob3RoZXJNb250aCAmJiAhc2VsZWN0T3RoZXJNb250aHMpIHx8ICFkYXlTZXR0aW5nc1swXSB8fFxuXHRcdFx0XHRcdFx0XHQobWluRGF0ZSAmJiBwcmludERhdGUgPCBtaW5EYXRlKSB8fCAobWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlKTtcblx0XHRcdFx0XHRcdHRib2R5ICs9IFwiPHRkIGNsYXNzPSdcIiArXG5cdFx0XHRcdFx0XHRcdCgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFwiIHVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIiA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHdlZWtlbmRzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gXCIgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aFwiIDogXCJcIikgKyAvLyBoaWdobGlnaHQgZGF5cyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoKHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgJiYgZHJhd01vbnRoID09PSBpbnN0LnNlbGVjdGVkTW9udGggJiYgaW5zdC5fa2V5RXZlbnQpIHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcblx0XHRcdFx0XHRcdFx0KGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PT0gcHJpbnREYXRlLmdldFRpbWUoKSAmJiBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkpID9cblx0XHRcdFx0XHRcdFx0Ly8gb3IgZGVmYXVsdERhdGUgaXMgY3VycmVudCBwcmludGVkRGF0ZSBhbmQgZGVmYXVsdERhdGUgaXMgc2VsZWN0ZWREYXRlXG5cdFx0XHRcdFx0XHRcdFwiIFwiICsgdGhpcy5fZGF5T3ZlckNsYXNzIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyBcIiBcIiArIHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzICsgXCIgdWktc3RhdGUtZGlzYWJsZWRcIjogXCJcIikgKyAgLy8gaGlnaGxpZ2h0IHVuc2VsZWN0YWJsZSBkYXlzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIlwiIDogXCIgXCIgKyBkYXlTZXR0aW5nc1sxXSArIC8vIGhpZ2hsaWdodCBjdXN0b20gZGF0ZXNcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIFwiICsgdGhpcy5fY3VycmVudENsYXNzIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1kYXRlcGlja2VyLXRvZGF5XCIgOiBcIlwiKSkgKyBcIidcIiArIC8vIGhpZ2hsaWdodCB0b2RheSAoaWYgZGlmZmVyZW50KVxuXHRcdFx0XHRcdFx0XHQoKCFvdGhlck1vbnRoIHx8IHNob3dPdGhlck1vbnRocykgJiYgZGF5U2V0dGluZ3NbMl0gPyBcIiB0aXRsZT0nXCIgKyBkYXlTZXR0aW5nc1syXS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIikgKyBcIidcIiA6IFwiXCIpICsgLy8gY2VsbCB0aXRsZVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gXCJcIiA6IFwiIGRhdGEtaGFuZGxlcj0nc2VsZWN0RGF5JyBkYXRhLWV2ZW50PSdjbGljaycgZGF0YS1tb250aD0nXCIgKyBwcmludERhdGUuZ2V0TW9udGgoKSArIFwiJyBkYXRhLXllYXI9J1wiICsgcHJpbnREYXRlLmdldEZ1bGxZZWFyKCkgKyBcIidcIikgKyBcIj5cIiArIC8vIGFjdGlvbnNcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggJiYgIXNob3dPdGhlck1vbnRocyA/IFwiJiN4YTA7XCIgOiAvLyBkaXNwbGF5IGZvciBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/IFwiPHNwYW4gY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHQnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9zcGFuPlwiIDogXCI8YSBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdFwiICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWhpZ2hsaWdodFwiIDogXCJcIikgK1xuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gXCIgdWktc3RhdGUtYWN0aXZlXCIgOiBcIlwiKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggPyBcIiB1aS1wcmlvcml0eS1zZWNvbmRhcnlcIiA6IFwiXCIpICsgLy8gZGlzdGluZ3Vpc2ggZGF0ZXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0XCInIGhyZWY9JyMnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9hPlwiKSkgKyBcIjwvdGQ+XCI7IC8vIGRpc3BsYXkgc2VsZWN0YWJsZSBkYXRlXG5cdFx0XHRcdFx0XHRwcmludERhdGUuc2V0RGF0ZShwcmludERhdGUuZ2V0RGF0ZSgpICsgMSk7XG5cdFx0XHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChwcmludERhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSB0Ym9keSArIFwiPC90cj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmF3TW9udGgrKztcblx0XHRcdFx0aWYgKGRyYXdNb250aCA+IDExKSB7XG5cdFx0XHRcdFx0ZHJhd01vbnRoID0gMDtcblx0XHRcdFx0XHRkcmF3WWVhcisrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPC90Ym9keT48L3RhYmxlPlwiICsgKGlzTXVsdGlNb250aCA/IFwiPC9kaXY+XCIgK1xuXHRcdFx0XHRcdFx0XHQoKG51bU1vbnRoc1swXSA+IDAgJiYgY29sID09PSBudW1Nb250aHNbMV0tMSkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItcm93LWJyZWFrJz48L2Rpdj5cIiA6IFwiXCIpIDogXCJcIik7XG5cdFx0XHRcdGdyb3VwICs9IGNhbGVuZGVyO1xuXHRcdFx0fVxuXHRcdFx0aHRtbCArPSBncm91cDtcblx0XHR9XG5cdFx0aHRtbCArPSBidXR0b25QYW5lbDtcblx0XHRpbnN0Ll9rZXlFdmVudCA9IGZhbHNlO1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBtb250aCBhbmQgeWVhciBoZWFkZXIuICovXG5cdF9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcjogZnVuY3Rpb24oaW5zdCwgZHJhd01vbnRoLCBkcmF3WWVhciwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSB7XG5cblx0XHR2YXIgaW5NaW5ZZWFyLCBpbk1heFllYXIsIG1vbnRoLCB5ZWFycywgdGhpc1llYXIsIGRldGVybWluZVllYXIsIHllYXIsIGVuZFllYXIsXG5cdFx0XHRjaGFuZ2VNb250aCA9IHRoaXMuX2dldChpbnN0LCBcImNoYW5nZU1vbnRoXCIpLFxuXHRcdFx0Y2hhbmdlWWVhciA9IHRoaXMuX2dldChpbnN0LCBcImNoYW5nZVllYXJcIiksXG5cdFx0XHRzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93TW9udGhBZnRlclllYXJcIiksXG5cdFx0XHRodG1sID0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXRpdGxlJz5cIixcblx0XHRcdG1vbnRoSHRtbCA9IFwiXCI7XG5cblx0XHQvLyBtb250aCBzZWxlY3Rpb25cblx0XHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VNb250aCkge1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXItbW9udGgnPlwiICsgbW9udGhOYW1lc1tkcmF3TW9udGhdICsgXCI8L3NwYW4+XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluTWluWWVhciA9IChtaW5EYXRlICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIpO1xuXHRcdFx0aW5NYXhZZWFyID0gKG1heERhdGUgJiYgbWF4RGF0ZS5nZXRGdWxsWWVhcigpID09PSBkcmF3WWVhcik7XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0Zm9yICggbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG5cdFx0XHRcdGlmICgoIWluTWluWWVhciB8fCBtb250aCA+PSBtaW5EYXRlLmdldE1vbnRoKCkpICYmICghaW5NYXhZZWFyIHx8IG1vbnRoIDw9IG1heERhdGUuZ2V0TW9udGgoKSkpIHtcblx0XHRcdFx0XHRtb250aEh0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG1vbnRoICsgXCInXCIgK1xuXHRcdFx0XHRcdFx0KG1vbnRoID09PSBkcmF3TW9udGggPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIG1vbnRoTmFtZXNTaG9ydFttb250aF0gKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblx0XHR9XG5cblx0XHRpZiAoIXNob3dNb250aEFmdGVyWWVhcikge1xuXHRcdFx0aHRtbCArPSBtb250aEh0bWwgKyAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyBcIiYjeGEwO1wiIDogXCJcIik7XG5cdFx0fVxuXG5cdFx0Ly8geWVhciBzZWxlY3Rpb25cblx0XHRpZiAoICFpbnN0LnllYXJzaHRtbCApIHtcblx0XHRcdGluc3QueWVhcnNodG1sID0gXCJcIjtcblx0XHRcdGlmIChzZWNvbmRhcnkgfHwgIWNoYW5nZVllYXIpIHtcblx0XHRcdFx0aHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInPlwiICsgZHJhd1llYXIgKyBcIjwvc3Bhbj5cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XG5cdFx0XHRcdHllYXJzID0gdGhpcy5fZ2V0KGluc3QsIFwieWVhclJhbmdlXCIpLnNwbGl0KFwiOlwiKTtcblx0XHRcdFx0dGhpc1llYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGRldGVybWluZVllYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdHZhciB5ZWFyID0gKHZhbHVlLm1hdGNoKC9jWytcXC1dLiovKSA/IGRyYXdZZWFyICsgcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDEpLCAxMCkgOlxuXHRcdFx0XHRcdFx0KHZhbHVlLm1hdGNoKC9bK1xcLV0uKi8pID8gdGhpc1llYXIgKyBwYXJzZUludCh2YWx1ZSwgMTApIDpcblx0XHRcdFx0XHRcdHBhcnNlSW50KHZhbHVlLCAxMCkpKTtcblx0XHRcdFx0XHRyZXR1cm4gKGlzTmFOKHllYXIpID8gdGhpc1llYXIgOiB5ZWFyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0eWVhciA9IGRldGVybWluZVllYXIoeWVhcnNbMF0pO1xuXHRcdFx0XHRlbmRZZWFyID0gTWF0aC5tYXgoeWVhciwgZGV0ZXJtaW5lWWVhcih5ZWFyc1sxXSB8fCBcIlwiKSk7XG5cdFx0XHRcdHllYXIgPSAobWluRGF0ZSA/IE1hdGgubWF4KHllYXIsIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgOiB5ZWFyKTtcblx0XHRcdFx0ZW5kWWVhciA9IChtYXhEYXRlID8gTWF0aC5taW4oZW5kWWVhciwgbWF4RGF0ZS5nZXRGdWxsWWVhcigpKSA6IGVuZFllYXIpO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSBcIjxzZWxlY3QgY2xhc3M9J3VpLWRhdGVwaWNrZXIteWVhcicgZGF0YS1oYW5kbGVyPSdzZWxlY3RZZWFyJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0XHRmb3IgKDsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKyspIHtcblx0XHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgeWVhciArIFwiJ1wiICtcblx0XHRcdFx0XHRcdCh5ZWFyID09PSBkcmF3WWVhciA/IFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIpICtcblx0XHRcdFx0XHRcdFwiPlwiICsgeWVhciArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblxuXHRcdFx0XHRodG1sICs9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aHRtbCArPSB0aGlzLl9nZXQoaW5zdCwgXCJ5ZWFyU3VmZml4XCIpO1xuXHRcdGlmIChzaG93TW9udGhBZnRlclllYXIpIHtcblx0XHRcdGh0bWwgKz0gKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXCImI3hhMDtcIiA6IFwiXCIpICsgbW9udGhIdG1sO1xuXHRcdH1cblx0XHRodG1sICs9IFwiPC9kaXY+XCI7IC8vIENsb3NlIGRhdGVwaWNrZXJfaGVhZGVyXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0SW5zdERhdGU6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0dmFyIHllYXIgPSBpbnN0LmRyYXdZZWFyICsgKHBlcmlvZCA9PT0gXCJZXCIgPyBvZmZzZXQgOiAwKSxcblx0XHRcdG1vbnRoID0gaW5zdC5kcmF3TW9udGggKyAocGVyaW9kID09PSBcIk1cIiA/IG9mZnNldCA6IDApLFxuXHRcdFx0ZGF5ID0gTWF0aC5taW4oaW5zdC5zZWxlY3RlZERheSwgdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArIChwZXJpb2QgPT09IFwiRFwiID8gb2Zmc2V0IDogMCksXG5cdFx0XHRkYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKHBlcmlvZCA9PT0gXCJNXCIgfHwgcGVyaW9kID09PSBcIllcIikge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBFbnN1cmUgYSBkYXRlIGlzIHdpdGhpbiBhbnkgbWluL21heCBib3VuZHMuICovXG5cdF9yZXN0cmljdE1pbk1heDogZnVuY3Rpb24oaW5zdCwgZGF0ZSkge1xuXHRcdHZhciBtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpLFxuXHRcdFx0bmV3RGF0ZSA9IChtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGUpO1xuXHRcdHJldHVybiAobWF4RGF0ZSAmJiBuZXdEYXRlID4gbWF4RGF0ZSA/IG1heERhdGUgOiBuZXdEYXRlKTtcblx0fSxcblxuXHQvKiBOb3RpZnkgY2hhbmdlIG9mIG1vbnRoL3llYXIuICovXG5cdF9ub3RpZnlDaGFuZ2U6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgb25DaGFuZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJvbkNoYW5nZU1vbnRoWWVhclwiKTtcblx0XHRpZiAob25DaGFuZ2UpIHtcblx0XHRcdG9uQ2hhbmdlLmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLFxuXHRcdFx0XHRbaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3RdKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgbW9udGhzIHRvIHNob3cuICovXG5cdF9nZXROdW1iZXJPZk1vbnRoczogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJudW1iZXJPZk1vbnRoc1wiKTtcblx0XHRyZXR1cm4gKG51bU1vbnRocyA9PSBudWxsID8gWzEsIDFdIDogKHR5cGVvZiBudW1Nb250aHMgPT09IFwibnVtYmVyXCIgPyBbMSwgbnVtTW9udGhzXSA6IG51bU1vbnRocykpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGUgLSBlbnN1cmUgbm8gdGltZSBjb21wb25lbnRzIGFyZSBzZXQuICovXG5cdF9nZXRNaW5NYXhEYXRlOiBmdW5jdGlvbihpbnN0LCBtaW5NYXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCB0aGlzLl9nZXQoaW5zdCwgbWluTWF4ICsgXCJEYXRlXCIpLCBudWxsKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIGdpdmVuIG1vbnRoLiAqL1xuXHRfZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIDMyIC0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIDMyKSkuZ2V0RGF0ZSgpO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZmlyc3Qgb2YgYSBtb250aC4gKi9cblx0X2dldEZpcnN0RGF5T2ZNb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGFsbG93IGEgXCJuZXh0L3ByZXZcIiBtb250aCBkaXNwbGF5IGNoYW5nZS4gKi9cblx0X2NhbkFkanVzdE1vbnRoOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIGN1clllYXIsIGN1ck1vbnRoKSB7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGN1clllYXIsXG5cdFx0XHRjdXJNb250aCArIChvZmZzZXQgPCAwID8gb2Zmc2V0IDogbnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSwgMSkpO1xuXG5cdFx0aWYgKG9mZnNldCA8IDApIHtcblx0XHRcdGRhdGUuc2V0RGF0ZSh0aGlzLl9nZXREYXlzSW5Nb250aChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXNJblJhbmdlKGluc3QsIGRhdGUpO1xuXHR9LFxuXG5cdC8qIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBhY2NlcHRlZCByYW5nZT8gKi9cblx0X2lzSW5SYW5nZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSkge1xuXHRcdHZhciB5ZWFyU3BsaXQsIGN1cnJlbnRZZWFyLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtaW5cIiksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1heFwiKSxcblx0XHRcdG1pblllYXIgPSBudWxsLFxuXHRcdFx0bWF4WWVhciA9IG51bGwsXG5cdFx0XHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcInllYXJSYW5nZVwiKTtcblx0XHRcdGlmICh5ZWFycyl7XG5cdFx0XHRcdHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KFwiOlwiKTtcblx0XHRcdFx0Y3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdG1pblllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMF0sIDEwKTtcblx0XHRcdFx0bWF4WWVhciA9IHBhcnNlSW50KHllYXJTcGxpdFsxXSwgMTApO1xuXHRcdFx0XHRpZiAoIHllYXJTcGxpdFswXS5tYXRjaCgvWytcXC1dLiovKSApIHtcblx0XHRcdFx0XHRtaW5ZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggeWVhclNwbGl0WzFdLm1hdGNoKC9bK1xcLV0uKi8pICkge1xuXHRcdFx0XHRcdG1heFllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdHJldHVybiAoKCFtaW5EYXRlIHx8IGRhdGUuZ2V0VGltZSgpID49IG1pbkRhdGUuZ2V0VGltZSgpKSAmJlxuXHRcdFx0KCFtYXhEYXRlIHx8IGRhdGUuZ2V0VGltZSgpIDw9IG1heERhdGUuZ2V0VGltZSgpKSAmJlxuXHRcdFx0KCFtaW5ZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA+PSBtaW5ZZWFyKSAmJlxuXHRcdFx0KCFtYXhZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA8PSBtYXhZZWFyKSk7XG5cdH0sXG5cblx0LyogUHJvdmlkZSB0aGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgZm9ybWF0dGluZy9wYXJzaW5nLiAqL1xuXHRfZ2V0Rm9ybWF0Q29uZmlnOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldChpbnN0LCBcInNob3J0WWVhckN1dG9mZlwiKTtcblx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPT0gXCJzdHJpbmdcIiA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKSk7XG5cdFx0cmV0dXJuIHtzaG9ydFllYXJDdXRvZmY6IHNob3J0WWVhckN1dG9mZixcblx0XHRcdGRheU5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcImRheU5hbWVzU2hvcnRcIiksIGRheU5hbWVzOiB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1wiKSxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1Nob3J0XCIpLCBtb250aE5hbWVzOiB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzXCIpfTtcblx0fSxcblxuXHQvKiBGb3JtYXQgdGhlIGdpdmVuIGRhdGUgZm9yIGRpc3BsYXkuICovXG5cdF9mb3JtYXREYXRlOiBmdW5jdGlvbihpbnN0LCBkYXksIG1vbnRoLCB5ZWFyKSB7XG5cdFx0aWYgKCFkYXkpIHtcblx0XHRcdGluc3QuY3VycmVudERheSA9IGluc3Quc2VsZWN0ZWREYXk7XG5cdFx0XHRpbnN0LmN1cnJlbnRNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aDtcblx0XHRcdGluc3QuY3VycmVudFllYXIgPSBpbnN0LnNlbGVjdGVkWWVhcjtcblx0XHR9XG5cdFx0dmFyIGRhdGUgPSAoZGF5ID8gKHR5cGVvZiBkYXkgPT09IFwib2JqZWN0XCIgPyBkYXkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpKSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5KSkpO1xuXHRcdHJldHVybiB0aGlzLmZvcm1hdERhdGUodGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0fVxufSk7XG5cbi8qXG4gKiBCaW5kIGhvdmVyIGV2ZW50cyBmb3IgZGF0ZXBpY2tlciBlbGVtZW50cy5cbiAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxuICogR2xvYmFsIGluc3RBY3RpdmUsIHNldCBieSBfdXBkYXRlRGF0ZXBpY2tlciBhbGxvd3MgdGhlIGhhbmRsZXJzIHRvIGZpbmQgdGhlaXIgd2F5IGJhY2sgdG8gdGhlIGFjdGl2ZSBwaWNrZXIuXG4gKi9cbmZ1bmN0aW9uIGJpbmRIb3ZlcihkcERpdikge1xuXHR2YXIgc2VsZWN0b3IgPSBcImJ1dHRvbiwgLnVpLWRhdGVwaWNrZXItcHJldiwgLnVpLWRhdGVwaWNrZXItbmV4dCwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQgYVwiO1xuXHRyZXR1cm4gZHBEaXYuZGVsZWdhdGUoc2VsZWN0b3IsIFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIik7XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItcHJldlwiKSAhPT0gLTEpIHtcblx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKFwidWktZGF0ZXBpY2tlci1uZXh0XCIpICE9PSAtMSkge1xuXHRcdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LmRlbGVnYXRlKHNlbGVjdG9yLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCEkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKCBpbnN0QWN0aXZlLmlubGluZSA/IGRwRGl2LnBhcmVudCgpWzBdIDogaW5zdEFjdGl2ZS5pbnB1dFswXSkpIHtcblx0XHRcdFx0JCh0aGlzKS5wYXJlbnRzKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIikuZmluZChcImFcIikucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcblx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO1xuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItcHJldlwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKFwidWktZGF0ZXBpY2tlci1uZXh0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW5leHQtaG92ZXJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcbn1cblxuLyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cbmZ1bmN0aW9uIGV4dGVuZFJlbW92ZSh0YXJnZXQsIHByb3BzKSB7XG5cdCQuZXh0ZW5kKHRhcmdldCwgcHJvcHMpO1xuXHRmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG5cdFx0aWYgKHByb3BzW25hbWVdID09IG51bGwpIHtcblx0XHRcdHRhcmdldFtuYW1lXSA9IHByb3BzW25hbWVdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBJbnZva2UgdGhlIGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eS5cbiAgIEBwYXJhbSAgb3B0aW9ucyAgc3RyaW5nIC0gYSBjb21tYW5kLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvclxuXHRcdFx0XHRcdE9iamVjdCAtIHNldHRpbmdzIGZvciBhdHRhY2hpbmcgbmV3IGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eVxuICAgQHJldHVybiAgalF1ZXJ5IG9iamVjdCAqL1xuJC5mbi5kYXRlcGlja2VyID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cblx0LyogVmVyaWZ5IGFuIGVtcHR5IGNvbGxlY3Rpb24gd2Fzbid0IHBhc3NlZCAtIEZpeGVzICM2OTc2ICovXG5cdGlmICggIXRoaXMubGVuZ3RoICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyogSW5pdGlhbGlzZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdGlmICghJC5kYXRlcGlja2VyLmluaXRpYWxpemVkKSB7XG5cdFx0JChkb2N1bWVudCkubW91c2Vkb3duKCQuZGF0ZXBpY2tlci5fY2hlY2tFeHRlcm5hbENsaWNrKTtcblx0XHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyogQXBwZW5kIGRhdGVwaWNrZXIgbWFpbiBjb250YWluZXIgdG8gYm9keSBpZiBub3QgZXhpc3QuICovXG5cdGlmICgkKFwiI1wiKyQuZGF0ZXBpY2tlci5fbWFpbkRpdklkKS5sZW5ndGggPT09IDApIHtcblx0XHQkKFwiYm9keVwiKS5hcHBlbmQoJC5kYXRlcGlja2VyLmRwRGl2KTtcblx0fVxuXG5cdHZhciBvdGhlckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgJiYgKG9wdGlvbnMgPT09IFwiaXNEaXNhYmxlZFwiIHx8IG9wdGlvbnMgPT09IFwiZ2V0RGF0ZVwiIHx8IG9wdGlvbnMgPT09IFwid2lkZ2V0XCIpKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlcltcIl9cIiArIG9wdGlvbnMgKyBcIkRhdGVwaWNrZXJcIl0uXG5cdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzWzBdXS5jb25jYXQob3RoZXJBcmdzKSk7XG5cdH1cblx0aWYgKG9wdGlvbnMgPT09IFwib3B0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlcltcIl9cIiArIG9wdGlvbnMgKyBcIkRhdGVwaWNrZXJcIl0uXG5cdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzWzBdXS5jb25jYXQob3RoZXJBcmdzKSk7XG5cdH1cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHQkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzXS5jb25jYXQob3RoZXJBcmdzKSkgOlxuXHRcdFx0JC5kYXRlcGlja2VyLl9hdHRhY2hEYXRlcGlja2VyKHRoaXMsIG9wdGlvbnMpO1xuXHR9KTtcbn07XG5cbiQuZGF0ZXBpY2tlciA9IG5ldyBEYXRlcGlja2VyKCk7IC8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuJC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gZmFsc2U7XG4kLmRhdGVwaWNrZXIudXVpZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuJC5kYXRlcGlja2VyLnZlcnNpb24gPSBcIjEuMTAuM1wiO1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHNpemVSZWxhdGVkT3B0aW9ucyA9IHtcblx0XHRidXR0b25zOiB0cnVlLFxuXHRcdGhlaWdodDogdHJ1ZSxcblx0XHRtYXhIZWlnaHQ6IHRydWUsXG5cdFx0bWF4V2lkdGg6IHRydWUsXG5cdFx0bWluSGVpZ2h0OiB0cnVlLFxuXHRcdG1pbldpZHRoOiB0cnVlLFxuXHRcdHdpZHRoOiB0cnVlXG5cdH0sXG5cdHJlc2l6YWJsZVJlbGF0ZWRPcHRpb25zID0ge1xuXHRcdG1heEhlaWdodDogdHJ1ZSxcblx0XHRtYXhXaWR0aDogdHJ1ZSxcblx0XHRtaW5IZWlnaHQ6IHRydWUsXG5cdFx0bWluV2lkdGg6IHRydWVcblx0fTtcblxuJC53aWRnZXQoIFwidWkuZGlhbG9nXCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjNcIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcImJvZHlcIixcblx0XHRhdXRvT3BlbjogdHJ1ZSxcblx0XHRidXR0b25zOiBbXSxcblx0XHRjbG9zZU9uRXNjYXBlOiB0cnVlLFxuXHRcdGNsb3NlVGV4dDogXCJjbG9zZVwiLFxuXHRcdGRpYWxvZ0NsYXNzOiBcIlwiLFxuXHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRoaWRlOiBudWxsLFxuXHRcdGhlaWdodDogXCJhdXRvXCIsXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxuXHRcdG1heFdpZHRoOiBudWxsLFxuXHRcdG1pbkhlaWdodDogMTUwLFxuXHRcdG1pbldpZHRoOiAxNTAsXG5cdFx0bW9kYWw6IGZhbHNlLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJjZW50ZXJcIixcblx0XHRcdGF0OiBcImNlbnRlclwiLFxuXHRcdFx0b2Y6IHdpbmRvdyxcblx0XHRcdGNvbGxpc2lvbjogXCJmaXRcIixcblx0XHRcdC8vIEVuc3VyZSB0aGUgdGl0bGViYXIgaXMgYWx3YXlzIHZpc2libGVcblx0XHRcdHVzaW5nOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0XHR2YXIgdG9wT2Zmc2V0ID0gJCggdGhpcyApLmNzcyggcG9zICkub2Zmc2V0KCkudG9wO1xuXHRcdFx0XHRpZiAoIHRvcE9mZnNldCA8IDAgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmNzcyggXCJ0b3BcIiwgcG9zLnRvcCAtIHRvcE9mZnNldCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXNpemFibGU6IHRydWUsXG5cdFx0c2hvdzogbnVsbCxcblx0XHR0aXRsZTogbnVsbCxcblx0XHR3aWR0aDogMzAwLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0YmVmb3JlQ2xvc2U6IG51bGwsXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0ZHJhZzogbnVsbCxcblx0XHRkcmFnU3RhcnQ6IG51bGwsXG5cdFx0ZHJhZ1N0b3A6IG51bGwsXG5cdFx0Zm9jdXM6IG51bGwsXG5cdFx0b3BlbjogbnVsbCxcblx0XHRyZXNpemU6IG51bGwsXG5cdFx0cmVzaXplU3RhcnQ6IG51bGwsXG5cdFx0cmVzaXplU3RvcDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luYWxDc3MgPSB7XG5cdFx0XHRkaXNwbGF5OiB0aGlzLmVsZW1lbnRbMF0uc3R5bGUuZGlzcGxheSxcblx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnRbMF0uc3R5bGUud2lkdGgsXG5cdFx0XHRtaW5IZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5taW5IZWlnaHQsXG5cdFx0XHRtYXhIZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5tYXhIZWlnaHQsXG5cdFx0XHRoZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5oZWlnaHRcblx0XHR9O1xuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHtcblx0XHRcdHBhcmVudDogdGhpcy5lbGVtZW50LnBhcmVudCgpLFxuXHRcdFx0aW5kZXg6IHRoaXMuZWxlbWVudC5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4KCB0aGlzLmVsZW1lbnQgKVxuXHRcdH07XG5cdFx0dGhpcy5vcmlnaW5hbFRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoXCJ0aXRsZVwiKTtcblx0XHR0aGlzLm9wdGlvbnMudGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGUgfHwgdGhpcy5vcmlnaW5hbFRpdGxlO1xuXG5cdFx0dGhpcy5fY3JlYXRlV3JhcHBlcigpO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuc2hvdygpXG5cdFx0XHQucmVtb3ZlQXR0cihcInRpdGxlXCIpXG5cdFx0XHQuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudFwiKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLnVpRGlhbG9nICk7XG5cblx0XHR0aGlzLl9jcmVhdGVUaXRsZWJhcigpO1xuXHRcdHRoaXMuX2NyZWF0ZUJ1dHRvblBhbmUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRyYWdnYWJsZSAmJiAkLmZuLmRyYWdnYWJsZSApIHtcblx0XHRcdHRoaXMuX21ha2VEcmFnZ2FibGUoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXphYmxlICYmICQuZm4ucmVzaXphYmxlICkge1xuXHRcdFx0dGhpcy5fbWFrZVJlc2l6YWJsZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuXHR9LFxuXG5cdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hdXRvT3BlbiApIHtcblx0XHRcdHRoaXMub3BlbigpO1xuXHRcdH1cblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuXHRcdGlmICggZWxlbWVudCAmJiAoZWxlbWVudC5qcXVlcnkgfHwgZWxlbWVudC5ub2RlVHlwZSkgKSB7XG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kb2N1bWVudC5maW5kKCBlbGVtZW50IHx8IFwiYm9keVwiICkuZXEoIDAgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5leHQsXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xuXG5cdFx0dGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZVVuaXF1ZUlkKClcblx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLWRpYWxvZy1jb250ZW50IHVpLXdpZGdldC1jb250ZW50XCIpXG5cdFx0XHQuY3NzKCB0aGlzLm9yaWdpbmFsQ3NzIClcblx0XHRcdC8vIFdpdGhvdXQgZGV0YWNoaW5nIGZpcnN0LCB0aGUgZm9sbG93aW5nIGJlY29tZXMgcmVhbGx5IHNsb3dcblx0XHRcdC5kZXRhY2goKTtcblxuXHRcdHRoaXMudWlEaWFsb2cuc3RvcCggdHJ1ZSwgdHJ1ZSApLnJlbW92ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9yaWdpbmFsVGl0bGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiLCB0aGlzLm9yaWdpbmFsVGl0bGUgKTtcblx0XHR9XG5cblx0XHRuZXh0ID0gb3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuY2hpbGRyZW4oKS5lcSggb3JpZ2luYWxQb3NpdGlvbi5pbmRleCApO1xuXHRcdC8vIERvbid0IHRyeSB0byBwbGFjZSB0aGUgZGlhbG9nIG5leHQgdG8gaXRzZWxmICgjODYxMylcblx0XHRpZiAoIG5leHQubGVuZ3RoICYmIG5leHRbMF0gIT09IHRoaXMuZWxlbWVudFswXSApIHtcblx0XHRcdG5leHQuYmVmb3JlKCB0aGlzLmVsZW1lbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuYXBwZW5kKCB0aGlzLmVsZW1lbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aURpYWxvZztcblx0fSxcblxuXHRkaXNhYmxlOiAkLm5vb3AsXG5cdGVuYWJsZTogJC5ub29wLFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKCAhdGhpcy5faXNPcGVuIHx8IHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQ2xvc2VcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XG5cdFx0dGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcblxuXHRcdGlmICggIXRoaXMub3BlbmVyLmZpbHRlcihcIjpmb2N1c2FibGVcIikuZm9jdXMoKS5sZW5ndGggKSB7XG5cdFx0XHQvLyBIaWRpbmcgYSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCB0cmlnZ2VyIGJsdXIgaW4gV2ViS2l0XG5cdFx0XHQvLyBzbyBpbiBjYXNlIHdlIGhhdmUgbm90aGluZyB0byBmb2N1cyBvbiwgZXhwbGljaXRseSBibHVyIHRoZSBhY3RpdmUgZWxlbWVudFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ3MTgyXG5cdFx0XHQkKCB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKS5ibHVyKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faGlkZSggdGhpcy51aURpYWxvZywgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGlzT3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT3Blbjtcblx0fSxcblxuXHRtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX21vdmVUb1RvcCgpO1xuXHR9LFxuXG5cdF9tb3ZlVG9Ub3A6IGZ1bmN0aW9uKCBldmVudCwgc2lsZW50ICkge1xuXHRcdHZhciBtb3ZlZCA9ICEhdGhpcy51aURpYWxvZy5uZXh0QWxsKFwiOnZpc2libGVcIikuaW5zZXJ0QmVmb3JlKCB0aGlzLnVpRGlhbG9nICkubGVuZ3RoO1xuXHRcdGlmICggbW92ZWQgJiYgIXNpbGVudCApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1vdmVkO1xuXHR9LFxuXG5cdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRpZiAoIHRoaXMuX2lzT3BlbiApIHtcblx0XHRcdGlmICggdGhpcy5fbW92ZVRvVG9wKCkgKSB7XG5cdFx0XHRcdHRoaXMuX2ZvY3VzVGFiYmFibGUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pc09wZW4gPSB0cnVlO1xuXHRcdHRoaXMub3BlbmVyID0gJCggdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICk7XG5cblx0XHR0aGlzLl9zaXplKCk7XG5cdFx0dGhpcy5fcG9zaXRpb24oKTtcblx0XHR0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG5cdFx0dGhpcy5fbW92ZVRvVG9wKCBudWxsLCB0cnVlICk7XG5cdFx0dGhpcy5fc2hvdyggdGhpcy51aURpYWxvZywgdGhpcy5vcHRpb25zLnNob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fZm9jdXNUYWJiYWJsZSgpO1xuXHRcdFx0dGhhdC5fdHJpZ2dlcihcImZvY3VzXCIpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fdHJpZ2dlcihcIm9wZW5cIik7XG5cdH0sXG5cblx0X2ZvY3VzVGFiYmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFNldCBmb2N1cyB0byB0aGUgZmlyc3QgbWF0Y2g6XG5cdFx0Ly8gMS4gRmlyc3QgZWxlbWVudCBpbnNpZGUgdGhlIGRpYWxvZyBtYXRjaGluZyBbYXV0b2ZvY3VzXVxuXHRcdC8vIDIuIFRhYmJhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBjb250ZW50IGVsZW1lbnRcblx0XHQvLyAzLiBUYWJiYWJsZSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9ucGFuZVxuXHRcdC8vIDQuIFRoZSBjbG9zZSBidXR0b25cblx0XHQvLyA1LiBUaGUgZGlhbG9nIGl0c2VsZlxuXHRcdHZhciBoYXNGb2N1cyA9IHRoaXMuZWxlbWVudC5maW5kKFwiW2F1dG9mb2N1c11cIik7XG5cdFx0aWYgKCAhaGFzRm9jdXMubGVuZ3RoICkge1xuXHRcdFx0aGFzRm9jdXMgPSB0aGlzLmVsZW1lbnQuZmluZChcIjp0YWJiYWJsZVwiKTtcblx0XHR9XG5cdFx0aWYgKCAhaGFzRm9jdXMubGVuZ3RoICkge1xuXHRcdFx0aGFzRm9jdXMgPSB0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5maW5kKFwiOnRhYmJhYmxlXCIpO1xuXHRcdH1cblx0XHRpZiAoICFoYXNGb2N1cy5sZW5ndGggKSB7XG5cdFx0XHRoYXNGb2N1cyA9IHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlLmZpbHRlcihcIjp0YWJiYWJsZVwiKTtcblx0XHR9XG5cdFx0aWYgKCAhaGFzRm9jdXMubGVuZ3RoICkge1xuXHRcdFx0aGFzRm9jdXMgPSB0aGlzLnVpRGlhbG9nO1xuXHRcdH1cblx0XHRoYXNGb2N1cy5lcSggMCApLmZvY3VzKCk7XG5cdH0sXG5cblx0X2tlZXBGb2N1czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGZ1bmN0aW9uIGNoZWNrRm9jdXMoKSB7XG5cdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCxcblx0XHRcdFx0aXNBY3RpdmUgPSB0aGlzLnVpRGlhbG9nWzBdID09PSBhY3RpdmVFbGVtZW50IHx8XG5cdFx0XHRcdFx0JC5jb250YWlucyggdGhpcy51aURpYWxvZ1swXSwgYWN0aXZlRWxlbWVudCApO1xuXHRcdFx0aWYgKCAhaXNBY3RpdmUgKSB7XG5cdFx0XHRcdHRoaXMuX2ZvY3VzVGFiYmFibGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRjaGVja0ZvY3VzLmNhbGwoIHRoaXMgKTtcblx0XHQvLyBzdXBwb3J0OiBJRVxuXHRcdC8vIElFIDw9IDggZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxuXHRcdC8vIHNvIHdlIGNoZWNrIGFnYWluIGxhdGVyXG5cdFx0dGhpcy5fZGVsYXkoIGNoZWNrRm9jdXMgKTtcblx0fSxcblxuXHRfY3JlYXRlV3JhcHBlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51aURpYWxvZyA9ICQoXCI8ZGl2PlwiKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWRpYWxvZyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS1mcm9udCBcIiArXG5cdFx0XHRcdHRoaXMub3B0aW9ucy5kaWFsb2dDbGFzcyApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdC8vIFNldHRpbmcgdGFiSW5kZXggbWFrZXMgdGhlIGRpdiBmb2N1c2FibGVcblx0XHRcdFx0dGFiSW5kZXg6IC0xLFxuXHRcdFx0XHRyb2xlOiBcImRpYWxvZ1wiXG5cdFx0XHR9KVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy51aURpYWxvZywge1xuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjYXBlICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBldmVudC5rZXlDb2RlICYmXG5cdFx0XHRcdFx0XHRldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwcmV2ZW50IHRhYmJpbmcgb3V0IG9mIGRpYWxvZ3Ncblx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlICE9PSAkLnVpLmtleUNvZGUuVEFCICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdGFiYmFibGVzID0gdGhpcy51aURpYWxvZy5maW5kKFwiOnRhYmJhYmxlXCIpLFxuXHRcdFx0XHRcdGZpcnN0ID0gdGFiYmFibGVzLmZpbHRlcihcIjpmaXJzdFwiKSxcblx0XHRcdFx0XHRsYXN0ICA9IHRhYmJhYmxlcy5maWx0ZXIoXCI6bGFzdFwiKTtcblxuXHRcdFx0XHRpZiAoICggZXZlbnQudGFyZ2V0ID09PSBsYXN0WzBdIHx8IGV2ZW50LnRhcmdldCA9PT0gdGhpcy51aURpYWxvZ1swXSApICYmICFldmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0XHRmaXJzdC5mb2N1cyggMSApO1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICggZXZlbnQudGFyZ2V0ID09PSBmaXJzdFswXSB8fCBldmVudC50YXJnZXQgPT09IHRoaXMudWlEaWFsb2dbMF0gKSAmJiBldmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0XHRsYXN0LmZvY3VzKCAxICk7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1vdXNlZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX21vdmVUb1RvcCggZXZlbnQgKSApIHtcblx0XHRcdFx0XHR0aGlzLl9mb2N1c1RhYmJhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGFueSBleGlzdGluZyBhcmlhLWRlc2NyaWJlZGJ5IGF0dHJpYnV0ZSBtZWFuc1xuXHRcdC8vIHRoYXQgdGhlIGRpYWxvZyBjb250ZW50IGlzIG1hcmtlZCB1cCBwcm9wZXJseVxuXHRcdC8vIG90aGVyd2lzZSB3ZSBicnV0ZSBmb3JjZSB0aGUgY29udGVudCBhcyB0aGUgZGVzY3JpcHRpb25cblx0XHRpZiAoICF0aGlzLmVsZW1lbnQuZmluZChcIlthcmlhLWRlc2NyaWJlZGJ5XVwiKS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtZGVzY3JpYmVkYnlcIjogdGhpcy5lbGVtZW50LnVuaXF1ZUlkKCkuYXR0cihcImlkXCIpXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZVRpdGxlYmFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWlEaWFsb2dUaXRsZTtcblxuXHRcdHRoaXMudWlEaWFsb2dUaXRsZWJhciA9ICQoXCI8ZGl2PlwiKVxuXHRcdFx0LmFkZENsYXNzKFwidWktZGlhbG9nLXRpdGxlYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXhcIilcblx0XHRcdC5wcmVwZW5kVG8oIHRoaXMudWlEaWFsb2cgKTtcblx0XHR0aGlzLl9vbiggdGhpcy51aURpYWxvZ1RpdGxlYmFyLCB7XG5cdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgcHJldmVudCBjbGljayBvbiBjbG9zZSBidXR0b24gKCM4ODM4KVxuXHRcdFx0XHQvLyBGb2N1c2luZyBhIGRpYWxvZyB0aGF0IGlzIHBhcnRpYWxseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuXHRcdFx0XHQvLyBjYXVzZXMgdGhlIGJyb3dzZXIgdG8gc2Nyb2xsIGl0IGludG8gdmlldywgcHJldmVudGluZyB0aGUgY2xpY2sgZXZlbnRcblx0XHRcdFx0aWYgKCAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdChcIi51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIikgKSB7XG5cdFx0XHRcdFx0Ly8gRGlhbG9nIGlzbid0IGdldHRpbmcgZm9jdXMgd2hlbiBkcmFnZ2luZyAoIzgwNjMpXG5cdFx0XHRcdFx0dGhpcy51aURpYWxvZy5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZSA9ICQoXCI8YnV0dG9uPjwvYnV0dG9uPlwiKVxuXHRcdFx0LmJ1dHRvbih7XG5cdFx0XHRcdGxhYmVsOiB0aGlzLm9wdGlvbnMuY2xvc2VUZXh0LFxuXHRcdFx0XHRpY29uczoge1xuXHRcdFx0XHRcdHByaW1hcnk6IFwidWktaWNvbi1jbG9zZXRoaWNrXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0dGV4dDogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHQuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIilcblx0XHRcdC5hcHBlbmRUbyggdGhpcy51aURpYWxvZ1RpdGxlYmFyICk7XG5cdFx0dGhpcy5fb24oIHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlLCB7XG5cdFx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dWlEaWFsb2dUaXRsZSA9ICQoXCI8c3Bhbj5cIilcblx0XHRcdC51bmlxdWVJZCgpXG5cdFx0XHQuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctdGl0bGVcIilcblx0XHRcdC5wcmVwZW5kVG8oIHRoaXMudWlEaWFsb2dUaXRsZWJhciApO1xuXHRcdHRoaXMuX3RpdGxlKCB1aURpYWxvZ1RpdGxlICk7XG5cblx0XHR0aGlzLnVpRGlhbG9nLmF0dHIoe1xuXHRcdFx0XCJhcmlhLWxhYmVsbGVkYnlcIjogdWlEaWFsb2dUaXRsZS5hdHRyKFwiaWRcIilcblx0XHR9KTtcblx0fSxcblxuXHRfdGl0bGU6IGZ1bmN0aW9uKCB0aXRsZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMudGl0bGUgKSB7XG5cdFx0XHR0aXRsZS5odG1sKFwiJiMxNjA7XCIpO1xuXHRcdH1cblx0XHR0aXRsZS50ZXh0KCB0aGlzLm9wdGlvbnMudGl0bGUgKTtcblx0fSxcblxuXHRfY3JlYXRlQnV0dG9uUGFuZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUgPSAkKFwiPGRpdj5cIilcblx0XHRcdC5hZGRDbGFzcyhcInVpLWRpYWxvZy1idXR0b25wYW5lIHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeFwiKTtcblxuXHRcdHRoaXMudWlCdXR0b25TZXQgPSAkKFwiPGRpdj5cIilcblx0XHRcdC5hZGRDbGFzcyhcInVpLWRpYWxvZy1idXR0b25zZXRcIilcblx0XHRcdC5hcHBlbmRUbyggdGhpcy51aURpYWxvZ0J1dHRvblBhbmUgKTtcblxuXHRcdHRoaXMuX2NyZWF0ZUJ1dHRvbnMoKTtcblx0fSxcblxuXHRfY3JlYXRlQnV0dG9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnV0dG9ucyA9IHRoaXMub3B0aW9ucy5idXR0b25zO1xuXG5cdFx0Ly8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgYnV0dG9uIHBhbmUsIHJlbW92ZSBpdFxuXHRcdHRoaXMudWlEaWFsb2dCdXR0b25QYW5lLnJlbW92ZSgpO1xuXHRcdHRoaXMudWlCdXR0b25TZXQuZW1wdHkoKTtcblxuXHRcdGlmICggJC5pc0VtcHR5T2JqZWN0KCBidXR0b25zICkgfHwgKCQuaXNBcnJheSggYnV0dG9ucyApICYmICFidXR0b25zLmxlbmd0aCkgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLnJlbW92ZUNsYXNzKFwidWktZGlhbG9nLWJ1dHRvbnNcIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBidXR0b25zLCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdFx0XHR2YXIgY2xpY2ssIGJ1dHRvbk9wdGlvbnM7XG5cdFx0XHRwcm9wcyA9ICQuaXNGdW5jdGlvbiggcHJvcHMgKSA/XG5cdFx0XHRcdHsgY2xpY2s6IHByb3BzLCB0ZXh0OiBuYW1lIH0gOlxuXHRcdFx0XHRwcm9wcztcblx0XHRcdC8vIERlZmF1bHQgdG8gYSBub24tc3VibWl0dGluZyBidXR0b25cblx0XHRcdHByb3BzID0gJC5leHRlbmQoIHsgdHlwZTogXCJidXR0b25cIiB9LCBwcm9wcyApO1xuXHRcdFx0Ly8gQ2hhbmdlIHRoZSBjb250ZXh0IGZvciB0aGUgY2xpY2sgY2FsbGJhY2sgdG8gYmUgdGhlIG1haW4gZWxlbWVudFxuXHRcdFx0Y2xpY2sgPSBwcm9wcy5jbGljaztcblx0XHRcdHByb3BzLmNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNsaWNrLmFwcGx5KCB0aGF0LmVsZW1lbnRbMF0sIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdGJ1dHRvbk9wdGlvbnMgPSB7XG5cdFx0XHRcdGljb25zOiBwcm9wcy5pY29ucyxcblx0XHRcdFx0dGV4dDogcHJvcHMuc2hvd1RleHRcblx0XHRcdH07XG5cdFx0XHRkZWxldGUgcHJvcHMuaWNvbnM7XG5cdFx0XHRkZWxldGUgcHJvcHMuc2hvd1RleHQ7XG5cdFx0XHQkKCBcIjxidXR0b24+PC9idXR0b24+XCIsIHByb3BzIClcblx0XHRcdFx0LmJ1dHRvbiggYnV0dG9uT3B0aW9ucyApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGhhdC51aUJ1dHRvblNldCApO1xuXHRcdH0pO1xuXHRcdHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoXCJ1aS1kaWFsb2ctYnV0dG9uc1wiKTtcblx0XHR0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5hcHBlbmRUbyggdGhpcy51aURpYWxvZyApO1xuXHR9LFxuXG5cdF9tYWtlRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSggdWkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwb3NpdGlvbjogdWkucG9zaXRpb24sXG5cdFx0XHRcdG9mZnNldDogdWkub2Zmc2V0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMudWlEaWFsb2cuZHJhZ2dhYmxlKHtcblx0XHRcdGNhbmNlbDogXCIudWktZGlhbG9nLWNvbnRlbnQsIC51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIixcblx0XHRcdGhhbmRsZTogXCIudWktZGlhbG9nLXRpdGxlYmFyXCIsXG5cdFx0XHRjb250YWlubWVudDogXCJkb2N1bWVudFwiLFxuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyhcInVpLWRpYWxvZy1kcmFnZ2luZ1wiKTtcblx0XHRcdFx0dGhhdC5fYmxvY2tGcmFtZXMoKTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJkcmFnU3RhcnRcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImRyYWdcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHRvcHRpb25zLnBvc2l0aW9uID0gW1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLmxlZnQgLSB0aGF0LmRvY3VtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpXG5cdFx0XHRcdF07XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyhcInVpLWRpYWxvZy1kcmFnZ2luZ1wiKTtcblx0XHRcdFx0dGhhdC5fdW5ibG9ja0ZyYW1lcygpO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImRyYWdTdG9wXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X21ha2VSZXNpemFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRoYW5kbGVzID0gb3B0aW9ucy5yZXNpemFibGUsXG5cdFx0XHQvLyAudWktcmVzaXphYmxlIGhhcyBwb3NpdGlvbjogcmVsYXRpdmUgZGVmaW5lZCBpbiB0aGUgc3R5bGVzaGVldFxuXHRcdFx0Ly8gYnV0IGRpYWxvZ3MgaGF2ZSB0byB1c2UgYWJzb2x1dGUgb3IgZml4ZWQgcG9zaXRpb25pbmdcblx0XHRcdHBvc2l0aW9uID0gdGhpcy51aURpYWxvZy5jc3MoXCJwb3NpdGlvblwiKSxcblx0XHRcdHJlc2l6ZUhhbmRsZXMgPSB0eXBlb2YgaGFuZGxlcyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGhhbmRsZXNcdDpcblx0XHRcdFx0XCJuLGUscyx3LHNlLHN3LG5lLG53XCI7XG5cblx0XHRmdW5jdGlvbiBmaWx0ZXJlZFVpKCB1aSApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHVpLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRcdG9yaWdpbmFsU2l6ZTogdWkub3JpZ2luYWxTaXplLFxuXHRcdFx0XHRwb3NpdGlvbjogdWkucG9zaXRpb24sXG5cdFx0XHRcdHNpemU6IHVpLnNpemVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpcy51aURpYWxvZy5yZXNpemFibGUoe1xuXHRcdFx0Y2FuY2VsOiBcIi51aS1kaWFsb2ctY29udGVudFwiLFxuXHRcdFx0Y29udGFpbm1lbnQ6IFwiZG9jdW1lbnRcIixcblx0XHRcdGFsc29SZXNpemU6IHRoaXMuZWxlbWVudCxcblx0XHRcdG1heFdpZHRoOiBvcHRpb25zLm1heFdpZHRoLFxuXHRcdFx0bWF4SGVpZ2h0OiBvcHRpb25zLm1heEhlaWdodCxcblx0XHRcdG1pbldpZHRoOiBvcHRpb25zLm1pbldpZHRoLFxuXHRcdFx0bWluSGVpZ2h0OiB0aGlzLl9taW5IZWlnaHQoKSxcblx0XHRcdGhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXG5cdFx0XHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKFwidWktZGlhbG9nLXJlc2l6aW5nXCIpO1xuXHRcdFx0XHR0aGF0Ll9ibG9ja0ZyYW1lcygpO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVN0YXJ0XCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzaXplOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVwiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdG9wdGlvbnMuaGVpZ2h0ID0gJCggdGhpcyApLmhlaWdodCgpO1xuXHRcdFx0XHRvcHRpb25zLndpZHRoID0gJCggdGhpcyApLndpZHRoKCk7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyhcInVpLWRpYWxvZy1yZXNpemluZ1wiKTtcblx0XHRcdFx0dGhhdC5fdW5ibG9ja0ZyYW1lcygpO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInJlc2l6ZVN0b3BcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5jc3MoIFwicG9zaXRpb25cIiwgcG9zaXRpb24gKTtcblx0fSxcblxuXHRfbWluSGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHJldHVybiBvcHRpb25zLmhlaWdodCA9PT0gXCJhdXRvXCIgP1xuXHRcdFx0b3B0aW9ucy5taW5IZWlnaHQgOlxuXHRcdFx0TWF0aC5taW4oIG9wdGlvbnMubWluSGVpZ2h0LCBvcHRpb25zLmhlaWdodCApO1xuXHR9LFxuXG5cdF9wb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gTmVlZCB0byBzaG93IHRoZSBkaWFsb2cgdG8gZ2V0IHRoZSBhY3R1YWwgb2Zmc2V0IGluIHRoZSBwb3NpdGlvbiBwbHVnaW5cblx0XHR2YXIgaXNWaXNpYmxlID0gdGhpcy51aURpYWxvZy5pcyhcIjp2aXNpYmxlXCIpO1xuXHRcdGlmICggIWlzVmlzaWJsZSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xuXHRcdH1cblx0XHR0aGlzLnVpRGlhbG9nLnBvc2l0aW9uKCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLmhpZGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHJlc2l6ZSA9IGZhbHNlLFxuXHRcdFx0cmVzaXphYmxlT3B0aW9ucyA9IHt9O1xuXG5cdFx0JC5lYWNoKCBvcHRpb25zLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3NldE9wdGlvbigga2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGtleSBpbiBzaXplUmVsYXRlZE9wdGlvbnMgKSB7XG5cdFx0XHRcdHJlc2l6ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGtleSBpbiByZXNpemFibGVSZWxhdGVkT3B0aW9ucyApIHtcblx0XHRcdFx0cmVzaXphYmxlT3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICggcmVzaXplICkge1xuXHRcdFx0dGhpcy5fc2l6ZSgpO1xuXHRcdFx0dGhpcy5fcG9zaXRpb24oKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnVpRGlhbG9nLmlzKFwiOmRhdGEodWktcmVzaXphYmxlKVwiKSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCByZXNpemFibGVPcHRpb25zICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MTUqL1xuXHRcdHZhciBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUsXG5cdFx0XHR1aURpYWxvZyA9IHRoaXMudWlEaWFsb2c7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaWFsb2dDbGFzc1wiICkge1xuXHRcdFx0dWlEaWFsb2dcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuZGlhbG9nQ2xhc3MgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiYXBwZW5kVG9cIiApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJidXR0b25zXCIgKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVCdXR0b25zKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiY2xvc2VUZXh0XCIgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZS5idXR0b24oe1xuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCB3ZSBhbHdheXMgcGFzcyBhIHN0cmluZ1xuXHRcdFx0XHRsYWJlbDogXCJcIiArIHZhbHVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkcmFnZ2FibGVcIiApIHtcblx0XHRcdGlzRHJhZ2dhYmxlID0gdWlEaWFsb2cuaXMoXCI6ZGF0YSh1aS1kcmFnZ2FibGUpXCIpO1xuXHRcdFx0aWYgKCBpc0RyYWdnYWJsZSAmJiAhdmFsdWUgKSB7XG5cdFx0XHRcdHVpRGlhbG9nLmRyYWdnYWJsZShcImRlc3Ryb3lcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIWlzRHJhZ2dhYmxlICYmIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLl9tYWtlRHJhZ2dhYmxlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwicG9zaXRpb25cIiApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwicmVzaXphYmxlXCIgKSB7XG5cdFx0XHQvLyBjdXJyZW50bHkgcmVzaXphYmxlLCBiZWNvbWluZyBub24tcmVzaXphYmxlXG5cdFx0XHRpc1Jlc2l6YWJsZSA9IHVpRGlhbG9nLmlzKFwiOmRhdGEodWktcmVzaXphYmxlKVwiKTtcblx0XHRcdGlmICggaXNSZXNpemFibGUgJiYgIXZhbHVlICkge1xuXHRcdFx0XHR1aURpYWxvZy5yZXNpemFibGUoXCJkZXN0cm95XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXJyZW50bHkgcmVzaXphYmxlLCBjaGFuZ2luZyBoYW5kbGVzXG5cdFx0XHRpZiAoIGlzUmVzaXphYmxlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0dWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCBcImhhbmRsZXNcIiwgdmFsdWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3VycmVudGx5IG5vbi1yZXNpemFibGUsIGJlY29taW5nIHJlc2l6YWJsZVxuXHRcdFx0aWYgKCAhaXNSZXNpemFibGUgJiYgdmFsdWUgIT09IGZhbHNlICkge1xuXHRcdFx0XHR0aGlzLl9tYWtlUmVzaXphYmxlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwidGl0bGVcIiApIHtcblx0XHRcdHRoaXMuX3RpdGxlKCB0aGlzLnVpRGlhbG9nVGl0bGViYXIuZmluZChcIi51aS1kaWFsb2ctdGl0bGVcIikgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIElmIHRoZSB1c2VyIGhhcyByZXNpemVkIHRoZSBkaWFsb2csIHRoZSAudWktZGlhbG9nIGFuZCAudWktZGlhbG9nLWNvbnRlbnRcblx0XHQvLyBkaXZzIHdpbGwgYm90aCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgc2V0LCBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZW1cblx0XHR2YXIgbm9uQ29udGVudEhlaWdodCwgbWluQ29udGVudEhlaWdodCwgbWF4Q29udGVudEhlaWdodCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBSZXNldCBjb250ZW50IHNpemluZ1xuXHRcdHRoaXMuZWxlbWVudC5zaG93KCkuY3NzKHtcblx0XHRcdHdpZHRoOiBcImF1dG9cIixcblx0XHRcdG1pbkhlaWdodDogMCxcblx0XHRcdG1heEhlaWdodDogXCJub25lXCIsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9KTtcblxuXHRcdGlmICggb3B0aW9ucy5taW5XaWR0aCA+IG9wdGlvbnMud2lkdGggKSB7XG5cdFx0XHRvcHRpb25zLndpZHRoID0gb3B0aW9ucy5taW5XaWR0aDtcblx0XHR9XG5cblx0XHQvLyByZXNldCB3cmFwcGVyIHNpemluZ1xuXHRcdC8vIGRldGVybWluZSB0aGUgaGVpZ2h0IG9mIGFsbCB0aGUgbm9uLWNvbnRlbnQgZWxlbWVudHNcblx0XHRub25Db250ZW50SGVpZ2h0ID0gdGhpcy51aURpYWxvZy5jc3Moe1xuXHRcdFx0XHRoZWlnaHQ6IFwiYXV0b1wiLFxuXHRcdFx0XHR3aWR0aDogb3B0aW9ucy53aWR0aFxuXHRcdFx0fSlcblx0XHRcdC5vdXRlckhlaWdodCgpO1xuXHRcdG1pbkNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heCggMCwgb3B0aW9ucy5taW5IZWlnaHQgLSBub25Db250ZW50SGVpZ2h0ICk7XG5cdFx0bWF4Q29udGVudEhlaWdodCA9IHR5cGVvZiBvcHRpb25zLm1heEhlaWdodCA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRNYXRoLm1heCggMCwgb3B0aW9ucy5tYXhIZWlnaHQgLSBub25Db250ZW50SGVpZ2h0ICkgOlxuXHRcdFx0XCJub25lXCI7XG5cblx0XHRpZiAoIG9wdGlvbnMuaGVpZ2h0ID09PSBcImF1dG9cIiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5jc3Moe1xuXHRcdFx0XHRtaW5IZWlnaHQ6IG1pbkNvbnRlbnRIZWlnaHQsXG5cdFx0XHRcdG1heEhlaWdodDogbWF4Q29udGVudEhlaWdodCxcblx0XHRcdFx0aGVpZ2h0OiBcImF1dG9cIlxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5oZWlnaHQoIE1hdGgubWF4KCAwLCBvcHRpb25zLmhlaWdodCAtIG5vbkNvbnRlbnRIZWlnaHQgKSApO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnVpRGlhbG9nLmlzKFwiOmRhdGEodWktcmVzaXphYmxlKVwiKSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCBcIm1pbkhlaWdodFwiLCB0aGlzLl9taW5IZWlnaHQoKSApO1xuXHRcdH1cblx0fSxcblxuXHRfYmxvY2tGcmFtZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaWZyYW1lQmxvY2tzID0gdGhpcy5kb2N1bWVudC5maW5kKCBcImlmcmFtZVwiICkubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlmcmFtZSA9ICQoIHRoaXMgKTtcblxuXHRcdFx0cmV0dXJuICQoIFwiPGRpdj5cIiApXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0d2lkdGg6IGlmcmFtZS5vdXRlcldpZHRoKCksXG5cdFx0XHRcdFx0aGVpZ2h0OiBpZnJhbWUub3V0ZXJIZWlnaHQoKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kVG8oIGlmcmFtZS5wYXJlbnQoKSApXG5cdFx0XHRcdC5vZmZzZXQoIGlmcmFtZS5vZmZzZXQoKSApWzBdO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF91bmJsb2NrRnJhbWVzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuaWZyYW1lQmxvY2tzICkge1xuXHRcdFx0dGhpcy5pZnJhbWVCbG9ja3MucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5pZnJhbWVCbG9ja3M7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbGxvd0ludGVyYWN0aW9uOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KFwiLnVpLWRpYWxvZ1wiKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBSZW1vdmUgaGFjayB3aGVuIGRhdGVwaWNrZXIgaW1wbGVtZW50c1xuXHRcdC8vIHRoZSAudWktZnJvbnQgbG9naWMgKCM4OTg5KVxuXHRcdHJldHVybiAhISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoXCIudWktZGF0ZXBpY2tlclwiKS5sZW5ndGg7XG5cdH0sXG5cblx0X2NyZWF0ZU92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXMub3B0aW9ucy5tb2RhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHR3aWRnZXRGdWxsTmFtZSA9IHRoaXMud2lkZ2V0RnVsbE5hbWU7XG5cdFx0aWYgKCAhJC51aS5kaWFsb2cub3ZlcmxheUluc3RhbmNlcyApIHtcblx0XHRcdC8vIFByZXZlbnQgdXNlIG9mIGFuY2hvcnMgYW5kIGlucHV0cy5cblx0XHRcdC8vIFdlIHVzZSBhIGRlbGF5IGluIGNhc2UgdGhlIG92ZXJsYXkgaXMgY3JlYXRlZCBmcm9tIGFuXG5cdFx0XHQvLyBldmVudCB0aGF0IHdlJ3JlIGdvaW5nIHRvIGJlIGNhbmNlbGxpbmcuICgjMjgwNClcblx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBIYW5kbGUgLmRpYWxvZygpLmRpYWxvZyhcImNsb3NlXCIpICgjNDA2NSlcblx0XHRcdFx0aWYgKCAkLnVpLmRpYWxvZy5vdmVybGF5SW5zdGFuY2VzICkge1xuXHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQuYmluZCggXCJmb2N1c2luLmRpYWxvZ1wiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICF0aGF0Ll9hbGxvd0ludGVyYWN0aW9uKCBldmVudCApICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQkKFwiLnVpLWRpYWxvZzp2aXNpYmxlOmxhc3QgLnVpLWRpYWxvZy1jb250ZW50XCIpXG5cdFx0XHRcdFx0XHRcdFx0LmRhdGEoIHdpZGdldEZ1bGxOYW1lICkuX2ZvY3VzVGFiYmFibGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vdmVybGF5ID0gJChcIjxkaXY+XCIpXG5cdFx0XHQuYWRkQ2xhc3MoXCJ1aS13aWRnZXQtb3ZlcmxheSB1aS1mcm9udFwiKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpICk7XG5cdFx0dGhpcy5fb24oIHRoaXMub3ZlcmxheSwge1xuXHRcdFx0bW91c2Vkb3duOiBcIl9rZWVwRm9jdXNcIlxuXHRcdH0pO1xuXHRcdCQudWkuZGlhbG9nLm92ZXJsYXlJbnN0YW5jZXMrKztcblx0fSxcblxuXHRfZGVzdHJveU92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXMub3B0aW9ucy5tb2RhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdCQudWkuZGlhbG9nLm92ZXJsYXlJbnN0YW5jZXMtLTtcblxuXHRcdFx0aWYgKCAhJC51aS5kaWFsb2cub3ZlcmxheUluc3RhbmNlcyApIHtcblx0XHRcdFx0dGhpcy5kb2N1bWVudC51bmJpbmQoIFwiZm9jdXNpbi5kaWFsb2dcIiApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5vdmVybGF5LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5vdmVybGF5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLnVpLmRpYWxvZy5vdmVybGF5SW5zdGFuY2VzID0gMDtcblxuLy8gREVQUkVDQVRFRFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdC8vIHBvc2l0aW9uIG9wdGlvbiB3aXRoIGFycmF5IG5vdGF0aW9uXG5cdC8vIGp1c3Qgb3ZlcnJpZGUgd2l0aCBvbGQgaW1wbGVtZW50YXRpb25cblx0JC53aWRnZXQoIFwidWkuZGlhbG9nXCIsICQudWkuZGlhbG9nLCB7XG5cdFx0X3Bvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcblx0XHRcdFx0bXlBdCA9IFtdLFxuXHRcdFx0XHRvZmZzZXQgPSBbIDAsIDAgXSxcblx0XHRcdFx0aXNWaXNpYmxlO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHBvc2l0aW9uID09PSBcIm9iamVjdFwiICYmIFwiMFwiIGluIHBvc2l0aW9uICkgKSB7XG5cdFx0XHRcdFx0bXlBdCA9IHBvc2l0aW9uLnNwbGl0ID8gcG9zaXRpb24uc3BsaXQoXCIgXCIpIDogWyBwb3NpdGlvblswXSwgcG9zaXRpb25bMV0gXTtcblx0XHRcdFx0XHRpZiAoIG15QXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdFx0bXlBdFsxXSA9IG15QXRbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBvZmZzZXRQb3NpdGlvbiApIHtcblx0XHRcdFx0XHRcdGlmICggK215QXRbIGkgXSA9PT0gbXlBdFsgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRvZmZzZXRbIGkgXSA9IG15QXRbIGkgXTtcblx0XHRcdFx0XHRcdFx0bXlBdFsgaSBdID0gb2Zmc2V0UG9zaXRpb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRwb3NpdGlvbiA9IHtcblx0XHRcdFx0XHRcdG15OiBteUF0WzBdICsgKG9mZnNldFswXSA8IDAgPyBvZmZzZXRbMF0gOiBcIitcIiArIG9mZnNldFswXSkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdG15QXRbMV0gKyAob2Zmc2V0WzFdIDwgMCA/IG9mZnNldFsxXSA6IFwiK1wiICsgb2Zmc2V0WzFdKSxcblx0XHRcdFx0XHRcdGF0OiBteUF0LmpvaW4oXCIgXCIpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCAkLnVpLmRpYWxvZy5wcm90b3R5cGUub3B0aW9ucy5wb3NpdGlvbiwgcG9zaXRpb24gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gJC51aS5kaWFsb2cucHJvdG90eXBlLm9wdGlvbnMucG9zaXRpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5lZWQgdG8gc2hvdyB0aGUgZGlhbG9nIHRvIGdldCB0aGUgYWN0dWFsIG9mZnNldCBpbiB0aGUgcG9zaXRpb24gcGx1Z2luXG5cdFx0XHRpc1Zpc2libGUgPSB0aGlzLnVpRGlhbG9nLmlzKFwiOnZpc2libGVcIik7XG5cdFx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHRcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51aURpYWxvZy5wb3NpdGlvbiggcG9zaXRpb24gKTtcblx0XHRcdGlmICggIWlzVmlzaWJsZSApIHtcblx0XHRcdFx0dGhpcy51aURpYWxvZy5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxufSggalF1ZXJ5ICkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciBydmVydGljYWwgPSAvdXB8ZG93bnx2ZXJ0aWNhbC8sXG5cdHJwb3NpdGl2ZW1vdGlvbiA9IC91cHxsZWZ0fHZlcnRpY2FsfGhvcml6b250YWwvO1xuXG4kLmVmZmVjdHMuZWZmZWN0LmJsaW5kID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcInVwXCIsXG5cdFx0dmVydGljYWwgPSBydmVydGljYWwudGVzdCggZGlyZWN0aW9uICksXG5cdFx0cmVmID0gdmVydGljYWwgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxuXHRcdHJlZjIgPSB2ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRtb3Rpb24gPSBycG9zaXRpdmVtb3Rpb24udGVzdCggZGlyZWN0aW9uICksXG5cdFx0YW5pbWF0aW9uID0ge30sXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdHdyYXBwZXIsIGRpc3RhbmNlLCBtYXJnaW47XG5cblx0Ly8gaWYgYWxyZWFkeSB3cmFwcGVkLCB0aGUgd3JhcHBlcidzIHByb3BlcnRpZXMgYXJlIG15IHByb3BlcnR5LiAjNjI0NVxuXHRpZiAoIGVsLnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuXHRcdCQuZWZmZWN0cy5zYXZlKCBlbC5wYXJlbnQoKSwgcHJvcHMgKTtcblx0fSBlbHNlIHtcblx0XHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdH1cblx0ZWwuc2hvdygpO1xuXHR3cmFwcGVyID0gJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICkuY3NzKHtcblx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIlxuXHR9KTtcblxuXHRkaXN0YW5jZSA9IHdyYXBwZXJbIHJlZiBdKCk7XG5cdG1hcmdpbiA9IHBhcnNlRmxvYXQoIHdyYXBwZXIuY3NzKCByZWYyICkgKSB8fCAwO1xuXG5cdGFuaW1hdGlvblsgcmVmIF0gPSBzaG93ID8gZGlzdGFuY2UgOiAwO1xuXHRpZiAoICFtb3Rpb24gKSB7XG5cdFx0ZWxcblx0XHRcdC5jc3MoIHZlcnRpY2FsID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgMCApXG5cdFx0XHQuY3NzKCB2ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIiwgXCJhdXRvXCIgKVxuXHRcdFx0LmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSk7XG5cblx0XHRhbmltYXRpb25bIHJlZjIgXSA9IHNob3cgPyBtYXJnaW4gOiBkaXN0YW5jZSArIG1hcmdpbjtcblx0fVxuXG5cdC8vIHN0YXJ0IGF0IDAgaWYgd2UgYXJlIHNob3dpbmdcblx0aWYgKCBzaG93ICkge1xuXHRcdHdyYXBwZXIuY3NzKCByZWYsIDAgKTtcblx0XHRpZiAoICEgbW90aW9uICkge1xuXHRcdFx0d3JhcHBlci5jc3MoIHJlZjIsIG1hcmdpbiArIGRpc3RhbmNlICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQW5pbWF0ZVxuXHR3cmFwcGVyLmFuaW1hdGUoIGFuaW1hdGlvbiwge1xuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH1cblx0fSk7XG5cbn07XG5cbn0pKGpRdWVyeSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmJvdW5jZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cblx0XHQvLyBkZWZhdWx0czpcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJlZmZlY3RcIiApLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJ1cFwiLFxuXHRcdGRpc3RhbmNlID0gby5kaXN0YW5jZSxcblx0XHR0aW1lcyA9IG8udGltZXMgfHwgNSxcblxuXHRcdC8vIG51bWJlciBvZiBpbnRlcm5hbCBhbmltYXRpb25zXG5cdFx0YW5pbXMgPSB0aW1lcyAqIDIgKyAoIHNob3cgfHwgaGlkZSA/IDEgOiAwICksXG5cdFx0c3BlZWQgPSBvLmR1cmF0aW9uIC8gYW5pbXMsXG5cdFx0ZWFzaW5nID0gby5lYXNpbmcsXG5cblx0XHQvLyB1dGlsaXR5OlxuXHRcdHJlZiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiApID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdG1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApLFxuXHRcdGksXG5cdFx0dXBBbmltLFxuXHRcdGRvd25BbmltLFxuXG5cdFx0Ly8gd2Ugd2lsbCBuZWVkIHRvIHJlLWFzc2VtYmxlIHRoZSBxdWV1ZSB0byBzdGFjayBvdXIgYW5pbWF0aW9ucyBpbiBwbGFjZVxuXHRcdHF1ZXVlID0gZWwucXVldWUoKSxcblx0XHRxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuXHQvLyBBdm9pZCB0b3VjaGluZyBvcGFjaXR5IHRvIHByZXZlbnQgY2xlYXJUeXBlIGFuZCBQTkcgaXNzdWVzIGluIElFXG5cdGlmICggc2hvdyB8fCBoaWRlICkge1xuXHRcdHByb3BzLnB1c2goIFwib3BhY2l0eVwiICk7XG5cdH1cblxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICk7IC8vIENyZWF0ZSBXcmFwcGVyXG5cblx0Ly8gZGVmYXVsdCBkaXN0YW5jZSBmb3IgdGhlIEJJR0dFU1QgYm91bmNlIGlzIHRoZSBvdXRlciBEaXN0YW5jZSAvIDNcblx0aWYgKCAhZGlzdGFuY2UgKSB7XG5cdFx0ZGlzdGFuY2UgPSBlbFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSgpIC8gMztcblx0fVxuXG5cdGlmICggc2hvdyApIHtcblx0XHRkb3duQW5pbSA9IHsgb3BhY2l0eTogMSB9O1xuXHRcdGRvd25BbmltWyByZWYgXSA9IDA7XG5cblx0XHQvLyBpZiB3ZSBhcmUgc2hvd2luZywgZm9yY2Ugb3BhY2l0eSAwIGFuZCBzZXQgdGhlIGluaXRpYWwgcG9zaXRpb25cblx0XHQvLyB0aGVuIGRvIHRoZSBcImZpcnN0XCIgYW5pbWF0aW9uXG5cdFx0ZWwuY3NzKCBcIm9wYWNpdHlcIiwgMCApXG5cdFx0XHQuY3NzKCByZWYsIG1vdGlvbiA/IC1kaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAqIDIgKVxuXHRcdFx0LmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cdH1cblxuXHQvLyBzdGFydCBhdCB0aGUgc21hbGxlc3QgZGlzdGFuY2UgaWYgd2UgYXJlIGhpZGluZ1xuXHRpZiAoIGhpZGUgKSB7XG5cdFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSAvIE1hdGgucG93KCAyLCB0aW1lcyAtIDEgKTtcblx0fVxuXG5cdGRvd25BbmltID0ge307XG5cdGRvd25BbmltWyByZWYgXSA9IDA7XG5cdC8vIEJvdW5jZXMgdXAvZG93bi9sZWZ0L3JpZ2h0IHRoZW4gYmFjayB0byAwIC0tIHRpbWVzICogMiBhbmltYXRpb25zIGhhcHBlbiBoZXJlXG5cdGZvciAoIGkgPSAwOyBpIDwgdGltZXM7IGkrKyApIHtcblx0XHR1cEFuaW0gPSB7fTtcblx0XHR1cEFuaW1bIHJlZiBdID0gKCBtb3Rpb24gPyBcIi09XCIgOiBcIis9XCIgKSArIGRpc3RhbmNlO1xuXG5cdFx0ZWwuYW5pbWF0ZSggdXBBbmltLCBzcGVlZCwgZWFzaW5nIClcblx0XHRcdC5hbmltYXRlKCBkb3duQW5pbSwgc3BlZWQsIGVhc2luZyApO1xuXG5cdFx0ZGlzdGFuY2UgPSBoaWRlID8gZGlzdGFuY2UgKiAyIDogZGlzdGFuY2UgLyAyO1xuXHR9XG5cblx0Ly8gTGFzdCBCb3VuY2Ugd2hlbiBIaWRpbmdcblx0aWYgKCBoaWRlICkge1xuXHRcdHVwQW5pbSA9IHsgb3BhY2l0eTogMCB9O1xuXHRcdHVwQW5pbVsgcmVmIF0gPSAoIG1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cblx0XHRlbC5hbmltYXRlKCB1cEFuaW0sIHNwZWVkLCBlYXNpbmcgKTtcblx0fVxuXG5cdGVsLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaGlkZSApIHtcblx0XHRcdGVsLmhpZGUoKTtcblx0XHR9XG5cdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdGRvbmUoKTtcblx0fSk7XG5cblx0Ly8gaW5qZWN0IGFsbCB0aGUgYW5pbWF0aW9ucyB3ZSBqdXN0IHF1ZXVlZCB0byBiZSBmaXJzdCBpbiBsaW5lIChhZnRlciBcImlucHJvZ3Jlc3NcIilcblx0aWYgKCBxdWV1ZWxlbiA+IDEpIHtcblx0XHRxdWV1ZS5zcGxpY2UuYXBwbHkoIHF1ZXVlLFxuXHRcdFx0WyAxLCAwIF0uY29uY2F0KCBxdWV1ZS5zcGxpY2UoIHF1ZXVlbGVuLCBhbmltcyArIDEgKSApICk7XG5cdH1cblx0ZWwuZGVxdWV1ZSgpO1xuXG59O1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5jbGlwID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJ2ZXJ0aWNhbFwiLFxuXHRcdHZlcnQgPSBkaXJlY3Rpb24gPT09IFwidmVydGljYWxcIixcblx0XHRzaXplID0gdmVydCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG5cdFx0cG9zaXRpb24gPSB2ZXJ0ID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdGFuaW1hdGlvbiA9IHt9LFxuXHRcdHdyYXBwZXIsIGFuaW1hdGUsIGRpc3RhbmNlO1xuXG5cdC8vIFNhdmUgJiBTaG93XG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXG5cdC8vIENyZWF0ZSBXcmFwcGVyXG5cdHdyYXBwZXIgPSAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuXHRcdG92ZXJmbG93OiBcImhpZGRlblwiXG5cdH0pO1xuXHRhbmltYXRlID0gKCBlbFswXS50YWdOYW1lID09PSBcIklNR1wiICkgPyB3cmFwcGVyIDogZWw7XG5cdGRpc3RhbmNlID0gYW5pbWF0ZVsgc2l6ZSBdKCk7XG5cblx0Ly8gU2hpZnRcblx0aWYgKCBzaG93ICkge1xuXHRcdGFuaW1hdGUuY3NzKCBzaXplLCAwICk7XG5cdFx0YW5pbWF0ZS5jc3MoIHBvc2l0aW9uLCBkaXN0YW5jZSAvIDIgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBBbmltYXRpb24gT2JqZWN0OlxuXHRhbmltYXRpb25bIHNpemUgXSA9IHNob3cgPyBkaXN0YW5jZSA6IDA7XG5cdGFuaW1hdGlvblsgcG9zaXRpb24gXSA9IHNob3cgPyAwIDogZGlzdGFuY2UgLyAyO1xuXG5cdC8vIEFuaW1hdGVcblx0YW5pbWF0ZS5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFzaG93ICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xuXG59O1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5kcm9wID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwib3BhY2l0eVwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJsZWZ0XCIsXG5cdFx0cmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0bW90aW9uID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiICkgPyBcInBvc1wiIDogXCJuZWdcIixcblx0XHRhbmltYXRpb24gPSB7XG5cdFx0XHRvcGFjaXR5OiBzaG93ID8gMSA6IDBcblx0XHR9LFxuXHRcdGRpc3RhbmNlO1xuXG5cdC8vIEFkanVzdFxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICk7XG5cblx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IGVsWyByZWYgPT09IFwidG9wXCIgPyBcIm91dGVySGVpZ2h0XCI6IFwib3V0ZXJXaWR0aFwiIF0oIHRydWUgKSAvIDI7XG5cblx0aWYgKCBzaG93ICkge1xuXHRcdGVsXG5cdFx0XHQuY3NzKCBcIm9wYWNpdHlcIiwgMCApXG5cdFx0XHQuY3NzKCByZWYsIG1vdGlvbiA9PT0gXCJwb3NcIiA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlICk7XG5cdH1cblxuXHQvLyBBbmltYXRpb25cblx0YW5pbWF0aW9uWyByZWYgXSA9ICggc2hvdyA/XG5cdFx0KCBtb3Rpb24gPT09IFwicG9zXCIgPyBcIis9XCIgOiBcIi09XCIgKSA6XG5cdFx0KCBtb3Rpb24gPT09IFwicG9zXCIgPyBcIi09XCIgOiBcIis9XCIgKSApICtcblx0XHRkaXN0YW5jZTtcblxuXHQvLyBBbmltYXRlXG5cdGVsLmFuaW1hdGUoIGFuaW1hdGlvbiwge1xuXHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRkdXJhdGlvbjogby5kdXJhdGlvbixcblx0XHRlYXNpbmc6IG8uZWFzaW5nLFxuXHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH1cblx0fSk7XG59O1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5leHBsb2RlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0dmFyIHJvd3MgPSBvLnBpZWNlcyA/IE1hdGgucm91bmQoIE1hdGguc3FydCggby5waWVjZXMgKSApIDogMyxcblx0XHRjZWxscyA9IHJvd3MsXG5cdFx0ZWwgPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXG5cdFx0Ly8gc2hvdyBhbmQgdGhlbiB2aXNpYmlsaXR5OmhpZGRlbiB0aGUgZWxlbWVudCBiZWZvcmUgY2FsY3VsYXRpbmcgb2Zmc2V0XG5cdFx0b2Zmc2V0ID0gZWwuc2hvdygpLmNzcyggXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIgKS5vZmZzZXQoKSxcblxuXHRcdC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBwaWVjZVxuXHRcdHdpZHRoID0gTWF0aC5jZWlsKCBlbC5vdXRlcldpZHRoKCkgLyBjZWxscyApLFxuXHRcdGhlaWdodCA9IE1hdGguY2VpbCggZWwub3V0ZXJIZWlnaHQoKSAvIHJvd3MgKSxcblx0XHRwaWVjZXMgPSBbXSxcblxuXHRcdC8vIGxvb3Bcblx0XHRpLCBqLCBsZWZ0LCB0b3AsIG14LCBteTtcblxuXHQvLyBjaGlsZHJlbiBhbmltYXRlIGNvbXBsZXRlOlxuXHRmdW5jdGlvbiBjaGlsZENvbXBsZXRlKCkge1xuXHRcdHBpZWNlcy5wdXNoKCB0aGlzICk7XG5cdFx0aWYgKCBwaWVjZXMubGVuZ3RoID09PSByb3dzICogY2VsbHMgKSB7XG5cdFx0XHRhbmltQ29tcGxldGUoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBjbG9uZSB0aGUgZWxlbWVudCBmb3IgZWFjaCByb3cgYW5kIGNlbGwuXG5cdGZvciggaSA9IDA7IGkgPCByb3dzIDsgaSsrICkgeyAvLyA9PT0+XG5cdFx0dG9wID0gb2Zmc2V0LnRvcCArIGkgKiBoZWlnaHQ7XG5cdFx0bXkgPSBpIC0gKCByb3dzIC0gMSApIC8gMiA7XG5cblx0XHRmb3IoIGogPSAwOyBqIDwgY2VsbHMgOyBqKysgKSB7IC8vIHx8fFxuXHRcdFx0bGVmdCA9IG9mZnNldC5sZWZ0ICsgaiAqIHdpZHRoO1xuXHRcdFx0bXggPSBqIC0gKCBjZWxscyAtIDEgKSAvIDIgO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgbm93IGhpZGRlbiBtYWluIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFic29sdXRlIHBvc2l0aW9uZWRcblx0XHRcdC8vIHdpdGhpbiBhIHdyYXBwZXIgZGl2IG9mZiB0aGUgLWxlZnQgYW5kIC10b3AgZXF1YWwgdG8gc2l6ZSBvZiBvdXIgcGllY2VzXG5cdFx0XHRlbFxuXHRcdFx0XHQuY2xvbmUoKVxuXHRcdFx0XHQuYXBwZW5kVG8oIFwiYm9keVwiIClcblx0XHRcdFx0LndyYXAoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIsXG5cdFx0XHRcdFx0bGVmdDogLWogKiB3aWR0aCxcblx0XHRcdFx0XHR0b3A6IC1pICogaGVpZ2h0XG5cdFx0XHRcdH0pXG5cblx0XHRcdC8vIHNlbGVjdCB0aGUgd3JhcHBlciAtIG1ha2UgaXQgb3ZlcmZsb3c6IGhpZGRlbiBhbmQgYWJzb2x1dGUgcG9zaXRpb25lZCBiYXNlZCBvblxuXHRcdFx0Ly8gd2hlcmUgdGhlIG9yaWdpbmFsIHdhcyBsb2NhdGVkICtsZWZ0IGFuZCArdG9wIGVxdWFsIHRvIHRoZSBzaXplIG9mIHBpZWNlc1xuXHRcdFx0XHQucGFyZW50KClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtZXhwbG9kZVwiIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIixcblx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdFx0bGVmdDogbGVmdCArICggc2hvdyA/IG14ICogd2lkdGggOiAwICksXG5cdFx0XHRcdFx0dG9wOiB0b3AgKyAoIHNob3cgPyBteSAqIGhlaWdodCA6IDAgKSxcblx0XHRcdFx0XHRvcGFjaXR5OiBzaG93ID8gMCA6IDFcblx0XHRcdFx0fSkuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0bGVmdDogbGVmdCArICggc2hvdyA/IDAgOiBteCAqIHdpZHRoICksXG5cdFx0XHRcdFx0dG9wOiB0b3AgKyAoIHNob3cgPyAwIDogbXkgKiBoZWlnaHQgKSxcblx0XHRcdFx0XHRvcGFjaXR5OiBzaG93ID8gMSA6IDBcblx0XHRcdFx0fSwgby5kdXJhdGlvbiB8fCA1MDAsIG8uZWFzaW5nLCBjaGlsZENvbXBsZXRlICk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYW5pbUNvbXBsZXRlKCkge1xuXHRcdGVsLmNzcyh7XG5cdFx0XHR2aXNpYmlsaXR5OiBcInZpc2libGVcIlxuXHRcdH0pO1xuXHRcdCQoIHBpZWNlcyApLnJlbW92ZSgpO1xuXHRcdGlmICggIXNob3cgKSB7XG5cdFx0XHRlbC5oaWRlKCk7XG5cdFx0fVxuXHRcdGRvbmUoKTtcblx0fVxufTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuZmFkZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwidG9nZ2xlXCIgKTtcblxuXHRlbC5hbmltYXRlKHtcblx0XHRvcGFjaXR5OiBtb2RlXG5cdH0sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9KTtcbn07XG5cbn0pKCBqUXVlcnkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuZm9sZCA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRwcm9wcyA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImhlaWdodFwiLCBcIndpZHRoXCIgXSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJoaWRlXCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0aGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuXHRcdHNpemUgPSBvLnNpemUgfHwgMTUsXG5cdFx0cGVyY2VudCA9IC8oWzAtOV0rKSUvLmV4ZWMoIHNpemUgKSxcblx0XHRob3JpekZpcnN0ID0gISFvLmhvcml6Rmlyc3QsXG5cdFx0d2lkdGhGaXJzdCA9IHNob3cgIT09IGhvcml6Rmlyc3QsXG5cdFx0cmVmID0gd2lkdGhGaXJzdCA/IFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0gOiBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdGR1cmF0aW9uID0gby5kdXJhdGlvbiAvIDIsXG5cdFx0d3JhcHBlciwgZGlzdGFuY2UsXG5cdFx0YW5pbWF0aW9uMSA9IHt9LFxuXHRcdGFuaW1hdGlvbjIgPSB7fTtcblxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblxuXHQvLyBDcmVhdGUgV3JhcHBlclxuXHR3cmFwcGVyID0gJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICkuY3NzKHtcblx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIlxuXHR9KTtcblx0ZGlzdGFuY2UgPSB3aWR0aEZpcnN0ID9cblx0XHRbIHdyYXBwZXIud2lkdGgoKSwgd3JhcHBlci5oZWlnaHQoKSBdIDpcblx0XHRbIHdyYXBwZXIuaGVpZ2h0KCksIHdyYXBwZXIud2lkdGgoKSBdO1xuXG5cdGlmICggcGVyY2VudCApIHtcblx0XHRzaXplID0gcGFyc2VJbnQoIHBlcmNlbnRbIDEgXSwgMTAgKSAvIDEwMCAqIGRpc3RhbmNlWyBoaWRlID8gMCA6IDEgXTtcblx0fVxuXHRpZiAoIHNob3cgKSB7XG5cdFx0d3JhcHBlci5jc3MoIGhvcml6Rmlyc3QgPyB7XG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHR3aWR0aDogc2l6ZVxuXHRcdH0gOiB7XG5cdFx0XHRoZWlnaHQ6IHNpemUsXG5cdFx0XHR3aWR0aDogMFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQW5pbWF0aW9uXG5cdGFuaW1hdGlvbjFbIHJlZlsgMCBdIF0gPSBzaG93ID8gZGlzdGFuY2VbIDAgXSA6IHNpemU7XG5cdGFuaW1hdGlvbjJbIHJlZlsgMSBdIF0gPSBzaG93ID8gZGlzdGFuY2VbIDEgXSA6IDA7XG5cblx0Ly8gQW5pbWF0ZVxuXHR3cmFwcGVyXG5cdFx0LmFuaW1hdGUoIGFuaW1hdGlvbjEsIGR1cmF0aW9uLCBvLmVhc2luZyApXG5cdFx0LmFuaW1hdGUoIGFuaW1hdGlvbjIsIGR1cmF0aW9uLCBvLmVhc2luZywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGhpZGUgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH0pO1xuXG59O1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5oaWdobGlnaHQgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwiYmFja2dyb3VuZEltYWdlXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIFwib3BhY2l0eVwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbGVtLCBvLm1vZGUgfHwgXCJzaG93XCIgKSxcblx0XHRhbmltYXRpb24gPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGVsZW0uY3NzKCBcImJhY2tncm91bmRDb2xvclwiIClcblx0XHR9O1xuXG5cdGlmIChtb2RlID09PSBcImhpZGVcIikge1xuXHRcdGFuaW1hdGlvbi5vcGFjaXR5ID0gMDtcblx0fVxuXG5cdCQuZWZmZWN0cy5zYXZlKCBlbGVtLCBwcm9wcyApO1xuXG5cdGVsZW1cblx0XHQuc2hvdygpXG5cdFx0LmNzcyh7XG5cdFx0XHRiYWNrZ3JvdW5kSW1hZ2U6IFwibm9uZVwiLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvLmNvbG9yIHx8IFwiI2ZmZmY5OVwiXG5cdFx0fSlcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRkdXJhdGlvbjogby5kdXJhdGlvbixcblx0XHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsZW0sIHByb3BzICk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH1cblx0XHR9KTtcbn07XG5cbn0pKGpRdWVyeSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnB1bHNhdGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbGVtLCBvLm1vZGUgfHwgXCJzaG93XCIgKSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0aGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuXHRcdHNob3doaWRlID0gKCBzaG93IHx8IG1vZGUgPT09IFwiaGlkZVwiICksXG5cblx0XHQvLyBzaG93aW5nIG9yIGhpZGluZyBsZWF2ZXMgb2YgdGhlIFwibGFzdFwiIGFuaW1hdGlvblxuXHRcdGFuaW1zID0gKCAoIG8udGltZXMgfHwgNSApICogMiApICsgKCBzaG93aGlkZSA/IDEgOiAwICksXG5cdFx0ZHVyYXRpb24gPSBvLmR1cmF0aW9uIC8gYW5pbXMsXG5cdFx0YW5pbWF0ZVRvID0gMCxcblx0XHRxdWV1ZSA9IGVsZW0ucXVldWUoKSxcblx0XHRxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aCxcblx0XHRpO1xuXG5cdGlmICggc2hvdyB8fCAhZWxlbS5pcyhcIjp2aXNpYmxlXCIpKSB7XG5cdFx0ZWxlbS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpO1xuXHRcdGFuaW1hdGVUbyA9IDE7XG5cdH1cblxuXHQvLyBhbmltcyAtIDEgb3BhY2l0eSBcInRvZ2dsZXNcIlxuXHRmb3IgKCBpID0gMTsgaSA8IGFuaW1zOyBpKysgKSB7XG5cdFx0ZWxlbS5hbmltYXRlKHtcblx0XHRcdG9wYWNpdHk6IGFuaW1hdGVUb1xuXHRcdH0sIGR1cmF0aW9uLCBvLmVhc2luZyApO1xuXHRcdGFuaW1hdGVUbyA9IDEgLSBhbmltYXRlVG87XG5cdH1cblxuXHRlbGVtLmFuaW1hdGUoe1xuXHRcdG9wYWNpdHk6IGFuaW1hdGVUb1xuXHR9LCBkdXJhdGlvbiwgby5lYXNpbmcpO1xuXG5cdGVsZW0ucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBoaWRlICkge1xuXHRcdFx0ZWxlbS5oaWRlKCk7XG5cdFx0fVxuXHRcdGRvbmUoKTtcblx0fSk7XG5cblx0Ly8gV2UganVzdCBxdWV1ZWQgdXAgXCJhbmltc1wiIGFuaW1hdGlvbnMsIHdlIG5lZWQgdG8gcHV0IHRoZW0gbmV4dCBpbiB0aGUgcXVldWVcblx0aWYgKCBxdWV1ZWxlbiA+IDEgKSB7XG5cdFx0cXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcblx0XHRcdFsgMSwgMCBdLmNvbmNhdCggcXVldWUuc3BsaWNlKCBxdWV1ZWxlbiwgYW5pbXMgKyAxICkgKSApO1xuXHR9XG5cdGVsZW0uZGVxdWV1ZSgpO1xufTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QucHVmZiA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsZW0sIG8ubW9kZSB8fCBcImhpZGVcIiApLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRwZXJjZW50ID0gcGFyc2VJbnQoIG8ucGVyY2VudCwgMTAgKSB8fCAxNTAsXG5cdFx0ZmFjdG9yID0gcGVyY2VudCAvIDEwMCxcblx0XHRvcmlnaW5hbCA9IHtcblx0XHRcdGhlaWdodDogZWxlbS5oZWlnaHQoKSxcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRvdXRlckhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxuXHRcdFx0b3V0ZXJXaWR0aDogZWxlbS5vdXRlcldpZHRoKClcblx0XHR9O1xuXG5cdCQuZXh0ZW5kKCBvLCB7XG5cdFx0ZWZmZWN0OiBcInNjYWxlXCIsXG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGZhZGU6IHRydWUsXG5cdFx0bW9kZTogbW9kZSxcblx0XHRjb21wbGV0ZTogZG9uZSxcblx0XHRwZXJjZW50OiBoaWRlID8gcGVyY2VudCA6IDEwMCxcblx0XHRmcm9tOiBoaWRlID9cblx0XHRcdG9yaWdpbmFsIDpcblx0XHRcdHtcblx0XHRcdFx0aGVpZ2h0OiBvcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IsXG5cdFx0XHRcdHdpZHRoOiBvcmlnaW5hbC53aWR0aCAqIGZhY3Rvcixcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6IG9yaWdpbmFsLm91dGVySGVpZ2h0ICogZmFjdG9yLFxuXHRcdFx0XHRvdXRlcldpZHRoOiBvcmlnaW5hbC5vdXRlcldpZHRoICogZmFjdG9yXG5cdFx0XHR9XG5cdH0pO1xuXG5cdGVsZW0uZWZmZWN0KCBvICk7XG59O1xuXG4kLmVmZmVjdHMuZWZmZWN0LnNjYWxlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0Ly8gQ3JlYXRlIGVsZW1lbnRcblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIG8gKSxcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJlZmZlY3RcIiApLFxuXHRcdHBlcmNlbnQgPSBwYXJzZUludCggby5wZXJjZW50LCAxMCApIHx8XG5cdFx0XHQoIHBhcnNlSW50KCBvLnBlcmNlbnQsIDEwICkgPT09IDAgPyAwIDogKCBtb2RlID09PSBcImhpZGVcIiA/IDAgOiAxMDAgKSApLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwiYm90aFwiLFxuXHRcdG9yaWdpbiA9IG8ub3JpZ2luLFxuXHRcdG9yaWdpbmFsID0ge1xuXHRcdFx0aGVpZ2h0OiBlbC5oZWlnaHQoKSxcblx0XHRcdHdpZHRoOiBlbC53aWR0aCgpLFxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCksXG5cdFx0XHRvdXRlcldpZHRoOiBlbC5vdXRlcldpZHRoKClcblx0XHR9LFxuXHRcdGZhY3RvciA9IHtcblx0XHRcdHk6IGRpcmVjdGlvbiAhPT0gXCJob3Jpem9udGFsXCIgPyAocGVyY2VudCAvIDEwMCkgOiAxLFxuXHRcdFx0eDogZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIgPyAocGVyY2VudCAvIDEwMCkgOiAxXG5cdFx0fTtcblxuXHQvLyBXZSBhcmUgZ29pbmcgdG8gcGFzcyB0aGlzIGVmZmVjdCB0byB0aGUgc2l6ZSBlZmZlY3Q6XG5cdG9wdGlvbnMuZWZmZWN0ID0gXCJzaXplXCI7XG5cdG9wdGlvbnMucXVldWUgPSBmYWxzZTtcblx0b3B0aW9ucy5jb21wbGV0ZSA9IGRvbmU7XG5cblx0Ly8gU2V0IGRlZmF1bHQgb3JpZ2luIGFuZCByZXN0b3JlIGZvciBzaG93L2hpZGVcblx0aWYgKCBtb2RlICE9PSBcImVmZmVjdFwiICkge1xuXHRcdG9wdGlvbnMub3JpZ2luID0gb3JpZ2luIHx8IFtcIm1pZGRsZVwiLFwiY2VudGVyXCJdO1xuXHRcdG9wdGlvbnMucmVzdG9yZSA9IHRydWU7XG5cdH1cblxuXHRvcHRpb25zLmZyb20gPSBvLmZyb20gfHwgKCBtb2RlID09PSBcInNob3dcIiA/IHtcblx0XHRoZWlnaHQ6IDAsXG5cdFx0d2lkdGg6IDAsXG5cdFx0b3V0ZXJIZWlnaHQ6IDAsXG5cdFx0b3V0ZXJXaWR0aDogMFxuXHR9IDogb3JpZ2luYWwgKTtcblx0b3B0aW9ucy50byA9IHtcblx0XHRoZWlnaHQ6IG9yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci55LFxuXHRcdHdpZHRoOiBvcmlnaW5hbC53aWR0aCAqIGZhY3Rvci54LFxuXHRcdG91dGVySGVpZ2h0OiBvcmlnaW5hbC5vdXRlckhlaWdodCAqIGZhY3Rvci55LFxuXHRcdG91dGVyV2lkdGg6IG9yaWdpbmFsLm91dGVyV2lkdGggKiBmYWN0b3IueFxuXHR9O1xuXG5cdC8vIEZhZGUgb3B0aW9uIHRvIHN1cHBvcnQgcHVmZlxuXHRpZiAoIG9wdGlvbnMuZmFkZSApIHtcblx0XHRpZiAoIG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdFx0b3B0aW9ucy5mcm9tLm9wYWNpdHkgPSAwO1xuXHRcdFx0b3B0aW9ucy50by5vcGFjaXR5ID0gMTtcblx0XHR9XG5cdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdG9wdGlvbnMuZnJvbS5vcGFjaXR5ID0gMTtcblx0XHRcdG9wdGlvbnMudG8ub3BhY2l0eSA9IDA7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbC5lZmZlY3QoIG9wdGlvbnMgKTtcblxufTtcblxuJC5lZmZlY3RzLmVmZmVjdC5zaXplID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0Ly8gQ3JlYXRlIGVsZW1lbnRcblx0dmFyIG9yaWdpbmFsLCBiYXNlbGluZSwgZmFjdG9yLFxuXHRcdGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzMCA9IFsgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwib3ZlcmZsb3dcIiwgXCJvcGFjaXR5XCIgXSxcblxuXHRcdC8vIEFsd2F5cyByZXN0b3JlXG5cdFx0cHJvcHMxID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwib3ZlcmZsb3dcIiwgXCJvcGFjaXR5XCIgXSxcblxuXHRcdC8vIENvcHkgZm9yIGNoaWxkcmVuXG5cdFx0cHJvcHMyID0gWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwib3ZlcmZsb3dcIiBdLFxuXHRcdGNQcm9wcyA9IFsgXCJmb250U2l6ZVwiIF0sXG5cdFx0dlByb3BzID0gWyBcImJvcmRlclRvcFdpZHRoXCIsIFwiYm9yZGVyQm90dG9tV2lkdGhcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiIF0sXG5cdFx0aFByb3BzID0gWyBcImJvcmRlckxlZnRXaWR0aFwiLCBcImJvcmRlclJpZ2h0V2lkdGhcIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiIF0sXG5cblx0XHQvLyBTZXQgb3B0aW9uc1xuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImVmZmVjdFwiICksXG5cdFx0cmVzdG9yZSA9IG8ucmVzdG9yZSB8fCBtb2RlICE9PSBcImVmZmVjdFwiLFxuXHRcdHNjYWxlID0gby5zY2FsZSB8fCBcImJvdGhcIixcblx0XHRvcmlnaW4gPSBvLm9yaWdpbiB8fCBbIFwibWlkZGxlXCIsIFwiY2VudGVyXCIgXSxcblx0XHRwb3NpdGlvbiA9IGVsLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0cHJvcHMgPSByZXN0b3JlID8gcHJvcHMwIDogcHJvcHMxLFxuXHRcdHplcm8gPSB7XG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdG91dGVySGVpZ2h0OiAwLFxuXHRcdFx0b3V0ZXJXaWR0aDogMFxuXHRcdH07XG5cblx0aWYgKCBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRlbC5zaG93KCk7XG5cdH1cblx0b3JpZ2luYWwgPSB7XG5cdFx0aGVpZ2h0OiBlbC5oZWlnaHQoKSxcblx0XHR3aWR0aDogZWwud2lkdGgoKSxcblx0XHRvdXRlckhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSxcblx0XHRvdXRlcldpZHRoOiBlbC5vdXRlcldpZHRoKClcblx0fTtcblxuXHRpZiAoIG8ubW9kZSA9PT0gXCJ0b2dnbGVcIiAmJiBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRlbC5mcm9tID0gby50byB8fCB6ZXJvO1xuXHRcdGVsLnRvID0gby5mcm9tIHx8IG9yaWdpbmFsO1xuXHR9IGVsc2Uge1xuXHRcdGVsLmZyb20gPSBvLmZyb20gfHwgKCBtb2RlID09PSBcInNob3dcIiA/IHplcm8gOiBvcmlnaW5hbCApO1xuXHRcdGVsLnRvID0gby50byB8fCAoIG1vZGUgPT09IFwiaGlkZVwiID8gemVybyA6IG9yaWdpbmFsICk7XG5cdH1cblxuXHQvLyBTZXQgc2NhbGluZyBmYWN0b3Jcblx0ZmFjdG9yID0ge1xuXHRcdGZyb206IHtcblx0XHRcdHk6IGVsLmZyb20uaGVpZ2h0IC8gb3JpZ2luYWwuaGVpZ2h0LFxuXHRcdFx0eDogZWwuZnJvbS53aWR0aCAvIG9yaWdpbmFsLndpZHRoXG5cdFx0fSxcblx0XHR0bzoge1xuXHRcdFx0eTogZWwudG8uaGVpZ2h0IC8gb3JpZ2luYWwuaGVpZ2h0LFxuXHRcdFx0eDogZWwudG8ud2lkdGggLyBvcmlnaW5hbC53aWR0aFxuXHRcdH1cblx0fTtcblxuXHQvLyBTY2FsZSB0aGUgY3NzIGJveFxuXHRpZiAoIHNjYWxlID09PSBcImJveFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHtcblxuXHRcdC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcblx0XHRpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoIHZQcm9wcyApO1xuXHRcdFx0ZWwuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgdlByb3BzLCBmYWN0b3IuZnJvbS55LCBlbC5mcm9tICk7XG5cdFx0XHRlbC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgdlByb3BzLCBmYWN0b3IudG8ueSwgZWwudG8gKTtcblx0XHR9XG5cblx0XHQvLyBIb3Jpem9udGFsIHByb3BzIHNjYWxpbmdcblx0XHRpZiAoIGZhY3Rvci5mcm9tLnggIT09IGZhY3Rvci50by54ICkge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoIGhQcm9wcyApO1xuXHRcdFx0ZWwuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBlbC5mcm9tICk7XG5cdFx0XHRlbC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgaFByb3BzLCBmYWN0b3IudG8ueCwgZWwudG8gKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTY2FsZSB0aGUgY29udGVudFxuXHRpZiAoIHNjYWxlID09PSBcImNvbnRlbnRcIiB8fCBzY2FsZSA9PT0gXCJib3RoXCIgKSB7XG5cblx0XHQvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXG5cdFx0aWYgKCBmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSApIHtcblx0XHRcdHByb3BzID0gcHJvcHMuY29uY2F0KCBjUHJvcHMgKS5jb25jYXQoIHByb3BzMiApO1xuXHRcdFx0ZWwuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgY1Byb3BzLCBmYWN0b3IuZnJvbS55LCBlbC5mcm9tICk7XG5cdFx0XHRlbC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbCwgY1Byb3BzLCBmYWN0b3IudG8ueSwgZWwudG8gKTtcblx0XHR9XG5cdH1cblxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICk7XG5cdGVsLmNzcyggXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiICkuY3NzKCBlbC5mcm9tICk7XG5cblx0Ly8gQWRqdXN0XG5cdGlmIChvcmlnaW4pIHsgLy8gQ2FsY3VsYXRlIGJhc2VsaW5lIHNoaWZ0c1xuXHRcdGJhc2VsaW5lID0gJC5lZmZlY3RzLmdldEJhc2VsaW5lKCBvcmlnaW4sIG9yaWdpbmFsICk7XG5cdFx0ZWwuZnJvbS50b3AgPSAoIG9yaWdpbmFsLm91dGVySGVpZ2h0IC0gZWwub3V0ZXJIZWlnaHQoKSApICogYmFzZWxpbmUueTtcblx0XHRlbC5mcm9tLmxlZnQgPSAoIG9yaWdpbmFsLm91dGVyV2lkdGggLSBlbC5vdXRlcldpZHRoKCkgKSAqIGJhc2VsaW5lLng7XG5cdFx0ZWwudG8udG9wID0gKCBvcmlnaW5hbC5vdXRlckhlaWdodCAtIGVsLnRvLm91dGVySGVpZ2h0ICkgKiBiYXNlbGluZS55O1xuXHRcdGVsLnRvLmxlZnQgPSAoIG9yaWdpbmFsLm91dGVyV2lkdGggLSBlbC50by5vdXRlcldpZHRoICkgKiBiYXNlbGluZS54O1xuXHR9XG5cdGVsLmNzcyggZWwuZnJvbSApOyAvLyBzZXQgdG9wICYgbGVmdFxuXG5cdC8vIEFuaW1hdGVcblx0aWYgKCBzY2FsZSA9PT0gXCJjb250ZW50XCIgfHwgc2NhbGUgPT09IFwiYm90aFwiICkgeyAvLyBTY2FsZSB0aGUgY2hpbGRyZW5cblxuXHRcdC8vIEFkZCBtYXJnaW5zL2ZvbnQtc2l6ZVxuXHRcdHZQcm9wcyA9IHZQcm9wcy5jb25jYXQoWyBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiIF0pLmNvbmNhdChjUHJvcHMpO1xuXHRcdGhQcm9wcyA9IGhQcm9wcy5jb25jYXQoWyBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiIF0pO1xuXHRcdHByb3BzMiA9IHByb3BzMC5jb25jYXQodlByb3BzKS5jb25jYXQoaFByb3BzKTtcblxuXHRcdGVsLmZpbmQoIFwiKlt3aWR0aF1cIiApLmVhY2goIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgY2hpbGQgPSAkKCB0aGlzICksXG5cdFx0XHRcdGNfb3JpZ2luYWwgPSB7XG5cdFx0XHRcdFx0aGVpZ2h0OiBjaGlsZC5oZWlnaHQoKSxcblx0XHRcdFx0XHR3aWR0aDogY2hpbGQud2lkdGgoKSxcblx0XHRcdFx0XHRvdXRlckhlaWdodDogY2hpbGQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHRvdXRlcldpZHRoOiBjaGlsZC5vdXRlcldpZHRoKClcblx0XHRcdFx0fTtcblx0XHRcdGlmIChyZXN0b3JlKSB7XG5cdFx0XHRcdCQuZWZmZWN0cy5zYXZlKGNoaWxkLCBwcm9wczIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGlsZC5mcm9tID0ge1xuXHRcdFx0XHRoZWlnaHQ6IGNfb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcblx0XHRcdFx0d2lkdGg6IGNfb3JpZ2luYWwud2lkdGggKiBmYWN0b3IuZnJvbS54LFxuXHRcdFx0XHRvdXRlckhlaWdodDogY19vcmlnaW5hbC5vdXRlckhlaWdodCAqIGZhY3Rvci5mcm9tLnksXG5cdFx0XHRcdG91dGVyV2lkdGg6IGNfb3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci5mcm9tLnhcblx0XHRcdH07XG5cdFx0XHRjaGlsZC50byA9IHtcblx0XHRcdFx0aGVpZ2h0OiBjX29yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci50by55LFxuXHRcdFx0XHR3aWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci50by54LFxuXHRcdFx0XHRvdXRlckhlaWdodDogY19vcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcblx0XHRcdFx0b3V0ZXJXaWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci50by54XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXG5cdFx0XHRpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuXHRcdFx0XHRjaGlsZC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGNoaWxkLmZyb20gKTtcblx0XHRcdFx0Y2hpbGQudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggY2hpbGQsIHZQcm9wcywgZmFjdG9yLnRvLnksIGNoaWxkLnRvICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xuXHRcdFx0aWYgKCBmYWN0b3IuZnJvbS54ICE9PSBmYWN0b3IudG8ueCApIHtcblx0XHRcdFx0Y2hpbGQuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBjaGlsZC5mcm9tICk7XG5cdFx0XHRcdGNoaWxkLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCBoUHJvcHMsIGZhY3Rvci50by54LCBjaGlsZC50byApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbmltYXRlIGNoaWxkcmVuXG5cdFx0XHRjaGlsZC5jc3MoIGNoaWxkLmZyb20gKTtcblx0XHRcdGNoaWxkLmFuaW1hdGUoIGNoaWxkLnRvLCBvLmR1cmF0aW9uLCBvLmVhc2luZywgZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSBjaGlsZHJlblxuXHRcdFx0XHRpZiAoIHJlc3RvcmUgKSB7XG5cdFx0XHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGNoaWxkLCBwcm9wczIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBBbmltYXRlXG5cdGVsLmFuaW1hdGUoIGVsLnRvLCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBlbC50by5vcGFjaXR5ID09PSAwICkge1xuXHRcdFx0XHRlbC5jc3MoIFwib3BhY2l0eVwiLCBlbC5mcm9tLm9wYWNpdHkgKTtcblx0XHRcdH1cblx0XHRcdGlmKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0aWYgKCAhcmVzdG9yZSApIHtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBvdXIgbmV3IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzY2FsaW5nXG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdFx0ZWwuY3NzKHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG5cdFx0XHRcdFx0XHR0b3A6IGVsLnRvLnRvcCxcblx0XHRcdFx0XHRcdGxlZnQ6IGVsLnRvLmxlZnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmVhY2goWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaWR4LCBwb3MgKSB7XG5cdFx0XHRcdFx0XHRlbC5jc3MoIHBvcywgZnVuY3Rpb24oIF8sIHN0ciApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbCA9IHBhcnNlSW50KCBzdHIsIDEwICksXG5cdFx0XHRcdFx0XHRcdFx0dG9SZWYgPSBpZHggPyBlbC50by5sZWZ0IDogZWwudG8udG9wO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIG9yaWdpbmFsIHdhcyBcImF1dG9cIiwgcmVjYWxjdWxhdGUgdGhlIG5ldyB2YWx1ZSBmcm9tIHdyYXBwZXJcblx0XHRcdFx0XHRcdFx0aWYgKCBzdHIgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0b1JlZiArIFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWwgKyB0b1JlZiArIFwicHhcIjtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH1cblx0fSk7XG5cbn07XG5cbn0pKGpRdWVyeSk7XG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnNoYWtlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImVmZmVjdFwiICksXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJsZWZ0XCIsXG5cdFx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IDIwLFxuXHRcdHRpbWVzID0gby50aW1lcyB8fCAzLFxuXHRcdGFuaW1zID0gdGltZXMgKiAyICsgMSxcblx0XHRzcGVlZCA9IE1hdGgucm91bmQoby5kdXJhdGlvbi9hbmltcyksXG5cdFx0cmVmID0gKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIpID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdHBvc2l0aXZlTW90aW9uID0gKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpLFxuXHRcdGFuaW1hdGlvbiA9IHt9LFxuXHRcdGFuaW1hdGlvbjEgPSB7fSxcblx0XHRhbmltYXRpb24yID0ge30sXG5cdFx0aSxcblxuXHRcdC8vIHdlIHdpbGwgbmVlZCB0byByZS1hc3NlbWJsZSB0aGUgcXVldWUgdG8gc3RhY2sgb3VyIGFuaW1hdGlvbnMgaW4gcGxhY2Vcblx0XHRxdWV1ZSA9IGVsLnF1ZXVlKCksXG5cdFx0cXVldWVsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApO1xuXG5cdC8vIEFuaW1hdGlvblxuXHRhbmltYXRpb25bIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cdGFuaW1hdGlvbjFbIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiKz1cIiA6IFwiLT1cIiApICsgZGlzdGFuY2UgKiAyO1xuXHRhbmltYXRpb24yWyByZWYgXSA9ICggcG9zaXRpdmVNb3Rpb24gPyBcIi09XCIgOiBcIis9XCIgKSArIGRpc3RhbmNlICogMjtcblxuXHQvLyBBbmltYXRlXG5cdGVsLmFuaW1hdGUoIGFuaW1hdGlvbiwgc3BlZWQsIG8uZWFzaW5nICk7XG5cblx0Ly8gU2hha2VzXG5cdGZvciAoIGkgPSAxOyBpIDwgdGltZXM7IGkrKyApIHtcblx0XHRlbC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcgKS5hbmltYXRlKCBhbmltYXRpb24yLCBzcGVlZCwgby5lYXNpbmcgKTtcblx0fVxuXHRlbFxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcgKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24sIHNwZWVkIC8gMiwgby5lYXNpbmcgKVxuXHRcdC5xdWV1ZShmdW5jdGlvbigpIHtcblx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH0pO1xuXG5cdC8vIGluamVjdCBhbGwgdGhlIGFuaW1hdGlvbnMgd2UganVzdCBxdWV1ZWQgdG8gYmUgZmlyc3QgaW4gbGluZSAoYWZ0ZXIgXCJpbnByb2dyZXNzXCIpXG5cdGlmICggcXVldWVsZW4gPiAxKSB7XG5cdFx0cXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcblx0XHRcdFsgMSwgMCBdLmNvbmNhdCggcXVldWUuc3BsaWNlKCBxdWV1ZWxlbiwgYW5pbXMgKyAxICkgKSApO1xuXHR9XG5cdGVsLmRlcXVldWUoKTtcblxufTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3Quc2xpZGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwic2hvd1wiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwibGVmdFwiLFxuXHRcdHJlZiA9IChkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiKSA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRwb3NpdGl2ZU1vdGlvbiA9IChkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiKSxcblx0XHRkaXN0YW5jZSxcblx0XHRhbmltYXRpb24gPSB7fTtcblxuXHQvLyBBZGp1c3Rcblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdGRpc3RhbmNlID0gby5kaXN0YW5jZSB8fCBlbFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApO1xuXG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApLmNzcyh7XG5cdFx0b3ZlcmZsb3c6IFwiaGlkZGVuXCJcblx0fSk7XG5cblx0aWYgKCBzaG93ICkge1xuXHRcdGVsLmNzcyggcmVmLCBwb3NpdGl2ZU1vdGlvbiA/IChpc05hTihkaXN0YW5jZSkgPyBcIi1cIiArIGRpc3RhbmNlIDogLWRpc3RhbmNlKSA6IGRpc3RhbmNlICk7XG5cdH1cblxuXHQvLyBBbmltYXRpb25cblx0YW5pbWF0aW9uWyByZWYgXSA9ICggc2hvdyA/XG5cdFx0KCBwb3NpdGl2ZU1vdGlvbiA/IFwiKz1cIiA6IFwiLT1cIikgOlxuXHRcdCggcG9zaXRpdmVNb3Rpb24gPyBcIi09XCIgOiBcIis9XCIpKSArXG5cdFx0ZGlzdGFuY2U7XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlciggZWwgKTtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0pO1xufTtcblxufSkoalF1ZXJ5KTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QudHJhbnNmZXIgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0dGFyZ2V0ID0gJCggby50byApLFxuXHRcdHRhcmdldEZpeGVkID0gdGFyZ2V0LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIixcblx0XHRib2R5ID0gJChcImJvZHlcIiksXG5cdFx0Zml4VG9wID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbFRvcCgpIDogMCxcblx0XHRmaXhMZWZ0ID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbExlZnQoKSA6IDAsXG5cdFx0ZW5kUG9zaXRpb24gPSB0YXJnZXQub2Zmc2V0KCksXG5cdFx0YW5pbWF0aW9uID0ge1xuXHRcdFx0dG9wOiBlbmRQb3NpdGlvbi50b3AgLSBmaXhUb3AgLFxuXHRcdFx0bGVmdDogZW5kUG9zaXRpb24ubGVmdCAtIGZpeExlZnQgLFxuXHRcdFx0aGVpZ2h0OiB0YXJnZXQuaW5uZXJIZWlnaHQoKSxcblx0XHRcdHdpZHRoOiB0YXJnZXQuaW5uZXJXaWR0aCgpXG5cdFx0fSxcblx0XHRzdGFydFBvc2l0aW9uID0gZWxlbS5vZmZzZXQoKSxcblx0XHR0cmFuc2ZlciA9ICQoIFwiPGRpdiBjbGFzcz0ndWktZWZmZWN0cy10cmFuc2Zlcic+PC9kaXY+XCIgKVxuXHRcdFx0LmFwcGVuZFRvKCBkb2N1bWVudC5ib2R5IClcblx0XHRcdC5hZGRDbGFzcyggby5jbGFzc05hbWUgKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdHRvcDogc3RhcnRQb3NpdGlvbi50b3AgLSBmaXhUb3AgLFxuXHRcdFx0XHRsZWZ0OiBzdGFydFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0ICxcblx0XHRcdFx0aGVpZ2h0OiBlbGVtLmlubmVySGVpZ2h0KCksXG5cdFx0XHRcdHdpZHRoOiBlbGVtLmlubmVyV2lkdGgoKSxcblx0XHRcdFx0cG9zaXRpb246IHRhcmdldEZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiXG5cdFx0XHR9KVxuXHRcdFx0LmFuaW1hdGUoIGFuaW1hdGlvbiwgby5kdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cmFuc2Zlci5yZW1vdmUoKTtcblx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0fSk7XG59O1xuXG59KShqUXVlcnkpO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoIFwidWkubWVudVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC4zXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjx1bD5cIixcblx0ZGVsYXk6IDMwMCxcblx0b3B0aW9uczoge1xuXHRcdGljb25zOiB7XG5cdFx0XHRzdWJtZW51OiBcInVpLWljb24tY2FyYXQtMS1lXCJcblx0XHR9LFxuXHRcdG1lbnVzOiBcInVsXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRhdDogXCJyaWdodCB0b3BcIlxuXHRcdH0sXG5cdFx0cm9sZTogXCJtZW51XCIsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRibHVyOiBudWxsLFxuXHRcdGZvY3VzOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHQvLyBmbGFnIHVzZWQgdG8gcHJldmVudCBmaXJpbmcgb2YgdGhlIGNsaWNrIGhhbmRsZXJcblx0XHQvLyBhcyB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aHJvdWdoIG5lc3RlZCBtZW51c1xuXHRcdHRoaXMubW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktbWVudS1pY29uc1wiLCAhIXRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1pY29uXCIgKS5sZW5ndGggKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0pXG5cdFx0XHQvLyBuZWVkIHRvIGNhdGNoIGFsbCBjbGlja3Mgb24gZGlzYWJsZWQgbWVudVxuXHRcdFx0Ly8gbm90IHBvc3NpYmxlIHRocm91Z2ggX29uXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgJC5wcm94eShmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMgKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbih7XG5cdFx0XHQvLyBQcmV2ZW50IGZvY3VzIGZyb20gc3RpY2tpbmcgdG8gbGlua3MgaW5zaWRlIG1lbnUgYWZ0ZXIgY2xpY2tpbmdcblx0XHRcdC8vIHRoZW0gKGZvY3VzIHNob3VsZCBhbHdheXMgc3RheSBvbiBVTCBkdXJpbmcgbmF2aWdhdGlvbikuXG5cdFx0XHRcIm1vdXNlZG93biAudWktbWVudS1pdGVtID4gYVwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJjbGljayAudWktc3RhdGUtZGlzYWJsZWQgPiBhXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1tZW51LWl0ZW06aGFzKGEpXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggIXRoaXMubW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5tb3VzZUhhbmRsZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0dGhpcy5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0Ly8gT3BlbiBzdWJtZW51IG9uIGNsaWNrXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQuaGFzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmV4cGFuZCggZXZlbnQgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhdGhpcy5lbGVtZW50LmlzKCBcIjpmb2N1c1wiICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWRpcmVjdCBmb2N1cyB0byB0aGUgbWVudVxuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIFwiZm9jdXNcIiwgWyB0cnVlIF0gKTtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGFjdGl2ZSBpdGVtIGlzIG9uIHRoZSB0b3AgbGV2ZWwsIGxldCBpdCBzdGF5IGFjdGl2ZS5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgYmx1ciB0aGUgYWN0aXZlIGl0ZW0gc2luY2UgaXQgaXMgbm8gbG9uZ2VyIHZpc2libGUuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuYWN0aXZlICYmIHRoaXMuYWN0aXZlLnBhcmVudHMoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XCJtb3VzZWVudGVyIC51aS1tZW51LWl0ZW1cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gJCggZXZlbnQuY3VycmVudFRhcmdldCApO1xuXHRcdFx0XHQvLyBSZW1vdmUgdWktc3RhdGUtYWN0aXZlIGNsYXNzIGZyb20gc2libGluZ3Mgb2YgdGhlIG5ld2x5IGZvY3VzZWQgbWVudSBpdGVtXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGEganVtcCBjYXVzZWQgYnkgYWRqYWNlbnQgZWxlbWVudHMgYm90aCBoYXZpbmcgYSBjbGFzcyB3aXRoIGEgYm9yZGVyXG5cdFx0XHRcdHRhcmdldC5zaWJsaW5ncygpLmNoaWxkcmVuKCBcIi51aS1zdGF0ZS1hY3RpdmVcIiApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCB0YXJnZXQgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBcImNvbGxhcHNlQWxsXCIsXG5cdFx0XHRcIm1vdXNlbGVhdmUgLnVpLW1lbnVcIjogXCJjb2xsYXBzZUFsbFwiLFxuXHRcdFx0Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwga2VlcEFjdGl2ZUl0ZW0gKSB7XG5cdFx0XHRcdC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhbiBhY3RpdmUgaXRlbSwga2VlcCBpdCBhY3RpdmVcblx0XHRcdFx0Ly8gSWYgbm90LCBhY3RpdmF0ZSB0aGUgZmlyc3QgaXRlbVxuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuYWN0aXZlIHx8IHRoaXMuZWxlbWVudC5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5lcSggMCApO1xuXG5cdFx0XHRcdGlmICggIWtlZXBBY3RpdmVJdGVtICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBpdGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRibHVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFswXSwgdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmNvbGxhcHNlQWxsKCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0a2V5ZG93bjogXCJfa2V5ZG93blwiXG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdC8vIENsaWNrcyBvdXRzaWRlIG9mIGEgbWVudSBjb2xsYXBzZSBhbnkgb3BlbiBtZW51c1xuXHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoICEkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBtb3VzZUhhbmRsZWQgZmxhZ1xuXHRcdFx0XHR0aGlzLm1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBEZXN0cm95IChzdWIpbWVudXNcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiIClcblx0XHRcdC5maW5kKCBcIi51aS1tZW51XCIgKS5hZGRCYWNrKClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktbWVudS1pY29uc1wiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1leHBhbmRlZFwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpXG5cdFx0XHRcdC5zaG93KCk7XG5cblx0XHQvLyBEZXN0cm95IG1lbnUgaXRlbXNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLW1lbnUtaXRlbVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImFcIiApXG5cdFx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWhvdmVyXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oYXNwb3B1cFwiIClcblx0XHRcdFx0LmNoaWxkcmVuKCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmRhdGEoIFwidWktbWVudS1zdWJtZW51LWNhcmF0XCIgKSApIHtcblx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdC8vIERlc3Ryb3kgbWVudSBkaXZpZGVyc1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWRpdmlkZXJcIiApLnJlbW92ZUNsYXNzKCBcInVpLW1lbnUtZGl2aWRlciB1aS13aWRnZXQtY29udGVudFwiICk7XG5cdH0sXG5cblx0X2tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHQvKmpzaGludCBtYXhjb21wbGV4aXR5OjIwKi9cblx0XHR2YXIgbWF0Y2gsIHByZXYsIGNoYXJhY3Rlciwgc2tpcCwgcmVnZXgsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cblx0XHRmdW5jdGlvbiBlc2NhcGUoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIiApO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdHRoaXMucHJldmlvdXNQYWdlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0dGhpcy5uZXh0UGFnZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHR0aGlzLl9tb3ZlKCBcImZpcnN0XCIsIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdHRoaXMuX21vdmUoIFwibGFzdFwiLCBcImxhc3RcIiwgZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0dGhpcy5wcmV2aW91cyggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0dGhpcy5jb2xsYXBzZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUuaXMoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSApIHtcblx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcblx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRVNDQVBFOlxuXHRcdFx0dGhpcy5jb2xsYXBzZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0cHJldiA9IHRoaXMucHJldmlvdXNGaWx0ZXIgfHwgXCJcIjtcblx0XHRcdGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGV2ZW50LmtleUNvZGUgKTtcblx0XHRcdHNraXAgPSBmYWxzZTtcblxuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmZpbHRlclRpbWVyICk7XG5cblx0XHRcdGlmICggY2hhcmFjdGVyID09PSBwcmV2ICkge1xuXHRcdFx0XHRza2lwID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYXJhY3RlciA9IHByZXYgKyBjaGFyYWN0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBlc2NhcGUoIGNoYXJhY3RlciApLCBcImlcIiApO1xuXHRcdFx0bWF0Y2ggPSB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcmVnZXgudGVzdCggJCggdGhpcyApLmNoaWxkcmVuKCBcImFcIiApLnRleHQoKSApO1xuXHRcdFx0fSk7XG5cdFx0XHRtYXRjaCA9IHNraXAgJiYgbWF0Y2guaW5kZXgoIHRoaXMuYWN0aXZlLm5leHQoKSApICE9PSAtMSA/XG5cdFx0XHRcdHRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkgOlxuXHRcdFx0XHRtYXRjaDtcblxuXHRcdFx0Ly8gSWYgbm8gbWF0Y2hlcyBvbiB0aGUgY3VycmVudCBmaWx0ZXIsIHJlc2V0IHRvIHRoZSBsYXN0IGNoYXJhY3RlciBwcmVzc2VkXG5cdFx0XHQvLyB0byBtb3ZlIGRvd24gdGhlIG1lbnUgdG8gdGhlIGZpcnN0IGl0ZW0gdGhhdCBzdGFydHMgd2l0aCB0aGF0IGNoYXJhY3RlclxuXHRcdFx0aWYgKCAhbWF0Y2gubGVuZ3RoICkge1xuXHRcdFx0XHRjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5rZXlDb2RlICk7XG5cdFx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBlc2NhcGUoIGNoYXJhY3RlciApLCBcImlcIiApO1xuXHRcdFx0XHRtYXRjaCA9IHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZ2V4LnRlc3QoICQoIHRoaXMgKS5jaGlsZHJlbiggXCJhXCIgKS50ZXh0KCkgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0Y2gubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbWF0Y2ggKTtcblx0XHRcdFx0aWYgKCBtYXRjaC5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXNGaWx0ZXIgPSBjaGFyYWN0ZXI7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHRcdFx0fSwgMTAwMCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUuaXMoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSApIHtcblx0XHRcdGlmICggdGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiYVthcmlhLWhhc3BvcHVwPSd0cnVlJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lbnVzLFxuXHRcdFx0aWNvbiA9IHRoaXMub3B0aW9ucy5pY29ucy5zdWJtZW51LFxuXHRcdFx0c3VibWVudXMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLm1lbnVzICk7XG5cblx0XHQvLyBJbml0aWFsaXplIG5lc3RlZCBtZW51c1xuXHRcdHN1Ym1lbnVzLmZpbHRlciggXCI6bm90KC51aS1tZW51KVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWVudSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRpdGVtID0gbWVudS5wcmV2KCBcImFcIiApLFxuXHRcdFx0XHRcdHN1Ym1lbnVDYXJhdCA9ICQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUtaWNvbiB1aS1pY29uIFwiICsgaWNvbiApXG5cdFx0XHRcdFx0XHQuZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcIiwgdHJ1ZSApO1xuXG5cdFx0XHRcdGl0ZW1cblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiIClcblx0XHRcdFx0XHQucHJlcGVuZCggc3VibWVudUNhcmF0ICk7XG5cdFx0XHRcdG1lbnUuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaXRlbS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0fSk7XG5cblx0XHRtZW51cyA9IHN1Ym1lbnVzLmFkZCggdGhpcy5lbGVtZW50ICk7XG5cblx0XHQvLyBEb24ndCByZWZyZXNoIGxpc3QgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSBhZGFwdGVkXG5cdFx0bWVudXMuY2hpbGRyZW4oIFwiOm5vdCgudWktbWVudS1pdGVtKTpoYXMoYSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdFx0XHRyb2xlOiB0aGlzLl9pdGVtUm9sZSgpXG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB1bmxpbmtlZCBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIjpub3QoLnVpLW1lbnUtaXRlbSlcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdC8vIGh5cGhlbiwgZW0gZGFzaCwgZW4gZGFzaFxuXHRcdFx0aWYgKCAhL1teXFwtXFx1MjAxNFxcdTIwMTNcXHNdLy50ZXN0KCBpdGVtLnRleHQoKSApICkge1xuXHRcdFx0XHRpdGVtLmFkZENsYXNzKCBcInVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtZGl2aWRlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkuYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHQvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZCwgYmx1ciB0aGUgbWVudVxuXHRcdGlmICggdGhpcy5hY3RpdmUgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLCB0aGlzLmFjdGl2ZVsgMCBdICkgKSB7XG5cdFx0XHR0aGlzLmJsdXIoKTtcblx0XHR9XG5cdH0sXG5cblx0X2l0ZW1Sb2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVudTogXCJtZW51aXRlbVwiLFxuXHRcdFx0bGlzdGJveDogXCJvcHRpb25cIlxuXHRcdH1bIHRoaXMub3B0aW9ucy5yb2xlIF07XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHZhbHVlLnN1Ym1lbnUgKTtcblx0XHR9XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRmb2N1czogZnVuY3Rpb24oIGV2ZW50LCBpdGVtICkge1xuXHRcdHZhciBuZXN0ZWQsIGZvY3VzZWQ7XG5cdFx0dGhpcy5ibHVyKCBldmVudCwgZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJmb2N1c1wiICk7XG5cblx0XHR0aGlzLl9zY3JvbGxJbnRvVmlldyggaXRlbSApO1xuXG5cdFx0dGhpcy5hY3RpdmUgPSBpdGVtLmZpcnN0KCk7XG5cdFx0Zm9jdXNlZCA9IHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFcIiApLmFkZENsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHQvLyBPbmx5IHVwZGF0ZSBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQgaWYgdGhlcmUncyBhIHJvbGVcblx0XHQvLyBvdGhlcndpc2Ugd2UgYXNzdW1lIGZvY3VzIGlzIG1hbmFnZWQgZWxzZXdoZXJlXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucm9sZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBmb2N1c2VkLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gSGlnaGxpZ2h0IGFjdGl2ZSBwYXJlbnQgbWVudSBpdGVtLCBpZiBhbnlcblx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0LnBhcmVudCgpXG5cdFx0XHQuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImE6Zmlyc3RcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIgKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0bmVzdGVkID0gaXRlbS5jaGlsZHJlbiggXCIudWktbWVudVwiICk7XG5cdFx0aWYgKCBuZXN0ZWQubGVuZ3RoICYmICggL15tb3VzZS8udGVzdCggZXZlbnQudHlwZSApICkgKSB7XG5cdFx0XHR0aGlzLl9zdGFydE9wZW5pbmcobmVzdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdH0sXG5cblx0X3Njcm9sbEludG9WaWV3OiBmdW5jdGlvbiggaXRlbSApIHtcblx0XHR2YXIgYm9yZGVyVG9wLCBwYWRkaW5nVG9wLCBvZmZzZXQsIHNjcm9sbCwgZWxlbWVudEhlaWdodCwgaXRlbUhlaWdodDtcblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVswXSwgXCJib3JkZXJUb3BXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0cGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoICQuY3NzKCB0aGlzLmFjdGl2ZU1lbnVbMF0sIFwicGFkZGluZ1RvcFwiICkgKSB8fCAwO1xuXHRcdFx0b2Zmc2V0ID0gaXRlbS5vZmZzZXQoKS50b3AgLSB0aGlzLmFjdGl2ZU1lbnUub2Zmc2V0KCkudG9wIC0gYm9yZGVyVG9wIC0gcGFkZGluZ1RvcDtcblx0XHRcdHNjcm9sbCA9IHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoKTtcblx0XHRcdGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFjdGl2ZU1lbnUuaGVpZ2h0KCk7XG5cdFx0XHRpdGVtSGVpZ2h0ID0gaXRlbS5oZWlnaHQoKTtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPCAwICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9mZnNldCArIGl0ZW1IZWlnaHQgPiBlbGVtZW50SGVpZ2h0ICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgLSBlbGVtZW50SGVpZ2h0ICsgaXRlbUhlaWdodCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRibHVyOiBmdW5jdGlvbiggZXZlbnQsIGZyb21Gb2N1cyApIHtcblx0XHRpZiAoICFmcm9tRm9jdXMgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmFjdGl2ZS5jaGlsZHJlbiggXCJhXCIgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0dGhpcy5hY3RpdmUgPSBudWxsO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJibHVyXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuYWN0aXZlIH0gKTtcblx0fSxcblxuXHRfc3RhcnRPcGVuaW5nOiBmdW5jdGlvbiggc3VibWVudSApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblxuXHRcdC8vIERvbid0IG9wZW4gaWYgYWxyZWFkeSBvcGVuIGZpeGVzIGEgRmlyZWZveCBidWcgdGhhdCBjYXVzZWQgYSAuNSBwaXhlbFxuXHRcdC8vIHNoaWZ0IGluIHRoZSBzdWJtZW51IHBvc2l0aW9uIHdoZW4gbW91c2luZyBvdmVyIHRoZSBjYXJhdCBpY29uXG5cdFx0aWYgKCBzdWJtZW51LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiApICE9PSBcInRydWVcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0dGhpcy5fb3Blbiggc3VibWVudSApO1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHRfb3BlbjogZnVuY3Rpb24oIHN1Ym1lbnUgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gJC5leHRlbmQoe1xuXHRcdFx0b2Y6IHRoaXMuYWN0aXZlXG5cdFx0fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uICk7XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudVwiICkubm90KCBzdWJtZW51LnBhcmVudHMoIFwiLnVpLW1lbnVcIiApIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRzdWJtZW51XG5cdFx0XHQuc2hvdygpXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIgKVxuXHRcdFx0LnBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlQWxsOiBmdW5jdGlvbiggZXZlbnQsIGFsbCApIHtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBldmVudCwgbG9vayBmb3IgdGhlIHN1Ym1lbnUgdGhhdCBjb250YWlucyB0aGUgZXZlbnRcblx0XHRcdHZhciBjdXJyZW50TWVudSA9IGFsbCA/IHRoaXMuZWxlbWVudCA6XG5cdFx0XHRcdCQoIGV2ZW50ICYmIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51XCIgKSApO1xuXG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBubyB2YWxpZCBzdWJtZW51IGFuY2VzdG9yLCB1c2UgdGhlIG1haW4gbWVudSB0byBjbG9zZSBhbGwgc3ViIG1lbnVzIGFueXdheVxuXHRcdFx0aWYgKCAhY3VycmVudE1lbnUubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJyZW50TWVudSA9IHRoaXMuZWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2xvc2UoIGN1cnJlbnRNZW51ICk7XG5cblx0XHRcdHRoaXMuYmx1ciggZXZlbnQgKTtcblx0XHRcdHRoaXMuYWN0aXZlTWVudSA9IGN1cnJlbnRNZW51O1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHQvLyBXaXRoIG5vIGFyZ3VtZW50cywgY2xvc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgLSBpZiBub3RoaW5nIGlzIGFjdGl2ZVxuXHQvLyBpdCBjbG9zZXMgYWxsIG1lbnVzLiAgSWYgcGFzc2VkIGFuIGFyZ3VtZW50LCBpdCB3aWxsIHNlYXJjaCBmb3IgbWVudXMgQkVMT1dcblx0X2Nsb3NlOiBmdW5jdGlvbiggc3RhcnRNZW51ICkge1xuXHRcdGlmICggIXN0YXJ0TWVudSApIHtcblx0XHRcdHN0YXJ0TWVudSA9IHRoaXMuYWN0aXZlID8gdGhpcy5hY3RpdmUucGFyZW50KCkgOiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0c3RhcnRNZW51XG5cdFx0XHQuZmluZCggXCIudWktbWVudVwiIClcblx0XHRcdFx0LmhpZGUoKVxuXHRcdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiIClcblx0XHRcdC5lbmQoKVxuXHRcdFx0LmZpbmQoIFwiYS51aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHR9LFxuXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG5ld0l0ZW0gPSB0aGlzLmFjdGl2ZSAmJlxuXHRcdFx0dGhpcy5hY3RpdmUucGFyZW50KCkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIsIHRoaXMuZWxlbWVudCApO1xuXHRcdGlmICggbmV3SXRlbSAmJiBuZXdJdGVtLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV3SXRlbSApO1xuXHRcdH1cblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmXG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUgXCIgKVxuXHRcdFx0XHQuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0LmZpcnN0KCk7XG5cblx0XHRpZiAoIG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBuZXdJdGVtLnBhcmVudCgpICk7XG5cblx0XHRcdC8vIERlbGF5IHNvIEZpcmVmb3ggd2lsbCBub3QgaGlkZSBhY3RpdmVkZXNjZW5kYW50IGNoYW5nZSBpbiBleHBhbmRpbmcgc3VibWVudSBmcm9tIEFUXG5cdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5ld0l0ZW0gKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fbW92ZSggXCJuZXh0XCIsIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRwcmV2aW91czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX21vdmUoIFwicHJldlwiLCBcImxhc3RcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRpc0ZpcnN0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5wcmV2QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aDtcblx0fSxcblxuXHRpc0xhc3RJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBmaWx0ZXIsIGV2ZW50ICkge1xuXHRcdHZhciBuZXh0O1xuXHRcdGlmICggdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsYXN0XCIgKSB7XG5cdFx0XHRcdG5leHQgPSB0aGlzLmFjdGl2ZVxuXHRcdFx0XHRcdFsgZGlyZWN0aW9uID09PSBcImZpcnN0XCIgPyBcInByZXZBbGxcIiA6IFwibmV4dEFsbFwiIF0oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0XHQuZXEoIC0xICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVcblx0XHRcdFx0XHRbIGRpcmVjdGlvbiArIFwiQWxsXCIgXSggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5lcSggMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoICFuZXh0IHx8ICFuZXh0Lmxlbmd0aCB8fCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApWyBmaWx0ZXIgXSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXh0ICk7XG5cdH0sXG5cblx0bmV4dFBhZ2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaXRlbSwgYmFzZSwgaGVpZ2h0O1xuXG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0xhc3RJdGVtKCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faGFzU2Nyb2xsKCkgKSB7XG5cdFx0XHRiYXNlID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wO1xuXHRcdFx0aGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUubmV4dEFsbCggXCIudWktbWVudS1pdGVtXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5vZmZzZXQoKS50b3AgLSBiYXNlIC0gaGVpZ2h0IDwgMDtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFsgIXRoaXMuYWN0aXZlID8gXCJmaXJzdFwiIDogXCJsYXN0XCIgXSgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZXZpb3VzUGFnZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0ZpcnN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLnByZXZBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW0ub2Zmc2V0KCkudG9wIC0gYmFzZSArIGhlaWdodCA+IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maXJzdCgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYXNTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSA8IHRoaXMuZWxlbWVudC5wcm9wKCBcInNjcm9sbEhlaWdodFwiICk7XG5cdH0sXG5cblx0c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Ly8gVE9ETzogSXQgc2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIG5vdCBoYXZlIGFuIGFjdGl2ZSBpdGVtIGF0IHRoaXNcblx0XHQvLyBwb2ludCwgYnV0IHRoZSB0ZXN0cyBkb24ndCB0cmlnZ2VyIG1vdXNlZW50ZXIgYmVmb3JlIGNsaWNrLlxuXHRcdHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgfHwgJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKTtcblx0XHR2YXIgdWkgPSB7IGl0ZW06IHRoaXMuYWN0aXZlIH07XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUuaGFzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmNvbGxhcHNlQWxsKCBldmVudCwgdHJ1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl90cmlnZ2VyKCBcInNlbGVjdFwiLCBldmVudCwgdWkgKTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cm91bmQgPSBNYXRoLnJvdW5kLFxuXHRyaG9yaXpvbnRhbCA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXG5cdHJ2ZXJ0aWNhbCA9IC90b3B8Y2VudGVyfGJvdHRvbS8sXG5cdHJvZmZzZXQgPSAvW1xcK1xcLV1cXGQrKFxcLltcXGRdKyk/JT8vLFxuXHRycG9zaXRpb24gPSAvXlxcdysvLFxuXHRycGVyY2VudCA9IC8lJC8sXG5cdF9wb3NpdGlvbiA9ICQuZm4ucG9zaXRpb247XG5cbmZ1bmN0aW9uIGdldE9mZnNldHMoIG9mZnNldHMsIHdpZHRoLCBoZWlnaHQgKSB7XG5cdHJldHVybiBbXG5cdFx0cGFyc2VGbG9hdCggb2Zmc2V0c1sgMCBdICkgKiAoIHJwZXJjZW50LnRlc3QoIG9mZnNldHNbIDAgXSApID8gd2lkdGggLyAxMDAgOiAxICksXG5cdFx0cGFyc2VGbG9hdCggb2Zmc2V0c1sgMSBdICkgKiAoIHJwZXJjZW50LnRlc3QoIG9mZnNldHNbIDEgXSApID8gaGVpZ2h0IC8gMTAwIDogMSApXG5cdF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApIHtcblx0cmV0dXJuIHBhcnNlSW50KCAkLmNzcyggZWxlbWVudCwgcHJvcGVydHkgKSwgMTAgKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKCBlbGVtICkge1xuXHR2YXIgcmF3ID0gZWxlbVswXTtcblx0aWYgKCByYXcubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH1cblx0XHR9O1xuXHR9XG5cdGlmICggJC5pc1dpbmRvdyggcmF3ICkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLCBsZWZ0OiBlbGVtLnNjcm9sbExlZnQoKSB9XG5cdFx0fTtcblx0fVxuXHRpZiAoIHJhdy5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiByYXcucGFnZVksIGxlZnQ6IHJhdy5wYWdlWCB9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRoZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcblx0fTtcbn1cblxuJC5wb3NpdGlvbiA9IHtcblx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdFx0dmFyIHcxLCB3Mixcblx0XHRcdGRpdiA9ICQoIFwiPGRpdiBzdHlsZT0nZGlzcGxheTpibG9jazt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OmhpZGRlbjsnPjxkaXYgc3R5bGU9J2hlaWdodDoxMDBweDt3aWR0aDphdXRvOyc+PC9kaXY+PC9kaXY+XCIgKSxcblx0XHRcdGlubmVyRGl2ID0gZGl2LmNoaWxkcmVuKClbMF07XG5cblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggZGl2ICk7XG5cdFx0dzEgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblx0XHRkaXYuY3NzKCBcIm92ZXJmbG93XCIsIFwic2Nyb2xsXCIgKTtcblxuXHRcdHcyID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cblx0XHRpZiAoIHcxID09PSB3MiApIHtcblx0XHRcdHcyID0gZGl2WzBdLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdGRpdi5yZW1vdmUoKTtcblxuXHRcdHJldHVybiAoY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3MSAtIHcyKTtcblx0fSxcblx0Z2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oIHdpdGhpbiApIHtcblx0XHR2YXIgb3ZlcmZsb3dYID0gd2l0aGluLmlzV2luZG93ID8gXCJcIiA6IHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy14XCIgKSxcblx0XHRcdG92ZXJmbG93WSA9IHdpdGhpbi5pc1dpbmRvdyA/IFwiXCIgOiB3aXRoaW4uZWxlbWVudC5jc3MoIFwib3ZlcmZsb3cteVwiICksXG5cdFx0XHRoYXNPdmVyZmxvd1ggPSBvdmVyZmxvd1ggPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1ggPT09IFwiYXV0b1wiICYmIHdpdGhpbi53aWR0aCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbFdpZHRoICksXG5cdFx0XHRoYXNPdmVyZmxvd1kgPSBvdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1kgPT09IFwiYXV0b1wiICYmIHdpdGhpbi5oZWlnaHQgPCB3aXRoaW4uZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGhhc092ZXJmbG93WSA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcblx0XHR9O1xuXHR9LFxuXHRnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgd2l0aGluRWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgd2luZG93ICksXG5cdFx0XHRpc1dpbmRvdyA9ICQuaXNXaW5kb3coIHdpdGhpbkVsZW1lbnRbMF0gKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdG9mZnNldDogd2l0aGluRWxlbWVudC5vZmZzZXQoKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuXHRcdFx0c2Nyb2xsTGVmdDogd2l0aGluRWxlbWVudC5zY3JvbGxMZWZ0KCksXG5cdFx0XHRzY3JvbGxUb3A6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHR3aWR0aDogaXNXaW5kb3cgPyB3aXRoaW5FbGVtZW50LndpZHRoKCkgOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogaXNXaW5kb3cgPyB3aXRoaW5FbGVtZW50LmhlaWdodCgpIDogd2l0aGluRWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fVxufTtcblxuJC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoICFvcHRpb25zIHx8ICFvcHRpb25zLm9mICkge1xuXHRcdHJldHVybiBfcG9zaXRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0Ly8gbWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xuXHRvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIGF0T2Zmc2V0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRPZmZzZXQsIGJhc2VQb3NpdGlvbiwgZGltZW5zaW9ucyxcblx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLm9mICksXG5cdFx0d2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKCBvcHRpb25zLndpdGhpbiApLFxuXHRcdHNjcm9sbEluZm8gPSAkLnBvc2l0aW9uLmdldFNjcm9sbEluZm8oIHdpdGhpbiApLFxuXHRcdGNvbGxpc2lvbiA9ICggb3B0aW9ucy5jb2xsaXNpb24gfHwgXCJmbGlwXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRvZmZzZXRzID0ge307XG5cblx0ZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIHRhcmdldCApO1xuXHRpZiAoIHRhcmdldFswXS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHQvLyBmb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xuXHRcdG9wdGlvbnMuYXQgPSBcImxlZnQgdG9wXCI7XG5cdH1cblx0dGFyZ2V0V2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuXHR0YXJnZXRIZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcblx0dGFyZ2V0T2Zmc2V0ID0gZGltZW5zaW9ucy5vZmZzZXQ7XG5cdC8vIGNsb25lIHRvIHJldXNlIG9yaWdpbmFsIHRhcmdldE9mZnNldCBsYXRlclxuXHRiYXNlUG9zaXRpb24gPSAkLmV4dGVuZCgge30sIHRhcmdldE9mZnNldCApO1xuXG5cdC8vIGZvcmNlIG15IGFuZCBhdCB0byBoYXZlIHZhbGlkIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHBvc2l0aW9uc1xuXHQvLyBpZiBhIHZhbHVlIGlzIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2VudGVyXG5cdCQuZWFjaCggWyBcIm15XCIsIFwiYXRcIiBdLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gKCBvcHRpb25zWyB0aGlzIF0gfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCxcblx0XHRcdHZlcnRpY2FsT2Zmc2V0O1xuXG5cdFx0aWYgKCBwb3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRwb3MgPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0cG9zLmNvbmNhdCggWyBcImNlbnRlclwiIF0gKSA6XG5cdFx0XHRcdHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0XHRbIFwiY2VudGVyXCIgXS5jb25jYXQoIHBvcyApIDpcblx0XHRcdFx0XHRbIFwiY2VudGVyXCIsIFwiY2VudGVyXCIgXTtcblx0XHR9XG5cdFx0cG9zWyAwIF0gPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID8gcG9zWyAwIF0gOiBcImNlbnRlclwiO1xuXHRcdHBvc1sgMSBdID0gcnZlcnRpY2FsLnRlc3QoIHBvc1sgMSBdICkgPyBwb3NbIDEgXSA6IFwiY2VudGVyXCI7XG5cblx0XHQvLyBjYWxjdWxhdGUgb2Zmc2V0c1xuXHRcdGhvcml6b250YWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMCBdICk7XG5cdFx0dmVydGljYWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMSBdICk7XG5cdFx0b2Zmc2V0c1sgdGhpcyBdID0gW1xuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXRbIDAgXSA6IDAsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0WyAwIF0gOiAwXG5cdFx0XTtcblxuXHRcdC8vIHJlZHVjZSB0byBqdXN0IHRoZSBwb3NpdGlvbnMgd2l0aG91dCB0aGUgb2Zmc2V0c1xuXHRcdG9wdGlvbnNbIHRoaXMgXSA9IFtcblx0XHRcdHJwb3NpdGlvbi5leGVjKCBwb3NbIDAgXSApWyAwIF0sXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAxIF0gKVsgMCBdXG5cdFx0XTtcblx0fSk7XG5cblx0Ly8gbm9ybWFsaXplIGNvbGxpc2lvbiBvcHRpb25cblx0aWYgKCBjb2xsaXNpb24ubGVuZ3RoID09PSAxICkge1xuXHRcdGNvbGxpc2lvblsgMSBdID0gY29sbGlzaW9uWyAwIF07XG5cdH1cblxuXHRpZiAoIG9wdGlvbnMuYXRbIDAgXSA9PT0gXCJyaWdodFwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoO1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gdGFyZ2V0V2lkdGggLyAyO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiYm90dG9tXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQ7XG5cdH0gZWxzZSBpZiAoIG9wdGlvbnMuYXRbIDEgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodCAvIDI7XG5cdH1cblxuXHRhdE9mZnNldCA9IGdldE9mZnNldHMoIG9mZnNldHMuYXQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQgKTtcblx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gYXRPZmZzZXRbIDAgXTtcblx0YmFzZVBvc2l0aW9uLnRvcCArPSBhdE9mZnNldFsgMSBdO1xuXG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbGxpc2lvblBvc2l0aW9uLCB1c2luZyxcblx0XHRcdGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRcdGVsZW1IZWlnaHQgPSBlbGVtLm91dGVySGVpZ2h0KCksXG5cdFx0XHRtYXJnaW5MZWZ0ID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRtYXJnaW5Ub3AgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0Y29sbGlzaW9uV2lkdGggPSBlbGVtV2lkdGggKyBtYXJnaW5MZWZ0ICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luUmlnaHRcIiApICsgc2Nyb2xsSW5mby53aWR0aCxcblx0XHRcdGNvbGxpc2lvbkhlaWdodCA9IGVsZW1IZWlnaHQgKyBtYXJnaW5Ub3AgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Cb3R0b21cIiApICsgc2Nyb2xsSW5mby5oZWlnaHQsXG5cdFx0XHRwb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgYmFzZVBvc2l0aW9uICksXG5cdFx0XHRteU9mZnNldCA9IGdldE9mZnNldHMoIG9mZnNldHMubXksIGVsZW0ub3V0ZXJXaWR0aCgpLCBlbGVtLm91dGVySGVpZ2h0KCkgKTtcblxuXHRcdGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aCAvIDI7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiYm90dG9tXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldFsgMCBdO1xuXHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldFsgMSBdO1xuXG5cdFx0Ly8gaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGZyYWN0aW9ucywgdGhlbiByb3VuZCBmb3IgY29uc2lzdGVudCByZXN1bHRzXG5cdFx0aWYgKCAhJC5zdXBwb3J0Lm9mZnNldEZyYWN0aW9ucyApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgPSByb3VuZCggcG9zaXRpb24ubGVmdCApO1xuXHRcdFx0cG9zaXRpb24udG9wID0gcm91bmQoIHBvc2l0aW9uLnRvcCApO1xuXHRcdH1cblxuXHRcdGNvbGxpc2lvblBvc2l0aW9uID0ge1xuXHRcdFx0bWFyZ2luTGVmdDogbWFyZ2luTGVmdCxcblx0XHRcdG1hcmdpblRvcDogbWFyZ2luVG9wXG5cdFx0fTtcblxuXHRcdCQuZWFjaCggWyBcImxlZnRcIiwgXCJ0b3BcIiBdLCBmdW5jdGlvbiggaSwgZGlyICkge1xuXHRcdFx0aWYgKCAkLnVpLnBvc2l0aW9uWyBjb2xsaXNpb25bIGkgXSBdICkge1xuXHRcdFx0XHQkLnVpLnBvc2l0aW9uWyBjb2xsaXNpb25bIGkgXSBdWyBkaXIgXSggcG9zaXRpb24sIHtcblx0XHRcdFx0XHR0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0dGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG5cdFx0XHRcdFx0ZWxlbVdpZHRoOiBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0ZWxlbUhlaWdodDogZWxlbUhlaWdodCxcblx0XHRcdFx0XHRjb2xsaXNpb25Qb3NpdGlvbjogY29sbGlzaW9uUG9zaXRpb24sXG5cdFx0XHRcdFx0Y29sbGlzaW9uV2lkdGg6IGNvbGxpc2lvbldpZHRoLFxuXHRcdFx0XHRcdGNvbGxpc2lvbkhlaWdodDogY29sbGlzaW9uSGVpZ2h0LFxuXHRcdFx0XHRcdG9mZnNldDogWyBhdE9mZnNldFsgMCBdICsgbXlPZmZzZXRbIDAgXSwgYXRPZmZzZXQgWyAxIF0gKyBteU9mZnNldFsgMSBdIF0sXG5cdFx0XHRcdFx0bXk6IG9wdGlvbnMubXksXG5cdFx0XHRcdFx0YXQ6IG9wdGlvbnMuYXQsXG5cdFx0XHRcdFx0d2l0aGluOiB3aXRoaW4sXG5cdFx0XHRcdFx0ZWxlbSA6IGVsZW1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNpbmcgKSB7XG5cdFx0XHQvLyBhZGRzIGZlZWRiYWNrIGFzIHNlY29uZCBhcmd1bWVudCB0byB1c2luZyBjYWxsYmFjaywgaWYgcHJlc2VudFxuXHRcdFx0dXNpbmcgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBsZWZ0ID0gdGFyZ2V0T2Zmc2V0LmxlZnQgLSBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdHJpZ2h0ID0gbGVmdCArIHRhcmdldFdpZHRoIC0gZWxlbVdpZHRoLFxuXHRcdFx0XHRcdHRvcCA9IHRhcmdldE9mZnNldC50b3AgLSBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0Ym90dG9tID0gdG9wICsgdGFyZ2V0SGVpZ2h0IC0gZWxlbUhlaWdodCxcblx0XHRcdFx0XHRmZWVkYmFjayA9IHtcblx0XHRcdFx0XHRcdHRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHRhcmdldE9mZnNldC5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHRhcmdldE9mZnNldC50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiB0YXJnZXRIZWlnaHRcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRlbGVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW0sXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1IZWlnaHRcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRob3Jpem9udGFsOiByaWdodCA8IDAgPyBcImxlZnRcIiA6IGxlZnQgPiAwID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIixcblx0XHRcdFx0XHRcdHZlcnRpY2FsOiBib3R0b20gPCAwID8gXCJ0b3BcIiA6IHRvcCA+IDAgPyBcImJvdHRvbVwiIDogXCJtaWRkbGVcIlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGlmICggdGFyZ2V0V2lkdGggPCBlbGVtV2lkdGggJiYgYWJzKCBsZWZ0ICsgcmlnaHQgKSA8IHRhcmdldFdpZHRoICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmhvcml6b250YWwgPSBcImNlbnRlclwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGFyZ2V0SGVpZ2h0IDwgZWxlbUhlaWdodCAmJiBhYnMoIHRvcCArIGJvdHRvbSApIDwgdGFyZ2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLnZlcnRpY2FsID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1heCggYWJzKCBsZWZ0ICksIGFicyggcmlnaHQgKSApID4gbWF4KCBhYnMoIHRvcCApLCBhYnMoIGJvdHRvbSApICkgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaW1wb3J0YW50ID0gXCJob3Jpem9udGFsXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaW1wb3J0YW50ID0gXCJ2ZXJ0aWNhbFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggdGhpcywgcHJvcHMsIGZlZWRiYWNrICk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGVsZW0ub2Zmc2V0KCAkLmV4dGVuZCggcG9zaXRpb24sIHsgdXNpbmc6IHVzaW5nIH0gKSApO1xuXHR9KTtcbn07XG5cbiQudWkucG9zaXRpb24gPSB7XG5cdGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc0xlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBlbGVtZW50IGlzIHdpZGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uV2lkdGggPiBvdXRlcldpZHRoICkge1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSBsZWZ0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdGlmICggb3ZlckxlZnQgPiAwICYmIG92ZXJSaWdodCA8PSAwICkge1xuXHRcdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBvdmVyTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQgLSBuZXdPdmVyUmlnaHQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgcmlnaHQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCAmJiBvdmVyTGVmdCA8PSAwICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldCArIG91dGVyV2lkdGggLSBkYXRhLmNvbGxpc2lvbldpZHRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gdG9vIGZhciBsZWZ0IC0+IGFsaWduIHdpdGggbGVmdCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyTGVmdCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XG5cdFx0XHQvLyB0b28gZmFyIHJpZ2h0IC0+IGFsaWduIHdpdGggcmlnaHQgZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCAtPSBvdmVyUmlnaHQ7XG5cdFx0XHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IG1heCggcG9zaXRpb24ubGVmdCAtIGNvbGxpc2lvblBvc0xlZnQsIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gZGF0YS53aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc1RvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cblx0XHRcdC8vIGVsZW1lbnQgaXMgdGFsbGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uSGVpZ2h0ID4gb3V0ZXJIZWlnaHQgKSB7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG92ZXJUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wIC0gbmV3T3ZlckJvdHRvbTtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICYmIG92ZXJUb3AgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCB0b3AgYW5kIGJvdHRvbSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJUb3AgPiBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0ICsgb3V0ZXJIZWlnaHQgLSBkYXRhLmNvbGxpc2lvbkhlaWdodDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gdG9vIGZhciB1cCAtPiBhbGlnbiB3aXRoIHRvcFxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclRvcCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wO1xuXHRcdFx0Ly8gdG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgLT0gb3ZlckJvdHRvbTtcblx0XHRcdC8vIGFkanVzdCBiYXNlZCBvbiBwb3NpdGlvbiBhbmQgbWFyZ2luXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgPSBtYXgoIHBvc2l0aW9uLnRvcCAtIGNvbGxpc2lvblBvc1RvcCwgcG9zaXRpb24udG9wICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwOiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LmxlZnQgKyB3aXRoaW4uc2Nyb2xsTGVmdCxcblx0XHRcdFx0b3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcblx0XHRcdFx0b2Zmc2V0TGVmdCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcblx0XHRcdFx0b3ZlckxlZnQgPSBjb2xsaXNpb25Qb3NMZWZ0IC0gb2Zmc2V0TGVmdCxcblx0XHRcdFx0b3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gb2Zmc2V0TGVmdCxcblx0XHRcdFx0bXlPZmZzZXQgPSBkYXRhLm15WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdGRhdGEubXlbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdGRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0b2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsgMCBdLFxuXHRcdFx0XHRuZXdPdmVyUmlnaHQsXG5cdFx0XHRcdG5ld092ZXJMZWZ0O1xuXG5cdFx0XHRpZiAoIG92ZXJMZWZ0IDwgMCApIHtcblx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyUmlnaHQgPCAwIHx8IG5ld092ZXJSaWdodCA8IGFicyggb3ZlckxlZnQgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0IC0gb2Zmc2V0TGVmdDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyTGVmdCA+IDAgfHwgYWJzKCBuZXdPdmVyTGVmdCApIDwgb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQudG9wICsgd2l0aGluLnNjcm9sbFRvcCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQgPSB3aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRvZmZzZXRUb3AgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxuXHRcdFx0XHRvdmVyVG9wID0gY29sbGlzaW9uUG9zVG9wIC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHRvdmVyQm90dG9tID0gY29sbGlzaW9uUG9zVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIG9mZnNldFRvcCxcblx0XHRcdFx0dG9wID0gZGF0YS5teVsgMSBdID09PSBcInRvcFwiLFxuXHRcdFx0XHRteU9mZnNldCA9IHRvcCA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdGRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDEgXSA9PT0gXCJ0b3BcIiA/XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0b2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsgMSBdLFxuXHRcdFx0XHRuZXdPdmVyVG9wLFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXHRcdFx0aWYgKCBvdmVyVG9wIDwgMCApIHtcblx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoICggcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCkgPiBvdmVyVG9wICYmICggbmV3T3ZlckJvdHRvbSA8IDAgfHwgbmV3T3ZlckJvdHRvbSA8IGFicyggb3ZlclRvcCApICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCApIHtcblx0XHRcdFx0bmV3T3ZlclRvcCA9IHBvc2l0aW9uLnRvcCAtICBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggKCBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0KSA+IG92ZXJCb3R0b20gJiYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fVxufTtcblxuLy8gZnJhY3Rpb24gc3VwcG9ydCB0ZXN0XG4oZnVuY3Rpb24gKCkge1xuXHR2YXIgdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LCB0ZXN0RWxlbWVudFN0eWxlLCBvZmZzZXRMZWZ0LCBpLFxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvL0NyZWF0ZSBhIFwiZmFrZSBib2R5XCIgZm9yIHRlc3RpbmcgYmFzZWQgb24gbWV0aG9kIHVzZWQgaW4galF1ZXJ5LnN1cHBvcnRcblx0dGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBib2R5ID8gXCJkaXZcIiA6IFwiYm9keVwiICk7XG5cdHRlc3RFbGVtZW50U3R5bGUgPSB7XG5cdFx0dmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0XHR3aWR0aDogMCxcblx0XHRoZWlnaHQ6IDAsXG5cdFx0Ym9yZGVyOiAwLFxuXHRcdG1hcmdpbjogMCxcblx0XHRiYWNrZ3JvdW5kOiBcIm5vbmVcIlxuXHR9O1xuXHRpZiAoIGJvZHkgKSB7XG5cdFx0JC5leHRlbmQoIHRlc3RFbGVtZW50U3R5bGUsIHtcblx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRsZWZ0OiBcIi0xMDAwcHhcIixcblx0XHRcdHRvcDogXCItMTAwMHB4XCJcblx0XHR9KTtcblx0fVxuXHRmb3IgKCBpIGluIHRlc3RFbGVtZW50U3R5bGUgKSB7XG5cdFx0dGVzdEVsZW1lbnQuc3R5bGVbIGkgXSA9IHRlc3RFbGVtZW50U3R5bGVbIGkgXTtcblx0fVxuXHR0ZXN0RWxlbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdHRlc3RFbGVtZW50UGFyZW50ID0gYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdHRlc3RFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZSggdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LmZpcnN0Q2hpbGQgKTtcblxuXHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAxMC43NDMyMjIycHg7XCI7XG5cblx0b2Zmc2V0TGVmdCA9ICQoIGRpdiApLm9mZnNldCgpLmxlZnQ7XG5cdCQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgPSBvZmZzZXRMZWZ0ID4gMTAgJiYgb2Zmc2V0TGVmdCA8IDExO1xuXG5cdHRlc3RFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG5cdHRlc3RFbGVtZW50UGFyZW50LnJlbW92ZUNoaWxkKCB0ZXN0RWxlbWVudCApO1xufSkoKTtcblxufSggalF1ZXJ5ICkgKTtcblxuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcInVpLnByb2dyZXNzYmFyXCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjNcIixcblx0b3B0aW9uczoge1xuXHRcdG1heDogMTAwLFxuXHRcdHZhbHVlOiAwLFxuXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdGNvbXBsZXRlOiBudWxsXG5cdH0sXG5cblx0bWluOiAwLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIENvbnN0cmFpbiBpbml0aWFsIHZhbHVlXG5cdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX2NvbnN0cmFpbmVkVmFsdWUoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHQvLyBPbmx5IHNldCBzdGF0aWMgdmFsdWVzLCBhcmlhLXZhbHVlbm93IGFuZCBhcmlhLXZhbHVlbWF4IGFyZVxuXHRcdFx0XHQvLyBzZXQgaW5zaWRlIF9yZWZyZXNoVmFsdWUoKVxuXHRcdFx0XHRyb2xlOiBcInByb2dyZXNzYmFyXCIsXG5cdFx0XHRcdFwiYXJpYS12YWx1ZW1pblwiOiB0aGlzLm1pblxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnZhbHVlRGl2ID0gJCggXCI8ZGl2IGNsYXNzPSd1aS1wcm9ncmVzc2Jhci12YWx1ZSB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1sZWZ0Jz48L2Rpdj5cIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtaW5cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbWF4XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW5vd1wiICk7XG5cblx0XHR0aGlzLnZhbHVlRGl2LnJlbW92ZSgpO1xuXHR9LFxuXG5cdHZhbHVlOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XG5cdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl9jb25zdHJhaW5lZFZhbHVlKCBuZXdWYWx1ZSApO1xuXHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHR9LFxuXG5cdF9jb25zdHJhaW5lZFZhbHVlOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XG5cdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbmRldGVybWluYXRlID0gbmV3VmFsdWUgPT09IGZhbHNlO1xuXG5cdFx0Ly8gc2FuaXRpemUgdmFsdWVcblx0XHRpZiAoIHR5cGVvZiBuZXdWYWx1ZSAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG5ld1ZhbHVlID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pbmRldGVybWluYXRlID8gZmFsc2UgOlxuXHRcdFx0TWF0aC5taW4oIHRoaXMub3B0aW9ucy5tYXgsIE1hdGgubWF4KCB0aGlzLm1pbiwgbmV3VmFsdWUgKSApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHQvLyBFbnN1cmUgXCJ2YWx1ZVwiIG9wdGlvbiBpcyBzZXQgYWZ0ZXIgb3RoZXIgdmFsdWVzIChsaWtlIG1heClcblx0XHR2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHRcdGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuXG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblxuXHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX2NvbnN0cmFpbmVkVmFsdWUoIHZhbHVlICk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwibWF4XCIgKSB7XG5cdFx0XHQvLyBEb24ndCBhbGxvdyBhIG1heCBsZXNzIHRoYW4gbWluXG5cdFx0XHR2YWx1ZSA9IE1hdGgubWF4KCB0aGlzLm1pbiwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9wZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pbmRldGVybWluYXRlID8gMTAwIDogMTAwICogKCB0aGlzLm9wdGlvbnMudmFsdWUgLSB0aGlzLm1pbiApIC8gKCB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5taW4gKTtcblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUsXG5cdFx0XHRwZXJjZW50YWdlID0gdGhpcy5fcGVyY2VudGFnZSgpO1xuXG5cdFx0dGhpcy52YWx1ZURpdlxuXHRcdFx0LnRvZ2dsZSggdGhpcy5pbmRldGVybWluYXRlIHx8IHZhbHVlID4gdGhpcy5taW4gKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLWNvcm5lci1yaWdodFwiLCB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zLm1heCApXG5cdFx0XHQud2lkdGgoIHBlcmNlbnRhZ2UudG9GaXhlZCgwKSArIFwiJVwiICk7XG5cblx0XHR0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoIFwidWktcHJvZ3Jlc3NiYXItaW5kZXRlcm1pbmF0ZVwiLCB0aGlzLmluZGV0ZXJtaW5hdGUgKTtcblxuXHRcdGlmICggdGhpcy5pbmRldGVybWluYXRlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW5vd1wiICk7XG5cdFx0XHRpZiAoICF0aGlzLm92ZXJsYXlEaXYgKSB7XG5cdFx0XHRcdHRoaXMub3ZlcmxheURpdiA9ICQoIFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItb3ZlcmxheSc+PC9kaXY+XCIgKS5hcHBlbmRUbyggdGhpcy52YWx1ZURpdiApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS12YWx1ZW1heFwiOiB0aGlzLm9wdGlvbnMubWF4LFxuXHRcdFx0XHRcImFyaWEtdmFsdWVub3dcIjogdmFsdWVcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCB0aGlzLm92ZXJsYXlEaXYgKSB7XG5cdFx0XHRcdHRoaXMub3ZlcmxheURpdi5yZW1vdmUoKTtcblx0XHRcdFx0dGhpcy5vdmVybGF5RGl2ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub2xkVmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiApO1xuXHRcdH1cblx0XHRpZiAoIHZhbHVlID09PSB0aGlzLm9wdGlvbnMubWF4ICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjb21wbGV0ZVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuLy8gbnVtYmVyIG9mIHBhZ2VzIGluIGEgc2xpZGVyXG4vLyAoaG93IG1hbnkgdGltZXMgY2FuIHlvdSBwYWdlIHVwL2Rvd24gdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgcmFuZ2UpXG52YXIgbnVtUGFnZXMgPSA1O1xuXG4kLndpZGdldCggXCJ1aS5zbGlkZXJcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJzbGlkZVwiLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRhbmltYXRlOiBmYWxzZSxcblx0XHRkaXN0YW5jZTogMCxcblx0XHRtYXg6IDEwMCxcblx0XHRtaW46IDAsXG5cdFx0b3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuXHRcdHJhbmdlOiBmYWxzZSxcblx0XHRzdGVwOiAxLFxuXHRcdHZhbHVlOiAwLFxuXHRcdHZhbHVlczogbnVsbCxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRzbGlkZTogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc2xpZGVyXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0XCIgK1xuXHRcdFx0XHRcIiB1aS13aWRnZXQtY29udGVudFwiICtcblx0XHRcdFx0XCIgdWktY29ybmVyLWFsbFwiKTtcblxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NyZWF0ZVJhbmdlKCk7XG5cdFx0dGhpcy5fY3JlYXRlSGFuZGxlcygpO1xuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X2NyZWF0ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpLCBoYW5kbGVDb3VudCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRleGlzdGluZ0hhbmRsZXMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktc2xpZGVyLWhhbmRsZVwiICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgKSxcblx0XHRcdGhhbmRsZSA9IFwiPGEgY2xhc3M9J3VpLXNsaWRlci1oYW5kbGUgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsJyBocmVmPScjJz48L2E+XCIsXG5cdFx0XHRoYW5kbGVzID0gW107XG5cblx0XHRoYW5kbGVDb3VudCA9ICggb3B0aW9ucy52YWx1ZXMgJiYgb3B0aW9ucy52YWx1ZXMubGVuZ3RoICkgfHwgMTtcblxuXHRcdGlmICggZXhpc3RpbmdIYW5kbGVzLmxlbmd0aCA+IGhhbmRsZUNvdW50ICkge1xuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzLnNsaWNlKCBoYW5kbGVDb3VudCApLnJlbW92ZSgpO1xuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLnNsaWNlKCAwLCBoYW5kbGVDb3VudCApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSBleGlzdGluZ0hhbmRsZXMubGVuZ3RoOyBpIDwgaGFuZGxlQ291bnQ7IGkrKyApIHtcblx0XHRcdGhhbmRsZXMucHVzaCggaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLmFkZCggJCggaGFuZGxlcy5qb2luKCBcIlwiICkgKS5hcHBlbmRUbyggdGhpcy5lbGVtZW50ICkgKTtcblxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5oYW5kbGVzLmVxKCAwICk7XG5cblx0XHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdCQoIHRoaXMgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiwgaSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jcmVhdGVSYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjbGFzc2VzID0gXCJcIjtcblxuXHRcdGlmICggb3B0aW9ucy5yYW5nZSApIHtcblx0XHRcdGlmICggb3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBbIHRoaXMuX3ZhbHVlTWluKCksIHRoaXMuX3ZhbHVlTWluKCkgXTtcblx0XHRcdFx0fSBlbHNlIGlmICggb3B0aW9ucy52YWx1ZXMubGVuZ3RoICYmIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRvcHRpb25zLnZhbHVlcyA9IFsgb3B0aW9ucy52YWx1ZXNbMF0sIG9wdGlvbnMudmFsdWVzWzBdIF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoICQuaXNBcnJheSggb3B0aW9ucy52YWx1ZXMgKSApIHtcblx0XHRcdFx0XHRvcHRpb25zLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzLnNsaWNlKDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXRoaXMucmFuZ2UgfHwgIXRoaXMucmFuZ2UubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlID0gJCggXCI8ZGl2PjwvZGl2PlwiIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0XHRcdGNsYXNzZXMgPSBcInVpLXNsaWRlci1yYW5nZVwiICtcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBpc24ndCB0aGUgbW9zdCBmaXR0aW5nbHkgc2VtYW50aWMgZnJhbWV3b3JrIGNsYXNzIGZvciB0aGlzIGVsZW1lbnQsXG5cdFx0XHRcdC8vIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcblx0XHRcdFx0XCIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnJlbW92ZUNsYXNzKCBcInVpLXNsaWRlci1yYW5nZS1taW4gdWktc2xpZGVyLXJhbmdlLW1heFwiIClcblx0XHRcdFx0XHQvLyBIYW5kbGUgcmFuZ2Ugc3dpdGNoaW5nIGZyb20gdHJ1ZSB0byBtaW4vbWF4XG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRcImxlZnRcIjogXCJcIixcblx0XHRcdFx0XHRcdFwiYm90dG9tXCI6IFwiXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYW5nZS5hZGRDbGFzcyggY2xhc3NlcyArXG5cdFx0XHRcdCggKCBvcHRpb25zLnJhbmdlID09PSBcIm1pblwiIHx8IG9wdGlvbnMucmFuZ2UgPT09IFwibWF4XCIgKSA/IFwiIHVpLXNsaWRlci1yYW5nZS1cIiArIG9wdGlvbnMucmFuZ2UgOiBcIlwiICkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5yYW5nZSA9ICQoW10pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50cyA9IHRoaXMuaGFuZGxlcy5hZGQoIHRoaXMucmFuZ2UgKS5maWx0ZXIoIFwiYVwiICk7XG5cdFx0dGhpcy5fb2ZmKCBlbGVtZW50cyApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50cywgdGhpcy5faGFuZGxlRXZlbnRzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCBlbGVtZW50cyApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggZWxlbWVudHMgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVzLnJlbW92ZSgpO1xuXHRcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXJcIiArXG5cdFx0XHRcdFwiIHVpLXNsaWRlci1ob3Jpem9udGFsXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItdmVydGljYWxcIiArXG5cdFx0XHRcdFwiIHVpLXdpZGdldFwiICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0LWNvbnRlbnRcIiArXG5cdFx0XHRcdFwiIHVpLWNvcm5lci1hbGxcIiApO1xuXG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBwb3NpdGlvbiwgbm9ybVZhbHVlLCBkaXN0YW5jZSwgY2xvc2VzdEhhbmRsZSwgaW5kZXgsIGFsbG93ZWQsIG9mZnNldCwgbW91c2VPdmVySGFuZGxlLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvLmRpc2FibGVkICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHRcdHRoaXMuZWxlbWVudE9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfTtcblx0XHRub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UoIHBvc2l0aW9uICk7XG5cdFx0ZGlzdGFuY2UgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSArIDE7XG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdGhpc0Rpc3RhbmNlID0gTWF0aC5hYnMoIG5vcm1WYWx1ZSAtIHRoYXQudmFsdWVzKGkpICk7XG5cdFx0XHRpZiAoKCBkaXN0YW5jZSA+IHRoaXNEaXN0YW5jZSApIHx8XG5cdFx0XHRcdCggZGlzdGFuY2UgPT09IHRoaXNEaXN0YW5jZSAmJlxuXHRcdFx0XHRcdChpID09PSB0aGF0Ll9sYXN0Q2hhbmdlZFZhbHVlIHx8IHRoYXQudmFsdWVzKGkpID09PSBvLm1pbiApKSkge1xuXHRcdFx0XHRkaXN0YW5jZSA9IHRoaXNEaXN0YW5jZTtcblx0XHRcdFx0Y2xvc2VzdEhhbmRsZSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YWxsb3dlZCA9IHRoaXMuX3N0YXJ0KCBldmVudCwgaW5kZXggKTtcblx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLl9tb3VzZVNsaWRpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBpbmRleDtcblxuXHRcdGNsb3Nlc3RIYW5kbGVcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHQuZm9jdXMoKTtcblxuXHRcdG9mZnNldCA9IGNsb3Nlc3RIYW5kbGUub2Zmc2V0KCk7XG5cdFx0bW91c2VPdmVySGFuZGxlID0gISQoIGV2ZW50LnRhcmdldCApLnBhcmVudHMoKS5hZGRCYWNrKCkuaXMoIFwiLnVpLXNsaWRlci1oYW5kbGVcIiApO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbW91c2VPdmVySGFuZGxlID8geyBsZWZ0OiAwLCB0b3A6IDAgfSA6IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQgLSAoIGNsb3Nlc3RIYW5kbGUud2lkdGgoKSAvIDIgKSxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSBvZmZzZXQudG9wIC1cblx0XHRcdFx0KCBjbG9zZXN0SGFuZGxlLmhlaWdodCgpIC8gMiApIC1cblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyhcImJvcmRlckJvdHRvbVdpZHRoXCIpLCAxMCApIHx8IDApICtcblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoXCJtYXJnaW5Ub3BcIiksIDEwICkgfHwgMClcblx0XHR9O1xuXG5cdFx0aWYgKCAhdGhpcy5oYW5kbGVzLmhhc0NsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKSApIHtcblx0XHRcdHRoaXMuX3NsaWRlKCBldmVudCwgaW5kZXgsIG5vcm1WYWx1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBwb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH0sXG5cdFx0XHRub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UoIHBvc2l0aW9uICk7XG5cblx0XHR0aGlzLl9zbGlkZSggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4LCBub3JtVmFsdWUgKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5oYW5kbGVzLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9zdG9wKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblx0XHR0aGlzLl9jaGFuZ2UoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCApO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbnVsbDtcblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X2RldGVjdE9yaWVudGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm9yaWVudGF0aW9uID0gKCB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG5cdH0sXG5cblx0X25vcm1WYWx1ZUZyb21Nb3VzZTogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHZhciBwaXhlbFRvdGFsLFxuXHRcdFx0cGl4ZWxNb3VzZSxcblx0XHRcdHBlcmNlbnRNb3VzZSxcblx0XHRcdHZhbHVlVG90YWwsXG5cdFx0XHR2YWx1ZU1vdXNlO1xuXG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLndpZHRoO1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnggLSB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtICggdGhpcy5fY2xpY2tPZmZzZXQgPyB0aGlzLl9jbGlja09mZnNldC5sZWZ0IDogMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS5oZWlnaHQ7XG5cdFx0XHRwaXhlbE1vdXNlID0gcG9zaXRpb24ueSAtIHRoaXMuZWxlbWVudE9mZnNldC50b3AgLSAoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQudG9wIDogMCApO1xuXHRcdH1cblxuXHRcdHBlcmNlbnRNb3VzZSA9ICggcGl4ZWxNb3VzZSAvIHBpeGVsVG90YWwgKTtcblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA+IDEgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxO1xuXHRcdH1cblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA8IDAgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAwO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdHBlcmNlbnRNb3VzZSA9IDEgLSBwZXJjZW50TW91c2U7XG5cdFx0fVxuXG5cdFx0dmFsdWVUb3RhbCA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdHZhbHVlTW91c2UgPSB0aGlzLl92YWx1ZU1pbigpICsgcGVyY2VudE1vdXNlICogdmFsdWVUb3RhbDtcblxuXHRcdHJldHVybiB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsdWVNb3VzZSApO1xuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCApIHtcblx0XHR2YXIgdWlIYXNoID0ge1xuXHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSgpXG5cdFx0fTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHR1aUhhc2gudmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdHJpZ2dlciggXCJzdGFydFwiLCBldmVudCwgdWlIYXNoICk7XG5cdH0sXG5cblx0X3NsaWRlOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4LCBuZXdWYWwgKSB7XG5cdFx0dmFyIG90aGVyVmFsLFxuXHRcdFx0bmV3VmFsdWVzLFxuXHRcdFx0YWxsb3dlZDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdG90aGVyVmFsID0gdGhpcy52YWx1ZXMoIGluZGV4ID8gMCA6IDEgKTtcblxuXHRcdFx0aWYgKCAoIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoID09PSAyICYmIHRoaXMub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApICYmXG5cdFx0XHRcdFx0KCAoIGluZGV4ID09PSAwICYmIG5ld1ZhbCA+IG90aGVyVmFsKSB8fCAoIGluZGV4ID09PSAxICYmIG5ld1ZhbCA8IG90aGVyVmFsICkgKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0bmV3VmFsID0gb3RoZXJWYWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmV3VmFsICE9PSB0aGlzLnZhbHVlcyggaW5kZXggKSApIHtcblx0XHRcdFx0bmV3VmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcblx0XHRcdFx0bmV3VmFsdWVzWyBpbmRleCBdID0gbmV3VmFsO1xuXHRcdFx0XHQvLyBBIHNsaWRlIGNhbiBiZSBjYW5jZWxlZCBieSByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGUgc2xpZGUgY2FsbGJhY2tcblx0XHRcdFx0YWxsb3dlZCA9IHRoaXMuX3RyaWdnZXIoIFwic2xpZGVcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdFx0XHR2YWx1ZTogbmV3VmFsLFxuXHRcdFx0XHRcdHZhbHVlczogbmV3VmFsdWVzXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0b3RoZXJWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggPyAwIDogMSApO1xuXHRcdFx0XHRpZiAoIGFsbG93ZWQgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzKCBpbmRleCwgbmV3VmFsLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBuZXdWYWwgIT09IHRoaXMudmFsdWUoKSApIHtcblx0XHRcdFx0Ly8gQSBzbGlkZSBjYW4gYmUgY2FuY2VsZWQgYnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIHNsaWRlIGNhbGxiYWNrXG5cdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl90cmlnZ2VyKCBcInNsaWRlXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRcdFx0dmFsdWU6IG5ld1ZhbFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggYWxsb3dlZCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSggbmV3VmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3N0b3A6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0dmFyIHVpSGFzaCA9IHtcblx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUoKVxuXHRcdH07XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0dWlIYXNoLnZhbHVlID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHR1aUhhc2gudmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQsIHVpSGFzaCApO1xuXHR9LFxuXG5cdF9jaGFuZ2U6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0aWYgKCAhdGhpcy5fa2V5U2xpZGluZyAmJiAhdGhpcy5fbW91c2VTbGlkaW5nICkge1xuXHRcdFx0dmFyIHVpSGFzaCA9IHtcblx0XHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlKClcblx0XHRcdH07XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHRcdHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0XHR1aUhhc2gudmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9zdG9yZSB0aGUgbGFzdCBjaGFuZ2VkIHZhbHVlIGluZGV4IGZvciByZWZlcmVuY2Ugd2hlbiBoYW5kbGVzIG92ZXJsYXBcblx0XHRcdHRoaXMuX2xhc3RDaGFuZ2VkVmFsdWUgPSBpbmRleDtcblxuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHVpSGFzaCApO1xuXHRcdH1cblx0fSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbHVlICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBuZXdWYWx1ZSApO1xuXHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIDAgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUoKTtcblx0fSxcblxuXHR2YWx1ZXM6IGZ1bmN0aW9uKCBpbmRleCwgbmV3VmFsdWUgKSB7XG5cdFx0dmFyIHZhbHMsXG5cdFx0XHRuZXdWYWx1ZXMsXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXNbIGluZGV4IF0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWUgKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpbmRleCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggJC5pc0FycmF5KCBhcmd1bWVudHNbIDAgXSApICkge1xuXHRcdFx0XHR2YWxzID0gdGhpcy5vcHRpb25zLnZhbHVlcztcblx0XHRcdFx0bmV3VmFsdWVzID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHR2YWxzWyBpIF0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWVzWyBpIF0gKTtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVzKCBpbmRleCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnZhbHVlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcygpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSxcblx0XHRcdHZhbHNMZW5ndGggPSAwO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwicmFuZ2VcIiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBcIm1pblwiICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl92YWx1ZXMoIDAgKTtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlcyA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gXCJtYXhcIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKCB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aC0xICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggJC5pc0FycmF5KCB0aGlzLm9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHR2YWxzTGVuZ3RoID0gdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0c3dpdGNoICgga2V5ICkge1xuXHRcdFx0Y2FzZSBcIm9yaWVudGF0aW9uXCI6XG5cdFx0XHRcdHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XG5cdFx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXItaG9yaXpvbnRhbCB1aS1zbGlkZXItdmVydGljYWxcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXNsaWRlci1cIiArIHRoaXMub3JpZW50YXRpb24gKTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZhbHVlXCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCAwICk7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidmFsdWVzXCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2YWxzTGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJtaW5cIjpcblx0XHRcdGNhc2UgXCJtYXhcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJhbmdlXCI6XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdC8vaW50ZXJuYWwgdmFsdWUgZ2V0dGVyXG5cdC8vIF92YWx1ZSgpIHJldHVybnMgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZTtcblx0XHR2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsICk7XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9LFxuXG5cdC8vaW50ZXJuYWwgdmFsdWVzIGdldHRlclxuXHQvLyBfdmFsdWVzKCkgcmV0dXJucyBhcnJheSBvZiB2YWx1ZXMgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdC8vIF92YWx1ZXMoIGluZGV4ICkgcmV0dXJucyBzaW5nbGUgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdF92YWx1ZXM6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgdmFsLFxuXHRcdFx0dmFscyxcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdO1xuXHRcdFx0dmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHQvLyAuc2xpY2UoKSBjcmVhdGVzIGEgY29weSBvZiB0aGUgYXJyYXlcblx0XHRcdC8vIHRoaXMgY29weSBnZXRzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXggYW5kIHRoZW4gcmV0dXJuZWRcblx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzLnNsaWNlKCk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKz0gMSkge1xuXHRcdFx0XHR2YWxzWyBpIF0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsc1sgaSBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWxzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHJldHVybnMgdGhlIHN0ZXAtYWxpZ25lZCB2YWx1ZSB0aGF0IHZhbCBpcyBjbG9zZXN0IHRvLCBiZXR3ZWVuIChpbmNsdXNpdmUpIG1pbiBhbmQgbWF4XG5cdF90cmltQWxpZ25WYWx1ZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHZhbCA8PSB0aGlzLl92YWx1ZU1pbigpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0fVxuXHRcdGlmICggdmFsID49IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHR9XG5cdFx0dmFyIHN0ZXAgPSAoIHRoaXMub3B0aW9ucy5zdGVwID4gMCApID8gdGhpcy5vcHRpb25zLnN0ZXAgOiAxLFxuXHRcdFx0dmFsTW9kU3RlcCA9ICh2YWwgLSB0aGlzLl92YWx1ZU1pbigpKSAlIHN0ZXAsXG5cdFx0XHRhbGlnblZhbHVlID0gdmFsIC0gdmFsTW9kU3RlcDtcblxuXHRcdGlmICggTWF0aC5hYnModmFsTW9kU3RlcCkgKiAyID49IHN0ZXAgKSB7XG5cdFx0XHRhbGlnblZhbHVlICs9ICggdmFsTW9kU3RlcCA+IDAgKSA/IHN0ZXAgOiAoIC1zdGVwICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luY2UgSmF2YVNjcmlwdCBoYXMgcHJvYmxlbXMgd2l0aCBsYXJnZSBmbG9hdHMsIHJvdW5kXG5cdFx0Ly8gdGhlIGZpbmFsIHZhbHVlIHRvIDUgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IChzZWUgIzQxMjQpXG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoIGFsaWduVmFsdWUudG9GaXhlZCg1KSApO1xuXHR9LFxuXG5cdF92YWx1ZU1pbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW47XG5cdH0sXG5cblx0X3ZhbHVlTWF4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heDtcblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdFZhbFBlcmNlbnQsIHZhbFBlcmNlbnQsIHZhbHVlLCB2YWx1ZU1pbiwgdmFsdWVNYXgsXG5cdFx0XHRvUmFuZ2UgPSB0aGlzLm9wdGlvbnMucmFuZ2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRhbmltYXRlID0gKCAhdGhpcy5fYW5pbWF0ZU9mZiApID8gby5hbmltYXRlIDogZmFsc2UsXG5cdFx0XHRfc2V0ID0ge307XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFsUGVyY2VudCA9ICggdGhhdC52YWx1ZXMoaSkgLSB0aGF0Ll92YWx1ZU1pbigpICkgLyAoIHRoYXQuX3ZhbHVlTWF4KCkgLSB0aGF0Ll92YWx1ZU1pbigpICkgKiAxMDA7XG5cdFx0XHRcdF9zZXRbIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIF0gPSB2YWxQZXJjZW50ICsgXCIlXCI7XG5cdFx0XHRcdCQoIHRoaXMgKS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggX3NldCwgby5hbmltYXRlICk7XG5cdFx0XHRcdGlmICggdGhhdC5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0XHRcdGlmICggdGhhdC5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgbGVmdDogdmFsUGVyY2VudCArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6ICggdmFsUGVyY2VudCAtIGxhc3RWYWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBib3R0b206ICggdmFsUGVyY2VudCApICsgXCIlXCIgfSwgby5hbmltYXRlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2VbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBoZWlnaHQ6ICggdmFsUGVyY2VudCAtIGxhc3RWYWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RWYWxQZXJjZW50ID0gdmFsUGVyY2VudDtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWUoKTtcblx0XHRcdHZhbHVlTWluID0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHRcdHZhbHVlTWF4ID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdHZhbFBlcmNlbnQgPSAoIHZhbHVlTWF4ICE9PSB2YWx1ZU1pbiApID9cblx0XHRcdFx0XHQoIHZhbHVlIC0gdmFsdWVNaW4gKSAvICggdmFsdWVNYXggLSB2YWx1ZU1pbiApICogMTAwIDpcblx0XHRcdFx0XHQwO1xuXHRcdFx0X3NldFsgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIgXSA9IHZhbFBlcmNlbnQgKyBcIiVcIjtcblx0XHRcdHRoaXMuaGFuZGxlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCBfc2V0LCBvLmFuaW1hdGUgKTtcblxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgd2lkdGg6ICggMTAwIC0gdmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGhlaWdodDogdmFsUGVyY2VudCArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgaGVpZ2h0OiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIHsgcXVldWU6IGZhbHNlLCBkdXJhdGlvbjogby5hbmltYXRlIH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUV2ZW50czoge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6MjUqL1xuXHRcdFx0dmFyIGFsbG93ZWQsIGN1clZhbCwgbmV3VmFsLCBzdGVwLFxuXHRcdFx0XHRpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRpZiAoICF0aGlzLl9rZXlTbGlkaW5nICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHRcdFx0YWxsb3dlZCA9IHRoaXMuX3N0YXJ0KCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0XHRcdGlmICggYWxsb3dlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcDtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdFx0Y3VyVmFsID0gbmV3VmFsID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCArICggKHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpKSAvIG51bVBhZ2VzICkgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgLSAoICh0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSkgLyBudW1QYWdlcyApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdFx0XHRpZiAoIGN1clZhbCA9PT0gdGhpcy5fdmFsdWVNYXgoKSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCArIHN0ZXAgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdFx0XHRpZiAoIGN1clZhbCA9PT0gdGhpcy5fdmFsdWVNaW4oKSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCAtIHN0ZXAgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCBpbmRleCwgbmV3VmFsICk7XG5cdFx0fSxcblx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9LFxuXHRcdGtleXVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgaW5kZXggPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiApO1xuXG5cdFx0XHRpZiAoIHRoaXMuX2tleVNsaWRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuX2tleVNsaWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fc3RvcCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG59KGpRdWVyeSkpO1xuXG4oZnVuY3Rpb24oICQgKSB7XG5cbmZ1bmN0aW9uIG1vZGlmaWVyKCBmbiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmV2aW91cyA9IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHRmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdGlmICggcHJldmlvdXMgIT09IHRoaXMuZWxlbWVudC52YWwoKSApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHR9XG5cdH07XG59XG5cbiQud2lkZ2V0KCBcInVpLnNwaW5uZXJcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8aW5wdXQ+XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNwaW5cIixcblx0b3B0aW9uczoge1xuXHRcdGN1bHR1cmU6IG51bGwsXG5cdFx0aWNvbnM6IHtcblx0XHRcdGRvd246IFwidWktaWNvbi10cmlhbmdsZS0xLXNcIixcblx0XHRcdHVwOiBcInVpLWljb24tdHJpYW5nbGUtMS1uXCJcblx0XHR9LFxuXHRcdGluY3JlbWVudGFsOiB0cnVlLFxuXHRcdG1heDogbnVsbCxcblx0XHRtaW46IG51bGwsXG5cdFx0bnVtYmVyRm9ybWF0OiBudWxsLFxuXHRcdHBhZ2U6IDEwLFxuXHRcdHN0ZXA6IDEsXG5cblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0c3BpbjogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaGFuZGxlIHN0cmluZyB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHBhcnNlZFxuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtYXhcIiwgdGhpcy5vcHRpb25zLm1heCApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtaW5cIiwgdGhpcy5vcHRpb25zLm1pbiApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJzdGVwXCIsIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cblx0XHQvLyBmb3JtYXQgdGhlIHZhbHVlLCBidXQgZG9uJ3QgY29uc3RyYWluXG5cdFx0dGhpcy5fdmFsdWUoIHRoaXMuZWxlbWVudC52YWwoKSwgdHJ1ZSApO1xuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHRcdHRoaXMuX29uKCB0aGlzLl9ldmVudHMgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHQvLyB0dXJuaW5nIG9mZiBhdXRvY29tcGxldGUgcHJldmVudHMgdGhlIGJyb3dzZXIgZnJvbSByZW1lbWJlcmluZyB0aGVcblx0XHQvLyB2YWx1ZSB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBoaXN0b3J5LCBzbyB3ZSByZS1lbmFibGUgYXV0b2NvbXBsZXRlXG5cdFx0Ly8gaWYgdGhlIHBhZ2UgaXMgdW5sb2FkZWQgYmVmb3JlIHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLiAjNzc5MFxuXHRcdHRoaXMuX29uKCB0aGlzLndpbmRvdywge1xuXHRcdFx0YmVmb3JldW5sb2FkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB7fSxcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cblx0XHQkLmVhY2goIFsgXCJtaW5cIiwgXCJtYXhcIiwgXCJzdGVwXCIgXSwgZnVuY3Rpb24oIGksIG9wdGlvbiApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGVsZW1lbnQuYXR0ciggb3B0aW9uICk7XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRvcHRpb25zWyBvcHRpb24gXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgJiYgdGhpcy5fa2V5ZG93biggZXZlbnQgKSApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGtleXVwOiBcIl9zdG9wXCIsXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHR9LFxuXHRcdGJsdXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggdGhpcy5jYW5jZWxCbHVyICkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0b3AoKTtcblx0XHRcdHRoaXMuX3JlZnJlc2goKTtcblx0XHRcdGlmICggdGhpcy5wcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpICkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW91c2V3aGVlbDogZnVuY3Rpb24oIGV2ZW50LCBkZWx0YSApIHtcblx0XHRcdGlmICggIWRlbHRhICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICYmICF0aGlzLl9zdGFydCggZXZlbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zcGluKCAoZGVsdGEgPiAwID8gMSA6IC0xKSAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCApO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLm1vdXNld2hlZWxUaW1lciApO1xuXHRcdFx0dGhpcy5tb3VzZXdoZWVsVGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNwaW5uaW5nICkge1xuXHRcdFx0XHRcdHRoaXMuX3N0b3AoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDEwMCApO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9LFxuXHRcdFwibW91c2Vkb3duIC51aS1zcGlubmVyLWJ1dHRvblwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcHJldmlvdXM7XG5cblx0XHRcdC8vIFdlIG5ldmVyIHdhbnQgdGhlIGJ1dHRvbnMgdG8gaGF2ZSBmb2N1czsgd2hlbmV2ZXIgdGhlIHVzZXIgaXNcblx0XHRcdC8vIGludGVyYWN0aW5nIHdpdGggdGhlIHNwaW5uZXIsIHRoZSBmb2N1cyBzaG91bGQgYmUgb24gdGhlIGlucHV0LlxuXHRcdFx0Ly8gSWYgdGhlIGlucHV0IGlzIGZvY3VzZWQgdGhlbiB0aGlzLnByZXZpb3VzIGlzIHByb3Blcmx5IHNldCBmcm9tXG5cdFx0XHQvLyB3aGVuIHRoZSBpbnB1dCBmaXJzdCByZWNlaXZlZCBmb2N1cy4gSWYgdGhlIGlucHV0IGlzIG5vdCBmb2N1c2VkXG5cdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoaXMucHJldmlvdXMgYmFzZWQgb24gdGhlIHZhbHVlIGJlZm9yZSBzcGlubmluZy5cblx0XHRcdHByZXZpb3VzID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgP1xuXHRcdFx0XHR0aGlzLnByZXZpb3VzIDogdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdFx0ZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcblx0XHRcdFx0dmFyIGlzQWN0aXZlID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XG5cdFx0XHRcdGlmICggIWlzQWN0aXZlICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBJRVxuXHRcdFx0XHRcdC8vIElFIHNldHMgZm9jdXMgYXN5bmNocm9ub3VzbHksIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgZm9jdXNcblx0XHRcdFx0XHQvLyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0IGJlY2F1c2UgdGhlIHVzZXIgY2xpY2tlZCBvbiB0aGUgYnV0dG9uLlxuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBmb2N1cyBpcyBvbiAob3Igc3RheXMgb24pIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2hlY2tGb2N1cy5jYWxsKCB0aGlzICk7XG5cblx0XHRcdC8vIHN1cHBvcnQ6IElFXG5cdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHQvLyBzbyB3ZSBzZXQgYSBmbGFnIHRvIGtub3cgd2hlbiB3ZSBzaG91bGQgaWdub3JlIHRoZSBibHVyIGV2ZW50XG5cdFx0XHQvLyBhbmQgY2hlY2sgKGFnYWluKSBpZiBmb2N1cyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0LlxuXHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRjaGVja0ZvY3VzLmNhbGwoIHRoaXMgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIHRoaXMuX3N0YXJ0KCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXHRcdFwibW91c2V1cCAudWktc3Bpbm5lci1idXR0b25cIjogXCJfc3RvcFwiLFxuXHRcdFwibW91c2VlbnRlciAudWktc3Bpbm5lci1idXR0b25cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Ly8gYnV0dG9uIHdpbGwgYWRkIHVpLXN0YXRlLWFjdGl2ZSBpZiBtb3VzZSB3YXMgZG93biB3aGlsZSBtb3VzZWxlYXZlIGFuZCBrZXB0IGRvd25cblx0XHRcdGlmICggISQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXHRcdC8vIFRPRE86IGRvIHdlIHJlYWxseSB3YW50IHRvIGNvbnNpZGVyIHRoaXMgYSBzdG9wP1xuXHRcdC8vIHNob3VsZG4ndCB3ZSBqdXN0IHN0b3AgdGhlIHJlcGVhdGVyIGFuZCB3YWl0IHVudGlsIG1vdXNldXAgYmVmb3JlXG5cdFx0Ly8gd2UgdHJpZ2dlciB0aGUgc3RvcCBldmVudD9cblx0XHRcIm1vdXNlbGVhdmUgLnVpLXNwaW5uZXItYnV0dG9uXCI6IFwiX3N0b3BcIlxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWlTcGlubmVyID0gdGhpcy51aVNwaW5uZXIgPSB0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zcGlubmVyLWlucHV0XCIgKVxuXHRcdFx0LmF0dHIoIFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIgKVxuXHRcdFx0LndyYXAoIHRoaXMuX3VpU3Bpbm5lckh0bWwoKSApXG5cdFx0XHQucGFyZW50KClcblx0XHRcdFx0Ly8gYWRkIGJ1dHRvbnNcblx0XHRcdFx0LmFwcGVuZCggdGhpcy5fYnV0dG9uSHRtbCgpICk7XG5cblx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiICk7XG5cblx0XHQvLyBidXR0b24gYmluZGluZ3Ncblx0XHR0aGlzLmJ1dHRvbnMgPSB1aVNwaW5uZXIuZmluZCggXCIudWktc3Bpbm5lci1idXR0b25cIiApXG5cdFx0XHQuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApXG5cdFx0XHQuYnV0dG9uKClcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItYWxsXCIgKTtcblxuXHRcdC8vIElFIDYgZG9lc24ndCB1bmRlcnN0YW5kIGhlaWdodDogNTAlIGZvciB0aGUgYnV0dG9uc1xuXHRcdC8vIHVubGVzcyB0aGUgd3JhcHBlciBoYXMgYW4gZXhwbGljaXQgaGVpZ2h0XG5cdFx0aWYgKCB0aGlzLmJ1dHRvbnMuaGVpZ2h0KCkgPiBNYXRoLmNlaWwoIHVpU3Bpbm5lci5oZWlnaHQoKSAqIDAuNSApICYmXG5cdFx0XHRcdHVpU3Bpbm5lci5oZWlnaHQoKSA+IDAgKSB7XG5cdFx0XHR1aVNwaW5uZXIuaGVpZ2h0KCB1aVNwaW5uZXIuaGVpZ2h0KCkgKTtcblx0XHR9XG5cblx0XHQvLyBkaXNhYmxlIHNwaW5uZXIgaWYgZWxlbWVudCB3YXMgYWxyZWFkeSBkaXNhYmxlZFxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIDEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLTEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgb3B0aW9ucy5wYWdlLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLW9wdGlvbnMucGFnZSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfdWlTcGlubmVySHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiPHNwYW4gY2xhc3M9J3VpLXNwaW5uZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPjwvc3Bhbj5cIjtcblx0fSxcblxuXHRfYnV0dG9uSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiXCIgK1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci11cCB1aS1jb3JuZXItdHInPlwiICtcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcIiArIHRoaXMub3B0aW9ucy5pY29ucy51cCArIFwiJz4mIzk2NTA7PC9zcGFuPlwiICtcblx0XHRcdFwiPC9hPlwiICtcblx0XHRcdFwiPGEgY2xhc3M9J3VpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItZG93biB1aS1jb3JuZXItYnInPlwiICtcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcIiArIHRoaXMub3B0aW9ucy5pY29ucy5kb3duICsgXCInPiYjOTY2MDs8L3NwYW4+XCIgK1xuXHRcdFx0XCI8L2E+XCI7XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5zcGlubmluZyAmJiB0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuY291bnRlciApIHtcblx0XHRcdHRoaXMuY291bnRlciA9IDE7XG5cdFx0fVxuXHRcdHRoaXMuc3Bpbm5pbmcgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9yZXBlYXQ6IGZ1bmN0aW9uKCBpLCBzdGVwcywgZXZlbnQgKSB7XG5cdFx0aSA9IGkgfHwgNTAwO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fcmVwZWF0KCA0MCwgc3RlcHMsIGV2ZW50ICk7XG5cdFx0fSwgaSApO1xuXG5cdFx0dGhpcy5fc3Bpbiggc3RlcHMgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQgKTtcblx0fSxcblxuXHRfc3BpbjogZnVuY3Rpb24oIHN0ZXAsIGV2ZW50ICkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKSB8fCAwO1xuXG5cdFx0aWYgKCAhdGhpcy5jb3VudGVyICkge1xuXHRcdFx0dGhpcy5jb3VudGVyID0gMTtcblx0XHR9XG5cblx0XHR2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKCB2YWx1ZSArIHN0ZXAgKiB0aGlzLl9pbmNyZW1lbnQoIHRoaXMuY291bnRlciApICk7XG5cblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nIHx8IHRoaXMuX3RyaWdnZXIoIFwic3BpblwiLCBldmVudCwgeyB2YWx1ZTogdmFsdWUgfSApICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5fdmFsdWUoIHZhbHVlICk7XG5cdFx0XHR0aGlzLmNvdW50ZXIrKztcblx0XHR9XG5cdH0sXG5cblx0X2luY3JlbWVudDogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGluY3JlbWVudGFsID0gdGhpcy5vcHRpb25zLmluY3JlbWVudGFsO1xuXG5cdFx0aWYgKCBpbmNyZW1lbnRhbCApIHtcblx0XHRcdHJldHVybiAkLmlzRnVuY3Rpb24oIGluY3JlbWVudGFsICkgP1xuXHRcdFx0XHRpbmNyZW1lbnRhbCggaSApIDpcblx0XHRcdFx0TWF0aC5mbG9vciggaSppKmkvNTAwMDAgLSBpKmkvNTAwICsgMTcqaS8yMDAgKyAxICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0X3ByZWNpc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCApIHtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KCBwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMubWluICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWNpc2lvbjtcblx0fSxcblxuXHRfcHJlY2lzaW9uT2Y6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxuXHRcdFx0ZGVjaW1hbCA9IHN0ci5pbmRleE9mKCBcIi5cIiApO1xuXHRcdHJldHVybiBkZWNpbWFsID09PSAtMSA/IDAgOiBzdHIubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG5cdH0sXG5cblx0X2FkanVzdFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGJhc2UsIGFib3ZlTWluLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIG1ha2Ugc3VyZSB3ZSdyZSBhdCBhIHZhbGlkIHN0ZXBcblx0XHQvLyAtIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSByZWxhdGl2ZSB0byB0aGUgYmFzZSAobWluIG9yIDApXG5cdFx0YmFzZSA9IG9wdGlvbnMubWluICE9PSBudWxsID8gb3B0aW9ucy5taW4gOiAwO1xuXHRcdGFib3ZlTWluID0gdmFsdWUgLSBiYXNlO1xuXHRcdC8vIC0gcm91bmQgdG8gdGhlIG5lYXJlc3Qgc3RlcFxuXHRcdGFib3ZlTWluID0gTWF0aC5yb3VuZChhYm92ZU1pbiAvIG9wdGlvbnMuc3RlcCkgKiBvcHRpb25zLnN0ZXA7XG5cdFx0Ly8gLSByb3VuZGluZyBpcyBiYXNlZCBvbiAwLCBzbyBhZGp1c3QgYmFjayB0byBvdXIgYmFzZVxuXHRcdHZhbHVlID0gYmFzZSArIGFib3ZlTWluO1xuXG5cdFx0Ly8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXG5cdFx0dmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZS50b0ZpeGVkKCB0aGlzLl9wcmVjaXNpb24oKSApICk7XG5cblx0XHQvLyBjbGFtcCB0aGUgdmFsdWVcblx0XHRpZiAoIG9wdGlvbnMubWF4ICE9PSBudWxsICYmIHZhbHVlID4gb3B0aW9ucy5tYXgpIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IG9wdGlvbnMubWluICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblxuXHRfc3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLm1vdXNld2hlZWxUaW1lciApO1xuXHRcdHRoaXMuY291bnRlciA9IDA7XG5cdFx0dGhpcy5zcGlubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImN1bHR1cmVcIiB8fCBrZXkgPT09IFwibnVtYmVyRm9ybWF0XCIgKSB7XG5cdFx0XHR2YXIgcHJldlZhbHVlID0gdGhpcy5fcGFyc2UoIHRoaXMuZWxlbWVudC52YWwoKSApO1xuXHRcdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5lbGVtZW50LnZhbCggdGhpcy5fZm9ybWF0KCBwcmV2VmFsdWUgKSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcIm1heFwiIHx8IGtleSA9PT0gXCJtaW5cIiB8fCBrZXkgPT09IFwic3RlcFwiICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fcGFyc2UoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImljb25zXCIgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbnMuZmlyc3QoKS5maW5kKCBcIi51aS1pY29uXCIgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRoaXMub3B0aW9ucy5pY29ucy51cCApXG5cdFx0XHRcdC5hZGRDbGFzcyggdmFsdWUudXAgKTtcblx0XHRcdHRoaXMuYnV0dG9ucy5sYXN0KCkuZmluZCggXCIudWktaWNvblwiIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuaWNvbnMuZG93biApXG5cdFx0XHRcdC5hZGRDbGFzcyggdmFsdWUuZG93biApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLmJ1dHRvbnMuYnV0dG9uKCBcImRpc2FibGVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0XHRcdFx0dGhpcy5idXR0b25zLmJ1dHRvbiggXCJlbmFibGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogbW9kaWZpZXIoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl92YWx1ZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdH0pLFxuXG5cdF9wYXJzZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRpZiAoIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgdmFsICE9PSBcIlwiICkge1xuXHRcdFx0dmFsID0gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID9cblx0XHRcdFx0R2xvYmFsaXplLnBhcnNlRmxvYXQoIHZhbCwgMTAsIHRoaXMub3B0aW9ucy5jdWx0dXJlICkgOiArdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsID09PSBcIlwiIHx8IGlzTmFOKCB2YWwgKSA/IG51bGwgOiB2YWw7XG5cdH0sXG5cblx0X2Zvcm1hdDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/XG5cdFx0XHRHbG9iYWxpemUuZm9ybWF0KCB2YWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCwgdGhpcy5vcHRpb25zLmN1bHR1cmUgKSA6XG5cdFx0XHR2YWx1ZTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoe1xuXHRcdFx0XCJhcmlhLXZhbHVlbWluXCI6IHRoaXMub3B0aW9ucy5taW4sXG5cdFx0XHRcImFyaWEtdmFsdWVtYXhcIjogdGhpcy5vcHRpb25zLm1heCxcblx0XHRcdC8vIFRPRE86IHdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdmFsdWVzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkP1xuXHRcdFx0XCJhcmlhLXZhbHVlbm93XCI6IHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8vIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aG91dCB0cmlnZ2VyaW5nIGNoYW5nZVxuXHRfdmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSwgYWxsb3dBbnkgKSB7XG5cdFx0dmFyIHBhcnNlZDtcblx0XHRpZiAoIHZhbHVlICE9PSBcIlwiICkge1xuXHRcdFx0cGFyc2VkID0gdGhpcy5fcGFyc2UoIHZhbHVlICk7XG5cdFx0XHRpZiAoIHBhcnNlZCAhPT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dBbnkgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gdGhpcy5fYWRqdXN0VmFsdWUoIHBhcnNlZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZm9ybWF0KCBwYXJzZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5lbGVtZW50LnZhbCggdmFsdWUgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXNwaW5uZXItaW5wdXRcIiApXG5cdFx0XHQucHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW1pblwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtYXhcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbm93XCIgKTtcblx0XHR0aGlzLnVpU3Bpbm5lci5yZXBsYWNlV2l0aCggdGhpcy5lbGVtZW50ICk7XG5cdH0sXG5cblx0c3RlcFVwOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCBzdGVwcyApO1xuXHR9KSxcblx0X3N0ZXBVcDogZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdGlmICggdGhpcy5fc3RhcnQoKSApIHtcblx0XHRcdHRoaXMuX3NwaW4oIChzdGVwcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cdFx0XHR0aGlzLl9zdG9wKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0ZXBEb3duOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcERvd24oIHN0ZXBzICk7XG5cdH0pLFxuXHRfc3RlcERvd246IGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHRpZiAoIHRoaXMuX3N0YXJ0KCkgKSB7XG5cdFx0XHR0aGlzLl9zcGluKCAoc3RlcHMgfHwgMSkgKiAtdGhpcy5vcHRpb25zLnN0ZXAgKTtcblx0XHRcdHRoaXMuX3N0b3AoKTtcblx0XHR9XG5cdH0sXG5cblx0cGFnZVVwOiBtb2RpZmllcihmdW5jdGlvbiggcGFnZXMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCAocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSApO1xuXHR9KSxcblxuXHRwYWdlRG93bjogbW9kaWZpZXIoZnVuY3Rpb24oIHBhZ2VzICkge1xuXHRcdHRoaXMuX3N0ZXBEb3duKCAocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSApO1xuXHR9KSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbCApIHtcblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKTtcblx0XHR9XG5cdFx0bW9kaWZpZXIoIHRoaXMuX3ZhbHVlICkuY2FsbCggdGhpcywgbmV3VmFsICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aVNwaW5uZXI7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHRhYklkID0gMCxcblx0cmhhc2ggPSAvIy4qJC87XG5cbmZ1bmN0aW9uIGdldE5leHRUYWJJZCgpIHtcblx0cmV0dXJuICsrdGFiSWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwoIGFuY2hvciApIHtcblx0cmV0dXJuIGFuY2hvci5oYXNoLmxlbmd0aCA+IDEgJiZcblx0XHRkZWNvZGVVUklDb21wb25lbnQoIGFuY2hvci5ocmVmLnJlcGxhY2UoIHJoYXNoLCBcIlwiICkgKSA9PT1cblx0XHRcdGRlY29kZVVSSUNvbXBvbmVudCggbG9jYXRpb24uaHJlZi5yZXBsYWNlKCByaGFzaCwgXCJcIiApICk7XG59XG5cbiQud2lkZ2V0KCBcInVpLnRhYnNcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHRkZWxheTogMzAwLFxuXHRvcHRpb25zOiB7XG5cdFx0YWN0aXZlOiBudWxsLFxuXHRcdGNvbGxhcHNpYmxlOiBmYWxzZSxcblx0XHRldmVudDogXCJjbGlja1wiLFxuXHRcdGhlaWdodFN0eWxlOiBcImNvbnRlbnRcIixcblx0XHRoaWRlOiBudWxsLFxuXHRcdHNob3c6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVBY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVMb2FkOiBudWxsLFxuXHRcdGxvYWQ6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLXRhYnMtY29sbGFwc2libGVcIiwgb3B0aW9ucy5jb2xsYXBzaWJsZSApXG5cdFx0XHQvLyBQcmV2ZW50IHVzZXJzIGZyb20gZm9jdXNpbmcgZGlzYWJsZWQgdGFicyB2aWEgY2xpY2tcblx0XHRcdC5kZWxlZ2F0ZSggXCIudWktdGFicy1uYXYgPiBsaVwiLCBcIm1vdXNlZG93blwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyBzdXBwb3J0OiBJRSA8OVxuXHRcdFx0Ly8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBhY3Rpb24gaW4gbW91c2Vkb3duIGRvZXNuJ3QgcHJldmVudCBJRVxuXHRcdFx0Ly8gZnJvbSBmb2N1c2luZyB0aGUgZWxlbWVudCwgc28gaWYgdGhlIGFuY2hvciBnZXRzIGZvY3VzZWQsIGJsdXIuXG5cdFx0XHQvLyBXZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IGZvY3VzaW5nIHRoZSBwcmV2aW91c2x5IGZvY3VzZWRcblx0XHRcdC8vIGVsZW1lbnQgc2luY2UgY2xpY2tpbmcgb24gYSBub24tZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGZvY3VzXG5cdFx0XHQvLyB0aGUgYm9keSBhbnl3YXkuXG5cdFx0XHQuZGVsZWdhdGUoIFwiLnVpLXRhYnMtYW5jaG9yXCIsIFwiZm9jdXNcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5jbG9zZXN0KCBcImxpXCIgKS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuX3Byb2Nlc3NUYWJzKCk7XG5cdFx0b3B0aW9ucy5hY3RpdmUgPSB0aGlzLl9pbml0aWFsQWN0aXZlKCk7XG5cblx0XHQvLyBUYWtlIGRpc2FibGluZyB0YWJzIHZpYSBjbGFzcyBhdHRyaWJ1dGUgZnJvbSBIVE1MXG5cdFx0Ly8gaW50byBhY2NvdW50IGFuZCB1cGRhdGUgb3B0aW9uIHByb3Blcmx5LlxuXHRcdGlmICggJC5pc0FycmF5KCBvcHRpb25zLmRpc2FibGVkICkgKSB7XG5cdFx0XHRvcHRpb25zLmRpc2FibGVkID0gJC51bmlxdWUoIG9wdGlvbnMuZGlzYWJsZWQuY29uY2F0KFxuXHRcdFx0XHQkLm1hcCggdGhpcy50YWJzLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLCBmdW5jdGlvbiggbGkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXQudGFicy5pbmRleCggbGkgKTtcblx0XHRcdFx0fSlcblx0XHRcdCkgKS5zb3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgZm9yIGxlbmd0aCBhdm9pZHMgZXJyb3Igd2hlbiBpbml0aWFsaXppbmcgZW1wdHkgbGlzdFxuXHRcdGlmICggdGhpcy5vcHRpb25zLmFjdGl2ZSAhPT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggb3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXG5cdFx0aWYgKCB0aGlzLmFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmxvYWQoIG9wdGlvbnMuYWN0aXZlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0aWFsQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYWN0aXZlID0gdGhpcy5vcHRpb25zLmFjdGl2ZSxcblx0XHRcdGNvbGxhcHNpYmxlID0gdGhpcy5vcHRpb25zLmNvbGxhcHNpYmxlLFxuXHRcdFx0bG9jYXRpb25IYXNoID0gbG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoIDEgKTtcblxuXHRcdGlmICggYWN0aXZlID09PSBudWxsICkge1xuXHRcdFx0Ly8gY2hlY2sgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaW4gdGhlIFVSTFxuXHRcdFx0aWYgKCBsb2NhdGlvbkhhc2ggKSB7XG5cdFx0XHRcdHRoaXMudGFicy5lYWNoKGZ1bmN0aW9uKCBpLCB0YWIgKSB7XG5cdFx0XHRcdFx0aWYgKCAkKCB0YWIgKS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApID09PSBsb2NhdGlvbkhhc2ggKSB7XG5cdFx0XHRcdFx0XHRhY3RpdmUgPSBpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGZvciBhIHRhYiBtYXJrZWQgYWN0aXZlIHZpYSBhIGNsYXNzXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZmlsdGVyKCBcIi51aS10YWJzLWFjdGl2ZVwiICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm8gYWN0aXZlIHRhYiwgc2V0IHRvIGZhbHNlXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMubGVuZ3RoID8gMCA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBudW1iZXJzOiBuZWdhdGl2ZSwgb3V0IG9mIHJhbmdlXG5cdFx0aWYgKCBhY3RpdmUgIT09IGZhbHNlICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZXEoIGFjdGl2ZSApICk7XG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gLTEgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IGNvbGxhcHNpYmxlID8gZmFsc2UgOiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRvbid0IGFsbG93IGNvbGxhcHNpYmxlOiBmYWxzZSBhbmQgYWN0aXZlOiBmYWxzZVxuXHRcdGlmICggIWNvbGxhcHNpYmxlICYmIGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdGFjdGl2ZSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGFiOiB0aGlzLmFjdGl2ZSxcblx0XHRcdHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlIClcblx0XHR9O1xuXHR9LFxuXG5cdF90YWJLZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eToxNSovXG5cdFx0dmFyIGZvY3VzZWRUYWIgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKS5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdHNlbGVjdGVkSW5kZXggPSB0aGlzLnRhYnMuaW5kZXgoIGZvY3VzZWRUYWIgKSxcblx0XHRcdGdvaW5nRm9yd2FyZCA9IHRydWU7XG5cblx0XHRpZiAoIHRoaXMuX2hhbmRsZVBhZ2VOYXYoIGV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdFx0c2VsZWN0ZWRJbmRleCsrO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcblx0XHRcdFx0Z29pbmdGb3J3YXJkID0gZmFsc2U7XG5cdFx0XHRcdHNlbGVjdGVkSW5kZXgtLTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdHNlbGVjdGVkSW5kZXggPSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0XHRzZWxlY3RlZEluZGV4ID0gMDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblx0XHRcdFx0Ly8gQWN0aXZhdGUgb25seSwgbm8gY29sbGFwc2luZ1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuYWN0aXZhdGluZyApO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmF0ZSggc2VsZWN0ZWRJbmRleCApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcblx0XHRcdFx0Ly8gVG9nZ2xlIChjYW5jZWwgZGVsYXllZCBhY3RpdmF0aW9uLCBhbGxvdyBjb2xsYXBzaW5nKVxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuYWN0aXZhdGluZyApO1xuXHRcdFx0XHQvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG9yIGFjdGl2YXRlXG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCBzZWxlY3RlZEluZGV4ID09PSB0aGlzLm9wdGlvbnMuYWN0aXZlID8gZmFsc2UgOiBzZWxlY3RlZEluZGV4ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGb2N1cyB0aGUgYXBwcm9wcmlhdGUgdGFiLCBiYXNlZCBvbiB3aGljaCBrZXkgd2FzIHByZXNzZWRcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMuX2ZvY3VzTmV4dFRhYiggc2VsZWN0ZWRJbmRleCwgZ29pbmdGb3J3YXJkICk7XG5cblx0XHQvLyBOYXZpZ2F0aW5nIHdpdGggY29udHJvbCBrZXkgd2lsbCBwcmV2ZW50IGF1dG9tYXRpYyBhY3RpdmF0aW9uXG5cdFx0aWYgKCAhZXZlbnQuY3RybEtleSApIHtcblx0XHRcdC8vIFVwZGF0ZSBhcmlhLXNlbGVjdGVkIGltbWVkaWF0ZWx5IHNvIHRoYXQgQVQgdGhpbmsgdGhlIHRhYiBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlIEFUIG1heSBjb25mdXNlIHRoZSB1c2VyIGJ5IHN0YXRpbmcgdGhhdCB0aGV5IG5lZWQgdG8gYWN0aXZhdGUgdGhlIHRhYixcblx0XHRcdC8vIGJ1dCB0aGUgdGFiIHdpbGwgYWxyZWFkeSBiZSBhY3RpdmF0ZWQgYnkgdGhlIHRpbWUgdGhlIGFubm91bmNlbWVudCBmaW5pc2hlcy5cblx0XHRcdGZvY3VzZWRUYWIuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0dGhpcy50YWJzLmVxKCBzZWxlY3RlZEluZGV4ICkuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdHRoaXMuYWN0aXZhdGluZyA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbiggXCJhY3RpdmVcIiwgc2VsZWN0ZWRJbmRleCApO1xuXHRcdFx0fSwgdGhpcy5kZWxheSApO1xuXHRcdH1cblx0fSxcblxuXHRfcGFuZWxLZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLl9oYW5kbGVQYWdlTmF2KCBldmVudCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEN0cmwrdXAgbW92ZXMgZm9jdXMgdG8gdGhlIGN1cnJlbnQgdGFiXG5cdFx0aWYgKCBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLmFjdGl2ZS5mb2N1cygpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBbHQrcGFnZSB1cC9kb3duIG1vdmVzIGZvY3VzIHRvIHRoZSBwcmV2aW91cy9uZXh0IHRhYiAoYW5kIGFjdGl2YXRlcylcblx0X2hhbmRsZVBhZ2VOYXY6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuUEFHRV9VUCApIHtcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB0aGlzLl9mb2N1c05leHRUYWIoIHRoaXMub3B0aW9ucy5hY3RpdmUgLSAxLCBmYWxzZSApICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCBldmVudC5hbHRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlBBR0VfRE9XTiApIHtcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB0aGlzLl9mb2N1c05leHRUYWIoIHRoaXMub3B0aW9ucy5hY3RpdmUgKyAxLCB0cnVlICkgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRfZmluZE5leHRUYWI6IGZ1bmN0aW9uKCBpbmRleCwgZ29pbmdGb3J3YXJkICkge1xuXHRcdHZhciBsYXN0VGFiSW5kZXggPSB0aGlzLnRhYnMubGVuZ3RoIC0gMTtcblxuXHRcdGZ1bmN0aW9uIGNvbnN0cmFpbigpIHtcblx0XHRcdGlmICggaW5kZXggPiBsYXN0VGFiSW5kZXggKSB7XG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRpbmRleCA9IGxhc3RUYWJJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmRleDtcblx0XHR9XG5cblx0XHR3aGlsZSAoICQuaW5BcnJheSggY29uc3RyYWluKCksIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApICE9PSAtMSApIHtcblx0XHRcdGluZGV4ID0gZ29pbmdGb3J3YXJkID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fSxcblxuXHRfZm9jdXNOZXh0VGFiOiBmdW5jdGlvbiggaW5kZXgsIGdvaW5nRm9yd2FyZCApIHtcblx0XHRpbmRleCA9IHRoaXMuX2ZpbmROZXh0VGFiKCBpbmRleCwgZ29pbmdGb3J3YXJkICk7XG5cdFx0dGhpcy50YWJzLmVxKCBpbmRleCApLmZvY3VzKCk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImFjdGl2ZVwiICkge1xuXHRcdFx0Ly8gX2FjdGl2YXRlKCkgd2lsbCBoYW5kbGUgaW52YWxpZCB2YWx1ZXMgYW5kIHVwZGF0ZSB0aGlzLm9wdGlvbnNcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHQvLyBkb24ndCB1c2UgdGhlIHdpZGdldCBmYWN0b3J5J3MgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIHZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUpO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiY29sbGFwc2libGVcIiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyggXCJ1aS10YWJzLWNvbGxhcHNpYmxlXCIsIHZhbHVlICk7XG5cdFx0XHQvLyBTZXR0aW5nIGNvbGxhcHNpYmxlOiBmYWxzZSB3aGlsZSBjb2xsYXBzZWQ7IG9wZW4gZmlyc3QgcGFuZWxcblx0XHRcdGlmICggIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmF0ZSggMCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImV2ZW50XCIgKSB7XG5cdFx0XHR0aGlzLl9zZXR1cEV2ZW50cyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJoZWlnaHRTdHlsZVwiICkge1xuXHRcdFx0dGhpcy5fc2V0dXBIZWlnaHRTdHlsZSggdmFsdWUgKTtcblx0XHR9XG5cdH0sXG5cblx0X3RhYklkOiBmdW5jdGlvbiggdGFiICkge1xuXHRcdHJldHVybiB0YWIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKSB8fCBcInVpLXRhYnMtXCIgKyBnZXROZXh0VGFiSWQoKTtcblx0fSxcblxuXHRfc2FuaXRpemVTZWxlY3RvcjogZnVuY3Rpb24oIGhhc2ggKSB7XG5cdFx0cmV0dXJuIGhhc2ggPyBoYXNoLnJlcGxhY2UoIC9bIVwiJCUmJygpKissLlxcLzo7PD0+P0BcXFtcXF1cXF5ge3x9fl0vZywgXCJcXFxcJCZcIiApIDogXCJcIjtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGxpcyA9IHRoaXMudGFibGlzdC5jaGlsZHJlbiggXCI6aGFzKGFbaHJlZl0pXCIgKTtcblxuXHRcdC8vIGdldCBkaXNhYmxlZCB0YWJzIGZyb20gY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxuXHRcdC8vIHRoaXMgd2lsbCBnZXQgY29udmVydGVkIHRvIGEgYm9vbGVhbiBpZiBuZWVkZWQgaW4gX3JlZnJlc2goKVxuXHRcdG9wdGlvbnMuZGlzYWJsZWQgPSAkLm1hcCggbGlzLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLCBmdW5jdGlvbiggdGFiICkge1xuXHRcdFx0cmV0dXJuIGxpcy5pbmRleCggdGFiICk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9wcm9jZXNzVGFicygpO1xuXG5cdFx0Ly8gd2FzIGNvbGxhcHNlZCBvciBubyB0YWJzXG5cdFx0aWYgKCBvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgfHwgIXRoaXMuYW5jaG9ycy5sZW5ndGggKSB7XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYnV0IGFjdGl2ZSB0YWIgaXMgZ29uZVxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhJC5jb250YWlucyggdGhpcy50YWJsaXN0WyAwIF0sIHRoaXMuYWN0aXZlWyAwIF0gKSApIHtcblx0XHRcdC8vIGFsbCByZW1haW5pbmcgdGFicyBhcmUgZGlzYWJsZWRcblx0XHRcdGlmICggdGhpcy50YWJzLmxlbmd0aCA9PT0gb3B0aW9ucy5kaXNhYmxlZC5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXHRcdFx0Ly8gYWN0aXZhdGUgcHJldmlvdXMgdGFiXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmF0ZSggdGhpcy5fZmluZE5leHRUYWIoIE1hdGgubWF4KCAwLCBvcHRpb25zLmFjdGl2ZSAtIDEgKSwgZmFsc2UgKSApO1xuXHRcdFx0fVxuXHRcdC8vIHdhcyBhY3RpdmUsIGFjdGl2ZSB0YWIgc3RpbGwgZXhpc3RzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIG1ha2Ugc3VyZSBhY3RpdmUgaW5kZXggaXMgY29ycmVjdFxuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSB0aGlzLnRhYnMuaW5kZXgoIHRoaXMuYWN0aXZlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9yZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZXR1cERpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR0aGlzLl9zZXR1cEV2ZW50cyggdGhpcy5vcHRpb25zLmV2ZW50ICk7XG5cdFx0dGhpcy5fc2V0dXBIZWlnaHRTdHlsZSggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICk7XG5cblx0XHR0aGlzLnRhYnMubm90KCB0aGlzLmFjdGl2ZSApLmF0dHIoe1xuXHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdH0pO1xuXHRcdHRoaXMucGFuZWxzLm5vdCggdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlICkgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0XHR9KTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBvbmUgdGFiIGlzIGluIHRoZSB0YWIgb3JkZXJcblx0XHRpZiAoICF0aGlzLmFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLnRhYnMuZXEoIDAgKS5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hY3RpdmVcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0XHR9KTtcblx0XHRcdHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3Byb2Nlc3NUYWJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLnRhYmxpc3QgPSB0aGlzLl9nZXRMaXN0KClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLW5hdiB1aS1oZWxwZXItcmVzZXQgdWktaGVscGVyLWNsZWFyZml4IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJsaXN0XCIgKTtcblxuXHRcdHRoaXMudGFicyA9IHRoaXMudGFibGlzdC5maW5kKCBcIj4gbGk6aGFzKGFbaHJlZl0pXCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXRvcFwiIClcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0cm9sZTogXCJ0YWJcIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuYW5jaG9ycyA9IHRoaXMudGFicy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCBcImFcIiwgdGhpcyApWyAwIF07XG5cdFx0XHR9KVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtYW5jaG9yXCIgKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiBcInByZXNlbnRhdGlvblwiLFxuXHRcdFx0XHR0YWJJbmRleDogLTFcblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5wYW5lbHMgPSAkKCk7XG5cblx0XHR0aGlzLmFuY2hvcnMuZWFjaChmdW5jdGlvbiggaSwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHNlbGVjdG9yLCBwYW5lbCwgcGFuZWxJZCxcblx0XHRcdFx0YW5jaG9ySWQgPSAkKCBhbmNob3IgKS51bmlxdWVJZCgpLmF0dHIoIFwiaWRcIiApLFxuXHRcdFx0XHR0YWIgPSAkKCBhbmNob3IgKS5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdFx0b3JpZ2luYWxBcmlhQ29udHJvbHMgPSB0YWIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblxuXHRcdFx0Ly8gaW5saW5lIHRhYlxuXHRcdFx0aWYgKCBpc0xvY2FsKCBhbmNob3IgKSApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBhbmNob3IuaGFzaDtcblx0XHRcdFx0cGFuZWwgPSB0aGF0LmVsZW1lbnQuZmluZCggdGhhdC5fc2FuaXRpemVTZWxlY3Rvciggc2VsZWN0b3IgKSApO1xuXHRcdFx0Ly8gcmVtb3RlIHRhYlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFuZWxJZCA9IHRoYXQuX3RhYklkKCB0YWIgKTtcblx0XHRcdFx0c2VsZWN0b3IgPSBcIiNcIiArIHBhbmVsSWQ7XG5cdFx0XHRcdHBhbmVsID0gdGhhdC5lbGVtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHRcdGlmICggIXBhbmVsLmxlbmd0aCApIHtcblx0XHRcdFx0XHRwYW5lbCA9IHRoYXQuX2NyZWF0ZVBhbmVsKCBwYW5lbElkICk7XG5cdFx0XHRcdFx0cGFuZWwuaW5zZXJ0QWZ0ZXIoIHRoYXQucGFuZWxzWyBpIC0gMSBdIHx8IHRoYXQudGFibGlzdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYW5lbC5sZW5ndGgpIHtcblx0XHRcdFx0dGhhdC5wYW5lbHMgPSB0aGF0LnBhbmVscy5hZGQoIHBhbmVsICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9yaWdpbmFsQXJpYUNvbnRyb2xzICkge1xuXHRcdFx0XHR0YWIuZGF0YSggXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcIiwgb3JpZ2luYWxBcmlhQ29udHJvbHMgKTtcblx0XHRcdH1cblx0XHRcdHRhYi5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLWNvbnRyb2xzXCI6IHNlbGVjdG9yLnN1YnN0cmluZyggMSApLFxuXHRcdFx0XHRcImFyaWEtbGFiZWxsZWRieVwiOiBhbmNob3JJZFxuXHRcdFx0fSk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiLCBhbmNob3JJZCApO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5wYW5lbHNcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIiApXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFicGFuZWxcIiApO1xuXHR9LFxuXG5cdC8vIGFsbG93IG92ZXJyaWRpbmcgaG93IHRvIGZpbmQgdGhlIGxpc3QgZm9yIHJhcmUgdXNhZ2Ugc2NlbmFyaW9zICgjNzcxNSlcblx0X2dldExpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZmluZCggXCJvbCx1bFwiICkuZXEoIDAgKTtcblx0fSxcblxuXHRfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRyZXR1cm4gJCggXCI8ZGl2PlwiIClcblx0XHRcdC5hdHRyKCBcImlkXCIsIGlkIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIiApXG5cdFx0XHQuZGF0YSggXCJ1aS10YWJzLWRlc3Ryb3lcIiwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9zZXR1cERpc2FibGVkOiBmdW5jdGlvbiggZGlzYWJsZWQgKSB7XG5cdFx0aWYgKCAkLmlzQXJyYXkoIGRpc2FibGVkICkgKSB7XG5cdFx0XHRpZiAoICFkaXNhYmxlZC5sZW5ndGggKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBkaXNhYmxlZC5sZW5ndGggPT09IHRoaXMuYW5jaG9ycy5sZW5ndGggKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBkaXNhYmxlIHRhYnNcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGxpOyAoIGxpID0gdGhpcy50YWJzWyBpIF0gKTsgaSsrICkge1xuXHRcdFx0aWYgKCBkaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkLmluQXJyYXkoIGksIGRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0XHQkKCBsaSApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoIGxpIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zLmRpc2FibGVkID0gZGlzYWJsZWQ7XG5cdH0sXG5cblx0X3NldHVwRXZlbnRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdGNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0JC5lYWNoKCBldmVudC5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpbmRleCwgZXZlbnROYW1lICkge1xuXHRcdFx0XHRldmVudHNbIGV2ZW50TmFtZSBdID0gXCJfZXZlbnRIYW5kbGVyXCI7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl9vZmYoIHRoaXMuYW5jaG9ycy5hZGQoIHRoaXMudGFicyApLmFkZCggdGhpcy5wYW5lbHMgKSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmFuY2hvcnMsIGV2ZW50cyApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnRhYnMsIHsga2V5ZG93bjogXCJfdGFiS2V5ZG93blwiIH0gKTtcblx0XHR0aGlzLl9vbiggdGhpcy5wYW5lbHMsIHsga2V5ZG93bjogXCJfcGFuZWxLZXlkb3duXCIgfSApO1xuXG5cdFx0dGhpcy5fZm9jdXNhYmxlKCB0aGlzLnRhYnMgKTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMudGFicyApO1xuXHR9LFxuXG5cdF9zZXR1cEhlaWdodFN0eWxlOiBmdW5jdGlvbiggaGVpZ2h0U3R5bGUgKSB7XG5cdFx0dmFyIG1heEhlaWdodCxcblx0XHRcdHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKTtcblxuXHRcdGlmICggaGVpZ2h0U3R5bGUgPT09IFwiZmlsbFwiICkge1xuXHRcdFx0bWF4SGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpO1xuXHRcdFx0bWF4SGVpZ2h0IC09IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIC0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwiOnZpc2libGVcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXhIZWlnaHQgLT0gZWxlbS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZWxlbWVudC5jaGlsZHJlbigpLm5vdCggdGhpcy5wYW5lbHMgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgLT0gJCggdGhpcyApLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5wYW5lbHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmhlaWdodCggTWF0aC5tYXgoIDAsIG1heEhlaWdodCAtXG5cdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0fSlcblx0XHRcdC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIgKTtcblx0XHR9IGVsc2UgaWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHRtYXhIZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5wYW5lbHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gTWF0aC5tYXgoIG1heEhlaWdodCwgJCggdGhpcyApLmhlaWdodCggXCJcIiApLmhlaWdodCgpICk7XG5cdFx0XHR9KS5oZWlnaHQoIG1heEhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfZXZlbnRIYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRhY3RpdmUgPSB0aGlzLmFjdGl2ZSxcblx0XHRcdGFuY2hvciA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSxcblx0XHRcdHRhYiA9IGFuY2hvci5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdGNsaWNrZWRJc0FjdGl2ZSA9IHRhYlsgMCBdID09PSBhY3RpdmVbIDAgXSxcblx0XHRcdGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcblx0XHRcdHRvU2hvdyA9IGNvbGxhcHNpbmcgPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGFiICksXG5cdFx0XHR0b0hpZGUgPSAhYWN0aXZlLmxlbmd0aCA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKCBhY3RpdmUgKSxcblx0XHRcdGV2ZW50RGF0YSA9IHtcblx0XHRcdFx0b2xkVGFiOiBhY3RpdmUsXG5cdFx0XHRcdG9sZFBhbmVsOiB0b0hpZGUsXG5cdFx0XHRcdG5ld1RhYjogY29sbGFwc2luZyA/ICQoKSA6IHRhYixcblx0XHRcdFx0bmV3UGFuZWw6IHRvU2hvd1xuXHRcdFx0fTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoIHRhYi5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgfHxcblx0XHRcdFx0Ly8gdGFiIGlzIGFscmVhZHkgbG9hZGluZ1xuXHRcdFx0XHR0YWIuaGFzQ2xhc3MoIFwidWktdGFicy1sb2FkaW5nXCIgKSB8fFxuXHRcdFx0XHQvLyBjYW4ndCBzd2l0Y2ggZHVybmluZyBhbiBhbmltYXRpb25cblx0XHRcdFx0dGhpcy5ydW5uaW5nIHx8XG5cdFx0XHRcdC8vIGNsaWNrIG9uIGFjdGl2ZSBoZWFkZXIsIGJ1dCBub3QgY29sbGFwc2libGVcblx0XHRcdFx0KCBjbGlja2VkSXNBY3RpdmUgJiYgIW9wdGlvbnMuY29sbGFwc2libGUgKSB8fFxuXHRcdFx0XHQvLyBhbGxvdyBjYW5jZWxpbmcgYWN0aXZhdGlvblxuXHRcdFx0XHQoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQWN0aXZhdGVcIiwgZXZlbnQsIGV2ZW50RGF0YSApID09PSBmYWxzZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuYWN0aXZlID0gY29sbGFwc2luZyA/IGZhbHNlIDogdGhpcy50YWJzLmluZGV4KCB0YWIgKTtcblxuXHRcdHRoaXMuYWN0aXZlID0gY2xpY2tlZElzQWN0aXZlID8gJCgpIDogdGFiO1xuXHRcdGlmICggdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdGlmICggIXRvSGlkZS5sZW5ndGggJiYgIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHQkLmVycm9yKCBcImpRdWVyeSBVSSBUYWJzOiBNaXNtYXRjaGluZyBmcmFnbWVudCBpZGVudGlmaWVyLlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5sb2FkKCB0aGlzLnRhYnMuaW5kZXgoIHRhYiApLCBldmVudCApO1xuXHRcdH1cblx0XHR0aGlzLl90b2dnbGUoIGV2ZW50LCBldmVudERhdGEgKTtcblx0fSxcblxuXHQvLyBoYW5kbGVzIHNob3cvaGlkZSBmb3Igc2VsZWN0aW5nIHRhYnNcblx0X3RvZ2dsZTogZnVuY3Rpb24oIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dG9TaG93ID0gZXZlbnREYXRhLm5ld1BhbmVsLFxuXHRcdFx0dG9IaWRlID0gZXZlbnREYXRhLm9sZFBhbmVsO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0dGhhdC5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaG93KCkge1xuXHRcdFx0ZXZlbnREYXRhLm5ld1RhYi5jbG9zZXN0KCBcImxpXCIgKS5hZGRDbGFzcyggXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdGhhdC5vcHRpb25zLnNob3cgKSB7XG5cdFx0XHRcdHRoYXQuX3Nob3coIHRvU2hvdywgdGhhdC5vcHRpb25zLnNob3csIGNvbXBsZXRlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1Nob3cuc2hvdygpO1xuXHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG91dCBieSBoaWRpbmcsIHRoZW4gc2hvd2luZywgdGhlbiBjb21wbGV0aW5nXG5cdFx0aWYgKCB0b0hpZGUubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5oaWRlICkge1xuXHRcdFx0dGhpcy5faGlkZSggdG9IaWRlLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0c2hvdygpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdHRvSGlkZS5oaWRlKCk7XG5cdFx0XHRzaG93KCk7XG5cdFx0fVxuXG5cdFx0dG9IaWRlLmF0dHIoe1xuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0XHR9KTtcblx0XHRldmVudERhdGEub2xkVGFiLmF0dHIoIFwiYXJpYS1zZWxlY3RlZFwiLCBcImZhbHNlXCIgKTtcblx0XHQvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgdGFicywgcmVtb3ZlIHRoZSBvbGQgdGFiIGZyb20gdGhlIHRhYiBvcmRlci5cblx0XHQvLyBJZiB3ZSdyZSBvcGVuaW5nIGZyb20gY29sbGFwc2VkIHN0YXRlLCByZW1vdmUgdGhlIHByZXZpb3VzIHRhYiBmcm9tIHRoZSB0YWIgb3JkZXIuXG5cdFx0Ly8gSWYgd2UncmUgY29sbGFwc2luZywgdGhlbiBrZWVwIHRoZSBjb2xsYXBzaW5nIHRhYiBpbiB0aGUgdGFiIG9yZGVyLlxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCAmJiB0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fSBlbHNlIGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICkgPT09IDA7XG5cdFx0XHR9KVxuXHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3cuYXR0cih7XG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdH0pO1xuXHRcdGV2ZW50RGF0YS5uZXdUYWIuYXR0cih7XG5cdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHR0YWJJbmRleDogMFxuXHRcdH0pO1xuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHZhciBhbmNob3IsXG5cdFx0XHRhY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBpbmRleCApO1xuXG5cdFx0Ly8gdHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlWyAwIF0gPT09IHRoaXMuYWN0aXZlWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gdHJ5aW5nIHRvIGNvbGxhcHNlLCBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBjdXJyZW50IGFjdGl2ZSBoZWFkZXJcblx0XHRpZiAoICFhY3RpdmUubGVuZ3RoICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmU7XG5cdFx0fVxuXG5cdFx0YW5jaG9yID0gYWN0aXZlLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdO1xuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcih7XG5cdFx0XHR0YXJnZXQ6IGFuY2hvcixcblx0XHRcdGN1cnJlbnRUYXJnZXQ6IGFuY2hvcixcblx0XHRcdHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0XHR9KTtcblx0fSxcblxuXHRfZmluZEFjdGl2ZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdHJldHVybiBpbmRleCA9PT0gZmFsc2UgPyAkKCkgOiB0aGlzLnRhYnMuZXEoIGluZGV4ICk7XG5cdH0sXG5cblx0X2dldEluZGV4OiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0Ly8gbWV0YS1mdW5jdGlvbiB0byBnaXZlIHVzZXJzIG9wdGlvbiB0byBwcm92aWRlIGEgaHJlZiBzdHJpbmcgaW5zdGVhZCBvZiBhIG51bWVyaWNhbCBpbmRleC5cblx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGluZGV4ID0gdGhpcy5hbmNob3JzLmluZGV4KCB0aGlzLmFuY2hvcnMuZmlsdGVyKCBcIltocmVmJD0nXCIgKyBpbmRleCArIFwiJ11cIiApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS10YWJzLWNvbGxhcHNpYmxlXCIgKTtcblxuXHRcdHRoaXMudGFibGlzdFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtbmF2IHVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cblx0XHR0aGlzLmFuY2hvcnNcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWFuY2hvclwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpO1xuXG5cdFx0dGhpcy50YWJzLmFkZCggdGhpcy5wYW5lbHMgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAkLmRhdGEoIHRoaXMsIFwidWktdGFicy1kZXN0cm95XCIgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkIFwiICtcblx0XHRcdFx0XHRcdFwidWktY29ybmVyLXRvcCB1aS1jb3JuZXItYm90dG9tIHVpLXdpZGdldC1jb250ZW50IHVpLXRhYnMtYWN0aXZlIHVpLXRhYnMtcGFuZWxcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1saXZlXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXNlbGVjdGVkXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWhpZGRlblwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWV4cGFuZGVkXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy50YWJzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGkgPSAkKCB0aGlzICksXG5cdFx0XHRcdHByZXYgPSBsaS5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiICk7XG5cdFx0XHRpZiAoIHByZXYgKSB7XG5cdFx0XHRcdGxpXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1jb250cm9sc1wiLCBwcmV2IClcblx0XHRcdFx0XHQucmVtb3ZlRGF0YSggXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGkucmVtb3ZlQXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMucGFuZWxzLnNob3coKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdHRoaXMucGFuZWxzLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZGlzYWJsZWQgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleCggaW5kZXggKTtcblx0XHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCBkaXNhYmxlZCwgZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSAkLm1hcCggdGhpcy50YWJzLCBmdW5jdGlvbiggbGksIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXR1cERpc2FibGVkKCBkaXNhYmxlZCApO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gdHJ1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggaW5kZXgsIGRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICQuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSAkLm1lcmdlKCBbIGluZGV4IF0sIGRpc2FibGVkICkuc29ydCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSBbIGluZGV4IF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIGRpc2FibGVkICk7XG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24oIGluZGV4LCBldmVudCApIHtcblx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRhYiA9IHRoaXMudGFicy5lcSggaW5kZXggKSxcblx0XHRcdGFuY2hvciA9IHRhYi5maW5kKCBcIi51aS10YWJzLWFuY2hvclwiICksXG5cdFx0XHRwYW5lbCA9IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0YWIgKSxcblx0XHRcdGV2ZW50RGF0YSA9IHtcblx0XHRcdFx0dGFiOiB0YWIsXG5cdFx0XHRcdHBhbmVsOiBwYW5lbFxuXHRcdFx0fTtcblxuXHRcdC8vIG5vdCByZW1vdGVcblx0XHRpZiAoIGlzTG9jYWwoIGFuY2hvclsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy54aHIgPSAkLmFqYXgoIHRoaXMuX2FqYXhTZXR0aW5ncyggYW5jaG9yLCBldmVudCwgZXZlbnREYXRhICkgKTtcblxuXHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0Ly8galF1ZXJ5IDwxLjggcmV0dXJucyBmYWxzZSBpZiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxlZCBpbiBiZWZvcmVTZW5kLFxuXHRcdC8vIGJ1dCBhcyBvZiAxLjgsICQuYWpheCgpIGFsd2F5cyByZXR1cm5zIGEganFYSFIgb2JqZWN0LlxuXHRcdGlmICggdGhpcy54aHIgJiYgdGhpcy54aHIuc3RhdHVzVGV4dCAhPT0gXCJjYW5jZWxlZFwiICkge1xuXHRcdFx0dGFiLmFkZENsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtYnVzeVwiLCBcInRydWVcIiApO1xuXG5cdFx0XHR0aGlzLnhoclxuXHRcdFx0XHQuc3VjY2VzcyhmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRwYW5lbC5odG1sKCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJsb2FkXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHRcdFx0XHR9LCAxICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jb21wbGV0ZShmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdHVzID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucGFuZWxzLnN0b3AoIGZhbHNlLCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhYi5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWxvYWRpbmdcIiApO1xuXHRcdFx0XHRcdFx0cGFuZWwucmVtb3ZlQXR0ciggXCJhcmlhLWJ1c3lcIiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGpxWEhSID09PSB0aGF0LnhociApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoYXQueGhyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDEgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hamF4U2V0dGluZ3M6IGZ1bmN0aW9uKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IGFuY2hvci5hdHRyKCBcImhyZWZcIiApLFxuXHRcdFx0YmVmb3JlU2VuZDogZnVuY3Rpb24oIGpxWEhSLCBzZXR0aW5ncyApIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX3RyaWdnZXIoIFwiYmVmb3JlTG9hZFwiLCBldmVudCxcblx0XHRcdFx0XHQkLmV4dGVuZCggeyBqcVhIUiA6IGpxWEhSLCBhamF4U2V0dGluZ3M6IHNldHRpbmdzIH0sIGV2ZW50RGF0YSApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0dmFyIGlkID0gJCggdGFiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMuX3Nhbml0aXplU2VsZWN0b3IoIFwiI1wiICsgaWQgKSApO1xuXHR9XG59KTtcblxufSkoIGpRdWVyeSApO1xuXG4oZnVuY3Rpb24oICQgKSB7XG5cbnZhciBpbmNyZW1lbnRzID0gMDtcblxuZnVuY3Rpb24gYWRkRGVzY3JpYmVkQnkoIGVsZW0sIGlkICkge1xuXHR2YXIgZGVzY3JpYmVkYnkgPSAoZWxlbS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApIHx8IFwiXCIpLnNwbGl0KCAvXFxzKy8gKTtcblx0ZGVzY3JpYmVkYnkucHVzaCggaWQgKTtcblx0ZWxlbVxuXHRcdC5kYXRhKCBcInVpLXRvb2x0aXAtaWRcIiwgaWQgKVxuXHRcdC5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgJC50cmltKCBkZXNjcmliZWRieS5qb2luKCBcIiBcIiApICkgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRGVzY3JpYmVkQnkoIGVsZW0gKSB7XG5cdHZhciBpZCA9IGVsZW0uZGF0YSggXCJ1aS10b29sdGlwLWlkXCIgKSxcblx0XHRkZXNjcmliZWRieSA9IChlbGVtLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiICkgfHwgXCJcIikuc3BsaXQoIC9cXHMrLyApLFxuXHRcdGluZGV4ID0gJC5pbkFycmF5KCBpZCwgZGVzY3JpYmVkYnkgKTtcblx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0ZGVzY3JpYmVkYnkuc3BsaWNlKCBpbmRleCwgMSApO1xuXHR9XG5cblx0ZWxlbS5yZW1vdmVEYXRhKCBcInVpLXRvb2x0aXAtaWRcIiApO1xuXHRkZXNjcmliZWRieSA9ICQudHJpbSggZGVzY3JpYmVkYnkuam9pbiggXCIgXCIgKSApO1xuXHRpZiAoIGRlc2NyaWJlZGJ5ICkge1xuXHRcdGVsZW0uYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGRlc2NyaWJlZGJ5ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApO1xuXHR9XG59XG5cbiQud2lkZ2V0KCBcInVpLnRvb2x0aXBcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuM1wiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBzdXBwb3J0OiBJRTw5LCBPcGVyYSBpbiBqUXVlcnkgPDEuN1xuXHRcdFx0Ly8gLnRleHQoKSBjYW4ndCBhY2NlcHQgdW5kZWZpbmVkLCBzbyBjb2VyY2UgdG8gYSBzdHJpbmdcblx0XHRcdHZhciB0aXRsZSA9ICQoIHRoaXMgKS5hdHRyKCBcInRpdGxlXCIgKSB8fCBcIlwiO1xuXHRcdFx0Ly8gRXNjYXBlIHRpdGxlLCBzaW5jZSB3ZSdyZSBnb2luZyBmcm9tIGFuIGF0dHJpYnV0ZSB0byByYXcgSFRNTFxuXHRcdFx0cmV0dXJuICQoIFwiPGE+XCIgKS50ZXh0KCB0aXRsZSApLmh0bWwoKTtcblx0XHR9LFxuXHRcdGhpZGU6IHRydWUsXG5cdFx0Ly8gRGlzYWJsZWQgZWxlbWVudHMgaGF2ZSBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzICgjODY2MSlcblx0XHRpdGVtczogXCJbdGl0bGVdOm5vdChbZGlzYWJsZWRdKVwiLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcCsxNVwiLFxuXHRcdFx0YXQ6IFwibGVmdCBib3R0b21cIixcblx0XHRcdGNvbGxpc2lvbjogXCJmbGlwZml0IGZsaXBcIlxuXHRcdH0sXG5cdFx0c2hvdzogdHJ1ZSxcblx0XHR0b29sdGlwQ2xhc3M6IG51bGwsXG5cdFx0dHJhY2s6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0b3BlbjogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX29uKHtcblx0XHRcdG1vdXNlb3ZlcjogXCJvcGVuXCIsXG5cdFx0XHRmb2N1c2luOiBcIm9wZW5cIlxuXHRcdH0pO1xuXG5cdFx0Ly8gSURzIG9mIGdlbmVyYXRlZCB0b29sdGlwcywgbmVlZGVkIGZvciBkZXN0cm95XG5cdFx0dGhpcy50b29sdGlwcyA9IHt9O1xuXHRcdC8vIElEcyBvZiBwYXJlbnQgdG9vbHRpcHMgd2hlcmUgd2UgcmVtb3ZlZCB0aGUgdGl0bGUgYXR0cmlidXRlXG5cdFx0dGhpcy5wYXJlbnRzID0ge307XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXNbIHZhbHVlID8gXCJfZGlzYWJsZVwiIDogXCJfZW5hYmxlXCIgXSgpO1xuXHRcdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0Ly8gZGlzYWJsZSBlbGVtZW50IHN0eWxlIGNoYW5nZXNcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0JC5lYWNoKCB0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiggaWQsIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHRoYXQuX3VwZGF0ZUNvbnRlbnQoIGVsZW1lbnQgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly8gY2xvc2Ugb3BlbiB0b29sdGlwc1xuXHRcdCQuZWFjaCggdGhpcy50b29sdGlwcywgZnVuY3Rpb24oIGlkLCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKTtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50WzBdO1xuXHRcdFx0dGhhdC5jbG9zZSggZXZlbnQsIHRydWUgKTtcblx0XHR9KTtcblxuXHRcdC8vIHJlbW92ZSB0aXRsZSBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgbmF0aXZlIHRvb2x0aXBzXG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApLmFkZEJhY2soKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGVsZW1lbnQuaXMoIFwiW3RpdGxlXVwiICkgKSB7XG5cdFx0XHRcdGVsZW1lbnRcblx0XHRcdFx0XHQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIsIGVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiICkgKVxuXHRcdFx0XHRcdC5hdHRyKCBcInRpdGxlXCIsIFwiXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHQvLyByZXN0b3JlIHRpdGxlIGF0dHJpYnV0ZXNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zICkuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9ICQoIHRoaXMgKTtcblx0XHRcdGlmICggZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0b3BlbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRhcmdldCA9ICQoIGV2ZW50ID8gZXZlbnQudGFyZ2V0IDogdGhpcy5lbGVtZW50IClcblx0XHRcdFx0Ly8gd2UgbmVlZCBjbG9zZXN0IGhlcmUgZHVlIHRvIG1vdXNlb3ZlciBidWJibGluZyxcblx0XHRcdFx0Ly8gYnV0IGFsd2F5cyBwb2ludGluZyBhdCB0aGUgc2FtZSBldmVudCB0YXJnZXRcblx0XHRcdFx0LmNsb3Nlc3QoIHRoaXMub3B0aW9ucy5pdGVtcyApO1xuXG5cdFx0Ly8gTm8gZWxlbWVudCB0byBzaG93IGEgdG9vbHRpcCBmb3Igb3IgdGhlIHRvb2x0aXAgaXMgYWxyZWFkeSBvcGVuXG5cdFx0aWYgKCAhdGFyZ2V0Lmxlbmd0aCB8fCB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLWlkXCIgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRhcmdldC5hdHRyKCBcInRpdGxlXCIgKSApIHtcblx0XHRcdHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiwgdGFyZ2V0LmF0dHIoIFwidGl0bGVcIiApICk7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIsIHRydWUgKTtcblxuXHRcdC8vIGtpbGwgcGFyZW50IHRvb2x0aXBzLCBjdXN0b20gb3IgbmF0aXZlLCBmb3IgaG92ZXJcblx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCIgKSB7XG5cdFx0XHR0YXJnZXQucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0Ymx1ckV2ZW50O1xuXHRcdFx0XHRpZiAoIHBhcmVudC5kYXRhKCBcInVpLXRvb2x0aXAtb3BlblwiICkgKSB7XG5cdFx0XHRcdFx0Ymx1ckV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKTtcblx0XHRcdFx0XHRibHVyRXZlbnQudGFyZ2V0ID0gYmx1ckV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdFx0XHRcdHRoYXQuY2xvc2UoIGJsdXJFdmVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcGFyZW50LmF0dHIoIFwidGl0bGVcIiApICkge1xuXHRcdFx0XHRcdHBhcmVudC51bmlxdWVJZCgpO1xuXHRcdFx0XHRcdHRoYXQucGFyZW50c1sgdGhpcy5pZCBdID0ge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogdGhpcyxcblx0XHRcdFx0XHRcdHRpdGxlOiBwYXJlbnQuYXR0ciggXCJ0aXRsZVwiIClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHBhcmVudC5hdHRyKCBcInRpdGxlXCIsIFwiXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCggdGFyZ2V0LCBldmVudCApO1xuXHR9LFxuXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiggdGFyZ2V0LCBldmVudCApIHtcblx0XHR2YXIgY29udGVudCxcblx0XHRcdGNvbnRlbnRPcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGVudCxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRlbnRPcHRpb24gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3BlbiggZXZlbnQsIHRhcmdldCwgY29udGVudE9wdGlvbiApO1xuXHRcdH1cblxuXHRcdGNvbnRlbnQgPSBjb250ZW50T3B0aW9uLmNhbGwoIHRhcmdldFswXSwgZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0Ly8gaWdub3JlIGFzeW5jIHJlc3BvbnNlIGlmIHRvb2x0aXAgd2FzIGNsb3NlZCBhbHJlYWR5XG5cdFx0XHRpZiAoICF0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLW9wZW5cIiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJRSBtYXkgaW5zdGFudGx5IHNlcnZlIGEgY2FjaGVkIHJlc3BvbnNlIGZvciBhamF4IHJlcXVlc3RzXG5cdFx0XHQvLyBkZWxheSB0aGlzIGNhbGwgdG8gX29wZW4gc28gdGhlIG90aGVyIGNhbGwgdG8gX29wZW4gcnVucyBmaXJzdFxuXHRcdFx0dGhhdC5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGpRdWVyeSBjcmVhdGVzIGEgc3BlY2lhbCBldmVudCBmb3IgZm9jdXNpbiB3aGVuIGl0IGRvZXNuJ3Rcblx0XHRcdFx0Ly8gZXhpc3QgbmF0aXZlbHkuIFRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0Ly8gb2JqZWN0IGlzIHJldXNlZCBhbmQgdGhlIHR5cGUgaXMgY2hhbmdlZC4gVGhlcmVmb3JlLCB3ZSBjYW4ndFxuXHRcdFx0XHQvLyByZWx5IG9uIHRoZSB0eXBlIGJlaW5nIGNvcnJlY3QgYWZ0ZXIgdGhlIGV2ZW50IGZpbmlzaGVkXG5cdFx0XHRcdC8vIGJ1YmJsaW5nLCBzbyB3ZSBzZXQgaXQgYmFjayB0byB0aGUgcHJldmlvdXMgdmFsdWUuICgjODc0MClcblx0XHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0XHRldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX29wZW4oIGV2ZW50LCB0YXJnZXQsIHJlc3BvbnNlICk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCBjb250ZW50ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vcGVuOiBmdW5jdGlvbiggZXZlbnQsIHRhcmdldCwgY29udGVudCApIHtcblx0XHR2YXIgdG9vbHRpcCwgZXZlbnRzLCBkZWxheWVkU2hvdyxcblx0XHRcdHBvc2l0aW9uT3B0aW9uID0gJC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblxuXHRcdGlmICggIWNvbnRlbnQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGVudCBjYW4gYmUgdXBkYXRlZCBtdWx0aXBsZSB0aW1lcy4gSWYgdGhlIHRvb2x0aXAgYWxyZWFkeVxuXHRcdC8vIGV4aXN0cywgdGhlbiBqdXN0IHVwZGF0ZSB0aGUgY29udGVudCBhbmQgYmFpbC5cblx0XHR0b29sdGlwID0gdGhpcy5fZmluZCggdGFyZ2V0ICk7XG5cdFx0aWYgKCB0b29sdGlwLmxlbmd0aCApIHtcblx0XHRcdHRvb2x0aXAuZmluZCggXCIudWktdG9vbHRpcC1jb250ZW50XCIgKS5odG1sKCBjb250ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHRpdGxlLCBjbGVhciBpdCB0byBwcmV2ZW50IHRoZSBuYXRpdmUgdG9vbHRpcFxuXHRcdC8vIHdlIGhhdmUgdG8gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZGVmaW5pbmcgYSB0aXRsZSBpZiBub25lIGV4aXN0c1xuXHRcdC8vICh3ZSBkb24ndCB3YW50IHRvIGNhdXNlIGFuIGVsZW1lbnQgdG8gc3RhcnQgbWF0Y2hpbmcgW3RpdGxlXSlcblx0XHQvL1xuXHRcdC8vIFdlIHVzZSByZW1vdmVBdHRyIG9ubHkgZm9yIGtleSBldmVudHMsIHRvIGFsbG93IElFIHRvIGV4cG9ydCB0aGUgY29ycmVjdFxuXHRcdC8vIGFjY2Vzc2libGUgYXR0cmlidXRlcy4gRm9yIG1vdXNlIGV2ZW50cywgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBhdm9pZFxuXHRcdC8vIG5hdGl2ZSB0b29sdGlwIHNob3dpbmcgdXAgKGhhcHBlbnMgb25seSB3aGVuIHJlbW92aW5nIGluc2lkZSBtb3VzZW92ZXIpLlxuXHRcdGlmICggdGFyZ2V0LmlzKCBcIlt0aXRsZV1cIiApICkge1xuXHRcdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcIm1vdXNlb3ZlclwiICkge1xuXHRcdFx0XHR0YXJnZXQuYXR0ciggXCJ0aXRsZVwiLCBcIlwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXQucmVtb3ZlQXR0ciggXCJ0aXRsZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9vbHRpcCA9IHRoaXMuX3Rvb2x0aXAoIHRhcmdldCApO1xuXHRcdGFkZERlc2NyaWJlZEJ5KCB0YXJnZXQsIHRvb2x0aXAuYXR0ciggXCJpZFwiICkgKTtcblx0XHR0b29sdGlwLmZpbmQoIFwiLnVpLXRvb2x0aXAtY29udGVudFwiICkuaHRtbCggY29udGVudCApO1xuXG5cdFx0ZnVuY3Rpb24gcG9zaXRpb24oIGV2ZW50ICkge1xuXHRcdFx0cG9zaXRpb25PcHRpb24ub2YgPSBldmVudDtcblx0XHRcdGlmICggdG9vbHRpcC5pcyggXCI6aGlkZGVuXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dG9vbHRpcC5wb3NpdGlvbiggcG9zaXRpb25PcHRpb24gKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudHJhY2sgJiYgZXZlbnQgJiYgL15tb3VzZS8udGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHtcblx0XHRcdFx0bW91c2Vtb3ZlOiBwb3NpdGlvblxuXHRcdFx0fSk7XG5cdFx0XHQvLyB0cmlnZ2VyIG9uY2UgdG8gb3ZlcnJpZGUgZWxlbWVudC1yZWxhdGl2ZSBwb3NpdGlvbmluZ1xuXHRcdFx0cG9zaXRpb24oIGV2ZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvb2x0aXAucG9zaXRpb24oICQuZXh0ZW5kKHtcblx0XHRcdFx0b2Y6IHRhcmdldFxuXHRcdFx0fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uICkgKTtcblx0XHR9XG5cblx0XHR0b29sdGlwLmhpZGUoKTtcblxuXHRcdHRoaXMuX3Nob3coIHRvb2x0aXAsIHRoaXMub3B0aW9ucy5zaG93ICk7XG5cdFx0Ly8gSGFuZGxlIHRyYWNraW5nIHRvb2x0aXBzIHRoYXQgYXJlIHNob3duIHdpdGggYSBkZWxheSAoIzg2NDQpLiBBcyBzb29uXG5cdFx0Ly8gYXMgdGhlIHRvb2x0aXAgaXMgdmlzaWJsZSwgcG9zaXRpb24gdGhlIHRvb2x0aXAgdXNpbmcgdGhlIG1vc3QgcmVjZW50XG5cdFx0Ly8gZXZlbnQuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hvdyAmJiB0aGlzLm9wdGlvbnMuc2hvdy5kZWxheSApIHtcblx0XHRcdGRlbGF5ZWRTaG93ID0gdGhpcy5kZWxheWVkU2hvdyA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRvb2x0aXAuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uKCBwb3NpdGlvbk9wdGlvbi5vZiApO1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoIGRlbGF5ZWRTaG93ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sICQuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiwgZXZlbnQsIHsgdG9vbHRpcDogdG9vbHRpcCB9ICk7XG5cblx0XHRldmVudHMgPSB7XG5cdFx0XHRrZXl1cDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FU0NBUEUgKSB7XG5cdFx0XHRcdFx0dmFyIGZha2VFdmVudCA9ICQuRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdGZha2VFdmVudC5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0WzBdO1xuXHRcdFx0XHRcdHRoaXMuY2xvc2UoIGZha2VFdmVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVG9vbHRpcCggdG9vbHRpcCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKCAhZXZlbnQgfHwgZXZlbnQudHlwZSA9PT0gXCJtb3VzZW92ZXJcIiApIHtcblx0XHRcdGV2ZW50cy5tb3VzZWxlYXZlID0gXCJjbG9zZVwiO1xuXHRcdH1cblx0XHRpZiAoICFldmVudCB8fCBldmVudC50eXBlID09PSBcImZvY3VzaW5cIiApIHtcblx0XHRcdGV2ZW50cy5mb2N1c291dCA9IFwiY2xvc2VcIjtcblx0XHR9XG5cdFx0dGhpcy5fb24oIHRydWUsIHRhcmdldCwgZXZlbnRzICk7XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHR0YXJnZXQgPSAkKCBldmVudCA/IGV2ZW50LmN1cnJlbnRUYXJnZXQgOiB0aGlzLmVsZW1lbnQgKSxcblx0XHRcdHRvb2x0aXAgPSB0aGlzLl9maW5kKCB0YXJnZXQgKTtcblxuXHRcdC8vIGRpc2FibGluZyBjbG9zZXMgdGhlIHRvb2x0aXAsIHNvIHdlIG5lZWQgdG8gdHJhY2sgd2hlbiB3ZSdyZSBjbG9zaW5nXG5cdFx0Ly8gdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCBpbiBjYXNlIHRoZSB0b29sdGlwIGJlY29tZXMgZGlzYWJsZWQgb24gY2xvc2Vcblx0XHRpZiAoIHRoaXMuY2xvc2luZyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGVhciB0aGUgaW50ZXJ2YWwgZm9yIGRlbGF5ZWQgdHJhY2tpbmcgdG9vbHRpcHNcblx0XHRjbGVhckludGVydmFsKCB0aGlzLmRlbGF5ZWRTaG93ICk7XG5cblx0XHQvLyBvbmx5IHNldCB0aXRsZSBpZiB3ZSBoYWQgb25lIGJlZm9yZSAoc2VlIGNvbW1lbnQgaW4gX29wZW4oKSlcblx0XHRpZiAoIHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICkge1xuXHRcdFx0dGFyZ2V0LmF0dHIoIFwidGl0bGVcIiwgdGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICkgKTtcblx0XHR9XG5cblx0XHRyZW1vdmVEZXNjcmliZWRCeSggdGFyZ2V0ICk7XG5cblx0XHR0b29sdGlwLnN0b3AoIHRydWUgKTtcblx0XHR0aGlzLl9oaWRlKCB0b29sdGlwLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0Ll9yZW1vdmVUb29sdGlwKCAkKCB0aGlzICkgKTtcblx0XHR9KTtcblxuXHRcdHRhcmdldC5yZW1vdmVEYXRhKCBcInVpLXRvb2x0aXAtb3BlblwiICk7XG5cdFx0dGhpcy5fb2ZmKCB0YXJnZXQsIFwibW91c2VsZWF2ZSBmb2N1c291dCBrZXl1cFwiICk7XG5cdFx0Ly8gUmVtb3ZlICdyZW1vdmUnIGJpbmRpbmcgb25seSBvbiBkZWxlZ2F0ZWQgdGFyZ2V0c1xuXHRcdGlmICggdGFyZ2V0WzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gKSB7XG5cdFx0XHR0aGlzLl9vZmYoIHRhcmdldCwgXCJyZW1vdmVcIiApO1xuXHRcdH1cblx0XHR0aGlzLl9vZmYoIHRoaXMuZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIgKTtcblxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJtb3VzZWxlYXZlXCIgKSB7XG5cdFx0XHQkLmVhY2goIHRoaXMucGFyZW50cywgZnVuY3Rpb24oIGlkLCBwYXJlbnQgKSB7XG5cdFx0XHRcdCQoIHBhcmVudC5lbGVtZW50ICkuYXR0ciggXCJ0aXRsZVwiLCBwYXJlbnQudGl0bGUgKTtcblx0XHRcdFx0ZGVsZXRlIHRoYXQucGFyZW50c1sgaWQgXTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2luZyA9IHRydWU7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCwgeyB0b29sdGlwOiB0b29sdGlwIH0gKTtcblx0XHR0aGlzLmNsb3NpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRfdG9vbHRpcDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIGlkID0gXCJ1aS10b29sdGlwLVwiICsgaW5jcmVtZW50cysrLFxuXHRcdFx0dG9vbHRpcCA9ICQoIFwiPGRpdj5cIiApXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdFx0cm9sZTogXCJ0b29sdGlwXCJcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXRvb2x0aXAgdWktd2lkZ2V0IHVpLWNvcm5lci1hbGwgdWktd2lkZ2V0LWNvbnRlbnQgXCIgK1xuXHRcdFx0XHRcdCggdGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyB8fCBcIlwiICkgKTtcblx0XHQkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRvb2x0aXAtY29udGVudFwiIClcblx0XHRcdC5hcHBlbmRUbyggdG9vbHRpcCApO1xuXHRcdHRvb2x0aXAuYXBwZW5kVG8oIHRoaXMuZG9jdW1lbnRbMF0uYm9keSApO1xuXHRcdHRoaXMudG9vbHRpcHNbIGlkIF0gPSBlbGVtZW50O1xuXHRcdHJldHVybiB0b29sdGlwO1xuXHR9LFxuXG5cdF9maW5kOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBpZCA9IHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtaWRcIiApO1xuXHRcdHJldHVybiBpZCA/ICQoIFwiI1wiICsgaWQgKSA6ICQoKTtcblx0fSxcblxuXHRfcmVtb3ZlVG9vbHRpcDogZnVuY3Rpb24oIHRvb2x0aXAgKSB7XG5cdFx0dG9vbHRpcC5yZW1vdmUoKTtcblx0XHRkZWxldGUgdGhpcy50b29sdGlwc1sgdG9vbHRpcC5hdHRyKCBcImlkXCIgKSBdO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHQvLyBjbG9zZSBvcGVuIHRvb2x0aXBzXG5cdFx0JC5lYWNoKCB0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiggaWQsIGVsZW1lbnQgKSB7XG5cdFx0XHQvLyBEZWxlZ2F0ZSB0byBjbG9zZSBtZXRob2QgdG8gaGFuZGxlIGNvbW1vbiBjbGVhbnVwXG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnRbMF07XG5cdFx0XHR0aGF0LmNsb3NlKCBldmVudCwgdHJ1ZSApO1xuXG5cdFx0XHQvLyBSZW1vdmUgaW1tZWRpYXRlbHk7IGRlc3Ryb3lpbmcgYW4gb3BlbiB0b29sdGlwIGRvZXNuJ3QgdXNlIHRoZVxuXHRcdFx0Ly8gaGlkZSBhbmltYXRpb25cblx0XHRcdCQoIFwiI1wiICsgaWQgKS5yZW1vdmUoKTtcblxuXHRcdFx0Ly8gUmVzdG9yZSB0aGUgdGl0bGVcblx0XHRcdGlmICggZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICk7XG5cdFx0XHRcdGVsZW1lbnQucmVtb3ZlRGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApICk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy94dWdlL3Byb2plY3QvcXVhbnNoaS11aS9+L2pxdWVyeS11aS9qcXVlcnktdWkuanNcbiAqKiBtb2R1bGUgaWQgPSAzNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyIsIi8qKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4gKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEltcGxlbWVudGluZyBEcmFnIGFuZCBEcm9wIGZ1bmN0aW9uYWxpdHkgaW4gQW5ndWxhckpTIGlzIGVhc2llciB0aGFuIGV2ZXIuXG4gKiBEZW1vOiBodHRwOi8vY29kZWYwcm1lci5naXRodWIuY29tL2FuZ3VsYXItZHJhZ2Ryb3AvXG4gKlxuICogQHZlcnNpb24gMS4wLjEzXG4gKlxuICogKGMpIDIwMTMgQW1pdCBHaGFyYXQgYS5rLmEgY29kZWYwcm1lciA8YW1pdC4yMDA2Lml0QGdtYWlsLmNvbT4gLSBhbWl0Z2hhcmF0LndvcmRwcmVzcy5jb21cbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgYW5ndWxhciwgJCwgdW5kZWZpbmVkKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBqcXlvdWkgPSBhbmd1bGFyLm1vZHVsZSgnbmdEcmFnRHJvcCcsIFtdKS5zZXJ2aWNlKCduZ0RyYWdEcm9wU2VydmljZScsIFsnJHRpbWVvdXQnLCAnJHBhcnNlJywgJyRxJywgZnVuY3Rpb24oJHRpbWVvdXQsICRwYXJzZSwgJHEpIHtcbiAgICB0aGlzLmRyYWdnYWJsZVNjb3BlID0gbnVsbDtcbiAgICB0aGlzLmRyb3BwYWJsZVNjb3BlID0gbnVsbDtcblxuICAgICQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+QGNoYXJzZXQgXCJVVEYtOFwiOy5hbmd1bGFyLWRyYWdkcm9wLWhpZGV7ZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O308L3N0eWxlPicpO1xuXG4gICAgdGhpcy5jYWxsRXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChzY29wZSwgY2FsbGJhY2tOYW1lLCBldmVudCwgdWkpIHtcbiAgICAgIGlmICghY2FsbGJhY2tOYW1lKSByZXR1cm47XG5cbiAgICAgIHZhciBvYmpFeHRyYWN0ID0gZXh0cmFjdChjYWxsYmFja05hbWUpLFxuICAgICAgICAgIGNhbGxiYWNrID0gb2JqRXh0cmFjdC5jYWxsYmFjayxcbiAgICAgICAgICBjb25zdHJ1Y3RvciA9IG9iakV4dHJhY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgYXJncyA9IFtldmVudCwgdWldLmNvbmNhdChvYmpFeHRyYWN0LmFyZ3MpO1xuICAgICAgXG4gICAgICAvLyBjYWxsIGVpdGhlciAkc2NvcGVkIG1ldGhvZCBpLmUuICRzY29wZS5kcm9wQ2FsbGJhY2sgb3IgY29uc3RydWN0b3IncyBtZXRob2QgaS5lLiB0aGlzLmRyb3BDYWxsYmFjay5cbiAgICAgIC8vIFJlbW92aW5nIHNjb3BlLiRhcHBseSBjYWxsIHRoYXQgd2FzIHBlcmZvcm1hbmNlIGludGVuc2l2ZSAoZXNwZWNpYWxseSBvbkRyYWcpIGFuZCBkb2VzIG5vdCByZXF1aXJlIGl0XG4gICAgICAvLyBhbHdheXMuIFNvIGNhbGwgaXQgd2l0aGluIHRoZSBjYWxsYmFjayBpZiBuZWVkZWQuXG4gICAgICByZXR1cm4gKHNjb3BlW2NhbGxiYWNrXSB8fCBzY29wZVtjb25zdHJ1Y3Rvcl1bY2FsbGJhY2tdKS5hcHBseShzY29wZVtjYWxsYmFja10gPyBzY29wZSA6IHNjb3BlW2NvbnN0cnVjdG9yXSwgYXJncyk7XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGV4dHJhY3QoY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBhdFN0YXJ0QnJhY2tldCA9IGNhbGxiYWNrTmFtZS5pbmRleE9mKCcoJykgIT09IC0xID8gY2FsbGJhY2tOYW1lLmluZGV4T2YoJygnKSA6IGNhbGxiYWNrTmFtZS5sZW5ndGgsXG4gICAgICAgICAgICBhdEVuZEJyYWNrZXQgPSBjYWxsYmFja05hbWUubGFzdEluZGV4T2YoJyknKSAhPT0gLTEgPyBjYWxsYmFja05hbWUubGFzdEluZGV4T2YoJyknKSA6IGNhbGxiYWNrTmFtZS5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gY2FsbGJhY2tOYW1lLnN1YnN0cmluZyhhdFN0YXJ0QnJhY2tldCArIDEsIGF0RW5kQnJhY2tldCksIC8vIG1hdGNoaW5nIGZ1bmN0aW9uIGFyZ3VtZW50cyBpbnNpZGUgYnJhY2tldHNcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gY2FsbGJhY2tOYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgPyBjYWxsYmFja05hbWUuc3Vic3RyKDAsIGNhbGxiYWNrTmFtZS5pbmRleE9mKCcuJykpIDogbnVsbDsgLy8gbWF0Y2hpbmcgYSBzdHJpbmcgdXB0byBhIGRvdCB0byBjaGVjayBjdHJsIGFzIHN5bnRheFxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBzY29wZVtjb25zdHJ1Y3Rvcl0gJiYgdHlwZW9mIHNjb3BlW2NvbnN0cnVjdG9yXS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnN0cnVjdG9yIDogbnVsbDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWUuc3Vic3RyaW5nKGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmxlbmd0aCArIDEgfHwgMCwgYXRTdGFydEJyYWNrZXQpLFxuICAgICAgICAgIGFyZ3M6ICQubWFwKGFyZ3MgJiYgYXJncy5zcGxpdCgnLCcpIHx8IFtdLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBbJHBhcnNlKGl0ZW0pKHNjb3BlKV07IH0pLFxuICAgICAgICAgIGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3RvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW52b2tlRHJvcCA9IGZ1bmN0aW9uICgkZHJhZ2dhYmxlLCAkZHJvcHBhYmxlLCBldmVudCwgdWkpIHtcbiAgICAgIHZhciBkcmFnTW9kZWwgPSAnJyxcbiAgICAgICAgZHJvcE1vZGVsID0gJycsXG4gICAgICAgIGRyYWdTZXR0aW5ncyA9IHt9LFxuICAgICAgICBkcm9wU2V0dGluZ3MgPSB7fSxcbiAgICAgICAganF5b3VpX3BvcyA9IG51bGwsXG4gICAgICAgIGRyYWdJdGVtID0ge30sXG4gICAgICAgIGRyb3BJdGVtID0ge30sXG4gICAgICAgIGRyYWdNb2RlbFZhbHVlLFxuICAgICAgICBkcm9wTW9kZWxWYWx1ZSxcbiAgICAgICAgJGRyb3BwYWJsZURyYWdnYWJsZSA9IG51bGwsXG4gICAgICAgIGRyb3BwYWJsZVNjb3BlID0gdGhpcy5kcm9wcGFibGVTY29wZSxcbiAgICAgICAgZHJhZ2dhYmxlU2NvcGUgPSB0aGlzLmRyYWdnYWJsZVNjb3BlLFxuICAgICAgICAkaGVscGVyID0gbnVsbCxcbiAgICAgICAgcHJvbWlzZXMgPSBbXSxcbiAgICAgICAgdGVtcDtcblxuICAgICAgZHJhZ01vZGVsID0gJGRyYWdnYWJsZS5uZ2F0dHIoJ25nLW1vZGVsJyk7XG4gICAgICBkcm9wTW9kZWwgPSAkZHJvcHBhYmxlLm5nYXR0cignbmctbW9kZWwnKTtcbiAgICAgIGRyYWdNb2RlbFZhbHVlID0gZHJhZ2dhYmxlU2NvcGUuJGV2YWwoZHJhZ01vZGVsKTtcbiAgICAgIGRyb3BNb2RlbFZhbHVlID0gZHJvcHBhYmxlU2NvcGUuJGV2YWwoZHJvcE1vZGVsKTtcblxuICAgICAgJGRyb3BwYWJsZURyYWdnYWJsZSA9ICRkcm9wcGFibGUuZmluZCgnW2pxeW91aS1kcmFnZ2FibGVdOmxhc3QsW2RhdGEtanF5b3VpLWRyYWdnYWJsZV06bGFzdCcpO1xuICAgICAgZHJvcFNldHRpbmdzID0gZHJvcHBhYmxlU2NvcGUuJGV2YWwoJGRyb3BwYWJsZS5hdHRyKCdqcXlvdWktZHJvcHBhYmxlJykgfHwgJGRyb3BwYWJsZS5hdHRyKCdkYXRhLWpxeW91aS1kcm9wcGFibGUnKSkgfHwgW107XG4gICAgICBkcmFnU2V0dGluZ3MgPSBkcmFnZ2FibGVTY29wZS4kZXZhbCgkZHJhZ2dhYmxlLmF0dHIoJ2pxeW91aS1kcmFnZ2FibGUnKSB8fCAkZHJhZ2dhYmxlLmF0dHIoJ2RhdGEtanF5b3VpLWRyYWdnYWJsZScpKSB8fCBbXTtcblxuICAgICAgLy8gSGVscHMgcGljayB1cCB0aGUgcmlnaHQgaXRlbVxuICAgICAgZHJhZ1NldHRpbmdzLmluZGV4ID0gdGhpcy5maXhJbmRleChkcmFnZ2FibGVTY29wZSwgZHJhZ1NldHRpbmdzLCBkcmFnTW9kZWxWYWx1ZSk7XG4gICAgICBkcm9wU2V0dGluZ3MuaW5kZXggPSB0aGlzLmZpeEluZGV4KGRyb3BwYWJsZVNjb3BlLCBkcm9wU2V0dGluZ3MsIGRyb3BNb2RlbFZhbHVlKTtcblxuICAgICAganF5b3VpX3BvcyA9IGFuZ3VsYXIuaXNBcnJheShkcmFnTW9kZWxWYWx1ZSkgPyBkcmFnU2V0dGluZ3MuaW5kZXggOiBudWxsO1xuICAgICAgZHJhZ0l0ZW0gPSBhbmd1bGFyLmlzQXJyYXkoZHJhZ01vZGVsVmFsdWUpID8gZHJhZ01vZGVsVmFsdWVbanF5b3VpX3Bvc10gOiBkcmFnTW9kZWxWYWx1ZTtcblxuICAgICAgaWYgKGRyYWdTZXR0aW5ncy5kZWVwQ29weSkge1xuICAgICAgICBkcmFnSXRlbSA9IGFuZ3VsYXIuY29weShkcmFnSXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoZHJvcE1vZGVsVmFsdWUpICYmIGRyb3BTZXR0aW5ncyAmJiBkcm9wU2V0dGluZ3MuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkcm9wSXRlbSA9IGRyb3BNb2RlbFZhbHVlW2Ryb3BTZXR0aW5ncy5pbmRleF07XG4gICAgICB9IGVsc2UgaWYgKCFhbmd1bGFyLmlzQXJyYXkoZHJvcE1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGRyb3BJdGVtID0gZHJvcE1vZGVsVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcm9wSXRlbSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZHJvcFNldHRpbmdzLmRlZXBDb3B5KSB7XG4gICAgICAgIGRyb3BJdGVtID0gYW5ndWxhci5jb3B5KGRyb3BJdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdTZXR0aW5ncy5iZWZvcmVEcm9wKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5jYWxsRXZlbnRDYWxsYmFjayhkcmFnZ2FibGVTY29wZSwgZHJhZ1NldHRpbmdzLmJlZm9yZURyb3AsIGV2ZW50LCB1aSkpO1xuICAgICAgfVxuXG4gICAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4oYW5ndWxhci5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZHJhZ1NldHRpbmdzLmluc2VydElubGluZSAmJiBkcmFnTW9kZWwgPT09IGRyb3BNb2RlbCkge1xuICAgICAgICAgIGlmIChkcmFnU2V0dGluZ3MuaW5kZXggPiBkcm9wU2V0dGluZ3MuaW5kZXgpIHtcbiAgICAgICAgICAgIHRlbXAgPSBkcmFnTW9kZWxWYWx1ZVtkcmFnU2V0dGluZ3MuaW5kZXhdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRyYWdTZXR0aW5ncy5pbmRleDsgaSA+IGRyb3BTZXR0aW5ncy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgIGRyb3BNb2RlbFZhbHVlW2ldID0gYW5ndWxhci5jb3B5KGRyb3BNb2RlbFZhbHVlW2kgLSAxXSk7XG4gICAgICAgICAgICAgIGRyb3BNb2RlbFZhbHVlW2kgLSAxXSA9IHt9O1xuICAgICAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVtpXVtkcmFnU2V0dGluZ3MuZGlyZWN0aW9uXSA9ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyb3BNb2RlbFZhbHVlW2Ryb3BTZXR0aW5ncy5pbmRleF0gPSB0ZW1wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZHJhZ01vZGVsVmFsdWVbZHJhZ1NldHRpbmdzLmluZGV4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkcmFnU2V0dGluZ3MuaW5kZXg7IGkgPCBkcm9wU2V0dGluZ3MuaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVtpXSA9IGFuZ3VsYXIuY29weShkcm9wTW9kZWxWYWx1ZVtpICsgMV0pO1xuICAgICAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVtpICsgMV0gPSB7fTtcbiAgICAgICAgICAgICAgZHJvcE1vZGVsVmFsdWVbaV1bZHJhZ1NldHRpbmdzLmRpcmVjdGlvbl0gPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJvcE1vZGVsVmFsdWVbZHJvcFNldHRpbmdzLmluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2FsbEV2ZW50Q2FsbGJhY2soZHJvcHBhYmxlU2NvcGUsIGRyb3BTZXR0aW5ncy5vbkRyb3AsIGV2ZW50LCB1aSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZHJhZ1NldHRpbmdzLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBiZSBuaWNlIHdpdGggYWJzb2x1dGVseSBwb3NpdGlvbmVkIGJyZXRocmVuIDotKVxuICAgICAgICAgICRoZWxwZXIgPSAkZHJhZ2dhYmxlLmNsb25lKCk7XG4gICAgICAgICAgJGhlbHBlci5jc3Moeydwb3NpdGlvbic6ICdhYnNvbHV0ZSd9KS5jc3MoJGRyYWdnYWJsZS5vZmZzZXQoKSk7XG4gICAgICAgICAgJCgnYm9keScpLmFwcGVuZCgkaGVscGVyKTtcbiAgICAgICAgICAkZHJhZ2dhYmxlLmFkZENsYXNzKCdhbmd1bGFyLWRyYWdkcm9wLWhpZGUnKTtcblxuICAgICAgICAgIHRoaXMubW92ZSgkaGVscGVyLCAkZHJvcHBhYmxlRHJhZ2dhYmxlLmxlbmd0aCA+IDAgPyAkZHJvcHBhYmxlRHJhZ2dhYmxlIDogJGRyb3BwYWJsZSwgbnVsbCwgJ2Zhc3QnLCBkcm9wU2V0dGluZ3MsIGZ1bmN0aW9uKCkgeyAkaGVscGVyLnJlbW92ZSgpOyB9KTtcbiAgICAgICAgICB0aGlzLm1vdmUoJGRyb3BwYWJsZURyYWdnYWJsZS5sZW5ndGggPiAwICYmICFkcm9wU2V0dGluZ3MubXVsdGlwbGUgPyAkZHJvcHBhYmxlRHJhZ2dhYmxlIDogW10sICRkcmFnZ2FibGUucGFyZW50KCdbanF5b3VpLWRyb3BwYWJsZV0sW2RhdGEtanF5b3VpLWRyb3BwYWJsZV0nKSwganF5b3VpLnN0YXJ0WFksICdmYXN0JywgZHJvcFNldHRpbmdzLCBhbmd1bGFyLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkdGltZW91dChhbmd1bGFyLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBtb3ZlIHRoaXMgaW50byBtb3ZlKCkgdG8gYXZvaWQgZmxpY2tlcmluZyBpc3N1ZVxuICAgICAgICAgICAgICAkZHJhZ2dhYmxlLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2xlZnQnOiAnJywgJ3RvcCc6ICcnfSkucmVtb3ZlQ2xhc3MoJ2FuZ3VsYXItZHJhZ2Ryb3AtaGlkZScpO1xuICAgICAgICAgICAgICAvLyBBbmd1bGFyIHYxLjIgdXNlcyBuZy1oaWRlIHRvIGhpZGUgYW4gZWxlbWVudCBub3QgZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAvLyBzbyB3ZSd2ZSB0byBtYW51YWxseSByZW1vdmUgZGlzcGxheTpub25lIHNldCBpbiB0aGlzLm1vdmUoKVxuICAgICAgICAgICAgICAkZHJvcHBhYmxlRHJhZ2dhYmxlLmNzcyh7J3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2xlZnQnOiAnJywgJ3RvcCc6ICcnLCAnZGlzcGxheSc6ICRkcm9wcGFibGVEcmFnZ2FibGUuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJyA/ICcnIDogJGRyb3BwYWJsZURyYWdnYWJsZS5jc3MoJ2Rpc3BsYXknKX0pO1xuXG4gICAgICAgICAgICAgIHRoaXMubXV0YXRlRHJhZ2dhYmxlKGRyYWdnYWJsZVNjb3BlLCBkcm9wU2V0dGluZ3MsIGRyYWdTZXR0aW5ncywgZHJhZ01vZGVsLCBkcm9wTW9kZWwsIGRyb3BJdGVtLCAkZHJhZ2dhYmxlKTtcbiAgICAgICAgICAgICAgdGhpcy5tdXRhdGVEcm9wcGFibGUoZHJvcHBhYmxlU2NvcGUsIGRyb3BTZXR0aW5ncywgZHJhZ1NldHRpbmdzLCBkcm9wTW9kZWwsIGRyYWdJdGVtLCBqcXlvdWlfcG9zKTtcbiAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRDYWxsYmFjayhkcm9wcGFibGVTY29wZSwgZHJvcFNldHRpbmdzLm9uRHJvcCwgZXZlbnQsIHVpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHRpbWVvdXQoYW5ndWxhci5iaW5kKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGVEcmFnZ2FibGUoZHJhZ2dhYmxlU2NvcGUsIGRyb3BTZXR0aW5ncywgZHJhZ1NldHRpbmdzLCBkcmFnTW9kZWwsIGRyb3BNb2RlbCwgZHJvcEl0ZW0sICRkcmFnZ2FibGUpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGVEcm9wcGFibGUoZHJvcHBhYmxlU2NvcGUsIGRyb3BTZXR0aW5ncywgZHJhZ1NldHRpbmdzLCBkcm9wTW9kZWwsIGRyYWdJdGVtLCBqcXlvdWlfcG9zKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50Q2FsbGJhY2soZHJvcHBhYmxlU2NvcGUsIGRyb3BTZXR0aW5ncy5vbkRyb3AsIGV2ZW50LCB1aSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KSkuZmluYWxseShhbmd1bGFyLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZSgkZHJhZ2dhYmxlKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oJGZyb21FbCwgJHRvRWwsIHRvUG9zLCBkdXJhdGlvbiwgZHJvcFNldHRpbmdzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCRmcm9tRWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHpJbmRleCA9ICRmcm9tRWwuY3NzKCd6LWluZGV4JyksXG4gICAgICAgIGZyb21Qb3MgPSAkZnJvbUVsW2Ryb3BTZXR0aW5ncy5jb250YWlubWVudCB8fCAnb2Zmc2V0J10oKSxcbiAgICAgICAgZGlzcGxheVByb3BlcnR5ID0gJHRvRWwuY3NzKCdkaXNwbGF5JyksIC8vIHNvbWV0aW1lcyBgZGlzcGxheWAgaXMgb3RoZXIgdGhhbiBgYmxvY2tgXG4gICAgICAgIGhhZE5nSGlkZUNscyA9ICR0b0VsLmhhc0NsYXNzKCduZy1oaWRlJyksXG4gICAgICAgIGhhZEROREhpZGVDbHMgPSAkdG9FbC5oYXNDbGFzcygnYW5ndWxhci1kcmFnZHJvcC1oaWRlJyk7XG5cbiAgICAgIGlmICh0b1BvcyA9PT0gbnVsbCAmJiAkdG9FbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgoJHRvRWwuYXR0cignanF5b3VpLWRyYWdnYWJsZScpIHx8ICR0b0VsLmF0dHIoJ2RhdGEtanF5b3VpLWRyYWdnYWJsZScpKSAhPT0gdW5kZWZpbmVkICYmICR0b0VsLm5nYXR0cignbmctbW9kZWwnKSAhPT0gdW5kZWZpbmVkICYmICR0b0VsLmlzKCc6dmlzaWJsZScpICYmIGRyb3BTZXR0aW5ncyAmJiBkcm9wU2V0dGluZ3MubXVsdGlwbGUpIHtcbiAgICAgICAgICB0b1BvcyA9ICR0b0VsW2Ryb3BTZXR0aW5ncy5jb250YWlubWVudCB8fCAnb2Zmc2V0J10oKTtcbiAgICAgICAgICBpZiAoZHJvcFNldHRpbmdzLnN0YWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9Qb3MubGVmdCs9ICR0b0VsLm91dGVyV2lkdGgodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvUG9zLnRvcCs9ICR0b0VsLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbmd1bGFyIHYxLjIgdXNlcyBuZy1oaWRlIHRvIGhpZGUgYW4gZWxlbWVudCBcbiAgICAgICAgICAvLyBzbyB3ZSd2ZSB0byByZW1vdmUgaXQgaW4gb3JkZXIgdG8gZ3JhYiBpdHMgcG9zaXRpb25cbiAgICAgICAgICBpZiAoaGFkTmdIaWRlQ2xzKSAkdG9FbC5yZW1vdmVDbGFzcygnbmctaGlkZScpO1xuICAgICAgICAgIGlmIChoYWRETkRIaWRlQ2xzKSAkdG9FbC5yZW1vdmVDbGFzcygnYW5ndWxhci1kcmFnZHJvcC1oaWRlJyk7XG4gICAgICAgICAgdG9Qb3MgPSAkdG9FbC5jc3Moeyd2aXNpYmlsaXR5JzogJ2hpZGRlbicsICdkaXNwbGF5JzogJ2Jsb2NrJ30pW2Ryb3BTZXR0aW5ncy5jb250YWlubWVudCB8fCAnb2Zmc2V0J10oKTtcbiAgICAgICAgICAkdG9FbC5jc3Moeyd2aXNpYmlsaXR5JzogJycsJ2Rpc3BsYXknOiBkaXNwbGF5UHJvcGVydHl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkZnJvbUVsLmNzcyh7J3Bvc2l0aW9uJzogJ2Fic29sdXRlJywgJ3otaW5kZXgnOiA5OTk5fSlcbiAgICAgICAgLmNzcyhmcm9tUG9zKVxuICAgICAgICAuYW5pbWF0ZSh0b1BvcywgZHVyYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIEFuZ3VsYXIgdjEuMiB1c2VzIG5nLWhpZGUgdG8gaGlkZSBhbiBlbGVtZW50XG4gICAgICAgICAgLy8gYW5kIGFzIHdlIHJlbW92ZSBpdCBhYm92ZSwgd2UndmUgdG8gcHV0IGl0IGJhY2sgdG9cbiAgICAgICAgICAvLyBoaWRlIHRoZSBlbGVtZW50ICh3aGlsZSBzd2FwcGluZykgaWYgaXQgd2FzIGhpZGRlbiBhbHJlYWR5XG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSByZW1vdmUgdGhlIGRpc3BsYXk6bm9uZSBpbiB0aGlzLmludm9rZURyb3AoKVxuICAgICAgICAgIGlmIChoYWROZ0hpZGVDbHMpICR0b0VsLmFkZENsYXNzKCduZy1oaWRlJyk7XG4gICAgICAgICAgaWYgKGhhZEROREhpZGVDbHMpICR0b0VsLmFkZENsYXNzKCdhbmd1bGFyLWRyYWdkcm9wLWhpZGUnKTtcbiAgICAgICAgICAkZnJvbUVsLmNzcygnei1pbmRleCcsIHpJbmRleCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5tdXRhdGVEcm9wcGFibGUgPSBmdW5jdGlvbihzY29wZSwgZHJvcFNldHRpbmdzLCBkcmFnU2V0dGluZ3MsIGRyb3BNb2RlbCwgZHJhZ0l0ZW0sIGpxeW91aV9wb3MpIHtcbiAgICAgIHZhciBkcm9wTW9kZWxWYWx1ZSA9IHNjb3BlLiRldmFsKGRyb3BNb2RlbCk7XG5cbiAgICAgIHNjb3BlLmRuZERyYWdJdGVtID0gZHJhZ0l0ZW07XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoZHJvcE1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGlmIChkcm9wU2V0dGluZ3MgJiYgZHJvcFNldHRpbmdzLmluZGV4ID49IDApIHtcbiAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVtkcm9wU2V0dGluZ3MuaW5kZXhdID0gZHJhZ0l0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJvcE1vZGVsVmFsdWUucHVzaChkcmFnSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyYWdTZXR0aW5ncyAmJiBkcmFnU2V0dGluZ3MucGxhY2Vob2xkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVtkcm9wTW9kZWxWYWx1ZS5sZW5ndGggLSAxXVsnanF5b3VpX3BvcyddID0ganF5b3VpX3BvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHBhcnNlKGRyb3BNb2RlbCArICcgPSBkbmREcmFnSXRlbScpKHNjb3BlKTtcbiAgICAgICAgaWYgKGRyYWdTZXR0aW5ncyAmJiBkcmFnU2V0dGluZ3MucGxhY2Vob2xkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBkcm9wTW9kZWxWYWx1ZVsnanF5b3VpX3BvcyddID0ganF5b3VpX3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm11dGF0ZURyYWdnYWJsZSA9IGZ1bmN0aW9uKHNjb3BlLCBkcm9wU2V0dGluZ3MsIGRyYWdTZXR0aW5ncywgZHJhZ01vZGVsLCBkcm9wTW9kZWwsIGRyb3BJdGVtLCAkZHJhZ2dhYmxlKSB7XG4gICAgICB2YXIgaXNFbXB0eSA9IGFuZ3VsYXIuZXF1YWxzKGRyb3BJdGVtLCB7fSkgfHwgIWRyb3BJdGVtLFxuICAgICAgICBkcmFnTW9kZWxWYWx1ZSA9IHNjb3BlLiRldmFsKGRyYWdNb2RlbCk7XG5cbiAgICAgIHNjb3BlLmRuZERyb3BJdGVtID0gZHJvcEl0ZW07XG5cbiAgICAgIGlmIChkcmFnU2V0dGluZ3MgJiYgZHJhZ1NldHRpbmdzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGlmIChkcmFnU2V0dGluZ3MucGxhY2Vob2xkZXIgIT0gJ2tlZXAnKXtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc0FycmF5KGRyYWdNb2RlbFZhbHVlKSAmJiBkcmFnU2V0dGluZ3MuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHJhZ01vZGVsVmFsdWVbZHJhZ1NldHRpbmdzLmluZGV4XSA9IGRyb3BJdGVtO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcGFyc2UoZHJhZ01vZGVsICsgJyA9IGRuZERyb3BJdGVtJykoc2NvcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheShkcmFnTW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKGRyYWdTZXR0aW5ncyAmJiAoIGRyYWdTZXR0aW5ncy5wbGFjZWhvbGRlciAhPT0gdHJ1ZSAmJiBkcmFnU2V0dGluZ3MucGxhY2Vob2xkZXIgIT09ICdrZWVwJyApKSB7XG4gICAgICAgICAgICAgIGRyYWdNb2RlbFZhbHVlLnNwbGljZShkcmFnU2V0dGluZ3MuaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnTW9kZWxWYWx1ZVtkcmFnU2V0dGluZ3MuaW5kZXhdID0gZHJvcEl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpeDogTElTVChvYmplY3QpIHRvIExJU1QoYXJyYXkpIC0gbW9kZWwgZG9lcyBub3QgZ2V0IHVwZGF0ZWQgdXNpbmcganVzdCBzY29wZVtkcmFnTW9kZWxdID0gey4uLn1cbiAgICAgICAgICAvLyBQLlMuOiBDb3VsZCBub3QgZmlndXJlIG91dCB3aHkgaXQgaGFwcGVuZWRcbiAgICAgICAgICAkcGFyc2UoZHJhZ01vZGVsICsgJyA9IGRuZERyb3BJdGVtJykoc2NvcGUpO1xuICAgICAgICAgIGlmIChzY29wZS4kcGFyZW50KSB7XG4gICAgICAgICAgICAkcGFyc2UoZHJhZ01vZGVsICsgJyA9IGRuZERyb3BJdGVtJykoc2NvcGUuJHBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzdG9yZSgkZHJhZ2dhYmxlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXN0b3JlID0gZnVuY3Rpb24oJGRyYWdnYWJsZSkge1xuICAgICAgJGRyYWdnYWJsZS5jc3Moeyd6LWluZGV4JzogJycsICdsZWZ0JzogJycsICd0b3AnOiAnJ30pO1xuICAgIH07XG5cbiAgICB0aGlzLmZpeEluZGV4ID0gZnVuY3Rpb24oc2NvcGUsIHNldHRpbmdzLCBtb2RlbFZhbHVlKSB7XG4gICAgICBpZiAoc2V0dGluZ3MuYXBwbHlGaWx0ZXIgJiYgYW5ndWxhci5pc0FycmF5KG1vZGVsVmFsdWUpICYmIG1vZGVsVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZHJhZ01vZGVsVmFsdWVGaWx0ZXJlZCA9IHNjb3BlW3NldHRpbmdzLmFwcGx5RmlsdGVyXSgpLFxuICAgICAgICAgICAgbG9va3VwID0gZHJhZ01vZGVsVmFsdWVGaWx0ZXJlZFtzZXR0aW5ncy5pbmRleF0sXG4gICAgICAgICAgICBhY3R1YWxJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBtb2RlbFZhbHVlLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgICAgICAgICBpZiAoYW5ndWxhci5lcXVhbHMoaXRlbSwgbG9va3VwKSkge1xuICAgICAgICAgICAgIGFjdHVhbEluZGV4ID0gaTtcbiAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYWN0dWFsSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR0aW5ncy5pbmRleDtcbiAgICB9O1xuICB9XSkuZGlyZWN0aXZlKCdqcXlvdWlEcmFnZ2FibGUnLCBbJ25nRHJhZ0Ryb3BTZXJ2aWNlJywgZnVuY3Rpb24obmdEcmFnRHJvcFNlcnZpY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZTogJz9qcXlvdWlEcm9wcGFibGUnLFxuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICQoZWxlbSk7XG4gICAgICAgIHZhciBkcmFnU2V0dGluZ3MsIGpxeW91aU9wdGlvbnMsIHpJbmRleCwga2lsbFdhdGNoZXI7XG4gICAgICAgIHZhciB1cGRhdGVEcmFnZ2FibGUgPSBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGRyYWdTZXR0aW5ncyA9IHNjb3BlLiRldmFsKGVsZW1lbnQuYXR0cignanF5b3VpLWRyYWdnYWJsZScpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1qcXlvdWktZHJhZ2dhYmxlJykpIHx8IHt9O1xuICAgICAgICAgICAganF5b3VpT3B0aW9ucyA9IHNjb3BlLiRldmFsKGF0dHJzLmpxeW91aU9wdGlvbnMpIHx8IHt9O1xuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAuZHJhZ2dhYmxlKHtkaXNhYmxlZDogZmFsc2V9KVxuICAgICAgICAgICAgICAuZHJhZ2dhYmxlKGpxeW91aU9wdGlvbnMpXG4gICAgICAgICAgICAgIC5kcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcbiAgICAgICAgICAgICAgICAgIG5nRHJhZ0Ryb3BTZXJ2aWNlLmRyYWdnYWJsZVNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICB6SW5kZXggPSAkKGpxeW91aU9wdGlvbnMuaGVscGVyID8gdWkuaGVscGVyIDogdGhpcykuY3NzKCd6LWluZGV4Jyk7XG4gICAgICAgICAgICAgICAgICAkKGpxeW91aU9wdGlvbnMuaGVscGVyID8gdWkuaGVscGVyIDogdGhpcykuY3NzKCd6LWluZGV4JywgOTk5OSk7XG4gICAgICAgICAgICAgICAgICBqcXlvdWkuc3RhcnRYWSA9ICQodGhpcylbZHJhZ1NldHRpbmdzLmNvbnRhaW5tZW50IHx8ICdvZmZzZXQnXSgpO1xuICAgICAgICAgICAgICAgICAgbmdEcmFnRHJvcFNlcnZpY2UuY2FsbEV2ZW50Q2FsbGJhY2soc2NvcGUsIGRyYWdTZXR0aW5ncy5vblN0YXJ0LCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICAkKGpxeW91aU9wdGlvbnMuaGVscGVyID8gdWkuaGVscGVyIDogdGhpcykuY3NzKCd6LWluZGV4JywgekluZGV4KTtcbiAgICAgICAgICAgICAgICAgIG5nRHJhZ0Ryb3BTZXJ2aWNlLmNhbGxFdmVudENhbGxiYWNrKHNjb3BlLCBkcmFnU2V0dGluZ3Mub25TdG9wLCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHJhZzogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICBuZ0RyYWdEcm9wU2VydmljZS5jYWxsRXZlbnRDYWxsYmFjayhzY29wZSwgZHJhZ1NldHRpbmdzLm9uRHJhZywgZXZlbnQsIHVpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSh7ZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2lsbFdhdGNoZXIgJiYgYW5ndWxhci5pc0RlZmluZWQobmV3VmFsdWUpICYmIChhbmd1bGFyLmVxdWFscyhhdHRycy5kcmFnLCAndHJ1ZScpIHx8IGFuZ3VsYXIuZXF1YWxzKGF0dHJzLmRyYWcsICdmYWxzZScpKSkge1xuICAgICAgICAgICAga2lsbFdhdGNoZXIoKTtcbiAgICAgICAgICAgIGtpbGxXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAga2lsbFdhdGNoZXIgPSBzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiBzY29wZS4kZXZhbChhdHRycy5kcmFnKTsgfSwgdXBkYXRlRHJhZ2dhYmxlKTtcbiAgICAgICAgdXBkYXRlRHJhZ2dhYmxlKCk7XG5cbiAgICAgICAgZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSh7ZGlzYWJsZWQ6IHRydWV9KS5kcmFnZ2FibGUoJ2Rlc3Ryb3knKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pLmRpcmVjdGl2ZSgnanF5b3VpRHJvcHBhYmxlJywgWyduZ0RyYWdEcm9wU2VydmljZScsICckcScsIGZ1bmN0aW9uKG5nRHJhZ0Ryb3BTZXJ2aWNlLCAkcSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKGVsZW0pO1xuICAgICAgICB2YXIgZHJvcFNldHRpbmdzLCBqcXlvdWlPcHRpb25zLCBraWxsV2F0Y2hlcjtcbiAgICAgICAgdmFyIHVwZGF0ZURyb3BwYWJsZSA9IGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZHJvcFNldHRpbmdzID0gc2NvcGUuJGV2YWwoJChlbGVtZW50KS5hdHRyKCdqcXlvdWktZHJvcHBhYmxlJykgfHwgJChlbGVtZW50KS5hdHRyKCdkYXRhLWpxeW91aS1kcm9wcGFibGUnKSkgfHwge307XG4gICAgICAgICAgICBqcXlvdWlPcHRpb25zID0gc2NvcGUuJGV2YWwoYXR0cnMuanF5b3VpT3B0aW9ucykgfHwge307XG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgIC5kcm9wcGFibGUoe2Rpc2FibGVkOiBmYWxzZX0pXG4gICAgICAgICAgICAgIC5kcm9wcGFibGUoanF5b3VpT3B0aW9ucylcbiAgICAgICAgICAgICAgLmRyb3BwYWJsZSh7XG4gICAgICAgICAgICAgICAgb3ZlcjogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICBuZ0RyYWdEcm9wU2VydmljZS5jYWxsRXZlbnRDYWxsYmFjayhzY29wZSwgZHJvcFNldHRpbmdzLm9uT3ZlciwgZXZlbnQsIHVpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG91dDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICBuZ0RyYWdEcm9wU2VydmljZS5jYWxsRXZlbnRDYWxsYmFjayhzY29wZSwgZHJvcFNldHRpbmdzLm9uT3V0LCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHJvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlRHJvcFByb21pc2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZHJvcFNldHRpbmdzLmJlZm9yZURyb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRHJvcFByb21pc2UgPSBuZ0RyYWdEcm9wU2VydmljZS5jYWxsRXZlbnRDYWxsYmFjayhzY29wZSwgZHJvcFNldHRpbmdzLmJlZm9yZURyb3AsIGV2ZW50LCB1aSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVEcm9wUHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYmVmb3JlRHJvcFByb21pc2UudGhlbihhbmd1bGFyLmJpbmQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHVpLmRyYWdnYWJsZSkubmdhdHRyKCduZy1tb2RlbCcpICYmIGF0dHJzLm5nTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZ0RyYWdEcm9wU2VydmljZS5kcm9wcGFibGVTY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgIG5nRHJhZ0Ryb3BTZXJ2aWNlLmludm9rZURyb3AoJCh1aS5kcmFnZ2FibGUpLCAkKHRoaXMpLCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG5nRHJhZ0Ryb3BTZXJ2aWNlLmNhbGxFdmVudENhbGxiYWNrKHNjb3BlLCBkcm9wU2V0dGluZ3Mub25Ecm9wLCBldmVudCwgdWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRyYWdnYWJsZS5hbmltYXRlKHtsZWZ0OiAnJywgdG9wOiAnJ30sIGpxeW91aU9wdGlvbnMucmV2ZXJ0RHVyYXRpb24gfHwgMCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmRyb3BwYWJsZSh7ZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2lsbFdhdGNoZXIgJiYgYW5ndWxhci5pc0RlZmluZWQobmV3VmFsdWUpICYmIChhbmd1bGFyLmVxdWFscyhhdHRycy5kcm9wLCAndHJ1ZScpIHx8IGFuZ3VsYXIuZXF1YWxzKGF0dHJzLmRyb3AsICdmYWxzZScpKSkge1xuICAgICAgICAgICAga2lsbFdhdGNoZXIoKTtcbiAgICAgICAgICAgIGtpbGxXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAga2lsbFdhdGNoZXIgPSBzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiBzY29wZS4kZXZhbChhdHRycy5kcm9wKTsgfSwgdXBkYXRlRHJvcHBhYmxlKTtcbiAgICAgICAgdXBkYXRlRHJvcHBhYmxlKCk7XG4gICAgICAgIFxuICAgICAgICBlbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnQuZHJvcHBhYmxlKHtkaXNhYmxlZDogdHJ1ZX0pLmRyb3BwYWJsZSgnZGVzdHJveScpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbiAgJC5mbi5uZ2F0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSk7XG4gIH07XG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyLCB3aW5kb3cualF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3h1Z2UvcHJvamVjdC9xdWFuc2hpLXVpL34vYW5ndWxhci1kcmFnZHJvcC9zcmMvYW5ndWxhci1kcmFnZHJvcC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAyXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL2RlZmF1bHRfbG9nby5wbmdcIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL2ltYWdlcy9kZWZhdWx0X2xvZ28ucG5nXG4gKiogbW9kdWxlIGlkID0gMzQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDIgNSA2XG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==