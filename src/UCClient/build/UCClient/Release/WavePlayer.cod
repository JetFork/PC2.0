; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\WavePlayer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__ResumeThread@4:PROC
EXTRN	__imp__waveOutClose@4:PROC
EXTRN	__imp__waveOutWrite@12:PROC
EXTRN	__imp__waveOutPause@4:PROC
EXTRN	__imp__waveOutRestart@4:PROC
EXTRN	__imp__waveOutReset@4:PROC
EXTRN	__imp__waveOutSetVolume@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__waveOutUnprepareHeader@12:PROC
EXTRN	__imp__waveOutOpen@24:PROC
EXTRN	__imp__waveOutPrepareHeader@12:PROC
CONST	ENDS
PUBLIC	?OnPlayFinished@WavePlayer@@IAEXXZ		; WavePlayer::OnPlayFinished
PUBLIC	?DecodeThreadProcImpl@WavePlayer@@IAEIXZ	; WavePlayer::DecodeThreadProcImpl
PUBLIC	?DecodeThread@WavePlayer@@KGIPAX@Z		; WavePlayer::DecodeThread
PUBLIC	?PlayThreadProcImpl@WavePlayer@@IAEIXZ		; WavePlayer::PlayThreadProcImpl
PUBLIC	?PlayThread@WavePlayer@@KGIPAX@Z		; WavePlayer::PlayThread
PUBLIC	?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ; WavePlayer::WaveOutProcImpl
PUBLIC	?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ; WavePlayer::WaveOutProc
PUBLIC	?UnInit@WavePlayer@@IAEXXZ			; WavePlayer::UnInit
PUBLIC	?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z	; WavePlayer::freeBlocks
PUBLIC	?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ; WavePlayer::allocBlocks
PUBLIC	?ceil@@YAMM@Z					; ceil
PUBLIC	_ceilf
PUBLIC	?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z ; WavePlayer::SetCallback
PUBLIC	?Stop@WavePlayer@@QAEXXZ			; WavePlayer::Stop
PUBLIC	?Play@WavePlayer@@QAEXPB_WPAK@Z			; WavePlayer::Play
PUBLIC	??1WavePlayer@@QAE@XZ				; WavePlayer::~WavePlayer
PUBLIC	??0WavePlayer@@QAE@XZ				; WavePlayer::WavePlayer
_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0WavePlayer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0WavePlayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0WavePlayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0WavePlayer@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Play@WavePlayer@@QAEXPB_WPAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Play@WavePlayer@@QAEXPB_WPAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Play@WavePlayer@@QAEXPB_WPAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Play@WavePlayer@@QAEXPB_WPAK@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ??0WavePlayer@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0WavePlayer@@QAE@XZ PROC				; WavePlayer::WavePlayer, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0WavePlayer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	0f 57 c0	 xorps	 xmm0, xmm0
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 27   :     memset(&m_waveData, 0, sizeof(WaveData));
; 28   : 
; 29   :     // 为播放缓存申请内存堆
; 30   :     m_wBlock.pWaveHdr   = allocBlocks( BLOCK_SIZE, BLOCK_COUNT );

  00036	83 ec 08	 sub	 esp, 8
  00039	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00040	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00047	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004e	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  00055	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0005c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00063	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  0006a	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0
  00071	f3 0f 7f 46 24	 movdqu	 XMMWORD PTR [esi+36], xmm0
  00076	f3 0f 7f 46 34	 movdqu	 XMMWORD PTR [esi+52], xmm0
  0007b	e8 00 00 00 00	 call	 ?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ; WavePlayer::allocBlocks

; 31   :     m_wBlock.wfreeblock = BLOCK_COUNT;
; 32   :     m_wBlock.wcurrblock = 0;
; 33   :     m_wBlock.wpos       = 0;
; 34   : 
; 35   :     m_hEventDecode = CreateEvent(NULL, FALSE, FALSE, NULL);

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00089	6a 00		 push	 0
  0008b	c7 46 1c 14 00
	00 00		 mov	 DWORD PTR [esi+28], 20	; 00000014H
  00092	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00099	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventW@16

; 38   :     m_pDecoder = new AMRFileDecoder();

  000a6	6a 40		 push	 64			; 00000040H
  000a8	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  000b1	83 c4 04	 add	 esp, 4
  000b4	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000be	85 c0		 test	 eax, eax
  000c0	74 46		 je	 SHORT $LN3@WavePlayer
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 36   : {

  000c2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7AMRFileDecoder@@6B@
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000c8	33 c9		 xor	 ecx, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\decoder\amrfiledecoder.cpp

; 36   : {

  000ca	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000d1	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000d8	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  000df	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  000e6	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  000ed	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  000f4	c7 40 38 07 00
	00 00		 mov	 DWORD PTR [eax+56], 7

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000fb	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00102	66 89 48 24	 mov	 WORD PTR [eax+36], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp

; 38   :     m_pDecoder = new AMRFileDecoder();

  00106	eb 02		 jmp	 SHORT $LN4@WavePlayer
$LN3@WavePlayer:
  00108	33 c0		 xor	 eax, eax
$LN4@WavePlayer:
  0010a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00111	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 39   :     ATLASSERT(m_pDecoder);
; 40   : 
; 41   :     // 初始化临界区
; 42   :     InitializeCriticalSection(&m_cs);

  00114	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  00117	50		 push	 eax
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 43   : }

  0011e	8b c6		 mov	 eax, esi
  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	5e		 pop	 esi
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0WavePlayer@@QAE@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
__ehhandler$??0WavePlayer@@QAE@XZ:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0WavePlayer@@QAE@XZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0WavePlayer@@QAE@XZ ENDP				; WavePlayer::WavePlayer
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ??1WavePlayer@@QAE@XZ
_TEXT	SEGMENT
??1WavePlayer@@QAE@XZ PROC				; WavePlayer::~WavePlayer, COMDAT
; _this$ = ecx

; 46   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 47   :     UnInit();

  00003	e8 00 00 00 00	 call	 ?UnInit@WavePlayer@@IAEXXZ ; WavePlayer::UnInit

; 62   : 
; 63   : //************************************
; 64   : // Method:    申请播放缓存
; 65   : // FullName:  WavePlayer::allocBlocks
; 66   : // Access:    protected 
; 67   : // Returns:   WAVEHDR*
; 68   : // Parameter: int size，每块波形数据缓存的大小
; 69   : // Parameter: int count，缓存块数
; 70   : //************************************
; 71   : WAVEHDR* WavePlayer::allocBlocks(int size, int count)
; 72   : {
; 73   :     unsigned char* buffer;
; 74   :     int i;
; 75   :     WAVEHDR* blocks;
; 76   :     DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;
; 77   : 
; 78   :     //  一次性分配所有缓存，不需多次申请，释放简单
; 79   :     if((buffer = ( UCHAR*) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, totalBufferSize )) == NULL)	
; 80   :         return NULL;
; 81   : 
; 82   :     // 设置缓存数据指针
; 83   :     blocks = (WAVEHDR*)buffer;
; 84   :     buffer += sizeof(WAVEHDR) * count;
; 85   :     for(i = 0; i < count; i++) 
; 86   :     {
; 87   :         blocks[i].dwBufferLength = size;
; 88   :         blocks[i].lpData = (CHAR *)buffer;
; 89   :         buffer += size;
; 90   :     }
; 91   : 
; 92   :     return blocks;
; 93   : }
; 94   : 
; 95   : //************************************
; 96   : // Method:    释放播放缓存
; 97   : // FullName:  WavePlayer::freeBlocks
; 98   : // Access:    protected 
; 99   : // Returns:   void
; 100  : // Parameter: WAVEHDR * blockArray
; 101  : //************************************
; 102  : void WavePlayer::freeBlocks(WAVEHDR* blockArray)
; 103  : {
; 104  :     HeapFree(GetProcessHeap(), 0, blockArray);

  00008	ff 76 18	 push	 DWORD PTR [esi+24]
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  0001a	0f 57 c0	 xorps	 xmm0, xmm0

; 48   : 
; 49   :     // 释放播放缓存
; 50   :     freeBlocks( m_wBlock.pWaveHdr );
; 51   :     memset(&m_wBlock, 0, sizeof(WaveBlock));

  0001d	f3 0f 7f 46 14	 movdqu	 XMMWORD PTR [esi+20], xmm0

; 52   : 
; 53   :     if(m_hEventDecode)

  00022	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00025	85 c0		 test	 eax, eax
  00027	74 0e		 je	 SHORT $LN1@WavePlayer

; 54   :     {
; 55   :         CloseHandle(m_hEventDecode);

  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 56   :         m_hEventDecode = NULL;

  00030	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN1@WavePlayer:

; 57   :     }
; 58   : 
; 59   :     // 销毁临界区
; 60   :     DeleteCriticalSection( &m_cs );

  00037	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00041	5e		 pop	 esi

; 61   : }

  00042	c3		 ret	 0
??1WavePlayer@@QAE@XZ ENDP				; WavePlayer::~WavePlayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Play@WavePlayer@@QAEXPB_WPAK@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 18
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpszFile$ = 8						; size = 4
_pLength$ = 12						; size = 4
?Play@WavePlayer@@QAEXPB_WPAK@Z PROC			; WavePlayer::Play, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Play@WavePlayer@@QAEXPB_WPAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx

; 159  :     // 如果已经有播放的了，先停止
; 160  :     if(m_ePlayStat != Play_Stop)

  0002d	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpszFile$[ebp]
  00034	8b 7d 0c	 mov	 edi, DWORD PTR _pLength$[ebp]
  00037	74 22		 je	 SHORT $LN14@Play

; 214  : 
; 215  : void WavePlayer::Pause()
; 216  : {
; 217  :     if(m_hWaveoutDev)
; 218  :         waveOutPause(m_hWaveoutDev);
; 219  : }
; 220  : 
; 221  : void WavePlayer::Resume()
; 222  : {
; 223  :     if(m_hWaveoutDev)
; 224  :         waveOutRestart(m_hWaveoutDev);
; 225  : }
; 226  : void WavePlayer::Stop()
; 227  : {
; 228  :     m_ePlayStat = Play_Stop;

  00039	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 229  : 
; 230  :     UnInit();

  00040	e8 00 00 00 00	 call	 ?UnInit@WavePlayer@@IAEXXZ ; WavePlayer::UnInit

; 231  : 
; 232  :     OnPlayFinished();
; 233  : }
; 234  : 
; 235  : void WavePlayer::SetVolume(DWORD dwVolume)
; 236  : {
; 237  :     waveOutSetVolume(m_hWaveoutDev, dwVolume);
; 238  : }
; 239  : 
; 240  : DWORD WavePlayer::GetAudioLength(LPCTSTR lpszFile)
; 241  : {
; 242  :     // 设置解码器
; 243  :     if(m_pDecoder == NULL)
; 244  :     {
; 245  :         m_pDecoder = new AMRFileDecoder(lpszFile);
; 246  :     }
; 247  :     else
; 248  :     {
; 249  :         m_pDecoder->SetFilePathName(lpszFile);
; 250  :     }
; 251  : 
; 252  :     DWORD dwTimeLength = 0;
; 253  :     if(m_pDecoder)
; 254  :     {
; 255  :         dwTimeLength = (DWORD)m_pDecoder->GetTimeLength();
; 256  :     }
; 257  :    
; 258  :     return dwTimeLength;
; 259  : }
; 260  : 
; 261  : BOOL WavePlayer::WaveOutProc(HWAVEOUT hwo, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
; 262  : {
; 263  :     WavePlayer* pPlayer = (WavePlayer*)dwInstance;
; 264  : 
; 265  :     return pPlayer->WaveOutProcImpl(hwo, uMsg, dwParam1, dwParam2);
; 266  : }
; 267  : 
; 268  : BOOL WavePlayer::WaveOutProcImpl(HWAVEOUT hwo, UINT uMsg, DWORD dwParam1, DWORD dwParam2)
; 269  : {
; 270  :     // 忽略打开和关闭设备时的处理
; 271  :     if(uMsg == WOM_DONE)
; 272  :     {
; 273  :         // 每一块播放完之后，意味着空闲缓存块数增加
; 274  :         EnterCriticalSection(&m_cs);
; 275  :         ++m_wBlock.wfreeblock;
; 276  : 		if (m_soundCB)
; 277  : 		{
; 278  : 			WAVEFORMATEX wfmtx = m_pDecoder->GetWaveFromatX();
; 279  : 			int interval = (BLOCK_SIZE * 1000) / wfmtx.nAvgBytesPerSec;
; 280  : 			int total = ceil(float(m_pDecoder->GetTimeLength()) / interval);
; 281  : 			int percent = ++m_notification * 100 / total;
; 282  : 			m_soundCB->onPlayingNotification(percent > 100 ? 100 : percent, (float)m_pDecoder->GetTimeLength() / 1000, m_cbData);
; 283  : 		}
; 284  : 		LeaveCriticalSection(&m_cs);
; 285  :     }
; 286  : 
; 287  :     return TRUE;
; 288  : }
; 289  : 
; 290  : unsigned int WavePlayer::PlayThread( LPVOID lp )
; 291  : {
; 292  :     WavePlayer *pPlayer = ( WavePlayer *)lp;
; 293  : 
; 294  :     return pPlayer->PlayThreadProcImpl();
; 295  : }
; 296  : 
; 297  : unsigned int WavePlayer::PlayThreadProcImpl()
; 298  : {
; 299  :     /// 定义为寄存器变量，因为它将会被高频率的使用，用于编译器优化
; 300  :     register    ThreadMsg       tmsg  = TMSG_ALIVE;         
; 301  : 
; 302  :     /// 线程循环
; 303  :     while( tmsg )
; 304  :     {
; 305  :         // 每次循环后，交出CPU控制权，放在此处，因为下面有continue语句
; 306  :         Sleep(10);
; 307  : 
; 308  :         /// 首先检查线程消息
; 309  :         EnterCriticalSection( &m_cs );
; 310  :         tmsg = m_msgPlayThread;
; 311  :         LeaveCriticalSection( &m_cs );
; 312  :         // 线程要结束，退出线程循环
; 313  :         if(!tmsg)   break;
; 314  : 
; 315  :         // 如果设备为空，表示还没有打开设备，需要打开设备
; 316  :         if(m_hWaveoutDev == NULL)
; 317  :         {
; 318  :             EnterCriticalSection(&m_cs);
; 319  :             MMRESULT mmres = waveOutOpen(&m_hWaveoutDev, WAVE_MAPPER, &m_waveData.wfmtx, (DWORD_PTR)WaveOutProc, (DWORD_PTR)this, CALLBACK_FUNCTION);
; 320  :             LeaveCriticalSection(&m_cs);
; 321  :             if(mmres != MMSYSERR_NOERROR)
; 322  :             {
; 323  :                 // failed, try again.
; 324  :                 continue;
; 325  :             }
; 326  :         }
; 327  :         
; 328  :         // 检查空闲缓存块
; 329  :         EnterCriticalSection( &m_cs );
; 330  :         int free = m_wBlock.wfreeblock;
; 331  :         LeaveCriticalSection( &m_cs );
; 332  : 
; 333  :         // 如果没有空闲的缓存了，等待...
; 334  :         if(free < BP_TURN)
; 335  :         {
; 336  :             continue;
; 337  :         }
; 338  : 
; 339  :         /////////////////////////////////////////////////////////////////////////
; 340  :         /////////////////////////////////////////////////////////////////////////
; 341  :         ///                       < 播放主循环 >                              ///
; 342  :         /////////////////////////////////////////////////////////////////////////
; 343  :         /////////////////////////////////////////////////////////////////////////
; 344  : 
; 345  :         WAVEHDR     *current = NULL;
; 346  : 
; 347  :         /// BP_TURN为每次写入播放队列的块数
; 348  :         for( unsigned int m = 0; m < BP_TURN; m++ )
; 349  :         {   
; 350  :             /// 当前空闲播放缓存块
; 351  :             current = &m_wBlock.pWaveHdr[m_wBlock.wcurrblock]; 
; 352  : 
; 353  :             // 首先需要检查有没有被Unprepare掉
; 354  :             if( current->dwFlags & WHDR_PREPARED )
; 355  :             {
; 356  :                 waveOutUnprepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );
; 357  :             }
; 358  : 
; 359  :             /// 计算剩余需要播放的数据
; 360  :             EnterCriticalSection(&m_cs);
; 361  :             unsigned long left  = m_waveData.dwSize - m_wBlock.wpos;
; 362  :             unsigned int bDecodeFinished = m_waveData.bDecodeFinished;
; 363  :             LeaveCriticalSection(&m_cs);
; 364  :             unsigned long chunk = 0;
; 365  : 
; 366  :             if( left  >= BLOCK_SIZE )
; 367  :             {
; 368  :                 chunk  = BLOCK_SIZE;
; 369  :             }
; 370  :             else if(!bDecodeFinished)
; 371  :             {
; 372  :                 // 如果解码还没有结束，现有的数据量有不足以填满一个缓存块，先不写入缓存
; 373  :                 break;
; 374  :             }
; 375  :             else if( left && left < BLOCK_SIZE)
; 376  :             {
; 377  :                 chunk  = left;
; 378  :             }
; 379  :             else
; 380  :             {   
; 381  :                 //////////////////////////////////////////////////////////////////////
; 382  :                 ///                 < 播放完成>                                    ///
; 383  :                 //////////////////////////////////////////////////////////////////////
; 384  : 
; 385  :                 /// 获取空闲缓存块数量
; 386  :                 EnterCriticalSection( &m_cs );
; 387  :                 int free = m_wBlock.wfreeblock;
; 388  :                 LeaveCriticalSection( &m_cs );
; 389  : 
; 390  :                 /// 当所有的缓存块都播放完了，才意味着播放真正完成
; 391  :                 if( free == BLOCK_COUNT )
; 392  :                 {
; 393  :                     /// Unprepare缓存块
; 394  :                     for( int j = 0; j < m_wBlock.wfreeblock; j++) 
; 395  :                     {
; 396  :                         if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )
; 397  :                         {
; 398  :                             waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));
; 399  :                         }
; 400  :                     }
; 401  : 
; 402  :                     // 此时，才算真正的播放完成，关闭线程
; 403  :                     tmsg = TMSG_CLOSE;
; 404  :                     // 处理播放完成事件
; 405  :                     OnPlayFinished();
; 406  :                 }
; 407  : 
; 408  :                 // 此break仅跳出该循环，没有跳出线程循环
; 409  :                 break;
; 410  :             }
; 411  : 
; 412  :             /// prepare current wave data block header
; 413  :             EnterCriticalSection(&m_cs);
; 414  :             memcpy( current->lpData, &m_waveData.pData[m_wBlock.wpos], chunk );
; 415  :             LeaveCriticalSection(&m_cs);
; 416  : 
; 417  :             current->dwBufferLength  = chunk;   // sizeof block
; 418  :             m_wBlock.wpos           += chunk;   // update position
; 419  : 
; 420  :             /// prepare for playback
; 421  :             waveOutPrepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );
; 422  : 
; 423  :             /// push to the queue
; 424  :             waveOutWrite(m_hWaveoutDev, current, sizeof(WAVEHDR));
; 425  : 
; 426  :             /// 减小空闲块计数
; 427  :             EnterCriticalSection( &m_cs );
; 428  :             m_wBlock.wfreeblock--;
; 429  :             LeaveCriticalSection( &m_cs );
; 430  : 
; 431  :             /// 使当前空闲块指向下一个
; 432  :             m_wBlock.wcurrblock++;
; 433  :             m_wBlock.wcurrblock %= BLOCK_COUNT;
; 434  :         }
; 435  : 
; 436  :     }/// thread
; 437  : 
; 438  :     ///////////////////////////////////////////////////////////////////////////////
; 439  :     ///////////////////////////////////////////////////////////////////////////////
; 440  :     ///
; 441  :     ///            < force to close device which are still playing > 
; 442  :     ///////////////////////////////////////////////////////////////////////////////
; 443  :     ///////////////////////////////////////////////////////////////////////////////
; 444  :     if(m_hWaveoutDev)
; 445  :     {
; 446  :         waveOutReset( m_hWaveoutDev );
; 447  : 
; 448  :         /// unprepare any blocks that are still prepared
; 449  :         for( int j = 0; j < BLOCK_COUNT; j++) 
; 450  :         {
; 451  :             if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )
; 452  :             {
; 453  :                 waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));
; 454  :             }
; 455  :         }
; 456  : 
; 457  :         waveOutClose(m_hWaveoutDev);
; 458  :         m_hWaveoutDev = NULL;
; 459  :     }
; 460  : 
; 461  :     return THREAD_EXIT;
; 462  : }
; 463  : 
; 464  : unsigned int WavePlayer::DecodeThread(LPVOID lp)
; 465  : {
; 466  :     WavePlayer* pThis = (WavePlayer*)lp;
; 467  : 
; 468  :     return pThis->DecodeThreadProcImpl();
; 469  : }
; 470  : 
; 471  : unsigned int WavePlayer::DecodeThreadProcImpl()
; 472  : {
; 473  :     if(m_pDecoder == NULL || !m_pDecoder->IsVaild())
; 474  : 	{
; 475  : 		SetEvent(m_hEventDecode);
; 476  :         return 0;
; 477  : 	}
; 478  : 
; 479  :     // 开始解码，初始化解码器
; 480  :     if(!m_pDecoder->BeginDecode())
; 481  :     {
; 482  : 		SetEvent(m_hEventDecode);
; 483  :         return 0;
; 484  :     }
; 485  : 
; 486  :     // 申请临时内存块，存储解码后的波形数据
; 487  :     DWORD dwFrameMaxSize = m_pDecoder->GetDecodedFrameMaxSize();
; 488  :     LPSTR pBufferBase = (LPSTR)malloc(dwFrameMaxSize);
; 489  :     ATLASSERT(pBufferBase);
; 490  :     memset(pBufferBase, 0, dwFrameMaxSize);
; 491  :     if(pBufferBase == NULL) return 0;
; 492  : 
; 493  :     register ThreadMsg tmsg = TMSG_ALIVE;
; 494  : 
; 495  :     DWORD dwSizeAmount = 0;
; 496  :     while(!m_pDecoder->IsEOF() && tmsg)
; 497  :     {
; 498  :         // 解码，每帧
; 499  :         DWORD dwSize = m_pDecoder->Decode(pBufferBase);
; 500  :         dwSizeAmount += dwSize;
; 501  : 
; 502  :         // 将解码后数据写入缓存区，供播放线程使用
; 503  :         EnterCriticalSection(&m_cs);           
; 504  :         memcpy(m_waveData.pData + m_waveData.dwSize, pBufferBase, dwSize);
; 505  :         m_waveData.dwSize += dwSize;
; 506  :         LeaveCriticalSection(&m_cs);
; 507  : 
; 508  :         // 当解码数据量操作了一个播放缓存时，发个信号，通知可以开始播放了
; 509  :         if(dwSizeAmount > BLOCK_SIZE)
; 510  :         {
; 511  :             dwSizeAmount = 0;
; 512  :             SetEvent(m_hEventDecode);
; 513  :         }
; 514  : 
; 515  :         // 节省CPU时间，让CPU有时间去干别的事儿
; 516  :         Sleep(1);
; 517  : 
; 518  :         // 检测线程是否将被强制退出
; 519  :         EnterCriticalSection(&m_cs);
; 520  :         tmsg = m_msgDecodeThread;
; 521  :         LeaveCriticalSection(&m_cs);
; 522  :     }
; 523  : 
; 524  :     // 如果数据量很小，根本不足一个播放缓存，也要发个信号
; 525  :     if(dwSizeAmount > 0)
; 526  :     {
; 527  :         SetEvent(m_hEventDecode);
; 528  :     }
; 529  : 
; 530  :     m_waveData.bDecodeFinished = true;
; 531  : 
; 532  :     // 解码结束
; 533  :     m_pDecoder->EndDecode();
; 534  : 
; 535  :     free(pBufferBase);
; 536  :     pBufferBase = NULL;
; 537  : 
; 538  :     return 0;
; 539  : }
; 540  : 
; 541  : void WavePlayer::SetCallback(ISoundCallBack *psoundCB, long cbData)
; 542  : {
; 543  : 	m_soundCB = psoundCB;
; 544  : 	m_cbData = cbData;
; 545  : }
; 546  : 
; 547  : void WavePlayer::OnPlayFinished()
; 548  : {
; 549  : 	m_ePlayStat = Play_Stop;
; 550  : 
; 551  : 	if (m_soundCB)

  00045	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  00048	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0004f	85 c9		 test	 ecx, ecx
  00051	74 08		 je	 SHORT $LN14@Play

; 552  : 		m_soundCB->onSoundPlayed(m_cbData);

  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 73 6c	 push	 DWORD PTR [ebx+108]
  00058	ff 50 04	 call	 DWORD PTR [eax+4]
$LN14@Play:

; 161  :     {
; 162  :         Stop();
; 163  :     }
; 164  : 
; 165  :     // 设置解码器
; 166  :     if(m_pDecoder == NULL)

  0005b	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  0005e	85 c9		 test	 ecx, ecx
  00060	75 3b		 jne	 SHORT $LN5@Play

; 167  :     {
; 168  :         m_pDecoder = new AMRFileDecoder(lpszFile);

  00062	6a 40		 push	 64			; 00000040H
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00077	85 c0		 test	 eax, eax
  00079	74 14		 je	 SHORT $LN9@Play
  0007b	56		 push	 esi
  0007c	8b c8		 mov	 ecx, eax
  0007e	e8 00 00 00 00	 call	 ??0AMRFileDecoder@@QAE@PB_W@Z ; AMRFileDecoder::AMRFileDecoder
  00083	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 169  :     }
; 170  :     else

  0008d	eb 14		 jmp	 SHORT $LN4@Play
$LN9@Play:

; 167  :     {
; 168  :         m_pDecoder = new AMRFileDecoder(lpszFile);

  0008f	33 c0		 xor	 eax, eax
  00091	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00098	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 169  :     }
; 170  :     else

  0009b	eb 06		 jmp	 SHORT $LN4@Play
$LN5@Play:

; 171  :     {
; 172  :         m_pDecoder->SetFilePathName(lpszFile);

  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	56		 push	 esi
  000a0	ff 50 04	 call	 DWORD PTR [eax+4]
$LN4@Play:

; 173  :     }
; 174  : 
; 175  :     // 取播放时间
; 176  :     if(pLength)

  000a3	85 ff		 test	 edi, edi
  000a5	74 0c		 je	 SHORT $LN3@Play

; 177  :     {
; 178  :         *pLength = (DWORD)m_pDecoder->GetTimeLength();

  000a7	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ac	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000af	ff d0		 call	 eax
  000b1	89 07		 mov	 DWORD PTR [edi], eax
$LN3@Play:

; 179  :     }
; 180  : 	m_notification = 0;
; 181  : 
; 182  :     // 申请解码后的数据堆内存块
; 183  :     DWORD dwWaveMaxSize = m_pDecoder->GetDecodedMaxSize();

  000b3	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000b6	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [ebx+112], 0
  000bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  000bf	ff 50 24	 call	 DWORD PTR [eax+36]

; 184  :     EnterCriticalSection(&m_cs);

  000c2	8d 7b 50	 lea	 edi, DWORD PTR [ebx+80]
  000c5	8b f0		 mov	 esi, eax
  000c7	57		 push	 edi
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 185  :     m_waveData.wfmtx = m_pDecoder->GetWaveFromatX();

  000ce	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000d1	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  000d4	50		 push	 eax
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	ff 52 0c	 call	 DWORD PTR [edx+12]

; 186  :     m_waveData.pData = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwWaveMaxSize);

  000da	56		 push	 esi
  000db	6a 08		 push	 8
  000dd	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  000e1	f3 0f 7f 43 24	 movdqu	 XMMWORD PTR [ebx+36], xmm0
  000e6	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]
  000ea	66 89 43 34	 mov	 WORD PTR [ebx+52], ax
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 187  :     LeaveCriticalSection(&m_cs);

  000fb	57		 push	 edi
  000fc	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 188  : 
; 189  :     // 设置回调函数
; 190  : 
; 191  :     // 创建解码线程
; 192  :     if(m_hThreadDecode == NULL)

  00105	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00109	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateThread@24
  0010f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ResumeThread@4
  00115	75 1d		 jne	 SHORT $LN2@Play

; 193  :     {
; 194  :         m_msgDecodeThread = TMSG_ALIVE;
; 195  :         m_hThreadDecode = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DecodeThread, (LPVOID)this, CREATE_SUSPENDED, NULL);

  00117	6a 00		 push	 0
  00119	6a 04		 push	 4
  0011b	53		 push	 ebx
  0011c	68 00 00 00 00	 push	 OFFSET ?DecodeThread@WavePlayer@@KGIPAX@Z ; WavePlayer::DecodeThread
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	c7 43 48 01 00
	00 00		 mov	 DWORD PTR [ebx+72], 1
  0012c	ff d6		 call	 esi

; 196  :         ATLASSERT(m_hThreadDecode);
; 197  :         ResumeThread(m_hThreadDecode);

  0012e	50		 push	 eax
  0012f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00132	ff d7		 call	 edi
$LN2@Play:

; 198  :     }
; 199  : 
; 200  :     // 等待解码缓存信号
; 201  :     WaitForSingleObject(m_hEventDecode, INFINITE);

  00134	6a ff		 push	 -1
  00136	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 202  : 
; 203  :     // 创建播放线程
; 204  :     if(m_hThreadPlay == NULL)

  0013f	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00142	75 1c		 jne	 SHORT $LN17@Play

; 205  :     {
; 206  :         m_msgPlayThread = TMSG_ALIVE;
; 207  :         m_hThreadPlay = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (LPVOID)this, CREATE_SUSPENDED, NULL );

  00144	6a 00		 push	 0
  00146	6a 04		 push	 4
  00148	53		 push	 ebx
  00149	68 00 00 00 00	 push	 OFFSET ?PlayThread@WavePlayer@@KGIPAX@Z ; WavePlayer::PlayThread
  0014e	6a 00		 push	 0
  00150	6a 00		 push	 0
  00152	c7 43 44 01 00
	00 00		 mov	 DWORD PTR [ebx+68], 1
  00159	ff d6		 call	 esi

; 208  :         ATLASSERT(m_hThreadPlay);
; 209  :         ResumeThread(m_hThreadPlay);

  0015b	50		 push	 eax
  0015c	89 03		 mov	 DWORD PTR [ebx], eax
  0015e	ff d7		 call	 edi
$LN17@Play:

; 210  :     }
; 211  : 
; 212  :     m_ePlayStat = Play_Playing;

  00160	c7 43 08 02 00
	00 00		 mov	 DWORD PTR [ebx+8], 2

; 213  : }

  00167	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00171	59		 pop	 ecx
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Play@WavePlayer@@QAEXPB_WPAK@Z$0:
  00000	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
__ehhandler$?Play@WavePlayer@@QAEXPB_WPAK@Z:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Play@WavePlayer@@QAEXPB_WPAK@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Play@WavePlayer@@QAEXPB_WPAK@Z ENDP			; WavePlayer::Play
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?Stop@WavePlayer@@QAEXXZ
_TEXT	SEGMENT
?Stop@WavePlayer@@QAEXXZ PROC				; WavePlayer::Stop, COMDAT
; _this$ = ecx

; 227  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 228  :     m_ePlayStat = Play_Stop;

  00003	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 229  : 
; 230  :     UnInit();

  0000a	e8 00 00 00 00	 call	 ?UnInit@WavePlayer@@IAEXXZ ; WavePlayer::UnInit

; 234  : 
; 235  : void WavePlayer::SetVolume(DWORD dwVolume)
; 236  : {
; 237  :     waveOutSetVolume(m_hWaveoutDev, dwVolume);
; 238  : }
; 239  : 
; 240  : DWORD WavePlayer::GetAudioLength(LPCTSTR lpszFile)
; 241  : {
; 242  :     // 设置解码器
; 243  :     if(m_pDecoder == NULL)
; 244  :     {
; 245  :         m_pDecoder = new AMRFileDecoder(lpszFile);
; 246  :     }
; 247  :     else
; 248  :     {
; 249  :         m_pDecoder->SetFilePathName(lpszFile);
; 250  :     }
; 251  : 
; 252  :     DWORD dwTimeLength = 0;
; 253  :     if(m_pDecoder)
; 254  :     {
; 255  :         dwTimeLength = (DWORD)m_pDecoder->GetTimeLength();
; 256  :     }
; 257  :    
; 258  :     return dwTimeLength;
; 259  : }
; 260  : 
; 261  : BOOL WavePlayer::WaveOutProc(HWAVEOUT hwo, UINT uMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
; 262  : {
; 263  :     WavePlayer* pPlayer = (WavePlayer*)dwInstance;
; 264  : 
; 265  :     return pPlayer->WaveOutProcImpl(hwo, uMsg, dwParam1, dwParam2);
; 266  : }
; 267  : 
; 268  : BOOL WavePlayer::WaveOutProcImpl(HWAVEOUT hwo, UINT uMsg, DWORD dwParam1, DWORD dwParam2)
; 269  : {
; 270  :     // 忽略打开和关闭设备时的处理
; 271  :     if(uMsg == WOM_DONE)
; 272  :     {
; 273  :         // 每一块播放完之后，意味着空闲缓存块数增加
; 274  :         EnterCriticalSection(&m_cs);
; 275  :         ++m_wBlock.wfreeblock;
; 276  : 		if (m_soundCB)
; 277  : 		{
; 278  : 			WAVEFORMATEX wfmtx = m_pDecoder->GetWaveFromatX();
; 279  : 			int interval = (BLOCK_SIZE * 1000) / wfmtx.nAvgBytesPerSec;
; 280  : 			int total = ceil(float(m_pDecoder->GetTimeLength()) / interval);
; 281  : 			int percent = ++m_notification * 100 / total;
; 282  : 			m_soundCB->onPlayingNotification(percent > 100 ? 100 : percent, (float)m_pDecoder->GetTimeLength() / 1000, m_cbData);
; 283  : 		}
; 284  : 		LeaveCriticalSection(&m_cs);
; 285  :     }
; 286  : 
; 287  :     return TRUE;
; 288  : }
; 289  : 
; 290  : unsigned int WavePlayer::PlayThread( LPVOID lp )
; 291  : {
; 292  :     WavePlayer *pPlayer = ( WavePlayer *)lp;
; 293  : 
; 294  :     return pPlayer->PlayThreadProcImpl();
; 295  : }
; 296  : 
; 297  : unsigned int WavePlayer::PlayThreadProcImpl()
; 298  : {
; 299  :     /// 定义为寄存器变量，因为它将会被高频率的使用，用于编译器优化
; 300  :     register    ThreadMsg       tmsg  = TMSG_ALIVE;         
; 301  : 
; 302  :     /// 线程循环
; 303  :     while( tmsg )
; 304  :     {
; 305  :         // 每次循环后，交出CPU控制权，放在此处，因为下面有continue语句
; 306  :         Sleep(10);
; 307  : 
; 308  :         /// 首先检查线程消息
; 309  :         EnterCriticalSection( &m_cs );
; 310  :         tmsg = m_msgPlayThread;
; 311  :         LeaveCriticalSection( &m_cs );
; 312  :         // 线程要结束，退出线程循环
; 313  :         if(!tmsg)   break;
; 314  : 
; 315  :         // 如果设备为空，表示还没有打开设备，需要打开设备
; 316  :         if(m_hWaveoutDev == NULL)
; 317  :         {
; 318  :             EnterCriticalSection(&m_cs);
; 319  :             MMRESULT mmres = waveOutOpen(&m_hWaveoutDev, WAVE_MAPPER, &m_waveData.wfmtx, (DWORD_PTR)WaveOutProc, (DWORD_PTR)this, CALLBACK_FUNCTION);
; 320  :             LeaveCriticalSection(&m_cs);
; 321  :             if(mmres != MMSYSERR_NOERROR)
; 322  :             {
; 323  :                 // failed, try again.
; 324  :                 continue;
; 325  :             }
; 326  :         }
; 327  :         
; 328  :         // 检查空闲缓存块
; 329  :         EnterCriticalSection( &m_cs );
; 330  :         int free = m_wBlock.wfreeblock;
; 331  :         LeaveCriticalSection( &m_cs );
; 332  : 
; 333  :         // 如果没有空闲的缓存了，等待...
; 334  :         if(free < BP_TURN)
; 335  :         {
; 336  :             continue;
; 337  :         }
; 338  : 
; 339  :         /////////////////////////////////////////////////////////////////////////
; 340  :         /////////////////////////////////////////////////////////////////////////
; 341  :         ///                       < 播放主循环 >                              ///
; 342  :         /////////////////////////////////////////////////////////////////////////
; 343  :         /////////////////////////////////////////////////////////////////////////
; 344  : 
; 345  :         WAVEHDR     *current = NULL;
; 346  : 
; 347  :         /// BP_TURN为每次写入播放队列的块数
; 348  :         for( unsigned int m = 0; m < BP_TURN; m++ )
; 349  :         {   
; 350  :             /// 当前空闲播放缓存块
; 351  :             current = &m_wBlock.pWaveHdr[m_wBlock.wcurrblock]; 
; 352  : 
; 353  :             // 首先需要检查有没有被Unprepare掉
; 354  :             if( current->dwFlags & WHDR_PREPARED )
; 355  :             {
; 356  :                 waveOutUnprepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );
; 357  :             }
; 358  : 
; 359  :             /// 计算剩余需要播放的数据
; 360  :             EnterCriticalSection(&m_cs);
; 361  :             unsigned long left  = m_waveData.dwSize - m_wBlock.wpos;
; 362  :             unsigned int bDecodeFinished = m_waveData.bDecodeFinished;
; 363  :             LeaveCriticalSection(&m_cs);
; 364  :             unsigned long chunk = 0;
; 365  : 
; 366  :             if( left  >= BLOCK_SIZE )
; 367  :             {
; 368  :                 chunk  = BLOCK_SIZE;
; 369  :             }
; 370  :             else if(!bDecodeFinished)
; 371  :             {
; 372  :                 // 如果解码还没有结束，现有的数据量有不足以填满一个缓存块，先不写入缓存
; 373  :                 break;
; 374  :             }
; 375  :             else if( left && left < BLOCK_SIZE)
; 376  :             {
; 377  :                 chunk  = left;
; 378  :             }
; 379  :             else
; 380  :             {   
; 381  :                 //////////////////////////////////////////////////////////////////////
; 382  :                 ///                 < 播放完成>                                    ///
; 383  :                 //////////////////////////////////////////////////////////////////////
; 384  : 
; 385  :                 /// 获取空闲缓存块数量
; 386  :                 EnterCriticalSection( &m_cs );
; 387  :                 int free = m_wBlock.wfreeblock;
; 388  :                 LeaveCriticalSection( &m_cs );
; 389  : 
; 390  :                 /// 当所有的缓存块都播放完了，才意味着播放真正完成
; 391  :                 if( free == BLOCK_COUNT )
; 392  :                 {
; 393  :                     /// Unprepare缓存块
; 394  :                     for( int j = 0; j < m_wBlock.wfreeblock; j++) 
; 395  :                     {
; 396  :                         if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )
; 397  :                         {
; 398  :                             waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));
; 399  :                         }
; 400  :                     }
; 401  : 
; 402  :                     // 此时，才算真正的播放完成，关闭线程
; 403  :                     tmsg = TMSG_CLOSE;
; 404  :                     // 处理播放完成事件
; 405  :                     OnPlayFinished();
; 406  :                 }
; 407  : 
; 408  :                 // 此break仅跳出该循环，没有跳出线程循环
; 409  :                 break;
; 410  :             }
; 411  : 
; 412  :             /// prepare current wave data block header
; 413  :             EnterCriticalSection(&m_cs);
; 414  :             memcpy( current->lpData, &m_waveData.pData[m_wBlock.wpos], chunk );
; 415  :             LeaveCriticalSection(&m_cs);
; 416  : 
; 417  :             current->dwBufferLength  = chunk;   // sizeof block
; 418  :             m_wBlock.wpos           += chunk;   // update position
; 419  : 
; 420  :             /// prepare for playback
; 421  :             waveOutPrepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );
; 422  : 
; 423  :             /// push to the queue
; 424  :             waveOutWrite(m_hWaveoutDev, current, sizeof(WAVEHDR));
; 425  : 
; 426  :             /// 减小空闲块计数
; 427  :             EnterCriticalSection( &m_cs );
; 428  :             m_wBlock.wfreeblock--;
; 429  :             LeaveCriticalSection( &m_cs );
; 430  : 
; 431  :             /// 使当前空闲块指向下一个
; 432  :             m_wBlock.wcurrblock++;
; 433  :             m_wBlock.wcurrblock %= BLOCK_COUNT;
; 434  :         }
; 435  : 
; 436  :     }/// thread
; 437  : 
; 438  :     ///////////////////////////////////////////////////////////////////////////////
; 439  :     ///////////////////////////////////////////////////////////////////////////////
; 440  :     ///
; 441  :     ///            < force to close device which are still playing > 
; 442  :     ///////////////////////////////////////////////////////////////////////////////
; 443  :     ///////////////////////////////////////////////////////////////////////////////
; 444  :     if(m_hWaveoutDev)
; 445  :     {
; 446  :         waveOutReset( m_hWaveoutDev );
; 447  : 
; 448  :         /// unprepare any blocks that are still prepared
; 449  :         for( int j = 0; j < BLOCK_COUNT; j++) 
; 450  :         {
; 451  :             if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )
; 452  :             {
; 453  :                 waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));
; 454  :             }
; 455  :         }
; 456  : 
; 457  :         waveOutClose(m_hWaveoutDev);
; 458  :         m_hWaveoutDev = NULL;
; 459  :     }
; 460  : 
; 461  :     return THREAD_EXIT;
; 462  : }
; 463  : 
; 464  : unsigned int WavePlayer::DecodeThread(LPVOID lp)
; 465  : {
; 466  :     WavePlayer* pThis = (WavePlayer*)lp;
; 467  : 
; 468  :     return pThis->DecodeThreadProcImpl();
; 469  : }
; 470  : 
; 471  : unsigned int WavePlayer::DecodeThreadProcImpl()
; 472  : {
; 473  :     if(m_pDecoder == NULL || !m_pDecoder->IsVaild())
; 474  : 	{
; 475  : 		SetEvent(m_hEventDecode);
; 476  :         return 0;
; 477  : 	}
; 478  : 
; 479  :     // 开始解码，初始化解码器
; 480  :     if(!m_pDecoder->BeginDecode())
; 481  :     {
; 482  : 		SetEvent(m_hEventDecode);
; 483  :         return 0;
; 484  :     }
; 485  : 
; 486  :     // 申请临时内存块，存储解码后的波形数据
; 487  :     DWORD dwFrameMaxSize = m_pDecoder->GetDecodedFrameMaxSize();
; 488  :     LPSTR pBufferBase = (LPSTR)malloc(dwFrameMaxSize);
; 489  :     ATLASSERT(pBufferBase);
; 490  :     memset(pBufferBase, 0, dwFrameMaxSize);
; 491  :     if(pBufferBase == NULL) return 0;
; 492  : 
; 493  :     register ThreadMsg tmsg = TMSG_ALIVE;
; 494  : 
; 495  :     DWORD dwSizeAmount = 0;
; 496  :     while(!m_pDecoder->IsEOF() && tmsg)
; 497  :     {
; 498  :         // 解码，每帧
; 499  :         DWORD dwSize = m_pDecoder->Decode(pBufferBase);
; 500  :         dwSizeAmount += dwSize;
; 501  : 
; 502  :         // 将解码后数据写入缓存区，供播放线程使用
; 503  :         EnterCriticalSection(&m_cs);           
; 504  :         memcpy(m_waveData.pData + m_waveData.dwSize, pBufferBase, dwSize);
; 505  :         m_waveData.dwSize += dwSize;
; 506  :         LeaveCriticalSection(&m_cs);
; 507  : 
; 508  :         // 当解码数据量操作了一个播放缓存时，发个信号，通知可以开始播放了
; 509  :         if(dwSizeAmount > BLOCK_SIZE)
; 510  :         {
; 511  :             dwSizeAmount = 0;
; 512  :             SetEvent(m_hEventDecode);
; 513  :         }
; 514  : 
; 515  :         // 节省CPU时间，让CPU有时间去干别的事儿
; 516  :         Sleep(1);
; 517  : 
; 518  :         // 检测线程是否将被强制退出
; 519  :         EnterCriticalSection(&m_cs);
; 520  :         tmsg = m_msgDecodeThread;
; 521  :         LeaveCriticalSection(&m_cs);
; 522  :     }
; 523  : 
; 524  :     // 如果数据量很小，根本不足一个播放缓存，也要发个信号
; 525  :     if(dwSizeAmount > 0)
; 526  :     {
; 527  :         SetEvent(m_hEventDecode);
; 528  :     }
; 529  : 
; 530  :     m_waveData.bDecodeFinished = true;
; 531  : 
; 532  :     // 解码结束
; 533  :     m_pDecoder->EndDecode();
; 534  : 
; 535  :     free(pBufferBase);
; 536  :     pBufferBase = NULL;
; 537  : 
; 538  :     return 0;
; 539  : }
; 540  : 
; 541  : void WavePlayer::SetCallback(ISoundCallBack *psoundCB, long cbData)
; 542  : {
; 543  : 	m_soundCB = psoundCB;
; 544  : 	m_cbData = cbData;
; 545  : }
; 546  : 
; 547  : void WavePlayer::OnPlayFinished()
; 548  : {
; 549  : 	m_ePlayStat = Play_Stop;
; 550  : 
; 551  : 	if (m_soundCB)

  0000f	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  00012	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00019	85 c9		 test	 ecx, ecx
  0001b	74 08		 je	 SHORT $LN3@Stop

; 552  : 		m_soundCB->onSoundPlayed(m_cbData);

  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	ff 76 6c	 push	 DWORD PTR [esi+108]
  00022	ff 50 04	 call	 DWORD PTR [eax+4]
$LN3@Stop:
  00025	5e		 pop	 esi

; 231  : 
; 232  :     OnPlayFinished();
; 233  : }

  00026	c3		 ret	 0
?Stop@WavePlayer@@QAEXXZ ENDP				; WavePlayer::Stop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z
_TEXT	SEGMENT
_psoundCB$ = 8						; size = 4
_cbData$ = 12						; size = 4
?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z PROC ; WavePlayer::SetCallback, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 	m_soundCB = psoundCB;

  00003	8b 45 08	 mov	 eax, DWORD PTR _psoundCB$[ebp]
  00006	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 544  : 	m_cbData = cbData;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _cbData$[ebp]
  0000c	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 545  : }

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?SetCallback@WavePlayer@@QAEXPAVISoundCallBack@@J@Z ENDP ; WavePlayer::SetCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv76 = -8						; size = 8
tv68 = -8						; size = 8
_ceilf	PROC						; COMDAT
; __X$ = xmm0s

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 659  :     return (float)ceil(_X);

  00006	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0000a	83 ec 08	 sub	 esp, 8
  0000d	f2 0f 11 45 f8	 movsd	 QWORD PTR tv68[ebp], xmm0
  00012	dd 45 f8	 fld	 QWORD PTR tv68[ebp]
  00015	dd 1c 24	 fstp	 QWORD PTR [esp]
  00018	e8 00 00 00 00	 call	 _ceil
  0001d	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
  00020	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR tv76[ebp]
  00025	83 c4 08	 add	 esp, 8
  00028	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 660  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
tv76 = -8						; size = 8
tv65 = -8						; size = 8
?ceil@@YAMM@Z PROC					; ceil, COMDAT
; __X$ = xmm0s

; 1048 :         {return (ceilf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 659  :     return (float)ceil(_X);

  00006	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0000a	83 ec 08	 sub	 esp, 8
  0000d	f2 0f 11 45 f8	 movsd	 QWORD PTR tv65[ebp], xmm0
  00012	dd 45 f8	 fld	 QWORD PTR tv65[ebp]
  00015	dd 1c 24	 fstp	 QWORD PTR [esp]
  00018	e8 00 00 00 00	 call	 _ceil
  0001d	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
  00020	f2 0f 10 45 f8	 movsd	 xmm0, QWORD PTR tv76[ebp]
  00025	83 c4 08	 add	 esp, 8
  00028	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 1048 :         {return (ceilf(_X)); }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z
_TEXT	SEGMENT
_size$dead$ = 8						; size = 4
_count$dead$ = 12					; size = 4
?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z PROC	; WavePlayer::allocBlocks, COMDAT
; _this$dead$ = ecx

; 73   :     unsigned char* buffer;
; 74   :     int i;
; 75   :     WAVEHDR* blocks;
; 76   :     DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;
; 77   : 
; 78   :     //  一次性分配所有缓存，不需多次申请，释放简单
; 79   :     if((buffer = ( UCHAR*) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, totalBufferSize )) == NULL)	

  00000	68 00 3b 01 00	 push	 80640			; 00013b00H
  00005	6a 08		 push	 8
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00014	85 c0		 test	 eax, eax
  00016	75 03		 jne	 SHORT $LN4@allocBlock

; 93   : }

  00018	c2 08 00	 ret	 8
$LN4@allocBlock:
  0001b	56		 push	 esi

; 80   :         return NULL;
; 81   : 
; 82   :     // 设置缓存数据指针
; 83   :     blocks = (WAVEHDR*)buffer;

  0001c	8b f0		 mov	 esi, eax
  0001e	ba 14 00 00 00	 mov	 edx, 20			; 00000014H

; 84   :     buffer += sizeof(WAVEHDR) * count;

  00023	05 80 02 00 00	 add	 eax, 640		; 00000280H
  00028	8b ce		 mov	 ecx, esi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL3@allocBlock:

; 85   :     for(i = 0; i < count; i++) 
; 86   :     {
; 87   :         blocks[i].dwBufferLength = size;
; 88   :         blocks[i].lpData = (CHAR *)buffer;

  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	8d 49 20	 lea	 ecx, DWORD PTR [ecx+32]

; 89   :         buffer += size;

  00035	05 a0 0f 00 00	 add	 eax, 4000		; 00000fa0H
  0003a	c7 41 e4 a0 0f
	00 00		 mov	 DWORD PTR [ecx-28], 4000 ; 00000fa0H
  00041	4a		 dec	 edx
  00042	75 ec		 jne	 SHORT $LL3@allocBlock

; 90   :     }
; 91   : 
; 92   :     return blocks;

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 93   : }

  00047	c2 08 00	 ret	 8
?allocBlocks@WavePlayer@@IAEPAUwavehdr_tag@@HH@Z ENDP	; WavePlayer::allocBlocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z
_TEXT	SEGMENT
_blockArray$ = 8					; size = 4
?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z PROC	; WavePlayer::freeBlocks, COMDAT
; _this$dead$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 104  :     HeapFree(GetProcessHeap(), 0, blockArray);

  00003	ff 75 08	 push	 DWORD PTR _blockArray$[ebp]
  00006	6a 00		 push	 0
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 105  : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?freeBlocks@WavePlayer@@IAEXPAUwavehdr_tag@@@Z ENDP	; WavePlayer::freeBlocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?UnInit@WavePlayer@@IAEXXZ
_TEXT	SEGMENT
?UnInit@WavePlayer@@IAEXXZ PROC				; WavePlayer::UnInit, COMDAT
; _this$ = ecx

; 108  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 109  :     if(m_hThreadPlay)

  00004	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00007	74 30		 je	 SHORT $LN4@UnInit

; 110  :     {
; 111  :         // 终止播放线程
; 112  :         EnterCriticalSection( &m_cs );

  00009	8d 77 50	 lea	 esi, DWORD PTR [edi+80]
  0000c	56		 push	 esi
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 113  :         m_msgPlayThread = TMSG_CLOSE;
; 114  :         LeaveCriticalSection( &m_cs );

  00013	56		 push	 esi
  00014	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 115  :         WaitForSingleObject(m_hThreadPlay, INFINITE);

  00021	6a ff		 push	 -1
  00023	ff 37		 push	 DWORD PTR [edi]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 116  : 
; 117  :         CloseHandle(m_hThreadPlay);

  0002b	ff 37		 push	 DWORD PTR [edi]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 118  :         m_hThreadPlay = NULL;

  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@UnInit:

; 119  :     }
; 120  : 
; 121  :     if(m_hThreadDecode)

  00039	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003d	74 33		 je	 SHORT $LN3@UnInit

; 122  :     {
; 123  :         // 终止解码线程
; 124  :         EnterCriticalSection( &m_cs );

  0003f	8d 77 50	 lea	 esi, DWORD PTR [edi+80]
  00042	56		 push	 esi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 125  :         m_msgDecodeThread = TMSG_CLOSE;
; 126  :         LeaveCriticalSection( &m_cs );

  00049	56		 push	 esi
  0004a	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 127  :         WaitForSingleObject(m_hThreadDecode, INFINITE);

  00057	6a ff		 push	 -1
  00059	ff 77 04	 push	 DWORD PTR [edi+4]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 128  : 
; 129  :         CloseHandle(m_hThreadDecode);

  00062	ff 77 04	 push	 DWORD PTR [edi+4]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 130  :         m_hThreadDecode = NULL;

  0006b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN3@UnInit:

; 131  :     }
; 132  : 
; 133  :     // 释放波形数据并恢复初始化样子，以供下次使用
; 134  :     if(m_waveData.pData)

  00072	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00075	85 c0		 test	 eax, eax
  00077	74 17		 je	 SHORT $LN2@UnInit

; 135  :     {
; 136  :         HeapFree(GetProcessHeap(), 0, m_waveData.pData);

  00079	50		 push	 eax
  0007a	6a 00		 push	 0
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 137  :         m_waveData.pData = NULL;

  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
$LN2@UnInit:

; 138  :     }
; 139  :     memset(&m_waveData, 0, sizeof(WaveData));

  00090	0f 57 c0	 xorps	 xmm0, xmm0
  00093	f3 0f 7f 47 24	 movdqu	 XMMWORD PTR [edi+36], xmm0
  00098	f3 0f 7f 47 34	 movdqu	 XMMWORD PTR [edi+52], xmm0

; 140  : 
; 141  :     // 关闭播放设备
; 142  :     if(m_hWaveoutDev)

  0009d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000a0	85 c0		 test	 eax, eax
  000a2	74 17		 je	 SHORT $LN1@UnInit

; 143  :     {
; 144  :         waveOutReset(m_hWaveoutDev);

  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutReset@4

; 145  :         waveOutClose(m_hWaveoutDev);

  000ab	ff 77 10	 push	 DWORD PTR [edi+16]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 146  :         m_hWaveoutDev = NULL;

  000b4	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
$LN1@UnInit:

; 147  :     }
; 148  :     
; 149  :     // 重设播放缓存块游标
; 150  :     m_wBlock.wfreeblock = BLOCK_COUNT;

  000bb	c7 47 1c 14 00
	00 00		 mov	 DWORD PTR [edi+28], 20	; 00000014H

; 151  :     m_wBlock.wcurrblock = 0;

  000c2	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0

; 152  :     m_wBlock.wpos       = 0;

  000c9	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 153  : 
; 154  :     m_ePlayStat         = Play_Stop;

  000d0	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi

; 155  : }

  000d9	c3		 ret	 0
?UnInit@WavePlayer@@IAEXXZ ENDP				; WavePlayer::UnInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z
_TEXT	SEGMENT
_hwo$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_dwInstance$ = 16					; size = 4
_dwParam1$ = 20						; size = 4
_dwParam2$ = 24						; size = 4
?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z PROC	; WavePlayer::WaveOutProc, COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 
; 268  : BOOL WavePlayer::WaveOutProcImpl(HWAVEOUT hwo, UINT uMsg, DWORD dwParam1, DWORD dwParam2)
; 269  : {
; 270  :     // 忽略打开和关闭设备时的处理
; 271  :     if(uMsg == WOM_DONE)

  00003	81 7d 0c bd 03
	00 00		 cmp	 DWORD PTR _uMsg$[ebp], 957 ; 000003bdH
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _dwInstance$[ebp]
  0000d	75 09		 jne	 SHORT $LN4@WaveOutPro
  0000f	e8 00 00 00 00	 call	 ?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ; WavePlayer::WaveOutProcImpl

; 266  : }

  00014	5d		 pop	 ebp
  00015	c2 14 00	 ret	 20			; 00000014H
$LN4@WaveOutPro:

; 263  :     WavePlayer* pPlayer = (WavePlayer*)dwInstance;
; 264  : 
; 265  :     return pPlayer->WaveOutProcImpl(hwo, uMsg, dwParam1, dwParam2);

  00018	b8 01 00 00 00	 mov	 eax, 1

; 266  : }

  0001d	5d		 pop	 ebp
  0001e	c2 14 00	 ret	 20			; 00000014H
?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ENDP	; WavePlayer::WaveOutProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z
_TEXT	SEGMENT
tv211 = -32						; size = 8
tv205 = -32						; size = 8
_wfmtx$1 = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z PROC ; WavePlayer::WaveOutProcImpl, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b d9		 mov	 ebx, ecx

; 270  :     // 忽略打开和关闭设备时的处理
; 271  :     if(uMsg == WOM_DONE)
; 272  :     {
; 273  :         // 每一块播放完之后，意味着空闲缓存块数增加
; 274  :         EnterCriticalSection(&m_cs);

  00013	8d 43 50	 lea	 eax, DWORD PTR [ebx+80]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 275  :         ++m_wBlock.wfreeblock;

  0001d	ff 43 1c	 inc	 DWORD PTR [ebx+28]

; 276  : 		if (m_soundCB)

  00020	83 7b 68 00	 cmp	 DWORD PTR [ebx+104], 0
  00024	0f 84 b1 00 00
	00		 je	 $LN1@WaveOutPro

; 277  : 		{
; 278  : 			WAVEFORMATEX wfmtx = m_pDecoder->GetWaveFromatX();

  0002a	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  0002d	8d 55 e8	 lea	 edx, DWORD PTR _wfmtx$1[ebp]
  00030	56		 push	 esi
  00031	57		 push	 edi
  00032	52		 push	 edx
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 50 0c	 call	 DWORD PTR [eax+12]

; 279  : 			int interval = (BLOCK_SIZE * 1000) / wfmtx.nAvgBytesPerSec;

  00038	33 d2		 xor	 edx, edx

; 280  : 			int total = ceil(float(m_pDecoder->GetTimeLength()) / interval);

  0003a	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  0003d	b8 00 09 3d 00	 mov	 eax, 4000000		; 003d0900H
  00042	f7 75 f0	 div	 DWORD PTR _wfmtx$1[ebp+8]
  00045	8b 11		 mov	 edx, DWORD PTR [ecx]
  00047	8b f0		 mov	 esi, eax
  00049	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0004c	ff d2		 call	 edx
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 __ultod3
  00055	0f 57 c9	 xorps	 xmm1, xmm1

; 281  : 			int percent = ++m_notification * 100 / total;

  00058	ff 43 70	 inc	 DWORD PTR [ebx+112]
  0005b	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 659  :     return (float)ceil(_X);

  0005f	83 ec 08	 sub	 esp, 8
  00062	66 0f 6e c6	 movd	 xmm0, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp

; 280  : 			int total = ceil(float(m_pDecoder->GetTimeLength()) / interval);

  00066	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00069	f3 0f 5e c8	 divss	 xmm1, xmm0
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 659  :     return (float)ceil(_X);

  0006d	0f 5a c1	 cvtps2pd xmm0, xmm1
  00070	f2 0f 11 45 e0	 movsd	 QWORD PTR tv211[ebp], xmm0
  00075	dd 45 e0	 fld	 QWORD PTR tv211[ebp]
  00078	dd 1c 24	 fstp	 QWORD PTR [esp]
  0007b	e8 00 00 00 00	 call	 _ceil
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp

; 281  : 			int percent = ++m_notification * 100 / total;

  00080	6b 43 70 64	 imul	 eax, DWORD PTR [ebx+112], 100
  00084	33 d2		 xor	 edx, edx
; File d:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 659  :     return (float)ceil(_X);

  00086	dd 5d e0	 fstp	 QWORD PTR tv205[ebp]
  00089	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR tv205[ebp]
  0008e	83 c4 08	 add	 esp, 8
  00091	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp

; 282  : 			m_soundCB->onPlayingNotification(percent > 100 ? 100 : percent, (float)m_pDecoder->GetTimeLength() / 1000, m_cbData);

  00095	ff 73 6c	 push	 DWORD PTR [ebx+108]
  00098	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0009c	f7 f1		 div	 ecx
  0009e	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  000a1	8b f0		 mov	 esi, eax
  000a3	8b 39		 mov	 edi, DWORD PTR [ecx]
  000a5	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000aa	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000ad	ff d2		 call	 edx
  000af	8b c8		 mov	 ecx, eax
  000b1	e8 00 00 00 00	 call	 __ultod3
  000b6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000ba	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  000bf	51		 push	 ecx
  000c0	8b 4b 68	 mov	 ecx, DWORD PTR [ebx+104]
  000c3	3b f0		 cmp	 esi, eax
  000c5	0f 4f f0	 cmovg	 esi, eax
  000c8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	56		 push	 esi
  000d6	ff 57 08	 call	 DWORD PTR [edi+8]
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
$LN1@WaveOutPro:

; 283  : 		}
; 284  : 		LeaveCriticalSection(&m_cs);

  000db	8d 43 50	 lea	 eax, DWORD PTR [ebx+80]
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 285  :     }
; 286  : 
; 287  :     return TRUE;
; 288  : }

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	33 cd		 xor	 ecx, ebp
  000ef	5b		 pop	 ebx
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?WaveOutProcImpl@WavePlayer@@IAEHPAUHWAVEOUT__@@IKK@Z ENDP ; WavePlayer::WaveOutProcImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?PlayThread@WavePlayer@@KGIPAX@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
?PlayThread@WavePlayer@@KGIPAX@Z PROC			; WavePlayer::PlayThread, COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 292  :     WavePlayer *pPlayer = ( WavePlayer *)lp;
; 293  : 
; 294  :     return pPlayer->PlayThreadProcImpl();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  00006	e8 00 00 00 00	 call	 ?PlayThreadProcImpl@WavePlayer@@IAEIXZ ; WavePlayer::PlayThreadProcImpl

; 295  : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?PlayThread@WavePlayer@@KGIPAX@Z ENDP			; WavePlayer::PlayThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?PlayThreadProcImpl@WavePlayer@@IAEIXZ
_TEXT	SEGMENT
_bDecodeFinished$1$ = -8				; size = 4
_m$1$ = -4						; size = 4
?PlayThreadProcImpl@WavePlayer@@IAEIXZ PROC		; WavePlayer::PlayThreadProcImpl, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	eb 03 8d 49 00	 npad	 5
$LL53@PlayThread:
  00010	8d 5e 50	 lea	 ebx, DWORD PTR [esi+80]
$LL26@PlayThread:

; 299  :     /// 定义为寄存器变量，因为它将会被高频率的使用，用于编译器优化
; 300  :     register    ThreadMsg       tmsg  = TMSG_ALIVE;         
; 301  : 
; 302  :     /// 线程循环
; 303  :     while( tmsg )
; 304  :     {
; 305  :         // 每次循环后，交出CPU控制权，放在此处，因为下面有continue语句
; 306  :         Sleep(10);

  00013	6a 0a		 push	 10			; 0000000aH
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 307  : 
; 308  :         /// 首先检查线程消息
; 309  :         EnterCriticalSection( &m_cs );

  0001b	53		 push	 ebx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 310  :         tmsg = m_msgPlayThread;

  00022	8b 7e 44	 mov	 edi, DWORD PTR [esi+68]

; 311  :         LeaveCriticalSection( &m_cs );

  00025	53		 push	 ebx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 312  :         // 线程要结束，退出线程循环
; 313  :         if(!tmsg)   break;

  0002c	85 ff		 test	 edi, edi
  0002e	0f 84 82 01 00
	00		 je	 $LN39@PlayThread

; 314  : 
; 315  :         // 如果设备为空，表示还没有打开设备，需要打开设备
; 316  :         if(m_hWaveoutDev == NULL)

  00034	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00038	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0003b	75 2c		 jne	 SHORT $LN22@PlayThread

; 317  :         {
; 318  :             EnterCriticalSection(&m_cs);

  0003d	53		 push	 ebx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 319  :             MMRESULT mmres = waveOutOpen(&m_hWaveoutDev, WAVE_MAPPER, &m_waveData.wfmtx, (DWORD_PTR)WaveOutProc, (DWORD_PTR)this, CALLBACK_FUNCTION);

  00044	68 00 00 03 00	 push	 196608			; 00030000H
  00049	56		 push	 esi
  0004a	68 00 00 00 00	 push	 OFFSET ?WaveOutProc@WavePlayer@@KGHPAUHWAVEOUT__@@IKKK@Z ; WavePlayer::WaveOutProc
  0004f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00052	50		 push	 eax
  00053	6a ff		 push	 -1
  00055	57		 push	 edi
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutOpen@24

; 320  :             LeaveCriticalSection(&m_cs);

  0005c	53		 push	 ebx
  0005d	8b f8		 mov	 edi, eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 321  :             if(mmres != MMSYSERR_NOERROR)

  00065	85 ff		 test	 edi, edi
  00067	75 aa		 jne	 SHORT $LL26@PlayThread
$LN22@PlayThread:

; 322  :             {
; 323  :                 // failed, try again.
; 324  :                 continue;
; 325  :             }
; 326  :         }
; 327  :         
; 328  :         // 检查空闲缓存块
; 329  :         EnterCriticalSection( &m_cs );

  00069	53		 push	 ebx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 330  :         int free = m_wBlock.wfreeblock;

  00070	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]

; 331  :         LeaveCriticalSection( &m_cs );

  00073	53		 push	 ebx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 332  : 
; 333  :         // 如果没有空闲的缓存了，等待...
; 334  :         if(free < BP_TURN)

  0007a	83 ff 01	 cmp	 edi, 1
  0007d	7c 94		 jl	 SHORT $LL26@PlayThread

; 335  :         {
; 336  :             continue;
; 337  :         }
; 338  : 
; 339  :         /////////////////////////////////////////////////////////////////////////
; 340  :         /////////////////////////////////////////////////////////////////////////
; 341  :         ///                       < 播放主循环 >                              ///
; 342  :         /////////////////////////////////////////////////////////////////////////
; 343  :         /////////////////////////////////////////////////////////////////////////
; 344  : 
; 345  :         WAVEHDR     *current = NULL;
; 346  : 
; 347  :         /// BP_TURN为每次写入播放队列的块数
; 348  :         for( unsigned int m = 0; m < BP_TURN; m++ )

  0007f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _m$1$[ebp], 0
$LL20@PlayThread:

; 349  :         {   
; 350  :             /// 当前空闲播放缓存块
; 351  :             current = &m_wBlock.pWaveHdr[m_wBlock.wcurrblock]; 

  00086	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00089	c1 e7 05	 shl	 edi, 5
  0008c	03 7e 18	 add	 edi, DWORD PTR [esi+24]

; 352  : 
; 353  :             // 首先需要检查有没有被Unprepare掉
; 354  :             if( current->dwFlags & WHDR_PREPARED )

  0008f	f6 47 10 02	 test	 BYTE PTR [edi+16], 2
  00093	74 0c		 je	 SHORT $LN17@PlayThread

; 355  :             {
; 356  :                 waveOutUnprepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );

  00095	6a 20		 push	 32			; 00000020H
  00097	57		 push	 edi
  00098	ff 76 10	 push	 DWORD PTR [esi+16]
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
$LN17@PlayThread:

; 357  :             }
; 358  : 
; 359  :             /// 计算剩余需要播放的数据
; 360  :             EnterCriticalSection(&m_cs);

  000a1	53		 push	 ebx
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 361  :             unsigned long left  = m_waveData.dwSize - m_wBlock.wpos;
; 362  :             unsigned int bDecodeFinished = m_waveData.bDecodeFinished;

  000a8	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000ab	8b 5e 3c	 mov	 ebx, DWORD PTR [esi+60]
  000ae	2b 5e 14	 sub	 ebx, DWORD PTR [esi+20]
  000b1	89 45 f8	 mov	 DWORD PTR _bDecodeFinished$1$[ebp], eax

; 363  :             LeaveCriticalSection(&m_cs);

  000b4	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 364  :             unsigned long chunk = 0;
; 365  : 
; 366  :             if( left  >= BLOCK_SIZE )

  000be	81 fb a0 0f 00
	00		 cmp	 ebx, 4000		; 00000fa0H
  000c4	72 07		 jb	 SHORT $LN16@PlayThread

; 367  :             {
; 368  :                 chunk  = BLOCK_SIZE;

  000c6	bb a0 0f 00 00	 mov	 ebx, 4000		; 00000fa0H
  000cb	eb 0e		 jmp	 SHORT $LN11@PlayThread
$LN16@PlayThread:

; 369  :             }
; 370  :             else if(!bDecodeFinished)

  000cd	83 7d f8 00	 cmp	 DWORD PTR _bDecodeFinished$1$[ebp], 0
  000d1	0f 84 39 ff ff
	ff		 je	 $LL53@PlayThread

; 371  :             {
; 372  :                 // 如果解码还没有结束，现有的数据量有不足以填满一个缓存块，先不写入缓存
; 373  :                 break;
; 374  :             }
; 375  :             else if( left && left < BLOCK_SIZE)

  000d7	85 db		 test	 ebx, ebx
  000d9	74 7c		 je	 SHORT $LN12@PlayThread
$LN11@PlayThread:

; 399  :                         }
; 400  :                     }
; 401  : 
; 402  :                     // 此时，才算真正的播放完成，关闭线程
; 403  :                     tmsg = TMSG_CLOSE;
; 404  :                     // 处理播放完成事件
; 405  :                     OnPlayFinished();
; 406  :                 }
; 407  : 
; 408  :                 // 此break仅跳出该循环，没有跳出线程循环
; 409  :                 break;
; 410  :             }
; 411  : 
; 412  :             /// prepare current wave data block header
; 413  :             EnterCriticalSection(&m_cs);

  000db	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 414  :             memcpy( current->lpData, &m_waveData.pData[m_wBlock.wpos], chunk );

  000e5	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000e8	03 46 14	 add	 eax, DWORD PTR [esi+20]
  000eb	53		 push	 ebx
  000ec	50		 push	 eax
  000ed	ff 37		 push	 DWORD PTR [edi]
  000ef	e8 00 00 00 00	 call	 _memcpy
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  :             LeaveCriticalSection(&m_cs);

  000f7	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  000fa	50		 push	 eax
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 416  : 
; 417  :             current->dwBufferLength  = chunk;   // sizeof block
; 418  :             m_wBlock.wpos           += chunk;   // update position
; 419  : 
; 420  :             /// prepare for playback
; 421  :             waveOutPrepareHeader( m_hWaveoutDev, current, sizeof(WAVEHDR) );

  00101	6a 20		 push	 32			; 00000020H
  00103	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00106	01 5e 14	 add	 DWORD PTR [esi+20], ebx
  00109	57		 push	 edi
  0010a	ff 76 10	 push	 DWORD PTR [esi+16]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutPrepareHeader@12

; 422  : 
; 423  :             /// push to the queue
; 424  :             waveOutWrite(m_hWaveoutDev, current, sizeof(WAVEHDR));

  00113	6a 20		 push	 32			; 00000020H
  00115	57		 push	 edi
  00116	ff 76 10	 push	 DWORD PTR [esi+16]
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutWrite@12

; 425  : 
; 426  :             /// 减小空闲块计数
; 427  :             EnterCriticalSection( &m_cs );

  0011f	8d 5e 50	 lea	 ebx, DWORD PTR [esi+80]
  00122	53		 push	 ebx
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 428  :             m_wBlock.wfreeblock--;

  00129	ff 4e 1c	 dec	 DWORD PTR [esi+28]

; 429  :             LeaveCriticalSection( &m_cs );

  0012c	53		 push	 ebx
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 430  : 
; 431  :             /// 使当前空闲块指向下一个
; 432  :             m_wBlock.wcurrblock++;

  00133	8b 46 20	 mov	 eax, DWORD PTR [esi+32]

; 433  :             m_wBlock.wcurrblock %= BLOCK_COUNT;

  00136	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0013b	40		 inc	 eax
  0013c	99		 cdq
  0013d	f7 f9		 idiv	 ecx
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _m$1$[ebp]
  00142	40		 inc	 eax
  00143	89 56 20	 mov	 DWORD PTR [esi+32], edx
  00146	89 45 fc	 mov	 DWORD PTR _m$1$[ebp], eax
  00149	83 f8 01	 cmp	 eax, 1
  0014c	0f 82 34 ff ff
	ff		 jb	 $LL20@PlayThread

; 312  :         // 线程要结束，退出线程循环
; 313  :         if(!tmsg)   break;

  00152	e9 bc fe ff ff	 jmp	 $LL26@PlayThread
$LN12@PlayThread:

; 376  :             {
; 377  :                 chunk  = left;
; 378  :             }
; 379  :             else
; 380  :             {   
; 381  :                 //////////////////////////////////////////////////////////////////////
; 382  :                 ///                 < 播放完成>                                    ///
; 383  :                 //////////////////////////////////////////////////////////////////////
; 384  : 
; 385  :                 /// 获取空闲缓存块数量
; 386  :                 EnterCriticalSection( &m_cs );

  00157	8d 5e 50	 lea	 ebx, DWORD PTR [esi+80]
  0015a	53		 push	 ebx
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 387  :                 int free = m_wBlock.wfreeblock;

  00161	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]

; 388  :                 LeaveCriticalSection( &m_cs );

  00164	53		 push	 ebx
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 389  : 
; 390  :                 /// 当所有的缓存块都播放完了，才意味着播放真正完成
; 391  :                 if( free == BLOCK_COUNT )

  0016b	83 ff 14	 cmp	 edi, 20			; 00000014H
  0016e	0f 85 9f fe ff
	ff		 jne	 $LL26@PlayThread

; 392  :                 {
; 393  :                     /// Unprepare缓存块
; 394  :                     for( int j = 0; j < m_wBlock.wfreeblock; j++) 

  00174	33 ff		 xor	 edi, edi
  00176	39 7e 1c	 cmp	 DWORD PTR [esi+28], edi
  00179	7e 25		 jle	 SHORT $LN7@PlayThread
  0017b	33 db		 xor	 ebx, ebx
  0017d	8d 49 00	 npad	 3
$LL9@PlayThread:

; 395  :                     {
; 396  :                         if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )

  00180	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00183	03 c3		 add	 eax, ebx
  00185	f6 40 10 02	 test	 BYTE PTR [eax+16], 2
  00189	74 0c		 je	 SHORT $LN8@PlayThread

; 397  :                         {
; 398  :                             waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));

  0018b	6a 20		 push	 32			; 00000020H
  0018d	50		 push	 eax
  0018e	ff 76 10	 push	 DWORD PTR [esi+16]
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
$LN8@PlayThread:

; 392  :                 {
; 393  :                     /// Unprepare缓存块
; 394  :                     for( int j = 0; j < m_wBlock.wfreeblock; j++) 

  00197	47		 inc	 edi
  00198	83 c3 20	 add	 ebx, 32			; 00000020H
  0019b	3b 7e 1c	 cmp	 edi, DWORD PTR [esi+28]
  0019e	7c e0		 jl	 SHORT $LL9@PlayThread
$LN7@PlayThread:

; 463  : 
; 464  : unsigned int WavePlayer::DecodeThread(LPVOID lp)
; 465  : {
; 466  :     WavePlayer* pThis = (WavePlayer*)lp;
; 467  : 
; 468  :     return pThis->DecodeThreadProcImpl();
; 469  : }
; 470  : 
; 471  : unsigned int WavePlayer::DecodeThreadProcImpl()
; 472  : {
; 473  :     if(m_pDecoder == NULL || !m_pDecoder->IsVaild())
; 474  : 	{
; 475  : 		SetEvent(m_hEventDecode);
; 476  :         return 0;
; 477  : 	}
; 478  : 
; 479  :     // 开始解码，初始化解码器
; 480  :     if(!m_pDecoder->BeginDecode())
; 481  :     {
; 482  : 		SetEvent(m_hEventDecode);
; 483  :         return 0;
; 484  :     }
; 485  : 
; 486  :     // 申请临时内存块，存储解码后的波形数据
; 487  :     DWORD dwFrameMaxSize = m_pDecoder->GetDecodedFrameMaxSize();
; 488  :     LPSTR pBufferBase = (LPSTR)malloc(dwFrameMaxSize);
; 489  :     ATLASSERT(pBufferBase);
; 490  :     memset(pBufferBase, 0, dwFrameMaxSize);
; 491  :     if(pBufferBase == NULL) return 0;
; 492  : 
; 493  :     register ThreadMsg tmsg = TMSG_ALIVE;
; 494  : 
; 495  :     DWORD dwSizeAmount = 0;
; 496  :     while(!m_pDecoder->IsEOF() && tmsg)
; 497  :     {
; 498  :         // 解码，每帧
; 499  :         DWORD dwSize = m_pDecoder->Decode(pBufferBase);
; 500  :         dwSizeAmount += dwSize;
; 501  : 
; 502  :         // 将解码后数据写入缓存区，供播放线程使用
; 503  :         EnterCriticalSection(&m_cs);           
; 504  :         memcpy(m_waveData.pData + m_waveData.dwSize, pBufferBase, dwSize);
; 505  :         m_waveData.dwSize += dwSize;
; 506  :         LeaveCriticalSection(&m_cs);
; 507  : 
; 508  :         // 当解码数据量操作了一个播放缓存时，发个信号，通知可以开始播放了
; 509  :         if(dwSizeAmount > BLOCK_SIZE)
; 510  :         {
; 511  :             dwSizeAmount = 0;
; 512  :             SetEvent(m_hEventDecode);
; 513  :         }
; 514  : 
; 515  :         // 节省CPU时间，让CPU有时间去干别的事儿
; 516  :         Sleep(1);
; 517  : 
; 518  :         // 检测线程是否将被强制退出
; 519  :         EnterCriticalSection(&m_cs);
; 520  :         tmsg = m_msgDecodeThread;
; 521  :         LeaveCriticalSection(&m_cs);
; 522  :     }
; 523  : 
; 524  :     // 如果数据量很小，根本不足一个播放缓存，也要发个信号
; 525  :     if(dwSizeAmount > 0)
; 526  :     {
; 527  :         SetEvent(m_hEventDecode);
; 528  :     }
; 529  : 
; 530  :     m_waveData.bDecodeFinished = true;
; 531  : 
; 532  :     // 解码结束
; 533  :     m_pDecoder->EndDecode();
; 534  : 
; 535  :     free(pBufferBase);
; 536  :     pBufferBase = NULL;
; 537  : 
; 538  :     return 0;
; 539  : }
; 540  : 
; 541  : void WavePlayer::SetCallback(ISoundCallBack *psoundCB, long cbData)
; 542  : {
; 543  : 	m_soundCB = psoundCB;
; 544  : 	m_cbData = cbData;
; 545  : }
; 546  : 
; 547  : void WavePlayer::OnPlayFinished()
; 548  : {
; 549  : 	m_ePlayStat = Play_Stop;
; 550  : 
; 551  : 	if (m_soundCB)

  001a0	8b 4e 68	 mov	 ecx, DWORD PTR [esi+104]
  001a3	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  001aa	85 c9		 test	 ecx, ecx
  001ac	74 08		 je	 SHORT $LN39@PlayThread

; 552  : 		m_soundCB->onSoundPlayed(m_cbData);

  001ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b0	ff 76 6c	 push	 DWORD PTR [esi+108]
  001b3	ff 50 04	 call	 DWORD PTR [eax+4]
$LN39@PlayThread:

; 434  :         }
; 435  : 
; 436  :     }/// thread
; 437  : 
; 438  :     ///////////////////////////////////////////////////////////////////////////////
; 439  :     ///////////////////////////////////////////////////////////////////////////////
; 440  :     ///
; 441  :     ///            < force to close device which are still playing > 
; 442  :     ///////////////////////////////////////////////////////////////////////////////
; 443  :     ///////////////////////////////////////////////////////////////////////////////
; 444  :     if(m_hWaveoutDev)

  001b6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001b9	85 c0		 test	 eax, eax
  001bb	74 3b		 je	 SHORT $LN52@PlayThread

; 445  :     {
; 446  :         waveOutReset( m_hWaveoutDev );

  001bd	50		 push	 eax
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutReset@4
  001c4	33 ff		 xor	 edi, edi
$LL4@PlayThread:

; 450  :         {
; 451  :             if( m_wBlock.pWaveHdr[j].dwFlags & WHDR_PREPARED )

  001c6	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001c9	03 c7		 add	 eax, edi
  001cb	f6 40 10 02	 test	 BYTE PTR [eax+16], 2
  001cf	74 0c		 je	 SHORT $LN3@PlayThread

; 452  :             {
; 453  :                 waveOutUnprepareHeader(m_hWaveoutDev, &m_wBlock.pWaveHdr[j], sizeof(WAVEHDR));

  001d1	6a 20		 push	 32			; 00000020H
  001d3	50		 push	 eax
  001d4	ff 76 10	 push	 DWORD PTR [esi+16]
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutUnprepareHeader@12
$LN3@PlayThread:

; 447  : 
; 448  :         /// unprepare any blocks that are still prepared
; 449  :         for( int j = 0; j < BLOCK_COUNT; j++) 

  001dd	83 c7 20	 add	 edi, 32			; 00000020H
  001e0	81 ff 80 02 00
	00		 cmp	 edi, 640		; 00000280H
  001e6	7c de		 jl	 SHORT $LL4@PlayThread

; 454  :             }
; 455  :         }
; 456  : 
; 457  :         waveOutClose(m_hWaveoutDev);

  001e8	ff 76 10	 push	 DWORD PTR [esi+16]
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__waveOutClose@4

; 458  :         m_hWaveoutDev = NULL;

  001f1	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN52@PlayThread:

; 459  :     }
; 460  : 
; 461  :     return THREAD_EXIT;

  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	b8 da ce be 0a	 mov	 eax, 180276954		; 0abecedaH
  001ff	5b		 pop	 ebx

; 462  : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
?PlayThreadProcImpl@WavePlayer@@IAEIXZ ENDP		; WavePlayer::PlayThreadProcImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?DecodeThread@WavePlayer@@KGIPAX@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
?DecodeThread@WavePlayer@@KGIPAX@Z PROC			; WavePlayer::DecodeThread, COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 466  :     WavePlayer* pThis = (WavePlayer*)lp;
; 467  : 
; 468  :     return pThis->DecodeThreadProcImpl();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  00006	e8 00 00 00 00	 call	 ?DecodeThreadProcImpl@WavePlayer@@IAEIXZ ; WavePlayer::DecodeThreadProcImpl

; 469  : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?DecodeThread@WavePlayer@@KGIPAX@Z ENDP			; WavePlayer::DecodeThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?DecodeThreadProcImpl@WavePlayer@@IAEIXZ
_TEXT	SEGMENT
_tmsg$1$ = -8						; size = 4
_pBufferBase$ = -4					; size = 4
?DecodeThreadProcImpl@WavePlayer@@IAEIXZ PROC		; WavePlayer::DecodeThreadProcImpl, COMDAT
; _this$ = ecx

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 473  :     if(m_pDecoder == NULL || !m_pDecoder->IsVaild())

  00009	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 17		 je	 SHORT $LN7@DecodeThre
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00015	ff d0		 call	 eax
  00017	84 c0		 test	 al, al
  00019	74 0c		 je	 SHORT $LN7@DecodeThre

; 474  : 	{
; 475  : 		SetEvent(m_hEventDecode);
; 476  :         return 0;
; 477  : 	}
; 478  : 
; 479  :     // 开始解码，初始化解码器
; 480  :     if(!m_pDecoder->BeginDecode())

  0001b	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0001e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00020	ff 50 10	 call	 DWORD PTR [eax+16]
  00023	85 c0		 test	 eax, eax
  00025	75 10		 jne	 SHORT $LN6@DecodeThre
$LN7@DecodeThre:

; 481  :     {
; 482  : 		SetEvent(m_hEventDecode);

  00027	ff 76 0c	 push	 DWORD PTR [esi+12]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 536  :     pBufferBase = NULL;
; 537  : 
; 538  :     return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 539  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN6@DecodeThre:

; 483  :         return 0;
; 484  :     }
; 485  : 
; 486  :     // 申请临时内存块，存储解码后的波形数据
; 487  :     DWORD dwFrameMaxSize = m_pDecoder->GetDecodedFrameMaxSize();

  00037	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0003a	57		 push	 edi
  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	ff 50 28	 call	 DWORD PTR [eax+40]
  00040	8b f8		 mov	 edi, eax

; 488  :     LPSTR pBufferBase = (LPSTR)malloc(dwFrameMaxSize);

  00042	57		 push	 edi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 489  :     ATLASSERT(pBufferBase);
; 490  :     memset(pBufferBase, 0, dwFrameMaxSize);

  00049	57		 push	 edi
  0004a	6a 00		 push	 0
  0004c	50		 push	 eax
  0004d	89 45 fc	 mov	 DWORD PTR _pBufferBase$[ebp], eax
  00050	e8 00 00 00 00	 call	 _memset
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 491  :     if(pBufferBase == NULL) return 0;

  00058	83 7d fc 00	 cmp	 DWORD PTR _pBufferBase$[ebp], 0
  0005c	0f 84 c5 00 00
	00		 je	 $LN16@DecodeThre

; 492  : 
; 493  :     register ThreadMsg tmsg = TMSG_ALIVE;
; 494  : 
; 495  :     DWORD dwSizeAmount = 0;
; 496  :     while(!m_pDecoder->IsEOF() && tmsg)

  00062	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00065	bf 01 00 00 00	 mov	 edi, 1
  0006a	53		 push	 ebx
  0006b	33 db		 xor	 ebx, ebx
  0006d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00072	ff d0		 call	 eax
  00074	84 c0		 test	 al, al
  00076	0f 85 8f 00 00
	00		 jne	 $LN1@DecodeThre
  0007c	8d 64 24 00	 npad	 4
$LL4@DecodeThre:
  00080	85 ff		 test	 edi, edi
  00082	74 7a		 je	 SHORT $LN3@DecodeThre

; 497  :     {
; 498  :         // 解码，每帧
; 499  :         DWORD dwSize = m_pDecoder->Decode(pBufferBase);

  00084	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  00087	8d 55 fc	 lea	 edx, DWORD PTR _pBufferBase$[ebp]
  0008a	52		 push	 edx
  0008b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008d	ff 50 14	 call	 DWORD PTR [eax+20]
  00090	8b f8		 mov	 edi, eax

; 500  :         dwSizeAmount += dwSize;
; 501  : 
; 502  :         // 将解码后数据写入缓存区，供播放线程使用
; 503  :         EnterCriticalSection(&m_cs);           

  00092	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  00095	50		 push	 eax
  00096	03 df		 add	 ebx, edi
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 504  :         memcpy(m_waveData.pData + m_waveData.dwSize, pBufferBase, dwSize);

  0009e	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000a1	03 4e 3c	 add	 ecx, DWORD PTR [esi+60]
  000a4	57		 push	 edi
  000a5	ff 75 fc	 push	 DWORD PTR _pBufferBase$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _memcpy

; 505  :         m_waveData.dwSize += dwSize;

  000ae	01 7e 3c	 add	 DWORD PTR [esi+60], edi
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  :         LeaveCriticalSection(&m_cs);

  000b4	8d 7e 50	 lea	 edi, DWORD PTR [esi+80]
  000b7	57		 push	 edi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 507  : 
; 508  :         // 当解码数据量操作了一个播放缓存时，发个信号，通知可以开始播放了
; 509  :         if(dwSizeAmount > BLOCK_SIZE)

  000be	81 fb a0 0f 00
	00		 cmp	 ebx, 4000		; 00000fa0H
  000c4	76 0b		 jbe	 SHORT $LN2@DecodeThre

; 510  :         {
; 511  :             dwSizeAmount = 0;
; 512  :             SetEvent(m_hEventDecode);

  000c6	ff 76 0c	 push	 DWORD PTR [esi+12]
  000c9	33 db		 xor	 ebx, ebx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN2@DecodeThre:

; 513  :         }
; 514  : 
; 515  :         // 节省CPU时间，让CPU有时间去干别的事儿
; 516  :         Sleep(1);

  000d1	6a 01		 push	 1
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 517  : 
; 518  :         // 检测线程是否将被强制退出
; 519  :         EnterCriticalSection(&m_cs);

  000d9	57		 push	 edi
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 520  :         tmsg = m_msgDecodeThread;

  000e0	8b 46 48	 mov	 eax, DWORD PTR [esi+72]

; 521  :         LeaveCriticalSection(&m_cs);

  000e3	57		 push	 edi
  000e4	89 45 f8	 mov	 DWORD PTR _tmsg$1$[ebp], eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000ed	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  000f0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f2	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000f5	ff d0		 call	 eax
  000f7	8b 7d f8	 mov	 edi, DWORD PTR _tmsg$1$[ebp]
  000fa	84 c0		 test	 al, al
  000fc	74 82		 je	 SHORT $LL4@DecodeThre
$LN3@DecodeThre:

; 522  :     }
; 523  : 
; 524  :     // 如果数据量很小，根本不足一个播放缓存，也要发个信号
; 525  :     if(dwSizeAmount > 0)

  000fe	85 db		 test	 ebx, ebx
  00100	74 09		 je	 SHORT $LN1@DecodeThre

; 526  :     {
; 527  :         SetEvent(m_hEventDecode);

  00102	ff 76 0c	 push	 DWORD PTR [esi+12]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
$LN1@DecodeThre:

; 528  :     }
; 529  : 
; 530  :     m_waveData.bDecodeFinished = true;
; 531  : 
; 532  :     // 解码结束
; 533  :     m_pDecoder->EndDecode();

  0010b	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0010e	c7 46 40 01 00
	00 00		 mov	 DWORD PTR [esi+64], 1
  00115	8b 01		 mov	 eax, DWORD PTR [ecx]
  00117	ff 50 1c	 call	 DWORD PTR [eax+28]

; 534  : 
; 535  :     free(pBufferBase);

  0011a	ff 75 fc	 push	 DWORD PTR _pBufferBase$[ebp]
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00123	83 c4 04	 add	 esp, 4
  00126	5b		 pop	 ebx
$LN16@DecodeThre:

; 536  :     pBufferBase = NULL;
; 537  : 
; 538  :     return 0;

  00127	5f		 pop	 edi
  00128	33 c0		 xor	 eax, eax
  0012a	5e		 pop	 esi

; 539  : }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
?DecodeThreadProcImpl@WavePlayer@@IAEIXZ ENDP		; WavePlayer::DecodeThreadProcImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\waveplayer.cpp
;	COMDAT ?OnPlayFinished@WavePlayer@@IAEXXZ
_TEXT	SEGMENT
?OnPlayFinished@WavePlayer@@IAEXXZ PROC			; WavePlayer::OnPlayFinished, COMDAT
; _this$ = ecx

; 549  : 	m_ePlayStat = Play_Stop;
; 550  : 
; 551  : 	if (m_soundCB)

  00000	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00003	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0000a	85 d2		 test	 edx, edx
  0000c	74 0a		 je	 SHORT $LN1@OnPlayFini

; 552  : 		m_soundCB->onSoundPlayed(m_cbData);

  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	ff 71 6c	 push	 DWORD PTR [ecx+108]
  00013	8b ca		 mov	 ecx, edx
  00015	ff 50 04	 call	 DWORD PTR [eax+4]
$LN1@OnPlayFini:

; 553  : }

  00018	c3		 ret	 0
?OnPlayFinished@WavePlayer@@IAEXXZ ENDP			; WavePlayer::OnPlayFinished
_TEXT	ENDS
END
