; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ex_ctrl.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Ex_ctrl
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c
;	COMDAT _Ex_ctrl
_TEXT	SEGMENT
tv625 = -12						; size = 4
_var_out$1$ = -8					; size = 4
_excEnergy$1$ = -4					; size = 4
_avgEnergy$1$ = 8					; size = 4
_exEnergyHist$ = 8					; size = 4
_voicedHangover$ = 12					; size = 2
_prevBFI$ = 16						; size = 2
_carefulFlag$ = 20					; size = 2
_Ex_ctrl PROC						; COMDAT
; _excitation$ = ecx
; _excEnergy$ = edx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 74   :    avgEnergy = gmed_n(exEnergyHist, 9);                    move16();

  00008	8b 75 08	 mov	 esi, DWORD PTR _exEnergyHist$[ebp]
  0000b	57		 push	 edi
  0000c	89 55 fc	 mov	 DWORD PTR _excEnergy$1$[ebp], edx
  0000f	8b f9		 mov	 edi, ecx
  00011	ba 09 00 00 00	 mov	 edx, 9
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 _gmed_n
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0001d	0f bf 4e 0e	 movsx	 ecx, WORD PTR [esi+14]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 74   :    avgEnergy = gmed_n(exEnergyHist, 9);                    move16();

  00021	0f b7 c0	 movzx	 eax, ax
  00024	89 45 08	 mov	 DWORD PTR _avgEnergy$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00027	0f b7 46 10	 movzx	 eax, WORD PTR [esi+16]
  0002b	0f bf d0	 movsx	 edx, ax
  0002e	03 ca		 add	 ecx, edx

; 79   :     if (L_var1 > 0X00007fffL)

  00030	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00036	7e 2f		 jle	 SHORT $LN20@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  00038	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00042	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
$LN26@Ex_ctrl:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00047	66 d1 f8	 sar	 ax, 1
$LN164@Ex_ctrl:
  0004a	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 76   :    prevEnergy = shr( add (exEnergyHist[7], exEnergyHist[8]) ,1);

  0004d	0f b7 d8	 movzx	 ebx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00050	98		 cwde
  00051	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00053	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00059	7e 3d		 jle	 SHORT $LN41@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00065	eb 4e		 jmp	 SHORT $LN46@Ex_ctrl
$LN20@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00067	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0006d	7d 18		 jge	 SHORT $LN18@Ex_ctrl

; 87   :         var_out = MIN_16;

  0006f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00074	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0007e	98		 cwde
  0007f	f7 d0		 not	 eax
  00081	d1 f8		 sar	 eax, 1
  00083	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00085	eb c3		 jmp	 SHORT $LN164@Ex_ctrl
$LN18@Ex_ctrl:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00087	0f b7 c1	 movzx	 eax, cx

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)

  0008a	66 85 c9	 test	 cx, cx
  0008d	79 b8		 jns	 SHORT $LN26@Ex_ctrl

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0008f	98		 cwde
  00090	f7 d0		 not	 eax
  00092	d1 f8		 sar	 eax, 1
  00094	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00096	eb b2		 jmp	 SHORT $LN164@Ex_ctrl
$LN41@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00098	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0009e	7d 0c		 jge	 SHORT $LN39@Ex_ctrl

; 85   :     {
; 86   :         Overflow = 1;

  000a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000aa	eb 05		 jmp	 SHORT $LN158@Ex_ctrl
$LN39@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 79   :    if ( sub (exEnergyHist[8], prevEnergy) < 0)

  000ac	66 85 d2	 test	 dx, dx
  000af	79 04		 jns	 SHORT $LN46@Ex_ctrl
$LN158@Ex_ctrl:

; 80   :    {
; 81   :       prevEnergy = exEnergyHist[8];         move16 ();

  000b1	0f b7 5e 10	 movzx	 ebx, WORD PTR [esi+16]
$LN46@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000b5	8b 45 08	 mov	 eax, DWORD PTR _avgEnergy$1$[ebp]
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _excEnergy$1$[ebp]
  000bb	0f bf f0	 movsx	 esi, ax
  000be	0f bf ca	 movsx	 ecx, dx
  000c1	8b c1		 mov	 eax, ecx
  000c3	2b c6		 sub	 eax, esi

; 79   :     if (L_var1 > 0X00007fffL)

  000c5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000ca	7e 13		 jle	 SHORT $LN57@Ex_ctrl
$LN166@Ex_ctrl:
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi

; 80   :     {
; 81   :         Overflow = 1;

  000ce	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 131  :    return 0;

  000d8	33 c0		 xor	 eax, eax
  000da	5b		 pop	 ebx

; 132  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
$LN57@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000df	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000e4	7d 0c		 jge	 SHORT $LN55@Ex_ctrl

; 85   :     {
; 86   :         Overflow = 1;

  000e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000f0	eb 09		 jmp	 SHORT $LN159@Ex_ctrl
$LN55@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 86   :    if ( sub (excEnergy, avgEnergy) < 0 && sub (excEnergy, 5) > 0)

  000f2	66 85 c0	 test	 ax, ax
  000f5	0f 89 fa 01 00
	00		 jns	 $LN1@Ex_ctrl
$LN159@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000fb	8d 41 fb	 lea	 eax, DWORD PTR [ecx-5]

; 79   :     if (L_var1 > 0X00007fffL)

  000fe	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00103	7e 0c		 jle	 SHORT $LN67@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  00105	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0010f	eb 10		 jmp	 SHORT $LN160@Ex_ctrl
$LN67@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00111	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00116	7c b4		 jl	 SHORT $LN166@Ex_ctrl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 86   :    if ( sub (excEnergy, avgEnergy) < 0 && sub (excEnergy, 5) > 0)

  00118	66 85 c0	 test	 ax, ax
  0011b	0f 8e d4 01 00
	00		 jle	 $LN1@Ex_ctrl
$LN160@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00121	0f bf cb	 movsx	 ecx, bx
  00124	c1 e1 02	 shl	 ecx, 2

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00127	0f bf c1	 movsx	 eax, cx
  0012a	c7 45 f4 ff 7f
	00 00		 mov	 DWORD PTR tv625[ebp], 32767 ; 00007fffH
  00131	3b c8		 cmp	 ecx, eax
  00133	74 1b		 je	 SHORT $LN75@Ex_ctrl

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00135	66 85 db	 test	 bx, bx
  00138	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00142	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00147	0f 4f 45 f4	 cmovg	 eax, DWORD PTR tv625[ebp]
  0014b	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0014e	eb 03		 jmp	 SHORT $LN165@Ex_ctrl
$LN75@Ex_ctrl:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00150	0f b7 c1	 movzx	 eax, cx
$LN165@Ex_ctrl:
  00153	89 45 f8	 mov	 DWORD PTR _var_out$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 88   :       testEnergy = shl(prevEnergy, 2);  /* testEnergy = 4*prevEnergy; */

  00156	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00159	8b 45 0c	 mov	 eax, DWORD PTR _voicedHangover$[ebp]
  0015c	98		 cwde
  0015d	83 e8 07	 sub	 eax, 7

; 79   :     if (L_var1 > 0X00007fffL)

  00160	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00165	7e 0c		 jle	 SHORT $LN92@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  00167	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00171	eb 18		 jmp	 SHORT $LN161@Ex_ctrl
$LN92@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00173	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00178	7d 0c		 jge	 SHORT $LN90@Ex_ctrl

; 85   :     {
; 86   :         Overflow = 1;

  0017a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00184	eb 0c		 jmp	 SHORT $LN7@Ex_ctrl
$LN90@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 91   :       if ( sub (voicedHangover, 7) < 0 || prevBFI != 0 )

  00186	66 85 c0	 test	 ax, ax
  00189	78 07		 js	 SHORT $LN7@Ex_ctrl
$LN161@Ex_ctrl:
  0018b	66 83 7d 10 00	 cmp	 WORD PTR _prevBFI$[ebp], 0
  00190	74 10		 je	 SHORT $LN8@Ex_ctrl
$LN7@Ex_ctrl:

; 92   :       {
; 93   :          /* testEnergy = 3*prevEnergy */
; 94   :          testEnergy = sub (testEnergy, prevEnergy);  

  00192	8b 4d f8	 mov	 ecx, DWORD PTR _var_out$1$[ebp]
  00195	8b d3		 mov	 edx, ebx
  00197	e8 00 00 00 00	 call	 _sub
  0019c	8b 55 fc	 mov	 edx, DWORD PTR _excEnergy$1$[ebp]
  0019f	0f b7 c8	 movzx	 ecx, ax
$LN8@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  001a2	0f bf c1	 movsx	 eax, cx
  001a5	2b f0		 sub	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001a7	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  001ad	7e 0c		 jle	 SHORT $LN104@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  001af	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001b9	eb 19		 jmp	 SHORT $LN162@Ex_ctrl
$LN104@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001bb	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  001c1	7d 0c		 jge	 SHORT $LN102@Ex_ctrl

; 85   :     {
; 86   :         Overflow = 1;

  001c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  001cd	eb 0b		 jmp	 SHORT $LN109@Ex_ctrl
$LN102@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 98   :       if ( sub (avgEnergy, testEnergy) > 0)

  001cf	66 85 f6	 test	 si, si
  001d2	7e 06		 jle	 SHORT $LN109@Ex_ctrl
$LN162@Ex_ctrl:

; 99   :       {
; 100  :          avgEnergy = testEnergy;         move16 ();

  001d4	0f b7 c1	 movzx	 eax, cx
  001d7	89 45 08	 mov	 DWORD PTR _avgEnergy$1$[ebp], eax
$LN109@Ex_ctrl:

; 101  :       }
; 102  : 
; 103  :       /* scaleFactor=avgEnergy/excEnergy in Q0 (const 29 below)*/
; 104  :       exp = norm_s (excEnergy);

  001da	8b ca		 mov	 ecx, edx
  001dc	e8 00 00 00 00	 call	 _norm_s

; 105  :       excEnergy = shl (excEnergy, exp);

  001e1	8b 4d fc	 mov	 ecx, DWORD PTR _excEnergy$1$[ebp]
  001e4	0f b7 d8	 movzx	 ebx, ax
  001e7	8b d3		 mov	 edx, ebx
  001e9	e8 00 00 00 00	 call	 _shl
  001ee	0f b7 d0	 movzx	 edx, ax

; 106  :       excEnergy = div_s ((Word16) 16383, excEnergy);

  001f1	b9 ff 3f 00 00	 mov	 ecx, 16383		; 00003fffH
  001f6	e8 00 00 00 00	 call	 _div_s
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  001fb	0f bf f0	 movsx	 esi, ax
  001fe	8b 45 08	 mov	 eax, DWORD PTR _avgEnergy$1$[ebp]
  00201	98		 cwde
  00202	0f af f0	 imul	 esi, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00205	81 fe 00 00 00
	40		 cmp	 esi, 1073741824		; 40000000H
  0020b	74 04		 je	 SHORT $LN112@Ex_ctrl

; 488  :     {
; 489  :         L_var_out *= 2;

  0020d	03 f6		 add	 esi, esi

; 490  :     }
; 491  :     else

  0020f	eb 0f		 jmp	 SHORT $LN111@Ex_ctrl
$LN112@Ex_ctrl:

; 492  :     {
; 493  :         Overflow = 1;

  00211	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0021b	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
$LN111@Ex_ctrl:

; 186  :     L_diff = (Word32) var1 - var2;

  00220	0f bf c3	 movsx	 eax, bx
  00223	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00228	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0022a	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00230	7e 11		 jle	 SHORT $LN120@Ex_ctrl

; 80   :     {
; 81   :         Overflow = 1;

  00232	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0023c	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00241	eb 1c		 jmp	 SHORT $LN117@Ex_ctrl
$LN120@Ex_ctrl:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00243	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00249	7d 11		 jge	 SHORT $LN118@Ex_ctrl

; 85   :     {
; 86   :         Overflow = 1;

  0024b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00255	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0025a	eb 03		 jmp	 SHORT $LN117@Ex_ctrl
$LN118@Ex_ctrl:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0025c	0f b7 d1	 movzx	 edx, cx
$LN117@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 108  :       t0 = L_shr (t0, sub (20, exp));  /* const=30 for t0 in Q0, 20 for Q10 */

  0025f	8b ce		 mov	 ecx, esi
  00261	e8 00 00 00 00	 call	 _L_shr
  00266	8b f0		 mov	 esi, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 983  :     L_var_out = L_var1 - L_var2;

  00268	8d 8e 01 80 ff
	ff		 lea	 ecx, DWORD PTR [esi-32767]

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  0026e	85 f6		 test	 esi, esi
  00270	79 1d		 jns	 SHORT $LN125@Ex_ctrl

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00272	8b c1		 mov	 eax, ecx
  00274	33 c6		 xor	 eax, esi
  00276	79 17		 jns	 SHORT $LN125@Ex_ctrl

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00278	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  0027a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00284	85 f6		 test	 esi, esi
  00286	0f 98 c1	 sets	 cl
  00289	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN125@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 109  :       if ( L_sub(t0, 32767) > 0 )

  0028f	85 c9		 test	 ecx, ecx
  00291	0f 4f 75 f4	 cmovg	 esi, DWORD PTR tv625[ebp]

; 110  :       {
; 111  :          t0 = 32767; move32 ();   /* saturate  */
; 112  :       }
; 113  :       scaleFactor = extract_l (t0); 
; 114  : 
; 115  :       /* test if scaleFactor > 3.0 */
; 116  :       test (); test ();
; 117  :       if ( carefulFlag != 0 && sub(scaleFactor, 3072) > 0 ) 

  00295	66 83 7d 14 00	 cmp	 WORD PTR _carefulFlag$[ebp], 0
  0029a	0f b7 de	 movzx	 ebx, si
  0029d	74 12		 je	 SHORT $LN137@Ex_ctrl
  0029f	ba 00 0c 00 00	 mov	 edx, 3072		; 00000c00H
  002a4	8b ce		 mov	 ecx, esi
  002a6	e8 00 00 00 00	 call	 _sub
  002ab	66 85 c0	 test	 ax, ax
  002ae	0f 4f da	 cmovg	 ebx, edx
$LN137@Ex_ctrl:

; 118  :       {
; 119  :          scaleFactor = 3072;              move16 ();
; 120  :       }
; 121  : 
; 122  :       /* scale the excitation by scaleFactor */
; 123  :       for (i = 0; i < L_SUBFR; i++)

  002b1	0f bf d3	 movsx	 edx, bx
  002b4	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL3@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  002c0	0f bf 07	 movsx	 eax, WORD PTR [edi]
  002c3	0f af c2	 imul	 eax, edx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  002c6	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  002cb	74 0d		 je	 SHORT $LN140@Ex_ctrl

; 488  :     {
; 489  :         L_var_out *= 2;

  002cd	03 c0		 add	 eax, eax

; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  002cf	79 18		 jns	 SHORT $LN144@Ex_ctrl

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  002d1	f7 d0		 not	 eax
  002d3	c1 f8 0b	 sar	 eax, 11			; 0000000bH
  002d6	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  002d8	eb 12		 jmp	 SHORT $LN143@Ex_ctrl
$LN140@Ex_ctrl:

; 492  :     {
; 493  :         Overflow = 1;

  002da	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  002e4	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN144@Ex_ctrl:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  002e9	c1 f8 0b	 sar	 eax, 11			; 0000000bH
$LN143@Ex_ctrl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ex_ctrl.c

; 127  :          excitation[i] = extract_l (t0);

  002ec	66 89 07	 mov	 WORD PTR [edi], ax
  002ef	83 c7 02	 add	 edi, 2
  002f2	49		 dec	 ecx
  002f3	75 cb		 jne	 SHORT $LL3@Ex_ctrl
$LN1@Ex_ctrl:
  002f5	5f		 pop	 edi
  002f6	5e		 pop	 esi

; 131  :    return 0;

  002f7	33 c0		 xor	 eax, eax
  002f9	5b		 pop	 ebx

; 132  : }

  002fa	8b e5		 mov	 esp, ebp
  002fc	5d		 pop	 ebp
  002fd	c3		 ret	 0
_Ex_ctrl ENDP
_TEXT	ENDS
END
