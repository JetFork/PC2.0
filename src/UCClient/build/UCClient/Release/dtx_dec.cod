; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\dtx_dec.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CO@KHMAKKFJ@dtx_dec_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@OPKPKAGI@dtx_dec_reset?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CB@LABEIKEE@dtx_dec_init?3?5invalid?5parameter?6@ ; `string'
;	COMDAT ??_C@_0CB@LABEIKEE@dtx_dec_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@LABEIKEE@dtx_dec_init?3?5invalid?5parameter?6@ DB 'dtx_dec_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OPKPKAGI@dtx_dec_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@OPKPKAGI@dtx_dec_reset?3?5invalid?5parameter@ DB 'dtx_dec_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KHMAKKFJ@dtx_dec_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@KHMAKKFJ@dtx_dec_init?3?5can?5not?5malloc?5sta@ DB 'dtx_dec_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
_mean_lsf DW	0568H
	DW	081dH
	DW	0d5cH
	DW	013f4H
	DW	01a56H
	DW	01fbaH
	DW	02687H
	DW	02b54H
	DW	031aaH
	DW	03585H
_dtx_log_en_adjust DW 0fc01H
	DW	0fc92H
	DW	0fd24H
	DW	0fdb6H
	DW	0fe48H
	DW	0fedaH
	DW	0ff6cH
	DW	00H
	DW	00H
_lsp_init_data DW 07530H
	DW	06590H
	DW	05208H
	DW	03a98H
	DW	01f40H
	DW	00H
	DW	0e0c0H
	DW	0c568H
	DW	0adf8H
	DW	09a70H
_lsf_hist_mean_scale DW 04e20H
	DW	04e20H
	DW	04e20H
	DW	04e20H
	DW	04e20H
	DW	04650H
	DW	04000H
	DW	02000H
	DW	00H
	DW	00H
PUBLIC	_dtx_dec_reset
PUBLIC	_dtx_dec_exit
PUBLIC	_rx_dtx_handler
PUBLIC	_dtx_dec_init
PUBLIC	_dtx_dec
PUBLIC	_dtx_dec_activity_update
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _dtx_dec_activity_update
_TEXT	SEGMENT
_log_en_m$ = -8						; size = 2
_log_en_e$ = -4						; size = 2
_frame$ = 8						; size = 4
_dtx_dec_activity_update PROC				; COMDAT
; _st$ = ecx
; _lsf$ = edx

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b f2		 mov	 esi, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0000c	0f bf 87 d4 00
	00 00		 movsx	 eax, WORD PTR [edi+212]
  00013	83 c0 0a	 add	 eax, 10			; 0000000aH

; 79   :     if (L_var1 > 0X00007fffL)

  00016	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0001b	7e 11		 jle	 SHORT $LN13@dtx_dec_ac

; 80   :     {
; 81   :         Overflow = 1;

  0001d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00027	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0002c	eb 1b		 jmp	 SHORT $LN10@dtx_dec_ac
$LN13@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0002e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00033	7d 11		 jge	 SHORT $LN11@dtx_dec_ac

; 85   :     {
; 86   :         Overflow = 1;

  00035	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0003f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00044	eb 03		 jmp	 SHORT $LN10@dtx_dec_ac
$LN11@dtx_dec_ac:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00046	0f b7 c0	 movzx	 eax, ax
$LN10@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 678  :    st->lsf_hist_ptr = add(st->lsf_hist_ptr,M);                     move16();

  00049	66 89 87 d4 00
	00 00		 mov	 WORD PTR [edi+212], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00050	98		 cwde
  00051	83 e8 50	 sub	 eax, 80			; 00000050H

; 79   :     if (L_var1 > 0X00007fffL)

  00054	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00059	7e 0c		 jle	 SHORT $LN27@dtx_dec_ac

; 80   :     {
; 81   :         Overflow = 1;

  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00065	eb 21		 jmp	 SHORT $LN32@dtx_dec_ac
$LN27@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00067	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0006c	7d 0c		 jge	 SHORT $LN25@dtx_dec_ac

; 85   :     {
; 86   :         Overflow = 1;

  0006e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00078	eb 0e		 jmp	 SHORT $LN32@dtx_dec_ac
$LN25@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 680  :    if (sub(st->lsf_hist_ptr, 80) == 0)

  0007a	66 85 c0	 test	 ax, ax
  0007d	75 09		 jne	 SHORT $LN32@dtx_dec_ac

; 681  :    {
; 682  :       st->lsf_hist_ptr = 0;                                        move16();

  0007f	33 c0		 xor	 eax, eax
  00081	66 89 87 d4 00
	00 00		 mov	 WORD PTR [edi+212], ax
$LN32@dtx_dec_ac:

; 683  :    }
; 684  :    Copy(lsf, &st->lsf_hist[st->lsf_hist_ptr], M); 

  00088	0f bf 8f d4 00
	00 00		 movsx	 ecx, WORD PTR [edi+212]
  0008f	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00094	83 c1 1a	 add	 ecx, 26			; 0000001aH
  00097	8d 0c 4f	 lea	 ecx, DWORD PTR [edi+ecx*2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  0009a	2b f1		 sub	 esi, ecx
  0009c	8d 64 24 00	 npad	 4
$LL36@dtx_dec_ac:

; 61   :     {
; 62   :         y[i] = x[i];            move16 (); 

  000a0	66 8b 04 0e	 mov	 ax, WORD PTR [esi+ecx]
  000a4	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  000a7	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax
  000ab	4a		 dec	 edx
  000ac	75 f2		 jne	 SHORT $LL36@dtx_dec_ac
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 687  :    L_frame_en = 0;     /* Q0 */                                    move32();

  000ae	8b 75 08	 mov	 esi, DWORD PTR _frame$[ebp]
  000b1	53		 push	 ebx
  000b2	bb a0 00 00 00	 mov	 ebx, 160		; 000000a0H
  000b7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL4@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000c0	0f bf 06	 movsx	 eax, WORD PTR [esi]
  000c3	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000c6	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000cb	74 04		 je	 SHORT $LN46@dtx_dec_ac

; 488  :     {
; 489  :         L_var_out *= 2;

  000cd	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  000cf	eb 0f		 jmp	 SHORT $LN45@dtx_dec_ac
$LN46@dtx_dec_ac:

; 492  :     {
; 493  :         Overflow = 1;

  000d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000db	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN45@dtx_dec_ac:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  000e0	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000e3	33 c2		 xor	 eax, edx
  000e5	78 1d		 js	 SHORT $LN49@dtx_dec_ac

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  000e7	8b c1		 mov	 eax, ecx
  000e9	33 c2		 xor	 eax, edx
  000eb	79 17		 jns	 SHORT $LN49@dtx_dec_ac

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  000ed	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  000ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000f9	85 d2		 test	 edx, edx
  000fb	0f 98 c1	 sets	 cl
  000fe	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN49@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 688  :    for (i=0; i < L_FRAME; i++)

  00104	83 c6 02	 add	 esi, 2

; 689  :    {
; 690  :       L_frame_en = L_mac(L_frame_en, frame[i], frame[i]); 

  00107	8b d1		 mov	 edx, ecx
  00109	4b		 dec	 ebx
  0010a	75 b4		 jne	 SHORT $LL4@dtx_dec_ac
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 120  :     exp = norm_l (L_x);

  0010c	8b c1		 mov	 eax, ecx
  0010e	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  0010f	85 c9		 test	 ecx, ecx
  00111	75 12		 jne	 SHORT $LN62@dtx_dec_ac

; 2110 :     {
; 2111 :         var_out = 0;

  00113	33 f6		 xor	 esi, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  00115	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1348 :         L_var_out = L_shr (L_var1, -var2);

  00118	f7 d8		 neg	 eax
  0011a	8b d0		 mov	 edx, eax
  0011c	e8 00 00 00 00	 call	 _L_shr
  00121	8b c8		 mov	 ecx, eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  00123	eb 7b		 jmp	 SHORT $LN68@dtx_dec_ac
$LN62@dtx_dec_ac:

; 2112 :     }
; 2113 :     else
; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00125	83 f9 ff	 cmp	 ecx, -1
  00128	75 22		 jne	 SHORT $LN60@dtx_dec_ac

; 2116 :         {
; 2117 :             var_out = 31;

  0012a	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  0012f	0f b7 c6	 movzx	 eax, si
$LL185@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00132	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00138	7f 57		 jg	 SHORT $LN166@dtx_dec_ac

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0013a	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  00140	7c 48		 jl	 SHORT $LN167@dtx_dec_ac

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00142	48		 dec	 eax
  00143	03 c9		 add	 ecx, ecx
  00145	66 85 c0	 test	 ax, ax
  00148	7f e8		 jg	 SHORT $LL185@dtx_dec_ac

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0014a	eb 54		 jmp	 SHORT $LN68@dtx_dec_ac
$LN60@dtx_dec_ac:

; 2118 :         }
; 2119 :         else
; 2120 :         {
; 2121 :             if (L_var1 < 0)

  0014c	85 c9		 test	 ecx, ecx
  0014e	79 04		 jns	 SHORT $LN58@dtx_dec_ac

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00150	8b c1		 mov	 eax, ecx
  00152	f7 d0		 not	 eax
$LN58@dtx_dec_ac:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00154	33 f6		 xor	 esi, esi
  00156	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0015b	7d 0d		 jge	 SHORT $LN55@dtx_dec_ac
  0015d	8d 49 00	 npad	 3
$LL57@dtx_dec_ac:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00160	03 c0		 add	 eax, eax
  00162	46		 inc	 esi
  00163	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00168	7c f6		 jl	 SHORT $LL57@dtx_dec_ac
$LN55@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  0016a	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1344 :     if (var2 <= 0)

  0016d	66 85 f6	 test	 si, si
  00170	7f c0		 jg	 SHORT $LL185@dtx_dec_ac

; 1345 :     {
; 1346 :         if (var2 < -32)

  00172	ba e0 ff ff ff	 mov	 edx, -32		; ffffffe0H
  00177	66 3b f2	 cmp	 si, dx
  0017a	0f 4c c2	 cmovl	 eax, edx

; 1348 :         L_var_out = L_shr (L_var1, -var2);

  0017d	f7 d8		 neg	 eax
  0017f	8b d0		 mov	 edx, eax
  00181	e8 00 00 00 00	 call	 _L_shr
  00186	8b c8		 mov	 ecx, eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  00188	eb 16		 jmp	 SHORT $LN68@dtx_dec_ac
$LN167@dtx_dec_ac:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0018a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0018f	eb 05		 jmp	 SHORT $LN187@dtx_dec_ac
$LN166@dtx_dec_ac:

; 1360 :                 L_var_out = MAX_32;

  00191	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN187@dtx_dec_ac:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00196	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN68@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  001a0	8d 45 f8	 lea	 eax, DWORD PTR _log_en_m$[ebp]
  001a3	8b d6		 mov	 edx, esi
  001a5	50		 push	 eax
  001a6	8d 45 fc	 lea	 eax, DWORD PTR _log_en_e$[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 _Log2_norm
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  001af	66 8b 55 fc	 mov	 dx, WORD PTR _log_en_e$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  001b3	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  001b6	0f bf ca	 movsx	 ecx, dx
  001b9	c1 e1 0a	 shl	 ecx, 10			; 0000000aH

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  001bc	0f bf c1	 movsx	 eax, cx
  001bf	3b c8		 cmp	 ecx, eax
  001c1	74 1f		 je	 SHORT $LN79@dtx_dec_ac

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  001c3	66 85 d2	 test	 dx, dx
  001c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001d0	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001d5	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  001da	0f 4f c1	 cmovg	 eax, ecx
  001dd	0f b7 d0	 movzx	 edx, ax

; 304  :         }
; 305  :         else

  001e0	eb 03		 jmp	 SHORT $LN76@dtx_dec_ac
$LN79@dtx_dec_ac:

; 306  :         {
; 307  :             var_out = extract_l (result);

  001e2	0f b7 d1	 movzx	 edx, cx
$LN76@dtx_dec_ac:

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)

  001e5	66 8b 45 f8	 mov	 ax, WORD PTR _log_en_m$[ebp]
  001e9	66 85 c0	 test	 ax, ax
  001ec	79 0a		 jns	 SHORT $LN97@dtx_dec_ac

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001ee	98		 cwde
  001ef	f7 d0		 not	 eax
  001f1	c1 f8 05	 sar	 eax, 5
  001f4	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  001f6	eb 04		 jmp	 SHORT $LN188@dtx_dec_ac
$LN97@dtx_dec_ac:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  001f8	66 c1 f8 05	 sar	 ax, 5
$LN188@dtx_dec_ac:
  001fc	0f b7 c0	 movzx	 eax, ax

; 139  :     L_sum = (Word32) var1 + var2;

  001ff	0f bf c8	 movsx	 ecx, ax
  00202	0f bf c2	 movsx	 eax, dx
  00205	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00207	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0020d	7e 11		 jle	 SHORT $LN121@dtx_dec_ac

; 80   :     {
; 81   :         Overflow = 1;

  0020f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00219	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0021e	eb 1c		 jmp	 SHORT $LN118@dtx_dec_ac
$LN121@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00220	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00226	7d 11		 jge	 SHORT $LN119@dtx_dec_ac

; 85   :     {
; 86   :         Overflow = 1;

  00228	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00232	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00237	eb 03		 jmp	 SHORT $LN118@dtx_dec_ac
$LN119@dtx_dec_ac:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00239	0f b7 c1	 movzx	 eax, cx
$LN118@dtx_dec_ac:

; 186  :     L_diff = (Word32) var1 - var2;

  0023c	98		 cwde
  0023d	2d 49 21 00 00	 sub	 eax, 8521		; 00002149H

; 79   :     if (L_var1 > 0X00007fffL)

  00242	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00247	7e 11		 jle	 SHORT $LN131@dtx_dec_ac

; 80   :     {
; 81   :         Overflow = 1;

  00249	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00253	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00258	eb 1b		 jmp	 SHORT $LN128@dtx_dec_ac
$LN131@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0025a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0025f	7d 11		 jge	 SHORT $LN129@dtx_dec_ac

; 85   :     {
; 86   :         Overflow = 1;

  00261	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0026b	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00270	eb 03		 jmp	 SHORT $LN128@dtx_dec_ac
$LN129@dtx_dec_ac:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00272	0f b7 c8	 movzx	 ecx, ax
$LN128@dtx_dec_ac:

; 139  :     L_sum = (Word32) var1 + var2;

  00275	0f bf 87 88 01
	00 00		 movsx	 eax, WORD PTR [edi+392]
  0027c	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0027d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00282	7e 11		 jle	 SHORT $LN141@dtx_dec_ac

; 80   :     {
; 81   :         Overflow = 1;

  00284	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0028e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00293	eb 1b		 jmp	 SHORT $LN138@dtx_dec_ac
$LN141@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00295	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0029a	7d 11		 jge	 SHORT $LN139@dtx_dec_ac

; 85   :     {
; 86   :         Overflow = 1;

  0029c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002a6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002ab	eb 03		 jmp	 SHORT $LN138@dtx_dec_ac
$LN139@dtx_dec_ac:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002ad	0f b7 c0	 movzx	 eax, ax
$LN138@dtx_dec_ac:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 703  :    st->log_en_hist_ptr = add(st->log_en_hist_ptr, 1);

  002b0	66 89 87 88 01
	00 00		 mov	 WORD PTR [edi+392], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002b7	98		 cwde
  002b8	83 e8 08	 sub	 eax, 8

; 79   :     if (L_var1 > 0X00007fffL)

  002bb	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002c0	7e 0c		 jle	 SHORT $LN153@dtx_dec_ac
$LN189@dtx_dec_ac:

; 80   :     {
; 81   :         Overflow = 1;

  002c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002cc	eb 15		 jmp	 SHORT $LN184@dtx_dec_ac
$LN153@dtx_dec_ac:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002ce	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002d3	7c ed		 jl	 SHORT $LN189@dtx_dec_ac
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 705  :    if (sub(st->log_en_hist_ptr, DTX_HIST_SIZE) == 0)

  002d5	66 85 c0	 test	 ax, ax
  002d8	75 09		 jne	 SHORT $LN184@dtx_dec_ac

; 706  :    {
; 707  :       st->log_en_hist_ptr = 0;                                     move16();

  002da	33 c0		 xor	 eax, eax
  002dc	66 89 87 88 01
	00 00		 mov	 WORD PTR [edi+392], ax
$LN184@dtx_dec_ac:

; 708  :    }
; 709  :    st->log_en_hist[st->log_en_hist_ptr] = log_en; /* Q11 */        move16();

  002e3	0f bf 87 88 01
	00 00		 movsx	 eax, WORD PTR [edi+392]
  002ea	66 89 8c 47 78
	01 00 00	 mov	 WORD PTR [edi+eax*2+376], cx
  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi

; 710  : }

  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c3		 ret	 0
_dtx_dec_activity_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _dtx_dec
_TEXT	SEGMENT
_A_t$GSCopy$1$ = -236					; size = 4
tv7359 = -232						; size = 4
_averState$GSCopy$1$ = -228				; size = 4
_mem_syn$GSCopy$1$ = -224				; size = 4
_synth$GSCopy$1$ = -220					; size = 4
tv7410 = -216						; size = 4
tv7328 = -216						; size = 4
_parm$GSCopy$1$ = -212					; size = 4
_L_var_out$1$ = -212					; size = 4
_predState$GSCopy$1$ = -208				; size = 4
tv7383 = -208						; size = 4
tv7378 = -208						; size = 4
_lsfState$GSCopy$1$ = -204				; size = 4
_log_pg_m$ = -204					; size = 2
tv7370 = -200						; size = 4
tv7358 = -200						; size = 4
tv7405 = -196						; size = 4
tv7360 = -196						; size = 4
_log_pg_e$ = -196					; size = 2
_st$GSCopy$1$ = -192					; size = 4
_L_lsf$ = -188						; size = 40
_acoeff_variab$ = -172					; size = 22
_ex$ = -148						; size = 80
_refl$ = -68						; size = 20
_lsp_int$ = -68						; size = 20
_lsf$ = -68						; size = 20
_lsp_int_variab$ = -48					; size = 20
_lsf_int$ = -48						; size = 20
_acoeff$ = -28						; size = 22
_lsf_int_variab$ = -28					; size = 20
__$ArrayPad$ = -4					; size = 4
_lsfState$ = 8						; size = 4
_predState$ = 12					; size = 4
_averState$ = 16					; size = 4
_new_state$ = 20					; size = 4
_mode$ = 24						; size = 4
_parm$ = 28						; size = 4
_synth$ = 32						; size = 4
_A_t$ = 36						; size = 4
_dtx_dec PROC						; COMDAT
; _st$ = ecx
; _mem_syn$ = edx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lsfState$[ebp]
  00016	89 85 34 ff ff
	ff		 mov	 DWORD PTR _lsfState$GSCopy$1$[ebp], eax
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _predState$[ebp]
  0001f	89 85 30 ff ff
	ff		 mov	 DWORD PTR _predState$GSCopy$1$[ebp], eax
  00025	8b 45 10	 mov	 eax, DWORD PTR _averState$[ebp]
  00028	53		 push	 ebx
  00029	89 85 1c ff ff
	ff		 mov	 DWORD PTR _averState$GSCopy$1$[ebp], eax
  0002f	8b d9		 mov	 ebx, ecx
  00031	8b 45 1c	 mov	 eax, DWORD PTR _parm$[ebp]
  00034	89 85 2c ff ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], eax
  0003a	8b 45 20	 mov	 eax, DWORD PTR _synth$[ebp]

; 223  :    Word16 log_en_index;
; 224  :    Word16 i, j;
; 225  :    Word16 int_fac;
; 226  :    Word32 L_log_en_int;
; 227  :    Word16 lsp_int[M];
; 228  :    Word16 log_en_int_e;
; 229  :    Word16 log_en_int_m;
; 230  :    Word16 level;
; 231  :    Word16 acoeff[M + 1];
; 232  :    Word16 refl[M];
; 233  :    Word16 pred_err;
; 234  :    Word16 ex[L_SUBFR];
; 235  :    Word16 ma_pred_init;
; 236  :    Word16 log_pg_e, log_pg_m;
; 237  :    Word16 log_pg;
; 238  :    Flag negative;
; 239  :    Word16 lsf_mean;
; 240  :    Word32 L_lsf_mean;
; 241  :    Word16 lsf_variab_index;
; 242  :    Word16 lsf_variab_factor;
; 243  :    Word16 lsf_int[M];
; 244  :    Word16 lsf_int_variab[M];
; 245  :    Word16 lsp_int_variab[M];
; 246  :    Word16 acoeff_variab[M + 1];
; 247  : 
; 248  :    Word16 lsf[M];
; 249  :    Word32 L_lsf[M];
; 250  :    Word16 ptr;
; 251  :    Word16 tmp_int_length;
; 252  : 
; 253  : 
; 254  :    /*  This function is called if synthesis state is not SPEECH 
; 255  :     *  the globally passed  inputs to this function are 
; 256  :     * st->sid_frame 
; 257  :     * st->valid_data 
; 258  :     * st->dtxHangoverAdded
; 259  :     * new_state  (SPEECH, DTX, DTX_MUTE)
; 260  :     */
; 261  : 
; 262  :    test(); test();
; 263  :    if ((st->dtxHangoverAdded != 0) && 
; 264  :        (st->sid_frame != 0))

  0003d	66 83 bb 94 01
	00 00 00	 cmp	 WORD PTR [ebx+404], 0
  00045	56		 push	 esi
  00046	89 85 24 ff ff
	ff		 mov	 DWORD PTR _synth$GSCopy$1$[ebp], eax
  0004c	8b 45 24	 mov	 eax, DWORD PTR _A_t$[ebp]
  0004f	57		 push	 edi
  00050	89 95 20 ff ff
	ff		 mov	 DWORD PTR _mem_syn$GSCopy$1$[ebp], edx
  00056	89 9d 40 ff ff
	ff		 mov	 DWORD PTR _st$GSCopy$1$[ebp], ebx
  0005c	89 85 14 ff ff
	ff		 mov	 DWORD PTR _A_t$GSCopy$1$[ebp], eax
  00062	0f 84 61 05 00
	00		 je	 $LN48@dtx_dec
  00068	66 83 bb 90 01
	00 00 00	 cmp	 WORD PTR [ebx+400], 0
  00070	0f 84 53 05 00
	00		 je	 $LN48@dtx_dec

; 270  :       st->log_en_adjust = dtx_log_en_adjust[mode];

  00076	8b 45 18	 mov	 eax, DWORD PTR _mode$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00079	0f bf 8b d4 00
	00 00		 movsx	 ecx, WORD PTR [ebx+212]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 270  :       st->log_en_adjust = dtx_log_en_adjust[mode];

  00080	66 8b 04 45 00
	00 00 00	 mov	 ax, WORD PTR _dtx_log_en_adjust[eax*2]
  00088	66 89 83 8a 01
	00 00		 mov	 WORD PTR [ebx+394], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0008f	8d 41 0a	 lea	 eax, DWORD PTR [ecx+10]

; 79   :     if (L_var1 > 0X00007fffL)

  00092	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00097	7e 11		 jle	 SHORT $LN77@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00099	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000a3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000a8	eb 1b		 jmp	 SHORT $LN74@dtx_dec
$LN77@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000aa	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000af	7d 11		 jge	 SHORT $LN75@dtx_dec

; 86   :         Overflow = 1;

  000b1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000bb	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  000c0	eb 03		 jmp	 SHORT $LN74@dtx_dec
$LN75@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  000c2	0f b7 c0	 movzx	 eax, ax
$LN74@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 272  :       ptr = add(st->lsf_hist_ptr, M);                               move16(); 

  000c5	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000c8	98		 cwde
  000c9	83 e8 50	 sub	 eax, 80			; 00000050H

; 79   :     if (L_var1 > 0X00007fffL)

  000cc	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000d1	7e 0c		 jle	 SHORT $LN91@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  000d3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000dd	eb 1b		 jmp	 SHORT $LN96@dtx_dec
$LN91@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000df	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000e4	7d 0c		 jge	 SHORT $LN89@dtx_dec

; 86   :         Overflow = 1;

  000e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  000f0	eb 08		 jmp	 SHORT $LN96@dtx_dec
$LN89@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 274  :       if (sub(ptr, 80) == 0)

  000f2	33 f6		 xor	 esi, esi
  000f4	66 85 c0	 test	 ax, ax
  000f7	0f 44 d6	 cmove	 edx, esi
$LN96@dtx_dec:

; 275  :       {
; 276  :          ptr = 0;                                                   move16();
; 277  :       }
; 278  :       Copy( &st->lsf_hist[st->lsf_hist_ptr],&st->lsf_hist[ptr],M); 

  000fa	0f bf d2	 movsx	 edx, dx
  000fd	83 c1 1a	 add	 ecx, 26			; 0000001aH
  00100	83 c2 1a	 add	 edx, 26			; 0000001aH
  00103	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  00108	8d 0c 4b	 lea	 ecx, DWORD PTR [ebx+ecx*2]
  0010b	8d 14 53	 lea	 edx, DWORD PTR [ebx+edx*2]
  0010e	8b ff		 npad	 2
$LL100@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00110	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00113	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00116	66 89 02	 mov	 WORD PTR [edx], ax
  00119	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  0011c	4e		 dec	 esi
  0011d	75 f1		 jne	 SHORT $LL100@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0011f	0f bf 93 88 01
	00 00		 movsx	 edx, WORD PTR [ebx+392]
  00126	8d 42 01	 lea	 eax, DWORD PTR [edx+1]

; 79   :     if (L_var1 > 0X00007fffL)

  00129	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0012e	7e 11		 jle	 SHORT $LN110@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00130	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0013a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0013f	eb 1b		 jmp	 SHORT $LN107@dtx_dec
$LN110@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00141	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00146	7d 11		 jge	 SHORT $LN108@dtx_dec

; 86   :         Overflow = 1;

  00148	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00152	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00157	eb 03		 jmp	 SHORT $LN107@dtx_dec
$LN108@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00159	0f b7 c0	 movzx	 eax, ax
$LN107@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 280  :       ptr = add(st->log_en_hist_ptr,1);                             move16();

  0015c	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0015f	98		 cwde
  00160	83 e8 08	 sub	 eax, 8

; 79   :     if (L_var1 > 0X00007fffL)

  00163	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00168	7e 0c		 jle	 SHORT $LN124@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0016a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00174	eb 1b		 jmp	 SHORT $LN129@dtx_dec
$LN124@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00176	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0017b	7d 0c		 jge	 SHORT $LN122@dtx_dec

; 86   :         Overflow = 1;

  0017d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  00187	eb 08		 jmp	 SHORT $LN129@dtx_dec
$LN122@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 282  :       if (sub(ptr, DTX_HIST_SIZE) == 0)

  00189	33 f6		 xor	 esi, esi
  0018b	66 85 c0	 test	 ax, ax
  0018e	0f 44 ce	 cmove	 ecx, esi
$LN129@dtx_dec:

; 283  :       {
; 284  :          ptr = 0;                                                   move16();
; 285  :       }
; 286  :       move16();
; 287  :       st->log_en_hist[ptr] = st->log_en_hist[st->log_en_hist_ptr]; /* Q11 */

  00191	66 8b 84 53 78
	01 00 00	 mov	 ax, WORD PTR [ebx+edx*2+376]

; 288  :       
; 289  :       /* compute mean log energy and lsp *
; 290  :        * from decoded signal (SID_FIRST) */         
; 291  :       st->log_en = 0;                                               move16();
; 292  :       for (i = 0; i < M; i++)
; 293  :       {
; 294  :          L_lsf[i] = 0;                                              move16();
; 295  :       }
; 296  :       
; 297  :       /* average energy and lsp */
; 298  :       for (i = 0; i < DTX_HIST_SIZE; i++)

  00199	8d 7b 34	 lea	 edi, DWORD PTR [ebx+52]
  0019c	0f bf c9	 movsx	 ecx, cx
  0019f	0f 57 c0	 xorps	 xmm0, xmm0
  001a2	f3 0f 7f 85 44
	ff ff ff	 movdqu	 XMMWORD PTR _L_lsf$[ebp], xmm0
  001aa	c7 85 3c ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv7405[ebp], 8
  001b4	f3 0f 7f 85 54
	ff ff ff	 movdqu	 XMMWORD PTR _L_lsf$[ebp+16], xmm0
  001bc	66 89 84 4b 78
	01 00 00	 mov	 WORD PTR [ebx+ecx*2+376], ax
  001c4	33 c0		 xor	 eax, eax
  001c6	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  001ca	33 d2		 xor	 edx, edx
  001cc	8d 83 78 01 00
	00		 lea	 eax, DWORD PTR [ebx+376]
  001d2	66 0f d6 85 64
	ff ff ff	 movq	 QWORD PTR _L_lsf$[ebp+32], xmm0
  001da	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv7370[ebp], eax
$LL59@dtx_dec:

; 301  :                           shr(st->log_en_hist[i],3));

  001e0	0f b7 00	 movzx	 eax, WORD PTR [eax]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  001e3	66 85 c0	 test	 ax, ax
  001e6	79 0a		 jns	 SHORT $LN138@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001e8	98		 cwde
  001e9	f7 d0		 not	 eax
  001eb	c1 f8 03	 sar	 eax, 3
  001ee	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  001f0	eb 04		 jmp	 SHORT $LN1564@dtx_dec
$LN138@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  001f2	66 c1 f8 03	 sar	 ax, 3
$LN1564@dtx_dec:
  001f6	0f b7 c0	 movzx	 eax, ax

; 139  :     L_sum = (Word32) var1 + var2;

  001f9	0f bf c8	 movsx	 ecx, ax
  001fc	0f bf c2	 movsx	 eax, dx
  001ff	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00201	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00207	7e 11		 jle	 SHORT $LN162@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00209	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00213	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00218	eb 1c		 jmp	 SHORT $LN159@dtx_dec
$LN162@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0021a	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00220	7d 11		 jge	 SHORT $LN160@dtx_dec

; 86   :         Overflow = 1;

  00222	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0022c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00231	eb 03		 jmp	 SHORT $LN159@dtx_dec
$LN160@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00233	0f b7 c1	 movzx	 eax, cx
$LN159@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 301  :                           shr(st->log_en_hist[i],3));

  00236	0f b7 c8	 movzx	 ecx, ax
  00239	8d b5 44 ff ff
	ff		 lea	 esi, DWORD PTR _L_lsf$[ebp]
  0023f	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  00243	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  00248	89 8d 28 ff ff
	ff		 mov	 DWORD PTR tv7328[ebp], ecx
  0024e	8b ff		 npad	 2
$LL56@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1715 :     L_var_out = (Word32) var1;

  00250	0f bf 07	 movsx	 eax, WORD PTR [edi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 305  :                              L_deposit_l(st->lsf_hist[i * M + j]));

  00253	8b 16		 mov	 edx, DWORD PTR [esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  00255	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00258	33 c2		 xor	 eax, edx
  0025a	78 1d		 js	 SHORT $LN169@dtx_dec

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0025c	8b c1		 mov	 eax, ecx
  0025e	33 c2		 xor	 eax, edx
  00260	79 17		 jns	 SHORT $LN169@dtx_dec

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00262	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  00264	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0026e	85 d2		 test	 edx, edx
  00270	0f 98 c1	 sets	 cl
  00273	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN169@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 305  :                              L_deposit_l(st->lsf_hist[i * M + j]));

  00279	89 0e		 mov	 DWORD PTR [esi], ecx
  0027b	83 c7 02	 add	 edi, 2
  0027e	83 c6 04	 add	 esi, 4
  00281	4b		 dec	 ebx
  00282	75 cc		 jne	 SHORT $LL56@dtx_dec

; 288  :       
; 289  :       /* compute mean log energy and lsp *
; 290  :        * from decoded signal (SID_FIRST) */         
; 291  :       st->log_en = 0;                                               move16();
; 292  :       for (i = 0; i < M; i++)
; 293  :       {
; 294  :          L_lsf[i] = 0;                                              move16();
; 295  :       }
; 296  :       
; 297  :       /* average energy and lsp */
; 298  :       for (i = 0; i < DTX_HIST_SIZE; i++)

  00284	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv7370[ebp]
  0028a	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv7328[ebp]
  00290	83 c0 02	 add	 eax, 2
  00293	ff 8d 3c ff ff
	ff		 dec	 DWORD PTR tv7405[ebp]
  00299	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  0029f	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv7370[ebp], eax
  002a5	0f 85 35 ff ff
	ff		 jne	 $LL59@dtx_dec

; 306  :          }
; 307  :       }
; 308  :        
; 309  :       for (j = 0; j < M; j++)

  002ab	8d 55 bc	 lea	 edx, DWORD PTR _lsf$[ebp]
  002ae	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  002b3	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _L_lsf$[ebp]
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL53@dtx_dec:

; 311  :          lsf[j] = extract_l(L_shr(L_lsf[j],3)); /* divide by 8 */  move16();

  002c0	8b 01		 mov	 eax, DWORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  002c2	85 c0		 test	 eax, eax
  002c4	79 09		 jns	 SHORT $LN174@dtx_dec

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  002c6	f7 d0		 not	 eax
  002c8	c1 f8 03	 sar	 eax, 3
  002cb	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  002cd	eb 03		 jmp	 SHORT $LN173@dtx_dec
$LN174@dtx_dec:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  002cf	c1 f8 03	 sar	 eax, 3
$LN173@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 311  :          lsf[j] = extract_l(L_shr(L_lsf[j],3)); /* divide by 8 */  move16();

  002d2	66 89 02	 mov	 WORD PTR [edx], ax
  002d5	83 c1 04	 add	 ecx, 4
  002d8	83 c2 02	 add	 edx, 2
  002db	4e		 dec	 esi
  002dc	75 e2		 jne	 SHORT $LL53@dtx_dec

; 314  :       Lsf_lsp(lsf, st->lsp, M); 

  002de	51		 push	 ecx
  002df	8d 53 0c	 lea	 edx, DWORD PTR [ebx+12]
  002e2	8d 4d bc	 lea	 ecx, DWORD PTR _lsf$[ebp]
  002e5	e8 00 00 00 00	 call	 _Lsf_lsp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002ea	0f bf 4b 04	 movsx	 ecx, WORD PTR [ebx+4]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 314  :       Lsf_lsp(lsf, st->lsp, M); 

  002ee	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002f1	0f bf 83 8a 01
	00 00		 movsx	 eax, WORD PTR [ebx+394]
  002f8	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  002fa	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00300	7e 11		 jle	 SHORT $LN202@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00302	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0030c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00311	eb 1c		 jmp	 SHORT $LN199@dtx_dec
$LN202@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00313	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00319	7d 11		 jge	 SHORT $LN200@dtx_dec

; 86   :         Overflow = 1;

  0031b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00325	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  0032a	eb 03		 jmp	 SHORT $LN199@dtx_dec
$LN200@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  0032c	0f b7 c1	 movzx	 eax, cx
$LN199@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 318  :       st->log_en = sub(st->log_en, st->log_en_adjust);

  0032f	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00333	8d 73 34	 lea	 esi, DWORD PTR [ebx+52]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 318  :       st->log_en = sub(st->log_en, st->log_en_adjust);

  00336	8d 83 d6 00 00
	00		 lea	 eax, DWORD PTR [ebx+214]

; 323  :       for (i = 0; i < M; i++)

  0033c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv7360[ebp], OFFSET _lsf_hist_mean_scale
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00346	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 318  :       st->log_en = sub(st->log_en, st->log_en_adjust);

  0034b	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv7358[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00351	8b f8		 mov	 edi, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 323  :       for (i = 0; i < M; i++)

  00353	c7 85 28 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv7410[ebp], 10 ; 0000000aH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  0035d	66 f3 a5	 rep movsw
$LL50@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 325  :          L_lsf_mean = 0;                                           move32();

  00360	33 d2		 xor	 edx, edx
  00362	8b f0		 mov	 esi, eax
  00364	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
$LL47@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1715 :     L_var_out = (Word32) var1;

  00367	0f bf 06	 movsx	 eax, WORD PTR [esi]

; 931  :     L_var_out = L_var1 + L_var2;

  0036a	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0036d	33 c2		 xor	 eax, edx
  0036f	78 1d		 js	 SHORT $LN218@dtx_dec

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00371	8b c1		 mov	 eax, ecx
  00373	33 c2		 xor	 eax, edx
  00375	79 17		 jns	 SHORT $LN218@dtx_dec

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00377	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  00379	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00383	85 d2		 test	 edx, edx
  00385	0f 98 c1	 sets	 cl
  00388	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN218@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 327  :          for (j = 0; j < 8; j++)

  0038e	83 c6 14	 add	 esi, 20			; 00000014H

; 328  :          {
; 329  :             L_lsf_mean = L_add(L_lsf_mean, 
; 330  :                                L_deposit_l(st->lsf_hist_mean[i+j*M]));

  00391	8b d1		 mov	 edx, ecx
  00393	4f		 dec	 edi
  00394	75 d1		 jne	 SHORT $LL47@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  00396	85 c9		 test	 ecx, ecx
  00398	79 09		 jns	 SHORT $LN223@dtx_dec

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0039a	f7 d1		 not	 ecx
  0039c	c1 f9 03	 sar	 ecx, 3
  0039f	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  003a1	eb 03		 jmp	 SHORT $LN222@dtx_dec
$LN223@dtx_dec:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  003a3	c1 f9 03	 sar	 ecx, 3
$LN222@dtx_dec:
  003a6	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv7360[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 336  :          for (j = 0; j < 8; j++)

  003ac	bf 08 00 00 00	 mov	 edi, 8
  003b1	0f bf d9	 movsx	 ebx, cx
  003b4	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv7358[ebp]
  003ba	0f bf 10	 movsx	 edx, WORD PTR [eax]
  003bd	89 95 18 ff ff
	ff		 mov	 DWORD PTR tv7359[ebp], edx
$LL44@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003c3	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  003c6	2b c3		 sub	 eax, ebx

; 79   :     if (L_var1 > 0X00007fffL)

  003c8	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003cd	7e 11		 jle	 SHORT $LN251@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  003cf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003d9	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  003de	eb 1b		 jmp	 SHORT $LN248@dtx_dec
$LN251@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003e0	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003e5	7d 11		 jge	 SHORT $LN249@dtx_dec

; 86   :         Overflow = 1;

  003e7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  003f1	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  003f6	eb 03		 jmp	 SHORT $LN248@dtx_dec
$LN249@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  003f8	0f b7 c0	 movzx	 eax, ax
$LN248@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 340  :                sub(st->lsf_hist_mean[i+j*M], lsf_mean);

  003fb	66 89 01	 mov	 WORD PTR [ecx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  003fe	98		 cwde
  003ff	0f af c2	 imul	 eax, edx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00402	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00405	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0040a	74 05		 je	 SHORT $LN256@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0040c	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN256@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00411	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00416	7e 25		 jle	 SHORT $LN262@dtx_dec

; 82   :         var_out = MAX_16;

  00418	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  0041d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 344  :                mult(st->lsf_hist_mean[i+j*M], lsf_hist_mean_scale[i]);

  00427	66 89 11	 mov	 WORD PTR [ecx], dx
$LN41@dtx_dec:

; 353  :             {
; 354  :                negative = 0;                                        move16();

  0042a	33 f6		 xor	 esi, esi
$LN271@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 226  :     if (var1 == (Word16) 0X8000)

  0042c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00431	66 3b d0	 cmp	 dx, ax
  00434	75 39		 jne	 SHORT $LN276@dtx_dec

; 227  :     {
; 228  :         var_out = MAX_16;

  00436	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 229  :     }
; 230  :     else

  0043b	eb 3c		 jmp	 SHORT $LN273@dtx_dec
$LN262@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0043d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00442	7d 19		 jge	 SHORT $LN260@dtx_dec

; 87   :         var_out = MIN_16;

  00444	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H
  00449	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 344  :                mult(st->lsf_hist_mean[i+j*M], lsf_hist_mean_scale[i]);

  00453	66 89 11	 mov	 WORD PTR [ecx], dx

; 349  :             {
; 350  :                negative = 1;                                        move16();

  00456	be 01 00 00 00	 mov	 esi, 1

; 351  :             }
; 352  :             else

  0045b	eb cf		 jmp	 SHORT $LN271@dtx_dec
$LN260@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  0045d	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 344  :                mult(st->lsf_hist_mean[i+j*M], lsf_hist_mean_scale[i]);

  00460	66 89 01	 mov	 WORD PTR [ecx], ax

; 345  : 
; 346  :             /* limit the deviation */
; 347  :             test();
; 348  :             if (st->lsf_hist_mean[i+j*M] < 0)

  00463	66 85 c0	 test	 ax, ax
  00466	79 c2		 jns	 SHORT $LN41@dtx_dec

; 349  :             {
; 350  :                negative = 1;                                        move16();

  00468	be 01 00 00 00	 mov	 esi, 1

; 351  :             }
; 352  :             else

  0046d	eb bd		 jmp	 SHORT $LN271@dtx_dec
$LN276@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 232  :         if (var1 < 0)

  0046f	66 85 d2	 test	 dx, dx
  00472	79 02		 jns	 SHORT $LN274@dtx_dec

; 233  :         {
; 234  :             var_out = -var1;

  00474	f7 da		 neg	 edx
$LN274@dtx_dec:

; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;

  00476	0f b7 c2	 movzx	 eax, dx
$LN273@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 356  :             st->lsf_hist_mean[i+j*M] = abs_s(st->lsf_hist_mean[i+j*M]);

  00479	66 89 01	 mov	 WORD PTR [ecx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0047c	98		 cwde
  0047d	05 71 fd ff ff	 add	 eax, -655		; fffffd71H

; 79   :     if (L_var1 > 0X00007fffL)

  00482	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00487	7e 0c		 jle	 SHORT $LN286@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00489	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00493	eb 1f		 jmp	 SHORT $LN1521@dtx_dec
$LN286@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00495	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0049a	7d 0f		 jge	 SHORT $LN284@dtx_dec

; 86   :         Overflow = 1;

  0049c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  004a6	e9 9e 00 00 00	 jmp	 $LN39@dtx_dec
$LN284@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 360  :             if (sub(st->lsf_hist_mean[i+j*M], 655) > 0)

  004ab	66 85 c0	 test	 ax, ax
  004ae	0f 8e 95 00 00
	00		 jle	 $LN39@dtx_dec
$LN1521@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  004b4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004b9	7e 34		 jle	 SHORT $LN296@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  004bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004c5	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
$LN302@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  004ca	66 c1 fa 02	 sar	 dx, 2
  004ce	0f b7 c2	 movzx	 eax, dx
$LN301@dtx_dec:

; 139  :     L_sum = (Word32) var1 + var2;

  004d1	98		 cwde
  004d2	05 8f 02 00 00	 add	 eax, 655		; 0000028fH

; 79   :     if (L_var1 > 0X00007fffL)

  004d7	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004dc	7e 4d		 jle	 SHORT $LN326@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  004de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004e8	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  004ed	eb 57		 jmp	 SHORT $LN323@dtx_dec
$LN296@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004ef	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004f4	7d 1e		 jge	 SHORT $LN294@dtx_dec

; 87   :         var_out = MIN_16;

  004f6	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H
  004fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00505	0f bf c2	 movsx	 eax, dx
  00508	f7 d0		 not	 eax
  0050a	c1 f8 02	 sar	 eax, 2
  0050d	f7 d0		 not	 eax
  0050f	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  00512	eb bd		 jmp	 SHORT $LN301@dtx_dec
$LN294@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00514	0f b7 d0	 movzx	 edx, ax

; 375  :             if (var1 < 0)

  00517	66 85 c0	 test	 ax, ax
  0051a	79 ae		 jns	 SHORT $LN302@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0051c	0f bf c2	 movsx	 eax, dx
  0051f	f7 d0		 not	 eax
  00521	c1 f8 02	 sar	 eax, 2
  00524	f7 d0		 not	 eax
  00526	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  00529	eb a6		 jmp	 SHORT $LN301@dtx_dec
$LN326@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0052b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00530	7d 11		 jge	 SHORT $LN324@dtx_dec

; 86   :         Overflow = 1;

  00532	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0053c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00541	eb 03		 jmp	 SHORT $LN323@dtx_dec
$LN324@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00543	0f b7 c0	 movzx	 eax, ax
$LN323@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 363  :                   add(655, shr(sub(st->lsf_hist_mean[i+j*M], 655), 2));

  00546	66 89 01	 mov	 WORD PTR [ecx], ax
$LN39@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00549	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  0054c	2d 1e 05 00 00	 sub	 eax, 1310		; 0000051eH

; 79   :     if (L_var1 > 0X00007fffL)

  00551	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00556	7e 0c		 jle	 SHORT $LN338@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00558	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00562	eb 18		 jmp	 SHORT $LN1522@dtx_dec
$LN338@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00564	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00569	7d 0c		 jge	 SHORT $LN336@dtx_dec

; 86   :         Overflow = 1;

  0056b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  00575	eb 0d		 jmp	 SHORT $LN343@dtx_dec
$LN336@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 368  :             if (sub(st->lsf_hist_mean[i+j*M], 1310) > 0)

  00577	66 85 c0	 test	 ax, ax
  0057a	7e 08		 jle	 SHORT $LN343@dtx_dec
$LN1522@dtx_dec:

; 369  :             {
; 370  :                st->lsf_hist_mean[i+j*M] = 1310;                     move16();

  0057c	b8 1e 05 00 00	 mov	 eax, 1310		; 0000051eH
  00581	66 89 01	 mov	 WORD PTR [ecx], ax
$LN343@dtx_dec:

; 371  :             }
; 372  :             test();
; 373  :             if (negative != 0) 

  00584	85 f6		 test	 esi, esi
  00586	74 09		 je	 SHORT $LN43@dtx_dec

; 374  :             {
; 375  :                st->lsf_hist_mean[i+j*M] = -st->lsf_hist_mean[i+j*M];move16();

  00588	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0058b	66 f7 d8	 neg	 ax
  0058e	66 89 01	 mov	 WORD PTR [ecx], ax
$LN43@dtx_dec:

; 336  :          for (j = 0; j < 8; j++)

  00591	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv7359[ebp]
  00597	83 c1 14	 add	 ecx, 20			; 00000014H
  0059a	4f		 dec	 edi
  0059b	0f 85 22 fe ff
	ff		 jne	 $LL44@dtx_dec

; 323  :       for (i = 0; i < M; i++)

  005a1	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv7358[ebp]
  005a7	83 85 3c ff ff
	ff 02		 add	 DWORD PTR tv7360[ebp], 2
  005ae	83 c0 02	 add	 eax, 2
  005b1	ff 8d 28 ff ff
	ff		 dec	 DWORD PTR tv7410[ebp]
  005b7	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv7358[ebp], eax
  005bd	0f 85 9d fd ff
	ff		 jne	 $LL50@dtx_dec
  005c3	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
$LN48@dtx_dec:

; 376  :             }
; 377  :             
; 378  :          }
; 379  :       }
; 380  :    }
; 381  :    
; 382  :    test();
; 383  :    if (st->sid_frame != 0 )

  005c9	66 83 bb 90 01
	00 00 00	 cmp	 WORD PTR [ebx+400], 0
  005d1	bf 00 40 00 00	 mov	 edi, 16384		; 00004000H
  005d6	0f 84 af 03 00
	00		 je	 $LN568@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  005dc	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  005e0	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  005e3	66 89 43 20	 mov	 WORD PTR [ebx+32], ax
  005e7	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  005eb	66 89 43 22	 mov	 WORD PTR [ebx+34], ax
  005ef	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  005f3	66 89 43 24	 mov	 WORD PTR [ebx+36], ax
  005f7	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  005fb	66 89 43 26	 mov	 WORD PTR [ebx+38], ax
  005ff	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00603	66 89 43 28	 mov	 WORD PTR [ebx+40], ax
  00607	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  0060b	66 89 43 2a	 mov	 WORD PTR [ebx+42], ax
  0060f	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  00613	66 89 43 2c	 mov	 WORD PTR [ebx+44], ax
  00617	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  0061b	66 89 43 2e	 mov	 WORD PTR [ebx+46], ax
  0061f	0f b7 46 10	 movzx	 eax, WORD PTR [esi+16]
  00623	66 89 43 30	 mov	 WORD PTR [ebx+48], ax
  00627	0f b7 46 12	 movzx	 eax, WORD PTR [esi+18]
  0062b	66 89 43 32	 mov	 WORD PTR [ebx+50], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 391  :       if (st->valid_data != 0 )  /* new data available (no CRC) */

  0062f	66 83 bb 92 01
	00 00 00	 cmp	 WORD PTR [ebx+402], 0
  00637	0f b7 43 04	 movzx	 eax, WORD PTR [ebx+4]
  0063b	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
  0063f	0f 84 45 02 00
	00		 je	 $LN491@dtx_dec

; 392  :       {
; 393  :          /* Compute interpolation factor, since the division only works *
; 394  :           * for values of since_last_sid < 32 we have to limit the      *
; 395  :           * interpolation to 32 frames                                  */
; 396  :          tmp_int_length = st->since_last_sid;                       move16();

  00645	0f b7 13	 movzx	 edx, WORD PTR [ebx]

; 397  :          st->since_last_sid = 0;                                    move16();

  00648	33 c0		 xor	 eax, eax
  0064a	66 89 03	 mov	 WORD PTR [ebx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0064d	0f bf c2	 movsx	 eax, dx
  00650	83 e8 20	 sub	 eax, 32			; 00000020H

; 79   :     if (L_var1 > 0X00007fffL)

  00653	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00658	7e 0c		 jle	 SHORT $LN373@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0065a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00664	eb 18		 jmp	 SHORT $LN1523@dtx_dec
$LN373@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00666	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0066b	7d 0c		 jge	 SHORT $LN371@dtx_dec

; 86   :         Overflow = 1;

  0066d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  00677	eb 0a		 jmp	 SHORT $LN378@dtx_dec
$LN371@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 400  :          if (sub(tmp_int_length, 32) > 0)

  00679	66 85 c0	 test	 ax, ax
  0067c	7e 05		 jle	 SHORT $LN378@dtx_dec
$LN1523@dtx_dec:

; 401  :          {
; 402  :             tmp_int_length = 32;                                    move16();

  0067e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
$LN378@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00683	0f bf ca	 movsx	 ecx, dx
  00686	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  00689	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0068e	7e 0f		 jle	 SHORT $LN387@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00690	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0069a	e9 b6 00 00 00	 jmp	 $LN1524@dtx_dec
$LN387@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0069f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  006a4	0f 8d a2 00 00
	00		 jge	 $LN385@dtx_dec

; 86   :         Overflow = 1;

  006aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN33@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 412  :             st->true_sid_period_inv = 1 << 14; /* 0.5 it Q15 */     move16();

  006b4	66 89 7b 02	 mov	 WORD PTR [ebx+2], di
$LN414@dtx_dec:

; 413  :          }
; 414  :          
; 415  :          Init_D_plsf_3(lsfState, parm[0]);  /* temporay initialization */ 

  006b8	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _parm$GSCopy$1$[ebp]
  006be	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  006c3	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _lsfState$GSCopy$1$[ebp]
  006c9	0f b7 00	 movzx	 eax, WORD PTR [eax]
  006cc	98		 cwde
  006cd	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  006d0	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR _past_rq_init[eax*4]
$LL420@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  006d7	66 8b 02	 mov	 ax, WORD PTR [edx]
  006da	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  006dd	66 89 01	 mov	 WORD PTR [ecx], ax
  006e0	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  006e3	4f		 dec	 edi
  006e4	75 f1		 jne	 SHORT $LL420@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 416  :          D_plsf_3(lsfState, MRDTX, 0, &parm[1], st->lsp);

  006e6	8b bd 2c ff ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]
  006ec	ba 08 00 00 00	 mov	 edx, 8
  006f1	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _lsfState$GSCopy$1$[ebp]
  006f7	56		 push	 esi
  006f8	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  006fb	50		 push	 eax
  006fc	6a 00		 push	 0
  006fe	e8 00 00 00 00	 call	 _D_plsf_3
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00703	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _lsfState$GSCopy$1$[ebp]
  00709	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 416  :          D_plsf_3(lsfState, MRDTX, 0, &parm[1], st->lsp);

  0070c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  0070f	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00713	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 419  :          log_en_index = parm[4];                                    move16();

  0071a	0f b7 57 08	 movzx	 edx, WORD PTR [edi+8]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0071e	0f bf ca	 movsx	 ecx, dx
  00721	c1 e1 09	 shl	 ecx, 9

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00724	0f bf c1	 movsx	 eax, cx
  00727	3b c8		 cmp	 ecx, eax
  00729	74 7a		 je	 SHORT $LN437@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0072b	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00730	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0073a	66 85 d2	 test	 dx, dx
  0073d	8b c1		 mov	 eax, ecx
  0073f	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  00744	0f 4f c7	 cmovg	 eax, edi
  00747	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0074a	eb 61		 jmp	 SHORT $LN434@dtx_dec
$LN385@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 405  :          if (sub(tmp_int_length, 2) >= 0)

  0074c	66 85 c0	 test	 ax, ax
  0074f	0f 88 5f ff ff
	ff		 js	 $LN33@dtx_dec
$LN1524@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00755	c1 e1 0a	 shl	 ecx, 10			; 0000000aH

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00758	0f bf c1	 movsx	 eax, cx
  0075b	3b c8		 cmp	 ecx, eax
  0075d	74 30		 je	 SHORT $LN397@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0075f	66 85 d2	 test	 dx, dx
  00762	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0076c	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00771	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00776	0f 4f c1	 cmovg	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 408  :             st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 

  00779	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0077e	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 408  :             st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 

  00781	e8 00 00 00 00	 call	 _div_s
  00786	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 409  :          }
; 410  :          else

  0078a	e9 29 ff ff ff	 jmp	 $LN414@dtx_dec
$LN397@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  0078f	0f b7 d1	 movzx	 edx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 408  :             st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 

  00792	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00797	e8 00 00 00 00	 call	 _div_s
  0079c	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 409  :          }
; 410  :          else

  007a0	e9 13 ff ff ff	 jmp	 $LN414@dtx_dec
$LN437@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  007a5	0f b7 c1	 movzx	 eax, cx
  007a8	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
$LN434@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 421  :          st->log_en = shl(log_en_index, (11 - 2));                  move16();

  007ad	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  007b1	98		 cwde
  007b2	2d 00 14 00 00	 sub	 eax, 5120		; 00001400H

; 79   :     if (L_var1 > 0X00007fffL)

  007b7	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  007bc	7e 11		 jle	 SHORT $LN461@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  007be	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  007c8	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  007cd	eb 1b		 jmp	 SHORT $LN458@dtx_dec
$LN461@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  007cf	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  007d4	7d 11		 jge	 SHORT $LN459@dtx_dec

; 86   :         Overflow = 1;

  007d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  007e0	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  007e5	eb 03		 jmp	 SHORT $LN458@dtx_dec
$LN459@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  007e7	0f b7 c0	 movzx	 eax, ax
$LN458@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 424  :          st->log_en = sub(st->log_en, (2560 * 2));

  007ea	66 89 43 04	 mov	 WORD PTR [ebx+4], ax

; 425  :          
; 426  :          /* Index 0 is reserved for silence */
; 427  :          test();
; 428  :          if (log_en_index == 0)

  007ee	66 85 d2	 test	 dx, dx
  007f1	75 04		 jne	 SHORT $LN468@dtx_dec

; 429  :          {
; 430  :             st->log_en = MIN_16;                                    move16();

  007f3	66 89 4b 04	 mov	 WORD PTR [ebx+4], cx
$LN468@dtx_dec:

; 438  :              ) 

  007f7	66 83 bb 9c 01
	00 00 00	 cmp	 WORD PTR [ebx+412], 0
  007ff	74 32		 je	 SHORT $LN29@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00801	0f bf 83 98 01
	00 00		 movsx	 eax, WORD PTR [ebx+408]

; 79   :     if (L_var1 > 0X00007fffL)

  00808	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0080d	7e 0c		 jle	 SHORT $LN479@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0080f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00819	eb 6f		 jmp	 SHORT $LN491@dtx_dec
$LN479@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0081b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00820	7d 0c		 jge	 SHORT $LN477@dtx_dec

; 86   :         Overflow = 1;

  00822	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  0082c	eb 5c		 jmp	 SHORT $LN491@dtx_dec
$LN477@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 438  :              ) 

  0082e	66 85 c0	 test	 ax, ax
  00831	75 57		 jne	 SHORT $LN491@dtx_dec
$LN29@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00833	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00836	66 89 43 20	 mov	 WORD PTR [ebx+32], ax
  0083a	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0083e	66 89 43 22	 mov	 WORD PTR [ebx+34], ax
  00842	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  00846	66 89 43 24	 mov	 WORD PTR [ebx+36], ax
  0084a	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0084e	66 89 43 26	 mov	 WORD PTR [ebx+38], ax
  00852	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00856	66 89 43 28	 mov	 WORD PTR [ebx+40], ax
  0085a	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  0085e	66 89 43 2a	 mov	 WORD PTR [ebx+42], ax
  00862	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  00866	66 89 43 2c	 mov	 WORD PTR [ebx+44], ax
  0086a	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  0086e	66 89 43 2e	 mov	 WORD PTR [ebx+46], ax
  00872	0f b7 46 10	 movzx	 eax, WORD PTR [esi+16]
  00876	66 89 43 30	 mov	 WORD PTR [ebx+48], ax
  0087a	0f b7 46 12	 movzx	 eax, WORD PTR [esi+18]
  0087e	66 89 43 32	 mov	 WORD PTR [ebx+50], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 441  :             st->old_log_en = st->log_en;                            move16();

  00882	0f b7 43 04	 movzx	 eax, WORD PTR [ebx+4]
  00886	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
$LN491@dtx_dec:

; 446  :       ma_pred_init = sub(shr(st->log_en,1), 9000);                  move16();

  0088a	0f b7 43 04	 movzx	 eax, WORD PTR [ebx+4]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0088e	66 85 c0	 test	 ax, ax
  00891	79 09		 jns	 SHORT $LN494@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00893	98		 cwde
  00894	f7 d0		 not	 eax
  00896	d1 f8		 sar	 eax, 1
  00898	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0089a	eb 03		 jmp	 SHORT $LN1565@dtx_dec
$LN494@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0089c	66 d1 f8	 sar	 ax, 1
$LN1565@dtx_dec:
  0089f	0f b7 c0	 movzx	 eax, ax

; 186  :     L_diff = (Word32) var1 - var2;

  008a2	0f bf c8	 movsx	 ecx, ax
  008a5	81 e9 28 23 00
	00		 sub	 ecx, 9000		; 00002328H

; 79   :     if (L_var1 > 0X00007fffL)

  008ab	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  008b1	7e 0c		 jle	 SHORT $LN518@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  008b3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  008bd	eb 21		 jmp	 SHORT $LN1537@dtx_dec
$LN518@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  008bf	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  008c5	7d 11		 jge	 SHORT $LN516@dtx_dec

; 86   :         Overflow = 1;

  008c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 446  :       ma_pred_init = sub(shr(st->log_en,1), 9000);                  move16();

  008d1	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 89   :     else

  008d6	eb 0a		 jmp	 SHORT $LN527@dtx_dec
$LN516@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 446  :       ma_pred_init = sub(shr(st->log_en,1), 9000);                  move16();

  008d8	0f b7 c1	 movzx	 eax, cx

; 447  :       test();
; 448  :       if (ma_pred_init > 0)

  008db	66 85 c9	 test	 cx, cx
  008de	7e 02		 jle	 SHORT $LN527@dtx_dec
$LN1537@dtx_dec:

; 449  :       {                   
; 450  :          ma_pred_init = 0;                                          move16();  

  008e0	33 c0		 xor	 eax, eax
$LN527@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  008e2	0f bf c8	 movsx	 ecx, ax
  008e5	81 c1 64 38 00
	00		 add	 ecx, 14436		; 00003864H

; 79   :     if (L_var1 > 0X00007fffL)

  008eb	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  008f1	7e 0c		 jle	 SHORT $LN536@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  008f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  008fd	eb 1e		 jmp	 SHORT $LN541@dtx_dec
$LN536@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  008ff	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00905	7d 0c		 jge	 SHORT $LN534@dtx_dec

; 86   :         Overflow = 1;

  00907	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  00911	eb 05		 jmp	 SHORT $LN1525@dtx_dec
$LN534@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 453  :       if (sub(ma_pred_init, -14436) < 0)

  00913	66 85 c9	 test	 cx, cx
  00916	79 05		 jns	 SHORT $LN541@dtx_dec
$LN1525@dtx_dec:

; 454  :       {
; 455  :          ma_pred_init = -14436;                                     move16();

  00918	b8 9c c7 ff ff	 mov	 eax, -14436		; ffffc79cH
$LN541@dtx_dec:

; 456  :       }
; 457  :       
; 458  :       predState->past_qua_en[0] = ma_pred_init;                     move16();

  0091d	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _predState$GSCopy$1$[ebp]
  00923	66 89 01	 mov	 WORD PTR [ecx], ax

; 459  :       predState->past_qua_en[1] = ma_pred_init;                     move16();

  00926	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 460  :       predState->past_qua_en[2] = ma_pred_init;                     move16();

  0092a	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 461  :       predState->past_qua_en[3] = ma_pred_init;                     move16();

  0092e	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00932	98		 cwde
  00933	69 c0 43 15 00
	00		 imul	 eax, eax, 5443

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00939	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0093c	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00941	74 05		 je	 SHORT $LN551@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00943	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN551@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00948	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0094d	7e 11		 jle	 SHORT $LN557@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0094f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00959	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0095e	eb 1b		 jmp	 SHORT $LN554@dtx_dec
$LN557@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00960	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00965	7d 11		 jge	 SHORT $LN555@dtx_dec

; 86   :         Overflow = 1;

  00967	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00971	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00976	eb 03		 jmp	 SHORT $LN554@dtx_dec
$LN555@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00978	0f b7 c0	 movzx	 eax, ax
$LN554@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 466  :       predState->past_qua_en_MR122[0] = ma_pred_init;               move16();

  0097b	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 467  :       predState->past_qua_en_MR122[1] = ma_pred_init;               move16();

  0097f	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 468  :       predState->past_qua_en_MR122[2] = ma_pred_init;               move16();

  00983	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 469  :       predState->past_qua_en_MR122[3] = ma_pred_init;               move16();

  00987	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax
$LN568@dtx_dec:

; 478  :                            shr(mult(shl(dtx_log_en_adjust[mode],5),3277),5));

  0098b	8b 45 18	 mov	 eax, DWORD PTR _mode$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0098e	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H
  00993	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 478  :                            shr(mult(shl(dtx_log_en_adjust[mode],5),3277),5));

  00998	0f b7 14 45 00
	00 00 00	 movzx	 edx, WORD PTR _dtx_log_en_adjust[eax*2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  009a0	0f bf ca	 movsx	 ecx, dx
  009a3	c1 e1 05	 shl	 ecx, 5

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  009a6	0f bf c1	 movsx	 eax, cx
  009a9	3b c8		 cmp	 ecx, eax
  009ab	74 17		 je	 SHORT $LN575@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  009ad	66 85 d2	 test	 dx, dx
  009b0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  009ba	8b c6		 mov	 eax, esi
  009bc	0f 4f c7	 cmovg	 eax, edi
  009bf	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  009c2	eb 03		 jmp	 SHORT $LN572@dtx_dec
$LN575@dtx_dec:

; 307  :             var_out = extract_l (result);

  009c4	0f b7 c1	 movzx	 eax, cx
$LN572@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  009c7	98		 cwde
  009c8	69 c0 cd 0c 00
	00		 imul	 eax, eax, 3277

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  009ce	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  009d1	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  009d6	74 05		 je	 SHORT $LN592@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  009d8	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN592@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  009dd	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  009e2	7e 4a		 jle	 SHORT $LN598@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  009e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  009ee	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
$LN604@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  009f3	66 c1 f9 05	 sar	 cx, 5
  009f7	0f b7 d1	 movzx	 edx, cx
$LN603@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  009fa	0f bf 83 8a 01
	00 00		 movsx	 eax, WORD PTR [ebx+394]
  00a01	69 c0 33 73 00
	00		 imul	 eax, eax, 29491

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00a07	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00a0a	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00a0f	74 05		 je	 SHORT $LN623@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00a11	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN623@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00a16	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00a1b	7e 4d		 jle	 SHORT $LN629@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00a1d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00a27	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00a2c	eb 57		 jmp	 SHORT $LN626@dtx_dec
$LN598@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00a2e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00a33	7d 1e		 jge	 SHORT $LN596@dtx_dec

; 87   :         var_out = MIN_16;

  00a35	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00a3a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00a44	0f bf c1	 movsx	 eax, cx
  00a47	f7 d0		 not	 eax
  00a49	c1 f8 05	 sar	 eax, 5
  00a4c	f7 d0		 not	 eax
  00a4e	0f b7 d0	 movzx	 edx, ax

; 378  :             }
; 379  :             else

  00a51	eb a7		 jmp	 SHORT $LN603@dtx_dec
$LN596@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00a53	0f b7 c8	 movzx	 ecx, ax

; 375  :             if (var1 < 0)

  00a56	66 85 c0	 test	 ax, ax
  00a59	79 98		 jns	 SHORT $LN604@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00a5b	0f bf c1	 movsx	 eax, cx
  00a5e	f7 d0		 not	 eax
  00a60	c1 f8 05	 sar	 eax, 5
  00a63	f7 d0		 not	 eax
  00a65	0f b7 d0	 movzx	 edx, ax

; 378  :             }
; 379  :             else

  00a68	eb 90		 jmp	 SHORT $LN603@dtx_dec
$LN629@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00a6a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00a6f	7d 11		 jge	 SHORT $LN627@dtx_dec

; 86   :         Overflow = 1;

  00a71	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00a7b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00a80	eb 03		 jmp	 SHORT $LN626@dtx_dec
$LN627@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00a82	0f b7 c0	 movzx	 eax, ax
$LN626@dtx_dec:

; 139  :     L_sum = (Word32) var1 + var2;

  00a85	0f bf c8	 movsx	 ecx, ax
  00a88	0f bf c2	 movsx	 eax, dx
  00a8b	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00a8d	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00a93	7e 11		 jle	 SHORT $LN639@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00a95	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00a9f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00aa4	eb 1c		 jmp	 SHORT $LN636@dtx_dec
$LN639@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00aa6	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00aac	7d 11		 jge	 SHORT $LN637@dtx_dec

; 86   :         Overflow = 1;

  00aae	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00ab8	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00abd	eb 03		 jmp	 SHORT $LN636@dtx_dec
$LN637@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00abf	0f b7 c1	 movzx	 eax, cx
$LN636@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 478  :                            shr(mult(shl(dtx_log_en_adjust[mode],5),3277),5));

  00ac2	66 89 83 8a 01
	00 00		 mov	 WORD PTR [ebx+394], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00ac9	0f bf 03	 movsx	 eax, WORD PTR [ebx]
  00acc	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00acd	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00ad2	7e 11		 jle	 SHORT $LN649@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00ad4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00ade	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00ae3	eb 1b		 jmp	 SHORT $LN646@dtx_dec
$LN649@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00ae5	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00aea	7d 11		 jge	 SHORT $LN647@dtx_dec

; 86   :         Overflow = 1;

  00aec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00af6	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 89   :     else

  00afb	eb 03		 jmp	 SHORT $LN646@dtx_dec
$LN647@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00afd	0f b7 d0	 movzx	 edx, ax
$LN646@dtx_dec:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00b00	0f bf ca	 movsx	 ecx, dx
  00b03	c1 e1 0a	 shl	 ecx, 10			; 0000000aH

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00b06	0f bf c1	 movsx	 eax, cx
  00b09	3b c8		 cmp	 ecx, eax
  00b0b	74 17		 je	 SHORT $LN657@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00b0d	66 85 d2	 test	 dx, dx
  00b10	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00b1a	8b c6		 mov	 eax, esi
  00b1c	0f 4f c7	 cmovg	 eax, edi
  00b1f	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00b22	eb 03		 jmp	 SHORT $LN654@dtx_dec
$LN657@dtx_dec:

; 307  :             var_out = extract_l (result);

  00b24	0f b7 c1	 movzx	 eax, cx
$LN654@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00b27	0f bf c8	 movsx	 ecx, ax
  00b2a	0f bf 43 02	 movsx	 eax, WORD PTR [ebx+2]
  00b2e	0f af c8	 imul	 ecx, eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00b31	c1 f9 0f	 sar	 ecx, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00b34	f7 c1 00 00 01
	00		 test	 ecx, 65536		; 00010000H
  00b3a	74 06		 je	 SHORT $LN676@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00b3c	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN676@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00b42	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00b48	7e 11		 jle	 SHORT $LN682@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00b4a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00b54	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00b59	eb 1c		 jmp	 SHORT $LN679@dtx_dec
$LN682@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00b5b	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00b61	7d 11		 jge	 SHORT $LN680@dtx_dec

; 86   :         Overflow = 1;

  00b63	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00b6d	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00b72	eb 03		 jmp	 SHORT $LN679@dtx_dec
$LN680@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00b74	0f b7 c1	 movzx	 eax, cx
$LN679@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 482  :    int_fac = mult(int_fac, st->true_sid_period_inv); /* Q10 * Q15 -> Q10 */

  00b77	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00b7a	98		 cwde
  00b7b	2d 00 04 00 00	 sub	 eax, 1024		; 00000400H

; 79   :     if (L_var1 > 0X00007fffL)

  00b80	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00b85	7e 0c		 jle	 SHORT $LN694@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00b87	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00b91	eb 18		 jmp	 SHORT $LN1526@dtx_dec
$LN694@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00b93	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00b98	7d 0c		 jge	 SHORT $LN692@dtx_dec

; 86   :         Overflow = 1;

  00b9a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 89   :     else

  00ba4	eb 0a		 jmp	 SHORT $LN699@dtx_dec
$LN692@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 486  :    if (sub(int_fac, 1024) > 0)

  00ba6	66 85 c0	 test	 ax, ax
  00ba9	7e 05		 jle	 SHORT $LN699@dtx_dec
$LN1526@dtx_dec:

; 487  :    {
; 488  :       int_fac = 1024;                                               move16();

  00bab	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
$LN699@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00bb0	0f bf ca	 movsx	 ecx, dx
  00bb3	c1 e1 04	 shl	 ecx, 4

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00bb6	0f bf c1	 movsx	 eax, cx
  00bb9	3b c8		 cmp	 ecx, eax
  00bbb	74 17		 je	 SHORT $LN704@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00bbd	66 85 d2	 test	 dx, dx
  00bc0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00bca	8b c6		 mov	 eax, esi
  00bcc	0f 4f c7	 cmovg	 eax, edi
  00bcf	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00bd2	eb 03		 jmp	 SHORT $LN701@dtx_dec
$LN704@dtx_dec:

; 307  :             var_out = extract_l (result);

  00bd4	0f b7 c1	 movzx	 eax, cx
$LN701@dtx_dec:

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00bd7	0f bf f8	 movsx	 edi, ax
  00bda	0f bf 43 04	 movsx	 eax, WORD PTR [ebx+4]
  00bde	0f af c7	 imul	 eax, edi

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00be1	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00be6	74 05		 je	 SHORT $LN722@dtx_dec

; 488  :     {
; 489  :         L_var_out *= 2;

  00be8	8d 1c 00	 lea	 ebx, DWORD PTR [eax+eax]

; 490  :     }
; 491  :     else

  00beb	eb 0f		 jmp	 SHORT $LN721@dtx_dec
$LN722@dtx_dec:

; 492  :     {
; 493  :         Overflow = 1;

  00bed	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00bf7	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
$LN721@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 493  :    for(i = 0; i < M; i++)

  00bfc	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _st$GSCopy$1$[ebp]
  00c02	8d 55 bc	 lea	 edx, DWORD PTR _lsp_int$[ebp]
  00c05	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00c08	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  00c0d	8d 49 00	 npad	 3
$LL25@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00c10	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00c13	0f af c7	 imul	 eax, edi

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00c16	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00c19	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00c1e	74 05		 je	 SHORT $LN727@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00c20	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN727@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00c25	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00c2a	7e 11		 jle	 SHORT $LN733@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00c2c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00c36	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00c3b	eb 1b		 jmp	 SHORT $LN730@dtx_dec
$LN733@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00c3d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00c42	7d 11		 jge	 SHORT $LN731@dtx_dec

; 86   :         Overflow = 1;

  00c44	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00c4e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00c53	eb 03		 jmp	 SHORT $LN730@dtx_dec
$LN731@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00c55	0f b7 c0	 movzx	 eax, ax
$LN730@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 495  :       lsp_int[i] = mult(int_fac, st->lsp[i]);/* Q14 * Q15 -> Q14 */ move16();

  00c58	66 89 02	 mov	 WORD PTR [edx], ax
  00c5b	83 c1 02	 add	 ecx, 2
  00c5e	83 c2 02	 add	 edx, 2
  00c61	4e		 dec	 esi
  00c62	75 ac		 jne	 SHORT $LL25@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00c64	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00c69	2b c7		 sub	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  00c6b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00c70	7e 11		 jle	 SHORT $LN745@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00c72	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00c7c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00c81	eb 1b		 jmp	 SHORT $LN742@dtx_dec
$LN745@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00c83	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00c88	7d 11		 jge	 SHORT $LN743@dtx_dec

; 86   :         Overflow = 1;

  00c8a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00c94	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00c99	eb 03		 jmp	 SHORT $LN742@dtx_dec
$LN743@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00c9b	0f b7 c0	 movzx	 eax, ax
$LN742@dtx_dec:

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00c9e	8b bd 40 ff ff
	ff		 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  00ca4	0f bf c8	 movsx	 ecx, ax
  00ca7	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv7378[ebp], ecx
  00cad	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  00cb1	0f af c1	 imul	 eax, ecx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00cb4	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00cb9	74 04		 je	 SHORT $LN755@dtx_dec

; 488  :     {
; 489  :         L_var_out *= 2;

  00cbb	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00cbd	eb 0f		 jmp	 SHORT $LN754@dtx_dec
$LN755@dtx_dec:

; 492  :     {
; 493  :         Overflow = 1;

  00cbf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00cc9	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN754@dtx_dec:

; 931  :     L_var_out = L_var1 + L_var2;

  00cce	8d 14 18	 lea	 edx, DWORD PTR [eax+ebx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00cd1	33 c3		 xor	 eax, ebx
  00cd3	89 95 2c ff ff
	ff		 mov	 DWORD PTR _L_var_out$1$[ebp], edx
  00cd9	78 23		 js	 SHORT $LN758@dtx_dec

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00cdb	8b c2		 mov	 eax, edx
  00cdd	33 c3		 xor	 eax, ebx
  00cdf	79 1d		 jns	 SHORT $LN758@dtx_dec

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00ce1	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00ce3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00ced	85 db		 test	 ebx, ebx
  00cef	0f 98 c2	 sets	 dl
  00cf2	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
  00cf8	89 95 2c ff ff
	ff		 mov	 DWORD PTR _L_var_out$1$[ebp], edx
$LN758@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 502  :    for(i = 0; i < M; i++)

  00cfe	8d 75 bc	 lea	 esi, DWORD PTR _lsp_int$[ebp]
  00d01	83 c7 20	 add	 edi, 32			; 00000020H
  00d04	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  00d09	8d a4 24 00 00
	00 00		 npad	 7
$LL22@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00d10	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00d13	0f af c1	 imul	 eax, ecx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00d16	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00d19	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00d1e	74 05		 je	 SHORT $LN762@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00d20	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN762@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00d25	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00d2a	7e 11		 jle	 SHORT $LN768@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00d2c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00d36	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00d3b	eb 1b		 jmp	 SHORT $LN765@dtx_dec
$LN768@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00d3d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00d42	7d 11		 jge	 SHORT $LN766@dtx_dec

; 86   :         Overflow = 1;

  00d44	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00d4e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00d53	eb 03		 jmp	 SHORT $LN765@dtx_dec
$LN766@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00d55	0f b7 c0	 movzx	 eax, ax
$LN765@dtx_dec:

; 139  :     L_sum = (Word32) var1 + var2;

  00d58	0f bf c8	 movsx	 ecx, ax
  00d5b	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00d5e	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00d60	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00d66	7e 11		 jle	 SHORT $LN778@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00d68	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00d72	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00d77	eb 1c		 jmp	 SHORT $LN775@dtx_dec
$LN778@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00d79	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00d7f	7d 11		 jge	 SHORT $LN776@dtx_dec

; 86   :         Overflow = 1;

  00d81	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00d8b	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 89   :     else

  00d90	eb 03		 jmp	 SHORT $LN775@dtx_dec
$LN776@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00d92	0f b7 c9	 movzx	 ecx, cx
$LN775@dtx_dec:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00d95	0f bf d1	 movsx	 edx, cx
  00d98	03 d2		 add	 edx, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 505  :       lsp_int[i] = add(lsp_int[i], mult(int_fac, st->lsp_old[i]));  move16();

  00d9a	66 89 0e	 mov	 WORD PTR [esi], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00d9d	0f bf c2	 movsx	 eax, dx
  00da0	3b d0		 cmp	 edx, eax
  00da2	74 1f		 je	 SHORT $LN788@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00da4	66 85 c9	 test	 cx, cx
  00da7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00db1	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00db6	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00dbb	0f 4f c1	 cmovg	 eax, ecx
  00dbe	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00dc1	eb 03		 jmp	 SHORT $LN785@dtx_dec
$LN788@dtx_dec:

; 307  :             var_out = extract_l (result);

  00dc3	0f b7 c2	 movzx	 eax, dx
$LN785@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 502  :    for(i = 0; i < M; i++)

  00dc6	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv7378[ebp]
  00dcc	83 c7 02	 add	 edi, 2

; 506  :       lsp_int[i] = shl(lsp_int[i], 1); /* Q14 -> Q15 */             move16();

  00dcf	66 89 06	 mov	 WORD PTR [esi], ax
  00dd2	83 c6 02	 add	 esi, 2
  00dd5	4b		 dec	 ebx
  00dd6	0f 85 34 ff ff
	ff		 jne	 $LL22@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00ddc	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00de2	0f bf 83 76 01
	00 00		 movsx	 eax, WORD PTR [ebx+374]
  00de9	2d 99 09 00 00	 sub	 eax, 2457		; 00000999H

; 79   :     if (L_var1 > 0X00007fffL)

  00dee	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00df3	7e 11		 jle	 SHORT $LN812@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00df5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00dff	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00e04	eb 1b		 jmp	 SHORT $LN809@dtx_dec
$LN812@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00e06	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00e0b	7d 11		 jge	 SHORT $LN810@dtx_dec

; 86   :         Overflow = 1;

  00e0d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00e17	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00e1c	eb 03		 jmp	 SHORT $LN809@dtx_dec
$LN810@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00e1e	0f b7 c0	 movzx	 eax, ax
$LN809@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00e21	98		 cwde
  00e22	69 c0 66 26 00
	00		 imul	 eax, eax, 9830

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00e28	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00e2b	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00e30	74 05		 je	 SHORT $LN819@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00e32	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN819@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00e37	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00e3c	7e 11		 jle	 SHORT $LN825@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00e3e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00e48	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00e4d	eb 1b		 jmp	 SHORT $LN822@dtx_dec
$LN825@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00e4f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00e54	7d 11		 jge	 SHORT $LN823@dtx_dec

; 86   :         Overflow = 1;

  00e56	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00e60	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00e65	eb 03		 jmp	 SHORT $LN822@dtx_dec
$LN823@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00e67	0f b7 c0	 movzx	 eax, ax
$LN822@dtx_dec:

; 186  :     L_diff = (Word32) var1 - var2;

  00e6a	98		 cwde
  00e6b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00e70	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00e72	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00e78	7e 11		 jle	 SHORT $LN835@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00e7a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00e84	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00e89	eb 1c		 jmp	 SHORT $LN832@dtx_dec
$LN835@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00e8b	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00e91	7d 11		 jge	 SHORT $LN833@dtx_dec

; 86   :         Overflow = 1;

  00e93	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00e9d	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 89   :     else

  00ea2	eb 03		 jmp	 SHORT $LN832@dtx_dec
$LN833@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00ea4	0f b7 c9	 movzx	 ecx, cx
$LN832@dtx_dec:

; 186  :     L_diff = (Word32) var1 - var2;

  00ea7	0f bf c1	 movsx	 eax, cx
  00eaa	2d 00 10 00 00	 sub	 eax, 4096		; 00001000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 512  :    lsf_variab_factor = sub(4096, mult(lsf_variab_factor, 9830)); 

  00eaf	0f b7 d1	 movzx	 edx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00eb2	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00eb7	7e 11		 jle	 SHORT $LN847@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00eb9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 518  :       lsf_variab_factor = 4096;                                     move16();

  00ec3	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H

; 521  :    if (lsf_variab_factor < 0)

  00ec8	eb 19		 jmp	 SHORT $LN856@dtx_dec
$LN847@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00eca	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00ecf	7d 3e		 jge	 SHORT $LN845@dtx_dec

; 86   :         Overflow = 1;

  00ed1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN852@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 521  :    if (lsf_variab_factor < 0)

  00edb	33 c0		 xor	 eax, eax
  00edd	66 85 c9	 test	 cx, cx
  00ee0	0f 48 d0	 cmovs	 edx, eax
$LN856@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00ee3	0f bf ca	 movsx	 ecx, dx
  00ee6	c1 e1 03	 shl	 ecx, 3

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00ee9	0f bf c1	 movsx	 eax, cx
  00eec	3b c8		 cmp	 ecx, eax
  00eee	74 2b		 je	 SHORT $LN861@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00ef0	66 85 d2	 test	 dx, dx
  00ef3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00efd	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00f02	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00f07	0f 4f c1	 cmovg	 eax, ecx
  00f0a	0f b7 f8	 movzx	 edi, ax

; 304  :         }
; 305  :         else

  00f0d	eb 0f		 jmp	 SHORT $LN858@dtx_dec
$LN845@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 516  :    if (sub(lsf_variab_factor, 4096) > 0)

  00f0f	66 85 c0	 test	 ax, ax
  00f12	7e c7		 jle	 SHORT $LN852@dtx_dec

; 518  :       lsf_variab_factor = 4096;                                     move16();

  00f14	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H

; 521  :    if (lsf_variab_factor < 0)

  00f19	eb c8		 jmp	 SHORT $LN856@dtx_dec
$LN861@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  00f1b	0f b7 f9	 movzx	 edi, cx
$LN858@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 528  :    lsf_variab_index = pseudonoise(&st->L_pn_seed_rx, 3);            move16();

  00f1e	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00f21	ba 03 00 00 00	 mov	 edx, 3
  00f26	8b c8		 mov	 ecx, eax
  00f28	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv7383[ebp], eax
  00f2e	e8 00 00 00 00	 call	 _pseudonoise

; 531  :    Lsp_lsf(lsp_int, lsf_int, M);

  00f33	51		 push	 ecx
  00f34	8d 55 d0	 lea	 edx, DWORD PTR _lsf_int$[ebp]
  00f37	0f b7 f0	 movzx	 esi, ax
  00f3a	8d 4d bc	 lea	 ecx, DWORD PTR _lsp_int$[ebp]
  00f3d	e8 00 00 00 00	 call	 _Lsp_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00f42	8b 45 e0	 mov	 eax, DWORD PTR _lsf_int$[ebp+16]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 535  :    for(i = 0; i < M; i++)

  00f45	8d 55 e4	 lea	 edx, DWORD PTR _lsf_int_variab$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00f48	f3 0f 6f 45 d0	 movdqu	 xmm0, XMMWORD PTR _lsf_int$[ebp]
  00f4d	89 45 f4	 mov	 DWORD PTR _lsf_int_variab$[ebp+16], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 531  :    Lsp_lsf(lsp_int, lsf_int, M);

  00f50	83 c4 04	 add	 esp, 4

; 535  :    for(i = 0; i < M; i++)

  00f53	0f bf c6	 movsx	 eax, si
  00f56	8b b5 40 ff ff
	ff		 mov	 esi, DWORD PTR _st$GSCopy$1$[ebp]
  00f5c	81 c6 d6 00 00
	00		 add	 esi, 214		; 000000d6H
  00f62	0f bf df	 movsx	 ebx, di
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00f65	f3 0f 7f 45 e4	 movdqu	 XMMWORD PTR _lsf_int_variab$[ebp], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 535  :    for(i = 0; i < M; i++)

  00f6a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00f6d	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00f72	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
$LL17@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00f75	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00f78	0f af c3	 imul	 eax, ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00f7b	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00f7e	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00f83	74 05		 je	 SHORT $LN891@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00f85	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN891@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  00f8a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00f8f	7e 11		 jle	 SHORT $LN897@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00f91	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00f9b	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00fa0	eb 1b		 jmp	 SHORT $LN894@dtx_dec
$LN897@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00fa2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00fa7	7d 11		 jge	 SHORT $LN895@dtx_dec

; 86   :         Overflow = 1;

  00fa9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00fb3	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00fb8	eb 03		 jmp	 SHORT $LN894@dtx_dec
$LN895@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00fba	0f b7 c0	 movzx	 eax, ax
$LN894@dtx_dec:

; 139  :     L_sum = (Word32) var1 + var2;

  00fbd	0f bf c8	 movsx	 ecx, ax
  00fc0	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00fc3	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00fc5	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00fcb	7e 11		 jle	 SHORT $LN907@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  00fcd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00fd7	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00fdc	eb 1c		 jmp	 SHORT $LN904@dtx_dec
$LN907@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00fde	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00fe4	7d 11		 jge	 SHORT $LN905@dtx_dec

; 86   :         Overflow = 1;

  00fe6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00ff0	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  00ff5	eb 03		 jmp	 SHORT $LN904@dtx_dec
$LN905@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  00ff7	0f b7 c1	 movzx	 eax, cx
$LN904@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 540  :                                    st->lsf_hist_mean[i+lsf_variab_index*M]));

  00ffa	66 89 02	 mov	 WORD PTR [edx], ax
  00ffd	83 c6 02	 add	 esi, 2
  01000	83 c2 02	 add	 edx, 2
  01003	4f		 dec	 edi
  01004	0f 85 6b ff ff
	ff		 jne	 $LL17@dtx_dec

; 541  :    }
; 542  : 
; 543  :    /* make sure that LSP's are ordered */
; 544  :    Reorder_lsf(lsf_int, LSF_GAP, M);

  0100a	51		 push	 ecx
  0100b	8d 4d d0	 lea	 ecx, DWORD PTR _lsf_int$[ebp]
  0100e	e8 00 00 00 00	 call	 _Reorder_lsf

; 545  :    Reorder_lsf(lsf_int_variab, LSF_GAP, M);

  01013	8d 4d e4	 lea	 ecx, DWORD PTR _lsf_int_variab$[ebp]
  01016	e8 00 00 00 00	 call	 _Reorder_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  0101b	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _lsfState$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 551  :    Lsf_lsp(lsf_int, lsp_int, M);

  01021	8d 55 bc	 lea	 edx, DWORD PTR _lsp_int$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  01024	f3 0f 6f 45 d0	 movdqu	 xmm0, XMMWORD PTR _lsf_int$[ebp]
  01029	8b 45 e0	 mov	 eax, DWORD PTR _lsf_int$[ebp+16]
  0102c	f3 0f 7f 41 14	 movdqu	 XMMWORD PTR [ecx+20], xmm0
  01031	89 41 24	 mov	 DWORD PTR [ecx+36], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 551  :    Lsf_lsp(lsf_int, lsp_int, M);

  01034	8d 4d d0	 lea	 ecx, DWORD PTR _lsf_int$[ebp]
  01037	e8 00 00 00 00	 call	 _Lsf_lsp

; 552  :    Lsf_lsp(lsf_int_variab, lsp_int_variab, M);

  0103c	8d 55 d0	 lea	 edx, DWORD PTR _lsp_int_variab$[ebp]
  0103f	8d 4d e4	 lea	 ecx, DWORD PTR _lsf_int_variab$[ebp]
  01042	e8 00 00 00 00	 call	 _Lsf_lsp
  01047	83 c4 04	 add	 esp, 4

; 553  : 
; 554  :    /* Compute acoeffs Q12 acoeff is used for level    * 
; 555  :     * normalization and postfilter, acoeff_variab is  *
; 556  :     * used for synthesis filter                       *
; 557  :     * by doing this we make sure that the level       *
; 558  :     * in high frequenncies does not jump up and down  */
; 559  : 
; 560  :    Lsp_Az(lsp_int, acoeff);

  0104a	8d 55 e4	 lea	 edx, DWORD PTR _acoeff$[ebp]
  0104d	8d 4d bc	 lea	 ecx, DWORD PTR _lsp_int$[ebp]
  01050	e8 00 00 00 00	 call	 _Lsp_Az

; 561  :    Lsp_Az(lsp_int_variab, acoeff_variab);

  01055	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _acoeff_variab$[ebp]
  0105b	8d 4d d0	 lea	 ecx, DWORD PTR _lsp_int_variab$[ebp]
  0105e	e8 00 00 00 00	 call	 _Lsp_Az
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  01063	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _A_t$GSCopy$1$[ebp]
  01069	f3 0f 6f 45 e4	 movdqu	 xmm0, XMMWORD PTR _acoeff$[ebp]
  0106e	8b 4d f4	 mov	 ecx, DWORD PTR _acoeff$[ebp+16]
  01071	66 8b 45 f8	 mov	 ax, WORD PTR _acoeff$[ebp+20]
  01075	f3 0f 7f 02	 movdqu	 XMMWORD PTR [edx], xmm0
  01079	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0107c	66 89 42 14	 mov	 WORD PTR [edx+20], ax
  01080	f3 0f 7f 42 16	 movdqu	 XMMWORD PTR [edx+22], xmm0
  01085	89 4a 26	 mov	 DWORD PTR [edx+38], ecx
  01088	66 89 42 2a	 mov	 WORD PTR [edx+42], ax
  0108c	f3 0f 7f 42 2c	 movdqu	 XMMWORD PTR [edx+44], xmm0
  01091	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx
  01094	66 89 42 40	 mov	 WORD PTR [edx+64], ax
  01098	f3 0f 7f 42 42	 movdqu	 XMMWORD PTR [edx+66], xmm0
  0109d	89 4a 52	 mov	 DWORD PTR [edx+82], ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 570  :    A_Refl(&acoeff[1], refl);

  010a0	8d 4d e6	 lea	 ecx, DWORD PTR _acoeff$[ebp+2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  010a3	66 89 42 56	 mov	 WORD PTR [edx+86], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 570  :    A_Refl(&acoeff[1], refl);

  010a7	8d 55 bc	 lea	 edx, DWORD PTR _refl$[ebp]
  010aa	e8 00 00 00 00	 call	 _A_Refl

; 571  :    
; 572  :    /* Compute prediction error in Q15 */
; 573  :    pred_err = MAX_16; /* 0.99997 in Q15 */                          move16();

  010af	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  010b4	8d 55 bc	 lea	 edx, DWORD PTR _refl$[ebp]
  010b7	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  010bc	8d 64 24 00	 npad	 4
$LL14@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  010c0	0f bf 02	 movsx	 eax, WORD PTR [edx]
  010c3	0f af c0	 imul	 eax, eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  010c6	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  010c9	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  010ce	74 05		 je	 SHORT $LN949@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  010d0	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN949@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  010d5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  010da	7e 11		 jle	 SHORT $LN955@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  010dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  010e6	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  010eb	eb 1b		 jmp	 SHORT $LN952@dtx_dec
$LN955@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  010ed	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  010f2	7d 11		 jge	 SHORT $LN953@dtx_dec

; 86   :         Overflow = 1;

  010f4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  010fe	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  01103	eb 03		 jmp	 SHORT $LN952@dtx_dec
$LN953@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01105	0f b7 c0	 movzx	 eax, ax
$LN952@dtx_dec:

; 186  :     L_diff = (Word32) var1 - var2;

  01108	98		 cwde
  01109	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0110e	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  01110	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01116	7e 11		 jle	 SHORT $LN965@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01118	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01122	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01127	eb 1c		 jmp	 SHORT $LN962@dtx_dec
$LN965@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01129	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0112f	7d 11		 jge	 SHORT $LN963@dtx_dec

; 86   :         Overflow = 1;

  01131	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0113b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  01140	eb 03		 jmp	 SHORT $LN962@dtx_dec
$LN963@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01142	0f b7 c1	 movzx	 eax, cx
$LN962@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  01145	0f bf ce	 movsx	 ecx, si
  01148	98		 cwde
  01149	0f af c8	 imul	 ecx, eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0114c	c1 f9 0f	 sar	 ecx, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0114f	f7 c1 00 00 01
	00		 test	 ecx, 65536		; 00010000H
  01155	74 06		 je	 SHORT $LN970@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  01157	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN970@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  0115d	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01163	7e 11		 jle	 SHORT $LN976@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01165	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0116f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01174	eb 1c		 jmp	 SHORT $LN973@dtx_dec
$LN976@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01176	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0117c	7d 11		 jge	 SHORT $LN974@dtx_dec

; 86   :         Overflow = 1;

  0117e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  01188	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  0118d	eb 03		 jmp	 SHORT $LN973@dtx_dec
$LN974@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  0118f	0f b7 c1	 movzx	 eax, cx
$LN973@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 574  :    for (i = 0; i < M; i++)

  01192	83 c2 02	 add	 edx, 2

; 575  :    { 
; 576  :       pred_err = mult(pred_err, sub(MAX_16, mult(refl[i], refl[i])));

  01195	0f b7 f0	 movzx	 esi, ax
  01198	4f		 dec	 edi
  01199	0f 85 21 ff ff
	ff		 jne	 $LL14@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1715 :     L_var_out = (Word32) var1;

  0119f	98		 cwde

; 2109 :     if (L_var1 == 0)

  011a0	8d 57 e0	 lea	 edx, DWORD PTR [edi-32]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 120  :     exp = norm_l (L_x);

  011a3	8b c8		 mov	 ecx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  011a5	85 c0		 test	 eax, eax
  011a7	75 07		 jne	 SHORT $LN992@dtx_dec

; 2110 :     {
; 2111 :         var_out = 0;

  011a9	33 f6		 xor	 esi, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  011ab	0f b7 ce	 movzx	 ecx, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2113 :     else

  011ae	eb 5c		 jmp	 SHORT $LN1002@dtx_dec
$LN992@dtx_dec:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  011b0	83 f8 ff	 cmp	 eax, -1
  011b3	75 2c		 jne	 SHORT $LN990@dtx_dec

; 2116 :         {
; 2117 :             var_out = 31;

  011b5	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  011ba	0f b7 ce	 movzx	 ecx, si
  011bd	8d 49 00	 npad	 3
$LL1553@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  011c0	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  011c5	0f 8f 89 00 00
	00		 jg	 $LN1409@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  011cb	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  011d0	7c 7b		 jl	 SHORT $LN1410@dtx_dec

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  011d2	03 c0		 add	 eax, eax
  011d4	49		 dec	 ecx

; 1373 :             L_var_out = L_var1;

  011d5	8b d8		 mov	 ebx, eax
  011d7	66 85 c9	 test	 cx, cx
  011da	7f e4		 jg	 SHORT $LL1553@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  011dc	e9 82 00 00 00	 jmp	 $LN998@dtx_dec
$LN990@dtx_dec:

; 2118 :         }
; 2119 :         else
; 2120 :         {
; 2121 :             if (L_var1 < 0)

  011e1	85 c0		 test	 eax, eax
  011e3	79 04		 jns	 SHORT $LN988@dtx_dec

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  011e5	8b c8		 mov	 ecx, eax
  011e7	f7 d1		 not	 ecx
$LN988@dtx_dec:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  011e9	33 f6		 xor	 esi, esi
  011eb	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  011f1	7d 0b		 jge	 SHORT $LN985@dtx_dec
$LL987@dtx_dec:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  011f3	03 c9		 add	 ecx, ecx
  011f5	46		 inc	 esi
  011f6	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  011fc	7c f5		 jl	 SHORT $LL987@dtx_dec
$LN985@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  011fe	0f b7 ce	 movzx	 ecx, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1344 :     if (var2 <= 0)

  01201	66 85 f6	 test	 si, si
  01204	7f ba		 jg	 SHORT $LL1553@dtx_dec

; 1345 :     {
; 1346 :         if (var2 < -32)

  01206	66 3b f2	 cmp	 si, dx
  01209	0f 4c ca	 cmovl	 ecx, edx
$LN1002@dtx_dec:

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  0120c	f7 d9		 neg	 ecx
  0120e	0f b7 c9	 movzx	 ecx, cx

; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)

  01211	66 85 c9	 test	 cx, cx
  01214	79 15		 jns	 SHORT $LN1012@dtx_dec

; 1421 :     {
; 1422 :         if (var2 < -32)

  01216	66 3b ca	 cmp	 cx, dx
  01219	0f 4c ca	 cmovl	 ecx, edx

; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);

  0121c	f7 d9		 neg	 ecx
  0121e	8b d1		 mov	 edx, ecx
  01220	8b c8		 mov	 ecx, eax
  01222	e8 00 00 00 00	 call	 _L_shl
  01227	8b d8		 mov	 ebx, eax

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  01229	eb 38		 jmp	 SHORT $LN998@dtx_dec
$LN1012@dtx_dec:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  0122b	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  0122f	7c 0a		 jl	 SHORT $LN1009@dtx_dec

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  01231	33 db		 xor	 ebx, ebx
  01233	85 c0		 test	 eax, eax
  01235	0f 99 c3	 setns	 bl
  01238	4b		 dec	 ebx

; 1434 :         }
; 1435 :         else

  01239	eb 28		 jmp	 SHORT $LN998@dtx_dec
$LN1009@dtx_dec:

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0123b	8b d8		 mov	 ebx, eax
  0123d	85 c0		 test	 eax, eax
  0123f	79 08		 jns	 SHORT $LN1007@dtx_dec
  01241	f7 d3		 not	 ebx
  01243	d3 fb		 sar	 ebx, cl
  01245	f7 d3		 not	 ebx

; 1440 :             }
; 1441 :             else

  01247	eb 1a		 jmp	 SHORT $LN998@dtx_dec
$LN1007@dtx_dec:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01249	d3 fb		 sar	 ebx, cl

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  0124b	eb 16		 jmp	 SHORT $LN998@dtx_dec
$LN1410@dtx_dec:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0124d	bb 00 00 00 80	 mov	 ebx, -2147483648	; 80000000H
  01252	eb 05		 jmp	 SHORT $LN1566@dtx_dec
$LN1409@dtx_dec:

; 1360 :                 L_var_out = MAX_32;

  01254	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
$LN1566@dtx_dec:

; 1358 :             {
; 1359 :                 Overflow = 1;

  01259	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN998@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  01263	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _log_pg_m$[ebp]
  01269	8b d6		 mov	 edx, esi
  0126b	50		 push	 eax
  0126c	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _log_pg_e$[ebp]
  01272	8b cb		 mov	 ecx, ebx
  01274	50		 push	 eax
  01275	e8 00 00 00 00	 call	 _Log2_norm
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0127a	0f bf 85 3c ff
	ff ff		 movsx	 eax, WORD PTR _log_pg_e$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  01281	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01284	83 e8 0f	 sub	 eax, 15			; 0000000fH

; 79   :     if (L_var1 > 0X00007fffL)

  01287	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0128c	7e 11		 jle	 SHORT $LN1020@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0128e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01298	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  0129d	eb 1b		 jmp	 SHORT $LN1017@dtx_dec
$LN1020@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0129f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  012a4	7d 11		 jge	 SHORT $LN1018@dtx_dec

; 86   :         Overflow = 1;

  012a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  012b0	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 89   :     else

  012b5	eb 03		 jmp	 SHORT $LN1017@dtx_dec
$LN1018@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  012b7	0f b7 d0	 movzx	 edx, ax
$LN1017@dtx_dec:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  012ba	0f bf ca	 movsx	 ecx, dx
  012bd	c1 e1 0c	 shl	 ecx, 12			; 0000000cH

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  012c0	0f bf c1	 movsx	 eax, cx
  012c3	3b c8		 cmp	 ecx, eax
  012c5	74 1f		 je	 SHORT $LN1028@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  012c7	66 85 d2	 test	 dx, dx
  012ca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  012d4	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  012d9	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  012de	0f 4f c1	 cmovg	 eax, ecx
  012e1	0f b7 d0	 movzx	 edx, ax

; 304  :         }
; 305  :         else

  012e4	eb 03		 jmp	 SHORT $LN1025@dtx_dec
$LN1028@dtx_dec:

; 307  :             var_out = extract_l (result);

  012e6	0f b7 d1	 movzx	 edx, cx
$LN1025@dtx_dec:

; 375  :             if (var1 < 0)

  012e9	66 8b 85 34 ff
	ff ff		 mov	 ax, WORD PTR _log_pg_m$[ebp]
  012f0	66 85 c0	 test	 ax, ax
  012f3	79 0a		 jns	 SHORT $LN1048@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  012f5	98		 cwde
  012f6	f7 d0		 not	 eax
  012f8	c1 f8 03	 sar	 eax, 3
  012fb	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  012fd	eb 04		 jmp	 SHORT $LN1567@dtx_dec
$LN1048@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  012ff	66 c1 f8 03	 sar	 ax, 3
$LN1567@dtx_dec:
  01303	0f b7 c0	 movzx	 eax, ax

; 139  :     L_sum = (Word32) var1 + var2;

  01306	0f bf c8	 movsx	 ecx, ax
  01309	0f bf c2	 movsx	 eax, dx
  0130c	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0130e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01314	7e 11		 jle	 SHORT $LN1072@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01316	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01320	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01325	eb 1c		 jmp	 SHORT $LN1069@dtx_dec
$LN1072@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01327	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0132d	7d 11		 jge	 SHORT $LN1070@dtx_dec

; 86   :         Overflow = 1;

  0132f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  01339	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  0133e	eb 03		 jmp	 SHORT $LN1069@dtx_dec
$LN1070@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01340	0f b7 c1	 movzx	 eax, cx
$LN1069@dtx_dec:

; 186  :     L_diff = (Word32) var1 - var2;

  01343	0f bf c8	 movsx	 ecx, ax
  01346	f7 d9		 neg	 ecx

; 79   :     if (L_var1 > 0X00007fffL)

  01348	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0134e	7e 45		 jle	 SHORT $LN1082@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01350	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0135a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
$LN1088@dtx_dec:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0135f	66 d1 f8	 sar	 ax, 1
$LN1568@dtx_dec:
  01362	0f b7 c0	 movzx	 eax, ax

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  01365	0f bf c8	 movsx	 ecx, ax
  01368	69 c1 cd 0c 00
	00		 imul	 eax, ecx, 3277

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0136e	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  01371	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  01376	74 05		 je	 SHORT $LN1109@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  01378	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN1109@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  0137d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01382	7e 42		 jle	 SHORT $LN1115@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01384	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0138e	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  01393	eb 4c		 jmp	 SHORT $LN1112@dtx_dec
$LN1082@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01395	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0139b	7d 18		 jge	 SHORT $LN1080@dtx_dec

; 87   :         var_out = MIN_16;

  0139d	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  013a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  013ac	98		 cwde
  013ad	f7 d0		 not	 eax
  013af	d1 f8		 sar	 eax, 1
  013b1	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  013b3	eb ad		 jmp	 SHORT $LN1568@dtx_dec
$LN1080@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  013b5	0f b7 c1	 movzx	 eax, cx

; 375  :             if (var1 < 0)

  013b8	66 85 c9	 test	 cx, cx
  013bb	79 a2		 jns	 SHORT $LN1088@dtx_dec

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  013bd	98		 cwde
  013be	f7 d0		 not	 eax
  013c0	d1 f8		 sar	 eax, 1
  013c2	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  013c4	eb 9c		 jmp	 SHORT $LN1568@dtx_dec
$LN1115@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  013c6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  013cb	7d 11		 jge	 SHORT $LN1113@dtx_dec

; 86   :         Overflow = 1;

  013cd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  013d7	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 89   :     else

  013dc	eb 03		 jmp	 SHORT $LN1112@dtx_dec
$LN1113@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  013de	0f b7 f0	 movzx	 esi, ax
$LN1112@dtx_dec:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  013e1	8b bd 40 ff ff
	ff		 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  013e7	0f bf 87 76 01
	00 00		 movsx	 eax, WORD PTR [edi+374]
  013ee	69 c0 33 73 00
	00		 imul	 eax, eax, 29491

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  013f4	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  013f7	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  013fc	74 05		 je	 SHORT $LN1120@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  013fe	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN1120@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  01403	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01408	7e 11		 jle	 SHORT $LN1126@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0140a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01414	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01419	eb 1b		 jmp	 SHORT $LN1123@dtx_dec
$LN1126@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0141b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01420	7d 11		 jge	 SHORT $LN1124@dtx_dec

; 86   :         Overflow = 1;

  01422	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0142c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  01431	eb 03		 jmp	 SHORT $LN1123@dtx_dec
$LN1124@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01433	0f b7 c0	 movzx	 eax, ax
$LN1123@dtx_dec:

; 139  :     L_sum = (Word32) var1 + var2;

  01436	0f bf d0	 movsx	 edx, ax
  01439	0f bf c6	 movsx	 eax, si
  0143c	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0143e	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  01444	7e 11		 jle	 SHORT $LN1136@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  01446	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01450	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01455	eb 1c		 jmp	 SHORT $LN1133@dtx_dec
$LN1136@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01457	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0145d	7d 11		 jge	 SHORT $LN1134@dtx_dec

; 86   :         Overflow = 1;

  0145f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  01469	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  0146e	eb 03		 jmp	 SHORT $LN1133@dtx_dec
$LN1134@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01470	0f b7 c2	 movzx	 eax, dx
$LN1133@dtx_dec:

; 1437 :             if (L_var1 < 0)

  01473	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _L_var_out$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 586  :                          mult(3277, log_pg));                       move16();

  01479	66 89 87 76 01
	00 00		 mov	 WORD PTR [edi+374], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  01480	85 d2		 test	 edx, edx
  01482	79 09		 jns	 SHORT $LN1144@dtx_dec

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01484	f7 d2		 not	 edx
  01486	c1 fa 0a	 sar	 edx, 10			; 0000000aH
  01489	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  0148b	eb 03		 jmp	 SHORT $LN1143@dtx_dec
$LN1144@dtx_dec:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0148d	c1 fa 0a	 sar	 edx, 10			; 0000000aH
$LN1143@dtx_dec:

; 931  :     L_var_out = L_var1 + L_var2;

  01490	8d 9a 00 00 04
	00		 lea	 ebx, DWORD PTR [edx+262144]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01496	85 d2		 test	 edx, edx
  01498	78 1d		 js	 SHORT $LN1165@dtx_dec

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0149a	8b c3		 mov	 eax, ebx
  0149c	33 c2		 xor	 eax, edx
  0149e	79 17		 jns	 SHORT $LN1165@dtx_dec

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  014a0	33 db		 xor	 ebx, ebx

; 938  :             Overflow = 1;

  014a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  014ac	85 d2		 test	 edx, edx
  014ae	0f 98 c3	 sets	 bl
  014b1	81 c3 ff ff ff
	7f		 add	 ebx, 2147483647		; 7fffffffH
$LN1165@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 595  :    L_log_en_int = L_sub(L_log_en_int, L_shl(L_deposit_l(log_pg), 4));move32();

  014b7	b8 04 00 00 00	 mov	 eax, 4
  014bc	8d 64 24 00	 npad	 4
$LL1181@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  014c0	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  014c6	7f 19		 jg	 SHORT $LN1413@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  014c8	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  014ce	7c 0a		 jl	 SHORT $LN1414@dtx_dec

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  014d0	48		 dec	 eax
  014d1	03 c9		 add	 ecx, ecx
  014d3	66 85 c0	 test	 ax, ax
  014d6	7f e8		 jg	 SHORT $LL1181@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  014d8	eb 16		 jmp	 SHORT $LN1176@dtx_dec
$LN1414@dtx_dec:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  014da	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  014df	eb 05		 jmp	 SHORT $LN1569@dtx_dec
$LN1413@dtx_dec:

; 1360 :                 L_var_out = MAX_32;

  014e1	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN1569@dtx_dec:

; 1358 :             {
; 1359 :                 Overflow = 1;

  014e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1176@dtx_dec:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  014f0	8b d3		 mov	 edx, ebx
  014f2	2b d1		 sub	 edx, ecx

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  014f4	33 cb		 xor	 ecx, ebx
  014f6	79 1d		 jns	 SHORT $LN1193@dtx_dec

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  014f8	8b c2		 mov	 eax, edx
  014fa	33 c3		 xor	 eax, ebx
  014fc	79 17		 jns	 SHORT $LN1193@dtx_dec

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  014fe	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  01500	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0150a	85 db		 test	 ebx, ebx
  0150c	0f 98 c2	 sets	 dl
  0150f	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN1193@dtx_dec:

; 1715 :     L_var_out = (Word32) var1;

  01515	0f bf 87 8a 01
	00 00		 movsx	 eax, WORD PTR [edi+394]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 599  :                         L_shl(L_deposit_l(st->log_en_adjust), 5));  move32();

  0151c	b9 05 00 00 00	 mov	 ecx, 5
$LL1209@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  01521	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  01526	7f 18		 jg	 SHORT $LN1415@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01528	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  0152d	7c 0a		 jl	 SHORT $LN1416@dtx_dec

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  0152f	49		 dec	 ecx
  01530	03 c0		 add	 eax, eax
  01532	66 85 c9	 test	 cx, cx
  01535	7f ea		 jg	 SHORT $LL1209@dtx_dec

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01537	eb 16		 jmp	 SHORT $LN1204@dtx_dec
$LN1416@dtx_dec:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  01539	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0153e	eb 05		 jmp	 SHORT $LN1570@dtx_dec
$LN1415@dtx_dec:

; 1360 :                 L_var_out = MAX_32;

  01540	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN1570@dtx_dec:

; 1358 :             {
; 1359 :                 Overflow = 1;

  01545	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1204@dtx_dec:

; 931  :     L_var_out = L_var1 + L_var2;

  0154f	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01552	33 c2		 xor	 eax, edx
  01554	78 1d		 js	 SHORT $LN1221@dtx_dec

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  01556	8b c1		 mov	 eax, ecx
  01558	33 c2		 xor	 eax, edx
  0155a	79 17		 jns	 SHORT $LN1221@dtx_dec

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0155c	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  0155e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01568	85 d2		 test	 edx, edx
  0156a	0f 98 c1	 sets	 cl
  0156d	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN1221@dtx_dec:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  01573	8b c1		 mov	 eax, ecx

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  01575	8b d1		 mov	 edx, ecx

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  01577	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 601  :    log_en_int_e = extract_h(L_log_en_int);                    move16();

  0157a	0f b7 f0	 movzx	 esi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1675 :     L_var_out = (Word32) var1 << 16;

  0157d	0f bf c6	 movsx	 eax, si
  01580	c1 e0 10	 shl	 eax, 16			; 00000010H

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  01583	2b d0		 sub	 edx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  01585	33 c1		 xor	 eax, ecx
  01587	79 1d		 jns	 SHORT $LN1235@dtx_dec

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  01589	8b c2		 mov	 eax, edx
  0158b	33 c1		 xor	 eax, ecx
  0158d	79 17		 jns	 SHORT $LN1235@dtx_dec

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0158f	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  01591	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0159b	85 c9		 test	 ecx, ecx
  0159d	0f 98 c2	 sets	 dl
  015a0	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN1235@dtx_dec:

; 1437 :             if (L_var1 < 0)

  015a6	85 d2		 test	 edx, edx
  015a8	79 08		 jns	 SHORT $LN1240@dtx_dec

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  015aa	f7 d2		 not	 edx
  015ac	d1 fa		 sar	 edx, 1
  015ae	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  015b0	eb 02		 jmp	 SHORT $LN1239@dtx_dec
$LN1240@dtx_dec:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  015b2	d1 fa		 sar	 edx, 1
$LN1239@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 605  :    level = extract_l(Pow2(log_en_int_e, log_en_int_m)); /* Q4 */ move16();

  015b4	8b ce		 mov	 ecx, esi
  015b6	e8 00 00 00 00	 call	 _Pow2
  015bb	8b 9d 30 ff ff
	ff		 mov	 ebx, DWORD PTR tv7383[ebp]
  015c1	bf 04 00 00 00	 mov	 edi, 4
  015c6	0f b7 c0	 movzx	 eax, ax
  015c9	0f bf f0	 movsx	 esi, ax
  015cc	8d 64 24 00	 npad	 4
$LL11@dtx_dec:

; 606  :    
; 607  :    for (i = 0; i < 4; i++)
; 608  :    {             
; 609  :       /* Compute innovation vector */
; 610  :       build_CN_code(&st->L_pn_seed_rx, ex);

  015d0	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _ex$[ebp]
  015d6	8b cb		 mov	 ecx, ebx
  015d8	e8 00 00 00 00	 call	 _build_CN_code
  015dd	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _ex$[ebp]
  015e3	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  015e8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL8@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  015f0	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  015f3	0f af c6	 imul	 eax, esi

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  015f6	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  015f9	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  015fe	74 05		 je	 SHORT $LN1265@dtx_dec

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  01600	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN1265@dtx_dec:

; 79   :     if (L_var1 > 0X00007fffL)

  01605	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0160a	7e 11		 jle	 SHORT $LN1271@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  0160c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01616	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0161b	eb 1b		 jmp	 SHORT $LN1268@dtx_dec
$LN1271@dtx_dec:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0161d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01622	7d 11		 jge	 SHORT $LN1269@dtx_dec

; 86   :         Overflow = 1;

  01624	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0162e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 89   :     else

  01633	eb 03		 jmp	 SHORT $LN1268@dtx_dec
$LN1269@dtx_dec:

; 91   :         var_out = extract_l (L_var1);

  01635	0f b7 c0	 movzx	 eax, ax
$LN1268@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 613  :          ex[j] = mult(level, ex[j]);                                move16();

  01638	66 89 01	 mov	 WORD PTR [ecx], ax
  0163b	83 c1 02	 add	 ecx, 2
  0163e	4a		 dec	 edx
  0163f	75 af		 jne	 SHORT $LL8@dtx_dec

; 614  :       }
; 615  :       /* Synthesize */
; 616  :       Syn_filt(acoeff_variab, ex, &synth[i * L_SUBFR], L_SUBFR, 
; 617  :                mem_syn, 1);

  01641	6a 01		 push	 1
  01643	ff b5 20 ff ff
	ff		 push	 DWORD PTR _mem_syn$GSCopy$1$[ebp]
  01649	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _ex$[ebp]
  0164f	6a 28		 push	 40			; 00000028H
  01651	ff b5 24 ff ff
	ff		 push	 DWORD PTR _synth$GSCopy$1$[ebp]
  01657	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _acoeff_variab$[ebp]
  0165d	e8 00 00 00 00	 call	 _Syn_filt
  01662	83 85 24 ff ff
	ff 50		 add	 DWORD PTR _synth$GSCopy$1$[ebp], 80 ; 00000050H
  01669	83 c4 10	 add	 esp, 16			; 00000010H
  0166c	4f		 dec	 edi
  0166d	0f 85 5d ff ff
	ff		 jne	 $LL11@dtx_dec

; 618  :       
; 619  :    } /* next i */
; 620  :    
; 621  :    /* reset codebook averaging variables */ 
; 622  :    averState->hangVar = 20;                                         move16();

  01673	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _averState$GSCopy$1$[ebp]
  01679	c7 40 0e 14 00
	00 00		 mov	 DWORD PTR [eax+14], 20	; 00000014H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01680	8b 45 14	 mov	 eax, DWORD PTR _new_state$[ebp]
  01683	98		 cwde
  01684	83 e8 02	 sub	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  01687	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0168c	0f 8f 42 01 00
	00		 jg	 $LN1571@dtx_dec

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01692	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01697	0f 8c 37 01 00
	00		 jl	 $LN1571@dtx_dec
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 626  :    if (sub(new_state, DTX_MUTE) == 0)

  0169d	66 85 c0	 test	 ax, ax
  016a0	0f 85 38 01 00
	00		 jne	 $LN1558@dtx_dec

; 627  :    {
; 628  :       /* mute comfort noise as it has been quite a long time since  
; 629  :        * last SID update  was performed                            */
; 630  :       
; 631  :       tmp_int_length = st->since_last_sid;                          move16();

  016a6	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  016ac	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  016af	0f bf c1	 movsx	 eax, cx
  016b2	83 e8 20	 sub	 eax, 32			; 00000020H

; 79   :     if (L_var1 > 0X00007fffL)

  016b5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  016ba	7e 0f		 jle	 SHORT $LN1303@dtx_dec

; 80   :     {
; 81   :         Overflow = 1;

  016bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 635  :          tmp_int_length = 32;                                       move16();

  016c6	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]

; 640  :       if(tmp_int_length <= 0) {

  016c9	eb 1c		 jmp	 SHORT $LN1312@dtx_dec
$LN1303@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  016cb	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  016d0	7d 41		 jge	 SHORT $LN1301@dtx_dec

; 86   :         Overflow = 1;

  016d2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1308@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 640  :       if(tmp_int_length <= 0) {

  016dc	66 85 c9	 test	 cx, cx
  016df	b8 08 00 00 00	 mov	 eax, 8
  016e4	0f 4e c8	 cmovle	 ecx, eax
$LN1312@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  016e7	0f bf d1	 movsx	 edx, cx
  016ea	c1 e2 0a	 shl	 edx, 10			; 0000000aH

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  016ed	0f bf c2	 movsx	 eax, dx
  016f0	3b d0		 cmp	 edx, eax
  016f2	74 2b		 je	 SHORT $LN1319@dtx_dec

; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  016f4	66 85 c9	 test	 cx, cx
  016f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01701	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  01706	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0170b	0f 4f c1	 cmovg	 eax, ecx
  0170e	0f b7 d0	 movzx	 edx, ax

; 304  :         }
; 305  :         else

  01711	eb 0f		 jmp	 SHORT $LN1316@dtx_dec
$LN1301@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 633  :       if (sub(tmp_int_length, 32) > 0)

  01713	66 85 c0	 test	 ax, ax
  01716	7e c4		 jle	 SHORT $LN1308@dtx_dec

; 635  :          tmp_int_length = 32;                                       move16();

  01718	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H

; 640  :       if(tmp_int_length <= 0) {

  0171d	eb c8		 jmp	 SHORT $LN1312@dtx_dec
$LN1319@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  0171f	0f b7 d2	 movzx	 edx, dx
$LN1316@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 645  :       st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 

  01722	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  01727	e8 00 00 00 00	 call	 _div_s
  0172c	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 646  : 
; 647  :       st->since_last_sid = 0;                                       move16();

  01730	33 c0		 xor	 eax, eax
  01732	66 89 03	 mov	 WORD PTR [ebx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  01735	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  01739	66 89 43 20	 mov	 WORD PTR [ebx+32], ax
  0173d	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  01741	66 89 43 22	 mov	 WORD PTR [ebx+34], ax
  01745	0f b7 43 10	 movzx	 eax, WORD PTR [ebx+16]
  01749	66 89 43 24	 mov	 WORD PTR [ebx+36], ax
  0174d	0f b7 43 12	 movzx	 eax, WORD PTR [ebx+18]
  01751	66 89 43 26	 mov	 WORD PTR [ebx+38], ax
  01755	0f b7 43 14	 movzx	 eax, WORD PTR [ebx+20]
  01759	66 89 43 28	 mov	 WORD PTR [ebx+40], ax
  0175d	0f b7 43 16	 movzx	 eax, WORD PTR [ebx+22]
  01761	66 89 43 2a	 mov	 WORD PTR [ebx+42], ax
  01765	0f b7 43 18	 movzx	 eax, WORD PTR [ebx+24]
  01769	66 89 43 2c	 mov	 WORD PTR [ebx+44], ax
  0176d	0f b7 43 1a	 movzx	 eax, WORD PTR [ebx+26]
  01771	66 89 43 2e	 mov	 WORD PTR [ebx+46], ax
  01775	0f b7 43 1c	 movzx	 eax, WORD PTR [ebx+28]
  01779	66 89 43 30	 mov	 WORD PTR [ebx+48], ax
  0177d	0f b7 43 1e	 movzx	 eax, WORD PTR [ebx+30]
  01781	66 89 43 32	 mov	 WORD PTR [ebx+50], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 649  :       st->old_log_en = st->log_en;                                  move16();

  01785	0f b7 43 04	 movzx	 eax, WORD PTR [ebx+4]
  01789	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0178d	98		 cwde
  0178e	2d 00 01 00 00	 sub	 eax, 256		; 00000100H

; 79   :     if (L_var1 > 0X00007fffL)

  01793	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01798	7e 15		 jle	 SHORT $LN1352@dtx_dec

; 82   :         var_out = MAX_16;

  0179a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0179f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 651  :       st->log_en = sub(st->log_en, 256);                            move16();  

  017a9	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  017ad	eb 35		 jmp	 SHORT $LN1357@dtx_dec
$LN1352@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  017af	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  017b4	7d 15		 jge	 SHORT $LN1350@dtx_dec

; 87   :         var_out = MIN_16;

  017b6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  017bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 651  :       st->log_en = sub(st->log_en, 256);                            move16();  

  017c5	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  017c9	eb 19		 jmp	 SHORT $LN1357@dtx_dec
$LN1350@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  017cb	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 651  :       st->log_en = sub(st->log_en, 256);                            move16();  

  017ce	66 89 43 04	 mov	 WORD PTR [ebx+4], ax
  017d2	eb 10		 jmp	 SHORT $LN1357@dtx_dec
$LN1571@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  017d4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1558@dtx_dec:
  017de	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
$LN1357@dtx_dec:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 659  :         ((st->valid_data == 0) &&  (st->dtxHangoverAdded) != 0))) 

  017e4	66 83 bb 90 01
	00 00 00	 cmp	 WORD PTR [ebx+400], 0
  017ec	74 25		 je	 SHORT $LN1551@dtx_dec
  017ee	66 83 bb 92 01
	00 00 00	 cmp	 WORD PTR [ebx+402], 0
  017f6	75 0a		 jne	 SHORT $LN1@dtx_dec
  017f8	66 83 bb 94 01
	00 00 00	 cmp	 WORD PTR [ebx+404], 0
  01800	74 11		 je	 SHORT $LN1551@dtx_dec
$LN1@dtx_dec:

; 660  :    {
; 661  :       st->since_last_sid =  0;                                      move16();

  01802	33 c0		 xor	 eax, eax
  01804	66 89 03	 mov	 WORD PTR [ebx], ax

; 662  :       st->data_updated = 1;                                         move16();

  01807	b8 01 00 00 00	 mov	 eax, 1
  0180c	66 89 83 9c 01
	00 00		 mov	 WORD PTR [ebx+412], ax
$LN1551@dtx_dec:

; 663  :    }
; 664  :          
; 665  :    return 0;
; 666  : }

  01813	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01816	33 c0		 xor	 eax, eax
  01818	5f		 pop	 edi
  01819	5e		 pop	 esi
  0181a	33 cd		 xor	 ecx, ebp
  0181c	5b		 pop	 ebx
  0181d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01822	8b e5		 mov	 esp, ebp
  01824	5d		 pop	 ebp
  01825	c3		 ret	 0
_dtx_dec ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _dtx_dec_init
_TEXT	SEGMENT
_dtx_dec_init PROC					; COMDAT
; _st$ = ecx

; 100  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 101  :    dtx_decState* s;
; 102  :    
; 103  :    if (st == (dtx_decState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@dtx_dec_in

; 104  :       fprintf(stderr, "dtx_dec_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LABEIKEE@dtx_dec_init?3?5invalid?5parameter?6@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 105  :       return -1; 

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 120  : }

  00023	c3		 ret	 0
$LN2@dtx_dec_in:
  00024	57		 push	 edi

; 106  :    }
; 107  :    
; 108  :    *st = NULL;
; 109  :    
; 110  :    /* allocate memory */
; 111  :    if ((s= (dtx_decState *) malloc(sizeof(dtx_decState))) == NULL){

  00025	68 a0 01 00 00	 push	 416			; 000001a0H
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00036	8b f8		 mov	 edi, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	85 ff		 test	 edi, edi
  0003d	75 1e		 jne	 SHORT $LN1@dtx_dec_in

; 112  :       fprintf(stderr, "dtx_dec_init: can not malloc state structure\n");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KHMAKKFJ@dtx_dec_init?3?5can?5not?5malloc?5sta@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0004a	83 c0 40	 add	 eax, 64			; 00000040H
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00054	83 c4 08	 add	 esp, 8

; 113  :       return -1;

  00057	83 c8 ff	 or	 eax, -1
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 120  : }

  0005c	c3		 ret	 0
$LN1@dtx_dec_in:

; 114  :    }
; 115  :    
; 116  :    dtx_dec_reset(s);

  0005d	8b cf		 mov	 ecx, edi
  0005f	e8 00 00 00 00	 call	 _dtx_dec_reset

; 117  :    *st = s;

  00064	89 3e		 mov	 DWORD PTR [esi], edi

; 118  :    
; 119  :    return 0;

  00066	33 c0		 xor	 eax, eax
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 120  : }

  0006a	c3		 ret	 0
_dtx_dec_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _rx_dtx_handler
_TEXT	SEGMENT
_var_out$1$ = -16					; size = 4
_L_diff$1$ = -12					; size = 4
tv739 = -8						; size = 4
_frame_type$1$ = -4					; size = 4
_rx_dtx_handler PROC					; COMDAT
; _st$ = ecx
; _frame_type$ = edx

; 742  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	8b f1		 mov	 esi, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0000d	0f bf d7	 movsx	 edx, di
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 742  : {

  00010	89 7d fc	 mov	 DWORD PTR _frame_type$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00013	89 55 f8	 mov	 DWORD PTR tv739[ebp], edx
  00016	8d 4a fc	 lea	 ecx, DWORD PTR [edx-4]
  00019	89 4d f4	 mov	 DWORD PTR _L_diff$1$[ebp], ecx

; 79   :     if (L_var1 > 0X00007fffL)

  0001c	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00022	7e 0c		 jle	 SHORT $LN49@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00024	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0002e	eb 1d		 jmp	 SHORT $LN350@rx_dtx_han
$LN49@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00030	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00036	7d 0c		 jge	 SHORT $LN47@rx_dtx_han

; 86   :         Overflow = 1;

  00038	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00042	eb 09		 jmp	 SHORT $LN350@rx_dtx_han
$LN47@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 757  :          (sub(frame_type, RX_ONSET) == 0))))

  00044	66 85 c9	 test	 cx, cx
  00047	0f 84 d9 00 00
	00		 je	 $LN22@rx_dtx_han
$LN350@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0004d	8d 7a fb	 lea	 edi, DWORD PTR [edx-5]

; 79   :     if (L_var1 > 0X00007fffL)

  00050	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00056	7e 0c		 jle	 SHORT $LN59@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00058	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00062	eb 1d		 jmp	 SHORT $LN351@rx_dtx_han
$LN59@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00064	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  0006a	7d 0c		 jge	 SHORT $LN57@rx_dtx_han

; 86   :         Overflow = 1;

  0006c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00076	eb 09		 jmp	 SHORT $LN351@rx_dtx_han
$LN57@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 757  :          (sub(frame_type, RX_ONSET) == 0))))

  00078	66 85 ff	 test	 di, di
  0007b	0f 84 a2 00 00
	00		 je	 $LN368@rx_dtx_han
$LN351@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00081	8d 42 fa	 lea	 eax, DWORD PTR [edx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  00084	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00089	7e 0c		 jle	 SHORT $LN69@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  0008b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00095	eb 18		 jmp	 SHORT $LN352@rx_dtx_han
$LN69@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00097	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0009c	7d 0c		 jge	 SHORT $LN67@rx_dtx_han

; 86   :         Overflow = 1;

  0009e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000a8	eb 05		 jmp	 SHORT $LN352@rx_dtx_han
$LN67@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 757  :          (sub(frame_type, RX_ONSET) == 0))))

  000aa	66 85 c0	 test	 ax, ax
  000ad	74 74		 je	 SHORT $LN368@rx_dtx_han
$LN352@rx_dtx_han:
  000af	0f b7 9e 98 01
	00 00		 movzx	 ebx, WORD PTR [esi+408]
  000b6	ba 01 00 00 00	 mov	 edx, 1
  000bb	8b cb		 mov	 ecx, ebx
  000bd	e8 00 00 00 00	 call	 _sub
  000c2	66 85 c0	 test	 ax, ax
  000c5	74 11		 je	 SHORT $LN23@rx_dtx_han
  000c7	ba 02 00 00 00	 mov	 edx, 2
  000cc	8b cb		 mov	 ecx, ebx
  000ce	e8 00 00 00 00	 call	 _sub
  000d3	66 85 c0	 test	 ax, ax
  000d6	75 36		 jne	 SHORT $LN25@rx_dtx_han
$LN23@rx_dtx_han:
  000d8	8b 5d fc	 mov	 ebx, DWORD PTR _frame_type$1$[ebp]
  000db	ba 07 00 00 00	 mov	 edx, 7
  000e0	8b cb		 mov	 ecx, ebx
  000e2	e8 00 00 00 00	 call	 _sub
  000e7	66 85 c0	 test	 ax, ax
  000ea	74 31		 je	 SHORT $LN366@rx_dtx_han
  000ec	ba 03 00 00 00	 mov	 edx, 3
  000f1	8b cb		 mov	 ecx, ebx
  000f3	e8 00 00 00 00	 call	 _sub
  000f8	66 85 c0	 test	 ax, ax
  000fb	74 20		 je	 SHORT $LN366@rx_dtx_han
  000fd	ba 02 00 00 00	 mov	 edx, 2
  00102	8b cb		 mov	 ecx, ebx
  00104	e8 00 00 00 00	 call	 _sub
  00109	66 85 c0	 test	 ax, ax
  0010c	74 0f		 je	 SHORT $LN366@rx_dtx_han
$LN25@rx_dtx_han:

; 786  :       }
; 787  :    }
; 788  :    else 
; 789  :    {
; 790  :       newState = SPEECH;                                           move16();
; 791  :       st->since_last_sid = 0;                                      move16();

  0010e	8b 4d f8	 mov	 ecx, DWORD PTR tv739[ebp]
  00111	33 db		 xor	 ebx, ebx
  00113	33 c0		 xor	 eax, eax
  00115	66 89 06	 mov	 WORD PTR [esi], ax
  00118	e9 51 01 00 00	 jmp	 $LN156@rx_dtx_han
$LN366@rx_dtx_han:
  0011d	8b 55 f8	 mov	 edx, DWORD PTR tv739[ebp]
  00120	8b 4d f4	 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
$LN368@rx_dtx_han:
  00123	8b 7d fc	 mov	 edi, DWORD PTR _frame_type$1$[ebp]
$LN22@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00126	0f bf 86 98 01
	00 00		 movsx	 eax, WORD PTR [esi+408]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 759  :       newState = DTX;                                              move16();

  0012d	bb 01 00 00 00	 mov	 ebx, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00132	83 e8 02	 sub	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  00135	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0013a	7e 0b		 jle	 SHORT $LN91@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  0013c	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 82   :         var_out = MAX_16;

  00142	e9 86 00 00 00	 jmp	 $LN116@rx_dtx_han
$LN91@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00147	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0014c	7d 08		 jge	 SHORT $LN89@rx_dtx_han

; 86   :         Overflow = 1;

  0014e	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 88   :     }
; 89   :     else

  00154	eb 77		 jmp	 SHORT $LN116@rx_dtx_han
$LN89@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 767  :            (sub(frame_type, RX_NO_DATA) == 0)))

  00156	66 85 c0	 test	 ax, ax
  00159	75 72		 jne	 SHORT $LN116@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0015b	8d 42 fa	 lea	 eax, DWORD PTR [edx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  0015e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00163	7e 08		 jle	 SHORT $LN101@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00165	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 82   :         var_out = MAX_16;

  0016b	eb 14		 jmp	 SHORT $LN353@rx_dtx_han
$LN101@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0016d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00172	7d 08		 jge	 SHORT $LN99@rx_dtx_han

; 86   :         Overflow = 1;

  00174	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 88   :     }
; 89   :     else

  0017a	eb 05		 jmp	 SHORT $LN353@rx_dtx_han
$LN99@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 767  :            (sub(frame_type, RX_NO_DATA) == 0)))

  0017c	66 85 c0	 test	 ax, ax
  0017f	74 47		 je	 SHORT $LN20@rx_dtx_han
$LN353@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00181	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00187	7e 08		 jle	 SHORT $LN111@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00189	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 82   :         var_out = MAX_16;

  0018f	eb 15		 jmp	 SHORT $LN354@rx_dtx_han
$LN111@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00191	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00197	7d 08		 jge	 SHORT $LN109@rx_dtx_han

; 86   :         Overflow = 1;

  00199	89 1d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ebx

; 88   :     }
; 89   :     else

  0019f	eb 05		 jmp	 SHORT $LN354@rx_dtx_han
$LN109@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 767  :            (sub(frame_type, RX_NO_DATA) == 0)))

  001a1	66 85 c9	 test	 cx, cx
  001a4	74 22		 je	 SHORT $LN20@rx_dtx_han
$LN354@rx_dtx_han:
  001a6	ba 02 00 00 00	 mov	 edx, 2
  001ab	8b cf		 mov	 ecx, edi
  001ad	e8 00 00 00 00	 call	 _sub
  001b2	66 85 c0	 test	 ax, ax
  001b5	74 11		 je	 SHORT $LN20@rx_dtx_han
  001b7	ba 07 00 00 00	 mov	 edx, 7
  001bc	8b cf		 mov	 ecx, edi
  001be	e8 00 00 00 00	 call	 _sub
  001c3	66 85 c0	 test	 ax, ax
  001c6	75 05		 jne	 SHORT $LN116@rx_dtx_han
$LN20@rx_dtx_han:

; 768  :       {
; 769  :          newState = DTX_MUTE;                                      move16();

  001c8	bb 02 00 00 00	 mov	 ebx, 2
$LN116@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  001cd	0f bf 06	 movsx	 eax, WORD PTR [esi]
  001d0	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  001d1	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001d6	7e 11		 jle	 SHORT $LN123@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  001d8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001e2	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001e7	eb 1b		 jmp	 SHORT $LN120@rx_dtx_han
$LN123@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001e9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001ee	7d 11		 jge	 SHORT $LN121@rx_dtx_han

; 86   :         Overflow = 1;

  001f0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001fa	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001ff	eb 03		 jmp	 SHORT $LN120@rx_dtx_han
$LN121@rx_dtx_han:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00201	0f b7 c0	 movzx	 eax, ax
$LN120@rx_dtx_han:

; 186  :     L_diff = (Word32) var1 - var2;

  00204	8b 4d f8	 mov	 ecx, DWORD PTR tv739[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 774  :       st->since_last_sid = add(st->since_last_sid, 1);             move16();

  00207	66 89 06	 mov	 WORD PTR [esi], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0020a	8d 79 fb	 lea	 edi, DWORD PTR [ecx-5]

; 79   :     if (L_var1 > 0X00007fffL)

  0020d	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00213	7e 0c		 jle	 SHORT $LN141@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00215	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0021f	eb 19		 jmp	 SHORT $LN355@rx_dtx_han
$LN141@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00221	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  00227	7d 0c		 jge	 SHORT $LN139@rx_dtx_han

; 86   :         Overflow = 1;

  00229	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00233	eb 05		 jmp	 SHORT $LN355@rx_dtx_han
$LN139@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 783  :          (sub(st->since_last_sid, DTX_MAX_EMPTY_THRESH) > 0))

  00235	66 85 ff	 test	 di, di
  00238	74 34		 je	 SHORT $LN156@rx_dtx_han
$LN355@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0023a	98		 cwde
  0023b	83 e8 32	 sub	 eax, 50			; 00000032H

; 79   :     if (L_var1 > 0X00007fffL)

  0023e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00243	7e 0c		 jle	 SHORT $LN151@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00245	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0024f	eb 18		 jmp	 SHORT $LN356@rx_dtx_han
$LN151@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00251	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00256	7d 0c		 jge	 SHORT $LN149@rx_dtx_han

; 86   :         Overflow = 1;

  00258	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00262	eb 0a		 jmp	 SHORT $LN156@rx_dtx_han
$LN149@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 783  :          (sub(st->since_last_sid, DTX_MAX_EMPTY_THRESH) > 0))

  00264	66 85 c0	 test	 ax, ax
  00267	7e 05		 jle	 SHORT $LN156@rx_dtx_han
$LN356@rx_dtx_han:

; 784  :       {
; 785  :          newState = DTX_MUTE;                                      move16();

  00269	bb 02 00 00 00	 mov	 ebx, 2
$LN156@rx_dtx_han:

; 801  :        (sub(frame_type, RX_SID_UPDATE) == 0))

  0026e	66 83 be 9c 01
	00 00 00	 cmp	 WORD PTR [esi+412], 0
  00276	75 36		 jne	 SHORT $LN176@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00278	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  0027e	7e 0c		 jle	 SHORT $LN171@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00280	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0028a	eb 22		 jmp	 SHORT $LN176@rx_dtx_han
$LN171@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0028c	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  00292	7d 0c		 jge	 SHORT $LN169@rx_dtx_han

; 86   :         Overflow = 1;

  00294	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0029e	eb 0e		 jmp	 SHORT $LN176@rx_dtx_han
$LN169@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 801  :        (sub(frame_type, RX_SID_UPDATE) == 0))

  002a0	66 85 ff	 test	 di, di
  002a3	75 09		 jne	 SHORT $LN176@rx_dtx_han

; 802  :    {
; 803  :       st->decAnaElapsedCount = 0;                                  move16();

  002a5	33 c0		 xor	 eax, eax
  002a7	66 89 86 8e 01
	00 00		 mov	 WORD PTR [esi+398], ax
$LN176@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002ae	0f bf 86 8e 01
	00 00		 movsx	 eax, WORD PTR [esi+398]
  002b5	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  002b6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002bb	7e 11		 jle	 SHORT $LN183@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  002bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002c7	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002cc	eb 1b		 jmp	 SHORT $LN369@rx_dtx_han
$LN183@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002ce	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002d3	7d 11		 jge	 SHORT $LN181@rx_dtx_han

; 86   :         Overflow = 1;

  002d5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002df	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002e4	eb 03		 jmp	 SHORT $LN369@rx_dtx_han
$LN181@rx_dtx_han:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002e6	0f b7 c0	 movzx	 eax, ax
$LN369@rx_dtx_han:
  002e9	89 45 f0	 mov	 DWORD PTR _var_out$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 808  :    st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1);        move16();

  002ec	66 89 86 8e 01
	00 00		 mov	 WORD PTR [esi+398], ax

; 809  :    st->dtxHangoverAdded = 0;                                       move16();

  002f3	33 c0		 xor	 eax, eax
  002f5	66 89 86 94 01
	00 00		 mov	 WORD PTR [esi+404], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  002fc	8b 45 f4	 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  002ff	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00304	7e 0c		 jle	 SHORT $LN207@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00306	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00310	eb 1c		 jmp	 SHORT $LN357@rx_dtx_han
$LN207@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00312	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00317	7d 0c		 jge	 SHORT $LN205@rx_dtx_han

; 86   :         Overflow = 1;

  00319	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00323	eb 09		 jmp	 SHORT $LN357@rx_dtx_han
$LN205@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 816  :        (sub(frame_type, RX_NO_DATA) == 0))

  00325	66 85 c0	 test	 ax, ax
  00328	0f 84 83 00 00
	00		 je	 $LN15@rx_dtx_han
$LN357@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0032e	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00334	7e 0c		 jle	 SHORT $LN217@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00336	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00340	eb 19		 jmp	 SHORT $LN358@rx_dtx_han
$LN217@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00342	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  00348	7d 0c		 jge	 SHORT $LN215@rx_dtx_han

; 86   :         Overflow = 1;

  0034a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00354	eb 05		 jmp	 SHORT $LN358@rx_dtx_han
$LN215@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 816  :        (sub(frame_type, RX_NO_DATA) == 0))

  00356	66 85 ff	 test	 di, di
  00359	74 56		 je	 SHORT $LN15@rx_dtx_han
$LN358@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0035b	8d 41 fa	 lea	 eax, DWORD PTR [ecx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  0035e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00363	7e 0c		 jle	 SHORT $LN227@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00365	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0036f	eb 18		 jmp	 SHORT $LN359@rx_dtx_han
$LN227@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00371	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00376	7d 0c		 jge	 SHORT $LN225@rx_dtx_han

; 86   :         Overflow = 1;

  00378	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00382	eb 05		 jmp	 SHORT $LN359@rx_dtx_han
$LN225@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 816  :        (sub(frame_type, RX_NO_DATA) == 0))

  00384	66 85 c0	 test	 ax, ax
  00387	74 28		 je	 SHORT $LN15@rx_dtx_han
$LN359@rx_dtx_han:
  00389	8b 4d fc	 mov	 ecx, DWORD PTR _frame_type$1$[ebp]
  0038c	ba 02 00 00 00	 mov	 edx, 2
  00391	e8 00 00 00 00	 call	 _sub
  00396	66 85 c0	 test	 ax, ax
  00399	74 16		 je	 SHORT $LN15@rx_dtx_han
  0039b	8b 4d fc	 mov	 ecx, DWORD PTR _frame_type$1$[ebp]
  0039e	ba 07 00 00 00	 mov	 edx, 7
  003a3	e8 00 00 00 00	 call	 _sub
  003a8	66 85 c0	 test	 ax, ax
  003ab	74 04		 je	 SHORT $LN15@rx_dtx_han

; 829  :       {
; 830  :          encState = SPEECH;                                       move16();
; 831  :       }
; 832  :       
; 833  :       
; 834  :       /* Note on RX_ONSET operation differing from RX_NO_DATA operation:
; 835  :          If a  RX_ONSET is received in the decoder (by "accident")
; 836  :          it is still most likely that the encoder  state
; 837  :          for the "ONSET frame" was DTX.
; 838  :       */      
; 839  :    }
; 840  :    else 
; 841  :    {
; 842  :       encState = SPEECH;                                           move16();

  003ad	33 c9		 xor	 ecx, ecx
  003af	eb 57		 jmp	 SHORT $LN258@rx_dtx_han
$LN15@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003b1	8b 45 f8	 mov	 eax, DWORD PTR tv739[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 818  :       encState = DTX;                                              move16();

  003b4	b9 01 00 00 00	 mov	 ecx, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003b9	83 c0 f9	 add	 eax, -7			; fffffff9H

; 79   :     if (L_var1 > 0X00007fffL)

  003bc	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003c1	7e 08		 jle	 SHORT $LN243@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  003c3	89 0d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ecx

; 82   :         var_out = MAX_16;

  003c9	eb 3d		 jmp	 SHORT $LN258@rx_dtx_han
$LN243@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003cb	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003d0	7d 08		 jge	 SHORT $LN241@rx_dtx_han

; 86   :         Overflow = 1;

  003d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ecx

; 88   :     }
; 89   :     else

  003d8	eb 2e		 jmp	 SHORT $LN258@rx_dtx_han
$LN241@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 828  :          (sub(newState, SPEECH) == 0)) 

  003da	66 85 c0	 test	 ax, ax
  003dd	75 29		 jne	 SHORT $LN258@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003df	0f bf c3	 movsx	 eax, bx

; 79   :     if (L_var1 > 0X00007fffL)

  003e2	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003e7	7e 08		 jle	 SHORT $LN253@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  003e9	89 0d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ecx

; 82   :         var_out = MAX_16;

  003ef	eb 17		 jmp	 SHORT $LN258@rx_dtx_han
$LN253@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003f1	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003f6	7d 08		 jge	 SHORT $LN251@rx_dtx_han

; 86   :         Overflow = 1;

  003f8	89 0d 00 00 00
	00		 mov	 DWORD PTR _Overflow, ecx

; 88   :     }
; 89   :     else

  003fe	eb 08		 jmp	 SHORT $LN258@rx_dtx_han
$LN251@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 828  :          (sub(newState, SPEECH) == 0)) 

  00400	33 d2		 xor	 edx, edx
  00402	66 85 c0	 test	 ax, ax
  00405	0f 44 ca	 cmove	 ecx, edx
$LN258@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00408	0f bf c1	 movsx	 eax, cx

; 79   :     if (L_var1 > 0X00007fffL)

  0040b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00410	7f 16		 jg	 SHORT $LN371@rx_dtx_han

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00412	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00417	7c 0f		 jl	 SHORT $LN371@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 846  :    if (sub(encState, SPEECH) == 0)

  00419	66 85 c0	 test	 ax, ax
  0041c	75 14		 jne	 SHORT $LN12@rx_dtx_han

; 847  :    {
; 848  :       st->dtxHangoverCount = DTX_HANG_CONST;                       move16();

  0041e	b8 07 00 00 00	 mov	 eax, 7

; 849  :    }
; 850  :    else

  00423	8d 48 fa	 lea	 ecx, DWORD PTR [eax-6]
  00426	eb 76		 jmp	 SHORT $LN370@rx_dtx_han
$LN371@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00428	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN12@rx_dtx_han:

; 186  :     L_diff = (Word32) var1 - var2;

  00432	8b 45 f0	 mov	 eax, DWORD PTR _var_out$1$[ebp]
  00435	98		 cwde
  00436	83 e8 1e	 sub	 eax, 30			; 0000001eH

; 79   :     if (L_var1 > 0X00007fffL)

  00439	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0043e	7e 0c		 jle	 SHORT $LN283@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  00440	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0044a	eb 30		 jmp	 SHORT $LN360@rx_dtx_han
$LN283@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0044c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00451	7d 24		 jge	 SHORT $LN281@rx_dtx_han

; 86   :         Overflow = 1;

  00453	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN10@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 859  :       else if (test(), st->dtxHangoverCount == 0)

  0045d	0f b7 8e 8c 01
	00 00		 movzx	 ecx, WORD PTR [esi+396]
  00464	66 85 c9	 test	 cx, cx
  00467	75 29		 jne	 SHORT $LN8@rx_dtx_han

; 860  :       {
; 861  :          st->decAnaElapsedCount = 0;                               move16();

  00469	33 c0		 xor	 eax, eax
  0046b	66 89 86 8e 01
	00 00		 mov	 WORD PTR [esi+398], ax

; 862  :       }
; 863  :       else

  00472	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00475	eb 2e		 jmp	 SHORT $LN298@rx_dtx_han
$LN281@rx_dtx_han:

; 851  :    {
; 852  :       test();
; 853  :       if (sub(st->decAnaElapsedCount, DTX_ELAPSED_FRAMES_THRESH) > 0)

  00477	66 85 c0	 test	 ax, ax
  0047a	7e e1		 jle	 SHORT $LN10@rx_dtx_han
$LN360@rx_dtx_han:

; 854  :       {
; 855  :          st->dtxHangoverAdded = 1;                                 move16();

  0047c	b9 01 00 00 00	 mov	 ecx, 1

; 856  :          st->decAnaElapsedCount = 0;                               move16();

  00481	33 c0		 xor	 eax, eax
  00483	66 89 8e 94 01
	00 00		 mov	 WORD PTR [esi+404], cx

; 857  :          st->dtxHangoverCount = 0;                                 move16();

  0048a	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c

; 172  : }

  00490	eb 13		 jmp	 SHORT $LN298@rx_dtx_han
$LN8@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 865  :          st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);      move16();

  00492	ba 01 00 00 00	 mov	 edx, 1
  00497	e8 00 00 00 00	 call	 _sub
  0049c	8b ca		 mov	 ecx, edx
$LN370@rx_dtx_han:
  0049e	66 89 86 8c 01
	00 00		 mov	 WORD PTR [esi+396], ax
$LN298@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004a5	0f bf c3	 movsx	 eax, bx

; 79   :     if (L_var1 > 0X00007fffL)

  004a8	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004ad	7e 0c		 jle	 SHORT $LN305@rx_dtx_han

; 80   :     {
; 81   :         Overflow = 1;

  004af	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004b9	eb 1c		 jmp	 SHORT $LN361@rx_dtx_han
$LN305@rx_dtx_han:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004bb	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004c0	7d 0c		 jge	 SHORT $LN303@rx_dtx_han

; 86   :         Overflow = 1;

  004c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  004cc	eb 09		 jmp	 SHORT $LN361@rx_dtx_han
$LN303@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 869  :    if (sub(newState, SPEECH) != 0)

  004ce	66 85 c0	 test	 ax, ax
  004d1	0f 84 91 00 00
	00		 je	 $LN363@rx_dtx_han
$LN361@rx_dtx_han:

; 870  :    {
; 871  :       /* DTX or DTX_MUTE
; 872  :        * CN data is not in a first SID, first SIDs are marked as SID_BAD 
; 873  :        *  but will do backwards analysis if a hangover period has been added
; 874  :        *  according to the state machine above 
; 875  :        */
; 876  :       
; 877  :       st->sid_frame = 0;                                           move16();

  004d7	33 c0		 xor	 eax, eax
  004d9	89 86 90 01 00
	00		 mov	 DWORD PTR [esi+400], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  004df	8b 45 f4	 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  004e2	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004e7	7f 1c		 jg	 SHORT $LN372@rx_dtx_han

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004e9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004ee	7c 15		 jl	 SHORT $LN372@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 881  :       if (sub(frame_type, RX_SID_FIRST) == 0)

  004f0	66 85 c0	 test	 ax, ax
  004f3	75 1a		 jne	 SHORT $LN5@rx_dtx_han

; 882  :       {
; 883  :          st->sid_frame = 1;                                        move16();

  004f5	5f		 pop	 edi
  004f6	66 89 8e 90 01
	00 00		 mov	 WORD PTR [esi+400], cx

; 894  :       } 
; 895  :    }
; 896  : 
; 897  :    return newState; 

  004fd	8b c3		 mov	 eax, ebx
  004ff	5e		 pop	 esi
  00500	5b		 pop	 ebx

; 898  :    /* newState is used by both SPEECH AND DTX synthesis routines */ 
; 899  : }

  00501	8b e5		 mov	 esp, ebp
  00503	5d		 pop	 ebp
  00504	c3		 ret	 0
$LN372@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00505	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN5@rx_dtx_han:

; 79   :     if (L_var1 > 0X00007fffL)

  0050f	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00515	7f 20		 jg	 SHORT $LN373@rx_dtx_han

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00517	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  0051d	7c 18		 jl	 SHORT $LN373@rx_dtx_han
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 885  :       else if (test(), sub(frame_type, RX_SID_UPDATE) == 0)

  0051f	66 85 ff	 test	 di, di
  00522	75 1d		 jne	 SHORT $LN3@rx_dtx_han

; 886  :       {
; 887  :          st->sid_frame = 1;                                        move16();

  00524	5f		 pop	 edi
  00525	c7 86 90 01 00
	00 01 00 01 00	 mov	 DWORD PTR [esi+400], 65537 ; 00010001H

; 894  :       } 
; 895  :    }
; 896  : 
; 897  :    return newState; 

  0052f	8b c3		 mov	 eax, ebx
  00531	5e		 pop	 esi
  00532	5b		 pop	 ebx

; 898  :    /* newState is used by both SPEECH AND DTX synthesis routines */ 
; 899  : }

  00533	8b e5		 mov	 esp, ebp
  00535	5d		 pop	 ebp
  00536	c3		 ret	 0
$LN373@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00537	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN3@rx_dtx_han:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 890  :       else if (test(), sub(frame_type, RX_SID_BAD) == 0)

  00541	8b 4d fc	 mov	 ecx, DWORD PTR _frame_type$1$[ebp]
  00544	ba 06 00 00 00	 mov	 edx, 6
  00549	e8 00 00 00 00	 call	 _sub
  0054e	66 85 c0	 test	 ax, ax
  00551	75 15		 jne	 SHORT $LN363@rx_dtx_han

; 891  :       {
; 892  :          st->sid_frame = 1;                                        move16();

  00553	b8 01 00 00 00	 mov	 eax, 1
  00558	66 89 86 90 01
	00 00		 mov	 WORD PTR [esi+400], ax

; 893  :          st->dtxHangoverAdded = 0; /* use old data */              move16();

  0055f	33 c0		 xor	 eax, eax
  00561	66 89 86 94 01
	00 00		 mov	 WORD PTR [esi+404], ax
$LN363@rx_dtx_han:

; 894  :       } 
; 895  :    }
; 896  : 
; 897  :    return newState; 

  00568	5f		 pop	 edi
  00569	5e		 pop	 esi
  0056a	8b c3		 mov	 eax, ebx
  0056c	5b		 pop	 ebx

; 898  :    /* newState is used by both SPEECH AND DTX synthesis routines */ 
; 899  : }

  0056d	8b e5		 mov	 esp, ebp
  0056f	5d		 pop	 ebp
  00570	c3		 ret	 0
_rx_dtx_handler ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _dtx_dec_exit
_TEXT	SEGMENT
_dtx_dec_exit PROC					; COMDAT
; _st$ = ecx

; 192  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 193  :    if (st == NULL || *st == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@dtx_dec_ex
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@dtx_dec_ex

; 194  :       return;
; 195  :    
; 196  :    /* deallocate memory */
; 197  :    free(*st);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 198  :    *st = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@dtx_dec_ex:
  0001d	5e		 pop	 esi

; 199  :    
; 200  :    return;
; 201  : }

  0001e	c3		 ret	 0
_dtx_dec_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
;	COMDAT _dtx_dec_reset
_TEXT	SEGMENT
_st$1$ = -8						; size = 4
tv1059 = -4						; size = 4
_dtx_dec_reset PROC					; COMDAT
; _st$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	89 7d f8	 mov	 DWORD PTR _st$1$[ebp], edi

; 131  :    int i;
; 132  : 
; 133  :    if (st == (dtx_decState *) NULL){

  0000c	85 ff		 test	 edi, edi
  0000e	75 20		 jne	 SHORT $LN7@dtx_dec_re

; 134  :       fprintf(stderr, "dtx_dec_reset: invalid parameter\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@OPKPKAGI@dtx_dec_reset?3?5invalid?5parameter@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0001b	83 c0 40	 add	 eax, 64			; 00000040H
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00025	83 c4 08	 add	 esp, 8

; 135  :       return -1;

  00028	83 c8 ff	 or	 eax, -1
  0002b	5f		 pop	 edi

; 181  :    return 0;
; 182  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN7@dtx_dec_re:
  00030	53		 push	 ebx
  00031	56		 push	 esi

; 136  :    }
; 137  :    
; 138  :    st->since_last_sid = 0;

  00032	c7 07 00 00 00
	20		 mov	 DWORD PTR [edi], 536870912 ; 20000000H
  00038	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]

; 139  :    st->true_sid_period_inv = (1 << 13); 
; 140  :  
; 141  :    st->log_en = 3500;  

  0003b	c7 47 04 ac 0d
	ac 0d		 mov	 DWORD PTR [edi+4], 229379500 ; 0dac0dacH
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET _lsp_init_data

; 142  :    st->old_log_en = 3500;
; 143  :    /* low level noise for better performance in  DTX handover cases*/
; 144  :    
; 145  :    st->L_pn_seed_rx = PN_INITIAL_SEED;

  00047	c7 47 08 58 69
	81 70		 mov	 DWORD PTR [edi+8], 1887529304 ; 70816958H
  0004e	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$LL12@dtx_dec_re:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00053	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00056	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00059	66 89 02	 mov	 WORD PTR [edx], ax
  0005c	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  0005f	4e		 dec	 esi
  00060	75 f1		 jne	 SHORT $LL12@dtx_dec_re

; 60   :     for (i = 0; i < L; i++)

  00062	b9 00 00 00 00	 mov	 ecx, OFFSET _lsp_init_data
  00067	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  0006a	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  0006f	90		 npad	 1
$LL19@dtx_dec_re:

; 62   :         y[i] = x[i];            move16 (); 

  00070	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00073	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00076	66 89 02	 mov	 WORD PTR [edx], ax
  00079	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  0007c	4e		 dec	 esi
  0007d	75 f1		 jne	 SHORT $LL19@dtx_dec_re
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 151  :    st->lsf_hist_ptr = 0;

  0007f	33 c0		 xor	 eax, eax
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET _mean_lsf
  00086	66 89 87 d4 00
	00 00		 mov	 WORD PTR [edi+212], ax
  0008d	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH

; 152  :    st->log_pg_mean = 0;

  00092	66 89 87 76 01
	00 00		 mov	 WORD PTR [edi+374], ax

; 153  :    st->log_en_hist_ptr = 0;

  00099	66 89 87 88 01
	00 00		 mov	 WORD PTR [edi+392], ax
  000a0	8d 47 34	 lea	 eax, DWORD PTR [edi+52]
  000a3	89 45 fc	 mov	 DWORD PTR tv1059[ebp], eax
  000a6	8b d0		 mov	 edx, eax
  000a8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL26@dtx_dec_re:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  000b0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000b3	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  000b6	66 89 02	 mov	 WORD PTR [edx], ax
  000b9	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  000bc	4e		 dec	 esi
  000bd	75 f1		 jne	 SHORT $LL26@dtx_dec_re
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 158  :    for (i = 1; i < DTX_HIST_SIZE; i++)

  000bf	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  000c2	8b 7d fc	 mov	 edi, DWORD PTR tv1059[ebp]
  000c5	8d 5e 07	 lea	 ebx, DWORD PTR [esi+7]
  000c8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL6@dtx_dec_re:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  000d0	8b d7		 mov	 edx, edi
  000d2	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$LL33@dtx_dec_re:

; 62   :         y[i] = x[i];            move16 (); 

  000d7	66 8b 0a	 mov	 cx, WORD PTR [edx]
  000da	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  000dd	66 89 08	 mov	 WORD PTR [eax], cx
  000e0	83 c0 02	 add	 eax, 2
  000e3	4e		 dec	 esi
  000e4	75 f1		 jne	 SHORT $LL33@dtx_dec_re
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 158  :    for (i = 1; i < DTX_HIST_SIZE; i++)

  000e6	4b		 dec	 ebx
  000e7	75 e7		 jne	 SHORT $LL6@dtx_dec_re
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  000e9	8b 7d f8	 mov	 edi, DWORD PTR _st$1$[ebp]
  000ec	0f 57 c0	 xorps	 xmm0, xmm0
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	f3 0f 7f 87 d6
	00 00 00	 movdqu	 XMMWORD PTR [edi+214], xmm0
  000f9	f3 0f 7f 87 e6
	00 00 00	 movdqu	 XMMWORD PTR [edi+230], xmm0
  00101	f3 0f 7f 87 f6
	00 00 00	 movdqu	 XMMWORD PTR [edi+246], xmm0
  00109	f3 0f 7f 87 06
	01 00 00	 movdqu	 XMMWORD PTR [edi+262], xmm0
  00111	f3 0f 7f 87 16
	01 00 00	 movdqu	 XMMWORD PTR [edi+278], xmm0
  00119	f3 0f 7f 87 26
	01 00 00	 movdqu	 XMMWORD PTR [edi+294], xmm0
  00121	f3 0f 7f 87 36
	01 00 00	 movdqu	 XMMWORD PTR [edi+310], xmm0
  00129	f3 0f 7f 87 46
	01 00 00	 movdqu	 XMMWORD PTR [edi+326], xmm0
  00131	f3 0f 7f 87 56
	01 00 00	 movdqu	 XMMWORD PTR [edi+342], xmm0
  00139	f3 0f 7f 87 66
	01 00 00	 movdqu	 XMMWORD PTR [edi+358], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 167  :       st->log_en_hist[i] = st->log_en;

  00141	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00145	66 89 87 78 01
	00 00		 mov	 WORD PTR [edi+376], ax
  0014c	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00150	66 89 87 7a 01
	00 00		 mov	 WORD PTR [edi+378], ax
  00157	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0015b	66 89 87 7c 01
	00 00		 mov	 WORD PTR [edi+380], ax
  00162	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00166	66 89 87 7e 01
	00 00		 mov	 WORD PTR [edi+382], ax
  0016d	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00171	66 89 87 80 01
	00 00		 mov	 WORD PTR [edi+384], ax
  00178	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0017c	66 89 87 82 01
	00 00		 mov	 WORD PTR [edi+386], ax
  00183	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00187	66 89 87 84 01
	00 00		 mov	 WORD PTR [edi+388], ax
  0018e	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  00192	66 89 87 86 01
	00 00		 mov	 WORD PTR [edi+390], ax

; 168  :    }
; 169  : 
; 170  :    st->log_en_adjust = 0;
; 171  : 
; 172  :    st->dtxHangoverCount = DTX_HANG_CONST;
; 173  :    st->decAnaElapsedCount = 32767;   
; 174  : 
; 175  :    st->sid_frame = 0;       
; 176  :    st->valid_data = 0;             

  00199	33 c0		 xor	 eax, eax
  0019b	c7 87 8a 01 00
	00 00 00 07 00	 mov	 DWORD PTR [edi+394], 458752 ; 00070000H
  001a5	c7 87 8e 01 00
	00 ff 7f 00 00	 mov	 DWORD PTR [edi+398], 32767 ; 00007fffH
  001af	89 87 92 01 00
	00		 mov	 DWORD PTR [edi+402], eax

; 177  :    st->dtxHangoverAdded = 0; 
; 178  :   
; 179  :    st->dtxGlobalState = DTX;    

  001b5	c7 87 98 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+408], 1

; 180  :    st->data_updated = 0; 

  001bf	66 89 87 9c 01
	00 00		 mov	 WORD PTR [edi+412], ax
  001c6	5f		 pop	 edi

; 181  :    return 0;
; 182  : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
_dtx_dec_reset ENDP
_TEXT	ENDS
END
