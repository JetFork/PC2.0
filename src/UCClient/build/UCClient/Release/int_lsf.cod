; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\int_lsf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Int_lsf
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c
;	COMDAT _Int_lsf
_TEXT	SEGMENT
tv1082 = 8						; size = 4
tv1081 = 8						; size = 4
_i_subfr$ = 8						; size = 2
_lsf_out$ = 12						; size = 4
_Int_lsf PROC						; COMDAT
; _lsf_old$ = ecx
; _lsf_new$ = edx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 77   :     Word16 i;
; 78   : 
; 79   :     if ( i_subfr == 0 )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _i_subfr$[ebp]
  00009	8b f2		 mov	 esi, edx
  0000b	66 85 ff	 test	 di, di
  0000e	0f 85 d2 00 00
	00		 jne	 $LN19@Int_lsf

; 80   :     {
; 81   :        test ();          
; 82   :        for (i = 0; i < M; i++) {

  00014	8b 45 0c	 mov	 eax, DWORD PTR _lsf_out$[ebp]
  00017	2b f1		 sub	 esi, ecx
  00019	2b c1		 sub	 eax, ecx
  0001b	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  00020	89 45 08	 mov	 DWORD PTR tv1082[ebp], eax
$LL18@Int_lsf:

; 83   :           lsf_out[i] = add(sub(lsf_old[i], shr(lsf_old[i], 2)), shr(lsf_new[i], 2));

  00023	0f b7 04 0e	 movzx	 eax, WORD PTR [esi+ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00027	66 85 c0	 test	 ax, ax
  0002a	79 0a		 jns	 SHORT $LN25@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0002c	98		 cwde
  0002d	f7 d0		 not	 eax
  0002f	c1 f8 02	 sar	 eax, 2
  00032	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00034	eb 04		 jmp	 SHORT $LN190@Int_lsf
$LN25@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  00036	66 c1 f8 02	 sar	 ax, 2
$LN190@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 83   :           lsf_out[i] = add(sub(lsf_old[i], shr(lsf_old[i], 2)), shr(lsf_new[i], 2));

  0003a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  0003d	0f b7 f8	 movzx	 edi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 83   :           lsf_out[i] = add(sub(lsf_old[i], shr(lsf_old[i], 2)), shr(lsf_new[i], 2));

  00040	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00042	66 85 c0	 test	 ax, ax
  00045	79 0a		 jns	 SHORT $LN34@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00047	98		 cwde
  00048	f7 d0		 not	 eax
  0004a	c1 f8 02	 sar	 eax, 2
  0004d	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0004f	eb 04		 jmp	 SHORT $LN191@Int_lsf
$LN34@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  00051	66 c1 f8 02	 sar	 ax, 2
$LN191@Int_lsf:
  00055	0f b7 c0	 movzx	 eax, ax

; 186  :     L_diff = (Word32) var1 - var2;

  00058	0f bf d2	 movsx	 edx, dx
  0005b	98		 cwde
  0005c	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0005e	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00064	7e 11		 jle	 SHORT $LN47@Int_lsf

; 80   :     {
; 81   :         Overflow = 1;

  00066	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00070	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00075	eb 1c		 jmp	 SHORT $LN44@Int_lsf
$LN47@Int_lsf:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00077	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0007d	7d 11		 jge	 SHORT $LN45@Int_lsf

; 86   :         Overflow = 1;

  0007f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00089	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0008e	eb 03		 jmp	 SHORT $LN44@Int_lsf
$LN45@Int_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00090	0f b7 c2	 movzx	 eax, dx
$LN44@Int_lsf:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00093	0f bf d0	 movsx	 edx, ax
  00096	0f bf c7	 movsx	 eax, di
  00099	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0009b	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  000a1	7e 11		 jle	 SHORT $LN57@Int_lsf

; 80   :     {
; 81   :         Overflow = 1;

  000a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000ad	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000b2	eb 1c		 jmp	 SHORT $LN54@Int_lsf
$LN57@Int_lsf:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000b4	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  000ba	7d 11		 jge	 SHORT $LN55@Int_lsf

; 86   :         Overflow = 1;

  000bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000c6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000cb	eb 03		 jmp	 SHORT $LN54@Int_lsf
$LN55@Int_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000cd	0f b7 c2	 movzx	 eax, dx
$LN54@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 83   :           lsf_out[i] = add(sub(lsf_old[i], shr(lsf_old[i], 2)), shr(lsf_new[i], 2));

  000d0	8b 55 08	 mov	 edx, DWORD PTR tv1082[ebp]
  000d3	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  000d7	83 c1 02	 add	 ecx, 2
  000da	4b		 dec	 ebx
  000db	0f 85 42 ff ff
	ff		 jne	 $LL18@Int_lsf
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 108  :        }
; 109  :     }
; 110  : 
; 111  :     return;
; 112  : }

  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN19@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000e6	0f bf d7	 movsx	 edx, di
  000e9	8d 42 d8	 lea	 eax, DWORD PTR [edx-40]

; 79   :     if (L_var1 > 0X00007fffL)

  000ec	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000f1	0f 8f a7 00 00
	00		 jg	 $LN194@Int_lsf

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000f7	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000fc	0f 8c 9c 00 00
	00		 jl	 $LN194@Int_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 87   :     else if ( sub(i_subfr, 40) == 0 )

  00102	66 85 c0	 test	 ax, ax
  00105	0f 85 9d 00 00
	00		 jne	 $LN14@Int_lsf

; 88   :     {
; 89   :        test (); test ();
; 90   :        for (i = 0; i < M; i++) {

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _lsf_out$[ebp]
  0010e	2b f1		 sub	 esi, ecx
  00110	2b c1		 sub	 eax, ecx
  00112	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  00117	89 45 08	 mov	 DWORD PTR tv1081[ebp], eax
  0011a	8d 9b 00 00 00
	00		 npad	 6
$LL13@Int_lsf:

; 91   :           lsf_out[i] = add(shr(lsf_old[i],1), shr(lsf_new[i], 1) );

  00120	0f b7 04 31	 movzx	 eax, WORD PTR [ecx+esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00124	66 85 c0	 test	 ax, ax
  00127	79 09		 jns	 SHORT $LN79@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00129	98		 cwde
  0012a	f7 d0		 not	 eax
  0012c	d1 f8		 sar	 eax, 1
  0012e	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00130	eb 03		 jmp	 SHORT $LN192@Int_lsf
$LN79@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  00132	66 d1 f8	 sar	 ax, 1
$LN192@Int_lsf:
  00135	0f b7 f8	 movzx	 edi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 91   :           lsf_out[i] = add(shr(lsf_old[i],1), shr(lsf_new[i], 1) );

  00138	0f b7 01	 movzx	 eax, WORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0013b	66 85 c0	 test	 ax, ax
  0013e	79 09		 jns	 SHORT $LN88@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00140	98		 cwde
  00141	f7 d0		 not	 eax
  00143	d1 f8		 sar	 eax, 1
  00145	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00147	eb 03		 jmp	 SHORT $LN193@Int_lsf
$LN88@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  00149	66 d1 f8	 sar	 ax, 1
$LN193@Int_lsf:
  0014c	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0014f	0f bf d0	 movsx	 edx, ax
  00152	0f bf c7	 movsx	 eax, di
  00155	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00157	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  0015d	7e 11		 jle	 SHORT $LN101@Int_lsf

; 80   :     {
; 81   :         Overflow = 1;

  0015f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00169	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0016e	eb 1c		 jmp	 SHORT $LN98@Int_lsf
$LN101@Int_lsf:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00170	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00176	7d 11		 jge	 SHORT $LN99@Int_lsf

; 86   :         Overflow = 1;

  00178	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00182	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00187	eb 03		 jmp	 SHORT $LN98@Int_lsf
$LN99@Int_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00189	0f b7 c2	 movzx	 eax, dx
$LN98@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 91   :           lsf_out[i] = add(shr(lsf_old[i],1), shr(lsf_new[i], 1) );

  0018c	8b 55 08	 mov	 edx, DWORD PTR tv1081[ebp]
  0018f	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  00193	83 c1 02	 add	 ecx, 2
  00196	4b		 dec	 ebx
  00197	75 87		 jne	 SHORT $LL13@Int_lsf
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx

; 108  :        }
; 109  :     }
; 110  : 
; 111  :     return;
; 112  : }

  0019c	5d		 pop	 ebp
  0019d	c3		 ret	 0
$LN194@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  0019e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN14@Int_lsf:

; 186  :     L_diff = (Word32) var1 - var2;

  001a8	8d 42 b0	 lea	 eax, DWORD PTR [edx-80]

; 79   :     if (L_var1 > 0X00007fffL)

  001ab	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001b0	0f 8f de 00 00
	00		 jg	 $LN197@Int_lsf

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001bb	0f 8c d3 00 00
	00		 jl	 $LN197@Int_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 95   :     else if ( sub(i_subfr, 80) == 0 )

  001c1	66 85 c0	 test	 ax, ax
  001c4	0f 85 d4 00 00
	00		 jne	 $LN9@Int_lsf

; 96   :     {
; 97   :        test (); test (); test ();
; 98   :        for (i = 0; i < M; i++) {

  001ca	8b 5d 0c	 mov	 ebx, DWORD PTR _lsf_out$[ebp]
  001cd	2b ce		 sub	 ecx, esi
  001cf	2b de		 sub	 ebx, esi
  001d1	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL8@Int_lsf:

; 99   :           lsf_out[i] = add(shr(lsf_old[i], 2), sub(lsf_new[i], shr(lsf_new[i], 2)));

  001d6	0f b7 16	 movzx	 edx, WORD PTR [esi]
  001d9	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  001db	66 85 c0	 test	 ax, ax
  001de	79 0a		 jns	 SHORT $LN125@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001e0	98		 cwde
  001e1	f7 d0		 not	 eax
  001e3	c1 f8 02	 sar	 eax, 2
  001e6	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  001e8	eb 04		 jmp	 SHORT $LN195@Int_lsf
$LN125@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  001ea	66 c1 f8 02	 sar	 ax, 2
$LN195@Int_lsf:
  001ee	0f b7 c0	 movzx	 eax, ax

; 186  :     L_diff = (Word32) var1 - var2;

  001f1	98		 cwde
  001f2	0f bf d2	 movsx	 edx, dx
  001f5	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001f7	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  001fd	7e 11		 jle	 SHORT $LN138@Int_lsf

; 80   :     {
; 81   :         Overflow = 1;

  001ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00209	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  0020e	eb 1c		 jmp	 SHORT $LN135@Int_lsf
$LN138@Int_lsf:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00210	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00216	7d 11		 jge	 SHORT $LN136@Int_lsf

; 86   :         Overflow = 1;

  00218	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00222	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00227	eb 03		 jmp	 SHORT $LN135@Int_lsf
$LN136@Int_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00229	0f b7 d2	 movzx	 edx, dx
$LN135@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 99   :           lsf_out[i] = add(shr(lsf_old[i], 2), sub(lsf_new[i], shr(lsf_new[i], 2)));

  0022c	0f b7 04 31	 movzx	 eax, WORD PTR [ecx+esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00230	66 85 c0	 test	 ax, ax
  00233	79 0a		 jns	 SHORT $LN144@Int_lsf

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00235	98		 cwde
  00236	f7 d0		 not	 eax
  00238	c1 f8 02	 sar	 eax, 2
  0023b	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0023d	eb 04		 jmp	 SHORT $LN196@Int_lsf
$LN144@Int_lsf:

; 381  :                 var_out = var1 >> var2;

  0023f	66 c1 f8 02	 sar	 ax, 2
$LN196@Int_lsf:
  00243	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00246	0f bf d2	 movsx	 edx, dx
  00249	98		 cwde
  0024a	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0024c	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00252	7e 11		 jle	 SHORT $LN157@Int_lsf

; 80   :     {
; 81   :         Overflow = 1;

  00254	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0025e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00263	eb 1c		 jmp	 SHORT $LN154@Int_lsf
$LN157@Int_lsf:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00265	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0026b	7d 11		 jge	 SHORT $LN155@Int_lsf

; 86   :         Overflow = 1;

  0026d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00277	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0027c	eb 03		 jmp	 SHORT $LN154@Int_lsf
$LN155@Int_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0027e	0f b7 c2	 movzx	 eax, dx
$LN154@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 99   :           lsf_out[i] = add(shr(lsf_old[i], 2), sub(lsf_new[i], shr(lsf_new[i], 2)));

  00281	66 89 04 33	 mov	 WORD PTR [ebx+esi], ax
  00285	83 c6 02	 add	 esi, 2
  00288	4f		 dec	 edi
  00289	0f 85 47 ff ff
	ff		 jne	 $LL8@Int_lsf
  0028f	5f		 pop	 edi
  00290	5e		 pop	 esi
  00291	5b		 pop	 ebx

; 108  :        }
; 109  :     }
; 110  : 
; 111  :     return;
; 112  : }

  00292	5d		 pop	 ebp
  00293	c3		 ret	 0
$LN197@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00294	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN9@Int_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lsf.c

; 103  :     else if ( sub(i_subfr, 120) == 0 )

  0029e	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  002a3	8b cf		 mov	 ecx, edi
  002a5	e8 00 00 00 00	 call	 _sub
  002aa	66 85 c0	 test	 ax, ax
  002ad	75 11		 jne	 SHORT $LN3@Int_lsf

; 104  :     {
; 105  :        test (); test (); test (); test ();                    
; 106  :        for (i = 0; i < M; i++) {
; 107  :           lsf_out[i] = lsf_new[i];                        move16 ();

  002af	8b 4d 0c	 mov	 ecx, DWORD PTR _lsf_out$[ebp]
  002b2	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  002b6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  002b9	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  002bd	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN3@Int_lsf:
  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi
  002c2	5b		 pop	 ebx

; 108  :        }
; 109  :     }
; 110  : 
; 111  :     return;
; 112  : }

  002c3	5d		 pop	 ebp
  002c4	c3		 ret	 0
_Int_lsf ENDP
_TEXT	ENDS
END
