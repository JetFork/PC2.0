; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d8_31pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_dec_8i40_31bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _dec_8i40_31bits
_TEXT	SEGMENT
_cod$GSCopy$1$ = -36					; size = 4
tv694 = -32						; size = 4
_linear_codewords$ = -28				; size = 16
_linear_signs$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_dec_8i40_31bits PROC					; COMDAT
; _index$ = ecx
; _cod$ = edx

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b fa		 mov	 edi, edx

; 178  :     Word16 i, j, pos1, pos2, sign;
; 179  :     Word16 linear_signs[NB_TRACK_MR102];
; 180  :     Word16 linear_codewords[NB_PULSE];
; 181  :     
; 182  :     for (i = 0; i < L_CODE; i++)
; 183  :     {
; 184  :         cod[i] = 0;                                    move16 (); 
; 185  :     }
; 186  :     
; 187  :     decompress_code (index, linear_signs, linear_codewords);

  00015	8d 45 e4	 lea	 eax, DWORD PTR _linear_codewords$[ebp]
  00018	0f 57 c0	 xorps	 xmm0, xmm0
  0001b	89 7d dc	 mov	 DWORD PTR _cod$GSCopy$1$[ebp], edi
  0001e	50		 push	 eax
  0001f	8d 55 f4	 lea	 edx, DWORD PTR _linear_signs$[ebp]
  00022	f3 0f 7f 07	 movdqu	 XMMWORD PTR [edi], xmm0
  00026	f3 0f 7f 47 10	 movdqu	 XMMWORD PTR [edi+16], xmm0
  0002b	f3 0f 7f 47 20	 movdqu	 XMMWORD PTR [edi+32], xmm0
  00030	f3 0f 7f 47 30	 movdqu	 XMMWORD PTR [edi+48], xmm0
  00035	f3 0f 7f 47 40	 movdqu	 XMMWORD PTR [edi+64], xmm0
  0003a	e8 00 00 00 00	 call	 _decompress_code
  0003f	ba 04 00 00 00	 mov	 edx, 4
  00044	83 c4 04	 add	 esp, 4

; 188  :     
; 189  :     /* decode the positions and signs of pulses and build the codeword */
; 190  : 
; 191  :     for (j = 0; j < NB_TRACK_MR102; j++)

  00047	33 db		 xor	 ebx, ebx
  00049	89 55 e0	 mov	 DWORD PTR tv694[ebp], edx
  0004c	bf ff 1f 00 00	 mov	 edi, 8191		; 00001fffH
$LL6@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00051	0f bf 44 1d e4	 movsx	 eax, WORD PTR _linear_codewords$[ebp+ebx]
  00056	c1 e0 02	 shl	 eax, 2

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00059	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0005e	74 0c		 je	 SHORT $LN15@dec_8i40_3

; 488  :     {
; 489  :         L_var_out *= 2;

  00060	03 c0		 add	 eax, eax

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  00062	79 17		 jns	 SHORT $LN19@dec_8i40_3

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00064	f7 d0		 not	 eax
  00066	d1 f8		 sar	 eax, 1
  00068	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  0006a	eb 11		 jmp	 SHORT $LN18@dec_8i40_3
$LN15@dec_8i40_3:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  0006c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00076	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN19@dec_8i40_3:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0007b	d1 f8		 sar	 eax, 1
$LN18@dec_8i40_3:

; 139  :     L_sum = (Word32) var1 + var2;

  0007d	8d 72 fc	 lea	 esi, DWORD PTR [edx-4]
  00080	98		 cwde
  00081	03 c6		 add	 eax, esi

; 79   :     if (L_var1 > 0X00007fffL)

  00083	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00088	7e 11		 jle	 SHORT $LN45@dec_8i40_3

; 80   :     {
; 81   :         Overflow = 1;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00094	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00099	eb 1b		 jmp	 SHORT $LN42@dec_8i40_3
$LN45@dec_8i40_3:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0009b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000a0	7d 11		 jge	 SHORT $LN43@dec_8i40_3

; 85   :     {
; 86   :         Overflow = 1;

  000a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000ac	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000b1	eb 03		 jmp	 SHORT $LN42@dec_8i40_3
$LN43@dec_8i40_3:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000b3	0f b7 c0	 movzx	 eax, ax
$LN42@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 200  :        if (linear_signs[j] == 0)

  000b6	66 83 7c 1d f4
	00		 cmp	 WORD PTR _linear_signs$[ebp+ebx], 0
  000bc	b9 01 e0 ff ff	 mov	 ecx, -8191		; ffffe001H
  000c1	0f 44 cf	 cmove	 ecx, edi

; 201  :        {
; 202  :           sign = POS_CODE;                             move16 (); /* +1.0 */
; 203  :        }
; 204  :        else
; 205  :        {
; 206  :           sign = -NEG_CODE;                            move16 (); /* -1.0 */
; 207  :        }
; 208  :        
; 209  :        cod[pos1] = sign;                               move16 (); 

  000c4	0f bf f8	 movsx	 edi, ax
  000c7	8b 45 dc	 mov	 eax, DWORD PTR _cod$GSCopy$1$[ebp]
  000ca	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  000ce	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  000d4	7e 11		 jle	 SHORT $LN63@dec_8i40_3

; 80   :     {
; 81   :         Overflow = 1;

  000d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000e0	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000e5	eb 1c		 jmp	 SHORT $LN60@dec_8i40_3
$LN63@dec_8i40_3:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000e7	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  000ed	7d 11		 jge	 SHORT $LN61@dec_8i40_3

; 85   :     {
; 86   :         Overflow = 1;

  000ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000f9	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000fe	eb 03		 jmp	 SHORT $LN60@dec_8i40_3
$LN61@dec_8i40_3:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00100	0f b7 c2	 movzx	 eax, dx
$LN60@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 213  :        i = linear_codewords[add (j, 4)];        

  00103	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00104	0f bf 44 45 e4	 movsx	 eax, WORD PTR _linear_codewords$[ebp+eax*2]
  00109	c1 e0 02	 shl	 eax, 2

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0010c	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00111	74 0c		 je	 SHORT $LN69@dec_8i40_3

; 488  :     {
; 489  :         L_var_out *= 2;

  00113	03 c0		 add	 eax, eax

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  00115	79 17		 jns	 SHORT $LN73@dec_8i40_3

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00117	f7 d0		 not	 eax
  00119	d1 f8		 sar	 eax, 1
  0011b	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  0011d	eb 11		 jmp	 SHORT $LN72@dec_8i40_3
$LN69@dec_8i40_3:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  0011f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00129	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN73@dec_8i40_3:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0012e	d1 f8		 sar	 eax, 1
$LN72@dec_8i40_3:

; 139  :     L_sum = (Word32) var1 + var2;

  00130	98		 cwde
  00131	03 c6		 add	 eax, esi

; 79   :     if (L_var1 > 0X00007fffL)

  00133	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00138	7e 11		 jle	 SHORT $LN99@dec_8i40_3

; 80   :     {
; 81   :         Overflow = 1;

  0013a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00144	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00149	eb 1b		 jmp	 SHORT $LN96@dec_8i40_3
$LN99@dec_8i40_3:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0014b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00150	7d 11		 jge	 SHORT $LN97@dec_8i40_3

; 85   :     {
; 86   :         Overflow = 1;

  00152	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0015c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00161	eb 03		 jmp	 SHORT $LN96@dec_8i40_3
$LN97@dec_8i40_3:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00163	0f b7 c0	 movzx	 eax, ax
$LN96@dec_8i40_3:

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00166	0f bf f0	 movsx	 esi, ax
  00169	8b c6		 mov	 eax, esi
  0016b	2b c7		 sub	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  0016d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00172	7e 0c		 jle	 SHORT $LN111@dec_8i40_3

; 80   :     {
; 81   :         Overflow = 1;

  00174	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0017e	eb 31		 jmp	 SHORT $LN1@dec_8i40_3
$LN111@dec_8i40_3:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00180	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00185	7d 0c		 jge	 SHORT $LN109@dec_8i40_3

; 85   :     {
; 86   :         Overflow = 1;

  00187	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00191	eb 05		 jmp	 SHORT $LN152@dec_8i40_3
$LN109@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 218  :        if (sub (pos2, pos1) < 0)

  00193	66 85 c0	 test	 ax, ax
  00196	79 19		 jns	 SHORT $LN1@dec_8i40_3
$LN152@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  00198	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0019d	66 3b c8	 cmp	 cx, ax
  001a0	75 07		 jne	 SHORT $LN118@dec_8i40_3
  001a2	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001a7	eb 05		 jmp	 SHORT $LN119@dec_8i40_3
$LN118@dec_8i40_3:
  001a9	f7 d9		 neg	 ecx
  001ab	0f b7 c1	 movzx	 eax, cx
$LN119@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 220  :           sign = negate (sign);

  001ae	0f b7 c8	 movzx	 ecx, ax
$LN1@dec_8i40_3:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  001b1	8b 7d dc	 mov	 edi, DWORD PTR _cod$GSCopy$1$[ebp]
  001b4	0f bf c9	 movsx	 ecx, cx
  001b7	0f bf 04 77	 movsx	 eax, WORD PTR [edi+esi*2]
  001bb	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001bd	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  001c3	7e 11		 jle	 SHORT $LN125@dec_8i40_3

; 80   :     {
; 81   :         Overflow = 1;

  001c5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001cf	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001d4	eb 1c		 jmp	 SHORT $LN122@dec_8i40_3
$LN125@dec_8i40_3:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001d6	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  001dc	7d 11		 jge	 SHORT $LN123@dec_8i40_3

; 85   :     {
; 86   :         Overflow = 1;

  001de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001e8	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001ed	eb 03		 jmp	 SHORT $LN122@dec_8i40_3
$LN123@dec_8i40_3:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  001ef	0f b7 c1	 movzx	 eax, cx
$LN122@dec_8i40_3:
  001f2	83 c3 02	 add	 ebx, 2
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 222  :        cod[pos2] = add (cod[pos2], sign);              move16 (); 

  001f5	66 89 04 77	 mov	 WORD PTR [edi+esi*2], ax
  001f9	42		 inc	 edx
  001fa	bf ff 1f 00 00	 mov	 edi, 8191		; 00001fffH
  001ff	ff 4d e0	 dec	 DWORD PTR tv694[ebp]
  00202	0f 85 49 fe ff
	ff		 jne	 $LL6@dec_8i40_3

; 223  :     }
; 224  :     
; 225  :     return;
; 226  : }

  00208	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi
  0020d	33 cd		 xor	 ecx, ebp
  0020f	5b		 pop	 ebx
  00210	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
_dec_8i40_31bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _decompress10
_TEXT	SEGMENT
tv1029 = -12						; size = 4
_L_product$1$ = -8					; size = 4
_LSBs$1$ = -2						; size = 2
_index1$ = 8						; size = 2
_index2$ = 12						; size = 2
_index3$ = 16						; size = 2
_pos_indx$ = 20						; size = 4
_decompress10 PROC					; COMDAT
; _MSBs$ = ecx
; _LSBs$ = dx

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00006	0f bf c1	 movsx	 eax, cx
  00009	53		 push	 ebx
  0000a	83 e8 7c	 sub	 eax, 124		; 0000007cH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 52   : {

  0000d	66 8b da	 mov	 bx, dx
  00010	66 89 5d fe	 mov	 WORD PTR _LSBs$1$[ebp], bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00014	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00019	7e 0c		 jle	 SHORT $LN11@decompress

; 81   :         Overflow = 1;

  0001b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00025	eb 18		 jmp	 SHORT $LN225@decompress
$LN11@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00027	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0002c	7d 0c		 jge	 SHORT $LN9@decompress

; 86   :         Overflow = 1;

  0002e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00038	eb 0a		 jmp	 SHORT $LN16@decompress
$LN9@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 62   :    if (sub(MSBs, 124) > 0)

  0003a	66 85 c0	 test	 ax, ax
  0003d	7e 05		 jle	 SHORT $LN16@decompress
$LN225@decompress:

; 63   :    {
; 64   :       MSBs = 124;                                              move16 (); 

  0003f	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
$LN16@decompress:
  00044	56		 push	 esi
  00045	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00046	0f bf c9	 movsx	 ecx, cx
  00049	69 f9 1f 05 00
	00		 imul	 edi, ecx, 1311

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0004f	c1 ff 0f	 sar	 edi, 15			; 0000000fH
  00052	8b c7		 mov	 eax, edi
  00054	89 7d f8	 mov	 DWORD PTR _L_product$1$[ebp], edi

; 436  :     if (L_product & (Word32) 0x00010000L)

  00057	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0005c	74 05		 je	 SHORT $LN18@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0005e	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN18@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  00063	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00068	7e 11		 jle	 SHORT $LN24@decompress

; 81   :         Overflow = 1;

  0006a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00074	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00079	eb 1b		 jmp	 SHORT $LN21@decompress
$LN24@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0007b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00080	7d 11		 jge	 SHORT $LN22@decompress

; 86   :         Overflow = 1;

  00082	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0008c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00091	eb 03		 jmp	 SHORT $LN21@decompress
$LN22@decompress:

; 91   :         var_out = extract_l (L_var1);

  00093	0f b7 c0	 movzx	 eax, ax
$LN21@decompress:

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00096	98		 cwde
  00097	6b c0 19	 imul	 eax, eax, 25

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0009a	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0009f	74 0c		 je	 SHORT $LN30@decompress

; 488  :     {
; 489  :         L_var_out *= 2;

  000a1	03 c0		 add	 eax, eax

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  000a3	79 17		 jns	 SHORT $LN34@decompress

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  000a5	f7 d0		 not	 eax
  000a7	d1 f8		 sar	 eax, 1
  000a9	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  000ab	eb 11		 jmp	 SHORT $LN33@decompress
$LN30@decompress:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  000ad	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000b7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN34@decompress:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  000bc	d1 f8		 sar	 eax, 1
$LN33@decompress:

; 186  :     L_diff = (Word32) var1 - var2;

  000be	98		 cwde
  000bf	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  000c1	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  000c7	7e 11		 jle	 SHORT $LN49@decompress

; 81   :         Overflow = 1;

  000c9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000d3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000d8	eb 1c		 jmp	 SHORT $LN46@decompress
$LN49@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000da	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  000e0	7d 11		 jge	 SHORT $LN47@decompress

; 86   :         Overflow = 1;

  000e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000ec	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000f1	eb 03		 jmp	 SHORT $LN46@decompress
$LN47@decompress:

; 91   :         var_out = extract_l (L_var1);

  000f3	0f b7 c1	 movzx	 eax, cx
$LN46@decompress:

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  000f6	0f bf c8	 movsx	 ecx, ax
  000f9	69 d1 9a 19 00
	00		 imul	 edx, ecx, 6554

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  000ff	c1 fa 0f	 sar	 edx, 15			; 0000000fH
  00102	8b c2		 mov	 eax, edx

; 436  :     if (L_product & (Word32) 0x00010000L)

  00104	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00109	74 05		 je	 SHORT $LN54@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0010b	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN54@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  00110	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00115	7e 11		 jle	 SHORT $LN60@decompress

; 81   :         Overflow = 1;

  00117	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00121	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00126	eb 1b		 jmp	 SHORT $LN57@decompress
$LN60@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00128	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0012d	7d 11		 jge	 SHORT $LN58@decompress

; 86   :         Overflow = 1;

  0012f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00139	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0013e	eb 03		 jmp	 SHORT $LN57@decompress
$LN58@decompress:

; 91   :         var_out = extract_l (L_var1);

  00140	0f b7 c0	 movzx	 eax, ax
$LN57@decompress:

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00143	98		 cwde
  00144	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00147	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0014c	74 0c		 je	 SHORT $LN66@decompress

; 488  :     {
; 489  :         L_var_out *= 2;

  0014e	03 c0		 add	 eax, eax

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  00150	79 17		 jns	 SHORT $LN70@decompress

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00152	f7 d0		 not	 eax
  00154	d1 f8		 sar	 eax, 1
  00156	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  00158	eb 11		 jmp	 SHORT $LN69@decompress
$LN66@decompress:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  0015a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00164	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN70@decompress:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00169	d1 f8		 sar	 eax, 1
$LN69@decompress:

; 186  :     L_diff = (Word32) var1 - var2;

  0016b	98		 cwde
  0016c	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0016e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00174	7e 11		 jle	 SHORT $LN85@decompress

; 81   :         Overflow = 1;

  00176	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00180	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00185	eb 1c		 jmp	 SHORT $LN82@decompress
$LN85@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00187	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0018d	7d 11		 jge	 SHORT $LN83@decompress

; 86   :         Overflow = 1;

  0018f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00199	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0019e	eb 03		 jmp	 SHORT $LN82@decompress
$LN83@decompress:

; 91   :         var_out = extract_l (L_var1);

  001a0	0f b7 c9	 movzx	 ecx, cx
$LN82@decompress:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  001a3	0f bf f1	 movsx	 esi, cx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  001a6	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  001ab	03 f6		 add	 esi, esi
  001ad	0f bf c6	 movsx	 eax, si
  001b0	3b f0		 cmp	 esi, eax
  001b2	74 1a		 je	 SHORT $LN93@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  001b4	66 85 c9	 test	 cx, cx
  001b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001c1	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001c6	0f 4f c7	 cmovg	 eax, edi
  001c9	0f b7 f8	 movzx	 edi, ax

; 304  :         }
; 305  :         else

  001cc	eb 03		 jmp	 SHORT $LN90@decompress
$LN93@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  001ce	0f b7 fe	 movzx	 edi, si
$LN90@decompress:

; 375  :             if (var1 < 0)

  001d1	66 85 db	 test	 bx, bx
  001d4	79 0c		 jns	 SHORT $LN102@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001d6	0f bf c3	 movsx	 eax, bx
  001d9	f7 d0		 not	 eax
  001db	c1 f8 02	 sar	 eax, 2
  001de	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  001e0	eb 07		 jmp	 SHORT $LN226@decompress
$LN102@decompress:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  001e2	66 8b c3	 mov	 ax, bx
  001e5	66 c1 f8 02	 sar	 ax, 2
$LN226@decompress:
  001e9	0f b7 f0	 movzx	 esi, ax

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  001ec	0f bf ce	 movsx	 ecx, si
  001ef	c1 e1 02	 shl	 ecx, 2

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  001f2	0f bf c1	 movsx	 eax, cx
  001f5	3b c8		 cmp	 ecx, eax
  001f7	74 1f		 je	 SHORT $LN113@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  001f9	66 85 f6	 test	 si, si
  001fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00206	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0020b	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00210	0f 4f c1	 cmovg	 eax, ecx
  00213	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00216	eb 03		 jmp	 SHORT $LN110@decompress
$LN113@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00218	0f b7 c1	 movzx	 eax, cx
$LN110@decompress:

; 186  :     L_diff = (Word32) var1 - var2;

  0021b	0f bf cb	 movsx	 ecx, bx
  0021e	98		 cwde
  0021f	8b f1		 mov	 esi, ecx
  00221	2b f0		 sub	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00223	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00229	7e 11		 jle	 SHORT $LN126@decompress

; 81   :         Overflow = 1;

  0022b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00235	bb ff 7f 00 00	 mov	 ebx, 32767		; 00007fffH
  0023a	eb 1c		 jmp	 SHORT $LN123@decompress
$LN126@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0023c	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00242	7d 11		 jge	 SHORT $LN124@decompress

; 86   :         Overflow = 1;

  00244	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0024e	bb 00 80 ff ff	 mov	 ebx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00253	eb 03		 jmp	 SHORT $LN123@decompress
$LN124@decompress:

; 91   :         var_out = extract_l (L_var1);

  00255	0f b7 de	 movzx	 ebx, si
$LN123@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  00258	0f bf f3	 movsx	 esi, bx
  0025b	89 75 f4	 mov	 DWORD PTR tv1029[ebp], esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 73   :    pos_indx[index1] = add(ib, (ic & 1));                        logic16 ();

  0025e	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00261	0f bf c7	 movsx	 eax, di
  00264	03 f0		 add	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00266	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  0026c	7e 11		 jle	 SHORT $LN136@decompress

; 81   :         Overflow = 1;

  0026e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00278	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  0027d	eb 1c		 jmp	 SHORT $LN133@decompress
$LN136@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0027f	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00285	7d 11		 jge	 SHORT $LN134@decompress

; 86   :         Overflow = 1;

  00287	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00291	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00296	eb 03		 jmp	 SHORT $LN133@decompress
$LN134@decompress:

; 91   :         var_out = extract_l (L_var1);

  00298	0f b7 f6	 movzx	 esi, si
$LN133@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 73   :    pos_indx[index1] = add(ib, (ic & 1));                        logic16 ();

  0029b	8b 45 08	 mov	 eax, DWORD PTR _index1$[ebp]
  0029e	8b 7d 14	 mov	 edi, DWORD PTR _pos_indx$[ebp]
  002a1	98		 cwde
  002a2	66 89 34 47	 mov	 WORD PTR [edi+eax*2], si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 436  :     if (L_product & (Word32) 0x00010000L)

  002a6	8b 7d f8	 mov	 edi, DWORD PTR _L_product$1$[ebp]
  002a9	f7 c2 00 00 01
	00		 test	 edx, 65536		; 00010000H
  002af	74 06		 je	 SHORT $LN143@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  002b1	81 ca 00 00 ff
	ff		 or	 edx, -65536		; ffff0000H
$LN143@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  002b7	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  002bd	7e 11		 jle	 SHORT $LN149@decompress

; 81   :         Overflow = 1;

  002bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002c9	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  002ce	eb 1c		 jmp	 SHORT $LN146@decompress
$LN149@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002d0	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  002d6	7d 11		 jge	 SHORT $LN147@decompress

; 86   :         Overflow = 1;

  002d8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002e2	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002e7	eb 03		 jmp	 SHORT $LN146@decompress
$LN147@decompress:

; 91   :         var_out = extract_l (L_var1);

  002e9	0f b7 d2	 movzx	 edx, dx
$LN146@decompress:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  002ec	0f bf f2	 movsx	 esi, dx
  002ef	03 f6		 add	 esi, esi

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  002f1	0f bf c6	 movsx	 eax, si
  002f4	3b f0		 cmp	 esi, eax
  002f6	74 1f		 je	 SHORT $LN157@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  002f8	66 85 d2	 test	 dx, dx
  002fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00305	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0030a	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  0030f	0f 4f c2	 cmovg	 eax, edx
  00312	0f b7 f0	 movzx	 esi, ax

; 304  :         }
; 305  :         else

  00315	eb 03		 jmp	 SHORT $LN154@decompress
$LN157@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00317	0f b7 f6	 movzx	 esi, si
$LN154@decompress:

; 375  :             if (var1 < 0)

  0031a	66 85 db	 test	 bx, bx
  0031d	79 0e		 jns	 SHORT $LN166@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0031f	8b 45 f4	 mov	 eax, DWORD PTR tv1029[ebp]
  00322	f7 d0		 not	 eax
  00324	d1 f8		 sar	 eax, 1
  00326	f7 d0		 not	 eax
  00328	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  0032b	eb 06		 jmp	 SHORT $LN165@decompress
$LN166@decompress:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0032d	66 d1 fb	 sar	 bx, 1
  00330	0f b7 c3	 movzx	 eax, bx
$LN165@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  00333	0f bf d0	 movsx	 edx, ax
  00336	0f bf c6	 movsx	 eax, si
  00339	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0033b	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00341	7e 11		 jle	 SHORT $LN179@decompress

; 81   :         Overflow = 1;

  00343	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0034d	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00352	eb 1c		 jmp	 SHORT $LN176@decompress
$LN179@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00354	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0035a	7d 11		 jge	 SHORT $LN177@decompress

; 86   :         Overflow = 1;

  0035c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00366	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0036b	eb 03		 jmp	 SHORT $LN176@decompress
$LN177@decompress:

; 91   :         var_out = extract_l (L_var1);

  0036d	0f b7 d2	 movzx	 edx, dx
$LN176@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 76   :    pos_indx[index2] = add(ib, shr(ic, 1));

  00370	8b 45 0c	 mov	 eax, DWORD PTR _index2$[ebp]
  00373	8b 5d 14	 mov	 ebx, DWORD PTR _pos_indx$[ebp]
  00376	98		 cwde
  00377	66 89 14 43	 mov	 WORD PTR [ebx+eax*2], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0037b	66 8b 45 fe	 mov	 ax, WORD PTR _LSBs$1$[ebp]
  0037f	66 85 c0	 test	 ax, ax
  00382	79 0c		 jns	 SHORT $LN185@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00384	f7 d1		 not	 ecx
  00386	c1 f9 02	 sar	 ecx, 2
  00389	f7 d1		 not	 ecx
  0038b	0f b7 f1	 movzx	 esi, cx

; 378  :             }
; 379  :             else

  0038e	eb 07		 jmp	 SHORT $LN184@decompress
$LN185@decompress:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00390	66 c1 f8 02	 sar	 ax, 2
  00394	0f b7 f0	 movzx	 esi, ax
$LN184@decompress:

; 436  :     if (L_product & (Word32) 0x00010000L)

  00397	f7 c7 00 00 01
	00		 test	 edi, 65536		; 00010000H
  0039d	74 06		 je	 SHORT $LN193@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0039f	81 cf 00 00 ff
	ff		 or	 edi, -65536		; ffff0000H
$LN193@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  003a5	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  003ab	7e 11		 jle	 SHORT $LN199@decompress

; 81   :         Overflow = 1;

  003ad	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003b7	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  003bc	eb 1c		 jmp	 SHORT $LN196@decompress
$LN199@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003be	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  003c4	7d 11		 jge	 SHORT $LN197@decompress

; 86   :         Overflow = 1;

  003c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  003d0	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  003d5	eb 03		 jmp	 SHORT $LN196@decompress
$LN197@decompress:

; 91   :         var_out = extract_l (L_var1);

  003d7	0f b7 d7	 movzx	 edx, di
$LN196@decompress:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  003da	0f bf ca	 movsx	 ecx, dx
  003dd	03 c9		 add	 ecx, ecx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  003df	0f bf c1	 movsx	 eax, cx
  003e2	3b c8		 cmp	 ecx, eax
  003e4	74 1f		 je	 SHORT $LN207@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  003e6	66 85 d2	 test	 dx, dx
  003e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  003f3	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  003f8	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  003fd	0f 4f c1	 cmovg	 eax, ecx
  00400	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00403	eb 03		 jmp	 SHORT $LN204@decompress
$LN207@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00405	0f b7 c1	 movzx	 eax, cx
$LN204@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  00408	0f bf c8	 movsx	 ecx, ax
  0040b	0f bf c6	 movsx	 eax, si
  0040e	03 c8		 add	 ecx, eax
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi

; 79   :     if (L_var1 > 0X00007fffL)

  00412	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00418	7e 1c		 jle	 SHORT $LN220@decompress
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  0041a	8b 45 10	 mov	 eax, DWORD PTR _index3$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 82   :         var_out = MAX_16;

  0041d	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  00422	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  00423	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  0042d	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx
  00431	5b		 pop	 ebx

; 79   : 
; 80   :    return;
; 81   : }    

  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c3		 ret	 0
$LN220@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00436	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0043c	7d 1c		 jge	 SHORT $LN218@decompress
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  0043e	8b 45 10	 mov	 eax, DWORD PTR _index3$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 87   :         var_out = MIN_16;

  00441	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  00446	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00447	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  00451	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx
  00455	5b		 pop	 ebx

; 79   : 
; 80   :    return;
; 81   : }    

  00456	8b e5		 mov	 esp, ebp
  00458	5d		 pop	 ebp
  00459	c3		 ret	 0
$LN218@decompress:

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  0045a	8b 45 10	 mov	 eax, DWORD PTR _index3$[ebp]
  0045d	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  0045e	0f b7 c9	 movzx	 ecx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 78   :    pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    

  00461	66 89 0c 43	 mov	 WORD PTR [ebx+eax*2], cx
  00465	5b		 pop	 ebx

; 79   : 
; 80   :    return;
; 81   : }    

  00466	8b e5		 mov	 esp, ebp
  00468	5d		 pop	 ebp
  00469	c3		 ret	 0
_decompress10 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c
;	COMDAT _decompress_code
_TEXT	SEGMENT
_pos_indx$ = 8						; size = 4
_decompress_code PROC					; COMDAT
; _indx$ = ecx
; _sign_indx$ = edx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 102  :     Word16 i, ia, ib, MSBs, LSBs, MSBs0_24;
; 103  : 
; 104  :     for (i = 0; i < NB_TRACK_MR102; i++)
; 105  :     {
; 106  :        sign_indx[i] = indx[i];                                  move16 (); 

  00008	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  0000c	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0

; 107  :     }
; 108  :     
; 109  :     /*
; 110  :       First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits 
; 111  :       MSBs = indx[NB_TRACK]/8;
; 112  :       LSBs = indx[NB_TRACK]%8;
; 113  :       */
; 114  :     MSBs = shr(indx[NB_TRACK_MR102], 3);

  00010	0f b7 56 08	 movzx	 edx, WORD PTR [esi+8]
  00014	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00016	66 85 c0	 test	 ax, ax
  00019	79 0a		 jns	 SHORT $LN10@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0001b	98		 cwde
  0001c	f7 d0		 not	 eax
  0001e	c1 f8 03	 sar	 eax, 3
  00021	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00023	eb 04		 jmp	 SHORT $LN287@decompress
$LN10@decompress:

; 381  :                 var_out = var1 >> var2;

  00025	66 c1 f8 03	 sar	 ax, 3
$LN287@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 116  :     decompress10 (MSBs, LSBs, 0, 4, 1, pos_indx);               

  00029	8b 7d 08	 mov	 edi, DWORD PTR _pos_indx$[ebp]
  0002c	83 e2 07	 and	 edx, 7
  0002f	57		 push	 edi
  00030	6a 01		 push	 1
  00032	6a 04		 push	 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  00034	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 116  :     decompress10 (MSBs, LSBs, 0, 4, 1, pos_indx);               

  00037	6a 00		 push	 0
  00039	e8 00 00 00 00	 call	 _decompress10

; 117  :     
; 118  :     /*
; 119  :       Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits       
; 120  :       MSBs = indx[NB_TRACK+1]/8;
; 121  :       LSBs = indx[NB_TRACK+1]%8;
; 122  :       */
; 123  :     MSBs = shr(indx[NB_TRACK_MR102+1], 3);

  0003e	0f b7 56 0a	 movzx	 edx, WORD PTR [esi+10]
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00047	66 85 c0	 test	 ax, ax
  0004a	79 0a		 jns	 SHORT $LN32@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0004c	98		 cwde
  0004d	f7 d0		 not	 eax
  0004f	c1 f8 03	 sar	 eax, 3
  00052	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00054	eb 04		 jmp	 SHORT $LN288@decompress
$LN32@decompress:

; 381  :                 var_out = var1 >> var2;

  00056	66 c1 f8 03	 sar	 ax, 3
$LN288@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 125  :     decompress10 (MSBs, LSBs, 2, 6, 5, pos_indx);               

  0005a	57		 push	 edi
  0005b	6a 05		 push	 5
  0005d	6a 06		 push	 6
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  0005f	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 124  :     LSBs = indx[NB_TRACK_MR102+1] & 7;                          logic16 ();

  00062	83 e2 07	 and	 edx, 7

; 125  :     decompress10 (MSBs, LSBs, 2, 6, 5, pos_indx);               

  00065	6a 02		 push	 2
  00067	e8 00 00 00 00	 call	 _decompress10

; 126  :     
; 127  :     /*
; 128  :       Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits    
; 129  :       MSBs = indx[NB_TRACK+2]/4;
; 130  :       LSBs = indx[NB_TRACK+2]%4;
; 131  :       MSBs0_24 = (MSBs*25+12)/32;
; 132  :       if ((MSBs0_24/5)%2==1)
; 133  :          pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
; 134  :       else
; 135  :          pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
; 136  :       pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
; 137  :       */
; 138  :     MSBs = shr(indx[NB_TRACK_MR102+2], 2);

  0006c	0f b7 5e 0c	 movzx	 ebx, WORD PTR [esi+12]
  00070	83 c4 10	 add	 esp, 16			; 00000010H
  00073	8b c3		 mov	 eax, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00075	66 85 c0	 test	 ax, ax
  00078	79 0a		 jns	 SHORT $LN54@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0007a	98		 cwde
  0007b	f7 d0		 not	 eax
  0007d	c1 f8 02	 sar	 eax, 2
  00080	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00082	eb 04		 jmp	 SHORT $LN289@decompress
$LN54@decompress:

; 381  :                 var_out = var1 >> var2;

  00084	66 c1 f8 02	 sar	 ax, 2
$LN289@decompress:
  00088	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 139  :     LSBs = indx[NB_TRACK_MR102+2] & 3;                          logic16 ();

  0008b	83 e3 03	 and	 ebx, 3
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0008e	98		 cwde
  0008f	6b c0 19	 imul	 eax, eax, 25

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00092	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00097	74 0c		 je	 SHORT $LN76@decompress

; 488  :     {
; 489  :         L_var_out *= 2;

  00099	03 c0		 add	 eax, eax

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  0009b	79 17		 jns	 SHORT $LN80@decompress

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0009d	f7 d0		 not	 eax
  0009f	d1 f8		 sar	 eax, 1
  000a1	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  000a3	eb 11		 jmp	 SHORT $LN79@decompress
$LN76@decompress:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  000a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000af	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN80@decompress:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  000b4	d1 f8		 sar	 eax, 1
$LN79@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  000b6	0f bf c8	 movsx	 ecx, ax
  000b9	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 79   :     if (L_var1 > 0X00007fffL)

  000bc	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  000c2	7e 48		 jle	 SHORT $LN95@decompress

; 80   :     {
; 81   :         Overflow = 1;

  000c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000ce	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
$LN101@decompress:

; 381  :                 var_out = var1 >> var2;

  000d3	66 c1 f8 05	 sar	 ax, 5
$LN290@decompress:
  000d7	0f b7 c0	 movzx	 eax, ax

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;

  000da	0f bf c8	 movsx	 ecx, ax
  000dd	69 d1 9a 19 00
	00		 imul	 edx, ecx, 6554

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  000e3	c1 fa 0f	 sar	 edx, 15			; 0000000fH
  000e6	8b c2		 mov	 eax, edx

; 436  :     if (L_product & (Word32) 0x00010000L)

  000e8	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  000ed	74 05		 je	 SHORT $LN120@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  000ef	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN120@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  000f4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000f9	7e 44		 jle	 SHORT $LN126@decompress

; 80   :     {
; 81   :         Overflow = 1;

  000fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00105	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  0010a	eb 4e		 jmp	 SHORT $LN123@decompress
$LN95@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0010c	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00112	7d 19		 jge	 SHORT $LN93@decompress

; 87   :         var_out = MIN_16;

  00114	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00123	98		 cwde
  00124	f7 d0		 not	 eax
  00126	c1 f8 05	 sar	 eax, 5
  00129	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0012b	eb aa		 jmp	 SHORT $LN290@decompress
$LN93@decompress:

; 91   :         var_out = extract_l (L_var1);

  0012d	0f b7 c1	 movzx	 eax, cx

; 375  :             if (var1 < 0)

  00130	66 85 c9	 test	 cx, cx
  00133	79 9e		 jns	 SHORT $LN101@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00135	98		 cwde
  00136	f7 d0		 not	 eax
  00138	c1 f8 05	 sar	 eax, 5
  0013b	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0013d	eb 98		 jmp	 SHORT $LN290@decompress
$LN126@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0013f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00144	7d 11		 jge	 SHORT $LN124@decompress

; 85   :     {
; 86   :         Overflow = 1;

  00146	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00150	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00155	eb 03		 jmp	 SHORT $LN123@decompress
$LN124@decompress:

; 91   :         var_out = extract_l (L_var1);

  00157	0f b7 f0	 movzx	 esi, ax
$LN123@decompress:

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0015a	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 143  :     ia = mult(MSBs0_24, 6554) & 1;

  0015c	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 436  :     if (L_product & (Word32) 0x00010000L)

  0015f	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00164	74 05		 je	 SHORT $LN131@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00166	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN131@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  0016b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00170	7e 11		 jle	 SHORT $LN137@decompress

; 80   :     {
; 81   :         Overflow = 1;

  00172	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0017c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00181	eb 1b		 jmp	 SHORT $LN134@decompress
$LN137@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00183	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00188	7d 11		 jge	 SHORT $LN135@decompress

; 85   :     {
; 86   :         Overflow = 1;

  0018a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00194	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00199	eb 03		 jmp	 SHORT $LN134@decompress
$LN135@decompress:

; 91   :         var_out = extract_l (L_var1);

  0019b	0f b7 c0	 movzx	 eax, ax
$LN134@decompress:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0019e	98		 cwde
  0019f	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  001a2	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  001a7	74 0c		 je	 SHORT $LN143@decompress

; 488  :     {
; 489  :         L_var_out *= 2;

  001a9	03 c0		 add	 eax, eax

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  001ab	79 17		 jns	 SHORT $LN147@decompress

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  001ad	f7 d0		 not	 eax
  001af	d1 f8		 sar	 eax, 1
  001b1	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  001b3	eb 11		 jmp	 SHORT $LN146@decompress
$LN143@decompress:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  001b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  001bf	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN147@decompress:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  001c4	d1 f8		 sar	 eax, 1
$LN146@decompress:

; 186  :     L_diff = (Word32) var1 - var2;

  001c6	98		 cwde
  001c7	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001c9	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  001cf	7e 11		 jle	 SHORT $LN162@decompress

; 80   :     {
; 81   :         Overflow = 1;

  001d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001db	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  001e0	eb 1c		 jmp	 SHORT $LN159@decompress
$LN162@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001e2	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  001e8	7d 11		 jge	 SHORT $LN160@decompress

; 85   :     {
; 86   :         Overflow = 1;

  001ea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001f4	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001f9	eb 03		 jmp	 SHORT $LN159@decompress
$LN160@decompress:

; 91   :         var_out = extract_l (L_var1);

  001fb	0f b7 c9	 movzx	 ecx, cx
$LN159@decompress:

; 186  :     L_diff = (Word32) var1 - var2;

  001fe	0f bf c6	 movsx	 eax, si
  00201	48		 dec	 eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 144  :     ib = sub(MSBs0_24, extract_l(L_shr(L_mult(mult(MSBs0_24, 6554), 5), 1)));

  00202	0f b7 f9	 movzx	 edi, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00205	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0020a	7e 0c		 jle	 SHORT $LN174@decompress

; 80   :     {
; 81   :         Overflow = 1;

  0020c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00216	eb 5a		 jmp	 SHORT $LN1@decompress
$LN174@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00218	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0021d	7d 0c		 jge	 SHORT $LN172@decompress

; 85   :     {
; 86   :         Overflow = 1;

  0021f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00229	eb 47		 jmp	 SHORT $LN1@decompress
$LN172@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 147  :     if (sub(ia, 1) == 0)

  0022b	66 85 c0	 test	 ax, ax
  0022e	75 42		 jne	 SHORT $LN1@decompress
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00230	0f bf c1	 movsx	 eax, cx
  00233	b9 04 00 00 00	 mov	 ecx, 4
  00238	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0023a	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00240	7e 11		 jle	 SHORT $LN184@decompress

; 80   :     {
; 81   :         Overflow = 1;

  00242	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0024c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00251	eb 1c		 jmp	 SHORT $LN181@decompress
$LN184@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00253	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00259	7d 11		 jge	 SHORT $LN182@decompress

; 85   :     {
; 86   :         Overflow = 1;

  0025b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00265	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0026a	eb 03		 jmp	 SHORT $LN181@decompress
$LN182@decompress:

; 91   :         var_out = extract_l (L_var1);

  0026c	0f b7 c1	 movzx	 eax, cx
$LN181@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 149  :        ib = sub(4, ib);

  0026f	0f b7 f8	 movzx	 edi, ax
$LN1@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00272	0f bf cf	 movsx	 ecx, di

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00275	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  0027a	03 c9		 add	 ecx, ecx
  0027c	0f bf c1	 movsx	 eax, cx
  0027f	3b c8		 cmp	 ecx, eax
  00281	74 1a		 je	 SHORT $LN192@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00283	66 85 ff	 test	 di, di
  00286	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00290	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00295	0f 4f c6	 cmovg	 eax, esi
  00298	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0029b	eb 03		 jmp	 SHORT $LN189@decompress
$LN192@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  0029d	0f b7 c1	 movzx	 eax, cx
$LN189@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  002a0	0f bf cb	 movsx	 ecx, bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 151  :     pos_indx[3] = add(shl(ib, 1), (LSBs & 1));               logic16 ();           

  002a3	8b f1		 mov	 esi, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002a5	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 151  :     pos_indx[3] = add(shl(ib, 1), (LSBs & 1));               logic16 ();           

  002a6	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002a9	03 f0		 add	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  002ab	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  002b1	7e 11		 jle	 SHORT $LN214@decompress

; 80   :     {
; 81   :         Overflow = 1;

  002b3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002bd	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002c2	eb 1c		 jmp	 SHORT $LN211@decompress
$LN214@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002c4	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  002ca	7d 11		 jge	 SHORT $LN212@decompress

; 85   :     {
; 86   :         Overflow = 1;

  002cc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002d6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002db	eb 03		 jmp	 SHORT $LN211@decompress
$LN212@decompress:

; 91   :         var_out = extract_l (L_var1);

  002dd	0f b7 c6	 movzx	 eax, si
$LN211@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 151  :     pos_indx[3] = add(shl(ib, 1), (LSBs & 1));               logic16 ();           

  002e0	8b 7d 08	 mov	 edi, DWORD PTR _pos_indx$[ebp]
  002e3	66 89 47 06	 mov	 WORD PTR [edi+6], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 436  :     if (L_product & (Word32) 0x00010000L)

  002e7	f7 c2 00 00 01
	00		 test	 edx, 65536		; 00010000H
  002ed	74 06		 je	 SHORT $LN221@decompress

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  002ef	81 ca 00 00 ff
	ff		 or	 edx, -65536		; ffff0000H
$LN221@decompress:

; 79   :     if (L_var1 > 0X00007fffL)

  002f5	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  002fb	7e 11		 jle	 SHORT $LN227@decompress

; 80   :     {
; 81   :         Overflow = 1;

  002fd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00307	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  0030c	eb 1c		 jmp	 SHORT $LN224@decompress
$LN227@decompress:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0030e	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00314	7d 11		 jge	 SHORT $LN225@decompress

; 85   :     {
; 86   :         Overflow = 1;

  00316	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00320	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00325	eb 03		 jmp	 SHORT $LN224@decompress
$LN225@decompress:

; 91   :         var_out = extract_l (L_var1);

  00327	0f b7 f2	 movzx	 esi, dx
$LN224@decompress:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0032a	0f bf d6	 movsx	 edx, si
  0032d	03 d2		 add	 edx, edx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0032f	0f bf c2	 movsx	 eax, dx
  00332	3b d0		 cmp	 edx, eax
  00334	74 1f		 je	 SHORT $LN235@decompress

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00336	66 85 f6	 test	 si, si
  00339	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00343	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00348	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0034d	0f 4f c2	 cmovg	 eax, edx
  00350	0f b7 d0	 movzx	 edx, ax

; 304  :         }
; 305  :         else

  00353	eb 03		 jmp	 SHORT $LN232@decompress
$LN235@decompress:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00355	0f b7 d2	 movzx	 edx, dx
$LN232@decompress:

; 375  :             if (var1 < 0)

  00358	66 85 db	 test	 bx, bx
  0035b	79 0b		 jns	 SHORT $LN253@decompress

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0035d	f7 d1		 not	 ecx
  0035f	d1 f9		 sar	 ecx, 1
  00361	f7 d1		 not	 ecx
  00363	0f b7 c1	 movzx	 eax, cx

; 378  :             }
; 379  :             else

  00366	eb 06		 jmp	 SHORT $LN252@decompress
$LN253@decompress:

; 381  :                 var_out = var1 >> var2;

  00368	66 d1 fb	 sar	 bx, 1
  0036b	0f b7 c3	 movzx	 eax, bx
$LN252@decompress:

; 139  :     L_sum = (Word32) var1 + var2;

  0036e	0f bf c8	 movsx	 ecx, ax
  00371	0f bf c2	 movsx	 eax, dx
  00374	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00376	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0037c	7e 18		 jle	 SHORT $LN277@decompress

; 82   :         var_out = MAX_16;

  0037e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00383	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 154  :     pos_indx[7] = add(ia, shr(LSBs, 1));

  0038d	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
  00391	5f		 pop	 edi
  00392	5e		 pop	 esi
  00393	5b		 pop	 ebx

; 155  : }

  00394	5d		 pop	 ebp
  00395	c3		 ret	 0
$LN277@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00396	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0039c	7d 18		 jge	 SHORT $LN275@decompress

; 87   :         var_out = MIN_16;

  0039e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  003a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 154  :     pos_indx[7] = add(ia, shr(LSBs, 1));

  003ad	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
  003b1	5f		 pop	 edi
  003b2	5e		 pop	 esi
  003b3	5b		 pop	 ebx

; 155  : }

  003b4	5d		 pop	 ebp
  003b5	c3		 ret	 0
$LN275@decompress:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  003b6	0f b7 c1	 movzx	 eax, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d8_31pf.c

; 154  :     pos_indx[7] = add(ia, shr(LSBs, 1));

  003b9	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
  003bd	5f		 pop	 edi
  003be	5e		 pop	 esi
  003bf	5b		 pop	 ebx

; 155  : }

  003c0	5d		 pop	 ebp
  003c1	c3		 ret	 0
_decompress_code ENDP
_TEXT	ENDS
END
