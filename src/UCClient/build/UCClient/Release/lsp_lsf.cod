; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\lsp_lsf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

	ORG $+6
_table	DW	07fffH
	DW	07fd9H
	DW	07f62H
	DW	07e9dH
	DW	07d8aH
	DW	07c2aH
	DW	07a7dH
	DW	07885H
	DW	07642H
	DW	073b6H
	DW	070e3H
	DW	06dcaH
	DW	06a6eH
	DW	066d0H
	DW	062f2H
	DW	05ed7H
	DW	05a82H
	DW	055f6H
	DW	05134H
	DW	04c40H
	DW	0471dH
	DW	041ceH
	DW	03c57H
	DW	036baH
	DW	030fcH
	DW	02b1fH
	DW	02528H
	DW	01f1aH
	DW	018f9H
	DW	012c8H
	DW	0c8cH
	DW	0648H
	DW	00H
	DW	0f9b8H
	DW	0f374H
	DW	0ed38H
	DW	0e707H
	DW	0e0e6H
	DW	0dad8H
	DW	0d4e1H
	DW	0cf04H
	DW	0c946H
	DW	0c3a9H
	DW	0be32H
	DW	0b8e3H
	DW	0b3c0H
	DW	0aeccH
	DW	0aa0aH
	DW	0a57eH
	DW	0a129H
	DW	09d0eH
	DW	09930H
	DW	09592H
	DW	09236H
	DW	08f1dH
	DW	08c4aH
	DW	089beH
	DW	0877bH
	DW	08583H
	DW	083d6H
	DW	08276H
	DW	08163H
	DW	0809eH
	DW	08027H
	DW	08000H
	ORG $+6
_slope	DW	096f9H
	DW	0dd94H
	DW	0eb35H
	DW	0f11bH
	DW	0f45dH
	DW	0f674H
	DW	0f7dfH
	DW	0f8edH
	DW	0f9b8H
	DW	0fa56H
	DW	0fad6H
	DW	0fb3dH
	DW	0fb94H
	DW	0fbddH
	DW	0fc1aH
	DW	0fc4eH
	DW	0fc7bH
	DW	0fca3H
	DW	0fcc5H
	DW	0fce3H
	DW	0fcfcH
	DW	0fd12H
	DW	0fd26H
	DW	0fd37H
	DW	0fd45H
	DW	0fd51H
	DW	0fd5bH
	DW	0fd64H
	DW	0fd6aH
	DW	0fd6fH
	DW	0fd72H
	DW	0fd74H
	DW	0fd74H
	DW	0fd72H
	DW	0fd6fH
	DW	0fd6aH
	DW	0fd64H
	DW	0fd5bH
	DW	0fd51H
	DW	0fd45H
	DW	0fd37H
	DW	0fd26H
	DW	0fd12H
	DW	0fcfcH
	DW	0fce3H
	DW	0fcc5H
	DW	0fca3H
	DW	0fc7bH
	DW	0fc4eH
	DW	0fc1aH
	DW	0fbddH
	DW	0fb94H
	DW	0fb3dH
	DW	0fad6H
	DW	0fa56H
	DW	0f9b8H
	DW	0f8edH
	DW	0f7dfH
	DW	0f674H
	DW	0f45dH
	DW	0f11bH
	DW	0eb35H
	DW	0dd94H
	DW	096f9H
PUBLIC	_Lsp_lsf
PUBLIC	_Lsf_lsp
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
;	COMDAT _Lsf_lsp
_TEXT	SEGMENT
_lsp$1$ = -4						; size = 4
_m$dead$ = 8						; size = 2
_Lsf_lsp PROC						; COMDAT
; _lsf$ = ecx
; _lsp$ = edx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b c2		 mov	 eax, edx
  00007	56		 push	 esi

; 66   :     Word16 i, ind, offset;
; 67   :     Word32 L_tmp;
; 68   : 
; 69   :     for (i = 0; i < m; i++)

  00008	2b c1		 sub	 eax, ecx
  0000a	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  0000f	57		 push	 edi
  00010	89 45 fc	 mov	 DWORD PTR _lsp$1$[ebp], eax
$LL3@Lsf_lsp:

; 70   :     {
; 71   :         ind = shr (lsf[i], 8);      /* ind    = b8-b15 of lsf[i] */

  00013	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00016	8b c2		 mov	 eax, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00018	66 85 c0	 test	 ax, ax
  0001b	79 0a		 jns	 SHORT $LN7@Lsf_lsp

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0001d	98		 cwde
  0001e	f7 d0		 not	 eax
  00020	c1 f8 08	 sar	 eax, 8
  00023	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00025	eb 04		 jmp	 SHORT $LN69@Lsf_lsp
$LN7@Lsf_lsp:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00027	66 c1 f8 08	 sar	 ax, 8
$LN69@Lsf_lsp:
  0002b	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 76   :         L_tmp = L_mult (sub (table[ind + 1], table[ind]), offset);

  0002e	98		 cwde
  0002f	0f b6 da	 movzx	 ebx, dl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00032	0f bf 3c 45 00
	00 00 00	 movsx	 edi, WORD PTR _table[eax*2]
  0003a	0f bf 04 45 02
	00 00 00	 movsx	 eax, WORD PTR _table[eax*2+2]
  00042	2b c7		 sub	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  00044	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00049	7e 11		 jle	 SHORT $LN33@Lsf_lsp

; 80   :     {
; 81   :         Overflow = 1;

  0004b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00055	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0005a	eb 1b		 jmp	 SHORT $LN30@Lsf_lsp
$LN33@Lsf_lsp:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0005c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00061	7d 11		 jge	 SHORT $LN31@Lsf_lsp

; 85   :     {
; 86   :         Overflow = 1;

  00063	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0006d	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00072	eb 03		 jmp	 SHORT $LN30@Lsf_lsp
$LN31@Lsf_lsp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00074	0f b7 c0	 movzx	 eax, ax
$LN30@Lsf_lsp:

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00077	0f bf d0	 movsx	 edx, ax
  0007a	0f bf c3	 movsx	 eax, bx
  0007d	0f af d0	 imul	 edx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00080	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  00086	74 10		 je	 SHORT $LN39@Lsf_lsp

; 488  :     {
; 489  :         L_var_out *= 2;

  00088	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  0008b	85 c0		 test	 eax, eax
  0008d	79 18		 jns	 SHORT $LN43@Lsf_lsp

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0008f	f7 d0		 not	 eax
  00091	c1 f8 09	 sar	 eax, 9
  00094	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  00096	eb 12		 jmp	 SHORT $LN42@Lsf_lsp
$LN39@Lsf_lsp:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  00098	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000a2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN43@Lsf_lsp:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  000a7	c1 f8 09	 sar	 eax, 9
$LN42@Lsf_lsp:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  000aa	98		 cwde
  000ab	03 c7		 add	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  000ad	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000b2	7e 11		 jle	 SHORT $LN58@Lsf_lsp

; 80   :     {
; 81   :         Overflow = 1;

  000b4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000be	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000c3	eb 1b		 jmp	 SHORT $LN55@Lsf_lsp
$LN58@Lsf_lsp:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000c5	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000ca	7d 11		 jge	 SHORT $LN56@Lsf_lsp

; 85   :     {
; 86   :         Overflow = 1;

  000cc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000d6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000db	eb 03		 jmp	 SHORT $LN55@Lsf_lsp
$LN56@Lsf_lsp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000dd	0f b7 c0	 movzx	 eax, ax
$LN55@Lsf_lsp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 77   :         lsp[i] = add (table[ind], extract_l (L_shr (L_tmp, 9)));

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _lsp$1$[ebp]
  000e3	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  000e7	83 c1 02	 add	 ecx, 2
  000ea	4e		 dec	 esi
  000eb	0f 85 22 ff ff
	ff		 jne	 $LL3@Lsf_lsp
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx

; 78   :                                     move16 (); 
; 79   :     }
; 80   :     return;
; 81   : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_Lsf_lsp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c
;	COMDAT _Lsp_lsf
_TEXT	SEGMENT
_lsp$1$ = -12						; size = 4
_lsf$1$ = -8						; size = 4
tv390 = -4						; size = 4
_m$dead$ = 8						; size = 2
_Lsp_lsf PROC						; COMDAT
; _lsp$ = ecx
; _lsf$ = edx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 55 f8	 mov	 DWORD PTR _lsf$1$[ebp], edx

; 89   :     Word16 i, ind;
; 90   :     Word32 L_tmp;
; 91   : 
; 92   :     ind = 63;  move16 ();                      /* begin at end of table -1 */

  0000c	bf 3f 00 00 00	 mov	 edi, 63			; 0000003fH
  00011	89 4d f4	 mov	 DWORD PTR _lsp$1$[ebp], ecx

; 93   : 
; 94   :     for (i = m - 1; i >= 0; i--)

  00014	bb 09 00 00 00	 mov	 ebx, 9
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Lsp_lsf:

; 95   :     {
; 96   :         /* find value in table that is just greater than lsp[i] */
; 97   :         test (); 
; 98   :         while (sub (table[ind], lsp[i]) < 0)

  00020	0f bf c3	 movsx	 eax, bx
  00023	03 c0		 add	 eax, eax
  00025	0f bf f7	 movsx	 esi, di
  00028	89 45 fc	 mov	 DWORD PTR tv390[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0002b	0f bf 04 08	 movsx	 eax, WORD PTR [eax+ecx]
  0002f	0f bf 14 75 00
	00 00 00	 movsx	 edx, WORD PTR _table[esi*2]
  00037	8b ca		 mov	 ecx, edx
  00039	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0003b	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00041	7e 24		 jle	 SHORT $LN17@Lsp_lsf

; 80   :     {
; 81   :         Overflow = 1;

  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1@Lsp_lsf:

; 186  :     L_diff = (Word32) var1 - var2;

  0004d	2b c2		 sub	 eax, edx

; 79   :     if (L_var1 > 0X00007fffL)

  0004f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00054	7e 34		 jle	 SHORT $LN29@Lsp_lsf

; 80   :     {
; 81   :         Overflow = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00060	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00065	eb 3e		 jmp	 SHORT $LN26@Lsp_lsf
$LN17@Lsp_lsf:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00067	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0006d	7d 10		 jge	 SHORT $LN15@Lsp_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 100  :             ind--;

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _lsp$1$[ebp]
  00072	4f		 dec	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00073	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 102  :         }

  0007d	eb a1		 jmp	 SHORT $LL2@Lsp_lsf
$LN15@Lsp_lsf:

; 95   :     {
; 96   :         /* find value in table that is just greater than lsp[i] */
; 97   :         test (); 
; 98   :         while (sub (table[ind], lsp[i]) < 0)

  0007f	66 85 c9	 test	 cx, cx
  00082	79 c9		 jns	 SHORT $LN1@Lsp_lsf

; 102  :         }

  00084	8b 4d f4	 mov	 ecx, DWORD PTR _lsp$1$[ebp]
  00087	4f		 dec	 edi
  00088	eb 96		 jmp	 SHORT $LL2@Lsp_lsf
$LN29@Lsp_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0008a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0008f	7d 11		 jge	 SHORT $LN27@Lsp_lsf

; 86   :         Overflow = 1;

  00091	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0009b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000a0	eb 03		 jmp	 SHORT $LN26@Lsp_lsf
$LN27@Lsp_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000a2	0f b7 c0	 movzx	 eax, ax
$LN26@Lsp_lsf:

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)
; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);
; 378  :             }
; 379  :             else
; 380  :             {
; 381  :                 var_out = var1 >> var2;
; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000a5	0f bf 0c 75 00
	00 00 00	 movsx	 ecx, WORD PTR _slope[esi*2]
  000ad	98		 cwde
  000ae	0f af c8	 imul	 ecx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000b1	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  000b7	74 05		 je	 SHORT $LN35@Lsp_lsf

; 488  :     {
; 489  :         L_var_out *= 2;

  000b9	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 490  :     }
; 491  :     else

  000bc	eb 0f		 jmp	 SHORT $LN34@Lsp_lsf
$LN35@Lsp_lsf:

; 492  :     {
; 493  :         Overflow = 1;

  000be	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000c8	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN34@Lsp_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 109  :         lsf[i] = round (L_shl (L_tmp, 3));      move16 (); 

  000cd	b9 03 00 00 00	 mov	 ecx, 3
$LL46@Lsp_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  000d2	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  000d7	7f 18		 jg	 SHORT $LN103@Lsp_lsf

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  000d9	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  000de	7c 0a		 jl	 SHORT $LN104@Lsp_lsf

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  000e0	49		 dec	 ecx
  000e1	03 c0		 add	 eax, eax
  000e3	66 85 c9	 test	 cx, cx
  000e6	7f ea		 jg	 SHORT $LL46@Lsp_lsf

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  000e8	eb 16		 jmp	 SHORT $LN41@Lsp_lsf
$LN104@Lsp_lsf:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  000ea	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  000ef	eb 05		 jmp	 SHORT $LN113@Lsp_lsf
$LN103@Lsp_lsf:

; 1360 :                 L_var_out = MAX_32;

  000f1	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN113@Lsp_lsf:

; 1358 :             {
; 1359 :                 Overflow = 1;

  000f6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN41@Lsp_lsf:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00100	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00106	85 c0		 test	 eax, eax
  00108	78 1d		 js	 SHORT $LN60@Lsp_lsf

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0010a	8b ca		 mov	 ecx, edx
  0010c	33 c8		 xor	 ecx, eax
  0010e	79 17		 jns	 SHORT $LN60@Lsp_lsf

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00110	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00112	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0011c	85 c0		 test	 eax, eax
  0011e	0f 98 c2	 sets	 dl
  00121	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN60@Lsp_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 109  :         lsf[i] = round (L_shl (L_tmp, 3));      move16 (); 

  00127	8b 45 fc	 mov	 eax, DWORD PTR tv390[ebp]
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _lsf$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0012d	c1 fa 10	 sar	 edx, 16			; 00000010H

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00130	c1 e6 08	 shl	 esi, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 109  :         lsf[i] = round (L_shl (L_tmp, 3));      move16 (); 

  00133	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00137	0f bf c6	 movsx	 eax, si
  0013a	3b f0		 cmp	 esi, eax
  0013c	74 1f		 je	 SHORT $LN71@Lsp_lsf

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0013e	66 85 ff	 test	 di, di
  00141	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0014b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00150	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00155	0f 4f c1	 cmovg	 eax, ecx
  00158	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0015b	eb 03		 jmp	 SHORT $LN68@Lsp_lsf
$LN71@Lsp_lsf:

; 306  :         {
; 307  :             var_out = extract_l (result);

  0015d	0f b7 c6	 movzx	 eax, si
$LN68@Lsp_lsf:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00160	0f bf ca	 movsx	 ecx, dx
  00163	98		 cwde
  00164	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00166	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0016c	7e 11		 jle	 SHORT $LN93@Lsp_lsf

; 80   :     {
; 81   :         Overflow = 1;

  0016e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00178	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0017d	eb 1c		 jmp	 SHORT $LN90@Lsp_lsf
$LN93@Lsp_lsf:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0017f	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00185	7d 11		 jge	 SHORT $LN91@Lsp_lsf

; 86   :         Overflow = 1;

  00187	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00191	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00196	eb 03		 jmp	 SHORT $LN90@Lsp_lsf
$LN91@Lsp_lsf:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00198	0f b7 c1	 movzx	 eax, cx
$LN90@Lsp_lsf:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_lsf.c

; 110  :         lsf[i] = add (lsf[i], shl (ind, 8));    move16 (); 

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR tv390[ebp]
  0019e	4b		 dec	 ebx
  0019f	8b 55 f8	 mov	 edx, DWORD PTR _lsf$1$[ebp]
  001a2	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  001a6	8b 4d f4	 mov	 ecx, DWORD PTR _lsp$1$[ebp]
  001a9	66 85 db	 test	 bx, bx
  001ac	0f 89 6e fe ff
	ff		 jns	 $LL2@Lsp_lsf
  001b2	5f		 pop	 edi
  001b3	5e		 pop	 esi
  001b4	5b		 pop	 ebx

; 111  :     }
; 112  :     return;
; 113  : }

  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c3		 ret	 0
_Lsp_lsf ENDP
_TEXT	ENDS
END
