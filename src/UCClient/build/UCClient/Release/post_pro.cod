; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\post_pro.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@ ; `string'
PUBLIC	??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@ ; `string'
;	COMDAT ??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@ DB 'Post_Process_'
	DB	'reset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@
CONST	SEGMENT
??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@ DB 'Post_Process'
	DB	'_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@ DB 'Post_Process_'
	DB	'init: invalid parameter', 0aH, 00H		; `string'
_b	DW	01e13H
	DW	0c3daH
	DW	01e13H
	ORG $+2
_a	DW	02000H
	DW	03ddcH
	DW	0e20dH
PUBLIC	_Post_Process_exit
PUBLIC	_Post_Process_init
PUBLIC	_Post_Process
PUBLIC	_Post_Process_reset
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_reset
_TEXT	SEGMENT
_Post_Process_reset PROC				; COMDAT
; _state$ = ecx

; 93   :   if (state == (Post_ProcessState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN1@Post_Proce

; 94   :       fprintf(stderr, "Post_Process_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DNAPCMKC@Post_Process_reset?3?5invalid?5para@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 95   :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 103  :   state->x1 = 0;
; 104  : 
; 105  :   return 0;
; 106  : }

  0001f	c3		 ret	 0
$LN1@Post_Proce:

; 96   :   }
; 97   :   
; 98   :   state->y2_hi = 0;

  00020	33 c0		 xor	 eax, eax
  00022	89 01		 mov	 DWORD PTR [ecx], eax

; 99   :   state->y2_lo = 0;
; 100  :   state->y1_hi = 0;

  00024	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 101  :   state->y1_lo = 0;
; 102  :   state->x0 = 0;

  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 103  :   state->x1 = 0;
; 104  : 
; 105  :   return 0;
; 106  : }

  0002a	c3		 ret	 0
_Post_Process_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process
_TEXT	SEGMENT
_x2$1$ = -12						; size = 4
tv670 = -8						; size = 4
_signal$1$ = -4						; size = 4
_lg$dead$ = 8						; size = 2
_Post_Process PROC					; COMDAT
; _st$ = ecx
; _signal$ = edx

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f2		 mov	 esi, edx

; 154  :     for (i = 0; i < lg; i++)

  0000a	c7 45 f8 a0 00
	00 00		 mov	 DWORD PTR tv670[ebp], 160 ; 000000a0H
  00011	57		 push	 edi
  00012	89 75 fc	 mov	 DWORD PTR _signal$1$[ebp], esi
  00015	8b f9		 mov	 edi, ecx
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL3@Post_Proce:

; 155  :     {
; 156  :         x2 = st->x1;                             move16 (); 

  00020	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]

; 157  :         st->x1 = st->x0;                         move16 (); 
; 158  :         st->x0 = signal[i];                      move16 (); 
; 159  :         
; 160  :         /*  y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2  */
; 161  :         /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */
; 162  :         
; 163  :         L_tmp = Mpy_32_16 (st->y1_hi, st->y1_lo, a[1]);

  00024	66 8b 57 06	 mov	 dx, WORD PTR [edi+6]
  00028	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]
  0002c	89 45 f4	 mov	 DWORD PTR _x2$1$[ebp], eax
  0002f	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  00033	66 89 47 0a	 mov	 WORD PTR [edi+10], ax
  00037	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0003a	68 dc 3d 00 00	 push	 15836			; 00003ddcH
  0003f	8b d8		 mov	 ebx, eax
  00041	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  00045	e8 00 00 00 00	 call	 _Mpy_32_16

; 164  :         L_tmp = L_add (L_tmp, Mpy_32_16 (st->y2_hi, st->y2_lo, a[2]));

  0004a	66 8b 57 02	 mov	 dx, WORD PTR [edi+2]
  0004e	8b f0		 mov	 esi, eax
  00050	66 8b 0f	 mov	 cx, WORD PTR [edi]
  00053	68 0d e2 ff ff	 push	 -7667			; ffffe20dH
  00058	e8 00 00 00 00	 call	 _Mpy_32_16
  0005d	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  00060	8d 14 30	 lea	 edx, DWORD PTR [eax+esi]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00063	33 c6		 xor	 eax, esi
  00065	78 1d		 js	 SHORT $LN16@Post_Proce

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00067	8b c2		 mov	 eax, edx
  00069	33 c6		 xor	 eax, esi
  0006b	79 17		 jns	 SHORT $LN16@Post_Proce

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0006d	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  0006f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00079	85 f6		 test	 esi, esi
  0007b	0f 98 c2	 sets	 dl
  0007e	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN16@Post_Proce:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00084	0f bf c3	 movsx	 eax, bx
  00087	69 c0 13 1e 00
	00		 imul	 eax, eax, 7699

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0008d	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00092	74 04		 je	 SHORT $LN23@Post_Proce

; 488  :     {
; 489  :         L_var_out *= 2;

  00094	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00096	eb 0f		 jmp	 SHORT $LN22@Post_Proce
$LN23@Post_Proce:

; 492  :     {
; 493  :         Overflow = 1;

  00098	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000a2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN22@Post_Proce:

; 931  :     L_var_out = L_var1 + L_var2;

  000a7	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000aa	33 c2		 xor	 eax, edx
  000ac	78 1d		 js	 SHORT $LN26@Post_Proce

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  000ae	8b c1		 mov	 eax, ecx
  000b0	33 c2		 xor	 eax, edx
  000b2	79 17		 jns	 SHORT $LN26@Post_Proce

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  000b4	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  000b6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000c0	85 d2		 test	 edx, edx
  000c2	0f 98 c1	 sets	 cl
  000c5	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN26@Post_Proce:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000cb	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]
  000cf	69 c0 da c3 ff
	ff		 imul	 eax, eax, -15398

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000d5	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000da	74 04		 je	 SHORT $LN33@Post_Proce

; 488  :     {
; 489  :         L_var_out *= 2;

  000dc	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  000de	eb 0f		 jmp	 SHORT $LN32@Post_Proce
$LN33@Post_Proce:

; 492  :     {
; 493  :         Overflow = 1;

  000e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000ea	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN32@Post_Proce:

; 931  :     L_var_out = L_var1 + L_var2;

  000ef	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000f2	33 c1		 xor	 eax, ecx
  000f4	78 1d		 js	 SHORT $LN36@Post_Proce

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  000f6	8b c2		 mov	 eax, edx
  000f8	33 c1		 xor	 eax, ecx
  000fa	79 17		 jns	 SHORT $LN36@Post_Proce

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  000fc	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  000fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00108	85 c9		 test	 ecx, ecx
  0010a	0f 98 c2	 sets	 dl
  0010d	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN36@Post_Proce:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00113	8b 45 f4	 mov	 eax, DWORD PTR _x2$1$[ebp]
  00116	98		 cwde
  00117	69 c8 13 1e 00
	00		 imul	 ecx, eax, 7699

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0011d	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00123	74 04		 je	 SHORT $LN43@Post_Proce

; 488  :     {
; 489  :         L_var_out *= 2;

  00125	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  00127	eb 0f		 jmp	 SHORT $LN42@Post_Proce
$LN43@Post_Proce:

; 492  :     {
; 493  :         Overflow = 1;

  00129	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00133	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN42@Post_Proce:

; 931  :     L_var_out = L_var1 + L_var2;

  00138	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0013b	33 ca		 xor	 ecx, edx
  0013d	78 1c		 js	 SHORT $LN46@Post_Proce

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0013f	8b c8		 mov	 ecx, eax
  00141	33 ca		 xor	 ecx, edx
  00143	79 16		 jns	 SHORT $LN46@Post_Proce

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00145	33 c0		 xor	 eax, eax

; 938  :             Overflow = 1;

  00147	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00151	85 d2		 test	 edx, edx
  00153	0f 98 c0	 sets	 al
  00156	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
$LN46@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 168  :         L_tmp = L_shl (L_tmp, 2);

  0015b	b9 02 00 00 00	 mov	 ecx, 2
$LL58@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00160	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00165	7f 18		 jg	 SHORT $LN114@Post_Proce

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00167	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  0016c	7c 0a		 jl	 SHORT $LN115@Post_Proce

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  0016e	49		 dec	 ecx
  0016f	03 c0		 add	 eax, eax
  00171	66 85 c9	 test	 cx, cx
  00174	7f ea		 jg	 SHORT $LL58@Post_Proce

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00176	eb 16		 jmp	 SHORT $LN53@Post_Proce
$LN115@Post_Proce:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  00178	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0017d	eb 05		 jmp	 SHORT $LN129@Post_Proce
$LN114@Post_Proce:

; 1360 :                 L_var_out = MAX_32;

  0017f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN129@Post_Proce:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00184	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN53@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 171  :         signal[i] = round(L_shl(L_tmp, 1));   move16 (); 

  0018e	b9 01 00 00 00	 mov	 ecx, 1
  00193	8b d0		 mov	 edx, eax
$LL69@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00195	81 fa ff ff ff
	3f		 cmp	 edx, 1073741823		; 3fffffffH
  0019b	7f 19		 jg	 SHORT $LN116@Post_Proce

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0019d	81 fa 00 00 00
	c0		 cmp	 edx, -1073741824	; c0000000H
  001a3	7c 0a		 jl	 SHORT $LN117@Post_Proce

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  001a5	49		 dec	 ecx
  001a6	03 d2		 add	 edx, edx
  001a8	66 85 c9	 test	 cx, cx
  001ab	7f e8		 jg	 SHORT $LL69@Post_Proce

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  001ad	eb 16		 jmp	 SHORT $LN64@Post_Proce
$LN117@Post_Proce:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  001af	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  001b4	eb 05		 jmp	 SHORT $LN130@Post_Proce
$LN116@Post_Proce:

; 1360 :                 L_var_out = MAX_32;

  001b6	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN130@Post_Proce:

; 1358 :             {
; 1359 :                 Overflow = 1;

  001bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN64@Post_Proce:

; 931  :     L_var_out = L_var1 + L_var2;

  001c5	8d 9a 00 80 00
	00		 lea	 ebx, DWORD PTR [edx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001cb	85 d2		 test	 edx, edx
  001cd	78 1d		 js	 SHORT $LN74@Post_Proce

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001cf	8b cb		 mov	 ecx, ebx
  001d1	33 ca		 xor	 ecx, edx
  001d3	79 17		 jns	 SHORT $LN74@Post_Proce

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  001d5	33 db		 xor	 ebx, ebx

; 938  :             Overflow = 1;

  001d7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001e1	85 d2		 test	 edx, edx
  001e3	0f 98 c3	 sets	 bl
  001e6	81 c3 ff ff ff
	7f		 add	 ebx, 2147483647		; 7fffffffH
$LN74@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 171  :         signal[i] = round(L_shl(L_tmp, 1));   move16 (); 

  001ec	8b 75 fc	 mov	 esi, DWORD PTR _signal$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  001ef	c1 fb 10	 sar	 ebx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 171  :         signal[i] = round(L_shl(L_tmp, 1));   move16 (); 

  001f2	66 89 1e	 mov	 WORD PTR [esi], bx

; 172  :         
; 173  :         st->y2_hi = st->y1_hi;                   move16 (); 

  001f5	0f b7 4f 04	 movzx	 ecx, WORD PTR [edi+4]
  001f9	66 89 0f	 mov	 WORD PTR [edi], cx

; 174  :         st->y2_lo = st->y1_lo;                   move16 (); 

  001fc	0f b7 4f 06	 movzx	 ecx, WORD PTR [edi+6]
  00200	66 89 4f 02	 mov	 WORD PTR [edi+2], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00204	8b c8		 mov	 ecx, eax
  00206	c1 f9 10	 sar	 ecx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 47   :     *hi = extract_h (L_32);

  00209	66 89 4f 04	 mov	 WORD PTR [edi+4], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  0020d	85 c0		 test	 eax, eax
  0020f	79 08		 jns	 SHORT $LN91@Post_Proce

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00211	f7 d0		 not	 eax
  00213	d1 f8		 sar	 eax, 1
  00215	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  00217	eb 02		 jmp	 SHORT $LN90@Post_Proce
$LN91@Post_Proce:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00219	d1 f8		 sar	 eax, 1
$LN90@Post_Proce:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0021b	0f bf c9	 movsx	 ecx, cx
  0021e	c1 e1 0e	 shl	 ecx, 14			; 0000000eH

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00221	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00227	74 04		 je	 SHORT $LN102@Post_Proce

; 488  :     {
; 489  :         L_var_out *= 2;

  00229	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  0022b	eb 0f		 jmp	 SHORT $LN101@Post_Proce
$LN102@Post_Proce:

; 492  :     {
; 493  :         Overflow = 1;

  0022d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00237	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN101@Post_Proce:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  0023c	8b d0		 mov	 edx, eax
  0023e	2b d1		 sub	 edx, ecx

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00240	33 c8		 xor	 ecx, eax
  00242	79 1d		 jns	 SHORT $LN105@Post_Proce

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00244	8b ca		 mov	 ecx, edx
  00246	33 c8		 xor	 ecx, eax
  00248	79 17		 jns	 SHORT $LN105@Post_Proce

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0024a	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  0024c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00256	85 c0		 test	 eax, eax
  00258	0f 98 c2	 sets	 dl
  0025b	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN105@Post_Proce:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 154  :     for (i = 0; i < lg; i++)

  00261	83 c6 02	 add	 esi, 2
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 48   :     *lo = extract_l (L_msu (L_shr (L_32, 1), *hi, 16384));

  00264	66 89 57 06	 mov	 WORD PTR [edi+6], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c

; 154  :     for (i = 0; i < lg; i++)

  00268	ff 4d f8	 dec	 DWORD PTR tv670[ebp]
  0026b	89 75 fc	 mov	 DWORD PTR _signal$1$[ebp], esi
  0026e	0f 85 ac fd ff
	ff		 jne	 $LL3@Post_Proce

; 175  :         L_Extract (L_tmp, &st->y1_hi, &st->y1_lo);
; 176  :     }
; 177  : 
; 178  :     return 0;    

  00274	5f		 pop	 edi
  00275	5e		 pop	 esi
  00276	33 c0		 xor	 eax, eax
  00278	5b		 pop	 ebx

; 179  : }

  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
_Post_Process ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_init
_TEXT	SEGMENT
_Post_Process_init PROC					; COMDAT
; _state$ = ecx

; 63   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 64   :   Post_ProcessState* s;
; 65   :  
; 66   :   if (state == (Post_ProcessState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@Post_Proce

; 67   :       fprintf(stderr, "Post_Process_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BNBNLNGC@Post_Process_init?3?5invalid?5param@
$LN8@Post_Proce:
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 68   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 82   : }

  00023	c3		 ret	 0
$LN2@Post_Proce:

; 69   :   }
; 70   :   *state = NULL;
; 71   :  
; 72   :   /* allocate memory */
; 73   :   if ((s= (Post_ProcessState *) malloc(sizeof(Post_ProcessState))) == NULL){

  00024	6a 0c		 push	 12			; 0000000cH
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN1@Post_Proce

; 74   :       fprintf(stderr, "Post_Process_init: can not malloc state structure\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@PDABFOBO@Post_Process_init?3?5can?5not?5mallo@

; 75   :       return -1;

  0003e	eb cc		 jmp	 SHORT $LN8@Post_Proce
$LN1@Post_Proce:

; 83   :  
; 84   : /*************************************************************************
; 85   : *
; 86   : *  Function:   Post_Process_reset
; 87   : *  Purpose:    Initializes state memory to zero
; 88   : *
; 89   : **************************************************************************
; 90   : */
; 91   : int Post_Process_reset (Post_ProcessState *state)
; 92   : {
; 93   :   if (state == (Post_ProcessState *) NULL){
; 94   :       fprintf(stderr, "Post_Process_reset: invalid parameter\n");
; 95   :       return -1;
; 96   :   }
; 97   :   
; 98   :   state->y2_hi = 0;

  00040	33 c9		 xor	 ecx, ecx
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 99   :   state->y2_lo = 0;
; 100  :   state->y1_hi = 0;

  00044	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 101  :   state->y1_lo = 0;
; 102  :   state->x0 = 0;

  00047	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 76   :   }
; 77   :   
; 78   :   Post_Process_reset(s);
; 79   :   *state = s;

  0004a	89 06		 mov	 DWORD PTR [esi], eax

; 80   :   
; 81   :   return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5e		 pop	 esi

; 82   : }

  0004f	c3		 ret	 0
_Post_Process_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\post_pro.c
;	COMDAT _Post_Process_exit
_TEXT	SEGMENT
_Post_Process_exit PROC					; COMDAT
; _state$ = ecx

; 116  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 117  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@Post_Proce
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@Post_Proce

; 118  :       return;
; 119  :  
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 122  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Post_Proce:
  0001d	5e		 pop	 esi

; 123  :   
; 124  :   return;
; 125  : }

  0001e	c3		 ret	 0
_Post_Process_exit ENDP
_TEXT	ENDS
END
