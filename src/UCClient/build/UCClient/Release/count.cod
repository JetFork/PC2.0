; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\count.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

COMM	_multiCounter:BYTE:0a400H
_DATA	ENDS
PUBLIC	_logic32
PUBLIC	_move32
PUBLIC	_fwc
PUBLIC	_Init_WMOPS_counter
PUBLIC	_WMOPS_output
PUBLIC	_move16
PUBLIC	_test
PUBLIC	_Reset_WMOPS_counter
PUBLIC	_setCounter
PUBLIC	_getCounterId
PUBLIC	_logic16
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _logic16
_TEXT	SEGMENT
_logic16 PROC						; COMDAT

; 190  : #if WMOPS
; 191  :     multiCounter[currCounter].Logic16++;
; 192  : #endif
; 193  : }

  00000	c3		 ret	 0
_logic16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _getCounterId
_TEXT	SEGMENT
_getCounterId PROC					; COMDAT
; _objectNameArg$dead$ = ecx

; 74   : #if WMOPS
; 75   :   if(maxCounter>=MAXCOUNTERS-1) return 0;
; 76   :   objectName[++maxCounter]=my_strdup(objectNameArg);
; 77   :   return maxCounter;
; 78   : #else
; 79   :   return 0; /* Dummy */

  00000	33 c0		 xor	 eax, eax

; 80   : #endif
; 81   : }

  00002	c3		 ret	 0
_getCounterId ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _setCounter
_TEXT	SEGMENT
_setCounter PROC					; COMDAT
; _counterId$dead$ = ecx

; 85   : #if WMOPS
; 86   :   if(counterId>maxCounter || counterId<0)
; 87   :     {
; 88   :       currCounter=0;
; 89   :       return;
; 90   :     }
; 91   :   currCounter=counterId;
; 92   : #endif
; 93   : }

  00000	c3		 ret	 0
_setCounter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _Reset_WMOPS_counter
_TEXT	SEGMENT
_Reset_WMOPS_counter PROC				; COMDAT

; 225  : #if WMOPS
; 226  :     Word32 tot = WMOPS_frameStat();
; 227  :         
; 228  :     /* increase the frame counter --> a frame is counted WHEN IT BEGINS */
; 229  :     nbframe[currCounter]++;
; 230  :     /* add wmops used in last frame to count, then reset counter */
; 231  :     /* (in first frame, this is a no-op                          */
; 232  :     total_wmops[currCounter] += ((float) tot) * 0.00005;
; 233  :     
; 234  :     /* clear counter before new frame starts */
; 235  :     WMOPS_clearMultiCounter();
; 236  :     LastWOper[currCounter] = 0;
; 237  :     funcid[currCounter] = 0;           /* new frame, set function id to zero */
; 238  : #endif
; 239  : }

  00000	c3		 ret	 0
_Reset_WMOPS_counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _test
_TEXT	SEGMENT
_test	PROC						; COMDAT

; 183  : #if WMOPS
; 184  :     multiCounter[currCounter].Test++;
; 185  : #endif
; 186  : }

  00000	c3		 ret	 0
_test	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _move16
_TEXT	SEGMENT
_move16	PROC						; COMDAT

; 169  : #if WMOPS
; 170  :     multiCounter[currCounter].DataMove16++;
; 171  : #endif
; 172  : }

  00000	c3		 ret	 0
_move16	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _WMOPS_output
_TEXT	SEGMENT
_WMOPS_output PROC					; COMDAT
; _dtx_mode$dead$ = cx

; 260  : #if WMOPS
; 261  :     Word16 i;
; 262  :     Word32 tot, tot_wm, tot_wc;
; 263  : 
; 264  :     /* get operations since last reset (or init),
; 265  :        but do not update the counters (except the glob_wc[] maximum)
; 266  :        so output CAN be called in each frame without problems.
; 267  :        The frame counter is NOT updated!
; 268  :      */
; 269  :     tot = WMOPS_frameStat();
; 270  :     tot_wm = total_wmops[currCounter] + ((float) tot) * 0.00005;
; 271  : 
; 272  :     fprintf (stdout, "%10s:WMOPS=%.3f",
; 273  : 	     objectName[currCounter]?objectName[currCounter]:"",
; 274  : 	     ((float) tot) * 0.00005);
; 275  : 
; 276  :     if (nbframe[currCounter] != 0)
; 277  :         fprintf (stdout, "  Average=%.3f",
; 278  :                  tot_wm / (float) nbframe[currCounter]);
; 279  :     
; 280  :     fprintf (stdout, "  WorstCase=%.3f",
; 281  :              ((float) glob_wc[currCounter]) * 0.00005);
; 282  : 
; 283  :     /* Worst worst case printed only when not in DTX mode */
; 284  :     if (dtx_mode == 0)
; 285  :     {
; 286  :         tot_wc = 0L;
; 287  :         for (i = 0; i < funcid[currCounter]; i++)
; 288  :             tot_wc += wc[currCounter][i];
; 289  :         fprintf (stdout, "  WorstWC=%.3f", ((float) tot_wc) * 0.00005);
; 290  :     }
; 291  :     fprintf (stdout, " (%d frames)\n", nbframe[currCounter]);
; 292  :     
; 293  : #endif
; 294  : }

  00000	c3		 ret	 0
_WMOPS_output ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _Init_WMOPS_counter
_TEXT	SEGMENT
_Init_WMOPS_counter PROC				; COMDAT

; 204  : #if WMOPS
; 205  :     Word16 i;
; 206  : 
; 207  :     /* reset function weight operation counter variable */
; 208  : 
; 209  :     for (i = 0; i < NbFuncMax; i++)
; 210  :         wc[currCounter][i] = (Word32) 0;
; 211  :     glob_wc[currCounter] = 0;
; 212  :     nbframe[currCounter] = 0;
; 213  :     total_wmops[currCounter] = 0.0;
; 214  : 
; 215  :     /* initially clear all counters */
; 216  :     WMOPS_clearMultiCounter();
; 217  :     LastWOper[currCounter] = 0;
; 218  :     funcid[currCounter] = 0;
; 219  : #endif
; 220  : }

  00000	c3		 ret	 0
_Init_WMOPS_counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _fwc
_TEXT	SEGMENT
_fwc	PROC						; COMDAT

; 243  : #if WMOPS
; 244  :     Word32 tot;
; 245  : 
; 246  :     tot = DeltaWeightedOperation ();
; 247  :     if (tot > wc[currCounter][funcid[currCounter]])
; 248  :         wc[currCounter][funcid[currCounter]] = tot;
; 249  : 
; 250  :     funcid[currCounter]++;
; 251  : 
; 252  :     return (tot);
; 253  : #else
; 254  :     return 0; /* Dummy */

  00000	33 c0		 xor	 eax, eax

; 255  : #endif
; 256  : }

  00002	c3		 ret	 0
_fwc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _move32
_TEXT	SEGMENT
_move32	PROC						; COMDAT

; 176  : #if WMOPS
; 177  :     multiCounter[currCounter].DataMove32++;
; 178  : #endif
; 179  : }

  00000	c3		 ret	 0
_move32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
;	COMDAT _logic32
_TEXT	SEGMENT
_logic32 PROC						; COMDAT

; 197  : #if WMOPS
; 198  :     multiCounter[currCounter].Logic32++;
; 199  : #endif
; 200  : }

  00000	c3		 ret	 0
_logic32 ENDP
_TEXT	ENDS
END
