; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ec_gains.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@ ; `string'
PUBLIC	??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@ ; `string'
PUBLIC	??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@ ; `string'
PUBLIC	??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@ ; `string'
PUBLIC	??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@ ; `string'
;	COMDAT ??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@ DB 'ec_gain_pitch'
	DB	'_init: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@
CONST	SEGMENT
??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@ DB 'ec_gain_code_'
	DB	'reset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@
CONST	SEGMENT
??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@ DB 'ec_gain_pitch'
	DB	'_reset: invalid parameter', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@
CONST	SEGMENT
??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@ DB 'ec_gain_pitc'
	DB	'h_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@
CONST	SEGMENT
??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@ DB 'ec_gain_code'
	DB	'_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@ DB 'ec_gain_code_'
	DB	'init: invalid parameter', 0aH, 00H		; `string'
?pdown@?1??ec_gain_pitch@@9@9 DW 07fffH			; `ec_gain_pitch'::`2'::pdown
	DW	07d70H
	DW	07d70H
	DW	06666H
	DW	02666H
	DW	01999H
	DW	01999H
	ORG $+2
?cdown@?1??ec_gain_code@@9@9 DW 07fffH			; `ec_gain_code'::`2'::cdown
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	07d70H
	DW	05999H
PUBLIC	_ec_gain_pitch_reset
PUBLIC	_ec_gain_code
PUBLIC	_ec_gain_code_update
PUBLIC	_ec_gain_code_exit
PUBLIC	_ec_gain_pitch_update
PUBLIC	_ec_gain_pitch_init
PUBLIC	_ec_gain_pitch
PUBLIC	_ec_gain_code_reset
PUBLIC	_ec_gain_pitch_exit
PUBLIC	_ec_gain_code_init
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_init
_TEXT	SEGMENT
_ec_gain_code_init PROC					; COMDAT
; _state$ = ecx

; 61   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 62   :   ec_gain_codeState* s;
; 63   :  
; 64   :   if (state == (ec_gain_codeState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@ec_gain_co

; 65   :       fprintf(stderr, "ec_gain_code_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LLEOCGOO@ec_gain_code_init?3?5invalid?5param@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 66   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 80   : }

  00023	c3		 ret	 0
$LN2@ec_gain_co:
  00024	57		 push	 edi

; 67   :   }
; 68   :   *state = NULL;
; 69   :  
; 70   :   /* allocate memory */
; 71   :   if ((s= (ec_gain_codeState *) malloc(sizeof(ec_gain_codeState))) == NULL){

  00025	6a 0e		 push	 14			; 0000000eH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	75 1e		 jne	 SHORT $LN1@ec_gain_co

; 72   :       fprintf(stderr, "ec_gain_code_init: can not malloc state structure\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JBIGCFFD@ec_gain_code_init?3?5can?5not?5mallo@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00047	83 c0 40	 add	 eax, 64			; 00000040H
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00051	83 c4 08	 add	 esp, 8

; 73   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 80   : }

  00059	c3		 ret	 0
$LN1@ec_gain_co:

; 74   :   }
; 75   : 
; 76   :   ec_gain_code_reset(s);

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _ec_gain_code_reset

; 77   :   *state = s;

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 78   :   
; 79   :   return 0;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 80   : }

  00067	c3		 ret	 0
_ec_gain_code_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_exit
_TEXT	SEGMENT
_ec_gain_pitch_exit PROC				; COMDAT
; _state$ = ecx

; 285  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 286  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@ec_gain_pi
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@ec_gain_pi

; 287  :       return;
; 288  :  
; 289  :   /* deallocate memory */
; 290  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 291  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@ec_gain_pi:
  0001d	5e		 pop	 esi

; 292  :   
; 293  :   return;
; 294  : }

  0001e	c3		 ret	 0
_ec_gain_pitch_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_reset
_TEXT	SEGMENT
_ec_gain_code_reset PROC				; COMDAT
; _state$ = ecx

; 92   :   Word16 i;
; 93   :   
; 94   :   if (state == (ec_gain_codeState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN4@ec_gain_co

; 95   :       fprintf(stderr, "ec_gain_code_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 96   :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 105  : }

  0001f	c3		 ret	 0
$LN4@ec_gain_co:

; 97   :   }
; 98   : 
; 99   :   for ( i = 0; i < 5; i++)
; 100  :       state->gbuf[i] = 1;

  00020	b8 01 00 01 00	 mov	 eax, 65537		; 00010001H
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 101  :   state->past_gain_code = 0;
; 102  :   state->prev_gc = 1;       

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
  00036	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 103  : 
; 104  :   return 0;

  0003a	33 c0		 xor	 eax, eax

; 105  : }

  0003c	c3		 ret	 0
_ec_gain_code_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch
_TEXT	SEGMENT
_gain_pitch$ = 8					; size = 4
_ec_gain_pitch PROC					; COMDAT
; _st$ = ecx
; _state$ = dx

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	66 8b da	 mov	 bx, dx
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 321  :     tmp = gmed_n (st->pbuf, 5);                        move16 (); 

  0000b	ba 05 00 00 00	 mov	 edx, 5
  00010	e8 00 00 00 00	 call	 _gmed_n
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00015	0f b7 76 0a	 movzx	 esi, WORD PTR [esi+10]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 321  :     tmp = gmed_n (st->pbuf, 5);                        move16 (); 

  00019	0f b7 f8	 movzx	 edi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0001c	0f bf c6	 movsx	 eax, si
  0001f	0f bf cf	 movsx	 ecx, di
  00022	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00024	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0002a	7e 0c		 jle	 SHORT $LN13@ec_gain_pi

; 80   :     {
; 81   :         Overflow = 1;

  0002c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00036	eb 19		 jmp	 SHORT $LN31@ec_gain_pi
$LN13@ec_gain_pi:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00038	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0003e	7d 0c		 jge	 SHORT $LN11@ec_gain_pi

; 85   :     {
; 86   :         Overflow = 1;

  00040	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0004a	eb 07		 jmp	 SHORT $LN18@ec_gain_pi
$LN11@ec_gain_pi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 325  :     if (sub (tmp, st->past_gain_pit) > 0)

  0004c	66 85 c9	 test	 cx, cx
  0004f	7e 02		 jle	 SHORT $LN18@ec_gain_pi
$LN31@ec_gain_pi:

; 326  :     {
; 327  :         tmp = st->past_gain_pit;                       move16 (); 

  00051	8b fe		 mov	 edi, esi
$LN18@ec_gain_pi:

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  00053	0f bf c3	 movsx	 eax, bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00056	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?pdown@?1??ec_gain_pitch@@9@9[eax*2]
  0005e	0f bf c7	 movsx	 eax, di
  00061	0f af c8	 imul	 ecx, eax
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00067	c1 f9 0f	 sar	 ecx, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0006a	f7 c1 00 00 01
	00		 test	 ecx, 65536		; 00010000H
  00070	74 06		 je	 SHORT $LN20@ec_gain_pi

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00072	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN20@ec_gain_pi:

; 79   :     if (L_var1 > 0X00007fffL)

  00078	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0007e	7e 17		 jle	 SHORT $LN26@ec_gain_pi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  00080	8b 45 08	 mov	 eax, DWORD PTR _gain_pitch$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 82   :         var_out = MAX_16;

  00083	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00088	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  00092	66 89 08	 mov	 WORD PTR [eax], cx

; 330  : }

  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN26@ec_gain_pi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00097	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0009d	7d 17		 jge	 SHORT $LN24@ec_gain_pi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  0009f	8b 45 08	 mov	 eax, DWORD PTR _gain_pitch$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 87   :         var_out = MIN_16;

  000a2	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  000a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  000b1	66 89 08	 mov	 WORD PTR [eax], cx

; 330  : }

  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN24@ec_gain_pi:

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  000b6	8b 45 08	 mov	 eax, DWORD PTR _gain_pitch$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  000b9	0f b7 c9	 movzx	 ecx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 329  :     *gain_pitch = mult (tmp, pdown[state]);

  000bc	66 89 08	 mov	 WORD PTR [eax], cx

; 330  : }

  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_ec_gain_pitch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_init
_TEXT	SEGMENT
_ec_gain_pitch_init PROC				; COMDAT
; _state$ = ecx

; 231  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 232  :   ec_gain_pitchState* s;
; 233  :  
; 234  :   if (state == (ec_gain_pitchState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@ec_gain_pi

; 235  :       fprintf(stderr, "ec_gain_pitch_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JLOMFIBF@ec_gain_pitch_init?3?5invalid?5para@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 236  :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 250  : }

  00023	c3		 ret	 0
$LN2@ec_gain_pi:
  00024	57		 push	 edi

; 237  :   }
; 238  :   *state = NULL;
; 239  :  
; 240  :   /* allocate memory */
; 241  :   if ((s= (ec_gain_pitchState *) malloc(sizeof(ec_gain_pitchState))) == NULL){

  00025	6a 0e		 push	 14			; 0000000eH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	75 1e		 jne	 SHORT $LN1@ec_gain_pi

; 242  :       fprintf(stderr, "ec_gain_pitch_init: can not malloc state structure\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EHOGJBNA@ec_gain_pitch_init?3?5can?5not?5mall@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00047	83 c0 40	 add	 eax, 64			; 00000040H
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00051	83 c4 08	 add	 esp, 8

; 243  :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 250  : }

  00059	c3		 ret	 0
$LN1@ec_gain_pi:

; 244  :   }
; 245  :   
; 246  :   ec_gain_pitch_reset(s);

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _ec_gain_pitch_reset

; 247  :   *state = s;

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 248  :   
; 249  :   return 0;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 250  : }

  00067	c3		 ret	 0
_ec_gain_pitch_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_update
_TEXT	SEGMENT
_prev_bf$ = 8						; size = 2
_gain_pitch$ = 12					; size = 4
_ec_gain_pitch_update PROC				; COMDAT
; _st$ = ecx
; _bfi$ = dx

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 350  :     Word16 i;
; 351  : 
; 352  :     test (); 
; 353  :     if (bfi == 0)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _gain_pitch$[ebp]
  00007	66 85 d2	 test	 dx, dx
  0000a	75 4c		 jne	 SHORT $LN26@ec_gain_pi

; 354  :     {
; 355  :         test ();
; 356  :         if (prev_bf != 0)

  0000c	66 83 7d 08 00	 cmp	 WORD PTR _prev_bf$[ebp], 0
  00011	74 3e		 je	 SHORT $LN5@ec_gain_pi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00013	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00016	57		 push	 edi
  00017	0f b7 79 0c	 movzx	 edi, WORD PTR [ecx+12]
  0001b	0f bf c7	 movsx	 eax, di
  0001e	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00020	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00026	7e 0c		 jle	 SHORT $LN21@ec_gain_pi

; 80   :     {
; 81   :         Overflow = 1;

  00028	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00032	eb 19		 jmp	 SHORT $LN52@ec_gain_pi
$LN21@ec_gain_pi:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00034	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0003a	7d 0c		 jge	 SHORT $LN19@ec_gain_pi

; 85   :     {
; 86   :         Overflow = 1;

  0003c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;
; 88   :     }
; 89   :     else

  00046	eb 08		 jmp	 SHORT $LN54@ec_gain_pi
$LN19@ec_gain_pi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 359  :             if (sub (*gain_pitch, st->prev_gp) > 0)

  00048	66 85 d2	 test	 dx, dx
  0004b	7e 03		 jle	 SHORT $LN54@ec_gain_pi
$LN52@ec_gain_pi:

; 360  :             {
; 361  :                 *gain_pitch = st->prev_gp;

  0004d	66 89 3e	 mov	 WORD PTR [esi], di
$LN54@ec_gain_pi:
  00050	5f		 pop	 edi
$LN5@ec_gain_pi:

; 362  :             }
; 363  :         }
; 364  :         st->prev_gp = *gain_pitch;                         move16 (); 

  00051	66 8b 06	 mov	 ax, WORD PTR [esi]
  00054	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
$LN26@ec_gain_pi:

; 365  :     }
; 366  :     
; 367  :     st->past_gain_pit = *gain_pitch;                       move16 ();

  00058	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0005b	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0005f	98		 cwde
  00060	2d 00 40 00 00	 sub	 eax, 16384		; 00004000H
  00065	5e		 pop	 esi

; 79   :     if (L_var1 > 0X00007fffL)

  00066	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0006b	7e 0c		 jle	 SHORT $LN37@ec_gain_pi

; 80   :     {
; 81   :         Overflow = 1;

  0006d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00077	eb 18		 jmp	 SHORT $LN53@ec_gain_pi
$LN37@ec_gain_pi:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00079	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0007e	7d 0c		 jge	 SHORT $LN35@ec_gain_pi

; 85   :     {
; 86   :         Overflow = 1;

  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;
; 88   :     }
; 89   :     else

  0008a	eb 0e		 jmp	 SHORT $LN42@ec_gain_pi
$LN35@ec_gain_pi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 370  :     if (sub (st->past_gain_pit, 16384) > 0)  /* if (st->past_gain_pit > 1.0) */

  0008c	66 85 c0	 test	 ax, ax
  0008f	7e 09		 jle	 SHORT $LN42@ec_gain_pi
$LN53@ec_gain_pi:

; 371  :     {
; 372  :         st->past_gain_pit = 16384;                         move16 (); 

  00091	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00096	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax
$LN42@ec_gain_pi:

; 373  :     }
; 374  :     for (i = 1; i < 5; i++)
; 375  :     {
; 376  :         st->pbuf[i - 1] = st->pbuf[i];                     move16 (); 

  0009a	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  0009e	66 89 01	 mov	 WORD PTR [ecx], ax
  000a1	0f b7 41 04	 movzx	 eax, WORD PTR [ecx+4]
  000a5	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  000a9	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  000ad	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  000b1	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  000b5	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 377  :     }
; 378  :     st->pbuf[4] = st->past_gain_pit;                       move16 (); 

  000b9	0f b7 41 0a	 movzx	 eax, WORD PTR [ecx+10]
  000bd	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 379  : }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_ec_gain_pitch_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_exit
_TEXT	SEGMENT
_ec_gain_code_exit PROC					; COMDAT
; _state$ = ecx

; 116  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 117  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@ec_gain_co
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@ec_gain_co

; 118  :       return;
; 119  : 
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 122  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@ec_gain_co:
  0001d	5e		 pop	 esi

; 123  :   
; 124  :   return;
; 125  : }

  0001e	c3		 ret	 0
_ec_gain_code_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code_update
_TEXT	SEGMENT
_prev_bf$ = 8						; size = 2
_gain_code$ = 12					; size = 4
_ec_gain_code_update PROC				; COMDAT
; _st$ = ecx
; _bfi$ = dx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 191  :     Word16 i;
; 192  :     
; 193  :     /* limit gain_code by previous good gain if previous frame was bad */
; 194  :     test ();
; 195  :     if (bfi == 0)

  00004	66 85 d2	 test	 dx, dx
  00007	8b f1		 mov	 esi, ecx
  00009	8b 55 0c	 mov	 edx, DWORD PTR _gain_code$[ebp]
  0000c	75 4c		 jne	 SHORT $LN27@ec_gain_co

; 196  :     {
; 197  : 		test ();
; 198  :         if (prev_bf != 0)

  0000e	66 83 7d 08 00	 cmp	 WORD PTR _prev_bf$[ebp], 0
  00013	74 3e		 je	 SHORT $LN25@ec_gain_co
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00015	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
  00018	57		 push	 edi
  00019	0f b7 7e 0c	 movzx	 edi, WORD PTR [esi+12]
  0001d	0f bf c7	 movsx	 eax, di
  00020	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00022	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00028	7e 0c		 jle	 SHORT $LN20@ec_gain_co

; 80   :     {
; 81   :         Overflow = 1;

  0002a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00034	eb 19		 jmp	 SHORT $LN39@ec_gain_co
$LN20@ec_gain_co:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00036	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0003c	7d 0c		 jge	 SHORT $LN18@ec_gain_co

; 85   :     {
; 86   :         Overflow = 1;

  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;
; 88   :     }
; 89   :     else

  00048	eb 08		 jmp	 SHORT $LN40@ec_gain_co
$LN18@ec_gain_co:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 201  :             if (sub (*gain_code, st->prev_gc) > 0)

  0004a	66 85 c9	 test	 cx, cx
  0004d	7e 03		 jle	 SHORT $LN40@ec_gain_co
$LN39@ec_gain_co:

; 202  :             {
; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  0004f	66 89 3a	 mov	 WORD PTR [edx], di
$LN40@ec_gain_co:
  00052	5f		 pop	 edi
$LN25@ec_gain_co:

; 204  :             }
; 205  :         }
; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  00053	66 8b 02	 mov	 ax, WORD PTR [edx]
  00056	66 89 46 0c	 mov	 WORD PTR [esi+12], ax
$LN27@ec_gain_co:

; 207  :     }
; 208  : 
; 209  :     /* update EC states: previous gain, gain buffer */
; 210  :     st->past_gain_code = *gain_code;                       move16 (); 

  0005a	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  0005d	66 89 4e 0a	 mov	 WORD PTR [esi+10], cx

; 211  :     
; 212  :     for (i = 1; i < 5; i++)
; 213  :     {
; 214  :         st->gbuf[i - 1] = st->gbuf[i];                     move16 (); 

  00061	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  0006c	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00070	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  00074	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  00078	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0007c	66 89 46 06	 mov	 WORD PTR [esi+6], ax

; 215  :     }
; 216  :     st->gbuf[4] = *gain_code;                              move16 (); 

  00080	66 89 4e 08	 mov	 WORD PTR [esi+8], cx
  00084	5e		 pop	 esi

; 217  : 
; 218  :     return;
; 219  : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_ec_gain_code_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_code
_TEXT	SEGMENT
_state$ = 8						; size = 2
_qua_ener_MR122$ = 8					; size = 2
_qua_ener$ = 12						; size = 2
_gain_code$ = 12					; size = 4
_ec_gain_code PROC					; COMDAT
; _st$ = ecx
; _pred_state$ = edx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	8b f1		 mov	 esi, ecx

; 155  :     tmp = gmed_n (st->gbuf,5);                                 move16 ();

  00009	ba 05 00 00 00	 mov	 edx, 5
  0000e	e8 00 00 00 00	 call	 _gmed_n
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00013	0f b7 76 0a	 movzx	 esi, WORD PTR [esi+10]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 155  :     tmp = gmed_n (st->gbuf,5);                                 move16 ();

  00017	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0001a	0f bf c6	 movsx	 eax, si
  0001d	0f bf ca	 movsx	 ecx, dx
  00020	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00022	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00028	7e 0c		 jle	 SHORT $LN13@ec_gain_co

; 80   :     {
; 81   :         Overflow = 1;

  0002a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00034	eb 19		 jmp	 SHORT $LN50@ec_gain_co
$LN13@ec_gain_co:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00036	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0003c	7d 0c		 jge	 SHORT $LN11@ec_gain_co

; 85   :     {
; 86   :         Overflow = 1;

  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00048	eb 07		 jmp	 SHORT $LN18@ec_gain_co
$LN11@ec_gain_co:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 159  :     if (sub (tmp, st->past_gain_code) > 0)

  0004a	66 85 c9	 test	 cx, cx
  0004d	7e 02		 jle	 SHORT $LN18@ec_gain_co
$LN50@ec_gain_co:

; 160  :     {
; 161  :         tmp = st->past_gain_code;                              move16 (); 

  0004f	8b d6		 mov	 edx, esi
$LN18@ec_gain_co:

; 162  :     }
; 163  :     tmp = mult (tmp, cdown[state]);

  00051	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00054	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00055	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?cdown@?1??ec_gain_code@@9@9[eax*2]
  0005d	0f bf c2	 movsx	 eax, dx
  00060	0f af c8	 imul	 ecx, eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00063	c1 f9 0f	 sar	 ecx, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00066	f7 c1 00 00 01
	00		 test	 ecx, 65536		; 00010000H
  0006c	74 06		 je	 SHORT $LN20@ec_gain_co

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0006e	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN20@ec_gain_co:

; 79   :     if (L_var1 > 0X00007fffL)

  00074	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0007a	7e 11		 jle	 SHORT $LN26@ec_gain_co

; 80   :     {
; 81   :         Overflow = 1;

  0007c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00086	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0008b	eb 1c		 jmp	 SHORT $LN23@ec_gain_co
$LN26@ec_gain_co:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0008d	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00093	7d 11		 jge	 SHORT $LN24@ec_gain_co

; 85   :     {
; 86   :         Overflow = 1;

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0009f	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000a4	eb 03		 jmp	 SHORT $LN23@ec_gain_co
$LN24@ec_gain_co:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000a6	0f b7 c9	 movzx	 ecx, cx
$LN23@ec_gain_co:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 164  :     *gain_code = tmp;                                          move16 (); 

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _gain_code$[ebp]

; 165  : 
; 166  :     /* update table of past quantized energies with average of
; 167  :      * current values
; 168  :      */
; 169  :     gc_pred_average_limited(pred_state, &qua_ener_MR122, &qua_ener);

  000ac	8d 55 08	 lea	 edx, DWORD PTR _qua_ener_MR122$[ebp]
  000af	66 89 08	 mov	 WORD PTR [eax], cx
  000b2	8d 45 0c	 lea	 eax, DWORD PTR _qua_ener$[ebp]
  000b5	50		 push	 eax
  000b6	8b cf		 mov	 ecx, edi
  000b8	e8 00 00 00 00	 call	 _gc_pred_average_limited
  000bd	83 c4 04	 add	 esp, 4
  000c0	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 364  :     for (i = 3; i > 0; i--)

  000c3	ba 03 00 00 00	 mov	 edx, 3
  000c8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL35@ec_gain_co:

; 365  :     {
; 366  :         st->past_qua_en[i] = st->past_qua_en[i - 1];             move16 ();

  000d0	0f b7 48 f8	 movzx	 ecx, WORD PTR [eax-8]
  000d4	8d 40 fe	 lea	 eax, DWORD PTR [eax-2]
  000d7	66 89 48 fc	 mov	 WORD PTR [eax-4], cx
  000db	4a		 dec	 edx

; 367  :         st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1]; move16 ();

  000dc	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  000e0	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  000e4	66 85 d2	 test	 dx, dx
  000e7	7f e7		 jg	 SHORT $LL35@ec_gain_co

; 368  :     }
; 369  : 
; 370  :     st->past_qua_en_MR122[0] = qua_ener_MR122;  /*    log2 (qua_err), Q10 */

  000e9	0f b7 45 08	 movzx	 eax, WORD PTR _qua_ener_MR122$[ebp]
  000ed	66 89 47 08	 mov	 WORD PTR [edi+8], ax

; 371  : 	                                                             move16 ();
; 372  :     st->past_qua_en[0] = qua_ener;              /* 20*log10(qua_err), Q10 */

  000f1	0f b7 45 0c	 movzx	 eax, WORD PTR _qua_ener$[ebp]
  000f5	66 89 07	 mov	 WORD PTR [edi], ax
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 171  : }

  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
_ec_gain_code ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
;	COMDAT _ec_gain_pitch_reset
_TEXT	SEGMENT
_ec_gain_pitch_reset PROC				; COMDAT
; _state$ = ecx

; 262  :   Word16 i;
; 263  :   
; 264  :   if (state == (ec_gain_pitchState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN4@ec_gain_pi

; 265  :       fprintf(stderr, "ec_gain_pitch_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 266  :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 275  : }

  0001f	c3		 ret	 0
$LN4@ec_gain_pi:

; 267  :   }
; 268  :   
; 269  :   for(i = 0; i < 5; i++)
; 270  :       state->pbuf[i] = 1640;

  00020	b8 68 06 68 06	 mov	 eax, 107480680		; 06680668H
  00025	89 01		 mov	 DWORD PTR [ecx], eax
  00027	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 271  :   state->past_gain_pit = 0; 
; 272  :   state->prev_gp = 16384;   

  0002a	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  0002f	c7 41 08 68 06
	00 00		 mov	 DWORD PTR [ecx+8], 1640	; 00000668H
  00036	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 273  : 
; 274  :   return 0;

  0003a	33 c0		 xor	 eax, eax

; 275  : }

  0003c	c3		 ret	 0
_ec_gain_pitch_reset ENDP
_TEXT	ENDS
END
