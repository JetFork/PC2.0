; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\syn_filt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Syn_filt
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c
;	COMDAT _Syn_filt
_TEXT	SEGMENT
tv849 = -192						; size = 4
_mem$GSCopy$1$ = -188					; size = 4
tv846 = -184						; size = 4
_yy$1$ = -180						; size = 4
_x$GSCopy$1$ = -176					; size = 4
_y$GSCopy$1$ = -172					; size = 4
tv844 = -168						; size = 4
tv812 = -168						; size = 4
_tmp$ = -164						; size = 160
__$ArrayPad$ = -4					; size = 4
_y$ = 8							; size = 4
_lg$ = 12						; size = 2
_mem$ = 16						; size = 4
_update$ = 20						; size = 2
_Syn_filt PROC						; COMDAT
; _a$ = ecx
; _x$ = edx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _mem$[ebp]
  00017	56		 push	 esi

; 60   :     Word16 i, j;
; 61   :     Word32 s;
; 62   :     Word16 tmp[80];   /* This is usually done by memory allocation (lg+M) */
; 63   :     Word16 *yy;
; 64   : 
; 65   :     /* Copy mem[] to yy[] */
; 66   : 
; 67   :     yy = tmp;                           move16 (); 
; 68   : 
; 69   :     for (i = 0; i < M; i++)
; 70   :     {
; 71   :         *yy++ = mem[i];                 move16 (); 
; 72   :     } 
; 73   : 
; 74   :     /* Do the filtering. */
; 75   : 
; 76   :     for (i = 0; i < lg; i++)

  00018	66 8b 75 0c	 mov	 si, WORD PTR _lg$[ebp]
  0001c	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv812[ebp], 0
  00026	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00029	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]
  0002d	89 85 6c ff ff
	ff		 mov	 DWORD PTR _tmp$[ebp+16], eax
  00033	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _tmp$[ebp+20]
  00039	57		 push	 edi
  0003a	8b 7d 08	 mov	 edi, DWORD PTR _y$[ebp]
  0003d	89 95 50 ff ff
	ff		 mov	 DWORD PTR _x$GSCopy$1$[ebp], edx
  00043	89 bd 54 ff ff
	ff		 mov	 DWORD PTR _y$GSCopy$1$[ebp], edi
  00049	89 9d 44 ff ff
	ff		 mov	 DWORD PTR _mem$GSCopy$1$[ebp], ebx
  0004f	f3 0f 7f 85 5c
	ff ff ff	 movdqu	 XMMWORD PTR _tmp$[ebp], xmm0
  00057	89 85 4c ff ff
	ff		 mov	 DWORD PTR _yy$1$[ebp], eax
  0005d	66 39 b5 58 ff
	ff ff		 cmp	 WORD PTR tv812[ebp], si
  00064	0f 8d 4d 01 00
	00		 jge	 $LN11@Syn_filt
  0006a	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  0006d	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00070	0f b7 ce	 movzx	 ecx, si
  00073	89 9d 40 ff ff
	ff		 mov	 DWORD PTR tv849[ebp], ebx
  00079	89 bd 48 ff ff
	ff		 mov	 DWORD PTR tv846[ebp], edi
  0007f	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv844[ebp], ecx
  00085	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL13@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00090	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00093	0f af d3	 imul	 edx, ebx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00096	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  0009c	74 04		 je	 SHORT $LN24@Syn_filt

; 488  :     {
; 489  :         L_var_out *= 2;

  0009e	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  000a0	eb 0f		 jmp	 SHORT $LN23@Syn_filt
$LN24@Syn_filt:

; 492  :     {
; 493  :         Overflow = 1;

  000a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000ac	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN23@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c

; 78   :         s = L_mult (x[i], a[0]);

  000b1	8b f7		 mov	 esi, edi
  000b3	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  000b8	8d 78 fe	 lea	 edi, DWORD PTR [eax-2]
  000bb	eb 03 8d 49 00	 npad	 5
$LL10@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000c0	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  000c3	0f bf 06	 movsx	 eax, WORD PTR [esi]
  000c6	0f af c8	 imul	 ecx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000c9	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  000cf	74 04		 je	 SHORT $LN30@Syn_filt

; 488  :     {
; 489  :         L_var_out *= 2;

  000d1	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  000d3	eb 0f		 jmp	 SHORT $LN29@Syn_filt
$LN30@Syn_filt:

; 492  :     {
; 493  :         Overflow = 1;

  000d5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000df	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN29@Syn_filt:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  000e4	8b c2		 mov	 eax, edx
  000e6	2b c1		 sub	 eax, ecx

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  000e8	33 ca		 xor	 ecx, edx
  000ea	79 1c		 jns	 SHORT $LN33@Syn_filt

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  000ec	8b c8		 mov	 ecx, eax
  000ee	33 ca		 xor	 ecx, edx
  000f0	79 16		 jns	 SHORT $LN33@Syn_filt

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  000f2	33 c0		 xor	 eax, eax

; 990  :             Overflow = 1;

  000f4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000fe	85 d2		 test	 edx, edx
  00100	0f 98 c0	 sets	 al
  00103	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
$LN33@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c

; 79   :         for (j = 1; j <= M; j++)

  00108	83 ef 02	 sub	 edi, 2
  0010b	83 c6 02	 add	 esi, 2

; 80   :         {
; 81   :             s = L_msu (s, a[j], yy[-j]);

  0010e	8b d0		 mov	 edx, eax
  00110	4b		 dec	 ebx
  00111	75 ad		 jne	 SHORT $LL10@Syn_filt

; 82   :         }
; 83   :         s = L_shl (s, 3);

  00113	8d 4b 03	 lea	 ecx, DWORD PTR [ebx+3]
$LL45@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00116	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0011b	7f 18		 jg	 SHORT $LN79@Syn_filt

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0011d	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  00122	7c 0a		 jl	 SHORT $LN80@Syn_filt

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00124	49		 dec	 ecx
  00125	03 c0		 add	 eax, eax
  00127	66 85 c9	 test	 cx, cx
  0012a	7f ea		 jg	 SHORT $LL45@Syn_filt

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0012c	eb 16		 jmp	 SHORT $LN40@Syn_filt
$LN80@Syn_filt:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0012e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00133	eb 05		 jmp	 SHORT $LN102@Syn_filt
$LN79@Syn_filt:

; 1360 :                 L_var_out = MAX_32;

  00135	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN102@Syn_filt:

; 1358 :             {
; 1359 :                 Overflow = 1;

  0013a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN40@Syn_filt:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00144	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0014a	85 c0		 test	 eax, eax
  0014c	78 1d		 js	 SHORT $LN59@Syn_filt

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0014e	8b ca		 mov	 ecx, edx
  00150	33 c8		 xor	 ecx, eax
  00152	79 17		 jns	 SHORT $LN59@Syn_filt

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00154	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00156	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00160	85 c0		 test	 eax, eax
  00162	0f 98 c2	 sets	 dl
  00165	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN59@Syn_filt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c

; 84   :         *yy++ = round (s);              move16 (); 

  0016b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _yy$1$[ebp]
  00171	8b 9d 40 ff ff
	ff		 mov	 ebx, DWORD PTR tv849[ebp]
  00177	8b bd 48 ff ff
	ff		 mov	 edi, DWORD PTR tv846[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0017d	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\syn_filt.c

; 84   :         *yy++ = round (s);              move16 (); 

  00180	66 89 10	 mov	 WORD PTR [eax], dx
  00183	83 c0 02	 add	 eax, 2
  00186	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _x$GSCopy$1$[ebp]
  0018c	83 c2 02	 add	 edx, 2
  0018f	89 85 4c ff ff
	ff		 mov	 DWORD PTR _yy$1$[ebp], eax
  00195	ff 8d 58 ff ff
	ff		 dec	 DWORD PTR tv844[ebp]
  0019b	89 95 50 ff ff
	ff		 mov	 DWORD PTR _x$GSCopy$1$[ebp], edx
  001a1	0f 85 e9 fe ff
	ff		 jne	 $LL13@Syn_filt
  001a7	8b 9d 44 ff ff
	ff		 mov	 ebx, DWORD PTR _mem$GSCopy$1$[ebp]
  001ad	66 8b 75 0c	 mov	 si, WORD PTR _lg$[ebp]
  001b1	8b bd 54 ff ff
	ff		 mov	 edi, DWORD PTR _y$GSCopy$1$[ebp]
$LN11@Syn_filt:

; 85   :     }
; 86   : 
; 87   :     for (i = 0; i < lg; i++)

  001b7	33 c0		 xor	 eax, eax
  001b9	66 3b c6	 cmp	 ax, si
  001bc	7d 16		 jge	 SHORT $LN7@Syn_filt
  001be	0f b7 ce	 movzx	 ecx, si
  001c1	8d b5 70 ff ff
	ff		 lea	 esi, DWORD PTR _tmp$[ebp+20]
  001c7	d1 e9		 shr	 ecx, 1
  001c9	f3 a5		 rep movsd
  001cb	13 c9		 adc	 ecx, ecx
  001cd	66 f3 a5	 rep movsw
  001d0	66 8b 75 0c	 mov	 si, WORD PTR _lg$[ebp]
$LN7@Syn_filt:

; 88   :     {
; 89   :         y[i] = tmp[i + M];              move16 (); 
; 90   :     }
; 91   : 
; 92   :     /* Update of memory if update==1 */
; 93   : 
; 94   :     test (); 
; 95   :     if (update != 0)

  001d4	66 39 45 14	 cmp	 WORD PTR _update$[ebp], ax
  001d8	74 25		 je	 SHORT $LN1@Syn_filt

; 96   :     {
; 97   :         for (i = 0; i < M; i++)

  001da	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _y$GSCopy$1$[ebp]
  001e0	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  001e5	0f bf c6	 movsx	 eax, si
  001e8	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  001eb	83 c1 ec	 add	 ecx, -20		; ffffffecH
  001ee	8b ff		 npad	 2
$LL3@Syn_filt:

; 98   :         {
; 99   :             mem[i] = y[lg - M + i];     move16 (); 

  001f0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  001f3	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  001f6	66 89 03	 mov	 WORD PTR [ebx], ax
  001f9	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  001fc	4a		 dec	 edx
  001fd	75 f1		 jne	 SHORT $LL3@Syn_filt
$LN1@Syn_filt:

; 100  :         }
; 101  :     }
; 102  :     return;
; 103  : }

  001ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	33 cd		 xor	 ecx, ebp
  00206	5b		 pop	 ebx
  00207	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020c	8b e5		 mov	 esp, ebp
  0020e	5d		 pop	 ebp
  0020f	c3		 ret	 0
_Syn_filt ENDP
_TEXT	ENDS
END
