; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\sqrt_l.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_table	DW	04000H
	DW	041f8H
	DW	043e2H
	DW	045beH
	DW	0478eH
	DW	04952H
	DW	04b0cH
	DW	04cbcH
	DW	04e62H
	DW	05000H
	DW	05196H
	DW	05323H
	DW	054aaH
	DW	0562aH
	DW	057a3H
	DW	05916H
	DW	05a82H
	DW	05beaH
	DW	05d4cH
	DW	05ea8H
	DW	06000H
	DW	06153H
	DW	062a1H
	DW	063ecH
	DW	06531H
	DW	06673H
	DW	067b1H
	DW	068ebH
	DW	06a22H
	DW	06b55H
	DW	06c84H
	DW	06db1H
	DW	06edaH
	DW	07000H
	DW	07123H
	DW	07243H
	DW	07361H
	DW	0747bH
	DW	07593H
	DW	076a9H
	DW	077bcH
	DW	078ccH
	DW	079daH
	DW	07ae6H
	DW	07befH
	DW	07cf7H
	DW	07dfcH
	DW	07effH
	DW	07fffH
PUBLIC	_sqrt_l_exp
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c
;	COMDAT _sqrt_l_exp
_TEXT	SEGMENT
_sqrt_l_exp PROC					; COMDAT
; _L_x$ = ecx
; _exp$ = edx

; 62   : {

  00000	53		 push	 ebx
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b da		 mov	 ebx, edx

; 63   :     /*
; 64   :           y = sqrt(x)
; 65   : 
; 66   :           x = f * 2^-e,   0.5 <= f < 1   (normalization)
; 67   : 
; 68   :           y = sqrt(f) * 2^(-e/2)  
; 69   : 
; 70   :           a) e = 2k   --> y = sqrt(f)   * 2^-k  (k = e div 2,
; 71   :                                                  0.707 <= sqrt(f) < 1)
; 72   :           b) e = 2k+1 --> y = sqrt(f/2) * 2^-k  (k = e div 2,
; 73   :                                                  0.5 <= sqrt(f/2) < 0.707)
; 74   :      */
; 75   :     
; 76   :     
; 77   :     Word16 e, i, a, tmp;
; 78   :     Word32 L_y;
; 79   : 
; 80   :     test (); 
; 81   :     if (L_x <= (Word32) 0)

  00006	85 ff		 test	 edi, edi
  00008	7f 08		 jg	 SHORT $LN1@sqrt_l_exp

; 82   :     {
; 83   :         *exp = 0;               move16 ();

  0000a	33 c0		 xor	 eax, eax
  0000c	5f		 pop	 edi
  0000d	66 89 03	 mov	 WORD PTR [ebx], ax
  00010	5b		 pop	 ebx

; 103  :        
; 104  :     /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
; 105  : 
; 106  :     return (L_y);
; 107  : }

  00011	c3		 ret	 0
$LN1@sqrt_l_exp:

; 87   :     e = norm_l (L_x) & 0xFFFE;  logic16 (); /* get next lower EVEN norm. exp  */

  00012	8b c7		 mov	 eax, edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00014	83 ff ff	 cmp	 edi, -1
  00017	75 05		 jne	 SHORT $LN13@sqrt_l_exp

; 2116 :         {
; 2117 :             var_out = 31;

  00019	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]

; 2118 :         }
; 2119 :         else

  0001c	eb 14		 jmp	 SHORT $LN8@sqrt_l_exp
$LN13@sqrt_l_exp:

; 2120 :         {
; 2121 :             if (L_var1 < 0)
; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;
; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  0001e	33 c9		 xor	 ecx, ecx
  00020	81 ff 00 00 00
	40		 cmp	 edi, 1073741824		; 40000000H
  00026	7d 0a		 jge	 SHORT $LN8@sqrt_l_exp
$LL10@sqrt_l_exp:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00028	03 c0		 add	 eax, eax
  0002a	41		 inc	 ecx
  0002b	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00030	7c f6		 jl	 SHORT $LL10@sqrt_l_exp
$LN8@sqrt_l_exp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 87   :     e = norm_l (L_x) & 0xFFFE;  logic16 (); /* get next lower EVEN norm. exp  */

  00032	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00035	56		 push	 esi
  00036	0f b7 f1	 movzx	 esi, cx

; 88   :     L_x = L_shl (L_x, e);                   /* L_x is normalized to [0.25..1) */

  00039	8b cf		 mov	 ecx, edi
  0003b	8b d6		 mov	 edx, esi
  0003d	e8 00 00 00 00	 call	 _L_shl
  00042	8b c8		 mov	 ecx, eax

; 89   :     *exp = e;                   move16 ();  /* return 2*exponent (or Q1)      */

  00044	66 89 33	 mov	 WORD PTR [ebx], si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  00047	85 c9		 test	 ecx, ecx
  00049	79 09		 jns	 SHORT $LN23@sqrt_l_exp

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0004b	f7 d1		 not	 ecx
  0004d	c1 f9 09	 sar	 ecx, 9
  00050	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  00052	eb 03		 jmp	 SHORT $LN22@sqrt_l_exp
$LN23@sqrt_l_exp:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00054	c1 f9 09	 sar	 ecx, 9
$LN22@sqrt_l_exp:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);
; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;
; 304  :         }
; 305  :         else
; 306  :         {
; 307  :             var_out = extract_l (result);
; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)
; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);
; 378  :             }
; 379  :             else
; 380  :             {
; 381  :                 var_out = var1 >> var2;
; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;
; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)
; 488  :     {
; 489  :         L_var_out *= 2;
; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;
; 494  :         L_var_out = MAX_32;
; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  00057	8b c1		 mov	 eax, ecx
  00059	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 92   :     i = extract_h (L_x);            /* Extract b25-b31, 16 <= i <= 63 because

  0005c	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  0005f	85 c9		 test	 ecx, ecx
  00061	79 08		 jns	 SHORT $LN34@sqrt_l_exp

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00063	f7 d1		 not	 ecx
  00065	d1 f9		 sar	 ecx, 1
  00067	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  00069	eb 02		 jmp	 SHORT $LN33@sqrt_l_exp
$LN34@sqrt_l_exp:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0006b	d1 f9		 sar	 ecx, 1
$LN33@sqrt_l_exp:

; 186  :     L_diff = (Word32) var1 - var2;

  0006d	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 96   :     a = a & (Word16) 0x7fff;    logic16 (); 

  0006e	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00074	83 e8 10	 sub	 eax, 16			; 00000010H

; 79   :     if (L_var1 > 0X00007fffL)

  00077	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0007c	7e 11		 jle	 SHORT $LN51@sqrt_l_exp

; 80   :     {
; 81   :         Overflow = 1;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00088	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0008d	eb 1b		 jmp	 SHORT $LN48@sqrt_l_exp
$LN51@sqrt_l_exp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0008f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00094	7d 11		 jge	 SHORT $LN49@sqrt_l_exp

; 85   :     {
; 86   :         Overflow = 1;

  00096	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000a0	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000a5	eb 03		 jmp	 SHORT $LN48@sqrt_l_exp
$LN49@sqrt_l_exp:

; 91   :         var_out = extract_l (L_var1);

  000a7	0f b7 c0	 movzx	 eax, ax
$LN48@sqrt_l_exp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 100  :     L_y = L_deposit_h (table[i]);           /* table[i] << 16                 */

  000aa	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1675 :     L_var_out = (Word32) var1 << 16;

  000ab	0f bf 14 45 00
	00 00 00	 movsx	 edx, WORD PTR _table[eax*2]

; 186  :     L_diff = (Word32) var1 - var2;

  000b3	0f bf 04 45 02
	00 00 00	 movsx	 eax, WORD PTR _table[eax*2+2]

; 1675 :     L_var_out = (Word32) var1 << 16;

  000bb	8b f2		 mov	 esi, edx

; 186  :     L_diff = (Word32) var1 - var2;

  000bd	2b d0		 sub	 edx, eax

; 1675 :     L_var_out = (Word32) var1 << 16;

  000bf	c1 e6 10	 shl	 esi, 16			; 00000010H

; 79   :     if (L_var1 > 0X00007fffL)

  000c2	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  000c8	7e 1e		 jle	 SHORT $LN63@sqrt_l_exp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  000ca	51		 push	 ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 82   :         var_out = MAX_16;

  000cb	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  000d0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 _L_msu
  000e1	83 c4 04	 add	 esp, 4
  000e4	5e		 pop	 esi
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx

; 103  :        
; 104  :     /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
; 105  : 
; 106  :     return (L_y);
; 107  : }

  000e7	c3		 ret	 0
$LN63@sqrt_l_exp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000e8	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  000ee	7d 1e		 jge	 SHORT $LN61@sqrt_l_exp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  000f0	51		 push	 ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 87   :         var_out = MIN_16;

  000f1	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H
  000f6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 _L_msu
  00107	83 c4 04	 add	 esp, 4
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi
  0010c	5b		 pop	 ebx

; 103  :        
; 104  :     /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
; 105  : 
; 106  :     return (L_y);
; 107  : }

  0010d	c3		 ret	 0
$LN61@sqrt_l_exp:

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  0010e	51		 push	 ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  0010f	0f b7 d2	 movzx	 edx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\sqrt_l.c

; 102  :     L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */

  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 _L_msu
  00119	83 c4 04	 add	 esp, 4
  0011c	5e		 pop	 esi
  0011d	5f		 pop	 edi
  0011e	5b		 pop	 ebx

; 103  :        
; 104  :     /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
; 105  : 
; 106  :     return (L_y);
; 107  : }

  0011f	c3		 ret	 0
_sqrt_l_exp ENDP
_TEXT	ENDS
END
