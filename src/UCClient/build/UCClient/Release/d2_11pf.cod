; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d2_11pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_decode_2i40_11bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c
;	COMDAT _decode_2i40_11bits
_TEXT	SEGMENT
_j$1$ = -16						; size = 4
tv482 = -16						; size = 4
tv1021 = -12						; size = 4
_result$1$ = -8						; size = 4
_pos$ = -8						; size = 4
tv1001 = -4						; size = 4
_cod$ = 8						; size = 4
_decode_2i40_11bits PROC				; COMDAT
; _sign$ = ecx
; _index$ = edx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 60   :     Word16 i, j;
; 61   :     Word16 pos[NB_PULSE];
; 62   : 
; 63   :     /* Decode the positions */
; 64   : 
; 65   :     j = index & 1;                                       logic16 ();

  00008	8b f2		 mov	 esi, edx
  0000a	83 e6 01	 and	 esi, 1
  0000d	89 75 f0	 mov	 DWORD PTR _j$1$[ebp], esi
  00010	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00011	66 85 d2	 test	 dx, dx
  00014	79 0e		 jns	 SHORT $LN16@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00016	0f bf c2	 movsx	 eax, dx
  00019	f7 d0		 not	 eax
  0001b	d1 f8		 sar	 eax, 1
  0001d	f7 d0		 not	 eax
  0001f	0f b7 d0	 movzx	 edx, ax

; 378  :             }
; 379  :             else

  00022	eb 06		 jmp	 SHORT $LN15@decode_2i4
$LN16@decode_2i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00024	66 d1 fa	 sar	 dx, 1
  00027	0f b7 d2	 movzx	 edx, dx
$LN15@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 67   :     i = index & 7;                                       logic16 ();

  0002a	8b fa		 mov	 edi, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0002c	c7 45 fc ff 7f
	00 00		 mov	 DWORD PTR tv1001[ebp], 32767 ; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 67   :     i = index & 7;                                       logic16 ();

  00033	83 e7 07	 and	 edi, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00036	bb 00 80 ff ff	 mov	 ebx, -32768		; ffff8000H
  0003b	0f bf c7	 movsx	 eax, di
  0003e	89 45 f4	 mov	 DWORD PTR tv1021[ebp], eax
  00041	c1 e0 02	 shl	 eax, 2
  00044	89 45 f8	 mov	 DWORD PTR _result$1$[ebp], eax
  00047	98		 cwde
  00048	39 45 f8	 cmp	 DWORD PTR _result$1$[ebp], eax
  0004b	74 15		 je	 SHORT $LN29@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0004d	66 85 ff	 test	 di, di
  00050	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0005a	8b c3		 mov	 eax, ebx
  0005c	0f 4f 45 fc	 cmovg	 eax, DWORD PTR tv1001[ebp]

; 304  :         }
; 305  :         else

  00060	eb 03		 jmp	 SHORT $LN218@decode_2i4
$LN29@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00062	8b 45 f8	 mov	 eax, DWORD PTR _result$1$[ebp]
$LN218@decode_2i4:
  00065	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00068	98		 cwde
  00069	03 45 f4	 add	 eax, DWORD PTR tv1021[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  0006c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00071	7e 11		 jle	 SHORT $LN42@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00073	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0007d	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00082	eb 18		 jmp	 SHORT $LN39@decode_2i4
$LN42@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00084	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00089	7d 0e		 jge	 SHORT $LN40@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  0008b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00095	8b c3		 mov	 eax, ebx

; 88   :     }
; 89   :     else

  00097	eb 03		 jmp	 SHORT $LN39@decode_2i4
$LN40@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00099	0f b7 c0	 movzx	 eax, ax
$LN39@decode_2i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0009c	98		 cwde
  0009d	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0009e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000a3	7e 11		 jle	 SHORT $LN52@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  000a5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000af	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  000b4	eb 18		 jmp	 SHORT $LN49@decode_2i4
$LN52@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000b6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000bb	7d 0e		 jge	 SHORT $LN50@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  000bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000c7	8b fb		 mov	 edi, ebx

; 88   :     }
; 89   :     else

  000c9	eb 03		 jmp	 SHORT $LN49@decode_2i4
$LN50@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000cb	0f b7 f8	 movzx	 edi, ax
$LN49@decode_2i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000ce	0f bf f6	 movsx	 esi, si
  000d1	03 f6		 add	 esi, esi

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000d3	0f bf c6	 movsx	 eax, si
  000d6	3b f0		 cmp	 esi, eax
  000d8	74 1a		 je	 SHORT $LN60@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  000da	66 83 7d f0 00	 cmp	 WORD PTR _j$1$[ebp], 0
  000df	8b c3		 mov	 eax, ebx
  000e1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000eb	0f 4f 45 fc	 cmovg	 eax, DWORD PTR tv1001[ebp]
  000ef	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  000f2	eb 03		 jmp	 SHORT $LN57@decode_2i4
$LN60@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000f4	0f b7 c6	 movzx	 eax, si
$LN57@decode_2i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  000f7	0f bf f0	 movsx	 esi, ax
  000fa	0f bf c7	 movsx	 eax, di
  000fd	03 f0		 add	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  000ff	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00105	7e 11		 jle	 SHORT $LN73@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00107	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00111	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00116	eb 15		 jmp	 SHORT $LN70@decode_2i4
$LN73@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00118	3b f3		 cmp	 esi, ebx
  0011a	7d 0e		 jge	 SHORT $LN71@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  0011c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00126	8b c3		 mov	 eax, ebx

; 88   :     }
; 89   :     else

  00128	eb 03		 jmp	 SHORT $LN70@decode_2i4
$LN71@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0012a	0f b7 c6	 movzx	 eax, si
$LN70@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 72   :     pos[0] = add(i, j);                                  move16 ();

  0012d	66 89 45 f8	 mov	 WORD PTR _pos$[ebp], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00131	66 85 d2	 test	 dx, dx
  00134	79 0f		 jns	 SHORT $LN81@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00136	0f bf c2	 movsx	 eax, dx
  00139	f7 d0		 not	 eax
  0013b	c1 f8 03	 sar	 eax, 3
  0013e	f7 d0		 not	 eax
  00140	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  00143	eb 07		 jmp	 SHORT $LN80@decode_2i4
$LN81@decode_2i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00145	66 c1 fa 03	 sar	 dx, 3
  00149	0f b7 c2	 movzx	 eax, dx
$LN80@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 75   :     j = index & 3;                                       logic16 ();

  0014c	8b f0		 mov	 esi, eax
  0014e	83 e6 03	 and	 esi, 3
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00151	66 85 c0	 test	 ax, ax
  00154	79 0a		 jns	 SHORT $LN92@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00156	98		 cwde
  00157	f7 d0		 not	 eax
  00159	c1 f8 02	 sar	 eax, 2
  0015c	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0015e	eb 04		 jmp	 SHORT $LN219@decode_2i4
$LN92@decode_2i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00160	66 c1 f8 02	 sar	 ax, 2
$LN219@decode_2i4:
  00164	0f b7 d0	 movzx	 edx, ax

; 186  :     L_diff = (Word32) var1 - var2;

  00167	0f bf c6	 movsx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 77   :     i = index & 7;                                       logic16 ();

  0016a	83 e2 07	 and	 edx, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0016d	89 45 f0	 mov	 DWORD PTR tv482[ebp], eax
  00170	83 c0 fd	 add	 eax, -3			; fffffffdH

; 79   :     if (L_var1 > 0X00007fffL)

  00173	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00178	7f 7d		 jg	 SHORT $LN220@decode_2i4

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0017a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0017f	7c 76		 jl	 SHORT $LN220@decode_2i4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 80   : 	if (sub(j, 3) == 0)

  00181	66 85 c0	 test	 ax, ax
  00184	75 7b		 jne	 SHORT $LN10@decode_2i4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00186	0f bf fa	 movsx	 edi, dx
  00189	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00190	0f bf c6	 movsx	 eax, si
  00193	3b f0		 cmp	 esi, eax
  00195	74 16		 je	 SHORT $LN117@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00197	66 85 d2	 test	 dx, dx
  0019a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001a4	0f 4f 5d fc	 cmovg	 ebx, DWORD PTR tv1001[ebp]
  001a8	0f b7 c3	 movzx	 eax, bx

; 304  :         }
; 305  :         else

  001ab	eb 03		 jmp	 SHORT $LN114@decode_2i4
$LN117@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  001ad	0f b7 c6	 movzx	 eax, si
$LN114@decode_2i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001b0	98		 cwde
  001b1	03 c7		 add	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  001b3	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001b8	7e 18		 jle	 SHORT $LN130@decode_2i4

; 82   :         var_out = MAX_16;

  001ba	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001bf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001c9	98		 cwde
  001ca	83 c0 04	 add	 eax, 4

; 82   :         var_out = MAX_16;

  001cd	e9 93 00 00 00	 jmp	 $LN221@decode_2i4
$LN130@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001d2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001d7	7d 15		 jge	 SHORT $LN128@decode_2i4

; 87   :         var_out = MIN_16;

  001d9	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001e8	98		 cwde
  001e9	83 c0 04	 add	 eax, 4

; 82   :         var_out = MAX_16;

  001ec	eb 77		 jmp	 SHORT $LN221@decode_2i4
$LN128@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  001ee	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001f1	98		 cwde
  001f2	83 c0 04	 add	 eax, 4

; 82   :         var_out = MAX_16;

  001f5	eb 6e		 jmp	 SHORT $LN221@decode_2i4
$LN220@decode_2i4:

; 85   :     {
; 86   :         Overflow = 1;

  001f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN10@decode_2i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00201	0f bf fa	 movsx	 edi, dx
  00204	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0020b	0f bf c6	 movsx	 eax, si
  0020e	3b f0		 cmp	 esi, eax
  00210	74 16		 je	 SHORT $LN150@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00212	66 85 d2	 test	 dx, dx
  00215	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0021f	0f 4f 5d fc	 cmovg	 ebx, DWORD PTR tv1001[ebp]
  00223	0f b7 c3	 movzx	 eax, bx

; 304  :         }
; 305  :         else

  00226	eb 03		 jmp	 SHORT $LN147@decode_2i4
$LN150@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00228	0f b7 c6	 movzx	 eax, si
$LN147@decode_2i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0022b	98		 cwde
  0022c	03 c7		 add	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  0022e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00233	7e 11		 jle	 SHORT $LN163@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00235	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0023f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00244	eb 1b		 jmp	 SHORT $LN160@decode_2i4
$LN163@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00246	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0024b	7d 11		 jge	 SHORT $LN161@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  0024d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00257	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0025c	eb 03		 jmp	 SHORT $LN160@decode_2i4
$LN161@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0025e	0f b7 c0	 movzx	 eax, ax
$LN160@decode_2i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00261	98		 cwde
  00262	03 45 f0	 add	 eax, DWORD PTR tv482[ebp]
$LN221@decode_2i4:

; 79   :     if (L_var1 > 0X00007fffL)

  00265	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0026a	7e 11		 jle	 SHORT $LN173@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  0026c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00276	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0027b	eb 1b		 jmp	 SHORT $LN170@decode_2i4
$LN173@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0027d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00282	7d 11		 jge	 SHORT $LN171@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  00284	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0028e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00293	eb 03		 jmp	 SHORT $LN170@decode_2i4
$LN171@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00295	0f b7 c0	 movzx	 eax, ax
$LN170@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 94   :         cod[i] = 0;                                      move16 ();

  00298	8b 7d 08	 mov	 edi, DWORD PTR _cod$[ebp]

; 95   :     }
; 96   : 
; 97   :     for (j = 0; j < NB_PULSE; j++) {

  0029b	8d 55 f8	 lea	 edx, DWORD PTR _pos$[ebp]
  0029e	0f 57 c0	 xorps	 xmm0, xmm0
  002a1	66 89 45 fa	 mov	 WORD PTR _pos$[ebp+2], ax
  002a5	bb 02 00 00 00	 mov	 ebx, 2
  002aa	f3 0f 7f 07	 movdqu	 XMMWORD PTR [edi], xmm0
  002ae	f3 0f 7f 47 10	 movdqu	 XMMWORD PTR [edi+16], xmm0
  002b3	f3 0f 7f 47 20	 movdqu	 XMMWORD PTR [edi+32], xmm0
  002b8	f3 0f 7f 47 30	 movdqu	 XMMWORD PTR [edi+48], xmm0
  002bd	f3 0f 7f 47 40	 movdqu	 XMMWORD PTR [edi+64], xmm0
$LL5@decode_2i4:

; 98   :         i = sign & 1;                                    logic16 ();

  002c2	8b f1		 mov	 esi, ecx
  002c4	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  002c7	66 85 c9	 test	 cx, cx
  002ca	79 0e		 jns	 SHORT $LN185@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  002cc	0f bf c1	 movsx	 eax, cx
  002cf	f7 d0		 not	 eax
  002d1	d1 f8		 sar	 eax, 1
  002d3	f7 d0		 not	 eax
  002d5	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  002d8	eb 06		 jmp	 SHORT $LN184@decode_2i4
$LN185@decode_2i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  002da	66 d1 f9	 sar	 cx, 1
  002dd	0f b7 c1	 movzx	 eax, cx
$LN184@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_11pf.c

; 99   :         sign = shr(sign, 1);

  002e0	0f b7 c8	 movzx	 ecx, ax

; 100  : 
; 101  :         test ();
; 102  :         if (i != 0) {

  002e3	66 85 f6	 test	 si, si

; 103  :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  002e6	0f bf 02	 movsx	 eax, WORD PTR [edx]
  002e9	be ff 1f 00 00	 mov	 esi, 8191		; 00001fffH
  002ee	75 05		 jne	 SHORT $LN222@decode_2i4

; 104  :         } else {
; 105  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  002f0	be 00 e0 ff ff	 mov	 esi, -8192		; ffffe000H
$LN222@decode_2i4:

; 95   :     }
; 96   : 
; 97   :     for (j = 0; j < NB_PULSE; j++) {

  002f5	83 c2 02	 add	 edx, 2

; 104  :         } else {
; 105  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  002f8	66 89 34 47	 mov	 WORD PTR [edi+eax*2], si
  002fc	4b		 dec	 ebx
  002fd	75 c3		 jne	 SHORT $LL5@decode_2i4
  002ff	5f		 pop	 edi
  00300	5e		 pop	 esi
  00301	5b		 pop	 ebx

; 106  :         }
; 107  :     }
; 108  : 
; 109  :     return;
; 110  : }

  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
_decode_2i40_11bits ENDP
_TEXT	ENDS
END
