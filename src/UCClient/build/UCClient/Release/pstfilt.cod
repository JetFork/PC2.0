; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\pstfilt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CG@ILBBKIP@Post_Filter_reset?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0CF@BGIDGKEK@Post_Filter_init?3?5invalid?5parame@ ; `string'
PUBLIC	??_C@_0DC@EBNJDLEA@Post_Filter_init?3?5can?5not?5malloc@ ; `string'
;	COMDAT ??_C@_0DC@EBNJDLEA@Post_Filter_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@EBNJDLEA@Post_Filter_init?3?5can?5not?5malloc@ DB 'Post_Filter_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BGIDGKEK@Post_Filter_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@BGIDGKEK@Post_Filter_init?3?5invalid?5parame@ DB 'Post_Filter_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ILBBKIP@Post_Filter_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@ILBBKIP@Post_Filter_reset?3?5invalid?5param@ DB 'Post_Filter_re'
	DB	'set: invalid parameter', 0aH, 00H		; `string'
	ORG $+6
_gamma4_MR122 DW 06000H
	DW	04800H
	DW	03600H
	DW	02880H
	DW	01e60H
	DW	016c8H
	DW	01116H
	DW	0cd1H
	DW	099dH
	DW	0736H
	ORG $+6
_gamma3	DW	04666H
	DW	026b8H
	DW	0154bH
	DW	0bb6H
	DW	0671H
	DW	038bH
	DW	01f3H
	DW	0112H
	DW	097H
	DW	053H
	ORG $+6
_gamma3_MR122 DW 0599aH
	DW	03eb9H
	DW	02be8H
	DW	01ebcH
	DW	01584H
	DW	0f10H
	DW	0a8bH
	DW	0761H
	DW	052aH
	DW	039dH
	ORG $+6
_gamma4	DW	0599aH
	DW	03eb9H
	DW	02be8H
	DW	01ebcH
	DW	01584H
	DW	0f10H
	DW	0a8bH
	DW	0761H
	DW	052aH
	DW	039dH
PUBLIC	_Post_Filter_init
PUBLIC	_Post_Filter
PUBLIC	_Post_Filter_exit
PUBLIC	_Post_Filter_reset
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
;	COMDAT _Post_Filter_reset
_TEXT	SEGMENT
_Post_Filter_reset PROC					; COMDAT
; _state$ = ecx

; 131  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 132  :   if (state == (Post_FilterState *) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN1@Post_Filte

; 133  :       fprintf(stderr, "Post_Filter_reset: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ILBBKIP@Post_Filter_reset?3?5invalid?5param@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 134  :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 144  : }

  00023	c3		 ret	 0
$LN1@Post_Filte:
  00024	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00027	33 c0		 xor	 eax, eax
  00029	f3 0f 7f 46 50	 movdqu	 XMMWORD PTR [esi+80], xmm0
  0002e	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  00035	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  0003a	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0003e	57		 push	 edi
  0003f	f3 0f 7f 46 10	 movdqu	 XMMWORD PTR [esi+16], xmm0

; 42   :     for (i = 0; i < L; i++)

  00044	8d 7e 6c	 lea	 edi, DWORD PTR [esi+108]

; 44   :         x[i] = 0;               move16 (); 

  00047	f3 0f 7f 46 20	 movdqu	 XMMWORD PTR [esi+32], xmm0
  0004c	f3 0f 7f 46 30	 movdqu	 XMMWORD PTR [esi+48], xmm0
  00051	f3 0f 7f 46 40	 movdqu	 XMMWORD PTR [esi+64], xmm0
  00056	f3 ab		 rep stosd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 140  :   agc_reset(state->agc_state);

  00058	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 145  :   if (state == (agcState *) NULL){

  0005b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__fprintf
  00061	85 c0		 test	 eax, eax
  00063	75 16		 jne	 SHORT $LN25@Post_Filte

; 146  :       fprintf(stderr, "agc_reset: invalid parameter\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00070	83 c0 40	 add	 eax, 64			; 00000040H
  00073	50		 push	 eax
  00074	ff d7		 call	 edi
  00076	83 c4 08	 add	 esp, 8

; 147  :       return -1;

  00079	eb 08		 jmp	 SHORT $LN26@Post_Filte
$LN25@Post_Filte:

; 148  :   }
; 149  :   
; 150  :   state->past_gain = 4096;   /* initial value of past_gain = 1.0  */

  0007b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00080	66 89 08	 mov	 WORD PTR [eax], cx
$LN26@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 141  :   preemphasis_reset(state->preemph_state);

  00083	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 87   :   if (state == (preemphasisState *) NULL){

  00086	85 c0		 test	 eax, eax
  00088	75 19		 jne	 SHORT $LN28@Post_Filte

; 88   :       fprintf(stderr, "preemphasis_reset: invalid parameter\n");

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00095	83 c0 40	 add	 eax, 64			; 00000040H
  00098	50		 push	 eax
  00099	ff d7		 call	 edi
  0009b	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 143  :   return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi

; 144  : }

  000a2	c3		 ret	 0
$LN28@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 92   :   state->mem_pre = 0;

  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	66 89 08	 mov	 WORD PTR [eax], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 143  :   return 0;

  000a9	33 c0		 xor	 eax, eax
  000ab	5e		 pop	 esi

; 144  : }

  000ac	c3		 ret	 0
_Post_Filter_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
;	COMDAT _Post_Filter_exit
_TEXT	SEGMENT
_Post_Filter_exit PROC					; COMDAT
; _state$ = ecx

; 154  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 155  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 4f		 je	 SHORT $LN1@Post_Filte
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 49		 je	 SHORT $LN1@Post_Filte
  0000d	53		 push	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 165  :   if (state == NULL || *state == NULL)

  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  00014	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 158  :   agc_exit(&(*state)->agc_state);

  00015	8d 78 68	 lea	 edi, DWORD PTR [eax+104]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 165  :   if (state == NULL || *state == NULL)

  00018	85 ff		 test	 edi, edi
  0001a	74 12		 je	 SHORT $LN5@Post_Filte
  0001c	8b 07		 mov	 eax, DWORD PTR [edi]
  0001e	85 c0		 test	 eax, eax
  00020	74 0c		 je	 SHORT $LN5@Post_Filte

; 166  :       return;
; 167  :  
; 168  :   /* deallocate memory */
; 169  :   free(*state);

  00022	50		 push	 eax
  00023	ff d3		 call	 ebx
  00025	83 c4 04	 add	 esp, 4

; 170  :   *state = NULL;

  00028	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN5@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 159  :   preemphasis_exit(&(*state)->preemph_state);

  0002e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00030	83 c7 64	 add	 edi, 100		; 00000064H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 106  :   if (state == NULL || *state == NULL)

  00033	74 12		 je	 SHORT $LN9@Post_Filte
  00035	8b 07		 mov	 eax, DWORD PTR [edi]
  00037	85 c0		 test	 eax, eax
  00039	74 0c		 je	 SHORT $LN9@Post_Filte

; 107  :       return;
; 108  :  
; 109  :   /* deallocate memory */
; 110  :   free(*state);

  0003b	50		 push	 eax
  0003c	ff d3		 call	 ebx
  0003e	83 c4 04	 add	 esp, 4

; 111  :   *state = NULL;

  00041	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN9@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 162  :   free(*state);

  00047	ff 36		 push	 DWORD PTR [esi]
  00049	ff d3		 call	 ebx
  0004b	83 c4 04	 add	 esp, 4

; 163  :   *state = NULL;

  0004e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00054	5f		 pop	 edi
  00055	5b		 pop	 ebx
$LN1@Post_Filte:
  00056	5e		 pop	 esi

; 164  :   
; 165  :   return;
; 166  : }

  00057	c3		 ret	 0
_Post_Filter_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
;	COMDAT _Post_Filter
_TEXT	SEGMENT
_L_diff$1$ = -128					; size = 4
tv1069 = -124						; size = 4
_temp1$1$ = -120					; size = 4
tv1057 = -116						; size = 4
_syn$GSCopy$1$ = -112					; size = 4
_Az$1$ = -108						; size = 4
_st$GSCopy$1$ = -104					; size = 4
tv1056 = -100						; size = 4
_Ap4$ = -96						; size = 22
_Ap3$ = -72						; size = 22
_h$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_syn$ = 8						; size = 4
_Az_4$ = 12						; size = 4
_Post_Filter PROC					; COMDAT
; _st$ = ecx
; _mode$ = edx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _Az_4$[ebp]
  00017	8b c1		 mov	 eax, ecx
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _syn$[ebp]
  0001c	56		 push	 esi
  0001d	89 5d 94	 mov	 DWORD PTR _Az$1$[ebp], ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  00020	8b d9		 mov	 ebx, ecx
  00022	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 202  :     Word16 *syn_work = &st->synth_buf[M]; move16 ();

  00023	8d b8 80 00 00
	00		 lea	 edi, DWORD PTR [eax+128]
  00029	89 45 98	 mov	 DWORD PTR _st$GSCopy$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  0002c	2b df		 sub	 ebx, edi
  0002e	8b f7		 mov	 esi, edi
  00030	89 5d 90	 mov	 DWORD PTR _syn$GSCopy$1$[ebp], ebx
  00033	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00038	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL21@Post_Filte:

; 62   :         y[i] = x[i];            move16 (); 

  00040	66 8b 04 33	 mov	 ax, WORD PTR [ebx+esi]
  00044	8d 76 02	 lea	 esi, DWORD PTR [esi+2]
  00047	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  0004b	49		 dec	 ecx
  0004c	75 f2		 jne	 SHORT $LL21@Post_Filte
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 211  :     Az = Az_4;

  0004e	8b 5d 94	 mov	 ebx, DWORD PTR _Az$1$[ebp]
  00051	8b f7		 mov	 esi, edi
  00053	8b 7d 98	 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  00056	0f bf d2	 movsx	 edx, dx
  00059	89 55 84	 mov	 DWORD PTR tv1069[ebp], edx
  0005c	89 75 9c	 mov	 DWORD PTR tv1056[ebp], esi
  0005f	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR tv1057[ebp], 4
  00066	8d 4a f9	 lea	 ecx, DWORD PTR [edx-7]
  00069	89 4d 80	 mov	 DWORD PTR _L_diff$1$[ebp], ecx
  0006c	8d 64 24 00	 npad	 4
$LL14@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00070	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00076	7e 0c		 jle	 SHORT $LN35@Post_Filte

; 80   :     {
; 81   :         Overflow = 1;

  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00082	eb 19		 jmp	 SHORT $LN146@Post_Filte
$LN35@Post_Filte:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00084	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0008a	7d 0c		 jge	 SHORT $LN33@Post_Filte

; 85   :     {
; 86   :         Overflow = 1;

  0008c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00096	eb 05		 jmp	 SHORT $LN146@Post_Filte
$LN33@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 218  :        if (sub(mode, MR122) == 0 || sub(mode, MR102) == 0)

  00098	66 85 c9	 test	 cx, cx
  0009b	74 45		 je	 SHORT $LN10@Post_Filte
$LN146@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0009d	8d 42 fa	 lea	 eax, DWORD PTR [edx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  000a0	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000a5	7e 0c		 jle	 SHORT $LN45@Post_Filte

; 80   :     {
; 81   :         Overflow = 1;

  000a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000b1	eb 18		 jmp	 SHORT $LN147@Post_Filte
$LN45@Post_Filte:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000b3	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000b8	7d 0c		 jge	 SHORT $LN43@Post_Filte

; 85   :     {
; 86   :         Overflow = 1;

  000ba	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000c4	eb 05		 jmp	 SHORT $LN147@Post_Filte
$LN43@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 218  :        if (sub(mode, MR122) == 0 || sub(mode, MR102) == 0)

  000c6	66 85 c0	 test	 ax, ax
  000c9	74 17		 je	 SHORT $LN10@Post_Filte
$LN147@Post_Filte:

; 222  :        }
; 223  :        else
; 224  :        {
; 225  :           Weight_Ai (Az, gamma3, Ap3);

  000cb	8d 45 b8	 lea	 eax, DWORD PTR _Ap3$[ebp]
  000ce	ba 00 00 00 00	 mov	 edx, OFFSET _gamma3
  000d3	50		 push	 eax
  000d4	8b cb		 mov	 ecx, ebx
  000d6	e8 00 00 00 00	 call	 _Weight_Ai

; 226  :           Weight_Ai (Az, gamma4, Ap4);

  000db	ba 00 00 00 00	 mov	 edx, OFFSET _gamma4
  000e0	eb 15		 jmp	 SHORT $LN148@Post_Filte
$LN10@Post_Filte:

; 219  :        {
; 220  :           Weight_Ai (Az, gamma3_MR122, Ap3);

  000e2	8d 45 b8	 lea	 eax, DWORD PTR _Ap3$[ebp]
  000e5	ba 00 00 00 00	 mov	 edx, OFFSET _gamma3_MR122
  000ea	50		 push	 eax
  000eb	8b cb		 mov	 ecx, ebx
  000ed	e8 00 00 00 00	 call	 _Weight_Ai

; 221  :           Weight_Ai (Az, gamma4_MR122, Ap4);

  000f2	ba 00 00 00 00	 mov	 edx, OFFSET _gamma4_MR122
$LN148@Post_Filte:
  000f7	8d 45 a0	 lea	 eax, DWORD PTR _Ap4$[ebp]
  000fa	8b cb		 mov	 ecx, ebx
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 _Weight_Ai
  00102	83 c4 08	 add	 esp, 8

; 227  :        }
; 228  :        
; 229  :        /* filtering of synthesis speech by A(z/0.7) to find res2[] */
; 230  :        
; 231  :        Residu (Ap3, &syn_work[i_subfr], st->res2, L_SUBFR);

  00105	8b d6		 mov	 edx, esi
  00107	51		 push	 ecx
  00108	57		 push	 edi
  00109	8d 4d b8	 lea	 ecx, DWORD PTR _Ap3$[ebp]
  0010c	e8 00 00 00 00	 call	 _Residu
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00111	8b 45 c8	 mov	 eax, DWORD PTR _Ap3$[ebp+16]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 239  :        Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);

  00114	8d 4d a0	 lea	 ecx, DWORD PTR _Ap4$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00117	f3 0f 6f 45 b8	 movdqu	 xmm0, XMMWORD PTR _Ap3$[ebp]
  0011c	89 45 e0	 mov	 DWORD PTR _h$[ebp+16], eax
  0011f	66 8b 45 cc	 mov	 ax, WORD PTR _Ap3$[ebp+20]
  00123	66 89 45 e4	 mov	 WORD PTR _h$[ebp+20], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 239  :        Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);

  00127	8d 45 e6	 lea	 eax, DWORD PTR _h$[ebp+22]
  0012a	6a 00		 push	 0
  0012c	50		 push	 eax
  0012d	8d 45 d0	 lea	 eax, DWORD PTR _h$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00130	c7 45 f6 00 00
	00 00		 mov	 DWORD PTR _h$[ebp+38], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00137	f3 0f 7f 45 d0	 movdqu	 XMMWORD PTR _h$[ebp], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  0013c	66 c7 45 fa 00
	00		 mov	 WORD PTR _h$[ebp+42], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 239  :        Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);

  00142	8b d0		 mov	 edx, eax
  00144	0f 57 c0	 xorps	 xmm0, xmm0
  00147	6a 16		 push	 22			; 00000016H
  00149	50		 push	 eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  0014a	f3 0f 7f 45 e6	 movdqu	 XMMWORD PTR _h$[ebp+22], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 239  :        Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);

  0014f	e8 00 00 00 00	 call	 _Syn_filt
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00154	0f bf 5d d0	 movsx	 ebx, WORD PTR _h$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 239  :        Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);

  00158	83 c4 18	 add	 esp, 24			; 00000018H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0015b	8b d3		 mov	 edx, ebx
  0015d	0f af d3	 imul	 edx, ebx

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00160	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  00166	74 04		 je	 SHORT $LN65@Post_Filte

; 488  :     {
; 489  :         L_var_out *= 2;

  00168	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  0016a	eb 0f		 jmp	 SHORT $LN64@Post_Filte
$LN65@Post_Filte:

; 492  :     {
; 493  :         Overflow = 1;

  0016c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00176	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN64@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 243  :        L_tmp = L_mult (h[0], h[0]);

  0017b	8d 75 d2	 lea	 esi, DWORD PTR _h$[ebp+2]
  0017e	bf 15 00 00 00	 mov	 edi, 21			; 00000015H
$LL8@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00183	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00186	0f af c0	 imul	 eax, eax

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00189	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0018e	74 04		 je	 SHORT $LN71@Post_Filte

; 488  :     {
; 489  :         L_var_out *= 2;

  00190	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00192	eb 0f		 jmp	 SHORT $LN70@Post_Filte
$LN71@Post_Filte:

; 492  :     {
; 493  :         Overflow = 1;

  00194	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0019e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN70@Post_Filte:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  001a3	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001a6	33 c2		 xor	 eax, edx
  001a8	78 1d		 js	 SHORT $LN74@Post_Filte

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001aa	8b c1		 mov	 eax, ecx
  001ac	33 c2		 xor	 eax, edx
  001ae	79 17		 jns	 SHORT $LN74@Post_Filte

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  001b0	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  001b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001bc	85 d2		 test	 edx, edx
  001be	0f 98 c1	 sets	 cl
  001c1	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN74@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 244  :        for (i = 1; i < L_H; i++)

  001c7	83 c6 02	 add	 esi, 2

; 245  :        {
; 246  :           L_tmp = L_mac (L_tmp, h[i], h[i]);

  001ca	8b d1		 mov	 edx, ecx
  001cc	4f		 dec	 edi
  001cd	75 b4		 jne	 SHORT $LL8@Post_Filte
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  001cf	0f bf 55 d2	 movsx	 edx, WORD PTR _h$[ebp+2]
  001d3	0f af d3	 imul	 edx, ebx

; 575  :     var_out = (Word16) (L_var1 >> 16);

  001d6	c1 f9 10	 sar	 ecx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 248  :        temp1 = extract_h (L_tmp);

  001d9	0f b7 c1	 movzx	 eax, cx
  001dc	89 45 88	 mov	 DWORD PTR _temp1$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  001df	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  001e5	74 04		 je	 SHORT $LN81@Post_Filte

; 488  :     {
; 489  :         L_var_out *= 2;

  001e7	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  001e9	eb 0f		 jmp	 SHORT $LN80@Post_Filte
$LN81@Post_Filte:

; 492  :     {
; 493  :         Overflow = 1;

  001eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  001f5	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN80@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 250  :        L_tmp = L_mult (h[0], h[1]);

  001fa	8d 75 d2	 lea	 esi, DWORD PTR _h$[ebp+2]
  001fd	bb 14 00 00 00	 mov	 ebx, 20			; 00000014H
$LL5@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00202	0f bf 4e 02	 movsx	 ecx, WORD PTR [esi+2]
  00206	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00209	0f af c8	 imul	 ecx, eax

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0020c	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00212	74 04		 je	 SHORT $LN87@Post_Filte

; 488  :     {
; 489  :         L_var_out *= 2;

  00214	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  00216	eb 0f		 jmp	 SHORT $LN86@Post_Filte
$LN87@Post_Filte:

; 492  :     {
; 493  :         Overflow = 1;

  00218	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00222	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN86@Post_Filte:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00227	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0022a	33 ca		 xor	 ecx, edx
  0022c	78 1c		 js	 SHORT $LN90@Post_Filte

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0022e	8b c8		 mov	 ecx, eax
  00230	33 ca		 xor	 ecx, edx
  00232	79 16		 jns	 SHORT $LN90@Post_Filte

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00234	33 c0		 xor	 eax, eax

; 938  :             Overflow = 1;

  00236	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00240	85 d2		 test	 edx, edx
  00242	0f 98 c0	 sets	 al
  00245	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
$LN90@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 251  :        for (i = 1; i < L_H - 1; i++)

  0024a	83 c6 02	 add	 esi, 2

; 252  :        {
; 253  :           L_tmp = L_mac (L_tmp, h[i], h[i + 1]);

  0024d	8b d0		 mov	 edx, eax
  0024f	4b		 dec	 ebx
  00250	75 b0		 jne	 SHORT $LL5@Post_Filte
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00252	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 255  :        temp2 = extract_h (L_tmp);

  00255	0f b7 c0	 movzx	 eax, ax

; 256  :        
; 257  :        test (); 
; 258  :        if (temp2 <= 0)

  00258	66 85 c0	 test	 ax, ax
  0025b	7f 04		 jg	 SHORT $LN2@Post_Filte

; 259  :        {
; 260  :           temp2 = 0;          move16 (); 

  0025d	33 c0		 xor	 eax, eax

; 261  :        }
; 262  :        else

  0025f	eb 54		 jmp	 SHORT $LN1@Post_Filte
$LN2@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00261	98		 cwde
  00262	69 c0 66 66 00
	00		 imul	 eax, eax, 26214

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00268	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0026b	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00270	74 05		 je	 SHORT $LN100@Post_Filte

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00272	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN100@Post_Filte:

; 79   :     if (L_var1 > 0X00007fffL)

  00277	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0027c	7e 11		 jle	 SHORT $LN106@Post_Filte

; 80   :     {
; 81   :         Overflow = 1;

  0027e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00288	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0028d	eb 1b		 jmp	 SHORT $LN103@Post_Filte
$LN106@Post_Filte:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0028f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00294	7d 11		 jge	 SHORT $LN104@Post_Filte

; 85   :     {
; 86   :         Overflow = 1;

  00296	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002a0	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002a5	eb 03		 jmp	 SHORT $LN103@Post_Filte
$LN104@Post_Filte:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002a7	0f b7 c8	 movzx	 ecx, ax
$LN103@Post_Filte:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 265  :           temp2 = div_s (temp2, temp1);

  002aa	8b 55 88	 mov	 edx, DWORD PTR _temp1$1$[ebp]
  002ad	e8 00 00 00 00	 call	 _div_s
  002b2	0f b7 c0	 movzx	 eax, ax
$LN1@Post_Filte:

; 266  :        }
; 267  :        
; 268  :        preemphasis (st->preemph_state, st->res2, temp2, L_SUBFR);

  002b5	8b 7d 98	 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  002b8	8b d7		 mov	 edx, edi
  002ba	51		 push	 ecx
  002bb	50		 push	 eax
  002bc	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  002bf	e8 00 00 00 00	 call	 _preemphasis

; 269  :        
; 270  :        /* filtering through  1/A(z/0.75) */
; 271  :        
; 272  :        Syn_filt (Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 1);

  002c4	8b 75 9c	 mov	 esi, DWORD PTR tv1056[ebp]
  002c7	8d 47 50	 lea	 eax, DWORD PTR [edi+80]
  002ca	03 75 90	 add	 esi, DWORD PTR _syn$GSCopy$1$[ebp]
  002cd	8d 4d a0	 lea	 ecx, DWORD PTR _Ap4$[ebp]
  002d0	6a 01		 push	 1
  002d2	50		 push	 eax
  002d3	6a 28		 push	 40			; 00000028H
  002d5	56		 push	 esi
  002d6	8b d7		 mov	 edx, edi
  002d8	e8 00 00 00 00	 call	 _Syn_filt

; 273  :        
; 274  :        /* scale output to input */
; 275  : 
; 276  :        agc (st->agc_state, &syn_work[i_subfr], &syn[i_subfr],
; 277  :             AGC_FAC, L_SUBFR);

  002dd	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  002e0	83 c4 10	 add	 esp, 16			; 00000010H
  002e3	56		 push	 esi
  002e4	8b 75 9c	 mov	 esi, DWORD PTR tv1056[ebp]
  002e7	8b d6		 mov	 edx, esi
  002e9	e8 00 00 00 00	 call	 _agc

; 278  :        
; 279  :        Az += MP1;

  002ee	8b 5d 94	 mov	 ebx, DWORD PTR _Az$1$[ebp]
  002f1	83 c6 50	 add	 esi, 80			; 00000050H
  002f4	8b 4d 80	 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
  002f7	83 c3 16	 add	 ebx, 22			; 00000016H
  002fa	8b 55 84	 mov	 edx, DWORD PTR tv1069[ebp]
  002fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00300	ff 4d 8c	 dec	 DWORD PTR tv1057[ebp]
  00303	89 5d 94	 mov	 DWORD PTR _Az$1$[ebp], ebx
  00306	89 75 9c	 mov	 DWORD PTR tv1056[ebp], esi
  00309	0f 85 61 fd ff
	ff		 jne	 $LL14@Post_Filte
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  0030f	0f b7 87 ac 01
	00 00		 movzx	 eax, WORD PTR [edi+428]
  00316	8d 8f 80 00 00
	00		 lea	 ecx, DWORD PTR [edi+128]
  0031c	66 89 41 ec	 mov	 WORD PTR [ecx-20], ax
  00320	0f b7 81 2e 01
	00 00		 movzx	 eax, WORD PTR [ecx+302]
  00327	66 89 41 ee	 mov	 WORD PTR [ecx-18], ax
  0032b	0f b7 81 30 01
	00 00		 movzx	 eax, WORD PTR [ecx+304]
  00332	66 89 41 f0	 mov	 WORD PTR [ecx-16], ax
  00336	0f b7 81 32 01
	00 00		 movzx	 eax, WORD PTR [ecx+306]
  0033d	66 89 41 f2	 mov	 WORD PTR [ecx-14], ax
  00341	0f b7 81 34 01
	00 00		 movzx	 eax, WORD PTR [ecx+308]
  00348	66 89 41 f4	 mov	 WORD PTR [ecx-12], ax
  0034c	0f b7 81 36 01
	00 00		 movzx	 eax, WORD PTR [ecx+310]
  00353	66 89 41 f6	 mov	 WORD PTR [ecx-10], ax
  00357	0f b7 81 38 01
	00 00		 movzx	 eax, WORD PTR [ecx+312]
  0035e	66 89 41 f8	 mov	 WORD PTR [ecx-8], ax
  00362	0f b7 81 3a 01
	00 00		 movzx	 eax, WORD PTR [ecx+314]
  00369	66 89 41 fa	 mov	 WORD PTR [ecx-6], ax
  0036d	0f b7 81 3c 01
	00 00		 movzx	 eax, WORD PTR [ecx+316]
  00374	66 89 41 fc	 mov	 WORD PTR [ecx-4], ax
  00378	0f b7 81 3e 01
	00 00		 movzx	 eax, WORD PTR [ecx+318]
  0037f	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c

; 286  :     return 0;

  00383	33 c0		 xor	 eax, eax

; 287  : }

  00385	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00388	5f		 pop	 edi
  00389	5e		 pop	 esi
  0038a	33 cd		 xor	 ecx, ebp
  0038c	5b		 pop	 ebx
  0038d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00392	8b e5		 mov	 esp, ebp
  00394	5d		 pop	 ebp
  00395	c3		 ret	 0
_Post_Filter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\pstfilt.c
;	COMDAT _Post_Filter_init
_TEXT	SEGMENT
_s$ = -4						; size = 4
_Post_Filter_init PROC					; COMDAT
; _state$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 96   :   Post_FilterState* s;
; 97   : 
; 98   :   if (state == (Post_FilterState **) NULL){

  00007	85 ff		 test	 edi, edi
  00009	75 20		 jne	 SHORT $LN4@Post_Filte

; 99   :       fprintf(stderr, "Post_Filter_init: invalid parameter\n");

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BGIDGKEK@Post_Filter_init?3?5invalid?5parame@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00016	83 c0 40	 add	 eax, 64			; 00000040H
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00020	83 c4 08	 add	 esp, 8

; 100  :       return -1;

  00023	83 c8 ff	 or	 eax, -1
  00026	5f		 pop	 edi

; 121  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@Post_Filte:
  0002b	56		 push	 esi

; 101  :   }
; 102  :   *state = NULL;
; 103  : 
; 104  :   /* allocate memory */
; 105  :   if ((s= (Post_FilterState *) malloc(sizeof(Post_FilterState))) == NULL){

  0002c	68 c0 01 00 00	 push	 448			; 000001c0H
  00031	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003d	8b f0		 mov	 esi, eax
  0003f	83 c4 04	 add	 esp, 4
  00042	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00045	85 f6		 test	 esi, esi
  00047	75 21		 jne	 SHORT $LN3@Post_Filte

; 106  :       fprintf(stderr, "Post_Filter_init: can not malloc state structure\n");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EBNJDLEA@Post_Filter_init?3?5can?5not?5malloc@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00054	83 c0 40	 add	 eax, 64			; 00000040H
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0005e	83 c4 08	 add	 esp, 8

; 107  :       return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	5e		 pop	 esi
  00065	5f		 pop	 edi

; 121  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN3@Post_Filte:

; 108  :   }
; 109  :   s->preemph_state = NULL;

  0006a	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  0006d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00073	53		 push	 ebx

; 110  :   s->agc_state = NULL;

  00074	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 111  : 
; 112  :   if (preemphasis_init(&s->preemph_state) || agc_init(&s->agc_state)) {

  0007b	e8 00 00 00 00	 call	 _preemphasis_init
  00080	85 c0		 test	 eax, eax
  00082	75 1e		 jne	 SHORT $LN1@Post_Filte
  00084	8d 4e 68	 lea	 ecx, DWORD PTR [esi+104]
  00087	e8 00 00 00 00	 call	 _agc_init
  0008c	85 c0		 test	 eax, eax
  0008e	75 12		 jne	 SHORT $LN1@Post_Filte

; 115  :   }
; 116  :       
; 117  :   Post_Filter_reset(s);

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 _Post_Filter_reset
  00097	5b		 pop	 ebx

; 118  :   *state = s;

  00098	89 37		 mov	 DWORD PTR [edi], esi

; 119  :   
; 120  :   return 0;

  0009a	33 c0		 xor	 eax, eax
  0009c	5e		 pop	 esi
  0009d	5f		 pop	 edi

; 121  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
$LN1@Post_Filte:

; 113  :       Post_Filter_exit(&s);

  000a2	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  000a5	e8 00 00 00 00	 call	 _Post_Filter_exit
  000aa	5b		 pop	 ebx
  000ab	5e		 pop	 esi

; 114  :       return -1;

  000ac	83 c8 ff	 or	 eax, -1
  000af	5f		 pop	 edi

; 121  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
_Post_Filter_init ENDP
_TEXT	ENDS
END
