; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\c_g_aver.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@ ; `string'
PUBLIC	??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@ ; `string'
PUBLIC	??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@ ; `string'
;	COMDAT ??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@
CONST	SEGMENT
??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@ DB 'Cb_gain_avera'
	DB	'ge_reset: invalid parameter', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@
CONST	SEGMENT
??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@ DB 'Cb_gain_aver'
	DB	'age_init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@
CONST	SEGMENT
??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@ DB 'Cb_gain_avera'
	DB	'ge_init: invalid parameter', 0aH, 00H	; `string'
PUBLIC	_Cb_gain_average_reset
PUBLIC	_Cb_gain_average_exit
PUBLIC	_Cb_gain_average_init
PUBLIC	_Cb_gain_average
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average
_TEXT	SEGMENT
_lsp$GSCopy$1$ = -60					; size = 4
tv2388 = -56						; size = 4
_mode$1$ = -52						; size = 4
_lspAver$GSCopy$1$ = -48				; size = 4
tv2404 = -44						; size = 4
_i$1$ = -40						; size = 4
_cbGainMix$1$ = -36					; size = 4
_st$GSCopy$1$ = -32					; size = 4
_bgMix$1$ = -28						; size = 4
_var_out$1$ = -28					; size = 4
_tmp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_gain_code$ = 8						; size = 2
_lsp$ = 12						; size = 4
_lspAver$ = 16						; size = 4
_bfi$ = 20						; size = 2
_prev_bf$ = 24						; size = 2
_pdfi$ = 28						; size = 2
_prev_pdf$ = 32						; size = 2
_inBackgroundNoise$ = 36				; size = 2
_voicedHangover$ = 40					; size = 2
_Cb_gain_average PROC					; COMDAT
; _st$ = ecx
; _mode$ = edx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 55 cc	 mov	 DWORD PTR _mode$1$[ebp], edx

; 171  :    for (i = 0; i < M; i++) {

  00016	89 4d e0	 mov	 DWORD PTR _st$GSCopy$1$[ebp], ecx
  00019	8b 5d 10	 mov	 ebx, DWORD PTR _lspAver$[ebp]
  0001c	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]

; 146  : {

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _lsp$[ebp]

; 147  :    /*---------------------------------------------------------*
; 148  :     * Compute mixed cb gain, used to make cb gain more        *
; 149  :     * smooth in background noise for modes 5.15, 5.9 and 6.7  *
; 150  :     * states that needs to be updated by all                  *
; 151  :     *---------------------------------------------------------*/
; 152  :    Word16 i;
; 153  :    Word16 cbGainMix, diff, tmp_diff, bgMix, cbGainMean;
; 154  :    Word32 L_sum;
; 155  :    Word16 tmp[M], tmp1, tmp2, shift1, shift2, shift;
; 156  : 
; 157  :    /* set correct cbGainMix for MR74, MR795, MR122 */
; 158  :    cbGainMix = gain_code;             move16 (); 

  00022	66 8b 7d 08	 mov	 di, WORD PTR _gain_code$[ebp]
  00026	0f b7 c7	 movzx	 eax, di
  00029	89 45 dc	 mov	 DWORD PTR _cbGainMix$1$[ebp], eax

; 159  :    
; 160  :    /*-------------------------------------------------------*
; 161  :     *   Store list of CB gain needed in the CB gain         *
; 162  :     *   averaging                                           *
; 163  :     *-------------------------------------------------------*/
; 164  :    for (i = 0; i < (L_CBGAINHIST-1); i++)
; 165  :    {
; 166  :       st->cbGainHistory[i] = st->cbGainHistory[i+1];    move16 ();

  0002c	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0002f	66 89 01	 mov	 WORD PTR [ecx], ax
  00032	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00036	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  0003a	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  0003e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00042	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  00046	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0004a	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0004e	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00052	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  00056	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 171  :    for (i = 0; i < M; i++) {

  0005a	33 c0		 xor	 eax, eax
  0005c	89 55 c4	 mov	 DWORD PTR _lsp$GSCopy$1$[ebp], edx
  0005f	89 5d d0	 mov	 DWORD PTR _lspAver$GSCopy$1$[ebp], ebx
  00062	89 75 c8	 mov	 DWORD PTR tv2388[ebp], esi
  00065	66 89 79 0c	 mov	 WORD PTR [ecx+12], di
  00069	89 45 d8	 mov	 DWORD PTR _i$1$[ebp], eax
  0006c	8d 64 24 00	 npad	 4
$LL658@Cb_gain_av:

; 172  :       tmp1 = abs_s(sub(lspAver[i], lsp[i]));  /* Q15       */

  00070	0f bf c8	 movsx	 ecx, ax
  00073	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H
  00078	03 c9		 add	 ecx, ecx
  0007a	89 4d d4	 mov	 DWORD PTR tv2404[ebp], ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0007d	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  00081	0f bf 0c 0b	 movsx	 ecx, WORD PTR [ebx+ecx]
  00085	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00087	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0008d	7e 1e		 jle	 SHORT $LN54@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  0008f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00099	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
$LN60@Cb_gain_av:

; 237  :         {
; 238  :             var_out = var1;

  0009e	0f b7 f0	 movzx	 esi, ax
$LN59@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 173  :       shift1 = sub(norm_s(tmp1), 1);          /* Qn        */

  000a1	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1942 :     if (var1 == 0)

  000a4	66 85 f6	 test	 si, si
  000a7	75 3e		 jne	 SHORT $LN72@Cb_gain_av

; 1943 :     {
; 1944 :         var_out = 0;

  000a9	33 c9		 xor	 ecx, ecx

; 1945 :     }
; 1946 :     else

  000ab	eb 6b		 jmp	 SHORT $LN65@Cb_gain_av
$LN54@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000ad	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  000b3	7d 14		 jge	 SHORT $LN52@Cb_gain_av

; 227  :     {
; 228  :         var_out = MAX_16;

  000b5	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH

; 86   :         Overflow = 1;

  000ba	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 173  :       shift1 = sub(norm_s(tmp1), 1);          /* Qn        */

  000c4	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 230  :     else

  000c7	eb 37		 jmp	 SHORT $LN68@Cb_gain_av
$LN52@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000c9	0f b7 c1	 movzx	 eax, cx

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)

  000cc	66 3b cf	 cmp	 cx, di
  000cf	75 0a		 jne	 SHORT $LN62@Cb_gain_av

; 227  :     {
; 228  :         var_out = MAX_16;

  000d1	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 173  :       shift1 = sub(norm_s(tmp1), 1);          /* Qn        */

  000d6	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 230  :     else

  000d9	eb 25		 jmp	 SHORT $LN68@Cb_gain_av
$LN62@Cb_gain_av:

; 231  :     {
; 232  :         if (var1 < 0)

  000db	66 85 c9	 test	 cx, cx
  000de	79 be		 jns	 SHORT $LN60@Cb_gain_av

; 233  :         {
; 234  :             var_out = -var1;

  000e0	f7 d9		 neg	 ecx
  000e2	0f b7 f1	 movzx	 esi, cx

; 235  :         }
; 236  :         else

  000e5	eb ba		 jmp	 SHORT $LN59@Cb_gain_av
$LN72@Cb_gain_av:

; 1947 :     {
; 1948 :         if (var1 == (Word16) 0xffff)

  000e7	66 83 fe ff	 cmp	 si, -1
  000eb	75 07		 jne	 SHORT $LN70@Cb_gain_av

; 1949 :         {
; 1950 :             var_out = 15;

  000ed	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 1951 :         }
; 1952 :         else

  000f2	eb 24		 jmp	 SHORT $LN65@Cb_gain_av
$LN70@Cb_gain_av:

; 1953 :         {
; 1954 :             if (var1 < 0)

  000f4	66 85 f6	 test	 si, si
  000f7	79 07		 jns	 SHORT $LN68@Cb_gain_av

; 1955 :             {
; 1956 :                 var1 = ~var1;

  000f9	8b c6		 mov	 eax, esi
  000fb	f7 d0		 not	 eax
  000fd	0f b7 c0	 movzx	 eax, ax
$LN68@Cb_gain_av:

; 1957 :             }
; 1958 :             for (var_out = 0; var1 < 0x4000; var_out++)

  00100	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  00105	33 c9		 xor	 ecx, ecx
  00107	66 3b c2	 cmp	 ax, dx
  0010a	7d 0c		 jge	 SHORT $LN65@Cb_gain_av
  0010c	8d 64 24 00	 npad	 4
$LL67@Cb_gain_av:

; 1959 :             {
; 1960 :                 var1 <<= 1;

  00110	03 c0		 add	 eax, eax
  00112	41		 inc	 ecx
  00113	66 3b c2	 cmp	 ax, dx
  00116	7c f8		 jl	 SHORT $LL67@Cb_gain_av
$LN65@Cb_gain_av:

; 186  :     L_diff = (Word32) var1 - var2;

  00118	0f bf c1	 movsx	 eax, cx
  0011b	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0011c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00121	7e 56		 jle	 SHORT $LN80@Cb_gain_av

; 82   :         var_out = MAX_16;

  00123	bb ff 7f 00 00	 mov	 ebx, 32767		; 00007fffH
  00128	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00132	89 5d e4	 mov	 DWORD PTR _var_out$1$[ebp], ebx
$LN91@Cb_gain_av:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00135	ba 01 00 00 00	 mov	 edx, 1
  0013a	0f bf c6	 movsx	 eax, si
  0013d	8a cb		 mov	 cl, bl
  0013f	d3 e2		 shl	 edx, cl
  00141	0f af d0	 imul	 edx, eax

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00144	66 83 fb 0f	 cmp	 bx, 15			; 0000000fH
  00148	7e 05		 jle	 SHORT $LN86@Cb_gain_av
  0014a	66 85 f6	 test	 si, si
  0014d	75 0b		 jne	 SHORT $LN87@Cb_gain_av
$LN86@Cb_gain_av:
  0014f	0f bf c2	 movsx	 eax, dx
  00152	3b d0		 cmp	 edx, eax
  00154	0f 84 b3 00 00
	00		 je	 $LN88@Cb_gain_av
$LN87@Cb_gain_av:

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0015a	8b c7		 mov	 eax, edi
  0015c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00166	66 85 f6	 test	 si, si
  00169	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0016e	0f 4f c1	 cmovg	 eax, ecx
  00171	0f b7 f8	 movzx	 edi, ax

; 304  :         }
; 305  :         else

  00174	e9 97 00 00 00	 jmp	 $LN85@Cb_gain_av
$LN80@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00179	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0017e	7d 13		 jge	 SHORT $LN78@Cb_gain_av

; 86   :         Overflow = 1;

  00180	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0018a	c7 45 e4 00 80
	ff ff		 mov	 DWORD PTR _var_out$1$[ebp], -32768 ; ffff8000H

; 88   :     }
; 89   :     else

  00191	eb 14		 jmp	 SHORT $LN652@Cb_gain_av
$LN78@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00193	0f b7 d8	 movzx	 ebx, ax
  00196	89 5d e4	 mov	 DWORD PTR _var_out$1$[ebp], ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 174  :       tmp1 = shl(tmp1, shift1);               /* Q15+Qn    */

  00199	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 287  :     if (var2 < 0)

  0019c	66 85 c0	 test	 ax, ax
  0019f	79 94		 jns	 SHORT $LN91@Cb_gain_av

; 288  :     {
; 289  :         if (var2 < -16)

  001a1	66 83 f8 f0	 cmp	 ax, -16			; fffffff0H
  001a5	7d 05		 jge	 SHORT $LN90@Cb_gain_av
$LN652@Cb_gain_av:

; 290  :             var2 = -16;

  001a7	b9 f0 ff ff ff	 mov	 ecx, -16		; fffffff0H
$LN90@Cb_gain_av:

; 291  :         var_out = shr (var1, -var2);

  001ac	f7 d9		 neg	 ecx
  001ae	0f b7 c9	 movzx	 ecx, cx

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)

  001b1	66 85 c9	 test	 cx, cx
  001b4	79 1f		 jns	 SHORT $LN100@Cb_gain_av

; 359  :     {
; 360  :         if (var2 < -16)

  001b6	66 83 f9 f0	 cmp	 cx, -16			; fffffff0H
  001ba	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  001bf	0f 4c c8	 cmovl	 ecx, eax

; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);

  001c2	f7 d9		 neg	 ecx
  001c4	8b d1		 mov	 edx, ecx
  001c6	8b ce		 mov	 ecx, esi
  001c8	e8 00 00 00 00	 call	 _shl
  001cd	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  001d0	0f b7 f8	 movzx	 edi, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  001d3	eb 3b		 jmp	 SHORT $LN85@Cb_gain_av
$LN100@Cb_gain_av:

; 369  :         if (var2 >= 15)

  001d5	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  001d9	7c 11		 jl	 SHORT $LN97@Cb_gain_av

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  001db	33 c0		 xor	 eax, eax
  001dd	66 85 f6	 test	 si, si
  001e0	0f 99 c0	 setns	 al
  001e3	48		 dec	 eax
  001e4	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  001e7	0f b7 f8	 movzx	 edi, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  001ea	eb 24		 jmp	 SHORT $LN85@Cb_gain_av
$LN97@Cb_gain_av:

; 374  :         {
; 375  :             if (var1 < 0)

  001ec	66 85 f6	 test	 si, si
  001ef	79 11		 jns	 SHORT $LN95@Cb_gain_av

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001f1	0f bf c6	 movsx	 eax, si
  001f4	f7 d0		 not	 eax
  001f6	d3 f8		 sar	 eax, cl
  001f8	f7 d0		 not	 eax
  001fa	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  001fd	0f b7 f8	 movzx	 edi, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  00200	eb 0e		 jmp	 SHORT $LN85@Cb_gain_av
$LN95@Cb_gain_av:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00202	66 d3 fe	 sar	 si, cl
  00205	0f b7 c6	 movzx	 eax, si

; 291  :         var_out = shr (var1, -var2);

  00208	0f b7 f8	 movzx	 edi, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  0020b	eb 03		 jmp	 SHORT $LN85@Cb_gain_av
$LN88@Cb_gain_av:

; 307  :             var_out = extract_l (result);

  0020d	0f b7 fa	 movzx	 edi, dx
$LN85@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 175  :       shift2 = norm_s(lspAver[i]);            /* Qm        */

  00210	8b 45 d4	 mov	 eax, DWORD PTR tv2404[ebp]
  00213	8b 4d d0	 mov	 ecx, DWORD PTR _lspAver$GSCopy$1$[ebp]
  00216	0f b7 0c 01	 movzx	 ecx, WORD PTR [ecx+eax]
  0021a	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1942 :     if (var1 == 0)

  0021c	66 85 c0	 test	 ax, ax
  0021f	75 04		 jne	 SHORT $LN112@Cb_gain_av

; 1943 :     {
; 1944 :         var_out = 0;

  00221	33 db		 xor	 ebx, ebx

; 1945 :     }
; 1946 :     else

  00223	eb 2b		 jmp	 SHORT $LN105@Cb_gain_av
$LN112@Cb_gain_av:

; 1947 :     {
; 1948 :         if (var1 == (Word16) 0xffff)

  00225	66 83 f8 ff	 cmp	 ax, -1
  00229	75 07		 jne	 SHORT $LN110@Cb_gain_av

; 1949 :         {
; 1950 :             var_out = 15;

  0022b	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH

; 1951 :         }
; 1952 :         else

  00230	eb 1e		 jmp	 SHORT $LN105@Cb_gain_av
$LN110@Cb_gain_av:

; 1953 :         {
; 1954 :             if (var1 < 0)

  00232	66 85 c0	 test	 ax, ax
  00235	79 05		 jns	 SHORT $LN108@Cb_gain_av

; 1955 :             {
; 1956 :                 var1 = ~var1;

  00237	f7 d0		 not	 eax
  00239	0f b7 c0	 movzx	 eax, ax
$LN108@Cb_gain_av:

; 1957 :             }
; 1958 :             for (var_out = 0; var1 < 0x4000; var_out++)

  0023c	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  00241	33 db		 xor	 ebx, ebx
  00243	66 3b c2	 cmp	 ax, dx
  00246	7d 08		 jge	 SHORT $LN105@Cb_gain_av
$LL107@Cb_gain_av:

; 1959 :             {
; 1960 :                 var1 <<= 1;

  00248	03 c0		 add	 eax, eax
  0024a	43		 inc	 ebx
  0024b	66 3b c2	 cmp	 ax, dx
  0024e	7c f8		 jl	 SHORT $LL107@Cb_gain_av
$LN105@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 176  :       tmp2 = shl(lspAver[i], shift2);         /* Q15+Qm    */

  00250	0f b7 c3	 movzx	 eax, bx
  00253	8b f1		 mov	 esi, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 287  :     if (var2 < 0)

  00255	66 85 db	 test	 bx, bx
  00258	79 67		 jns	 SHORT $LN121@Cb_gain_av

; 288  :     {
; 289  :         if (var2 < -16)

  0025a	66 83 fb f0	 cmp	 bx, -16			; fffffff0H
  0025e	ba f0 ff ff ff	 mov	 edx, -16		; fffffff0H
  00263	0f 4c c2	 cmovl	 eax, edx

; 291  :         var_out = shr (var1, -var2);

  00266	f7 d8		 neg	 eax
  00268	0f b7 c8	 movzx	 ecx, ax

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)

  0026b	66 85 c9	 test	 cx, cx
  0026e	79 19		 jns	 SHORT $LN130@Cb_gain_av

; 359  :     {
; 360  :         if (var2 < -16)

  00270	66 3b ca	 cmp	 cx, dx
  00273	0f 4c ca	 cmovl	 ecx, edx

; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);

  00276	f7 d9		 neg	 ecx
  00278	8b d1		 mov	 edx, ecx
  0027a	8b ce		 mov	 ecx, esi
  0027c	e8 00 00 00 00	 call	 _shl
  00281	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  00284	0f b7 d0	 movzx	 edx, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  00287	eb 7b		 jmp	 SHORT $LN115@Cb_gain_av
$LN130@Cb_gain_av:

; 369  :         if (var2 >= 15)

  00289	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  0028d	7c 11		 jl	 SHORT $LN127@Cb_gain_av

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  0028f	33 c0		 xor	 eax, eax
  00291	66 85 f6	 test	 si, si
  00294	0f 99 c0	 setns	 al
  00297	48		 dec	 eax
  00298	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  0029b	0f b7 d0	 movzx	 edx, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  0029e	eb 64		 jmp	 SHORT $LN115@Cb_gain_av
$LN127@Cb_gain_av:

; 374  :         {
; 375  :             if (var1 < 0)

  002a0	66 85 f6	 test	 si, si
  002a3	79 11		 jns	 SHORT $LN125@Cb_gain_av

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  002a5	0f bf c6	 movsx	 eax, si
  002a8	f7 d0		 not	 eax
  002aa	d3 f8		 sar	 eax, cl
  002ac	f7 d0		 not	 eax
  002ae	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  002b1	0f b7 d0	 movzx	 edx, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  002b4	eb 4e		 jmp	 SHORT $LN115@Cb_gain_av
$LN125@Cb_gain_av:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  002b6	66 d3 fe	 sar	 si, cl
  002b9	0f b7 c6	 movzx	 eax, si

; 291  :         var_out = shr (var1, -var2);

  002bc	0f b7 d0	 movzx	 edx, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  002bf	eb 43		 jmp	 SHORT $LN115@Cb_gain_av
$LN121@Cb_gain_av:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  002c1	ba 01 00 00 00	 mov	 edx, 1
  002c6	0f bf c6	 movsx	 eax, si
  002c9	8a cb		 mov	 cl, bl
  002cb	d3 e2		 shl	 edx, cl
  002cd	0f af d0	 imul	 edx, eax

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  002d0	66 83 fb 0f	 cmp	 bx, 15			; 0000000fH
  002d4	7e 05		 jle	 SHORT $LN116@Cb_gain_av
  002d6	66 85 f6	 test	 si, si
  002d9	75 07		 jne	 SHORT $LN117@Cb_gain_av
$LN116@Cb_gain_av:
  002db	0f bf c2	 movsx	 eax, dx
  002de	3b d0		 cmp	 edx, eax
  002e0	74 1f		 je	 SHORT $LN118@Cb_gain_av
$LN117@Cb_gain_av:

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  002e2	66 85 f6	 test	 si, si
  002e5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  002ef	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  002f4	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  002f9	0f 4f c1	 cmovg	 eax, ecx
  002fc	0f b7 d0	 movzx	 edx, ax

; 304  :         }
; 305  :         else

  002ff	eb 03		 jmp	 SHORT $LN115@Cb_gain_av
$LN118@Cb_gain_av:

; 307  :             var_out = extract_l (result);

  00301	0f b7 d2	 movzx	 edx, dx
$LN115@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 177  :       tmp[i] = div_s(tmp1, tmp2);             /* Q15+(Q15+Qn)-(Q15+Qm) */

  00304	8b cf		 mov	 ecx, edi
  00306	e8 00 00 00 00	 call	 _div_s
  0030b	8b 7d d4	 mov	 edi, DWORD PTR tv2404[ebp]
  0030e	66 8b d0	 mov	 dx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00311	8b 45 e4	 mov	 eax, DWORD PTR _var_out$1$[ebp]
  00314	98		 cwde
  00315	83 c0 02	 add	 eax, 2
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 177  :       tmp[i] = div_s(tmp1, tmp2);             /* Q15+(Q15+Qn)-(Q15+Qm) */

  00318	66 89 54 3d e8	 mov	 WORD PTR _tmp$[ebp+edi], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0031d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00322	7e 11		 jle	 SHORT $LN142@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00324	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0032e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00333	eb 1b		 jmp	 SHORT $LN139@Cb_gain_av
$LN142@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00335	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0033a	7d 11		 jge	 SHORT $LN140@Cb_gain_av

; 86   :         Overflow = 1;

  0033c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00346	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0034b	eb 03		 jmp	 SHORT $LN139@Cb_gain_av
$LN140@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0034d	0f b7 c0	 movzx	 eax, ax
$LN139@Cb_gain_av:

; 186  :     L_diff = (Word32) var1 - var2;

  00350	0f bf c8	 movsx	 ecx, ax
  00353	0f bf c3	 movsx	 eax, bx
  00356	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00358	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0035e	7e 1b		 jle	 SHORT $LN152@Cb_gain_av

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  00360	33 c0		 xor	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 183  :          tmp[i] = shr(tmp[i], shift); move16 ();          /* Q15+Qn-Qm-Qx=Q13 */

  00362	0f b7 d2	 movzx	 edx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  00365	66 85 d2	 test	 dx, dx

; 80   :     {
; 81   :         Overflow = 1;

  00368	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  00372	0f 99 c0	 setns	 al
  00375	48		 dec	 eax
  00376	0f b7 c0	 movzx	 eax, ax

; 372  :         }
; 373  :         else

  00379	eb 50		 jmp	 SHORT $LN185@Cb_gain_av
$LN152@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0037b	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00381	7d 0f		 jge	 SHORT $LN150@Cb_gain_av

; 86   :         Overflow = 1;

  00383	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0038d	e9 93 00 00 00	 jmp	 $LN655@Cb_gain_av
$LN150@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 181  :       if (shift >= 0)

  00392	66 85 c9	 test	 cx, cx
  00395	0f 88 80 00 00
	00		 js	 $LN34@Cb_gain_av

; 183  :          tmp[i] = shr(tmp[i], shift); move16 ();          /* Q15+Qn-Qm-Qx=Q13 */

  0039b	0f b7 d2	 movzx	 edx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 369  :         if (var2 >= 15)

  0039e	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  003a2	7c 0e		 jl	 SHORT $LN162@Cb_gain_av

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  003a4	33 c0		 xor	 eax, eax
  003a6	66 85 d2	 test	 dx, dx
  003a9	0f 99 c0	 setns	 al
  003ac	48		 dec	 eax
  003ad	0f b7 c0	 movzx	 eax, ax

; 372  :         }
; 373  :         else

  003b0	eb 19		 jmp	 SHORT $LN185@Cb_gain_av
$LN162@Cb_gain_av:

; 374  :         {
; 375  :             if (var1 < 0)

  003b2	66 85 d2	 test	 dx, dx
  003b5	79 0e		 jns	 SHORT $LN160@Cb_gain_av

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  003b7	0f bf c2	 movsx	 eax, dx
  003ba	f7 d0		 not	 eax
  003bc	d3 f8		 sar	 eax, cl
  003be	f7 d0		 not	 eax
  003c0	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  003c3	eb 06		 jmp	 SHORT $LN185@Cb_gain_av
$LN160@Cb_gain_av:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  003c5	66 d3 fa	 sar	 dx, cl
$LN188@Cb_gain_av:

; 307  :             var_out = extract_l (result);

  003c8	0f b7 c2	 movzx	 eax, dx
$LN185@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 171  :    for (i = 0; i < M; i++) {

  003cb	8b 55 c4	 mov	 edx, DWORD PTR _lsp$GSCopy$1$[ebp]
  003ce	8b 5d d0	 mov	 ebx, DWORD PTR _lspAver$GSCopy$1$[ebp]

; 187  :          tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */

  003d1	66 89 44 3d e8	 mov	 WORD PTR _tmp$[ebp+edi], ax
  003d6	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  003d9	40		 inc	 eax
  003da	89 45 d8	 mov	 DWORD PTR _i$1$[ebp], eax
  003dd	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  003e1	0f 8c 89 fc ff
	ff		 jl	 $LL658@Cb_gain_av

; 188  :       }
; 189  :    }
; 190  :    
; 191  :    diff = tmp[0];                                   move16 ();

  003e7	0f b7 4d e8	 movzx	 ecx, WORD PTR _tmp$[ebp]
  003eb	8d 55 ea	 lea	 edx, DWORD PTR _tmp$[ebp+2]
  003ee	be 09 00 00 00	 mov	 esi, 9
$LL32@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  003f3	0f bf 02	 movsx	 eax, WORD PTR [edx]
  003f6	0f bf c9	 movsx	 ecx, cx
  003f9	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  003fb	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00401	0f 8e ef 00 00
	00		 jle	 $LN214@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00407	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00411	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00416	e9 f7 00 00 00	 jmp	 $LN211@Cb_gain_av
$LN34@Cb_gain_av:

; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  0041b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00420	66 3b c8	 cmp	 cx, ax
  00423	75 4f		 jne	 SHORT $LN183@Cb_gain_av
$LN655@Cb_gain_av:
  00425	bb ff 7f 00 00	 mov	 ebx, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 187  :          tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */

  0042a	0f b7 f2	 movzx	 esi, dx
$LN191@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0042d	ba 01 00 00 00	 mov	 edx, 1
  00432	0f bf c6	 movsx	 eax, si
  00435	8a cb		 mov	 cl, bl
  00437	d3 e2		 shl	 edx, cl
  00439	0f af d0	 imul	 edx, eax

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0043c	66 83 fb 0f	 cmp	 bx, 15			; 0000000fH
  00440	7e 05		 jle	 SHORT $LN186@Cb_gain_av
  00442	66 85 f6	 test	 si, si
  00445	75 0b		 jne	 SHORT $LN187@Cb_gain_av
$LN186@Cb_gain_av:
  00447	0f bf c2	 movsx	 eax, dx
  0044a	3b d0		 cmp	 edx, eax
  0044c	0f 84 76 ff ff
	ff		 je	 $LN188@Cb_gain_av
$LN187@Cb_gain_av:

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00452	66 85 f6	 test	 si, si
  00455	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0045f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00464	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00469	0f 4f c1	 cmovg	 eax, ecx
  0046c	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0046f	e9 57 ff ff ff	 jmp	 $LN185@Cb_gain_av
$LN183@Cb_gain_av:

; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  00474	f7 d9		 neg	 ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 187  :          tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */

  00476	0f b7 f2	 movzx	 esi, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  00479	0f b7 d9	 movzx	 ebx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 187  :          tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */

  0047c	8b c3		 mov	 eax, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 287  :     if (var2 < 0)

  0047e	66 85 db	 test	 bx, bx
  00481	79 aa		 jns	 SHORT $LN191@Cb_gain_av

; 288  :     {
; 289  :         if (var2 < -16)

  00483	66 83 fb f0	 cmp	 bx, -16			; fffffff0H
  00487	ba f0 ff ff ff	 mov	 edx, -16		; fffffff0H
  0048c	0f 4c c2	 cmovl	 eax, edx

; 291  :         var_out = shr (var1, -var2);

  0048f	f7 d8		 neg	 eax
  00491	0f b7 c8	 movzx	 ecx, ax

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)

  00494	66 85 c9	 test	 cx, cx
  00497	79 1c		 jns	 SHORT $LN200@Cb_gain_av

; 359  :     {
; 360  :         if (var2 < -16)

  00499	66 3b ca	 cmp	 cx, dx
  0049c	0f 4c ca	 cmovl	 ecx, edx

; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);

  0049f	f7 d9		 neg	 ecx
  004a1	8b d1		 mov	 edx, ecx
  004a3	8b ce		 mov	 ecx, esi
  004a5	e8 00 00 00 00	 call	 _shl
  004aa	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  004ad	0f b7 c0	 movzx	 eax, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  004b0	e9 16 ff ff ff	 jmp	 $LN185@Cb_gain_av
$LN200@Cb_gain_av:

; 369  :         if (var2 >= 15)

  004b5	66 83 f9 0f	 cmp	 cx, 15			; 0000000fH
  004b9	7c 14		 jl	 SHORT $LN197@Cb_gain_av

; 371  :             var_out = (var1 < 0) ? -1 : 0;

  004bb	33 c0		 xor	 eax, eax
  004bd	66 85 f6	 test	 si, si
  004c0	0f 99 c0	 setns	 al
  004c3	48		 dec	 eax
  004c4	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  004c7	0f b7 c0	 movzx	 eax, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  004ca	e9 fc fe ff ff	 jmp	 $LN185@Cb_gain_av
$LN197@Cb_gain_av:

; 374  :         {
; 375  :             if (var1 < 0)

  004cf	66 85 f6	 test	 si, si
  004d2	79 14		 jns	 SHORT $LN195@Cb_gain_av

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  004d4	0f bf c6	 movsx	 eax, si
  004d7	f7 d0		 not	 eax
  004d9	d3 f8		 sar	 eax, cl
  004db	f7 d0		 not	 eax
  004dd	0f b7 c0	 movzx	 eax, ax

; 291  :         var_out = shr (var1, -var2);

  004e0	0f b7 c0	 movzx	 eax, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  004e3	e9 e3 fe ff ff	 jmp	 $LN185@Cb_gain_av
$LN195@Cb_gain_av:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  004e8	66 d3 fe	 sar	 si, cl
  004eb	0f b7 c6	 movzx	 eax, si

; 291  :         var_out = shr (var1, -var2);

  004ee	0f b7 c0	 movzx	 eax, ax

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else

  004f1	e9 d5 fe ff ff	 jmp	 $LN185@Cb_gain_av
$LN214@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004f6	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  004fc	7d 11		 jge	 SHORT $LN212@Cb_gain_av

; 86   :         Overflow = 1;

  004fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00508	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0050d	eb 03		 jmp	 SHORT $LN211@Cb_gain_av
$LN212@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0050f	0f b7 c1	 movzx	 eax, cx
$LN211@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 192  :    for (i = 1; i < M; i++) { 

  00512	83 c2 02	 add	 edx, 2

; 193  :       diff = add(diff, tmp[i]);       /* Q13 */

  00515	0f b7 c8	 movzx	 ecx, ax
  00518	4e		 dec	 esi
  00519	0f 85 d4 fe ff
	ff		 jne	 $LL32@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0051f	0f bf c8	 movsx	 ecx, ax
  00522	8d b1 33 eb ff
	ff		 lea	 esi, DWORD PTR [ecx-5325]

; 79   :     if (L_var1 > 0X00007fffL)

  00528	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  0052e	7e 0c		 jle	 SHORT $LN226@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00530	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0053a	eb 39		 jmp	 SHORT $LN638@Cb_gain_av
$LN226@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0053c	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00542	7d 2c		 jge	 SHORT $LN224@Cb_gain_av

; 86   :         Overflow = 1;

  00544	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN29@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 204  :       st->hangVar = 0;     move16 ();

  0054e	8b 7d e0	 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  00551	33 c0		 xor	 eax, eax
$LN233@Cb_gain_av:
  00553	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00557	0f bf c0	 movsx	 eax, ax
  0055a	83 e8 0a	 sub	 eax, 10			; 0000000aH

; 79   :     if (L_var1 > 0X00007fffL)

  0055d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00562	7e 4e		 jle	 SHORT $LN250@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00564	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0056e	eb 5a		 jmp	 SHORT $LN639@Cb_gain_av
$LN224@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 198  :    if (sub(diff, 5325) > 0)  /* 0.65 in Q11 */

  00570	66 85 f6	 test	 si, si
  00573	7e d9		 jle	 SHORT $LN29@Cb_gain_av
$LN638@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00575	8b 7d e0	 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]
  00578	0f bf 47 0e	 movsx	 eax, WORD PTR [edi+14]
  0057c	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0057d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00582	7e 11		 jle	 SHORT $LN236@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00584	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0058e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00593	eb be		 jmp	 SHORT $LN233@Cb_gain_av
$LN236@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00595	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0059a	7d 11		 jge	 SHORT $LN234@Cb_gain_av

; 86   :         Overflow = 1;

  0059c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  005a6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  005ab	eb a6		 jmp	 SHORT $LN233@Cb_gain_av
$LN234@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  005ad	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 202  :    else

  005b0	eb a1		 jmp	 SHORT $LN233@Cb_gain_av
$LN250@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  005b2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  005b7	7d 0c		 jge	 SHORT $LN248@Cb_gain_av

; 86   :         Overflow = 1;

  005b9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  005c3	eb 0b		 jmp	 SHORT $LN255@Cb_gain_av
$LN248@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 208  :    if (sub(st->hangVar, 10) > 0)

  005c5	66 85 c0	 test	 ax, ax
  005c8	7e 06		 jle	 SHORT $LN255@Cb_gain_av
$LN639@Cb_gain_av:

; 209  :    {
; 210  :       st->hangCount = 0;  /* Speech period, reset hangover variable */ move16 ();

  005ca	33 c0		 xor	 eax, eax
  005cc	66 89 47 10	 mov	 WORD PTR [edi+16], ax
$LN255@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  005d0	8b 45 cc	 mov	 eax, DWORD PTR _mode$1$[ebp]
  005d3	0f bf d8	 movsx	 ebx, ax
  005d6	8d 43 fd	 lea	 eax, DWORD PTR [ebx-3]

; 79   :     if (L_var1 > 0X00007fffL)

  005d9	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  005de	7e 0c		 jle	 SHORT $LN266@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  005e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  005ea	eb 18		 jmp	 SHORT $LN640@Cb_gain_av
$LN266@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  005ec	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  005f1	7d 0c		 jge	 SHORT $LN264@Cb_gain_av

; 86   :         Overflow = 1;

  005f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  005fd	eb 27		 jmp	 SHORT $LN25@Cb_gain_av
$LN264@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 216  :    if ((sub(mode, MR67) <= 0) || (sub(mode, MR102) == 0))  

  005ff	66 85 c0	 test	 ax, ax
  00602	7e 22		 jle	 SHORT $LN25@Cb_gain_av
$LN640@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00604	8d 43 fa	 lea	 eax, DWORD PTR [ebx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  00607	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0060c	0f 8f 73 05 00
	00		 jg	 $LN662@Cb_gain_av

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00612	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00617	0f 8c 68 05 00
	00		 jl	 $LN662@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 216  :    if ((sub(mode, MR67) <= 0) || (sub(mode, MR102) == 0))  

  0061d	66 85 c0	 test	 ax, ax
  00620	0f 85 69 05 00
	00		 jne	 $LN659@Cb_gain_av
$LN25@Cb_gain_av:

; 225  :            (sub(mode, MR59) == 0)) ))

  00626	66 83 7d 1c 00	 cmp	 WORD PTR _pdfi$[ebp], 0
  0062b	74 07		 je	 SHORT $LN22@Cb_gain_av
  0062d	66 83 7d 20 00	 cmp	 WORD PTR _prev_pdf$[ebp], 0
  00632	75 12		 jne	 SHORT $LN23@Cb_gain_av
$LN22@Cb_gain_av:
  00634	66 83 7d 14 00	 cmp	 WORD PTR _bfi$[ebp], 0
  00639	75 0b		 jne	 SHORT $LN23@Cb_gain_av
  0063b	66 83 7d 18 00	 cmp	 WORD PTR _prev_bf$[ebp], 0
  00640	0f 84 42 01 00
	00		 je	 $LN24@Cb_gain_av
$LN23@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00646	8b 45 28	 mov	 eax, DWORD PTR _voicedHangover$[ebp]
  00649	98		 cwde
  0064a	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0064b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00650	7e 0c		 jle	 SHORT $LN304@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00652	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0065c	eb 14		 jmp	 SHORT $LN641@Cb_gain_av
$LN304@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0065e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00663	0f 8c 15 01 00
	00		 jl	 $LN660@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 225  :            (sub(mode, MR59) == 0)) ))

  00669	66 85 c0	 test	 ax, ax
  0066c	0f 8e 16 01 00
	00		 jle	 $LN24@Cb_gain_av
$LN641@Cb_gain_av:
  00672	66 83 7d 24 00	 cmp	 WORD PTR _inBackgroundNoise$[ebp], 0
  00677	0f 84 0b 01 00
	00		 je	 $LN24@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0067d	81 fb ff 7f 00
	00		 cmp	 ebx, 32767		; 00007fffH
  00683	7e 0c		 jle	 SHORT $LN314@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00685	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0068f	eb 19		 jmp	 SHORT $LN642@Cb_gain_av
$LN314@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00691	81 fb 00 80 ff
	ff		 cmp	 ebx, -32768		; ffff8000H
  00697	7d 0c		 jge	 SHORT $LN312@Cb_gain_av

; 86   :         Overflow = 1;

  00699	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  006a3	eb 05		 jmp	 SHORT $LN642@Cb_gain_av
$LN312@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 225  :            (sub(mode, MR59) == 0)) ))

  006a5	66 85 db	 test	 bx, bx
  006a8	74 50		 je	 SHORT $LN21@Cb_gain_av
$LN642@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006aa	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  006ad	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  006b2	7e 0c		 jle	 SHORT $LN324@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  006b4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  006be	eb 18		 jmp	 SHORT $LN643@Cb_gain_av
$LN324@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  006c0	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  006c5	7d 0c		 jge	 SHORT $LN322@Cb_gain_av

; 86   :         Overflow = 1;

  006c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  006d1	eb 05		 jmp	 SHORT $LN643@Cb_gain_av
$LN322@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 225  :            (sub(mode, MR59) == 0)) ))

  006d3	66 85 c0	 test	 ax, ax
  006d6	74 22		 je	 SHORT $LN21@Cb_gain_av
$LN643@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006d8	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  006db	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  006e0	0f 8f 98 00 00
	00		 jg	 $LN660@Cb_gain_av

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  006e6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  006eb	0f 8c 8d 00 00
	00		 jl	 $LN660@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 225  :            (sub(mode, MR59) == 0)) ))

  006f1	66 85 c0	 test	 ax, ax
  006f4	0f 85 8e 00 00
	00		 jne	 $LN24@Cb_gain_av
$LN21@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006fa	8d 81 66 ee ff
	ff		 lea	 eax, DWORD PTR [ecx-4506]

; 79   :     if (L_var1 > 0X00007fffL)

  00700	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00705	7e 14		 jle	 SHORT $LN344@Cb_gain_av

; 82   :         var_out = MAX_16;

  00707	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0070c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 261  :             tmp1 = tmp_diff;        move16 ();

  00716	0f b7 d1	 movzx	 edx, cx

; 262  :          }
; 263  :          else

  00719	eb 17		 jmp	 SHORT $LN403@Cb_gain_av
$LN344@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0071b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00720	0f 8d 8e 00 00
	00		 jge	 $LN392@Cb_gain_av
$LN664@Cb_gain_av:

; 86   :         Overflow = 1;

  00726	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN15@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 265  :             tmp1 = 0;               move16 ();

  00730	33 d2		 xor	 edx, edx
$LN403@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00732	0f bf ca	 movsx	 ecx, dx
  00735	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  0073a	2b c1		 sub	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  0073c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00741	0f 8e 81 00 00
	00		 jle	 $LN412@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00747	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN13@Cb_gain_av:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00751	c1 e1 02	 shl	 ecx, 2

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00754	0f bf c1	 movsx	 eax, cx
  00757	3b c8		 cmp	 ecx, eax
  00759	0f 84 95 00 00
	00		 je	 $LN422@Cb_gain_av

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0075f	66 85 d2	 test	 dx, dx
  00762	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0076c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00771	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00776	0f 4f c1	 cmovg	 eax, ecx
  00779	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0077c	eb 79		 jmp	 SHORT $LN419@Cb_gain_av
$LN660@Cb_gain_av:

; 80   :     {
; 81   :         Overflow = 1;

  0077e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN24@Cb_gain_av:

; 186  :     L_diff = (Word32) var1 - var2;

  00788	8d 81 33 f3 ff
	ff		 lea	 eax, DWORD PTR [ecx-3277]

; 79   :     if (L_var1 > 0X00007fffL)

  0078e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00793	7e 14		 jle	 SHORT $LN394@Cb_gain_av

; 82   :         var_out = MAX_16;

  00795	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0079a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 261  :             tmp1 = tmp_diff;        move16 ();

  007a4	0f b7 d1	 movzx	 edx, cx

; 262  :          }
; 263  :          else

  007a7	eb 89		 jmp	 SHORT $LN403@Cb_gain_av
$LN394@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  007a9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  007ae	0f 8c 72 ff ff
	ff		 jl	 $LN664@Cb_gain_av
$LN392@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  007b4	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 259  :          if (tmp_diff > 0)

  007b7	66 85 c0	 test	 ax, ax
  007ba	0f 8e 70 ff ff
	ff		 jle	 $LN15@Cb_gain_av

; 261  :             tmp1 = tmp_diff;        move16 ();

  007c0	0f b7 d1	 movzx	 edx, cx

; 262  :          }
; 263  :          else

  007c3	e9 6a ff ff ff	 jmp	 $LN403@Cb_gain_av
$LN412@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  007c8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  007cd	7d 13		 jge	 SHORT $LN410@Cb_gain_av

; 86   :         Overflow = 1;

  007cf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 272  :             bgMix = 8192;           move16 ();

  007d9	c7 45 e4 00 20
	00 00		 mov	 DWORD PTR _bgMix$1$[ebp], 8192 ; 00002000H

; 273  :          }
; 274  :          else

  007e0	eb 1b		 jmp	 SHORT $LN12@Cb_gain_av
$LN410@Cb_gain_av:

; 266  :          }
; 267  : 
; 268  :          /* min(0.25, tmp1) */
; 269  :          test ();
; 270  :          if (sub(2048, tmp1) < 0)

  007e2	66 85 c0	 test	 ax, ax
  007e5	0f 89 66 ff ff
	ff		 jns	 $LN13@Cb_gain_av

; 272  :             bgMix = 8192;           move16 ();

  007eb	c7 45 e4 00 20
	00 00		 mov	 DWORD PTR _bgMix$1$[ebp], 8192 ; 00002000H

; 273  :          }
; 274  :          else

  007f2	eb 09		 jmp	 SHORT $LN12@Cb_gain_av
$LN422@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  007f4	0f b7 c1	 movzx	 eax, cx
$LN419@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 276  :             bgMix = shl(tmp1, 2);

  007f7	0f b7 c8	 movzx	 ecx, ax
  007fa	89 4d e4	 mov	 DWORD PTR _bgMix$1$[ebp], ecx
$LN12@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  007fd	0f bf 47 10	 movsx	 eax, WORD PTR [edi+16]
  00801	83 e8 28	 sub	 eax, 40			; 00000028H

; 79   :     if (L_var1 > 0X00007fffL)

  00804	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00809	7e 0c		 jle	 SHORT $LN448@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  0080b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00815	eb 18		 jmp	 SHORT $LN646@Cb_gain_av
$LN448@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00817	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0081c	7d 0c		 jge	 SHORT $LN446@Cb_gain_av

; 86   :         Overflow = 1;

  0081e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00828	eb 32		 jmp	 SHORT $LN10@Cb_gain_av
$LN446@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 281  :       if ((sub(st->hangCount, 40) < 0) || (sub(diff, 5325) > 0)) /* 0.65 in Q13 */

  0082a	66 85 c0	 test	 ax, ax
  0082d	78 2d		 js	 SHORT $LN10@Cb_gain_av
$LN646@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0082f	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00835	7e 0c		 jle	 SHORT $LN458@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00837	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00841	eb 19		 jmp	 SHORT $LN10@Cb_gain_av
$LN458@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00843	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00849	7d 0c		 jge	 SHORT $LN456@Cb_gain_av

; 86   :         Overflow = 1;

  0084b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00855	eb 0c		 jmp	 SHORT $LN463@Cb_gain_av
$LN456@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 281  :       if ((sub(st->hangCount, 40) < 0) || (sub(diff, 5325) > 0)) /* 0.65 in Q13 */

  00857	66 85 f6	 test	 si, si
  0085a	7e 07		 jle	 SHORT $LN463@Cb_gain_av
$LN10@Cb_gain_av:

; 282  :       {
; 283  :          bgMix = 8192;  /* disable mix if too short time since */ move16 ();

  0085c	c7 45 e4 00 20
	00 00		 mov	 DWORD PTR _bgMix$1$[ebp], 8192 ; 00002000H
$LN463@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00863	0f bf 47 04	 movsx	 eax, WORD PTR [edi+4]
  00867	69 d0 9a 19 00
	00		 imul	 edx, eax, 6554

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0086d	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  00873	74 04		 je	 SHORT $LN466@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  00875	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  00877	eb 0f		 jmp	 SHORT $LN465@Cb_gain_av
$LN466@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  00879	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00883	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN465@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 288  :       L_sum = L_mult(6554, st->cbGainHistory[2]);     /* 0.2 in Q15; L_sum in Q17 */   

  00888	8d 77 06	 lea	 esi, DWORD PTR [edi+6]
  0088b	bf 04 00 00 00	 mov	 edi, 4
$LL9@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00890	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00893	69 c0 9a 19 00
	00		 imul	 eax, eax, 6554

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00899	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0089e	74 04		 je	 SHORT $LN472@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  008a0	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  008a2	eb 0f		 jmp	 SHORT $LN471@Cb_gain_av
$LN472@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  008a4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  008ae	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN471@Cb_gain_av:

; 931  :     L_var_out = L_var1 + L_var2;

  008b3	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  008b6	33 c2		 xor	 eax, edx
  008b8	78 1d		 js	 SHORT $LN475@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  008ba	8b c1		 mov	 eax, ecx
  008bc	33 c2		 xor	 eax, edx
  008be	79 17		 jns	 SHORT $LN475@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  008c0	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  008c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  008cc	85 d2		 test	 edx, edx
  008ce	0f 98 c1	 sets	 cl
  008d1	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN475@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 289  :       for (i = 3; i < L_CBGAINHIST; i++)

  008d7	83 c6 02	 add	 esi, 2

; 290  :       {
; 291  :          L_sum = L_mac(L_sum, 6554, st->cbGainHistory[i]);

  008da	8b d1		 mov	 edx, ecx
  008dc	4f		 dec	 edi
  008dd	75 b1		 jne	 SHORT $LL9@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  008df	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  008e5	85 c9		 test	 ecx, ecx
  008e7	78 1d		 js	 SHORT $LN481@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  008e9	8b c2		 mov	 eax, edx
  008eb	33 c1		 xor	 eax, ecx
  008ed	79 17		 jns	 SHORT $LN481@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  008ef	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  008f1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  008fb	85 c9		 test	 ecx, ecx
  008fd	0f 98 c2	 sets	 dl
  00900	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN481@Cb_gain_av:

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  00906	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 300  :            (sub(mode, MR59) == 0)) )

  00909	66 83 7d 14 00	 cmp	 WORD PTR _bfi$[ebp], 0
  0090e	0f b7 d2	 movzx	 edx, dx
  00911	75 0b		 jne	 SHORT $LN5@Cb_gain_av
  00913	66 83 7d 18 00	 cmp	 WORD PTR _prev_bf$[ebp], 0
  00918	0f 84 4e 01 00
	00		 je	 $LN6@Cb_gain_av
$LN5@Cb_gain_av:
  0091e	66 83 7d 24 00	 cmp	 WORD PTR _inBackgroundNoise$[ebp], 0
  00923	0f 84 43 01 00
	00		 je	 $LN6@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00929	81 fb ff 7f 00
	00		 cmp	 ebx, 32767		; 00007fffH
  0092f	7e 0c		 jle	 SHORT $LN504@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00931	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0093b	eb 19		 jmp	 SHORT $LN647@Cb_gain_av
$LN504@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0093d	81 fb 00 80 ff
	ff		 cmp	 ebx, -32768		; ffff8000H
  00943	7d 0c		 jge	 SHORT $LN502@Cb_gain_av

; 86   :         Overflow = 1;

  00945	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0094f	eb 05		 jmp	 SHORT $LN647@Cb_gain_av
$LN502@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 300  :            (sub(mode, MR59) == 0)) )

  00951	66 85 db	 test	 bx, bx
  00954	74 68		 je	 SHORT $LN4@Cb_gain_av
$LN647@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00956	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  00959	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0095e	7e 0c		 jle	 SHORT $LN514@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00960	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0096a	eb 18		 jmp	 SHORT $LN648@Cb_gain_av
$LN514@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0096c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00971	7d 0c		 jge	 SHORT $LN512@Cb_gain_av

; 86   :         Overflow = 1;

  00973	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0097d	eb 05		 jmp	 SHORT $LN648@Cb_gain_av
$LN512@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 300  :            (sub(mode, MR59) == 0)) )

  0097f	66 85 c0	 test	 ax, ax
  00982	74 3a		 je	 SHORT $LN4@Cb_gain_av
$LN648@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00984	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 79   :     if (L_var1 > 0X00007fffL)

  00987	81 fb ff 7f 00
	00		 cmp	 ebx, 32767		; 00007fffH
  0098d	7e 0f		 jle	 SHORT $LN524@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  0098f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00999	e9 ce 00 00 00	 jmp	 $LN6@Cb_gain_av
$LN524@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0099e	81 fb 00 80 ff
	ff		 cmp	 ebx, -32768		; ffff8000H
  009a4	7d 0f		 jge	 SHORT $LN522@Cb_gain_av

; 86   :         Overflow = 1;

  009a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  009b0	e9 b7 00 00 00	 jmp	 $LN6@Cb_gain_av
$LN522@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 300  :            (sub(mode, MR59) == 0)) )

  009b5	66 85 db	 test	 bx, bx
  009b8	0f 85 ae 00 00
	00		 jne	 $LN6@Cb_gain_av
$LN4@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  009be	8b 45 e0	 mov	 eax, DWORD PTR _st$GSCopy$1$[ebp]
  009c1	0f bf 00	 movsx	 eax, WORD PTR [eax]
  009c4	69 d0 49 12 00
	00		 imul	 edx, eax, 4681

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  009ca	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  009d0	74 04		 je	 SHORT $LN530@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  009d2	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  009d4	eb 0f		 jmp	 SHORT $LN529@Cb_gain_av
$LN530@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  009d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  009e0	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN529@Cb_gain_av:
  009e5	8b 5d c8	 mov	 ebx, DWORD PTR tv2388[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 302  :          L_sum = L_mult(4681, st->cbGainHistory[0]);  /* 0.143 in Q15; L_sum in Q17 */     

  009e8	be 06 00 00 00	 mov	 esi, 6
  009ed	8d 49 00	 npad	 3
$LL3@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  009f0	0f bf 03	 movsx	 eax, WORD PTR [ebx]
  009f3	69 c0 49 12 00
	00		 imul	 eax, eax, 4681

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  009f9	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  009fe	74 04		 je	 SHORT $LN536@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  00a00	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00a02	eb 0f		 jmp	 SHORT $LN535@Cb_gain_av
$LN536@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  00a04	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00a0e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN535@Cb_gain_av:

; 931  :     L_var_out = L_var1 + L_var2;

  00a13	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00a16	33 c2		 xor	 eax, edx
  00a18	78 1d		 js	 SHORT $LN539@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00a1a	8b c1		 mov	 eax, ecx
  00a1c	33 c2		 xor	 eax, edx
  00a1e	79 17		 jns	 SHORT $LN539@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00a20	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  00a22	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00a2c	85 d2		 test	 edx, edx
  00a2e	0f 98 c1	 sets	 cl
  00a31	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN539@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 303  :          for (i = 1; i < L_CBGAINHIST; i++)

  00a37	83 c3 02	 add	 ebx, 2

; 304  :          {
; 305  :             L_sum = L_mac(L_sum, 4681, st->cbGainHistory[i]);

  00a3a	8b d1		 mov	 edx, ecx
  00a3c	4e		 dec	 esi
  00a3d	75 b1		 jne	 SHORT $LL3@Cb_gain_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  00a3f	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00a45	85 c9		 test	 ecx, ecx
  00a47	78 1d		 js	 SHORT $LN545@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00a49	8b c2		 mov	 eax, edx
  00a4b	33 c1		 xor	 eax, ecx
  00a4d	79 17		 jns	 SHORT $LN545@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00a4f	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00a51	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00a5b	85 c9		 test	 ecx, ecx
  00a5d	0f 98 c2	 sets	 dl
  00a60	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN545@Cb_gain_av:

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  00a66	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 307  :          cbGainMean = round(L_sum);                   /* Q1 */

  00a69	0f b7 d2	 movzx	 edx, dx
$LN6@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00a6c	8b 45 e4	 mov	 eax, DWORD PTR _bgMix$1$[ebp]
  00a6f	0f bf 4d 08	 movsx	 ecx, WORD PTR _gain_code$[ebp]
  00a73	0f bf f8	 movsx	 edi, ax
  00a76	0f af cf	 imul	 ecx, edi

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00a79	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00a7f	74 04		 je	 SHORT $LN552@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  00a81	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  00a83	eb 0f		 jmp	 SHORT $LN551@Cb_gain_av
$LN552@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  00a85	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00a8f	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN551@Cb_gain_av:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00a94	0f bf f2	 movsx	 esi, dx
  00a97	8b c6		 mov	 eax, esi
  00a99	c1 e0 0d	 shl	 eax, 13			; 0000000dH

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00a9c	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00aa1	74 04		 je	 SHORT $LN558@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  00aa3	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00aa5	eb 0f		 jmp	 SHORT $LN557@Cb_gain_av
$LN558@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  00aa7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00ab1	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN557@Cb_gain_av:

; 931  :     L_var_out = L_var1 + L_var2;

  00ab6	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00ab9	33 c1		 xor	 eax, ecx
  00abb	78 1d		 js	 SHORT $LN561@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00abd	8b c2		 mov	 eax, edx
  00abf	33 c1		 xor	 eax, ecx
  00ac1	79 17		 jns	 SHORT $LN561@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00ac3	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00ac5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00acf	85 c9		 test	 ecx, ecx
  00ad1	0f 98 c2	 sets	 dl
  00ad4	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN561@Cb_gain_av:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00ada	0f af f7	 imul	 esi, edi

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00add	81 fe 00 00 00
	40		 cmp	 esi, 1073741824		; 40000000H
  00ae3	74 05		 je	 SHORT $LN568@Cb_gain_av

; 488  :     {
; 489  :         L_var_out *= 2;

  00ae5	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]

; 490  :     }
; 491  :     else

  00ae8	eb 0f		 jmp	 SHORT $LN567@Cb_gain_av
$LN568@Cb_gain_av:

; 492  :     {
; 493  :         Overflow = 1;

  00aea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00af4	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN567@Cb_gain_av:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  00af9	8b ca		 mov	 ecx, edx
  00afb	2b c8		 sub	 ecx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00afd	33 c2		 xor	 eax, edx
  00aff	79 1d		 jns	 SHORT $LN571@Cb_gain_av

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00b01	8b c1		 mov	 eax, ecx
  00b03	33 c2		 xor	 eax, edx
  00b05	79 17		 jns	 SHORT $LN571@Cb_gain_av

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00b07	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  00b09	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00b13	85 d2		 test	 edx, edx
  00b15	0f 98 c1	 sets	 cl
  00b18	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN571@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 314  :       cbGainMix = round(L_shl(L_sum, 2));             /* Q1 */

  00b1e	b8 02 00 00 00	 mov	 eax, 2
$LL583@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00b23	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00b29	7f 19		 jg	 SHORT $LN612@Cb_gain_av

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00b2b	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  00b31	7c 0a		 jl	 SHORT $LN613@Cb_gain_av

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00b33	48		 dec	 eax
  00b34	03 c9		 add	 ecx, ecx
  00b36	66 85 c0	 test	 ax, ax
  00b39	7f e8		 jg	 SHORT $LL583@Cb_gain_av

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00b3b	eb 16		 jmp	 SHORT $LN578@Cb_gain_av
$LN613@Cb_gain_av:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  00b3d	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00b42	eb 05		 jmp	 SHORT $LN661@Cb_gain_av
$LN612@Cb_gain_av:

; 1360 :                 L_var_out = MAX_32;

  00b44	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN661@Cb_gain_av:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00b49	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN578@Cb_gain_av:

; 931  :     L_var_out = L_var1 + L_var2;

  00b53	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00b59	85 c9		 test	 ecx, ecx
  00b5b	78 1d		 js	 SHORT $LN588@Cb_gain_av

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00b5d	8b c2		 mov	 eax, edx
  00b5f	33 c1		 xor	 eax, ecx
  00b61	79 17		 jns	 SHORT $LN588@Cb_gain_av

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00b63	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00b65	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00b6f	85 c9		 test	 ecx, ecx
  00b71	0f 98 c2	 sets	 dl
  00b74	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN588@Cb_gain_av:
  00b7a	8b 7d e0	 mov	 edi, DWORD PTR _st$GSCopy$1$[ebp]

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  00b7d	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 314  :       cbGainMix = round(L_shl(L_sum, 2));             /* Q1 */

  00b80	0f b7 d2	 movzx	 edx, dx
  00b83	eb 0d		 jmp	 SHORT $LN26@Cb_gain_av
$LN662@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00b85	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN659@Cb_gain_av:
  00b8f	8b 55 dc	 mov	 edx, DWORD PTR _cbGainMix$1$[ebp]
$LN26@Cb_gain_av:

; 139  :     L_sum = (Word32) var1 + var2;

  00b92	0f bf 4f 10	 movsx	 ecx, WORD PTR [edi+16]
  00b96	41		 inc	 ecx

; 79   :     if (L_var1 > 0X00007fffL)

  00b97	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00b9d	7e 11		 jle	 SHORT $LN599@Cb_gain_av

; 80   :     {
; 81   :         Overflow = 1;

  00b9f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00ba9	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00bae	eb 1c		 jmp	 SHORT $LN663@Cb_gain_av
$LN599@Cb_gain_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00bb0	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00bb6	7d 11		 jge	 SHORT $LN597@Cb_gain_av

; 86   :         Overflow = 1;

  00bb8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00bc2	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00bc7	eb 03		 jmp	 SHORT $LN663@Cb_gain_av
$LN597@Cb_gain_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00bc9	0f b7 c1	 movzx	 eax, cx
$LN663@Cb_gain_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 319  : }

  00bcc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bcf	66 89 47 10	 mov	 WORD PTR [edi+16], ax
  00bd3	33 cd		 xor	 ecx, ebp
  00bd5	5f		 pop	 edi
  00bd6	5e		 pop	 esi
  00bd7	66 8b c2	 mov	 ax, dx
  00bda	5b		 pop	 ebx
  00bdb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be0	8b e5		 mov	 esp, ebp
  00be2	5d		 pop	 ebp
  00be3	c3		 ret	 0
_Cb_gain_average ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_init
_TEXT	SEGMENT
_Cb_gain_average_init PROC				; COMDAT
; _state$ = ecx

; 58   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 59   :    Cb_gain_averageState* s;
; 60   :    
; 61   :    if (state == (Cb_gain_averageState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@Cb_gain_av

; 62   :       fprintf(stderr, "Cb_gain_average_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOCPFLEA@Cb_gain_average_init?3?5invalid?5pa@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 63   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 77   : }

  00023	c3		 ret	 0
$LN2@Cb_gain_av:
  00024	57		 push	 edi

; 64   :    }
; 65   :    *state = NULL;
; 66   :    
; 67   :    /* allocate memory */
; 68   :    if ((s= (Cb_gain_averageState *) malloc(sizeof(Cb_gain_averageState))) == NULL){

  00025	6a 12		 push	 18			; 00000012H
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	75 1e		 jne	 SHORT $LN1@Cb_gain_av

; 69   :      fprintf(stderr, "Cb_gain_average_init: can not malloc state structure\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@BMLKEPHG@Cb_gain_average_init?3?5can?5not?5ma@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00047	83 c0 40	 add	 eax, 64			; 00000040H
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00051	83 c4 08	 add	 esp, 8

; 70   :      return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 77   : }

  00059	c3		 ret	 0
$LN1@Cb_gain_av:

; 71   :    }
; 72   :    
; 73   :    Cb_gain_average_reset(s);

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _Cb_gain_average_reset

; 74   :    *state = s;

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 75   :    
; 76   :    return 0;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 77   : }

  00067	c3		 ret	 0
_Cb_gain_average_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_exit
_TEXT	SEGMENT
_Cb_gain_average_exit PROC				; COMDAT
; _state$ = ecx

; 113  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 114  :    if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@Cb_gain_av
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@Cb_gain_av

; 115  :       return;
; 116  : 
; 117  :    /* deallocate memory */
; 118  :    free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 119  :    *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Cb_gain_av:
  0001d	5e		 pop	 esi

; 120  :    
; 121  :    return;
; 122  : }

  0001e	c3		 ret	 0
_Cb_gain_average_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
;	COMDAT _Cb_gain_average_reset
_TEXT	SEGMENT
_Cb_gain_average_reset PROC				; COMDAT
; _state$ = ecx

; 89   :    if (state == (Cb_gain_averageState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN1@Cb_gain_av

; 90   :       fprintf(stderr, "Cb_gain_average_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 91   :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 100  :    
; 101  :    return 0;
; 102  : }

  0001f	c3		 ret	 0
$LN1@Cb_gain_av:
  00020	0f 57 c0	 xorps	 xmm0, xmm0

; 99   :    state->hangCount= 0;

  00023	33 c0		 xor	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00025	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00029	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00030	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 99   :    state->hangCount= 0;

  00037	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 100  :    
; 101  :    return 0;
; 102  : }

  0003b	c3		 ret	 0
_Cb_gain_average_reset ENDP
_TEXT	ENDS
END
