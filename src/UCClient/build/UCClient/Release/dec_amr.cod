; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\dec_amr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@ ; `string'
PUBLIC	??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@ ; `string'
PUBLIC	??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@ ; `string'
;	COMDAT ??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@ DB 'Decoder_amr_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@ DB 'Decoder_amr_r'
	DB	'eset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@ DB 'Decoder_amr_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
	ORG $+2
_sort_59 DW	00H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	06H
	DW	07H
	DW	02H
	DW	0dH
	DW	0fH
	DW	08H
	DW	09H
	DW	0bH
	DW	0cH
	DW	0eH
	DW	0aH
	DW	010H
	DW	01cH
	DW	04aH
	DW	01dH
	DW	04bH
	DW	01bH
	DW	049H
	DW	01aH
	DW	048H
	DW	01eH
	DW	04cH
	DW	033H
	DW	061H
	DW	032H
	DW	047H
	DW	060H
	DW	075H
	DW	01fH
	DW	04dH
	DW	034H
	DW	062H
	DW	031H
	DW	046H
	DW	05fH
	DW	074H
	DW	035H
	DW	063H
	DW	020H
	DW	04eH
	DW	021H
	DW	04fH
	DW	030H
	DW	045H
	DW	05eH
	DW	073H
	DW	02fH
	DW	044H
	DW	05dH
	DW	072H
	DW	02eH
	DW	043H
	DW	05cH
	DW	071H
	DW	013H
	DW	015H
	DW	017H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	06fH
	DW	02bH
	DW	059H
	DW	06eH
	DW	040H
	DW	041H
	DW	02cH
	DW	05aH
	DW	019H
	DW	02dH
	DW	042H
	DW	05bH
	DW	070H
	DW	036H
	DW	064H
	DW	028H
	DW	03dH
	DW	056H
	DW	06bH
	DW	027H
	DW	03cH
	DW	055H
	DW	06aH
	DW	024H
	DW	039H
	DW	052H
	DW	067H
	DW	023H
	DW	038H
	DW	051H
	DW	066H
	DW	022H
	DW	037H
	DW	050H
	DW	065H
	DW	02aH
	DW	03fH
	DW	058H
	DW	06dH
	DW	029H
	DW	03eH
	DW	057H
	DW	06cH
	DW	026H
	DW	03bH
	DW	054H
	DW	069H
	DW	025H
	DW	03aH
	DW	053H
	DW	068H
	ORG $+4
_sort_122 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	017H
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	026H
	DW	08dH
	DW	027H
	DW	08eH
	DW	028H
	DW	08fH
	DW	029H
	DW	090H
	DW	02aH
	DW	091H
	DW	02bH
	DW	092H
	DW	02cH
	DW	093H
	DW	02dH
	DW	094H
	DW	02eH
	DW	095H
	DW	02fH
	DW	061H
	DW	096H
	DW	0c8H
	DW	030H
	DW	062H
	DW	097H
	DW	0c9H
	DW	031H
	DW	063H
	DW	098H
	DW	0caH
	DW	056H
	DW	088H
	DW	0bdH
	DW	0efH
	DW	057H
	DW	089H
	DW	0beH
	DW	0f0H
	DW	058H
	DW	08aH
	DW	0bfH
	DW	0f1H
	DW	05bH
	DW	0c2H
	DW	05cH
	DW	0c3H
	DW	05dH
	DW	0c4H
	DW	05eH
	DW	0c5H
	DW	05fH
	DW	0c6H
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	032H
	DW	064H
	DW	099H
	DW	0cbH
	DW	059H
	DW	08bH
	DW	0c0H
	DW	0f2H
	DW	033H
	DW	065H
	DW	09aH
	DW	0ccH
	DW	037H
	DW	069H
	DW	09eH
	DW	0d0H
	DW	05aH
	DW	08cH
	DW	0c1H
	DW	0f3H
	DW	03bH
	DW	06dH
	DW	0a2H
	DW	0d4H
	DW	03fH
	DW	071H
	DW	0a6H
	DW	0d8H
	DW	043H
	DW	075H
	DW	0aaH
	DW	0dcH
	DW	024H
	DW	025H
	DW	036H
	DW	035H
	DW	034H
	DW	03aH
	DW	039H
	DW	038H
	DW	03eH
	DW	03dH
	DW	03cH
	DW	042H
	DW	041H
	DW	040H
	DW	046H
	DW	045H
	DW	044H
	DW	068H
	DW	067H
	DW	066H
	DW	06cH
	DW	06bH
	DW	06aH
	DW	070H
	DW	06fH
	DW	06eH
	DW	074H
	DW	073H
	DW	072H
	DW	078H
	DW	077H
	DW	076H
	DW	09dH
	DW	09cH
	DW	09bH
	DW	0a1H
	DW	0a0H
	DW	09fH
	DW	0a5H
	DW	0a4H
	DW	0a3H
	DW	0a9H
	DW	0a8H
	DW	0a7H
	DW	0adH
	DW	0acH
	DW	0abH
	DW	0cfH
	DW	0ceH
	DW	0cdH
	DW	0d3H
	DW	0d2H
	DW	0d1H
	DW	0d7H
	DW	0d6H
	DW	0d5H
	DW	0dbH
	DW	0daH
	DW	0d9H
	DW	0dfH
	DW	0deH
	DW	0ddH
	DW	049H
	DW	048H
	DW	047H
	DW	04cH
	DW	04bH
	DW	04aH
	DW	04fH
	DW	04eH
	DW	04dH
	DW	052H
	DW	051H
	DW	050H
	DW	055H
	DW	054H
	DW	053H
	DW	07bH
	DW	07aH
	DW	079H
	DW	07eH
	DW	07dH
	DW	07cH
	DW	081H
	DW	080H
	DW	07fH
	DW	084H
	DW	083H
	DW	082H
	DW	087H
	DW	086H
	DW	085H
	DW	0b0H
	DW	0afH
	DW	0aeH
	DW	0b3H
	DW	0b2H
	DW	0b1H
	DW	0b6H
	DW	0b5H
	DW	0b4H
	DW	0b9H
	DW	0b8H
	DW	0b7H
	DW	0bcH
	DW	0bbH
	DW	0baH
	DW	0e2H
	DW	0e1H
	DW	0e0H
	DW	0e5H
	DW	0e4H
	DW	0e3H
	DW	0e8H
	DW	0e7H
	DW	0e6H
	DW	0ebH
	DW	0eaH
	DW	0e9H
	DW	0eeH
	DW	0edH
	DW	0ecH
	DW	060H
	DW	0c7H
_sort_795 DW	08H
	DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	0eH
	DW	010H
	DW	09H
	DW	0aH
	DW	0cH
	DW	0dH
	DW	0fH
	DW	0bH
	DW	011H
	DW	014H
	DW	016H
	DW	018H
	DW	017H
	DW	013H
	DW	012H
	DW	015H
	DW	038H
	DW	058H
	DW	07aH
	DW	09aH
	DW	039H
	DW	059H
	DW	07bH
	DW	09bH
	DW	03aH
	DW	05aH
	DW	07cH
	DW	09cH
	DW	034H
	DW	054H
	DW	076H
	DW	096H
	DW	035H
	DW	055H
	DW	077H
	DW	097H
	DW	01bH
	DW	05dH
	DW	01cH
	DW	05eH
	DW	01dH
	DW	05fH
	DW	01eH
	DW	060H
	DW	01fH
	DW	061H
	DW	03dH
	DW	07fH
	DW	03eH
	DW	080H
	DW	03fH
	DW	081H
	DW	03bH
	DW	05bH
	DW	07dH
	DW	09dH
	DW	020H
	DW	062H
	DW	040H
	DW	082H
	DW	01H
	DW	00H
	DW	019H
	DW	01aH
	DW	021H
	DW	063H
	DW	022H
	DW	064H
	DW	041H
	DW	083H
	DW	042H
	DW	084H
	DW	036H
	DW	056H
	DW	078H
	DW	098H
	DW	03cH
	DW	05cH
	DW	07eH
	DW	09eH
	DW	037H
	DW	057H
	DW	079H
	DW	099H
	DW	075H
	DW	074H
	DW	073H
	DW	02eH
	DW	04eH
	DW	070H
	DW	090H
	DW	02bH
	DW	04bH
	DW	06dH
	DW	08dH
	DW	028H
	DW	048H
	DW	06aH
	DW	08aH
	DW	024H
	DW	044H
	DW	066H
	DW	086H
	DW	072H
	DW	095H
	DW	094H
	DW	093H
	DW	092H
	DW	053H
	DW	052H
	DW	051H
	DW	050H
	DW	033H
	DW	032H
	DW	031H
	DW	030H
	DW	02fH
	DW	02dH
	DW	02cH
	DW	02aH
	DW	027H
	DW	023H
	DW	04fH
	DW	04dH
	DW	04cH
	DW	04aH
	DW	047H
	DW	043H
	DW	071H
	DW	06fH
	DW	06eH
	DW	06cH
	DW	069H
	DW	065H
	DW	091H
	DW	08fH
	DW	08eH
	DW	08cH
	DW	089H
	DW	085H
	DW	029H
	DW	049H
	DW	06bH
	DW	08bH
	DW	025H
	DW	045H
	DW	067H
	DW	087H
	DW	026H
	DW	046H
	DW	068H
	DW	088H
	ORG $+2
_sort_102 DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	00H
	DW	010H
	DW	0fH
	DW	0eH
	DW	0dH
	DW	0cH
	DW	0bH
	DW	0aH
	DW	09H
	DW	08H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	073H
	DW	074H
	DW	075H
	DW	076H
	DW	077H
	DW	078H
	DW	048H
	DW	049H
	DW	0a1H
	DW	0a2H
	DW	041H
	DW	044H
	DW	045H
	DW	06cH
	DW	06fH
	DW	070H
	DW	09aH
	DW	09dH
	DW	09eH
	DW	0c5H
	DW	0c8H
	DW	0c9H
	DW	020H
	DW	021H
	DW	079H
	DW	07aH
	DW	04aH
	DW	04bH
	DW	0a3H
	DW	0a4H
	DW	042H
	DW	06dH
	DW	09bH
	DW	0c6H
	DW	013H
	DW	017H
	DW	015H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	019H
	DW	025H
	DW	024H
	DW	023H
	DW	022H
	DW	050H
	DW	04fH
	DW	04eH
	DW	04dH
	DW	07eH
	DW	07dH
	DW	07cH
	DW	07bH
	DW	0a9H
	DW	0a8H
	DW	0a7H
	DW	0a6H
	DW	046H
	DW	043H
	DW	047H
	DW	071H
	DW	06eH
	DW	072H
	DW	09fH
	DW	09cH
	DW	0a0H
	DW	0caH
	DW	0c7H
	DW	0cbH
	DW	04cH
	DW	0a5H
	DW	051H
	DW	052H
	DW	05cH
	DW	05bH
	DW	05dH
	DW	053H
	DW	05fH
	DW	055H
	DW	054H
	DW	05eH
	DW	065H
	DW	066H
	DW	060H
	DW	068H
	DW	056H
	DW	067H
	DW	057H
	DW	061H
	DW	07fH
	DW	080H
	DW	08aH
	DW	089H
	DW	08bH
	DW	081H
	DW	08dH
	DW	083H
	DW	082H
	DW	08cH
	DW	093H
	DW	094H
	DW	08eH
	DW	096H
	DW	084H
	DW	095H
	DW	085H
	DW	08fH
	DW	0aaH
	DW	0abH
	DW	0b5H
	DW	0b4H
	DW	0b6H
	DW	0acH
	DW	0b8H
	DW	0aeH
	DW	0adH
	DW	0b7H
	DW	0beH
	DW	0bfH
	DW	0b9H
	DW	0c1H
	DW	0afH
	DW	0c0H
	DW	0b0H
	DW	0baH
	DW	026H
	DW	027H
	DW	031H
	DW	030H
	DW	032H
	DW	028H
	DW	034H
	DW	02aH
	DW	029H
	DW	033H
	DW	03aH
	DW	03bH
	DW	035H
	DW	03dH
	DW	02bH
	DW	03cH
	DW	02cH
	DW	036H
	DW	0c2H
	DW	0b3H
	DW	0bdH
	DW	0c4H
	DW	0b1H
	DW	0c3H
	DW	0b2H
	DW	0bbH
	DW	0bcH
	DW	097H
	DW	088H
	DW	092H
	DW	099H
	DW	086H
	DW	098H
	DW	087H
	DW	090H
	DW	091H
	DW	069H
	DW	05aH
	DW	064H
	DW	06bH
	DW	058H
	DW	06aH
	DW	059H
	DW	062H
	DW	063H
	DW	03eH
	DW	02fH
	DW	039H
	DW	040H
	DW	02dH
	DW	03fH
	DW	02eH
	DW	037H
	DW	038H
_sort_475 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	030H
	DW	031H
	DW	03dH
	DW	03eH
	DW	052H
	DW	053H
	DW	02fH
	DW	02eH
	DW	02dH
	DW	02cH
	DW	051H
	DW	050H
	DW	04fH
	DW	04eH
	DW	011H
	DW	012H
	DW	014H
	DW	016H
	DW	04dH
	DW	04cH
	DW	04bH
	DW	04aH
	DW	01dH
	DW	01eH
	DW	02bH
	DW	02aH
	DW	029H
	DW	028H
	DW	026H
	DW	027H
	DW	010H
	DW	013H
	DW	015H
	DW	032H
	DW	033H
	DW	03bH
	DW	03cH
	DW	03fH
	DW	040H
	DW	048H
	DW	049H
	DW	054H
	DW	055H
	DW	05dH
	DW	05eH
	DW	020H
	DW	021H
	DW	023H
	DW	024H
	DW	035H
	DW	036H
	DW	038H
	DW	039H
	DW	042H
	DW	043H
	DW	045H
	DW	046H
	DW	057H
	DW	058H
	DW	05aH
	DW	05bH
	DW	022H
	DW	037H
	DW	044H
	DW	059H
	DW	025H
	DW	03aH
	DW	047H
	DW	05cH
	DW	01fH
	DW	034H
	DW	041H
	DW	056H
	ORG $+2
_sort_67 DW	00H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	06H
	DW	0dH
	DW	07H
	DW	02H
	DW	08H
	DW	09H
	DW	0bH
	DW	0fH
	DW	0cH
	DW	0eH
	DW	0aH
	DW	01cH
	DW	052H
	DW	01dH
	DW	053H
	DW	01bH
	DW	051H
	DW	01aH
	DW	050H
	DW	01eH
	DW	054H
	DW	010H
	DW	037H
	DW	06dH
	DW	038H
	DW	06eH
	DW	01fH
	DW	055H
	DW	039H
	DW	06fH
	DW	030H
	DW	049H
	DW	066H
	DW	07fH
	DW	020H
	DW	056H
	DW	033H
	DW	04cH
	DW	069H
	DW	082H
	DW	034H
	DW	04dH
	DW	06aH
	DW	083H
	DW	03aH
	DW	070H
	DW	021H
	DW	057H
	DW	013H
	DW	017H
	DW	035H
	DW	04eH
	DW	06bH
	DW	084H
	DW	015H
	DW	016H
	DW	012H
	DW	011H
	DW	014H
	DW	018H
	DW	019H
	DW	032H
	DW	04bH
	DW	068H
	DW	081H
	DW	02fH
	DW	048H
	DW	065H
	DW	07eH
	DW	036H
	DW	04fH
	DW	06cH
	DW	085H
	DW	02eH
	DW	047H
	DW	064H
	DW	07dH
	DW	080H
	DW	067H
	DW	04aH
	DW	031H
	DW	02dH
	DW	046H
	DW	063H
	DW	07cH
	DW	02aH
	DW	043H
	DW	060H
	DW	079H
	DW	027H
	DW	040H
	DW	05dH
	DW	076H
	DW	026H
	DW	03fH
	DW	05cH
	DW	075H
	DW	023H
	DW	03cH
	DW	059H
	DW	072H
	DW	022H
	DW	03bH
	DW	058H
	DW	071H
	DW	02cH
	DW	045H
	DW	062H
	DW	07bH
	DW	02bH
	DW	044H
	DW	061H
	DW	07aH
	DW	029H
	DW	042H
	DW	05fH
	DW	078H
	DW	028H
	DW	041H
	DW	05eH
	DW	077H
	DW	025H
	DW	03eH
	DW	05bH
	DW	074H
	DW	024H
	DW	03dH
	DW	05aH
	DW	073H
	ORG $+4
_sort_74 DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	01aH
	DW	057H
	DW	01bH
	DW	058H
	DW	01cH
	DW	059H
	DW	01dH
	DW	05aH
	DW	01eH
	DW	05bH
	DW	033H
	DW	050H
	DW	070H
	DW	08dH
	DW	034H
	DW	051H
	DW	071H
	DW	08eH
	DW	036H
	DW	053H
	DW	073H
	DW	090H
	DW	037H
	DW	054H
	DW	074H
	DW	091H
	DW	03aH
	DW	077H
	DW	03bH
	DW	078H
	DW	015H
	DW	016H
	DW	017H
	DW	011H
	DW	012H
	DW	013H
	DW	01fH
	DW	03cH
	DW	05cH
	DW	079H
	DW	038H
	DW	055H
	DW	075H
	DW	092H
	DW	014H
	DW	018H
	DW	019H
	DW	032H
	DW	04fH
	DW	06fH
	DW	08cH
	DW	039H
	DW	056H
	DW	076H
	DW	093H
	DW	031H
	DW	04eH
	DW	06eH
	DW	08bH
	DW	030H
	DW	04dH
	DW	035H
	DW	052H
	DW	072H
	DW	08fH
	DW	06dH
	DW	08aH
	DW	02fH
	DW	04cH
	DW	06cH
	DW	089H
	DW	020H
	DW	021H
	DW	03dH
	DW	03eH
	DW	05dH
	DW	05eH
	DW	07aH
	DW	07bH
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	046H
	DW	047H
	DW	048H
	DW	049H
	DW	04aH
	DW	04bH
	DW	066H
	DW	067H
	DW	068H
	DW	069H
	DW	06aH
	DW	06bH
	DW	083H
	DW	084H
	DW	085H
	DW	086H
	DW	087H
	DW	088H
	DW	022H
	DW	03fH
	DW	05fH
	DW	07cH
	DW	023H
	DW	040H
	DW	060H
	DW	07dH
	DW	024H
	DW	041H
	DW	061H
	DW	07eH
	DW	025H
	DW	042H
	DW	062H
	DW	07fH
	DW	026H
	DW	043H
	DW	063H
	DW	080H
	DW	027H
	DW	044H
	DW	064H
	DW	081H
	DW	028H
	DW	045H
	DW	065H
	DW	082H
_sort_SID DW	00H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	ORG $+2
_sort_515 DW	07H
	DW	06H
	DW	05H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	00H
	DW	0fH
	DW	0eH
	DW	0dH
	DW	0cH
	DW	0bH
	DW	0aH
	DW	09H
	DW	08H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	02eH
	DW	041H
	DW	054H
	DW	02dH
	DW	02cH
	DW	02bH
	DW	040H
	DW	03fH
	DW	03eH
	DW	053H
	DW	052H
	DW	051H
	DW	066H
	DW	065H
	DW	064H
	DW	02aH
	DW	03dH
	DW	050H
	DW	063H
	DW	01cH
	DW	02fH
	DW	042H
	DW	055H
	DW	012H
	DW	029H
	DW	03cH
	DW	04fH
	DW	062H
	DW	01dH
	DW	030H
	DW	043H
	DW	011H
	DW	014H
	DW	016H
	DW	028H
	DW	03bH
	DW	04eH
	DW	061H
	DW	015H
	DW	01eH
	DW	031H
	DW	044H
	DW	056H
	DW	013H
	DW	010H
	DW	057H
	DW	027H
	DW	026H
	DW	03aH
	DW	039H
	DW	04dH
	DW	023H
	DW	036H
	DW	049H
	DW	05cH
	DW	04cH
	DW	060H
	DW	05fH
	DW	024H
	DW	037H
	DW	04aH
	DW	05dH
	DW	020H
	DW	033H
	DW	021H
	DW	034H
	DW	046H
	DW	047H
	DW	059H
	DW	05aH
	DW	01fH
	DW	032H
	DW	045H
	DW	058H
	DW	025H
	DW	038H
	DW	04bH
	DW	05eH
	DW	022H
	DW	035H
	DW	048H
	DW	05bH
	ORG $+2
_prmno	DW	011H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	017H
	DW	027H
	DW	039H
	DW	05H
	ORG $+6
_bitno_MR122 DW	07H
	DW	08H
	DW	09H
	DW	08H
	DW	06H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
_bitno_MR67 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	0bH
	DW	03H
	DW	07H
	DW	04H
	DW	0bH
	DW	03H
	DW	07H
	DW	08H
	DW	0bH
	DW	03H
	DW	07H
	DW	04H
	DW	0bH
	DW	03H
	DW	07H
_bitno_MR59 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	09H
	DW	02H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	06H
	DW	08H
	DW	09H
	DW	02H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	06H
_bitno_MR74 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	0dH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	04H
	DW	07H
	DW	08H
	DW	0dH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	04H
	DW	07H
_bitno_MR795 DW	09H
	DW	09H
	DW	09H
	DW	08H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	06H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	08H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	DW	06H
	DW	0dH
	DW	04H
	DW	04H
	DW	05H
	ORG $+2
_bitno_MRDTX DW	03H
	DW	08H
	DW	09H
	DW	09H
	DW	06H
	ORG $+2
_bitno_MR475 DW	08H
	DW	08H
	DW	07H
	DW	08H
	DW	07H
	DW	02H
	DW	08H
	DW	04H
	DW	07H
	DW	02H
	DW	04H
	DW	07H
	DW	02H
	DW	08H
	DW	04H
	DW	07H
	DW	02H
	ORG $+2
_bitno_MR515 DW	08H
	DW	08H
	DW	07H
	DW	08H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	DW	04H
	DW	07H
	DW	02H
	DW	06H
	ORG $+2
_lsp_init_data DW 07530H
	DW	06590H
	DW	05208H
	DW	03a98H
	DW	01f40H
	DW	00H
	DW	0e0c0H
	DW	0c568H
	DW	0adf8H
	DW	09a70H
_bitno_MR102 DW	08H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	0aH
	DW	07H
	DW	07H
	ORG $+2
_bitno	DD	FLAT:_bitno_MR475
	DD	FLAT:_bitno_MR515
	DD	FLAT:_bitno_MR59
	DD	FLAT:_bitno_MR67
	DD	FLAT:_bitno_MR74
	DD	FLAT:_bitno_MR795
	DD	FLAT:_bitno_MR102
	DD	FLAT:_bitno_MR122
	DD	FLAT:_bitno_MRDTX
PUBLIC	_Decoder_amr
PUBLIC	_Decoder_amr_reset
PUBLIC	_Decoder_amr_exit
PUBLIC	_Decoder_amr_init
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_init
_TEXT	SEGMENT
_s$ = -4						; size = 4
_Decoder_amr_init PROC					; COMDAT
; _state$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 98   :   Decoder_amrState* s;
; 99   :   Word16 i;
; 100  :  
; 101  :   if (state == (Decoder_amrState **) NULL){

  00007	85 ff		 test	 edi, edi
  00009	75 20		 jne	 SHORT $LN7@Decoder_am

; 102  :       fprintf(stderr, "Decoder_amr_init: invalid parameter\n");

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PGPEPFJF@Decoder_amr_init?3?5invalid?5parame@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00016	83 c0 40	 add	 eax, 64			; 00000040H
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00020	83 c4 08	 add	 esp, 8

; 103  :       return -1;

  00023	83 c8 ff	 or	 eax, -1
  00026	5f		 pop	 edi

; 143  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Decoder_am:
  0002b	56		 push	 esi

; 104  :   }
; 105  :   *state = NULL;
; 106  :  
; 107  :   /* allocate memory */
; 108  :   if ((s= (Decoder_amrState *) malloc(sizeof(Decoder_amrState))) == NULL){

  0002c	68 0c 02 00 00	 push	 524			; 0000020cH
  00031	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003d	8b f0		 mov	 esi, eax
  0003f	83 c4 04	 add	 esp, 4
  00042	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00045	85 f6		 test	 esi, esi
  00047	75 21		 jne	 SHORT $LN6@Decoder_am

; 109  :       fprintf(stderr, "Decoder_amr_init: can not malloc state structure\n");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@DBPJKLHP@Decoder_amr_init?3?5can?5not?5malloc@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00054	83 c0 40	 add	 eax, 64			; 00000040H
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0005e	83 c4 08	 add	 esp, 8

; 110  :       return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	5e		 pop	 esi
  00065	5f		 pop	 edi

; 143  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN6@Decoder_am:

; 111  :   }
; 112  :   
; 113  :   s->T0_lagBuff = 40;

  0006a	c7 86 cc 01 00
	00 28 00 00 00	 mov	 DWORD PTR [esi+460], 40	; 00000028H

; 114  :   s->inBackgroundNoise = 0;
; 115  :   s->voicedHangover = 0;
; 116  :   for (i = 0; i < 9; i++)
; 117  :      s->ltpGainHistory[i] = 0;
; 118  : 
; 119  :   s->lsfState = NULL;

  00074	8d 8e f4 01 00
	00		 lea	 ecx, DWORD PTR [esi+500]
  0007a	33 c0		 xor	 eax, eax
  0007c	0f 57 c0	 xorps	 xmm0, xmm0
  0007f	66 89 86 d0 01
	00 00		 mov	 WORD PTR [esi+464], ax
  00086	f3 0f 7f 86 d2
	01 00 00	 movdqu	 XMMWORD PTR [esi+466], xmm0
  0008e	66 89 86 e2 01
	00 00		 mov	 WORD PTR [esi+482], ax
  00095	89 01		 mov	 DWORD PTR [ecx], eax

; 120  :   s->ec_gain_p_st = NULL;

  00097	89 86 f8 01 00
	00		 mov	 DWORD PTR [esi+504], eax

; 121  :   s->ec_gain_c_st = NULL;  

  0009d	89 86 fc 01 00
	00		 mov	 DWORD PTR [esi+508], eax

; 122  :   s->pred_state = NULL;

  000a3	89 86 00 02 00
	00		 mov	 DWORD PTR [esi+512], eax

; 123  :   s->ph_disp_st = NULL;

  000a9	89 86 04 02 00
	00		 mov	 DWORD PTR [esi+516], eax
  000af	53		 push	 ebx

; 124  :   s->dtxDecoderState = NULL;

  000b0	89 86 08 02 00
	00		 mov	 DWORD PTR [esi+520], eax

; 125  :   
; 126  :   if (D_plsf_init(&s->lsfState) ||
; 127  :       ec_gain_pitch_init(&s->ec_gain_p_st) ||
; 128  :       ec_gain_code_init(&s->ec_gain_c_st) ||
; 129  :       gc_pred_init(&s->pred_state) ||
; 130  :       Cb_gain_average_init(&s->Cb_gain_averState) ||
; 131  :       lsp_avg_init(&s->lsp_avg_st) ||      
; 132  :       Bgn_scd_init(&s->background_state) ||      
; 133  :       ph_disp_init(&s->ph_disp_st) || 
; 134  :       dtx_dec_init(&s->dtxDecoderState)) {

  000b6	e8 00 00 00 00	 call	 _D_plsf_init
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 8e 00 00
	00		 jne	 $LN1@Decoder_am
  000c3	8d 8e f8 01 00
	00		 lea	 ecx, DWORD PTR [esi+504]
  000c9	e8 00 00 00 00	 call	 _ec_gain_pitch_init
  000ce	85 c0		 test	 eax, eax
  000d0	75 7f		 jne	 SHORT $LN1@Decoder_am
  000d2	8d 8e fc 01 00
	00		 lea	 ecx, DWORD PTR [esi+508]
  000d8	e8 00 00 00 00	 call	 _ec_gain_code_init
  000dd	85 c0		 test	 eax, eax
  000df	75 70		 jne	 SHORT $LN1@Decoder_am
  000e1	8d 8e 00 02 00
	00		 lea	 ecx, DWORD PTR [esi+512]
  000e7	e8 00 00 00 00	 call	 _gc_pred_init
  000ec	85 c0		 test	 eax, eax
  000ee	75 61		 jne	 SHORT $LN1@Decoder_am
  000f0	8d 8e ec 01 00
	00		 lea	 ecx, DWORD PTR [esi+492]
  000f6	e8 00 00 00 00	 call	 _Cb_gain_average_init
  000fb	66 85 c0	 test	 ax, ax
  000fe	75 51		 jne	 SHORT $LN1@Decoder_am
  00100	8d 8e f0 01 00
	00		 lea	 ecx, DWORD PTR [esi+496]
  00106	e8 00 00 00 00	 call	 _lsp_avg_init
  0010b	85 c0		 test	 eax, eax
  0010d	75 42		 jne	 SHORT $LN1@Decoder_am
  0010f	8d 8e e4 01 00
	00		 lea	 ecx, DWORD PTR [esi+484]
  00115	e8 00 00 00 00	 call	 _Bgn_scd_init
  0011a	66 85 c0	 test	 ax, ax
  0011d	75 32		 jne	 SHORT $LN1@Decoder_am
  0011f	8d 8e 04 02 00
	00		 lea	 ecx, DWORD PTR [esi+516]
  00125	e8 00 00 00 00	 call	 _ph_disp_init
  0012a	85 c0		 test	 eax, eax
  0012c	75 23		 jne	 SHORT $LN1@Decoder_am
  0012e	8d 8e 08 02 00
	00		 lea	 ecx, DWORD PTR [esi+520]
  00134	e8 00 00 00 00	 call	 _dtx_dec_init
  00139	85 c0		 test	 eax, eax
  0013b	75 14		 jne	 SHORT $LN1@Decoder_am

; 137  :   }
; 138  :       
; 139  :   Decoder_amr_reset(s, (enum Mode)0);

  0013d	33 d2		 xor	 edx, edx
  0013f	8b ce		 mov	 ecx, esi
  00141	e8 00 00 00 00	 call	 _Decoder_amr_reset
  00146	5b		 pop	 ebx

; 140  :   *state = s;

  00147	89 37		 mov	 DWORD PTR [edi], esi

; 141  :   
; 142  :   return 0;

  00149	33 c0		 xor	 eax, eax
  0014b	5e		 pop	 esi
  0014c	5f		 pop	 edi

; 143  : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
$LN1@Decoder_am:

; 135  :       Decoder_amr_exit(&s);

  00151	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00154	e8 00 00 00 00	 call	 _Decoder_amr_exit
  00159	5b		 pop	 ebx
  0015a	5e		 pop	 esi

; 136  :       return -1;

  0015b	83 c8 ff	 or	 eax, -1
  0015e	5f		 pop	 edi

; 143  : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
_Decoder_amr_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_avg.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_exit
_TEXT	SEGMENT
_Decoder_amr_exit PROC					; COMDAT
; _state$ = ecx

; 225  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 226  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	0f 84 1d 01 00
	00		 je	 $LN1@Decoder_am
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	0f 84 13 01 00
	00		 je	 $LN1@Decoder_am

; 227  :       return;
; 228  :  
; 229  :   D_plsf_exit(&(*state)->lsfState);

  00015	53		 push	 ebx
  00016	8d 98 f4 01 00
	00		 lea	 ebx, DWORD PTR [eax+500]
  0001c	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c

; 120  :   if (state == NULL || *state == NULL)

  0001d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00023	85 db		 test	 ebx, ebx
  00025	74 12		 je	 SHORT $LN5@Decoder_am
  00027	8b 03		 mov	 eax, DWORD PTR [ebx]
  00029	85 c0		 test	 eax, eax
  0002b	74 0c		 je	 SHORT $LN5@Decoder_am

; 121  :       return;
; 122  :  
; 123  :   /* deallocate memory */
; 124  :   free(*state);

  0002d	50		 push	 eax
  0002e	ff d7		 call	 edi
  00030	83 c4 04	 add	 esp, 4

; 125  :   *state = NULL;

  00033	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN5@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 230  :   ec_gain_pitch_exit(&(*state)->ec_gain_p_st);

  00039	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0003b	81 c3 f8 01 00
	00		 add	 ebx, 504		; 000001f8H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 286  :   if (state == NULL || *state == NULL)

  00041	74 12		 je	 SHORT $LN9@Decoder_am
  00043	8b 03		 mov	 eax, DWORD PTR [ebx]
  00045	85 c0		 test	 eax, eax
  00047	74 0c		 je	 SHORT $LN9@Decoder_am

; 287  :       return;
; 288  :  
; 289  :   /* deallocate memory */
; 290  :   free(*state);

  00049	50		 push	 eax
  0004a	ff d7		 call	 edi
  0004c	83 c4 04	 add	 esp, 4

; 291  :   *state = NULL;

  0004f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN9@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 231  :   ec_gain_code_exit(&(*state)->ec_gain_c_st);

  00055	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00057	81 c3 fc 01 00
	00		 add	 ebx, 508		; 000001fcH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 117  :   if (state == NULL || *state == NULL)

  0005d	74 12		 je	 SHORT $LN13@Decoder_am
  0005f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00061	85 c0		 test	 eax, eax
  00063	74 0c		 je	 SHORT $LN13@Decoder_am

; 118  :       return;
; 119  : 
; 120  :   /* deallocate memory */
; 121  :   free(*state);

  00065	50		 push	 eax
  00066	ff d7		 call	 edi
  00068	83 c4 04	 add	 esp, 4

; 122  :   *state = NULL;

  0006b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN13@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 232  :   gc_pred_exit(&(*state)->pred_state);

  00071	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00073	81 c3 00 02 00
	00		 add	 ebx, 512		; 00000200H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 125  :   if (state == NULL || *state == NULL)

  00079	74 12		 je	 SHORT $LN17@Decoder_am
  0007b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0007d	85 c0		 test	 eax, eax
  0007f	74 0c		 je	 SHORT $LN17@Decoder_am

; 126  :       return;
; 127  : 
; 128  :   /* deallocate memory */
; 129  :   free(*state);

  00081	50		 push	 eax
  00082	ff d7		 call	 edi
  00084	83 c4 04	 add	 esp, 4

; 130  :   *state = NULL;

  00087	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN17@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 233  :   Bgn_scd_exit(&(*state)->background_state);

  0008d	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0008f	81 c3 e4 01 00
	00		 add	 ebx, 484		; 000001e4H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 115  :    if (state == NULL || *state == NULL)

  00095	74 12		 je	 SHORT $LN21@Decoder_am
  00097	8b 03		 mov	 eax, DWORD PTR [ebx]
  00099	85 c0		 test	 eax, eax
  0009b	74 0c		 je	 SHORT $LN21@Decoder_am

; 116  :       return;
; 117  : 
; 118  :    /* deallocate memory */
; 119  :    free(*state);

  0009d	50		 push	 eax
  0009e	ff d7		 call	 edi
  000a0	83 c4 04	 add	 esp, 4

; 120  :    *state = NULL;

  000a3	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN21@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 234  :   ph_disp_exit(&(*state)->ph_disp_st);

  000a9	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000ab	81 c3 04 02 00
	00		 add	 ebx, 516		; 00000204H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 112  :   if ((state == NULL) || (*state == NULL))

  000b1	74 12		 je	 SHORT $LN25@Decoder_am
  000b3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b5	85 c0		 test	 eax, eax
  000b7	74 0c		 je	 SHORT $LN25@Decoder_am

; 113  :       return;
; 114  :   
; 115  :   /* deallocate memory */
; 116  :   free(*state);

  000b9	50		 push	 eax
  000ba	ff d7		 call	 edi
  000bc	83 c4 04	 add	 esp, 4

; 117  :   *state = NULL;

  000bf	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN25@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 235  :   Cb_gain_average_exit(&(*state)->Cb_gain_averState);

  000c5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000c7	81 c3 ec 01 00
	00		 add	 ebx, 492		; 000001ecH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 114  :    if (state == NULL || *state == NULL)

  000cd	74 12		 je	 SHORT $LN29@Decoder_am
  000cf	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d1	85 c0		 test	 eax, eax
  000d3	74 0c		 je	 SHORT $LN29@Decoder_am

; 115  :       return;
; 116  : 
; 117  :    /* deallocate memory */
; 118  :    free(*state);

  000d5	50		 push	 eax
  000d6	ff d7		 call	 edi
  000d8	83 c4 04	 add	 esp, 4

; 119  :    *state = NULL;

  000db	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN29@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 236  :   lsp_avg_exit(&(*state)->lsp_avg_st);

  000e1	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000e3	81 c3 f0 01 00
	00		 add	 ebx, 496		; 000001f0H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_avg.c

; 108  :   if (state == NULL || *state == NULL)

  000e9	74 12		 je	 SHORT $LN33@Decoder_am
  000eb	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ed	85 c0		 test	 eax, eax
  000ef	74 0c		 je	 SHORT $LN33@Decoder_am

; 109  :       return;
; 110  : 
; 111  :   /* deallocate memory */
; 112  :   free(*state);

  000f1	50		 push	 eax
  000f2	ff d7		 call	 edi
  000f4	83 c4 04	 add	 esp, 4

; 113  :   *state = NULL;

  000f7	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN33@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 237  :   dtx_dec_exit(&(*state)->dtxDecoderState);

  000fd	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000ff	81 c3 08 02 00
	00		 add	 ebx, 520		; 00000208H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dtx_dec.c

; 193  :    if (st == NULL || *st == NULL)

  00105	74 12		 je	 SHORT $LN37@Decoder_am
  00107	8b 03		 mov	 eax, DWORD PTR [ebx]
  00109	85 c0		 test	 eax, eax
  0010b	74 0c		 je	 SHORT $LN37@Decoder_am

; 194  :       return;
; 195  :    
; 196  :    /* deallocate memory */
; 197  :    free(*st);

  0010d	50		 push	 eax
  0010e	ff d7		 call	 edi
  00110	83 c4 04	 add	 esp, 4

; 198  :    *st = NULL;

  00113	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN37@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 240  :   free(*state);

  00119	ff 36		 push	 DWORD PTR [esi]
  0011b	ff d7		 call	 edi
  0011d	83 c4 04	 add	 esp, 4

; 241  :   *state = NULL;

  00120	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00126	5f		 pop	 edi
  00127	5b		 pop	 ebx
$LN1@Decoder_am:
  00128	5e		 pop	 esi

; 242  :   
; 243  :   return;
; 244  : }

  00129	c3		 ret	 0
_Decoder_amr_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_avg.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr_reset
_TEXT	SEGMENT
_mode$1$ = -4						; size = 4
_Decoder_amr_reset PROC					; COMDAT
; _state$ = ecx
; _mode$ = edx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	8b da		 mov	 ebx, edx
  0000a	89 5d fc	 mov	 DWORD PTR _mode$1$[ebp], ebx

; 155  :   Word16 i;
; 156  : 
; 157  :   if (state == (Decoder_amrState *) NULL){

  0000d	85 f6		 test	 esi, esi
  0000f	75 21		 jne	 SHORT $LN13@Decoder_am

; 158  :       fprintf(stderr, "Decoder_amr_reset: invalid parameter\n");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BODNKCFF@Decoder_amr_reset?3?5invalid?5param@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0001c	83 c0 40	 add	 eax, 64			; 00000040H
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00026	83 c4 08	 add	 esp, 8

; 159  :       return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx

; 214  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN13@Decoder_am:

; 163  :   state->exc = state->old_exc + PIT_MAX + L_INTERPOL;

  00032	8d 86 34 01 00
	00		 lea	 eax, DWORD PTR [esi+308]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00038	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  0003d	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 163  :   state->exc = state->old_exc + PIT_MAX + L_INTERPOL;

  0003e	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00044	8b fe		 mov	 edi, esi
  00046	33 c0		 xor	 eax, eax
  00048	f3 ab		 rep stosd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 168  :   if (mode != MRDTX)

  0004a	83 fb 08	 cmp	 ebx, 8
  0004d	74 11		 je	 SHORT $LN25@Decoder_am
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00052	f3 0f 7f 86 9c
	01 00 00	 movdqu	 XMMWORD PTR [esi+412], xmm0
  0005a	89 86 ac 01 00
	00		 mov	 DWORD PTR [esi+428], eax
$LN25@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 172  :   state->sharp = SHARPMIN;

  00060	c7 86 b0 01 00
	00 00 00 28 00	 mov	 DWORD PTR [esi+432], 2621440 ; 00280000H

; 173  :   state->old_T0 = 40;
; 174  :      
; 175  :   /* Initialize state->lsp_old [] */ 
; 176  : 
; 177  :   if (mode != MRDTX) {

  0006a	83 fb 08	 cmp	 ebx, 8
  0006d	74 20		 je	 SHORT $LN30@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET _lsp_init_data
  00074	8d 96 88 01 00
	00		 lea	 edx, DWORD PTR [esi+392]
  0007a	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0007f	90		 npad	 1
$LL32@Decoder_am:

; 61   :     {
; 62   :         y[i] = x[i];            move16 (); 

  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00086	66 89 02	 mov	 WORD PTR [edx], ax
  00089	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  0008c	4f		 dec	 edi
  0008d	75 f1		 jne	 SHORT $LL32@Decoder_am
$LN30@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 182  :   state->prev_bf = 0;

  0008f	33 c0		 xor	 eax, eax

; 183  :   state->prev_pdf = 0;
; 184  :   state->state = 0;
; 185  :   
; 186  :   state->T0_lagBuff = 40;

  00091	c7 86 cc 01 00
	00 28 00 00 00	 mov	 DWORD PTR [esi+460], 40	; 00000028H
  0009b	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
  000a1	66 89 86 b8 01
	00 00		 mov	 WORD PTR [esi+440], ax

; 187  :   state->inBackgroundNoise = 0;
; 188  :   state->voicedHangover = 0;

  000a8	66 89 86 d0 01
	00 00		 mov	 WORD PTR [esi+464], ax

; 189  :   if (mode != MRDTX) {

  000af	83 fb 08	 cmp	 ebx, 8
  000b2	74 12		 je	 SHORT $LN9@Decoder_am

; 190  :       for (i=0;i<9;i++)
; 191  :           state->excEnergyHist[i] = 0;

  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	f3 0f 7f 86 ba
	01 00 00	 movdqu	 XMMWORD PTR [esi+442], xmm0
  000bf	66 89 86 ca 01
	00 00		 mov	 WORD PTR [esi+458], ax
$LN9@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 89   :    if (state == (Cb_gain_averageState *) NULL){

  000c6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fprintf
  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp____iob_func
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 195  :      state->ltpGainHistory[i] = 0;

  000d5	f3 0f 7f 86 d2
	01 00 00	 movdqu	 XMMWORD PTR [esi+466], xmm0
  000dd	66 89 86 e2 01
	00 00		 mov	 WORD PTR [esi+482], ax

; 196  : 
; 197  :   Cb_gain_average_reset(state->Cb_gain_averState);

  000e4	8b 86 ec 01 00
	00		 mov	 eax, DWORD PTR [esi+492]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 89   :    if (state == (Cb_gain_averageState *) NULL){

  000ea	85 c0		 test	 eax, eax
  000ec	75 12		 jne	 SHORT $LN37@Decoder_am

; 90   :       fprintf(stderr, "Cb_gain_average_reset: invalid parameter\n");

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@OIGMFPKA@Cb_gain_average_reset?3?5invalid?5p@
  000f3	ff d7		 call	 edi
  000f5	83 c0 40	 add	 eax, 64			; 00000040H
  000f8	50		 push	 eax
  000f9	ff d3		 call	 ebx
  000fb	83 c4 08	 add	 esp, 8

; 91   :       return -1;

  000fe	eb 18		 jmp	 SHORT $LN38@Decoder_am
$LN37@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00100	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 99   :    state->hangCount= 0;

  00104	33 c9		 xor	 ecx, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00106	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0010d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\c_g_aver.c

; 99   :    state->hangCount= 0;

  00114	66 89 48 10	 mov	 WORD PTR [eax+16], cx
$LN38@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 198  :   if (mode != MRDTX)

  00118	83 7d fc 08	 cmp	 DWORD PTR _mode$1$[ebp], 8
  0011c	74 46		 je	 SHORT $LN50@Decoder_am

; 199  :      lsp_avg_reset(state->lsp_avg_st);

  0011e	8b 8e f0 01 00
	00		 mov	 ecx, DWORD PTR [esi+496]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_avg.c

; 88   :   if (st == (lsp_avgState *) NULL){

  00124	85 c9		 test	 ecx, ecx
  00126	75 12		 jne	 SHORT $LN47@Decoder_am

; 89   :       fprintf(stderr, "lsp_avg_reset: invalid parameter\n");

  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JLPBJECB@lsp_avg_reset?3?5invalid?5parameter@
  0012d	ff d7		 call	 edi
  0012f	83 c0 40	 add	 eax, 64			; 00000040H
  00132	50		 push	 eax
  00133	ff d3		 call	 ebx
  00135	83 c4 08	 add	 esp, 8

; 90   :       return -1;

  00138	eb 2a		 jmp	 SHORT $LN50@Decoder_am
$LN47@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  0013a	bf 00 00 00 00	 mov	 edi, OFFSET _mean_lsf
  0013f	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00144	2b f9		 sub	 edi, ecx
  00146	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL52@Decoder_am:

; 61   :     {
; 62   :         y[i] = x[i];            move16 (); 

  00150	66 8b 04 0f	 mov	 ax, WORD PTR [edi+ecx]
  00154	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00157	66 89 41 fe	 mov	 WORD PTR [ecx-2], ax
  0015b	4a		 dec	 edx
  0015c	75 f2		 jne	 SHORT $LL52@Decoder_am
  0015e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp____iob_func
$LN50@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 200  :   D_plsf_reset(state->lsfState);

  00164	8b 96 f4 01 00
	00		 mov	 edx, DWORD PTR [esi+500]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c

; 95   :   if (state == (D_plsfState *) NULL){

  0016a	85 d2		 test	 edx, edx
  0016c	75 12		 jne	 SHORT $LN60@Decoder_am

; 96   :       fprintf(stderr, "D_plsf_reset: invalid parameter\n");

  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NIKNKACH@D_plsf_reset?3?5invalid?5parameter?6@
  00173	ff d7		 call	 edi
  00175	83 c0 40	 add	 eax, 64			; 00000040H
  00178	50		 push	 eax
  00179	ff d3		 call	 ebx
  0017b	83 c4 08	 add	 esp, 8

; 97   :       return -1;

  0017e	eb 35		 jmp	 SHORT $LN63@Decoder_am
$LN60@Decoder_am:
  00180	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  00183	b9 00 00 00 00	 mov	 ecx, OFFSET _mean_lsf
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_plsf.c

; 101  :       state->past_r_q[i] = 0;             /* Past quantized prediction error */

  00188	f3 0f 7f 02	 movdqu	 XMMWORD PTR [edx], xmm0
  0018c	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  00193	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00198	83 c2 14	 add	 edx, 20			; 00000014H
  0019b	eb 03 8d 49 00	 npad	 5
$LL65@Decoder_am:

; 61   :     {
; 62   :         y[i] = x[i];            move16 (); 

  001a0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  001a3	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  001a6	66 89 02	 mov	 WORD PTR [edx], ax
  001a9	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  001ac	4f		 dec	 edi
  001ad	75 f1		 jne	 SHORT $LL65@Decoder_am
  001af	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp____iob_func
$LN63@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 201  :   ec_gain_pitch_reset(state->ec_gain_p_st);

  001b5	8b 86 f8 01 00
	00		 mov	 eax, DWORD PTR [esi+504]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 264  :   if (state == (ec_gain_pitchState *) NULL){

  001bb	85 c0		 test	 eax, eax
  001bd	75 12		 jne	 SHORT $LN73@Decoder_am

; 265  :       fprintf(stderr, "ec_gain_pitch_reset: invalid parameter\n");

  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PDOIDJNI@ec_gain_pitch_reset?3?5invalid?5par@
  001c4	ff d7		 call	 edi
  001c6	83 c0 40	 add	 eax, 64			; 00000040H
  001c9	50		 push	 eax
  001ca	ff d3		 call	 ebx
  001cc	83 c4 08	 add	 esp, 8

; 266  :       return -1;

  001cf	eb 1a		 jmp	 SHORT $LN74@Decoder_am
$LN73@Decoder_am:

; 267  :   }
; 268  :   
; 269  :   for(i = 0; i < 5; i++)
; 270  :       state->pbuf[i] = 1640;

  001d1	b9 68 06 68 06	 mov	 ecx, 107480680		; 06680668H
  001d6	89 08		 mov	 DWORD PTR [eax], ecx
  001d8	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 271  :   state->past_gain_pit = 0; 
; 272  :   state->prev_gp = 16384;   

  001db	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  001e0	c7 40 08 68 06
	00 00		 mov	 DWORD PTR [eax+8], 1640	; 00000668H
  001e7	66 89 48 0c	 mov	 WORD PTR [eax+12], cx
$LN74@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 202  :   ec_gain_code_reset(state->ec_gain_c_st);

  001eb	8b 86 fc 01 00
	00		 mov	 eax, DWORD PTR [esi+508]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 94   :   if (state == (ec_gain_codeState *) NULL){

  001f1	85 c0		 test	 eax, eax
  001f3	75 12		 jne	 SHORT $LN79@Decoder_am

; 95   :       fprintf(stderr, "ec_gain_code_reset: invalid parameter\n");

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NJKHLADC@ec_gain_code_reset?3?5invalid?5para@
  001fa	ff d7		 call	 edi
  001fc	83 c0 40	 add	 eax, 64			; 00000040H
  001ff	50		 push	 eax
  00200	ff d3		 call	 ebx
  00202	83 c4 08	 add	 esp, 8

; 96   :       return -1;

  00205	eb 1a		 jmp	 SHORT $LN80@Decoder_am
$LN79@Decoder_am:

; 97   :   }
; 98   : 
; 99   :   for ( i = 0; i < 5; i++)
; 100  :       state->gbuf[i] = 1;

  00207	b9 01 00 01 00	 mov	 ecx, 65537		; 00010001H
  0020c	89 08		 mov	 DWORD PTR [eax], ecx
  0020e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 101  :   state->past_gain_code = 0;
; 102  :   state->prev_gc = 1;       

  00211	b9 01 00 00 00	 mov	 ecx, 1
  00216	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1
  0021d	66 89 48 0c	 mov	 WORD PTR [eax+12], cx
$LN80@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 204  :   if (mode != MRDTX)

  00221	83 7d fc 08	 cmp	 DWORD PTR _mode$1$[ebp], 8
  00225	74 3e		 je	 SHORT $LN82@Decoder_am

; 205  :      gc_pred_reset(state->pred_state);

  00227	8b 86 00 02 00
	00		 mov	 eax, DWORD PTR [esi+512]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 103  :    if (state == (gc_predState *) NULL){

  0022d	85 c0		 test	 eax, eax
  0022f	75 12		 jne	 SHORT $LN85@Decoder_am

; 104  :       fprintf(stderr, "gc_pred_reset: invalid parameter\n");

  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@
  00236	ff d7		 call	 edi
  00238	83 c0 40	 add	 eax, 64			; 00000040H
  0023b	50		 push	 eax
  0023c	ff d3		 call	 ebx
  0023e	83 c4 08	 add	 esp, 8

; 105  :       return -1;

  00241	eb 22		 jmp	 SHORT $LN82@Decoder_am
$LN85@Decoder_am:

; 106  :    }
; 107  : 
; 108  :    for(i = 0; i < NPRED; i++)

  00243	b9 04 00 00 00	 mov	 ecx, 4
  00248	ba 00 c8 ff ff	 mov	 edx, -14336		; ffffc800H
  0024d	bb b3 f6 ff ff	 mov	 ebx, -2381		; fffff6b3H
$LL84@Decoder_am:

; 109  :    {
; 110  :       state->past_qua_en[i] = MIN_ENERGY;

  00252	66 89 10	 mov	 WORD PTR [eax], dx
  00255	8d 40 02	 lea	 eax, DWORD PTR [eax+2]

; 111  :       state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;

  00258	66 89 58 06	 mov	 WORD PTR [eax+6], bx
  0025c	49		 dec	 ecx
  0025d	75 f3		 jne	 SHORT $LL84@Decoder_am
  0025f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__fprintf
$LN82@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 207  :   Bgn_scd_reset(state->background_state);

  00265	8b 86 e4 01 00
	00		 mov	 eax, DWORD PTR [esi+484]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 91   :    if (state == (Bgn_scdState *) NULL){

  0026b	85 c0		 test	 eax, eax
  0026d	75 12		 jne	 SHORT $LN88@Decoder_am

; 92   :       fprintf(stderr, "Bgn_scd_reset: invalid parameter\n");

  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PJKCAIBL@Bgn_scd_reset?3?5invalid?5parameter@
  00274	ff d7		 call	 edi
  00276	83 c0 40	 add	 eax, 64			; 00000040H
  00279	50		 push	 eax
  0027a	ff d3		 call	 ebx
  0027c	83 c4 08	 add	 esp, 8

; 93   :       return -1;

  0027f	eb 30		 jmp	 SHORT $LN89@Decoder_am
$LN88@Decoder_am:
  00281	0f 57 c0	 xorps	 xmm0, xmm0

; 100  :    state->bgHangover = 0;

  00284	33 c9		 xor	 ecx, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00286	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0028a	f3 0f 7f 40 10	 movdqu	 XMMWORD PTR [eax+16], xmm0
  0028f	f3 0f 7f 40 20	 movdqu	 XMMWORD PTR [eax+32], xmm0
  00294	f3 0f 7f 40 30	 movdqu	 XMMWORD PTR [eax+48], xmm0
  00299	f3 0f 7f 40 40	 movdqu	 XMMWORD PTR [eax+64], xmm0
  0029e	f3 0f 7f 40 50	 movdqu	 XMMWORD PTR [eax+80], xmm0
  002a3	f3 0f 7f 40 60	 movdqu	 XMMWORD PTR [eax+96], xmm0
  002a8	66 0f d6 40 70	 movq	 QWORD PTR [eax+112], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 100  :    state->bgHangover = 0;

  002ad	66 89 48 78	 mov	 WORD PTR [eax+120], cx
$LN89@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 208  :   state->nodataSeed = 21845;

  002b1	b8 55 55 00 00	 mov	 eax, 21845		; 00005555H
  002b6	66 89 86 e8 01
	00 00		 mov	 WORD PTR [esi+488], ax

; 209  :   ph_disp_reset(state->ph_disp_st);

  002bd	8b 86 04 02 00
	00		 mov	 eax, DWORD PTR [esi+516]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 88   :    if (state == (ph_dispState *) NULL){

  002c3	85 c0		 test	 eax, eax
  002c5	75 12		 jne	 SHORT $LN101@Decoder_am

; 89   :       fprintf(stderr, "ph_disp_reset: invalid parameter\n");

  002c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@
  002cc	ff d7		 call	 edi
  002ce	83 c0 40	 add	 eax, 64			; 00000040H
  002d1	50		 push	 eax
  002d2	ff d3		 call	 ebx
  002d4	83 c4 08	 add	 esp, 8

; 90   :       return -1;

  002d7	eb 17		 jmp	 SHORT $LN102@Decoder_am
$LN101@Decoder_am:
  002d9	0f 57 c0	 xorps	 xmm0, xmm0

; 91   :    }
; 92   :    for (i=0; i<PHDGAINMEMSIZE; i++)
; 93   :    {
; 94   :        state->gainMem[i] = 0;
; 95   :    }
; 96   :    state->prevState = 0;
; 97   :    state->prevCbGain = 0;

  002dc	33 c9		 xor	 ecx, ecx
  002de	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  002e2	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  002e9	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 98   :    state->lockFull = 0;
; 99   :    state->onset = 0;          /* assume no onset in start */ 

  002ec	66 89 48 10	 mov	 WORD PTR [eax+16], cx
$LN102@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 210  :   if (mode != MRDTX)

  002f0	83 7d fc 08	 cmp	 DWORD PTR _mode$1$[ebp], 8
  002f4	5f		 pop	 edi
  002f5	74 0b		 je	 SHORT $LN1@Decoder_am

; 211  :      dtx_dec_reset(state->dtxDecoderState);

  002f7	8b 8e 08 02 00
	00		 mov	 ecx, DWORD PTR [esi+520]
  002fd	e8 00 00 00 00	 call	 _dtx_dec_reset
$LN1@Decoder_am:

; 212  :   
; 213  :   return 0;

  00302	5e		 pop	 esi
  00303	33 c0		 xor	 eax, eax
  00305	5b		 pop	 ebx

; 214  : }

  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c3		 ret	 0
_Decoder_amr_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c
;	COMDAT _Decoder_amr
_TEXT	SEGMENT
_L_diff$1$ = -408					; size = 4
_subfrNr$1$ = -404					; size = 4
_L_diff$1$ = -400					; size = 4
_L_diff$1$ = -396					; size = 4
_evenSubfr$1$ = -392					; size = 4
_newDTXState$1$ = -388					; size = 4
_index_mr475$1$ = -384					; size = 4
_temp$ = -380						; size = 2
_L_diff$1$ = -376					; size = 4
_pdfi$1$ = -372						; size = 4
_index$1$ = -368					; size = 4
tv6383 = -368						; size = 4
tv6380 = -368						; size = 4
_synth$GSCopy$1$ = -364					; size = 4
_T0_frac$ = -360					; size = 2
_i_subfr$1$ = -356					; size = 4
_tmp_shift$1$ = -352					; size = 4
_var_out$1$ = -352					; size = 4
_pitch_fac$1$ = -348					; size = 4
_pit_flag$1$ = -348					; size = 4
tv6386 = -348						; size = 4
_Az$1$ = -344						; size = 4
_gain_code_mix$1$ = -340				; size = 4
_var_out$1$ = -340					; size = 4
_mode$GSCopy$1$ = -336					; size = 4
_T0$ = -332						; size = 2
_L_diff$1$ = -328					; size = 4
_st$GSCopy$1$ = -324					; size = 4
_gain_code$ = -320					; size = 2
_gain_pit$ = -316					; size = 2
_parm$GSCopy$1$ = -312					; size = 4
_bfi$1$ = -308						; size = 4
_excp$ = -304						; size = 80
_exc_enhanced$ = -224					; size = 80
_prev_lsf$ = -144					; size = 20
_code$ = -124						; size = 80
_lsf_i$ = -44						; size = 20
_lsp_mid$ = -44						; size = 20
_lsp_new$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_parm$ = 8						; size = 4
_frame_type$ = 12					; size = 4
_synth$ = 16						; size = 4
_A_t$ = 20						; size = 4
_Decoder_amr PROC					; COMDAT
; _st$ = ecx
; _mode$ = edx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _synth$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx
  00019	89 95 b0 fe ff
	ff		 mov	 DWORD PTR _mode$GSCopy$1$[ebp], edx
  0001f	56		 push	 esi
  00020	8b 75 08	 mov	 esi, DWORD PTR _parm$[ebp]
  00023	57		 push	 edi

; 310  :     newDTXState = rx_dtx_handler(st->dtxDecoderState, frame_type);

  00024	8b 7d 0c	 mov	 edi, DWORD PTR _frame_type$[ebp]
  00027	8b d7		 mov	 edx, edi
  00029	8b 8b 08 02 00
	00		 mov	 ecx, DWORD PTR [ebx+520]
  0002f	89 85 94 fe ff
	ff		 mov	 DWORD PTR _synth$GSCopy$1$[ebp], eax
  00035	8b 45 14	 mov	 eax, DWORD PTR _A_t$[ebp]
  00038	89 9d bc fe ff
	ff		 mov	 DWORD PTR _st$GSCopy$1$[ebp], ebx
  0003e	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], esi
  00044	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _Az$1$[ebp], eax
  0004a	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _index_mr475$1$[ebp], 0
  00054	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bfi$1$[ebp], 0
  0005e	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pdfi$1$[ebp], 0
  00068	e8 00 00 00 00	 call	 _rx_dtx_handler
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0006d	0f bf c8	 movsx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 310  :     newDTXState = rx_dtx_handler(st->dtxDecoderState, frame_type);

  00070	89 85 7c fe ff
	ff		 mov	 DWORD PTR _newDTXState$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00076	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0007c	7e 0c		 jle	 SHORT $LN143@Decoder_am
$LN2016@Decoder_am:

; 81   :         Overflow = 1;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00088	eb 0d		 jmp	 SHORT $LN1906@Decoder_am
$LN143@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0008a	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00090	7c ec		 jl	 SHORT $LN2016@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 315  :     if (sub(newDTXState, SPEECH) != 0 )

  00092	66 85 c9	 test	 cx, cx
  00095	74 7c		 je	 SHORT $LN129@Decoder_am
$LN1906@Decoder_am:

; 316  :     {
; 317  :        Decoder_amr_reset (st, MRDTX);

  00097	ba 08 00 00 00	 mov	 edx, 8
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 _Decoder_amr_reset

; 318  : 
; 319  :        dtx_dec(st->dtxDecoderState, 
; 320  :                st->mem_syn, 
; 321  :                st->lsfState, 
; 322  :                st->pred_state,
; 323  :                st->Cb_gain_averState,
; 324  :                newDTXState,
; 325  :                mode, 
; 326  :                parm, synth, A_t);

  000a3	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _Az$1$[ebp]
  000a9	8b 8b 08 02 00
	00		 mov	 ecx, DWORD PTR [ebx+520]
  000af	8d 93 9c 01 00
	00		 lea	 edx, DWORD PTR [ebx+412]
  000b5	ff b5 94 fe ff
	ff		 push	 DWORD PTR _synth$GSCopy$1$[ebp]
  000bb	56		 push	 esi
  000bc	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _mode$GSCopy$1$[ebp]
  000c2	8b b5 7c fe ff
	ff		 mov	 esi, DWORD PTR _newDTXState$1$[ebp]
  000c8	56		 push	 esi
  000c9	ff b3 ec 01 00
	00		 push	 DWORD PTR [ebx+492]
  000cf	ff b3 00 02 00
	00		 push	 DWORD PTR [ebx+512]
  000d5	ff b3 f4 01 00
	00		 push	 DWORD PTR [ebx+500]
  000db	e8 00 00 00 00	 call	 _dtx_dec

; 327  :        /* update average lsp */
; 328  :        
; 329  :        Lsf_lsp(st->lsfState->past_lsf_q, st->lsp_old, M);

  000e0	8b 8b f4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+500]
  000e6	8d 93 88 01 00
	00		 lea	 edx, DWORD PTR [ebx+392]
  000ec	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ef	83 c1 14	 add	 ecx, 20			; 00000014H
  000f2	e8 00 00 00 00	 call	 _Lsf_lsp

; 330  :        lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);

  000f7	8b 93 f4 01 00
	00		 mov	 edx, DWORD PTR [ebx+500]
  000fd	83 c4 04	 add	 esp, 4
  00100	8b 8b f0 01 00
	00		 mov	 ecx, DWORD PTR [ebx+496]
  00106	83 c2 14	 add	 edx, 20			; 00000014H
  00109	e8 00 00 00 00	 call	 _lsp_avg

; 331  :        goto the_end;

  0010e	e9 e8 21 00 00	 jmp	 $the_end$2040
$LN129@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00113	0f bf f7	 movsx	 esi, di
  00116	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]

; 79   :     if (L_var1 > 0X00007fffL)

  00119	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0011e	7e 0c		 jle	 SHORT $LN159@Decoder_am

; 81   :         Overflow = 1;

  00120	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0012a	eb 1c		 jmp	 SHORT $LN1907@Decoder_am
$LN159@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0012c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00131	7d 0c		 jge	 SHORT $LN157@Decoder_am

; 86   :         Overflow = 1;

  00133	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0013d	eb 09		 jmp	 SHORT $LN1907@Decoder_am
$LN157@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 338  :         (sub(frame_type, RX_ONSET) == 0)) 

  0013f	66 85 c0	 test	 ax, ax
  00142	0f 84 97 00 00
	00		 je	 $LN127@Decoder_am
$LN1907@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00148	8d 46 f9	 lea	 eax, DWORD PTR [esi-7]

; 79   :     if (L_var1 > 0X00007fffL)

  0014b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00150	7e 0c		 jle	 SHORT $LN169@Decoder_am

; 81   :         Overflow = 1;

  00152	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0015c	eb 18		 jmp	 SHORT $LN1908@Decoder_am
$LN169@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0015e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00163	7d 0c		 jge	 SHORT $LN167@Decoder_am

; 86   :         Overflow = 1;

  00165	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0016f	eb 05		 jmp	 SHORT $LN1908@Decoder_am
$LN167@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 338  :         (sub(frame_type, RX_ONSET) == 0)) 

  00171	66 85 c0	 test	 ax, ax
  00174	74 69		 je	 SHORT $LN127@Decoder_am
$LN1908@Decoder_am:
  00176	ba 02 00 00 00	 mov	 edx, 2
  0017b	8b cf		 mov	 ecx, edi
  0017d	e8 00 00 00 00	 call	 _sub
  00182	66 85 c0	 test	 ax, ax
  00185	74 58		 je	 SHORT $LN127@Decoder_am

; 349  :        }       
; 350  :     }
; 351  :     else if (sub(frame_type, RX_SPEECH_DEGRADED) == 0)

  00187	be 01 00 00 00	 mov	 esi, 1
  0018c	8b cf		 mov	 ecx, edi
  0018e	8b d6		 mov	 edx, esi
  00190	e8 00 00 00 00	 call	 _sub
  00195	66 85 c0	 test	 ax, ax
  00198	75 06		 jne	 SHORT $LN122@Decoder_am

; 352  :     {
; 353  :        pdfi = 1;                                         move16 ();

  0019a	89 95 8c fe ff
	ff		 mov	 DWORD PTR _pdfi$1$[ebp], edx
$LN122@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  001a0	0f bf 83 b8 01
	00 00		 movsx	 eax, WORD PTR [ebx+440]
  001a7	83 e8 06	 sub	 eax, 6

; 79   :     if (L_var1 > 0X00007fffL)

  001aa	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001af	7f 1f		 jg	 SHORT $LN2017@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b1	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001b6	7c 18		 jl	 SHORT $LN2017@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 362  :     else if (sub (st->state, 6) == 0)

  001b8	66 85 c0	 test	 ax, ax
  001bb	75 19		 jne	 SHORT $LN120@Decoder_am

; 363  : 
; 364  :     {
; 365  :         st->state = 5;                                   move16 ();

  001bd	ba 05 00 00 00	 mov	 edx, 5

; 366  :     }
; 367  :     else

  001c2	33 ff		 xor	 edi, edi
  001c4	66 89 93 b8 01
	00 00		 mov	 WORD PTR [ebx+440], dx
  001cb	e9 d2 00 00 00	 jmp	 $LN226@Decoder_am
$LN2017@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  001d0	89 15 00 00 00
	00		 mov	 DWORD PTR _Overflow, edx
$LN120@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 369  :         st->state = 0;                                   move16 ();

  001d6	33 c0		 xor	 eax, eax
  001d8	33 ff		 xor	 edi, edi
  001da	e9 b7 00 00 00	 jmp	 $LN2018@Decoder_am
$LN127@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  001df	8d 46 f9	 lea	 eax, DWORD PTR [esi-7]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 340  :        bfi = 1;                                          move16 ();

  001e2	bf 01 00 00 00	 mov	 edi, 1
  001e7	89 bd cc fe ff
	ff		 mov	 DWORD PTR _bfi$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  001ed	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001f2	7e 08		 jle	 SHORT $LN185@Decoder_am

; 81   :         Overflow = 1;

  001f4	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 82   :         var_out = MAX_16;

  001fa	eb 14		 jmp	 SHORT $LN1909@Decoder_am
$LN185@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001fc	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00201	7d 08		 jge	 SHORT $LN183@Decoder_am

; 86   :         Overflow = 1;

  00203	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 88   :     }
; 89   :     else

  00209	eb 05		 jmp	 SHORT $LN1909@Decoder_am
$LN183@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 343  :            (sub(frame_type, RX_ONSET) == 0))

  0020b	66 85 c0	 test	 ax, ax
  0020e	74 28		 je	 SHORT $LN125@Decoder_am
$LN1909@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00210	83 c6 fe	 add	 esi, -2			; fffffffeH

; 79   :     if (L_var1 > 0X00007fffL)

  00213	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00219	7e 08		 jle	 SHORT $LN195@Decoder_am

; 81   :         Overflow = 1;

  0021b	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 82   :         var_out = MAX_16;

  00221	eb 3e		 jmp	 SHORT $LN1910@Decoder_am
$LN195@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00223	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00229	7d 08		 jge	 SHORT $LN193@Decoder_am

; 86   :         Overflow = 1;

  0022b	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 88   :     }
; 89   :     else

  00231	eb 2e		 jmp	 SHORT $LN1910@Decoder_am
$LN193@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 343  :            (sub(frame_type, RX_ONSET) == 0))

  00233	66 85 f6	 test	 si, si
  00236	75 29		 jne	 SHORT $LN1910@Decoder_am
$LN125@Decoder_am:

; 344  :        {
; 345  : 	  build_CN_param(&st->nodataSeed,
; 346  : 			 prmno[mode],
; 347  : 			 bitno[mode],
; 348  : 			 parm);

  00238	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _mode$GSCopy$1$[ebp]
  0023e	8d 8b e8 01 00
	00		 lea	 ecx, DWORD PTR [ebx+488]
  00244	ff b5 c8 fe ff
	ff		 push	 DWORD PTR _parm$GSCopy$1$[ebp]
  0024a	ff 34 85 00 00
	00 00		 push	 DWORD PTR _bitno[eax*4]
  00251	66 8b 14 45 00
	00 00 00	 mov	 dx, WORD PTR _prmno[eax*2]
  00259	e8 00 00 00 00	 call	 _build_CN_param
  0025e	83 c4 08	 add	 esp, 8
$LN1910@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00261	0f bf 83 b8 01
	00 00		 movsx	 eax, WORD PTR [ebx+440]
  00268	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00269	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0026e	7e 0d		 jle	 SHORT $LN209@Decoder_am

; 81   :         Overflow = 1;

  00270	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 82   :         var_out = MAX_16;

  00276	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0027b	eb 17		 jmp	 SHORT $LN206@Decoder_am
$LN209@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0027d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00282	7d 0d		 jge	 SHORT $LN207@Decoder_am

; 86   :         Overflow = 1;

  00284	89 3d 00 00 00
	00		 mov	 DWORD PTR _Overflow, edi

; 87   :         var_out = MIN_16;

  0028a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0028f	eb 03		 jmp	 SHORT $LN206@Decoder_am
$LN207@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00291	0f b7 c0	 movzx	 eax, ax
$LN206@Decoder_am:
  00294	8b f7		 mov	 esi, edi
$LN2018@Decoder_am:
  00296	ba 05 00 00 00	 mov	 edx, 5
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 360  :         st->state = add (st->state, 1);

  0029b	66 89 83 b8 01
	00 00		 mov	 WORD PTR [ebx+440], ax
$LN226@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002a2	0f bf 83 b8 01
	00 00		 movsx	 eax, WORD PTR [ebx+440]
  002a9	83 e8 06	 sub	 eax, 6

; 79   :     if (L_var1 > 0X00007fffL)

  002ac	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002b1	7e 0c		 jle	 SHORT $LN235@Decoder_am

; 81   :         Overflow = 1;

  002b3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002bd	eb 18		 jmp	 SHORT $LN1911@Decoder_am
$LN235@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002bf	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002c4	7d 0c		 jge	 SHORT $LN233@Decoder_am

; 86   :         Overflow = 1;

  002c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  002d0	eb 11		 jmp	 SHORT $LN240@Decoder_am
$LN233@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 373  :     if (sub (st->state, 6) > 0)

  002d2	66 85 c0	 test	 ax, ax
  002d5	7e 0c		 jle	 SHORT $LN240@Decoder_am
$LN1911@Decoder_am:

; 374  :     {
; 375  :         st->state = 6;                                   move16 ();

  002d7	b8 06 00 00 00	 mov	 eax, 6
  002dc	66 89 83 b8 01
	00 00		 mov	 WORD PTR [ebx+440], ax
$LN240@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002e3	8b 83 08 02 00
	00		 mov	 eax, DWORD PTR [ebx+520]
  002e9	0f bf 88 98 01
	00 00		 movsx	 ecx, WORD PTR [eax+408]
  002f0	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  002f3	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002f8	7f 17		 jg	 SHORT $LN2020@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002fa	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002ff	7c 10		 jl	 SHORT $LN2020@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 389  :     if (sub(st->dtxDecoderState->dtxGlobalState, DTX) == 0)

  00301	66 85 c0	 test	 ax, ax
  00304	75 15		 jne	 SHORT $LN117@Decoder_am

; 390  :     {
; 391  :        st->state = 5;                                    move16 ();
; 392  :        st->prev_bf = 0;                                  move16 ();

  00306	33 c0		 xor	 eax, eax
  00308	66 89 83 b4 01
	00 00		 mov	 WORD PTR [ebx+436], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\count.c

; 172  : }

  0030f	eb 3f		 jmp	 SHORT $LN2019@Decoder_am
$LN2020@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00311	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN117@Decoder_am:

; 186  :     L_diff = (Word32) var1 - var2;

  0031b	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  0031e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00323	7e 0c		 jle	 SHORT $LN265@Decoder_am

; 81   :         Overflow = 1;

  00325	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0032f	eb 26		 jmp	 SHORT $LN272@Decoder_am
$LN265@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00331	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00336	7d 0c		 jge	 SHORT $LN263@Decoder_am

; 86   :         Overflow = 1;

  00338	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00342	eb 13		 jmp	 SHORT $LN272@Decoder_am
$LN263@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 394  :     else if (test (), sub(st->dtxDecoderState->dtxGlobalState, DTX_MUTE) == 0)

  00344	66 85 c0	 test	 ax, ax
  00347	75 0e		 jne	 SHORT $LN272@Decoder_am

; 397  :        st->prev_bf = 1;                                  move16 ();

  00349	66 89 b3 b4 01
	00 00		 mov	 WORD PTR [ebx+436], si
$LN2019@Decoder_am:

; 395  :     {
; 396  :        st->state = 5;                                    move16 ();

  00350	66 89 93 b8 01
	00 00		 mov	 WORD PTR [ebx+440], dx
$LN272@Decoder_am:

; 398  :     }
; 399  :     
; 400  :     /* save old LSFs for CB gain smoothing */
; 401  :     Copy (st->lsfState->past_lsf_q, prev_lsf, M);

  00357	8b 8b f4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+500]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0035d	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00363	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00366	f3 0f 6f 41 14	 movdqu	 xmm0, XMMWORD PTR [ecx+20]
  0036b	89 45 80	 mov	 DWORD PTR _prev_lsf$[ebp+16], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0036e	0f bf c2	 movsx	 eax, dx
  00371	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _L_diff$1$[ebp], eax
  00377	83 c0 f9	 add	 eax, -7			; fffffff9H
  0037a	89 85 70 fe ff
	ff		 mov	 DWORD PTR _L_diff$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  00380	f3 0f 7f 85 70
	ff ff ff	 movdqu	 XMMWORD PTR _prev_lsf$[ebp], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00388	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0038d	7e 0c		 jle	 SHORT $LN288@Decoder_am

; 81   :         Overflow = 1;

  0038f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00399	eb 18		 jmp	 SHORT $LN1912@Decoder_am
$LN288@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0039b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003a0	7d 0c		 jge	 SHORT $LN286@Decoder_am

; 86   :         Overflow = 1;

  003a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  003ac	eb 05		 jmp	 SHORT $LN1912@Decoder_am
$LN286@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 406  :     if (sub (mode, MR122) != 0)

  003ae	66 85 c0	 test	 ax, ax
  003b1	74 35		 je	 SHORT $LN114@Decoder_am
$LN1912@Decoder_am:

; 407  :     {
; 408  :        D_plsf_3(st->lsfState, mode, bfi, parm, lsp_new);

  003b3	8b b5 c8 fe ff
	ff		 mov	 esi, DWORD PTR _parm$GSCopy$1$[ebp]
  003b9	8d 45 e8	 lea	 eax, DWORD PTR _lsp_new$[ebp]
  003bc	50		 push	 eax
  003bd	56		 push	 esi
  003be	57		 push	 edi
  003bf	e8 00 00 00 00	 call	 _D_plsf_3

; 409  : 
; 410  :        fwc ();                     /* function worst case */
; 411  : 
; 412  :        /* Advance synthesis parameters pointer */
; 413  :        parm += 3;                  move16 ();
; 414  :        
; 415  :        Int_lpc_1to3(st->lsp_old, lsp_new, A_t);

  003c4	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _Az$1$[ebp]
  003ca	83 c6 06	 add	 esi, 6
  003cd	8d 55 e8	 lea	 edx, DWORD PTR _lsp_new$[ebp]
  003d0	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], esi
  003d6	8d b3 88 01 00
	00		 lea	 esi, DWORD PTR [ebx+392]
  003dc	8b ce		 mov	 ecx, esi
  003de	e8 00 00 00 00	 call	 _Int_lpc_1to3
  003e3	83 c4 10	 add	 esp, 16			; 00000010H

; 416  :     }
; 417  :     else

  003e6	eb 3c		 jmp	 SHORT $LN113@Decoder_am
$LN114@Decoder_am:

; 418  :     {
; 419  :        D_plsf_5 (st->lsfState, bfi, parm, lsp_mid, lsp_new);

  003e8	8b b5 c8 fe ff
	ff		 mov	 esi, DWORD PTR _parm$GSCopy$1$[ebp]
  003ee	8d 45 e8	 lea	 eax, DWORD PTR _lsp_new$[ebp]
  003f1	50		 push	 eax
  003f2	8d 45 d4	 lea	 eax, DWORD PTR _lsp_mid$[ebp]
  003f5	8b d7		 mov	 edx, edi
  003f7	50		 push	 eax
  003f8	56		 push	 esi
  003f9	e8 00 00 00 00	 call	 _D_plsf_5

; 420  : 
; 421  :        fwc ();                     /* function worst case */
; 422  : 
; 423  :        /* Advance synthesis parameters pointer */
; 424  :        parm += 5;                  move16 ();
; 425  :        
; 426  :        Int_lpc_1and3 (st->lsp_old, lsp_mid, lsp_new, A_t);

  003fe	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _Az$1$[ebp]
  00404	83 c6 0a	 add	 esi, 10			; 0000000aH
  00407	8d 45 e8	 lea	 eax, DWORD PTR _lsp_new$[ebp]
  0040a	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], esi
  00410	8d 55 d4	 lea	 edx, DWORD PTR _lsp_mid$[ebp]
  00413	8d b3 88 01 00
	00		 lea	 esi, DWORD PTR [ebx+392]
  00419	50		 push	 eax
  0041a	8b ce		 mov	 ecx, esi
  0041c	e8 00 00 00 00	 call	 _Int_lpc_1and3
  00421	83 c4 14	 add	 esp, 20			; 00000014H
$LN113@Decoder_am:

; 427  :     }
; 428  :        
; 429  :     /* update the LSPs for the next frame */
; 430  :     for (i = 0; i < M; i++)
; 431  :     {
; 432  :        st->lsp_old[i] = lsp_new[i];        move16 (); 

  00424	f3 0f 6f 45 e8	 movdqu	 xmm0, XMMWORD PTR _lsp_new$[ebp]
  00429	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _L_diff$1$[ebp]

; 433  :     }
; 434  : 
; 435  :     fwc ();                     /* function worst case */
; 436  : 
; 437  :    /*------------------------------------------------------------------------*
; 438  :     *          Loop for every subframe in the analysis frame                 *
; 439  :     *------------------------------------------------------------------------*
; 440  :     * The subframe size is L_SUBFR and the loop is repeated L_FRAME/L_SUBFR  *
; 441  :     *  times                                                                 *
; 442  :     *     - decode the pitch delay                                           *
; 443  :     *     - decode algebraic code                                            *
; 444  :     *     - decode pitch and codebook gains                                  *
; 445  :     *     - find the excitation and compute synthesis speech                 *
; 446  :     *------------------------------------------------------------------------*/
; 447  :     
; 448  :     /* pointer to interpolated LPC parameters */
; 449  :     Az = A_t;                                                       move16 (); 
; 450  :     
; 451  :     evenSubfr = 0;                                                  move16();
; 452  :     subfrNr = -1;                                                   move16();

  0042f	83 c9 ff	 or	 ecx, -1
  00432	8b 45 f8	 mov	 eax, DWORD PTR _lsp_new$[ebp+16]
  00435	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  00439	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 453  :     for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)

  0043c	33 f6		 xor	 esi, esi
  0043e	8d 42 fd	 lea	 eax, DWORD PTR [edx-3]
  00441	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _evenSubfr$1$[ebp], 0
  0044b	89 85 68 fe ff
	ff		 mov	 DWORD PTR _L_diff$1$[ebp], eax
  00451	8d 42 fa	 lea	 eax, DWORD PTR [edx-6]
  00454	89 b5 9c fe ff
	ff		 mov	 DWORD PTR _i_subfr$1$[ebp], esi
  0045a	89 85 88 fe ff
	ff		 mov	 DWORD PTR _L_diff$1$[ebp], eax
$LL109@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00460	0f bf c1	 movsx	 eax, cx
  00463	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00464	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00469	7e 11		 jle	 SHORT $LN316@Decoder_am

; 81   :         Overflow = 1;

  0046b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00475	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  0047a	eb 1b		 jmp	 SHORT $LN2021@Decoder_am
$LN316@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0047c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00481	7d 11		 jge	 SHORT $LN314@Decoder_am

; 86   :         Overflow = 1;

  00483	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0048d	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00492	eb 03		 jmp	 SHORT $LN2021@Decoder_am
$LN314@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00494	0f b7 f8	 movzx	 edi, ax
$LN2021@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 455  :        subfrNr = add(subfrNr, 1);

  00497	0f b7 c7	 movzx	 eax, di
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0049a	b9 01 00 00 00	 mov	 ecx, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 455  :        subfrNr = add(subfrNr, 1);

  0049f	89 85 6c fe ff
	ff		 mov	 DWORD PTR _subfrNr$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004a5	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _evenSubfr$1$[ebp]
  004ab	98		 cwde
  004ac	2b c8		 sub	 ecx, eax

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  004ae	89 bd a0 fe ff
	ff		 mov	 DWORD PTR _var_out$1$[ebp], edi

; 79   :     if (L_var1 > 0X00007fffL)

  004b4	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  004ba	7e 11		 jle	 SHORT $LN326@Decoder_am

; 81   :         Overflow = 1;

  004bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004c6	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  004cb	eb 1c		 jmp	 SHORT $LN2022@Decoder_am
$LN326@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004cd	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  004d3	7d 11		 jge	 SHORT $LN324@Decoder_am

; 86   :         Overflow = 1;

  004d5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  004df	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  004e4	eb 03		 jmp	 SHORT $LN2022@Decoder_am
$LN324@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  004e6	0f b7 c1	 movzx	 eax, cx
$LN2022@Decoder_am:
  004e9	89 85 ac fe ff
	ff		 mov	 DWORD PTR _var_out$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 456  :        evenSubfr = sub(1, evenSubfr);

  004ef	0f b7 c0	 movzx	 eax, ax
  004f2	89 85 78 fe ff
	ff		 mov	 DWORD PTR _evenSubfr$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004f8	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _i_subfr$1$[ebp]
  004fe	98		 cwde
  004ff	83 c0 b0	 add	 eax, -80		; ffffffb0H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 459  :        pit_flag = i_subfr;             move16 ();

  00502	0f b7 f6	 movzx	 esi, si
  00505	89 b5 a4 fe ff
	ff		 mov	 DWORD PTR _pit_flag$1$[ebp], esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0050b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00510	7e 0c		 jle	 SHORT $LN340@Decoder_am

; 81   :         Overflow = 1;

  00512	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0051c	eb 7b		 jmp	 SHORT $LN369@Decoder_am
$LN340@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0051e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00523	7d 0c		 jge	 SHORT $LN338@Decoder_am

; 86   :         Overflow = 1;

  00525	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0052f	eb 68		 jmp	 SHORT $LN369@Decoder_am
$LN338@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 462  :        if (sub (i_subfr, L_FRAME_BY2) == 0)

  00531	66 85 c0	 test	 ax, ax
  00534	75 63		 jne	 SHORT $LN369@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00536	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  0053c	7e 0c		 jle	 SHORT $LN354@Decoder_am

; 81   :         Overflow = 1;

  0053e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00548	eb 19		 jmp	 SHORT $LN1913@Decoder_am
$LN354@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0054a	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00550	7d 0c		 jge	 SHORT $LN352@Decoder_am

; 86   :         Overflow = 1;

  00552	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0055c	eb 05		 jmp	 SHORT $LN1913@Decoder_am
$LN352@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 465  :           if (sub(mode, MR475) != 0 && sub(mode, MR515) != 0) 

  0055e	66 85 d2	 test	 dx, dx
  00561	74 36		 je	 SHORT $LN369@Decoder_am
$LN1913@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00563	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  00566	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0056b	7e 0c		 jle	 SHORT $LN364@Decoder_am

; 81   :         Overflow = 1;

  0056d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00577	eb 18		 jmp	 SHORT $LN1914@Decoder_am
$LN364@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00579	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0057e	7d 0c		 jge	 SHORT $LN362@Decoder_am

; 86   :         Overflow = 1;

  00580	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0058a	eb 05		 jmp	 SHORT $LN1914@Decoder_am
$LN362@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 465  :           if (sub(mode, MR475) != 0 && sub(mode, MR515) != 0) 

  0058c	66 85 c0	 test	 ax, ax
  0058f	74 08		 je	 SHORT $LN369@Decoder_am
$LN1914@Decoder_am:

; 466  :           {
; 467  :              pit_flag = 0;             move16 ();

  00591	33 f6		 xor	 esi, esi
  00593	89 b5 a4 fe ff
	ff		 mov	 DWORD PTR _pit_flag$1$[ebp], esi
$LN369@Decoder_am:

; 472  :        index = *parm++;                move16 ();

  00599	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _parm$GSCopy$1$[ebp]
  0059f	0f b7 18	 movzx	 ebx, WORD PTR [eax]
  005a2	83 c0 02	 add	 eax, 2
  005a5	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  005ab	8d 42 f9	 lea	 eax, DWORD PTR [edx-7]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 472  :        index = *parm++;                move16 ();

  005ae	89 9d 90 fe ff
	ff		 mov	 DWORD PTR _index$1$[ebp], ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  005b4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  005b9	7e 0c		 jle	 SHORT $LN380@Decoder_am

; 81   :         Overflow = 1;

  005bb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  005c5	eb 1c		 jmp	 SHORT $LN1915@Decoder_am
$LN380@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  005c7	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  005cc	7d 0c		 jge	 SHORT $LN378@Decoder_am

; 86   :         Overflow = 1;

  005ce	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  005d8	eb 09		 jmp	 SHORT $LN1915@Decoder_am
$LN378@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 479  :        if (sub(mode, MR122) != 0)

  005da	66 85 c0	 test	 ax, ax
  005dd	0f 84 f6 03 00
	00		 je	 $LN104@Decoder_am
$LN1915@Decoder_am:

; 480  :        {
; 481  :           /* flag4 indicates encoding with 4 bit resolution;     */
; 482  :           /* this is needed for mode MR475, MR515, MR59 and MR67 */
; 483  :           
; 484  :           flag4 = 0;                                 move16 ();

  005e3	33 db		 xor	 ebx, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  005e5	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  005eb	7e 0c		 jle	 SHORT $LN400@Decoder_am

; 81   :         Overflow = 1;

  005ed	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  005f7	eb 1d		 jmp	 SHORT $LN1916@Decoder_am
$LN400@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  005f9	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  005ff	7d 0c		 jge	 SHORT $LN398@Decoder_am

; 86   :         Overflow = 1;

  00601	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0060b	eb 09		 jmp	 SHORT $LN1916@Decoder_am
$LN398@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 489  :               (sub (mode, MR67) == 0) ) {

  0060d	66 85 d2	 test	 dx, dx
  00610	0f 84 8a 00 00
	00		 je	 $LN102@Decoder_am
$LN1916@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00616	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  00619	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0061e	7e 0c		 jle	 SHORT $LN410@Decoder_am

; 81   :         Overflow = 1;

  00620	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0062a	eb 18		 jmp	 SHORT $LN1917@Decoder_am
$LN410@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0062c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00631	7d 0c		 jge	 SHORT $LN408@Decoder_am

; 86   :         Overflow = 1;

  00633	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0063d	eb 05		 jmp	 SHORT $LN1917@Decoder_am
$LN408@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 489  :               (sub (mode, MR67) == 0) ) {

  0063f	66 85 c0	 test	 ax, ax
  00642	74 5c		 je	 SHORT $LN102@Decoder_am
$LN1917@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00644	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  00647	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0064c	7e 0c		 jle	 SHORT $LN420@Decoder_am

; 81   :         Overflow = 1;

  0064e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00658	eb 18		 jmp	 SHORT $LN1918@Decoder_am
$LN420@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0065a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0065f	7d 0c		 jge	 SHORT $LN418@Decoder_am

; 86   :         Overflow = 1;

  00661	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0066b	eb 05		 jmp	 SHORT $LN1918@Decoder_am
$LN418@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 489  :               (sub (mode, MR67) == 0) ) {

  0066d	66 85 c0	 test	 ax, ax
  00670	74 2e		 je	 SHORT $LN102@Decoder_am
$LN1918@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00672	8d 42 fd	 lea	 eax, DWORD PTR [edx-3]
  00675	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0067a	7e 0c		 jle	 SHORT $LN430@Decoder_am

; 81   :         Overflow = 1;

  0067c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00686	eb 1d		 jmp	 SHORT $LN435@Decoder_am
$LN430@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00688	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0068d	7d 0c		 jge	 SHORT $LN428@Decoder_am

; 86   :         Overflow = 1;

  0068f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00699	eb 0a		 jmp	 SHORT $LN435@Decoder_am
$LN428@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 489  :               (sub (mode, MR67) == 0) ) {

  0069b	66 85 c0	 test	 ax, ax
  0069e	75 05		 jne	 SHORT $LN435@Decoder_am
$LN102@Decoder_am:

; 490  :              flag4 = 1;                              move16 ();

  006a0	bb 01 00 00 00	 mov	 ebx, 1
$LN435@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006a5	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _L_diff$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 498  :           delta_frc_low = 5;                      move16();

  006ab	ba 05 00 00 00	 mov	 edx, 5
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006b0	83 c0 fb	 add	 eax, -5			; fffffffbH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 499  :           delta_frc_range = 9;                    move16();

  006b3	8d 72 04	 lea	 esi, DWORD PTR [edx+4]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  006b6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  006bb	7e 0c		 jle	 SHORT $LN448@Decoder_am

; 81   :         Overflow = 1;

  006bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  006c7	eb 20		 jmp	 SHORT $LN455@Decoder_am
$LN448@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  006c9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  006ce	7d 0c		 jge	 SHORT $LN446@Decoder_am

; 86   :         Overflow = 1;

  006d0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  006da	eb 0d		 jmp	 SHORT $LN455@Decoder_am
$LN446@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 502  :           if ( sub(mode, MR795) == 0 )

  006dc	66 85 c0	 test	 ax, ax
  006df	75 08		 jne	 SHORT $LN455@Decoder_am

; 503  :           {
; 504  :              delta_frc_low = 10;                  move16();

  006e1	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH

; 505  :              delta_frc_range = 19;                move16();

  006e6	8d 72 09	 lea	 esi, DWORD PTR [edx+9]
$LN455@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  006e9	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _st$GSCopy$1$[ebp]
  006ef	0f b7 b8 b2 01
	00 00		 movzx	 edi, WORD PTR [eax+434]
  006f6	0f bf cf	 movsx	 ecx, di
  006f9	0f bf c2	 movsx	 eax, dx
  006fc	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  006fe	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00704	7e 11		 jle	 SHORT $LN462@Decoder_am

; 81   :         Overflow = 1;

  00706	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00710	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00715	eb 1c		 jmp	 SHORT $LN459@Decoder_am
$LN462@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00717	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0071d	7d 11		 jge	 SHORT $LN460@Decoder_am

; 86   :         Overflow = 1;

  0071f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00729	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0072e	eb 03		 jmp	 SHORT $LN459@Decoder_am
$LN460@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00730	0f b7 c1	 movzx	 eax, cx
$LN459@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 508  :           t0_min = sub(st->old_T0, delta_frc_low);

  00733	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00736	98		 cwde
  00737	83 e8 14	 sub	 eax, 20			; 00000014H

; 79   :     if (L_var1 > 0X00007fffL)

  0073a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0073f	7e 0c		 jle	 SHORT $LN474@Decoder_am

; 81   :         Overflow = 1;

  00741	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0074b	eb 1d		 jmp	 SHORT $LN479@Decoder_am
$LN474@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0074d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00752	7d 0c		 jge	 SHORT $LN472@Decoder_am

; 86   :         Overflow = 1;

  00754	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0075e	eb 05		 jmp	 SHORT $LN1919@Decoder_am
$LN472@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 510  :           if (sub(t0_min, PIT_MIN) < 0)

  00760	66 85 c0	 test	 ax, ax
  00763	79 05		 jns	 SHORT $LN479@Decoder_am
$LN1919@Decoder_am:

; 511  :           {
; 512  :              t0_min = PIT_MIN;                    move16();

  00765	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
$LN479@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0076a	0f bf ce	 movsx	 ecx, si
  0076d	0f bf c2	 movsx	 eax, dx
  00770	03 c1		 add	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  00772	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00777	7e 11		 jle	 SHORT $LN486@Decoder_am

; 81   :         Overflow = 1;

  00779	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00783	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00788	eb 1b		 jmp	 SHORT $LN483@Decoder_am
$LN486@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0078a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0078f	7d 11		 jge	 SHORT $LN484@Decoder_am

; 86   :         Overflow = 1;

  00791	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0079b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  007a0	eb 03		 jmp	 SHORT $LN483@Decoder_am
$LN484@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  007a2	0f b7 c0	 movzx	 eax, ax
$LN483@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 514  :           t0_max = add(t0_min, delta_frc_range);

  007a5	0f b7 f0	 movzx	 esi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  007a8	98		 cwde
  007a9	2d 8f 00 00 00	 sub	 eax, 143		; 0000008fH

; 79   :     if (L_var1 > 0X00007fffL)

  007ae	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  007b3	7e 0c		 jle	 SHORT $LN498@Decoder_am

; 81   :         Overflow = 1;

  007b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  007bf	eb 18		 jmp	 SHORT $LN1920@Decoder_am
$LN498@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  007c1	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  007c6	7d 0c		 jge	 SHORT $LN496@Decoder_am

; 86   :         Overflow = 1;

  007c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  007d2	eb 44		 jmp	 SHORT $LN99@Decoder_am
$LN496@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 516  :           if (sub(t0_max, PIT_MAX) > 0)

  007d4	66 85 c0	 test	 ax, ax
  007d7	7e 3f		 jle	 SHORT $LN99@Decoder_am
$LN1920@Decoder_am:

; 517  :           {
; 518  :              t0_max = PIT_MAX;                    move16();

  007d9	be 8f 00 00 00	 mov	 esi, 143		; 0000008fH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  007de	8b c6		 mov	 eax, esi
  007e0	2b c1		 sub	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  007e2	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  007e7	7e 11		 jle	 SHORT $LN510@Decoder_am

; 81   :         Overflow = 1;

  007e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  007f3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  007f8	eb 1b		 jmp	 SHORT $LN507@Decoder_am
$LN510@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  007fa	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  007ff	7d 11		 jge	 SHORT $LN508@Decoder_am

; 86   :         Overflow = 1;

  00801	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0080b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00810	eb 03		 jmp	 SHORT $LN507@Decoder_am
$LN508@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00812	0f b7 c0	 movzx	 eax, ax
$LN507@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 519  :              t0_min = sub(t0_max, delta_frc_range);

  00815	0f b7 d0	 movzx	 edx, ax
$LN99@Decoder_am:

; 520  :           }
; 521  :              
; 522  :           Dec_lag3 (index, t0_min, t0_max, pit_flag, st->old_T0,
; 523  :                     &T0, &T0_frac, flag4);

  00818	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _index$1$[ebp]
  0081e	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _T0_frac$[ebp]
  00824	53		 push	 ebx
  00825	50		 push	 eax
  00826	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _T0$[ebp]
  0082c	50		 push	 eax
  0082d	57		 push	 edi
  0082e	ff b5 a4 fe ff
	ff		 push	 DWORD PTR _pit_flag$1$[ebp]
  00834	56		 push	 esi
  00835	e8 00 00 00 00	 call	 _Dec_lag3

; 524  : 
; 525  :           st->T0_lagBuff = T0;                        move16 ();

  0083a	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00840	83 c4 18	 add	 esp, 24			; 00000018H

; 526  : 
; 527  :           test ();
; 528  :           if (bfi != 0)

  00843	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  0084b	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _T0$[ebp]
  00851	66 89 83 cc 01
	00 00		 mov	 WORD PTR [ebx+460], ax
  00858	0f 84 70 01 00
	00		 je	 $LN1981@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0085e	0f bf 8b b2 01
	00 00		 movsx	 ecx, WORD PTR [ebx+434]
  00865	8d 81 71 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-143]

; 79   :     if (L_var1 > 0X00007fffL)

  0086b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00870	7e 0c		 jle	 SHORT $LN526@Decoder_am

; 81   :         Overflow = 1;

  00872	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0087c	eb 55		 jmp	 SHORT $LN97@Decoder_am
$LN526@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0087e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00883	7d 0c		 jge	 SHORT $LN524@Decoder_am

; 86   :         Overflow = 1;

  00885	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0088f	eb 05		 jmp	 SHORT $LN1921@Decoder_am
$LN524@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 531  :              if (sub (st->old_T0, PIT_MAX) < 0)     

  00891	66 85 c0	 test	 ax, ax
  00894	79 3d		 jns	 SHORT $LN97@Decoder_am
$LN1921@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00896	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 79   :     if (L_var1 > 0X00007fffL)

  00899	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0089e	7e 11		 jle	 SHORT $LN536@Decoder_am

; 81   :         Overflow = 1;

  008a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  008aa	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  008af	eb 1b		 jmp	 SHORT $LN533@Decoder_am
$LN536@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  008b1	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  008b6	7d 11		 jge	 SHORT $LN534@Decoder_am

; 86   :         Overflow = 1;

  008b8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  008c2	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  008c7	eb 03		 jmp	 SHORT $LN533@Decoder_am
$LN534@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  008c9	0f b7 c0	 movzx	 eax, ax
$LN533@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 533  :                 st->old_T0 = add(st->old_T0, 1);    /* degradation    */

  008cc	66 89 83 b2 01
	00 00		 mov	 WORD PTR [ebx+434], ax
$LN97@Decoder_am:

; 534  :              }
; 535  :              T0 = st->old_T0;                     move16 (); 

  008d3	0f b7 b3 b2 01
	00 00		 movzx	 esi, WORD PTR [ebx+434]
  008da	89 b5 b4 fe ff
	ff		 mov	 DWORD PTR _T0$[ebp], esi

; 536  :              T0_frac = 0;                         move16 (); 

  008e0	33 f6		 xor	 esi, esi
  008e2	89 b5 98 fe ff
	ff		 mov	 DWORD PTR _T0_frac$[ebp], esi

; 544  :                   )

  008e8	66 39 b3 ce 01
	00 00		 cmp	 WORD PTR [ebx+462], si
  008ef	74 2e		 je	 SHORT $LN2002@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  008f1	0f bf 83 d0 01
	00 00		 movsx	 eax, WORD PTR [ebx+464]
  008f8	83 e8 04	 sub	 eax, 4

; 79   :     if (L_var1 > 0X00007fffL)

  008fb	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00900	7e 0c		 jle	 SHORT $LN560@Decoder_am

; 81   :         Overflow = 1;

  00902	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0090c	eb 38		 jmp	 SHORT $LN1922@Decoder_am
$LN560@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0090e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00913	7d 2c		 jge	 SHORT $LN558@Decoder_am

; 86   :         Overflow = 1;

  00915	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2002@Decoder_am:
  0091f	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _T0$[ebp]
$LN585@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 552  :           Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 1);

  00925	6a 01		 push	 1
  00927	51		 push	 ecx
  00928	8b 8b 84 01 00
	00		 mov	 ecx, DWORD PTR [ebx+388]
  0092e	8b d0		 mov	 edx, eax
  00930	56		 push	 esi
  00931	e8 00 00 00 00	 call	 _Pred_lt_3or6

; 553  :        }
; 554  :        else

  00936	8b bd a0 fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  0093c	e9 1d 01 00 00	 jmp	 $LN2024@Decoder_am
$LN558@Decoder_am:

; 544  :                   )

  00941	66 85 c0	 test	 ax, ax
  00944	7e d9		 jle	 SHORT $LN2002@Decoder_am
$LN1922@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00946	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  0094c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00951	7e 0c		 jle	 SHORT $LN570@Decoder_am

; 81   :         Overflow = 1;

  00953	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0095d	eb 18		 jmp	 SHORT $LN1923@Decoder_am
$LN570@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0095f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00964	7d 0c		 jge	 SHORT $LN568@Decoder_am

; 86   :         Overflow = 1;

  00966	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00970	eb 05		 jmp	 SHORT $LN1923@Decoder_am
$LN568@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 544  :                   )

  00972	66 85 c0	 test	 ax, ax
  00975	74 45		 je	 SHORT $LN95@Decoder_am
$LN1923@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00977	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00978	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0097d	7e 0c		 jle	 SHORT $LN580@Decoder_am

; 81   :         Overflow = 1;

  0097f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00989	eb 18		 jmp	 SHORT $LN1924@Decoder_am
$LN580@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0098b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00990	7d 0c		 jge	 SHORT $LN578@Decoder_am

; 86   :         Overflow = 1;

  00992	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0099c	eb 05		 jmp	 SHORT $LN1924@Decoder_am
$LN578@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 544  :                   )

  0099e	66 85 c0	 test	 ax, ax
  009a1	74 19		 je	 SHORT $LN95@Decoder_am
$LN1924@Decoder_am:
  009a3	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _mode$GSCopy$1$[ebp]
  009a9	ba 02 00 00 00	 mov	 edx, 2
  009ae	e8 00 00 00 00	 call	 _sub
  009b3	66 85 c0	 test	 ax, ax
  009b6	0f 85 63 ff ff
	ff		 jne	 $LN2002@Decoder_am
$LN95@Decoder_am:

; 545  :              {
; 546  :                 T0 = st->T0_lagBuff;                  move16 ();

  009bc	0f b7 83 cc 01
	00 00		 movzx	 eax, WORD PTR [ebx+460]
  009c3	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _T0$[ebp], eax
  009c9	e9 57 ff ff ff	 jmp	 $LN585@Decoder_am
$LN1981@Decoder_am:
  009ce	8b b5 98 fe ff
	ff		 mov	 esi, DWORD PTR _T0_frac$[ebp]
  009d4	e9 4c ff ff ff	 jmp	 $LN585@Decoder_am
$LN104@Decoder_am:

; 555  :        {
; 556  :           Dec_lag6 (index, PIT_MIN_MR122,
; 557  :                     PIT_MAX, pit_flag, &T0, &T0_frac);

  009d9	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _T0_frac$[ebp]
  009df	50		 push	 eax
  009e0	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _T0$[ebp]
  009e6	50		 push	 eax
  009e7	56		 push	 esi
  009e8	51		 push	 ecx
  009e9	8b cb		 mov	 ecx, ebx
  009eb	e8 00 00 00 00	 call	 _Dec_lag6
  009f0	83 c4 10	 add	 esp, 16			; 00000010H

; 560  :           if ( bfi == 0 && (pit_flag == 0 || sub (index, 61) < 0))

  009f3	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  009fb	75 20		 jne	 SHORT $LN93@Decoder_am
  009fd	66 85 f6	 test	 si, si
  00a00	0f 84 9d 00 00
	00		 je	 $LN1982@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00a06	0f bf c3	 movsx	 eax, bx
  00a09	83 e8 3d	 sub	 eax, 61			; 0000003dH

; 79   :     if (L_var1 > 0X00007fffL)

  00a0c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00a11	7e 68		 jle	 SHORT $LN600@Decoder_am

; 81   :         Overflow = 1;

  00a13	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN93@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 565  :              st->T0_lagBuff = T0;                 move16 ();

  00a1d	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00a23	66 8b 85 b4 fe
	ff ff		 mov	 ax, WORD PTR _T0$[ebp]

; 566  :              T0 = st->old_T0;                     move16 (); 
; 567  :              T0_frac = 0;                         move16 (); 

  00a2a	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _T0_frac$[ebp], 0
  00a34	66 89 83 cc 01
	00 00		 mov	 WORD PTR [ebx+460], ax
  00a3b	0f b7 83 b2 01
	00 00		 movzx	 eax, WORD PTR [ebx+434]
  00a42	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _T0$[ebp], eax
$LN609@Decoder_am:

; 572  :           Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 0);

  00a48	6a 00		 push	 0
  00a4a	51		 push	 ecx
  00a4b	ff b5 98 fe ff
	ff		 push	 DWORD PTR _T0_frac$[ebp]
  00a51	8b 8b 84 01 00
	00		 mov	 ecx, DWORD PTR [ebx+388]
  00a57	8b d0		 mov	 edx, eax
  00a59	e8 00 00 00 00	 call	 _Pred_lt_3or6
$LN2024@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00a5e	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 572  :           Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 0);

  00a64	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00a67	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00a6d	7e 42		 jle	 SHORT $LN624@Decoder_am

; 81   :         Overflow = 1;

  00a6f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00a79	eb 53		 jmp	 SHORT $LN1925@Decoder_am
$LN600@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00a7b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00a80	7d 18		 jge	 SHORT $LN598@Decoder_am

; 88   :     }
; 89   :     else

  00a82	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00a88	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _T0$[ebp]
  00a8e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00a98	eb ae		 jmp	 SHORT $LN609@Decoder_am
$LN598@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 560  :           if ( bfi == 0 && (pit_flag == 0 || sub (index, 61) < 0))

  00a9a	66 85 c0	 test	 ax, ax
  00a9d	0f 89 7a ff ff
	ff		 jns	 $LN93@Decoder_am
$LN1982@Decoder_am:
  00aa3	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00aa9	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _T0$[ebp]
  00aaf	eb 97		 jmp	 SHORT $LN609@Decoder_am
$LN624@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00ab1	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00ab7	7d 0c		 jge	 SHORT $LN622@Decoder_am

; 86   :         Overflow = 1;

  00ab9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00ac3	eb 09		 jmp	 SHORT $LN1925@Decoder_am
$LN622@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 584  :         if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)

  00ac5	66 85 f6	 test	 si, si
  00ac8	0f 84 d5 01 00
	00		 je	 $LN89@Decoder_am
$LN1925@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00ace	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 79   :     if (L_var1 > 0X00007fffL)

  00ad1	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00ad6	7e 0c		 jle	 SHORT $LN634@Decoder_am

; 81   :         Overflow = 1;

  00ad8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00ae2	eb 1c		 jmp	 SHORT $LN1926@Decoder_am
$LN634@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00ae4	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00ae9	7d 0c		 jge	 SHORT $LN632@Decoder_am

; 86   :         Overflow = 1;

  00aeb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00af5	eb 09		 jmp	 SHORT $LN1926@Decoder_am
$LN632@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 584  :         if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)

  00af7	66 85 c0	 test	 ax, ax
  00afa	0f 84 a3 01 00
	00		 je	 $LN89@Decoder_am
$LN1926@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00b00	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]

; 79   :     if (L_var1 > 0X00007fffL)

  00b03	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00b08	7f 33		 jg	 SHORT $LN2025@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00b0a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00b0f	7c 2c		 jl	 SHORT $LN2025@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 597  :         else if (sub (mode, MR59) == 0)

  00b11	66 85 c0	 test	 ax, ax
  00b14	75 31		 jne	 SHORT $LN87@Decoder_am

; 598  :         {   /* MR59 */
; 599  :            test (); 
; 600  :            index = *parm++;        /* index of position */ move16 ();

  00b16	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]

; 601  :            i = *parm++;            /* signs             */ move16 ();
; 602  :            
; 603  :            fwc ();                 /* function worst case */
; 604  : 
; 605  :            decode_2i40_11bits (i, index, code);

  00b1c	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  00b1f	50		 push	 eax
  00b20	0f b7 17	 movzx	 edx, WORD PTR [edi]
  00b23	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00b27	83 c7 04	 add	 edi, 4
  00b2a	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
  00b30	e8 00 00 00 00	 call	 _decode_2i40_11bits
  00b35	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 305  :         else

  00b38	e9 8b 01 00 00	 jmp	 $LN2028@Decoder_am
$LN2025@Decoder_am:

; 86   :         Overflow = 1;

  00b3d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN87@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  00b47	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]
  00b4a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00b4f	7f 33		 jg	 SHORT $LN2026@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00b51	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00b56	7c 2c		 jl	 SHORT $LN2026@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 611  :         else if (sub (mode, MR67) == 0)

  00b58	66 85 c0	 test	 ax, ax
  00b5b	75 31		 jne	 SHORT $LN85@Decoder_am

; 612  :         {   /* MR67 */
; 613  :            test (); test ();
; 614  :            index = *parm++;        /* index of position */ move16 ();

  00b5d	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]

; 615  :            i = *parm++;            /* signs             */ move16 ();
; 616  :            
; 617  :            fwc ();                 /* function worst case */
; 618  : 
; 619  :            decode_3i40_14bits (i, index, code);

  00b63	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  00b66	50		 push	 eax
  00b67	0f b7 17	 movzx	 edx, WORD PTR [edi]
  00b6a	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00b6e	83 c7 04	 add	 edi, 4
  00b71	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
  00b77	e8 00 00 00 00	 call	 _decode_3i40_14bits
  00b7c	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 305  :         else

  00b7f	e9 44 01 00 00	 jmp	 $LN2028@Decoder_am
$LN2026@Decoder_am:

; 86   :         Overflow = 1;

  00b84	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN85@Decoder_am:

; 186  :     L_diff = (Word32) var1 - var2;

  00b8e	8d 46 fb	 lea	 eax, DWORD PTR [esi-5]

; 79   :     if (L_var1 > 0X00007fffL)

  00b91	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00b96	7e 3e		 jle	 SHORT $LN745@Decoder_am

; 81   :         Overflow = 1;

  00b98	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN83@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  00ba2	8d 46 fa	 lea	 eax, DWORD PTR [esi-6]
  00ba5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00baa	7f 69		 jg	 SHORT $LN2027@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00bac	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00bb1	7c 62		 jl	 SHORT $LN2027@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 639  :         else if (sub (mode, MR102) == 0)

  00bb3	66 85 c0	 test	 ax, ax
  00bb6	75 67		 jne	 SHORT $LN81@Decoder_am

; 640  :         {  /* MR102 */
; 641  :            test (); test (); test ();
; 642  : 
; 643  :            fwc ();                 /* function worst case */
; 644  : 
; 645  :            dec_8i40_31bits (parm, code);

  00bb8	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]
  00bbe	8d 55 84	 lea	 edx, DWORD PTR _code$[ebp]
  00bc1	8b cf		 mov	 ecx, edi
  00bc3	e8 00 00 00 00	 call	 _dec_8i40_31bits

; 646  :            parm += 7;                                       move16 (); 

  00bc8	83 c7 0e	 add	 edi, 14			; 0000000eH
  00bcb	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 305  :         else

  00bd1	e9 f2 00 00 00	 jmp	 $LN2028@Decoder_am
$LN745@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00bd6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00bdb	7d 0c		 jge	 SHORT $LN743@Decoder_am

; 86   :         Overflow = 1;

  00bdd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00be7	eb 05		 jmp	 SHORT $LN1927@Decoder_am
$LN743@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 625  :         else if (sub (mode, MR795) <= 0)

  00be9	66 85 c0	 test	 ax, ax
  00bec	7f b4		 jg	 SHORT $LN83@Decoder_am
$LN1927@Decoder_am:

; 626  :         {   /* MR74, MR795 */
; 627  :            test (); test (); test ();
; 628  :            index = *parm++;        /* index of position */ move16 ();

  00bee	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]

; 629  :            i = *parm++;            /* signs             */ move16 ();
; 630  :            
; 631  :            fwc ();                 /* function worst case */
; 632  : 
; 633  :            decode_4i40_17bits (i, index, code);

  00bf4	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  00bf7	50		 push	 eax
  00bf8	0f b7 17	 movzx	 edx, WORD PTR [edi]
  00bfb	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00bff	83 c7 04	 add	 edi, 4
  00c02	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
  00c08	e8 00 00 00 00	 call	 _decode_4i40_17bits
  00c0d	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 305  :         else

  00c10	e9 b3 00 00 00	 jmp	 $LN2028@Decoder_am
$LN2027@Decoder_am:

; 86   :         Overflow = 1;

  00c15	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN81@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 657  :            if (bfi != 0)

  00c1f	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  00c27	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]
  00c2d	0f b7 17	 movzx	 edx, WORD PTR [edi]
  00c30	74 1e		 je	 SHORT $LN79@Decoder_am

; 658  :            {
; 659  :               ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  00c32	66 8b 93 b8 01
	00 00		 mov	 dx, WORD PTR [ebx+440]
  00c39	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00c3f	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  00c45	50		 push	 eax
  00c46	e8 00 00 00 00	 call	 _ec_gain_pitch
  00c4b	83 c4 04	 add	 esp, 4

; 660  :            }
; 661  :            else

  00c4e	eb 14		 jmp	 SHORT $LN818@Decoder_am
$LN79@Decoder_am:

; 662  :            {
; 663  :               gain_pit = d_gain_pitch (mode, index);        move16 ();

  00c50	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _mode$GSCopy$1$[ebp]
  00c56	e8 00 00 00 00	 call	 _d_gain_pitch
  00c5b	0f b7 c0	 movzx	 eax, ax
  00c5e	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _gain_pit$[ebp], eax
$LN818@Decoder_am:

; 664  :            }
; 665  :            ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 666  :                                  &gain_pit);

  00c64	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
  00c6a	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00c70	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  00c76	50		 push	 eax
  00c77	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  00c7e	50		 push	 eax
  00c7f	e8 00 00 00 00	 call	 _ec_gain_pitch_update
  00c84	83 c4 08	 add	 esp, 8

; 667  :            
; 668  : 
; 669  :            fwc ();                 /* function worst case */
; 670  : 
; 671  : 
; 672  :            dec_10i40_35bits (parm, code);

  00c87	8d 55 84	 lea	 edx, DWORD PTR _code$[ebp]
  00c8a	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  00c8d	e8 00 00 00 00	 call	 _dec_10i40_35bits
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00c92	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _gain_pit$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 673  :            parm += 10;                                     move16 (); 

  00c98	83 c7 16	 add	 edi, 22			; 00000016H
  00c9b	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 305  :         else

  00ca1	eb 2c		 jmp	 SHORT $LN2029@Decoder_am
$LN89@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 586  :            index = *parm++;        /* index of position */ move16 ();

  00ca3	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _parm$GSCopy$1$[ebp]
  00ca9	0f b7 01	 movzx	 eax, WORD PTR [ecx]

; 587  :            i = *parm++;            /* signs             */ move16 ();

  00cac	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00cb0	83 c1 04	 add	 ecx, 4
  00cb3	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], ecx

; 588  :            
; 589  :            fwc ();                 /* function worst case */
; 590  : 
; 591  :            decode_2i40_9bits (subfrNr, i, index, code);

  00cb9	8d 4d 84	 lea	 ecx, DWORD PTR _code$[ebp]
  00cbc	51		 push	 ecx
  00cbd	50		 push	 eax
  00cbe	8b cf		 mov	 ecx, edi
  00cc0	e8 00 00 00 00	 call	 _decode_2i40_9bits
  00cc5	83 c4 08	 add	 esp, 8
$LN2028@Decoder_am:

; 592  :            
; 593  :            fwc ();                 /* function worst case */
; 594  : 
; 595  :            pit_sharp = shl (st->sharp, 1);

  00cc8	0f b7 93 b0 01
	00 00		 movzx	 edx, WORD PTR [ebx+432]
$LN2029@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00ccf	0f bf ca	 movsx	 ecx, dx
  00cd2	03 c9		 add	 ecx, ecx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00cd4	0f bf c1	 movsx	 eax, cx
  00cd7	3b c8		 cmp	 ecx, eax
  00cd9	74 1f		 je	 SHORT $LN650@Decoder_am

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00cdb	66 85 d2	 test	 dx, dx
  00cde	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00ce8	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00ced	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00cf2	0f 4f c1	 cmovg	 eax, ecx
  00cf5	0f b7 c0	 movzx	 eax, ax

; 305  :         else

  00cf8	eb 03		 jmp	 SHORT $LN647@Decoder_am
$LN650@Decoder_am:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00cfa	0f b7 c1	 movzx	 eax, cx
$LN647@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 686  :         for (i = T0; i < L_SUBFR; i++)

  00cfd	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _T0$[ebp]
  00d03	0f b7 c0	 movzx	 eax, ax
  00d06	66 83 f9 28	 cmp	 cx, 40			; 00000028H
  00d0a	0f 8d ca 00 00
	00		 jge	 $LN75@Decoder_am
  00d10	0f bf d8	 movsx	 ebx, ax
  00d13	8d 55 84	 lea	 edx, DWORD PTR _code$[ebp]
  00d16	0f bf c1	 movsx	 eax, cx
  00d19	8d 75 84	 lea	 esi, DWORD PTR _code$[ebp]
  00d1c	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  00d1f	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00d24	2b c1		 sub	 eax, ecx
  00d26	0f b7 f8	 movzx	 edi, ax
  00d29	8d a4 24 00 00
	00 00		 npad	 7
$LL77@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00d30	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00d33	0f af c3	 imul	 eax, ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00d36	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00d39	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00d3e	74 05		 je	 SHORT $LN837@Decoder_am

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00d40	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN837@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  00d45	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00d4a	7e 11		 jle	 SHORT $LN843@Decoder_am

; 81   :         Overflow = 1;

  00d4c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00d56	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00d5b	eb 1b		 jmp	 SHORT $LN840@Decoder_am
$LN843@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00d5d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00d62	7d 11		 jge	 SHORT $LN841@Decoder_am

; 86   :         Overflow = 1;

  00d64	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00d6e	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00d73	eb 03		 jmp	 SHORT $LN840@Decoder_am
$LN841@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00d75	0f b7 c8	 movzx	 ecx, ax
$LN840@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 688  :            temp = mult (code[i - T0], pit_sharp);

  00d78	0f b7 c1	 movzx	 eax, cx
  00d7b	89 85 84 fe ff
	ff		 mov	 DWORD PTR _temp$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00d81	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00d84	0f bf c9	 movsx	 ecx, cx
  00d87	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00d89	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00d8f	7e 11		 jle	 SHORT $LN853@Decoder_am

; 81   :         Overflow = 1;

  00d91	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00d9b	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00da0	eb 1c		 jmp	 SHORT $LN850@Decoder_am
$LN853@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00da2	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00da8	7d 11		 jge	 SHORT $LN851@Decoder_am

; 86   :         Overflow = 1;

  00daa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00db4	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00db9	eb 03		 jmp	 SHORT $LN850@Decoder_am
$LN851@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00dbb	0f b7 c1	 movzx	 eax, cx
$LN850@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 689  :            code[i] = add (code[i], temp);

  00dbe	66 89 02	 mov	 WORD PTR [edx], ax
  00dc1	83 c6 02	 add	 esi, 2
  00dc4	83 c2 02	 add	 edx, 2
  00dc7	4f		 dec	 edi
  00dc8	0f 85 62 ff ff
	ff		 jne	 $LL77@Decoder_am
  00dce	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  00dd4	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
$LN75@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00dda	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00de0	0f 8f d3 01 00
	00		 jg	 $LN2030@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00de6	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00dec	0f 8c c7 01 00
	00		 jl	 $LN2030@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 701  :         if (test(), sub (mode, MR475) == 0)

  00df2	66 85 f6	 test	 si, si
  00df5	0f 85 c8 01 00
	00		 jne	 $LN74@Decoder_am

; 702  :         {
; 703  :            /* read and decode pitch and code gain */
; 704  :            test();      
; 705  :            if (evenSubfr != 0) 

  00dfb	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  00e01	66 85 ff	 test	 di, di
  00e04	74 1a		 je	 SHORT $LN2008@Decoder_am

; 706  :            {
; 707  :               index_mr475 = *parm++;        move16 (); /* index of gain(s) */

  00e06	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _parm$GSCopy$1$[ebp]
  00e0c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00e0f	83 c0 02	 add	 eax, 2
  00e12	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _index_mr475$1$[ebp], ecx
  00e18	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], eax
  00e1e	eb 06		 jmp	 SHORT $LN876@Decoder_am
$LN2008@Decoder_am:
  00e20	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _index_mr475$1$[ebp]
$LN876@Decoder_am:

; 708  :            }
; 709  : 
; 710  :            test();
; 711  :            if (bfi == 0)

  00e26	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  00e2e	75 2a		 jne	 SHORT $LN72@Decoder_am

; 712  :            {
; 713  :               Dec_gain(st->pred_state, mode, index_mr475, code,
; 714  :                        evenSubfr, &gain_pit, &gain_code); 

  00e30	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  00e36	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  00e3c	50		 push	 eax
  00e3d	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00e43	50		 push	 eax
  00e44	57		 push	 edi
  00e45	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  00e48	50		 push	 eax
  00e49	51		 push	 ecx
  00e4a	8b 8b 00 02 00
	00		 mov	 ecx, DWORD PTR [ebx+512]
  00e50	e8 00 00 00 00	 call	 _Dec_gain
  00e55	83 c4 14	 add	 esp, 20			; 00000014H

; 715  :            }
; 716  :            else

  00e58	eb 3c		 jmp	 SHORT $LN71@Decoder_am
$LN72@Decoder_am:

; 717  :            {
; 718  :               ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  00e5a	66 8b 93 b8 01
	00 00		 mov	 dx, WORD PTR [ebx+440]
  00e61	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00e67	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  00e6d	50		 push	 eax
  00e6e	e8 00 00 00 00	 call	 _ec_gain_pitch

; 719  :               ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 720  :                             &gain_code);

  00e73	8b 93 00 02 00
	00		 mov	 edx, DWORD PTR [ebx+512]
  00e79	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  00e7f	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  00e85	50		 push	 eax
  00e86	0f b7 83 b8 01
	00 00		 movzx	 eax, WORD PTR [ebx+440]
  00e8d	50		 push	 eax
  00e8e	e8 00 00 00 00	 call	 _ec_gain_code
  00e93	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN71@Decoder_am:

; 721  :            }
; 722  :            ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 723  :                                  &gain_pit);

  00e96	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
  00e9c	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  00ea2	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  00ea8	50		 push	 eax
  00ea9	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  00eb0	50		 push	 eax
  00eb1	e8 00 00 00 00	 call	 _ec_gain_pitch_update

; 724  :            ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 725  :                                 &gain_code);

  00eb6	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  00ebc	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 195  :     if (bfi == 0)

  00ebf	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  00ec7	75 79		 jne	 SHORT $LN1984@Decoder_am

; 198  :         if (prev_bf != 0)

  00ec9	66 83 bb b4 01
	00 00 00	 cmp	 WORD PTR [ebx+436], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00ed1	8b 9d c0 fe ff
	ff		 mov	 ebx, DWORD PTR _gain_code$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 198  :         if (prev_bf != 0)

  00ed7	74 63		 je	 SHORT $LN904@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00ed9	0f b7 71 0c	 movzx	 esi, WORD PTR [ecx+12]
  00edd	0f bf c6	 movsx	 eax, si
  00ee0	0f bf d3	 movsx	 edx, bx
  00ee3	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00ee5	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00eeb	7e 1e		 jle	 SHORT $LN899@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  00eed	8b de		 mov	 ebx, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  00eef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00ef9	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  00eff	89 9d c0 fe ff
	ff		 mov	 DWORD PTR _gain_code$[ebp], ebx

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  00f05	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  00f09	eb 3d		 jmp	 SHORT $LN906@Decoder_am
$LN899@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00f0b	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00f11	7d 16		 jge	 SHORT $LN897@Decoder_am
  00f13	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]

; 86   :         Overflow = 1;

  00f19	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  00f23	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  00f27	eb 1f		 jmp	 SHORT $LN906@Decoder_am
$LN897@Decoder_am:

; 199  :         {
; 200  :             test (); 
; 201  :             if (sub (*gain_code, st->prev_gc) > 0)

  00f29	66 85 d2	 test	 dx, dx
  00f2c	7e 08		 jle	 SHORT $LN1999@Decoder_am

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  00f2e	8b de		 mov	 ebx, esi
  00f30	89 9d c0 fe ff
	ff		 mov	 DWORD PTR _gain_code$[ebp], ebx
$LN1999@Decoder_am:
  00f36	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
$LN904@Decoder_am:

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  00f3c	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  00f40	eb 06		 jmp	 SHORT $LN906@Decoder_am
$LN1984@Decoder_am:
  00f42	8b 9d c0 fe ff
	ff		 mov	 ebx, DWORD PTR _gain_code$[ebp]
$LN906@Decoder_am:

; 207  :     }
; 208  : 
; 209  :     /* update EC states: previous gain, gain buffer */
; 210  :     st->past_gain_code = *gain_code;                       move16 (); 

  00f48	66 89 59 0a	 mov	 WORD PTR [ecx+10], bx

; 211  :     
; 212  :     for (i = 1; i < 5; i++)
; 213  :     {
; 214  :         st->gbuf[i - 1] = st->gbuf[i];                     move16 (); 

  00f4c	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  00f50	66 89 01	 mov	 WORD PTR [ecx], ax
  00f53	0f b7 41 04	 movzx	 eax, WORD PTR [ecx+4]
  00f57	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  00f5b	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00f5f	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00f63	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00f67	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 215  :     }
; 216  :     st->gbuf[4] = *gain_code;                              move16 (); 

  00f6b	66 89 59 08	 mov	 WORD PTR [ecx+8], bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 729  :            pit_sharp = gain_pit;                                move16 ();

  00f6f	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _gain_pit$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00f75	0f bf c1	 movsx	 eax, cx
  00f78	2d d9 32 00 00	 sub	 eax, 13017		; 000032d9H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 729  :            pit_sharp = gain_pit;                                move16 ();

  00f7d	0f b7 d1	 movzx	 edx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00f80	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00f85	7e 14		 jle	 SHORT $LN925@Decoder_am

; 81   :         Overflow = 1;

  00f87	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 733  :                pit_sharp = SHARPMAX;                            move16 ();

  00f91	ba d9 32 00 00	 mov	 edx, 13017		; 000032d9H

; 734  :            }
; 735  : 
; 736  :         }
; 737  :         else if (test(), test(), (sub (mode, MR74) <= 0) || 

  00f96	e9 ab 04 00 00	 jmp	 $LN1997@Decoder_am
$LN925@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00f9b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00fa0	0f 8c 96 04 00
	00		 jl	 $LN2032@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 731  :            if (sub (pit_sharp, SHARPMAX) > 0) 

  00fa6	66 85 c0	 test	 ax, ax
  00fa9	0f 8e 97 04 00
	00		 jle	 $LN1997@Decoder_am

; 733  :                pit_sharp = SHARPMAX;                            move16 ();

  00faf	ba d9 32 00 00	 mov	 edx, 13017		; 000032d9H

; 734  :            }
; 735  : 
; 736  :         }
; 737  :         else if (test(), test(), (sub (mode, MR74) <= 0) || 

  00fb4	e9 8d 04 00 00	 jmp	 $LN1997@Decoder_am
$LN2030@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00fb9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN74@Decoder_am:

; 186  :     L_diff = (Word32) var1 - var2;

  00fc3	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]

; 79   :     if (L_var1 > 0X00007fffL)

  00fc6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00fcb	7e 0c		 jle	 SHORT $LN941@Decoder_am

; 81   :         Overflow = 1;

  00fcd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00fd7	eb 69		 jmp	 SHORT $LN1930@Decoder_am
$LN941@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00fd9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00fde	7d 5d		 jge	 SHORT $LN939@Decoder_am

; 86   :         Overflow = 1;

  00fe0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN132@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 741  :             index = *parm++;                move16 (); /* index of gain(s) */

  00fea	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _parm$GSCopy$1$[ebp]
  00ff0	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00ff3	83 c1 02	 add	 ecx, 2

; 742  :            
; 743  :             test();
; 744  :             if (bfi == 0)

  00ff6	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  00ffe	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], ecx
  01004	0f 85 62 02 00
	00		 jne	 $LN67@Decoder_am

; 745  :             {
; 746  :                Dec_gain(st->pred_state, mode, index, code,
; 747  :                         evenSubfr, &gain_pit, &gain_code);

  0100a	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  01010	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _gain_code$[ebp]
  01016	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  0101c	51		 push	 ecx
  0101d	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _gain_pit$[ebp]
  01023	51		 push	 ecx
  01024	57		 push	 edi
  01025	8d 4d 84	 lea	 ecx, DWORD PTR _code$[ebp]
  01028	51		 push	 ecx
  01029	8b 8b 00 02 00
	00		 mov	 ecx, DWORD PTR [ebx+512]
  0102f	50		 push	 eax
  01030	e8 00 00 00 00	 call	 _Dec_gain
  01035	83 c4 14	 add	 esp, 20			; 00000014H

; 748  :             }
; 749  :             else

  01038	e9 71 02 00 00	 jmp	 $LN66@Decoder_am
$LN939@Decoder_am:

; 738  :                  (sub (mode, MR102) == 0))

  0103d	66 85 c0	 test	 ax, ax
  01040	7e a8		 jle	 SHORT $LN132@Decoder_am
$LN1930@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01042	8d 46 fa	 lea	 eax, DWORD PTR [esi-6]
  01045	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0104a	7e 0c		 jle	 SHORT $LN951@Decoder_am

; 81   :         Overflow = 1;

  0104c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01056	eb 1c		 jmp	 SHORT $LN68@Decoder_am
$LN951@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01058	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0105d	7d 0c		 jge	 SHORT $LN949@Decoder_am

; 86   :         Overflow = 1;

  0105f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01069	eb 09		 jmp	 SHORT $LN68@Decoder_am
$LN949@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 738  :                  (sub (mode, MR102) == 0))

  0106b	66 85 c0	 test	 ax, ax
  0106e	0f 84 76 ff ff
	ff		 je	 $LN132@Decoder_am
$LN68@Decoder_am:

; 780  :            index = *parm++;                move16 (); /* index of gain(s) */

  01074	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _parm$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0107a	8d 46 fb	 lea	 eax, DWORD PTR [esi-5]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 780  :            index = *parm++;                move16 (); /* index of gain(s) */

  0107d	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  01080	83 c7 02	 add	 edi, 2
  01083	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01089	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0108e	0f 8f 52 01 00
	00		 jg	 $LN2031@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01094	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01099	0f 8c 47 01 00
	00		 jl	 $LN2031@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 783  :            if (sub (mode, MR795) == 0)

  0109f	66 85 c0	 test	 ax, ax
  010a2	0f 85 48 01 00
	00		 jne	 $LN61@Decoder_am

; 784  :            {
; 785  :               /* decode pitch gain */
; 786  :               test();
; 787  :               if (bfi != 0)

  010a8	66 39 85 cc fe
	ff ff		 cmp	 WORD PTR _bfi$1$[ebp], ax
  010af	74 1e		 je	 SHORT $LN60@Decoder_am

; 788  :               {
; 789  :                  ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  010b1	66 8b 93 b8 01
	00 00		 mov	 dx, WORD PTR [ebx+440]
  010b8	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  010be	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  010c4	50		 push	 eax
  010c5	e8 00 00 00 00	 call	 _ec_gain_pitch
  010ca	83 c4 04	 add	 esp, 4

; 790  :               }
; 791  :               else

  010cd	eb 16		 jmp	 SHORT $LN1067@Decoder_am
$LN60@Decoder_am:

; 792  :               {
; 793  :                  gain_pit = d_gain_pitch (mode, index);       move16 ();

  010cf	8b d1		 mov	 edx, ecx
  010d1	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR _mode$GSCopy$1$[ebp]
  010d7	e8 00 00 00 00	 call	 _d_gain_pitch
  010dc	0f b7 c0	 movzx	 eax, ax
  010df	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _gain_pit$[ebp], eax
$LN1067@Decoder_am:

; 794  :               }
; 795  :               ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 796  :                                     &gain_pit);

  010e5	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
  010eb	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  010f1	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  010f7	50		 push	 eax
  010f8	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  010ff	50		 push	 eax
  01100	e8 00 00 00 00	 call	 _ec_gain_pitch_update

; 797  :               
; 798  :               /* read and decode code gain */
; 799  :               index = *parm++;                                move16 ();

  01105	0f b7 07	 movzx	 eax, WORD PTR [edi]
  01108	83 c4 08	 add	 esp, 8
  0110b	83 c7 02	 add	 edi, 2
  0110e	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _parm$GSCopy$1$[ebp], edi

; 800  :               test();
; 801  :               if (bfi == 0)

  01114	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR _bfi$1$[ebp]
  0111a	66 85 ff	 test	 di, di
  0111d	75 22		 jne	 SHORT $LN58@Decoder_am

; 802  :               {
; 803  :                  d_gain_code (st->pred_state, mode, index, code, &gain_code);

  0111f	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  01125	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _gain_code$[ebp]
  0112b	51		 push	 ecx
  0112c	8d 4d 84	 lea	 ecx, DWORD PTR _code$[ebp]
  0112f	51		 push	 ecx
  01130	8b 8b 00 02 00
	00		 mov	 ecx, DWORD PTR [ebx+512]
  01136	50		 push	 eax
  01137	e8 00 00 00 00	 call	 _d_gain_code
  0113c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 804  :               }
; 805  :               else

  0113f	eb 23		 jmp	 SHORT $LN57@Decoder_am
$LN58@Decoder_am:

; 806  :               {
; 807  :                  ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 808  :                                &gain_code);

  01141	8b 93 00 02 00
	00		 mov	 edx, DWORD PTR [ebx+512]
  01147	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  0114d	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  01153	50		 push	 eax
  01154	0f b7 83 b8 01
	00 00		 movzx	 eax, WORD PTR [ebx+440]
  0115b	50		 push	 eax
  0115c	e8 00 00 00 00	 call	 _ec_gain_code
  01161	83 c4 08	 add	 esp, 8
$LN57@Decoder_am:

; 809  :               }
; 810  :               ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 811  :                                    &gain_code);

  01164	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  0116a	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01170	50		 push	 eax
  01171	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  01178	8b d7		 mov	 edx, edi
  0117a	50		 push	 eax
  0117b	e8 00 00 00 00	 call	 _ec_gain_code_update

; 815  :               pit_sharp = gain_pit;                               move16 ();

  01180	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  01186	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01189	0f bf c1	 movsx	 eax, cx
  0118c	2d d9 32 00 00	 sub	 eax, 13017		; 000032d9H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 815  :               pit_sharp = gain_pit;                               move16 ();

  01191	0f b7 d1	 movzx	 edx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01194	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01199	7e 1a		 jle	 SHORT $LN1084@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 819  :                  pit_sharp = SHARPMAX;                           move16 ();

  0119b	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  011a1	ba d9 32 00 00	 mov	 edx, 13017		; 000032d9H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  011a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 822  :            else 

  011b0	e9 97 02 00 00	 jmp	 $LN1095@Decoder_am
$LN1084@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  011b5	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  011ba	7d 15		 jge	 SHORT $LN1082@Decoder_am

; 88   :     }
; 89   :     else

  011bc	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  011c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  011cc	e9 7b 02 00 00	 jmp	 $LN1095@Decoder_am
$LN1082@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 817  :               if (sub (pit_sharp, SHARPMAX) > 0)

  011d1	66 85 c0	 test	 ax, ax
  011d4	7e 05		 jle	 SHORT $LN1987@Decoder_am

; 819  :                  pit_sharp = SHARPMAX;                           move16 ();

  011d6	ba d9 32 00 00	 mov	 edx, 13017		; 000032d9H
$LN1987@Decoder_am:

; 822  :            else 

  011db	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  011e1	e9 66 02 00 00	 jmp	 $LN1095@Decoder_am
$LN2031@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  011e6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN61@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 825  :               if (bfi == 0)

  011f0	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR _bfi$1$[ebp]

; 826  :               {
; 827  :                  d_gain_code (st->pred_state, mode, index, code, &gain_code);

  011f6	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  011fc	50		 push	 eax
  011fd	66 85 ff	 test	 di, di
  01200	75 1b		 jne	 SHORT $LN54@Decoder_am
  01202	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  01208	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  0120b	50		 push	 eax
  0120c	51		 push	 ecx
  0120d	8b 8b 00 02 00
	00		 mov	 ecx, DWORD PTR [ebx+512]
  01213	e8 00 00 00 00	 call	 _d_gain_code
  01218	83 c4 0c	 add	 esp, 12			; 0000000cH

; 828  :               }
; 829  :               else

  0121b	eb 1c		 jmp	 SHORT $LN53@Decoder_am
$LN54@Decoder_am:

; 830  :               {
; 831  :                  ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 832  :                                &gain_code);

  0121d	0f b7 83 b8 01
	00 00		 movzx	 eax, WORD PTR [ebx+440]
  01224	8b 93 00 02 00
	00		 mov	 edx, DWORD PTR [ebx+512]
  0122a	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  01230	50		 push	 eax
  01231	e8 00 00 00 00	 call	 _ec_gain_code
  01236	83 c4 08	 add	 esp, 8
$LN53@Decoder_am:

; 833  :               }
; 834  :               ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 835  :                                    &gain_code);

  01239	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  0123f	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01245	50		 push	 eax
  01246	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  0124d	8b d7		 mov	 edx, edi
  0124f	50		 push	 eax
  01250	e8 00 00 00 00	 call	 _ec_gain_code_update

; 836  :                             
; 837  :               fwc ();                 /* function worst case */
; 838  :                 
; 839  :               pit_sharp = gain_pit;                                move16 ();

  01255	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _gain_pit$[ebp]
  0125b	83 c4 08	 add	 esp, 8
  0125e	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  01264	0f b7 d1	 movzx	 edx, cx
  01267	e9 e0 01 00 00	 jmp	 $LN1095@Decoder_am
$LN67@Decoder_am:

; 750  :             {
; 751  :                ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);

  0126c	66 8b 93 b8 01
	00 00		 mov	 dx, WORD PTR [ebx+440]
  01273	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  01279	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  0127f	50		 push	 eax
  01280	e8 00 00 00 00	 call	 _ec_gain_pitch

; 752  :                ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
; 753  :                              &gain_code);

  01285	8b 93 00 02 00
	00		 mov	 edx, DWORD PTR [ebx+512]
  0128b	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _gain_code$[ebp]
  01291	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  01297	50		 push	 eax
  01298	0f b7 83 b8 01
	00 00		 movzx	 eax, WORD PTR [ebx+440]
  0129f	50		 push	 eax
  012a0	e8 00 00 00 00	 call	 _ec_gain_code
  012a5	8b bd ac fe ff
	ff		 mov	 edi, DWORD PTR _var_out$1$[ebp]
  012ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN66@Decoder_am:

; 754  :             }
; 755  :             ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
; 756  :                                   &gain_pit);

  012ae	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
  012b4	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _gain_pit$[ebp]
  012ba	8b 8b f8 01 00
	00		 mov	 ecx, DWORD PTR [ebx+504]
  012c0	50		 push	 eax
  012c1	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  012c8	50		 push	 eax
  012c9	e8 00 00 00 00	 call	 _ec_gain_pitch_update

; 757  :             ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
; 758  :                                  &gain_code);

  012ce	8b 8b fc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+508]
  012d4	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 195  :     if (bfi == 0)

  012d7	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  012df	75 79		 jne	 SHORT $LN1986@Decoder_am

; 198  :         if (prev_bf != 0)

  012e1	66 83 bb b4 01
	00 00 00	 cmp	 WORD PTR [ebx+436], 0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  012e9	8b 9d c0 fe ff
	ff		 mov	 ebx, DWORD PTR _gain_code$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 198  :         if (prev_bf != 0)

  012ef	74 63		 je	 SHORT $LN984@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  012f1	0f b7 71 0c	 movzx	 esi, WORD PTR [ecx+12]
  012f5	0f bf c6	 movsx	 eax, si
  012f8	0f bf d3	 movsx	 edx, bx
  012fb	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  012fd	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  01303	7e 1e		 jle	 SHORT $LN979@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  01305	8b de		 mov	 ebx, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  01307	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01311	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  01317	89 9d c0 fe ff
	ff		 mov	 DWORD PTR _gain_code$[ebp], ebx

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  0131d	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  01321	eb 3d		 jmp	 SHORT $LN986@Decoder_am
$LN979@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01323	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  01329	7d 16		 jge	 SHORT $LN977@Decoder_am
  0132b	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]

; 86   :         Overflow = 1;

  01331	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ec_gains.c

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  0133b	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  0133f	eb 1f		 jmp	 SHORT $LN986@Decoder_am
$LN977@Decoder_am:

; 199  :         {
; 200  :             test (); 
; 201  :             if (sub (*gain_code, st->prev_gc) > 0)

  01341	66 85 d2	 test	 dx, dx
  01344	7e 08		 jle	 SHORT $LN1998@Decoder_am

; 203  :                 *gain_code = st->prev_gc;     move16 (); 

  01346	8b de		 mov	 ebx, esi
  01348	89 9d c0 fe ff
	ff		 mov	 DWORD PTR _gain_code$[ebp], ebx
$LN1998@Decoder_am:
  0134e	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
$LN984@Decoder_am:

; 206  :         st->prev_gc = *gain_code;                          move16 (); 

  01354	66 89 59 0c	 mov	 WORD PTR [ecx+12], bx
  01358	eb 06		 jmp	 SHORT $LN986@Decoder_am
$LN1986@Decoder_am:
  0135a	8b 9d c0 fe ff
	ff		 mov	 ebx, DWORD PTR _gain_code$[ebp]
$LN986@Decoder_am:

; 207  :     }
; 208  : 
; 209  :     /* update EC states: previous gain, gain buffer */
; 210  :     st->past_gain_code = *gain_code;                       move16 (); 

  01360	66 89 59 0a	 mov	 WORD PTR [ecx+10], bx

; 211  :     
; 212  :     for (i = 1; i < 5; i++)
; 213  :     {
; 214  :         st->gbuf[i - 1] = st->gbuf[i];                     move16 (); 

  01364	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  01368	66 89 01	 mov	 WORD PTR [ecx], ax
  0136b	0f b7 41 04	 movzx	 eax, WORD PTR [ecx+4]
  0136f	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  01373	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  01377	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  0137b	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  0137f	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 215  :     }
; 216  :     st->gbuf[4] = *gain_code;                              move16 (); 

  01383	66 89 59 08	 mov	 WORD PTR [ecx+8], bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 762  :             pit_sharp = gain_pit;                               move16 ();

  01387	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _gain_pit$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0138d	0f bf c1	 movsx	 eax, cx
  01390	2d d9 32 00 00	 sub	 eax, 13017		; 000032d9H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 762  :             pit_sharp = gain_pit;                               move16 ();

  01395	0f b7 d1	 movzx	 edx, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01398	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0139d	7e 0c		 jle	 SHORT $LN1005@Decoder_am

; 81   :         Overflow = 1;

  0139f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  013a9	eb 18		 jmp	 SHORT $LN1934@Decoder_am
$LN1005@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  013ab	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  013b0	7d 0c		 jge	 SHORT $LN1003@Decoder_am

; 86   :         Overflow = 1;

  013b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  013bc	eb 0a		 jmp	 SHORT $LN1010@Decoder_am
$LN1003@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 764  :             if (sub (pit_sharp, SHARPMAX) > 0) 

  013be	66 85 c0	 test	 ax, ax
  013c1	7e 05		 jle	 SHORT $LN1010@Decoder_am
$LN1934@Decoder_am:

; 765  :             {
; 766  :                pit_sharp = SHARPMAX;                           move16 ();

  013c3	ba d9 32 00 00	 mov	 edx, 13017		; 000032d9H
$LN1010@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  013c8	8d 46 fa	 lea	 eax, DWORD PTR [esi-6]
  013cb	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  013d0	7f 6a		 jg	 SHORT $LN2032@Decoder_am

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  013d2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  013d7	7c 63		 jl	 SHORT $LN2032@Decoder_am

; 186  :     L_diff = (Word32) var1 - var2;

  013d9	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 769  :             if (sub (mode, MR102) == 0)

  013df	66 85 c0	 test	 ax, ax
  013e2	75 68		 jne	 SHORT $LN1095@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  013e4	0f bf 83 b2 01
	00 00		 movsx	 eax, WORD PTR [ebx+434]
  013eb	83 e8 2d	 sub	 eax, 45			; 0000002dH

; 79   :     if (L_var1 > 0X00007fffL)

  013ee	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  013f3	7e 0c		 jle	 SHORT $LN1037@Decoder_am

; 81   :         Overflow = 1;

  013f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  013ff	eb 18		 jmp	 SHORT $LN1935@Decoder_am
$LN1037@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01401	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01406	7d 0c		 jge	 SHORT $LN1035@Decoder_am

; 86   :         Overflow = 1;

  01408	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01412	eb 38		 jmp	 SHORT $LN1095@Decoder_am
$LN1035@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 771  :                if (sub (st->old_T0, add(L_SUBFR, 5)) > 0)

  01414	66 85 c0	 test	 ax, ax
  01417	7e 33		 jle	 SHORT $LN1095@Decoder_am
$LN1935@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  01419	66 85 d2	 test	 dx, dx
  0141c	79 12		 jns	 SHORT $LN1043@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0141e	0f bf c2	 movsx	 eax, dx
  01421	f7 d0		 not	 eax
  01423	c1 f8 02	 sar	 eax, 2
  01426	f7 d0		 not	 eax
  01428	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 773  :                   pit_sharp = shr(pit_sharp, 2);

  0142b	0f b7 d0	 movzx	 edx, ax
  0142e	eb 1c		 jmp	 SHORT $LN1095@Decoder_am
$LN1043@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  01430	66 c1 fa 02	 sar	 dx, 2
  01434	0f b7 c2	 movzx	 eax, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 773  :                   pit_sharp = shr(pit_sharp, 2);

  01437	0f b7 d0	 movzx	 edx, ax
  0143a	eb 10		 jmp	 SHORT $LN1095@Decoder_am
$LN2032@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  0143c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1997@Decoder_am:
  01446	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
$LN1095@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  0144c	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  01452	7e 0c		 jle	 SHORT $LN1106@Decoder_am

; 81   :         Overflow = 1;

  01454	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0145e	eb 1e		 jmp	 SHORT $LN51@Decoder_am
$LN1106@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01460	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  01466	7d 0c		 jge	 SHORT $LN1104@Decoder_am

; 86   :         Overflow = 1;

  01468	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01472	eb 0a		 jmp	 SHORT $LN51@Decoder_am
$LN1104@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 848  :         if (sub(mode, MR475) != 0 || evenSubfr == 0)

  01474	66 85 f6	 test	 si, si
  01477	75 05		 jne	 SHORT $LN51@Decoder_am
  01479	66 85 ff	 test	 di, di
  0147c	75 46		 jne	 SHORT $LN1125@Decoder_am
$LN51@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0147e	0f bf c1	 movsx	 eax, cx
  01481	2d d9 32 00 00	 sub	 eax, 13017		; 000032d9H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 850  :             st->sharp = gain_pit;                                   move16 (); 

  01486	66 89 8b b0 01
	00 00		 mov	 WORD PTR [ebx+432], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0148d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01492	7e 0c		 jle	 SHORT $LN1120@Decoder_am

; 81   :         Overflow = 1;

  01494	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0149e	eb 18		 jmp	 SHORT $LN1937@Decoder_am
$LN1120@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  014a0	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  014a5	7d 0c		 jge	 SHORT $LN1118@Decoder_am

; 86   :         Overflow = 1;

  014a7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  014b1	eb 11		 jmp	 SHORT $LN1125@Decoder_am
$LN1118@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 852  :             if (sub (st->sharp, SHARPMAX) > 0)

  014b3	66 85 c0	 test	 ax, ax
  014b6	7e 0c		 jle	 SHORT $LN1125@Decoder_am
$LN1937@Decoder_am:

; 853  :             {
; 854  :                 st->sharp = SHARPMAX;                                move16 ();

  014b8	b8 d9 32 00 00	 mov	 eax, 13017		; 000032d9H
  014bd	66 89 83 b0 01
	00 00		 mov	 WORD PTR [ebx+432], ax
$LN1125@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  014c4	0f bf ca	 movsx	 ecx, dx
  014c7	03 c9		 add	 ecx, ecx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  014c9	0f bf c1	 movsx	 eax, cx
  014cc	3b c8		 cmp	 ecx, eax
  014ce	74 1f		 je	 SHORT $LN1130@Decoder_am

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  014d0	66 85 d2	 test	 dx, dx
  014d3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  014dd	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  014e2	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  014e7	0f 4f c1	 cmovg	 eax, ecx
  014ea	0f b7 c0	 movzx	 eax, ax

; 305  :         else

  014ed	eb 03		 jmp	 SHORT $LN1127@Decoder_am
$LN1130@Decoder_am:

; 306  :         {
; 307  :             var_out = extract_l (result);

  014ef	0f b7 c1	 movzx	 eax, cx
$LN1127@Decoder_am:

; 186  :     L_diff = (Word32) var1 - var2;

  014f2	0f bf c8	 movsx	 ecx, ax
  014f5	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv6380[ebp], ecx
  014fb	8d 81 00 c0 ff
	ff		 lea	 eax, DWORD PTR [ecx-16384]
  01501	89 85 74 fe ff
	ff		 mov	 DWORD PTR _L_diff$1$[ebp], eax

; 79   :     if (L_var1 > 0X00007fffL)

  01507	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0150c	7e 0c		 jle	 SHORT $LN1154@Decoder_am

; 81   :         Overflow = 1;

  0150e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01518	eb 1f		 jmp	 SHORT $LN1938@Decoder_am
$LN1154@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0151a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0151f	7d 0f		 jge	 SHORT $LN1152@Decoder_am

; 86   :         Overflow = 1;

  01521	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0152b	e9 2b 01 00 00	 jmp	 $LN46@Decoder_am
$LN1152@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 860  :         if (sub (pit_sharp, 16384) > 0)

  01530	66 85 c0	 test	 ax, ax
  01533	0f 8e 22 01 00
	00		 jle	 $LN46@Decoder_am
$LN1938@Decoder_am:
  01539	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _gain_pit$[ebp]

; 862  :            for (i = 0; i < L_SUBFR; i++)

  0153f	8d b5 d0 fe ff
	ff		 lea	 esi, DWORD PTR _excp$[ebp]
  01545	8b 9b 84 01 00
	00		 mov	 ebx, DWORD PTR [ebx+388]
  0154b	8b c6		 mov	 eax, esi
  0154d	0f bf d2	 movsx	 edx, dx
  01550	2b d8		 sub	 ebx, eax
  01552	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv6386[ebp], edx
  01558	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  0155d	8d 49 00	 npad	 3
$LL48@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  01560	0f bf 04 1e	 movsx	 eax, WORD PTR [esi+ebx]
  01564	0f af c1	 imul	 eax, ecx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  01567	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0156a	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0156f	74 05		 je	 SHORT $LN1159@Decoder_am

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  01571	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN1159@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  01576	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0157b	7e 11		 jle	 SHORT $LN1165@Decoder_am

; 81   :         Overflow = 1;

  0157d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01587	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0158c	eb 1b		 jmp	 SHORT $LN1162@Decoder_am
$LN1165@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0158e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01593	7d 11		 jge	 SHORT $LN1163@Decoder_am

; 86   :         Overflow = 1;

  01595	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0159f	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  015a4	eb 03		 jmp	 SHORT $LN1162@Decoder_am
$LN1163@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  015a6	0f b7 c8	 movzx	 ecx, ax
$LN1162@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 864  :                temp = mult (st->exc[i], pit_sharp);

  015a9	0f b7 c1	 movzx	 eax, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  015ac	0f bf c9	 movsx	 ecx, cx
  015af	0f af ca	 imul	 ecx, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 864  :                temp = mult (st->exc[i], pit_sharp);

  015b2	89 85 84 fe ff
	ff		 mov	 DWORD PTR _temp$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  015b8	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  015be	74 04		 je	 SHORT $LN1171@Decoder_am

; 488  :     {
; 489  :         L_var_out *= 2;

  015c0	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  015c2	eb 0f		 jmp	 SHORT $LN1170@Decoder_am
$LN1171@Decoder_am:

; 492  :     {
; 493  :         Overflow = 1;

  015c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  015ce	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN1170@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  015d3	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  015d9	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  015de	7e 0c		 jle	 SHORT $LN1181@Decoder_am

; 81   :         Overflow = 1;

  015e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  015ea	eb 26		 jmp	 SHORT $LN1186@Decoder_am
$LN1181@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  015ec	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  015f1	7d 0c		 jge	 SHORT $LN1179@Decoder_am

; 86   :         Overflow = 1;

  015f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  015fd	eb 13		 jmp	 SHORT $LN1186@Decoder_am
$LN1179@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 867  :                if (sub(mode, MR122)==0)

  015ff	66 85 c0	 test	 ax, ax
  01602	75 0e		 jne	 SHORT $LN1186@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  01604	85 c9		 test	 ecx, ecx
  01606	79 08		 jns	 SHORT $LN1187@Decoder_am

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01608	f7 d1		 not	 ecx
  0160a	d1 f9		 sar	 ecx, 1
  0160c	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  0160e	eb 02		 jmp	 SHORT $LN1186@Decoder_am
$LN1187@Decoder_am:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01610	d1 f9		 sar	 ecx, 1
$LN1186@Decoder_am:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  01612	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01618	85 c9		 test	 ecx, ecx
  0161a	78 1d		 js	 SHORT $LN1208@Decoder_am

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0161c	8b c1		 mov	 eax, ecx
  0161e	33 c2		 xor	 eax, edx
  01620	79 17		 jns	 SHORT $LN1208@Decoder_am

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  01622	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  01624	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0162e	85 c9		 test	 ecx, ecx
  01630	0f 98 c2	 sets	 dl
  01633	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN1208@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 862  :            for (i = 0; i < L_SUBFR; i++)

  01639	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR tv6380[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0163f	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 871  :                excp[i] = round (L_temp);                        move16 (); 

  01642	66 89 16	 mov	 WORD PTR [esi], dx
  01645	83 c6 02	 add	 esi, 2
  01648	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR tv6386[ebp]
  0164e	4f		 dec	 edi
  0164f	0f 85 0b ff ff
	ff		 jne	 $LL48@Decoder_am
  01655	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _L_diff$1$[ebp]
$LN46@Decoder_am:

; 872  :             }
; 873  :         }
; 874  :         
; 875  :         /*-------------------------------------------------------*
; 876  :          * - Store list of LTP gains needed in the source        *
; 877  :          *   characteristic detector (SCD)                       *
; 878  :          *-------------------------------------------------------*/
; 879  :         test ();
; 880  :         if ( bfi == 0 )

  0165b	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _bfi$1$[ebp]

; 881  :         {
; 882  :            for (i = 0; i < 8; i++)
; 883  :            {
; 884  :               st->ltpGainHistory[i] = st->ltpGainHistory[i+1];     move16 ();

  01661	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]

; 885  :            }
; 886  :            st->ltpGainHistory[8] = gain_pit;                       move16 ();

  01667	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR _gain_pit$[ebp]
  0166d	66 85 c0	 test	 ax, ax
  01670	75 7d		 jne	 SHORT $LN1220@Decoder_am

; 881  :         {
; 882  :            for (i = 0; i < 8; i++)
; 883  :            {
; 884  :               st->ltpGainHistory[i] = st->ltpGainHistory[i+1];     move16 ();

  01672	0f b7 83 d4 01
	00 00		 movzx	 eax, WORD PTR [ebx+468]
  01679	66 89 83 d2 01
	00 00		 mov	 WORD PTR [ebx+466], ax
  01680	0f b7 83 d6 01
	00 00		 movzx	 eax, WORD PTR [ebx+470]
  01687	66 89 83 d4 01
	00 00		 mov	 WORD PTR [ebx+468], ax
  0168e	0f b7 83 d8 01
	00 00		 movzx	 eax, WORD PTR [ebx+472]
  01695	66 89 83 d6 01
	00 00		 mov	 WORD PTR [ebx+470], ax
  0169c	0f b7 83 da 01
	00 00		 movzx	 eax, WORD PTR [ebx+474]
  016a3	66 89 83 d8 01
	00 00		 mov	 WORD PTR [ebx+472], ax
  016aa	0f b7 83 dc 01
	00 00		 movzx	 eax, WORD PTR [ebx+476]
  016b1	66 89 83 da 01
	00 00		 mov	 WORD PTR [ebx+474], ax
  016b8	0f b7 83 de 01
	00 00		 movzx	 eax, WORD PTR [ebx+478]
  016bf	66 89 83 dc 01
	00 00		 mov	 WORD PTR [ebx+476], ax
  016c6	0f b7 83 e0 01
	00 00		 movzx	 eax, WORD PTR [ebx+480]
  016cd	66 89 83 de 01
	00 00		 mov	 WORD PTR [ebx+478], ax
  016d4	0f b7 83 e2 01
	00 00		 movzx	 eax, WORD PTR [ebx+482]
  016db	66 89 83 e0 01
	00 00		 mov	 WORD PTR [ebx+480], ax

; 885  :            }
; 886  :            st->ltpGainHistory[8] = gain_pit;                       move16 ();

  016e2	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _bfi$1$[ebp]
  016e8	66 89 bb e2 01
	00 00		 mov	 WORD PTR [ebx+482], di
$LN1220@Decoder_am:

; 899  :              )

  016ef	66 83 bb b4 01
	00 00 00	 cmp	 WORD PTR [ebx+436], 0
  016f7	75 09		 jne	 SHORT $LN39@Decoder_am
  016f9	66 85 c0	 test	 ax, ax
  016fc	0f 84 b1 01 00
	00		 je	 $LN1328@Decoder_am
$LN39@Decoder_am:
  01702	66 83 bb ce 01
	00 00 00	 cmp	 WORD PTR [ebx+462], 0
  0170a	0f 84 a3 01 00
	00		 je	 $LN1328@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01710	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  01716	7e 0c		 jle	 SHORT $LN1239@Decoder_am

; 81   :         Overflow = 1;

  01718	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01722	eb 19		 jmp	 SHORT $LN1939@Decoder_am
$LN1239@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01724	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  0172a	7d 0c		 jge	 SHORT $LN1237@Decoder_am

; 86   :         Overflow = 1;

  0172c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01736	eb 05		 jmp	 SHORT $LN1939@Decoder_am
$LN1237@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 899  :              )

  01738	66 85 f6	 test	 si, si
  0173b	74 66		 je	 SHORT $LN38@Decoder_am
$LN1939@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0173d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 79   :     if (L_var1 > 0X00007fffL)

  01740	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01745	7e 0c		 jle	 SHORT $LN1249@Decoder_am

; 81   :         Overflow = 1;

  01747	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01751	eb 18		 jmp	 SHORT $LN1940@Decoder_am
$LN1249@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01753	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01758	7d 0c		 jge	 SHORT $LN1247@Decoder_am

; 86   :         Overflow = 1;

  0175a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01764	eb 05		 jmp	 SHORT $LN1940@Decoder_am
$LN1247@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 899  :              )

  01766	66 85 c0	 test	 ax, ax
  01769	74 38		 je	 SHORT $LN38@Decoder_am
$LN1940@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0176b	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]

; 79   :     if (L_var1 > 0X00007fffL)

  0176e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01773	7e 0f		 jle	 SHORT $LN1259@Decoder_am

; 81   :         Overflow = 1;

  01775	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0177f	e9 2f 01 00 00	 jmp	 $LN1328@Decoder_am
$LN1259@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01784	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01789	7d 0f		 jge	 SHORT $LN1257@Decoder_am

; 86   :         Overflow = 1;

  0178b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01795	e9 19 01 00 00	 jmp	 $LN1328@Decoder_am
$LN1257@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 899  :              )

  0179a	66 85 c0	 test	 ax, ax
  0179d	0f 85 10 01 00
	00		 jne	 $LN1328@Decoder_am
$LN38@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  017a3	0f bf c7	 movsx	 eax, di
  017a6	05 00 d0 ff ff	 add	 eax, -12288		; ffffd000H

; 79   :     if (L_var1 > 0X00007fffL)

  017ab	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  017b0	7e 0c		 jle	 SHORT $LN1271@Decoder_am

; 81   :         Overflow = 1;

  017b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  017bc	eb 1f		 jmp	 SHORT $LN1941@Decoder_am
$LN1271@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  017be	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  017c3	7d 0f		 jge	 SHORT $LN1269@Decoder_am

; 86   :         Overflow = 1;

  017c5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  017cf	e9 a1 00 00 00	 jmp	 $LN37@Decoder_am
$LN1269@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 902  :            if ( sub (gain_pit, 12288) > 0)    /* if (gain_pit > 0.75) in Q14*/

  017d4	66 85 c0	 test	 ax, ax
  017d7	0f 8e 98 00 00
	00		 jle	 $LN37@Decoder_am
$LN1941@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  017dd	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  017e2	7e 33		 jle	 SHORT $LN1281@Decoder_am

; 81   :         Overflow = 1;

  017e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  017ee	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
$LN1287@Decoder_am:

; 381  :                 var_out = var1 >> var2;

  017f3	66 d1 f9	 sar	 cx, 1
  017f6	0f b7 c1	 movzx	 eax, cx
$LN1286@Decoder_am:

; 139  :     L_sum = (Word32) var1 + var2;

  017f9	98		 cwde
  017fa	05 00 30 00 00	 add	 eax, 12288		; 00003000H

; 79   :     if (L_var1 > 0X00007fffL)

  017ff	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01804	7e 4b		 jle	 SHORT $LN1311@Decoder_am

; 81   :         Overflow = 1;

  01806	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01810	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  01815	eb 55		 jmp	 SHORT $LN1308@Decoder_am
$LN1281@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01817	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0181c	7d 1d		 jge	 SHORT $LN1279@Decoder_am

; 87   :         var_out = MIN_16;

  0181e	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  01823	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0182d	0f bf c1	 movsx	 eax, cx
  01830	f7 d0		 not	 eax
  01832	d1 f8		 sar	 eax, 1
  01834	f7 d0		 not	 eax
  01836	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  01839	eb be		 jmp	 SHORT $LN1286@Decoder_am
$LN1279@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0183b	0f b7 c8	 movzx	 ecx, ax

; 375  :             if (var1 < 0)

  0183e	66 85 c0	 test	 ax, ax
  01841	79 b0		 jns	 SHORT $LN1287@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  01843	0f bf c1	 movsx	 eax, cx
  01846	f7 d0		 not	 eax
  01848	d1 f8		 sar	 eax, 1
  0184a	f7 d0		 not	 eax
  0184c	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  0184f	eb a8		 jmp	 SHORT $LN1286@Decoder_am
$LN1311@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01851	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01856	7d 11		 jge	 SHORT $LN1309@Decoder_am

; 86   :         Overflow = 1;

  01858	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  01862	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  01867	eb 03		 jmp	 SHORT $LN1308@Decoder_am
$LN1309@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  01869	0f b7 c0	 movzx	 eax, ax
$LN1308@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 903  :               gain_pit = add( shr( sub(gain_pit, 12288), 1 ), 12288 );

  0186c	0f b7 f8	 movzx	 edi, ax
  0186f	89 bd c4 fe ff
	ff		 mov	 DWORD PTR _gain_pit$[ebp], edi
$LN37@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01875	0f bf c7	 movsx	 eax, di
  01878	2d 99 39 00 00	 sub	 eax, 14745		; 00003999H

; 79   :     if (L_var1 > 0X00007fffL)

  0187d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01882	7e 0c		 jle	 SHORT $LN1323@Decoder_am

; 81   :         Overflow = 1;

  01884	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0188e	eb 18		 jmp	 SHORT $LN1942@Decoder_am
$LN1323@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01890	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01895	7d 0c		 jge	 SHORT $LN1321@Decoder_am

; 86   :         Overflow = 1;

  01897	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  018a1	eb 10		 jmp	 SHORT $LN1328@Decoder_am
$LN1321@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 907  :            if ( sub (gain_pit, 14745) > 0)    /* if (gain_pit > 0.90) in Q14*/

  018a3	66 85 c0	 test	 ax, ax
  018a6	7e 0b		 jle	 SHORT $LN1328@Decoder_am
$LN1942@Decoder_am:

; 908  :            {
; 909  :               gain_pit = 14745;                                 move16 ();

  018a8	bf 99 39 00 00	 mov	 edi, 14745		; 00003999H
  018ad	89 bd c4 fe ff
	ff		 mov	 DWORD PTR _gain_pit$[ebp], edi
$LN1328@Decoder_am:

; 910  :            }
; 911  :         }
; 912  : 
; 913  :         /*-------------------------------------------------------*
; 914  :          *  Calculate CB mixed gain                              *
; 915  :          *-------------------------------------------------------*/
; 916  :         Int_lsf(prev_lsf, st->lsfState->past_lsf_q, i_subfr, lsf_i); 

  018b3	8b 93 f4 01 00
	00		 mov	 edx, DWORD PTR [ebx+500]
  018b9	8d 45 d4	 lea	 eax, DWORD PTR _lsf_i$[ebp]
  018bc	50		 push	 eax
  018bd	ff b5 9c fe ff
	ff		 push	 DWORD PTR _i_subfr$1$[ebp]
  018c3	83 c2 14	 add	 edx, 20			; 00000014H
  018c6	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _prev_lsf$[ebp]
  018cc	e8 00 00 00 00	 call	 _Int_lsf

; 917  :         gain_code_mix = Cb_gain_average(
; 918  :             st->Cb_gain_averState, mode, gain_code, 
; 919  :             lsf_i, st->lsp_avg_st->lsp_meanSave, bfi, 
; 920  :             st->prev_bf, pdfi, st->prev_pdf,  
; 921  :             st->inBackgroundNoise, st->voicedHangover);         move16 ();

  018d1	0f b7 83 d0 01
	00 00		 movzx	 eax, WORD PTR [ebx+464]
  018d8	50		 push	 eax
  018d9	0f b7 83 ce 01
	00 00		 movzx	 eax, WORD PTR [ebx+462]
  018e0	8b b5 c0 fe ff
	ff		 mov	 esi, DWORD PTR _gain_code$[ebp]
  018e6	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  018ec	8b 8b ec 01 00
	00		 mov	 ecx, DWORD PTR [ebx+492]
  018f2	50		 push	 eax
  018f3	0f b7 83 b6 01
	00 00		 movzx	 eax, WORD PTR [ebx+438]
  018fa	50		 push	 eax
  018fb	ff b5 8c fe ff
	ff		 push	 DWORD PTR _pdfi$1$[ebp]
  01901	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  01908	50		 push	 eax
  01909	ff b5 cc fe ff
	ff		 push	 DWORD PTR _bfi$1$[ebp]
  0190f	8d 45 d4	 lea	 eax, DWORD PTR _lsf_i$[ebp]
  01912	ff b3 f0 01 00
	00		 push	 DWORD PTR [ebx+496]
  01918	50		 push	 eax
  01919	56		 push	 esi
  0191a	e8 00 00 00 00	 call	 _Cb_gain_average
  0191f	0f b7 c0	 movzx	 eax, ax
  01922	83 c4 2c	 add	 esp, 44			; 0000002cH
  01925	89 85 ac fe ff
	ff		 mov	 DWORD PTR _gain_code_mix$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0192b	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  01931	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01936	7e 0c		 jle	 SHORT $LN1339@Decoder_am

; 81   :         Overflow = 1;

  01938	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01942	eb 45		 jmp	 SHORT $LN1943@Decoder_am
$LN1339@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01944	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01949	7d 39		 jge	 SHORT $LN1337@Decoder_am

; 86   :         Overflow = 1;

  0194b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2007@Decoder_am:
  01955	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
$LN1354@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  0195b	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01961	7e 76		 jle	 SHORT $LN1363@Decoder_am

; 81   :         Overflow = 1;

  01963	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN34@Decoder_am:

; 375  :             if (var1 < 0)

  0196d	66 85 ff	 test	 di, di
  01970	0f 89 92 00 00
	00		 jns	 $LN1373@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  01976	0f bf c7	 movsx	 eax, di
  01979	f7 d0		 not	 eax
  0197b	d1 f8		 sar	 eax, 1
  0197d	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0197f	e9 8a 00 00 00	 jmp	 $LN2034@Decoder_am
$LN1337@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 925  :         if ((sub(mode, MR67) > 0) && (sub(mode, MR102) != 0) ) 

  01984	66 85 c0	 test	 ax, ax
  01987	7e cc		 jle	 SHORT $LN2007@Decoder_am
$LN1943@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01989	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
  0198f	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01995	7e 15		 jle	 SHORT $LN1349@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 928  :            gain_code_mix = gain_code;                 move16 ();

  01997	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  0199a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 928  :            gain_code_mix = gain_code;                 move16 ();

  019a4	89 85 ac fe ff
	ff		 mov	 DWORD PTR _gain_code_mix$1$[ebp], eax
  019aa	eb af		 jmp	 SHORT $LN1354@Decoder_am
$LN1349@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  019ac	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  019b2	7d 15		 jge	 SHORT $LN1347@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 928  :            gain_code_mix = gain_code;                 move16 ();

  019b4	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  019b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 928  :            gain_code_mix = gain_code;                 move16 ();

  019c1	89 85 ac fe ff
	ff		 mov	 DWORD PTR _gain_code_mix$1$[ebp], eax
  019c7	eb 92		 jmp	 SHORT $LN1354@Decoder_am
$LN1347@Decoder_am:

; 925  :         if ((sub(mode, MR67) > 0) && (sub(mode, MR102) != 0) ) 

  019c9	66 85 c9	 test	 cx, cx
  019cc	74 8d		 je	 SHORT $LN1354@Decoder_am

; 928  :            gain_code_mix = gain_code;                 move16 ();

  019ce	0f b7 c6	 movzx	 eax, si
  019d1	89 85 ac fe ff
	ff		 mov	 DWORD PTR _gain_code_mix$1$[ebp], eax
  019d7	eb 82		 jmp	 SHORT $LN1354@Decoder_am
$LN1363@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  019d9	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  019df	7d 14		 jge	 SHORT $LN1361@Decoder_am

; 86   :         Overflow = 1;

  019e1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 939  :            tmp_shift = 1;                                       move16 ();

  019eb	b8 01 00 00 00	 mov	 eax, 1
  019f0	0f b7 cf	 movzx	 ecx, di

; 940  :         }
; 941  :         else       /* MR122 */

  019f3	eb 24		 jmp	 SHORT $LN2033@Decoder_am
$LN1361@Decoder_am:

; 929  :         }
; 930  :         
; 931  :         /*-------------------------------------------------------*
; 932  :          * - Find the total excitation.                          *
; 933  :          * - Find synthesis speech corresponding to st->exc[].   *
; 934  :          *-------------------------------------------------------*/
; 935  :         test ();
; 936  :         if (sub(mode, MR102) <= 0) /* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/

  019f5	66 85 c9	 test	 cx, cx
  019f8	0f 8f 6f ff ff
	ff		 jg	 $LN34@Decoder_am

; 937  :         {
; 938  :            pitch_fac = gain_pit;                                move16 ();

  019fe	0f b7 cf	 movzx	 ecx, di

; 939  :            tmp_shift = 1;                                       move16 ();

  01a01	b8 01 00 00 00	 mov	 eax, 1

; 940  :         }
; 941  :         else       /* MR122 */

  01a06	eb 11		 jmp	 SHORT $LN2033@Decoder_am
$LN1373@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  01a08	66 8b c7	 mov	 ax, di
  01a0b	66 d1 f8	 sar	 ax, 1
$LN2034@Decoder_am:
  01a0e	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 943  :            pitch_fac = shr (gain_pit, 1);                       move16 ();

  01a11	0f b7 c8	 movzx	 ecx, ax

; 944  :            tmp_shift = 2;                                       move16 ();

  01a14	b8 02 00 00 00	 mov	 eax, 2
$LN2033@Decoder_am:

; 945  :         }
; 946  : 
; 947  :         /* copy unscaled LTP excitation to exc_enhanced (used in phase
; 948  :          * dispersion below) and compute total excitation for LTP feedback
; 949  :          */
; 950  :         for (i = 0; i < L_SUBFR; i++)

  01a19	0f bf de	 movsx	 ebx, si
  01a1c	33 f6		 xor	 esi, esi
  01a1e	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _pitch_fac$1$[ebp], ecx
  01a24	0f bf c9	 movsx	 ecx, cx
  01a27	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _tmp_shift$1$[ebp], eax
  01a2d	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv6383[ebp], ecx
  01a33	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  01a36	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL32@Decoder_am:

; 951  :         {
; 952  :            exc_enhanced[i] = st->exc[i];                        move16 ();

  01a40	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _st$GSCopy$1$[ebp]
  01a46	8b 80 84 01 00
	00		 mov	 eax, DWORD PTR [eax+388]
  01a4c	0f b7 04 06	 movzx	 eax, WORD PTR [esi+eax]
  01a50	66 89 84 35 20
	ff ff ff	 mov	 WORD PTR _exc_enhanced$[ebp+esi], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  01a58	98		 cwde
  01a59	0f af c1	 imul	 eax, ecx

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  01a5c	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  01a61	74 05		 je	 SHORT $LN1399@Decoder_am

; 488  :     {
; 489  :         L_var_out *= 2;

  01a63	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]

; 490  :     }
; 491  :     else

  01a66	eb 0f		 jmp	 SHORT $LN1398@Decoder_am
$LN1399@Decoder_am:

; 492  :     {
; 493  :         Overflow = 1;

  01a68	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  01a72	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN1398@Decoder_am:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  01a77	0f bf 44 35 84	 movsx	 eax, WORD PTR _code$[ebp+esi]
  01a7c	0f af c3	 imul	 eax, ebx

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  01a7f	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  01a84	74 04		 je	 SHORT $LN1405@Decoder_am

; 488  :     {
; 489  :         L_var_out *= 2;

  01a86	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  01a88	eb 0f		 jmp	 SHORT $LN1404@Decoder_am
$LN1405@Decoder_am:

; 492  :     {
; 493  :         Overflow = 1;

  01a8a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  01a94	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN1404@Decoder_am:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  01a99	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01a9c	33 c2		 xor	 eax, edx
  01a9e	78 1d		 js	 SHORT $LN1408@Decoder_am

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  01aa0	8b c1		 mov	 eax, ecx
  01aa2	33 c2		 xor	 eax, edx
  01aa4	79 17		 jns	 SHORT $LN1408@Decoder_am

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  01aa6	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  01aa8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01ab2	85 d2		 test	 edx, edx
  01ab4	0f 98 c1	 sets	 cl
  01ab7	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN1408@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 961  :            L_temp = L_shl (L_temp, tmp_shift);                   /* Q16 */

  01abd	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _tmp_shift$1$[ebp]
  01ac3	0f b7 c2	 movzx	 eax, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1344 :     if (var2 <= 0)

  01ac6	66 85 d2	 test	 dx, dx
  01ac9	7f 4d		 jg	 SHORT $LL1988@Decoder_am

; 1345 :     {
; 1346 :         if (var2 < -32)

  01acb	66 83 fa e0	 cmp	 dx, -32			; ffffffe0H
  01acf	ba e0 ff ff ff	 mov	 edx, -32		; ffffffe0H
  01ad4	0f 4c c2	 cmovl	 eax, edx

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  01ad7	f7 d8		 neg	 eax
  01ad9	0f b7 c0	 movzx	 eax, ax

; 1420 :     if (var2 < 0)

  01adc	66 85 c0	 test	 ax, ax
  01adf	79 13		 jns	 SHORT $LN1429@Decoder_am

; 1421 :     {
; 1422 :         if (var2 < -32)

  01ae1	66 3b c2	 cmp	 ax, dx
  01ae4	0f 4c c2	 cmovl	 eax, edx

; 1424 :         L_var_out = L_shl (L_var1, -var2);

  01ae7	f7 d8		 neg	 eax
  01ae9	8b d0		 mov	 edx, eax
  01aeb	e8 00 00 00 00	 call	 _L_shl
  01af0	8b d0		 mov	 edx, eax

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  01af2	eb 56		 jmp	 SHORT $LN1415@Decoder_am
$LN1429@Decoder_am:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  01af4	66 83 f8 1f	 cmp	 ax, 31			; 0000001fH
  01af8	7c 0a		 jl	 SHORT $LN1426@Decoder_am

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  01afa	33 d2		 xor	 edx, edx
  01afc	85 c9		 test	 ecx, ecx
  01afe	0f 99 c2	 setns	 dl
  01b01	4a		 dec	 edx

; 1434 :         }
; 1435 :         else

  01b02	eb 46		 jmp	 SHORT $LN1415@Decoder_am
$LN1426@Decoder_am:

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01b04	8b d1		 mov	 edx, ecx
  01b06	85 c9		 test	 ecx, ecx
  01b08	8a c8		 mov	 cl, al
  01b0a	79 08		 jns	 SHORT $LN1424@Decoder_am
  01b0c	f7 d2		 not	 edx
  01b0e	d3 fa		 sar	 edx, cl
  01b10	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  01b12	eb 36		 jmp	 SHORT $LN1415@Decoder_am
$LN1424@Decoder_am:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01b14	d3 fa		 sar	 edx, cl

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  01b16	eb 32		 jmp	 SHORT $LN1415@Decoder_am
$LL1988@Decoder_am:

; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  01b18	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  01b1e	7f 1b		 jg	 SHORT $LN1835@Decoder_am

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01b20	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  01b26	7c 0c		 jl	 SHORT $LN1836@Decoder_am

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  01b28	03 c9		 add	 ecx, ecx
  01b2a	48		 dec	 eax

; 1373 :             L_var_out = L_var1;

  01b2b	8b d1		 mov	 edx, ecx
  01b2d	66 85 c0	 test	 ax, ax
  01b30	7f e6		 jg	 SHORT $LL1988@Decoder_am

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01b32	eb 16		 jmp	 SHORT $LN1415@Decoder_am
$LN1836@Decoder_am:

; 1368 :                     L_var_out = MIN_32;

  01b34	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  01b39	eb 05		 jmp	 SHORT $LN2035@Decoder_am
$LN1835@Decoder_am:

; 1360 :                 L_var_out = MAX_32;

  01b3b	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN2035@Decoder_am:

; 1358 :             {
; 1359 :                 Overflow = 1;

  01b40	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN1415@Decoder_am:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  01b4a	8d 8a 00 80 00
	00		 lea	 ecx, DWORD PTR [edx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01b50	85 d2		 test	 edx, edx
  01b52	78 1d		 js	 SHORT $LN1434@Decoder_am

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  01b54	8b c1		 mov	 eax, ecx
  01b56	33 c2		 xor	 eax, edx
  01b58	79 17		 jns	 SHORT $LN1434@Decoder_am

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  01b5a	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  01b5c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01b66	85 d2		 test	 edx, edx
  01b68	0f 98 c1	 sets	 cl
  01b6b	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN1434@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 962  :            st->exc[i] = round (L_temp);                         move16 (); 

  01b71	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _st$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  01b77	c1 f9 10	 sar	 ecx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 962  :            st->exc[i] = round (L_temp);                         move16 (); 

  01b7a	8b 80 84 01 00
	00		 mov	 eax, DWORD PTR [eax+388]
  01b80	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx
  01b84	83 c6 02	 add	 esi, 2
  01b87	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR tv6383[ebp]
  01b8d	4f		 dec	 edi
  01b8e	0f 85 ac fe ff
	ff		 jne	 $LL32@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 141  :   state->lockFull = 0;

  01b94	8b 9d bc fe ff
	ff		 mov	 ebx, DWORD PTR _st$GSCopy$1$[ebp]
  01b9a	33 c9		 xor	 ecx, ecx
  01b9c	8b 83 04 02 00
	00		 mov	 eax, DWORD PTR [ebx+516]
  01ba2	66 89 48 0e	 mov	 WORD PTR [eax+14], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  01ba6	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
  01bac	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01bb2	7e 0c		 jle	 SHORT $LN1461@Decoder_am

; 81   :         Overflow = 1;

  01bb4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01bbe	eb 19		 jmp	 SHORT $LN1946@Decoder_am
$LN1461@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01bc0	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  01bc6	7d 0c		 jge	 SHORT $LN1459@Decoder_am

; 86   :         Overflow = 1;

  01bc8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01bd2	eb 05		 jmp	 SHORT $LN1946@Decoder_am
$LN1459@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 976  :              bfi != 0 )

  01bd4	66 85 c9	 test	 cx, cx
  01bd7	74 5c		 je	 SHORT $LN28@Decoder_am
$LN1946@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01bd9	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  01bdc	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01be1	7e 0c		 jle	 SHORT $LN1471@Decoder_am

; 81   :         Overflow = 1;

  01be3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01bed	eb 18		 jmp	 SHORT $LN1947@Decoder_am
$LN1471@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01bef	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01bf4	7d 0c		 jge	 SHORT $LN1469@Decoder_am

; 86   :         Overflow = 1;

  01bf6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01c00	eb 05		 jmp	 SHORT $LN1947@Decoder_am
$LN1469@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 976  :              bfi != 0 )

  01c02	66 85 c0	 test	 ax, ax
  01c05	74 2e		 je	 SHORT $LN28@Decoder_am
$LN1947@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01c07	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  01c0a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01c0f	7e 0c		 jle	 SHORT $LN1481@Decoder_am

; 81   :         Overflow = 1;

  01c11	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01c1b	eb 70		 jmp	 SHORT $LN1496@Decoder_am
$LN1481@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01c1d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01c22	7d 0c		 jge	 SHORT $LN1479@Decoder_am

; 86   :         Overflow = 1;

  01c24	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01c2e	eb 5d		 jmp	 SHORT $LN1496@Decoder_am
$LN1479@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 976  :              bfi != 0 )

  01c30	66 85 c0	 test	 ax, ax
  01c33	75 58		 jne	 SHORT $LN1496@Decoder_am
$LN28@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01c35	0f bf 83 d0 01
	00 00		 movsx	 eax, WORD PTR [ebx+464]
  01c3c	83 e8 03	 sub	 eax, 3

; 79   :     if (L_var1 > 0X00007fffL)

  01c3f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01c44	7e 0c		 jle	 SHORT $LN1491@Decoder_am

; 81   :         Overflow = 1;

  01c46	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01c50	eb 18		 jmp	 SHORT $LN1948@Decoder_am
$LN1491@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01c52	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01c57	7d 0c		 jge	 SHORT $LN1489@Decoder_am

; 86   :         Overflow = 1;

  01c59	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01c63	eb 28		 jmp	 SHORT $LN1496@Decoder_am
$LN1489@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 976  :              bfi != 0 )

  01c65	66 85 c0	 test	 ax, ax
  01c68	7e 23		 jle	 SHORT $LN1496@Decoder_am
$LN1948@Decoder_am:
  01c6a	66 83 bb ce 01
	00 00 00	 cmp	 WORD PTR [ebx+462], 0
  01c72	74 19		 je	 SHORT $LN1496@Decoder_am
  01c74	66 83 bd cc fe
	ff ff 00	 cmp	 WORD PTR _bfi$1$[ebp], 0
  01c7c	74 0f		 je	 SHORT $LN1496@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 129  :   state->lockFull = 1;

  01c7e	8b 83 04 02 00
	00		 mov	 eax, DWORD PTR [ebx+516]
  01c84	b9 01 00 00 00	 mov	 ecx, 1
  01c89	66 89 48 0e	 mov	 WORD PTR [eax+14], cx
$LN1496@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 985  :                 pitch_fac, tmp_shift);       

  01c8d	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _tmp_shift$1$[ebp]
  01c93	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _gain_pit$[ebp]
  01c99	8b 8b 04 02 00
	00		 mov	 ecx, DWORD PTR [ebx+516]
  01c9f	50		 push	 eax
  01ca0	ff b5 a4 fe ff
	ff		 push	 DWORD PTR _pitch_fac$1$[ebp]
  01ca6	8d 45 84	 lea	 eax, DWORD PTR _code$[ebp]
  01ca9	50		 push	 eax
  01caa	52		 push	 edx
  01cab	ff b5 ac fe ff
	ff		 push	 DWORD PTR _gain_code_mix$1$[ebp]
  01cb1	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _mode$GSCopy$1$[ebp]
  01cb7	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _exc_enhanced$[ebp]
  01cbd	50		 push	 eax
  01cbe	e8 00 00 00 00	 call	 _ph_disp
  01cc3	83 c4 18	 add	 esp, 24			; 00000018H
  01cc6	8d b5 20 ff ff
	ff		 lea	 esi, DWORD PTR _exc_enhanced$[ebp]

; 986  :         
; 987  :         /*-------------------------------------------------------*
; 988  :          * - The Excitation control module are active during BFI.*
; 989  :          * - Conceal drops in signal energy if in bg noise.      *
; 990  :          *-------------------------------------------------------*/
; 991  : 
; 992  :         L_temp = 0;                                   move32 ();

  01ccc	33 d2		 xor	 edx, edx
  01cce	8d 7a 28	 lea	 edi, DWORD PTR [edx+40]
$LL27@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  01cd1	0f bf 06	 movsx	 eax, WORD PTR [esi]
  01cd4	0f af c0	 imul	 eax, eax

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  01cd7	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  01cdc	74 04		 je	 SHORT $LN1503@Decoder_am

; 488  :     {
; 489  :         L_var_out *= 2;

  01cde	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  01ce0	eb 0f		 jmp	 SHORT $LN1502@Decoder_am
$LN1503@Decoder_am:

; 492  :     {
; 493  :         Overflow = 1;

  01ce2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  01cec	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN1502@Decoder_am:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  01cf1	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  01cf4	33 c2		 xor	 eax, edx
  01cf6	78 1d		 js	 SHORT $LN1506@Decoder_am

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  01cf8	8b c1		 mov	 eax, ecx
  01cfa	33 c2		 xor	 eax, edx
  01cfc	79 17		 jns	 SHORT $LN1506@Decoder_am

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  01cfe	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  01d00	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  01d0a	85 d2		 test	 edx, edx
  01d0c	0f 98 c1	 sets	 cl
  01d0f	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN1506@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 993  :         for (i = 0; i < L_SUBFR; i++)

  01d15	83 c6 02	 add	 esi, 2

; 994  :         {
; 995  :             L_temp = L_mac (L_temp, exc_enhanced[i], exc_enhanced[i] );

  01d18	8b d1		 mov	 edx, ecx
  01d1a	4f		 dec	 edi
  01d1b	75 b4		 jne	 SHORT $LL27@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  01d1d	85 c9		 test	 ecx, ecx
  01d1f	79 08		 jns	 SHORT $LN1511@Decoder_am

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01d21	f7 d1		 not	 ecx
  01d23	d1 f9		 sar	 ecx, 1
  01d25	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  01d27	eb 02		 jmp	 SHORT $LN1510@Decoder_am
$LN1511@Decoder_am:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01d29	d1 f9		 sar	 ecx, 1
$LN1510@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 999  :         L_temp = sqrt_l_exp(L_temp, &temp); move32 (); /* function result */

  01d2b	8d 95 84 fe ff
	ff		 lea	 edx, DWORD PTR _temp$[ebp]
  01d31	e8 00 00 00 00	 call	 _sqrt_l_exp
  01d36	8b f0		 mov	 esi, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  01d38	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _temp$[ebp]
  01d3e	66 85 c0	 test	 ax, ax
  01d41	79 09		 jns	 SHORT $LN1533@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  01d43	98		 cwde
  01d44	f7 d0		 not	 eax
  01d46	d1 f8		 sar	 eax, 1
  01d48	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  01d4a	eb 03		 jmp	 SHORT $LN2036@Decoder_am
$LN1533@Decoder_am:

; 381  :                 var_out = var1 >> var2;

  01d4c	66 d1 f8	 sar	 ax, 1
$LN2036@Decoder_am:
  01d4f	0f b7 c0	 movzx	 eax, ax

; 139  :     L_sum = (Word32) var1 + var2;

  01d52	98		 cwde
  01d53	83 c0 0f	 add	 eax, 15			; 0000000fH

; 79   :     if (L_var1 > 0X00007fffL)

  01d56	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01d5b	7e 19		 jle	 SHORT $LN1557@Decoder_am

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  01d5d	33 c0		 xor	 eax, eax

; 81   :         Overflow = 1;

  01d5f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  01d69	85 f6		 test	 esi, esi
  01d6b	0f 99 c0	 setns	 al
  01d6e	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]

; 1434 :         }
; 1435 :         else

  01d71	e9 a9 00 00 00	 jmp	 $LN1562@Decoder_am
$LN1557@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01d76	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01d7b	7d 0c		 jge	 SHORT $LN1555@Decoder_am

; 86   :         Overflow = 1;

  01d7d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01d87	eb 0e		 jmp	 SHORT $LN1966@Decoder_am
$LN1555@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1000 :         L_temp = L_shr(L_temp, add( shr(temp, 1), 15));

  01d89	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1420 :     if (var2 < 0)

  01d8c	66 85 c0	 test	 ax, ax
  01d8f	79 6c		 jns	 SHORT $LN1568@Decoder_am

; 1421 :     {
; 1422 :         if (var2 < -32)

  01d91	66 83 f8 e0	 cmp	 ax, -32			; ffffffe0H
  01d95	7d 05		 jge	 SHORT $LN1567@Decoder_am
$LN1966@Decoder_am:

; 1423 :             var2 = -32;

  01d97	b9 e0 ff ff ff	 mov	 ecx, -32		; ffffffe0H
$LN1567@Decoder_am:

; 1424 :         L_var_out = L_shl (L_var1, -var2);

  01d9c	f7 d9		 neg	 ecx
  01d9e	0f b7 c1	 movzx	 eax, cx

; 1344 :     if (var2 <= 0)

  01da1	66 85 c0	 test	 ax, ax
  01da4	7f 1b		 jg	 SHORT $LL1990@Decoder_am

; 1345 :     {
; 1346 :         if (var2 < -32)

  01da6	66 83 f8 e0	 cmp	 ax, -32			; ffffffe0H
  01daa	bf e0 ff ff ff	 mov	 edi, -32		; ffffffe0H

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  01daf	8b ce		 mov	 ecx, esi
  01db1	0f 4c c7	 cmovl	 eax, edi
  01db4	f7 d8		 neg	 eax
  01db6	8b d0		 mov	 edx, eax
  01db8	e8 00 00 00 00	 call	 _L_shr
  01dbd	8b f0		 mov	 esi, eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  01dbf	eb 5e		 jmp	 SHORT $LN1562@Decoder_am
$LL1990@Decoder_am:

; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  01dc1	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  01dc7	7f 23		 jg	 SHORT $LN1839@Decoder_am

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01dc9	81 fe 00 00 00
	c0		 cmp	 esi, -1073741824	; c0000000H
  01dcf	7c 0a		 jl	 SHORT $LN1840@Decoder_am

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  01dd1	48		 dec	 eax
  01dd2	03 f6		 add	 esi, esi
  01dd4	66 85 c0	 test	 ax, ax
  01dd7	7f e8		 jg	 SHORT $LL1990@Decoder_am

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  01dd9	eb 44		 jmp	 SHORT $LN1562@Decoder_am
$LN1840@Decoder_am:

; 1366 :                 {
; 1367 :                     Overflow = 1;

  01ddb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1368 :                     L_var_out = MIN_32;

  01de5	be 00 00 00 80	 mov	 esi, -2147483648	; 80000000H
  01dea	eb 33		 jmp	 SHORT $LN1562@Decoder_am
$LN1839@Decoder_am:

; 1358 :             {
; 1359 :                 Overflow = 1;

  01dec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1360 :                 L_var_out = MAX_32;

  01df6	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  01dfb	eb 22		 jmp	 SHORT $LN1562@Decoder_am
$LN1568@Decoder_am:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  01dfd	66 83 f8 1f	 cmp	 ax, 31			; 0000001fH
  01e01	7c 0c		 jl	 SHORT $LN1565@Decoder_am

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  01e03	33 c0		 xor	 eax, eax
  01e05	85 f6		 test	 esi, esi
  01e07	0f 99 c0	 setns	 al
  01e0a	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]

; 1434 :         }
; 1435 :         else

  01e0d	eb 10		 jmp	 SHORT $LN1562@Decoder_am
$LN1565@Decoder_am:

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01e0f	8a c8		 mov	 cl, al
  01e11	85 f6		 test	 esi, esi
  01e13	79 08		 jns	 SHORT $LN1563@Decoder_am
  01e15	f7 d6		 not	 esi
  01e17	d3 fe		 sar	 esi, cl
  01e19	f7 d6		 not	 esi

; 1440 :             }
; 1441 :             else

  01e1b	eb 02		 jmp	 SHORT $LN1562@Decoder_am
$LN1563@Decoder_am:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01e1d	d3 fe		 sar	 esi, cl
$LN1562@Decoder_am:

; 1437 :             if (L_var1 < 0)

  01e1f	85 f6		 test	 esi, esi
  01e21	79 09		 jns	 SHORT $LN1583@Decoder_am

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  01e23	f7 d6		 not	 esi
  01e25	c1 fe 02	 sar	 esi, 2
  01e28	f7 d6		 not	 esi

; 1440 :             }
; 1441 :             else

  01e2a	eb 03		 jmp	 SHORT $LN1582@Decoder_am
$LN1583@Decoder_am:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  01e2c	c1 fe 02	 sar	 esi, 2
$LN1582@Decoder_am:

; 79   :     if (L_var1 > 0X00007fffL)

  01e2f	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _L_diff$1$[ebp]
  01e35	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  01e3b	7e 0c		 jle	 SHORT $LN1629@Decoder_am

; 81   :         Overflow = 1;

  01e3d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01e47	eb 19		 jmp	 SHORT $LN1949@Decoder_am
$LN1629@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01e49	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  01e4f	7d 0c		 jge	 SHORT $LN1627@Decoder_am

; 86   :         Overflow = 1;

  01e51	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01e5b	eb 05		 jmp	 SHORT $LN1949@Decoder_am
$LN1627@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1014 :                 st->prev_bf != 0) )

  01e5d	66 85 c9	 test	 cx, cx
  01e60	74 66		 je	 SHORT $LN23@Decoder_am
$LN1949@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01e62	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  01e65	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01e6a	7e 0c		 jle	 SHORT $LN1639@Decoder_am

; 81   :         Overflow = 1;

  01e6c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01e76	eb 18		 jmp	 SHORT $LN1950@Decoder_am
$LN1639@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01e78	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01e7d	7d 0c		 jge	 SHORT $LN1637@Decoder_am

; 86   :         Overflow = 1;

  01e7f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01e89	eb 05		 jmp	 SHORT $LN1950@Decoder_am
$LN1637@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1014 :                 st->prev_bf != 0) )

  01e8b	66 85 c0	 test	 ax, ax
  01e8e	74 38		 je	 SHORT $LN23@Decoder_am
$LN1950@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01e90	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  01e93	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01e98	7e 0f		 jle	 SHORT $LN1649@Decoder_am

; 81   :         Overflow = 1;

  01e9a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01ea4	e9 05 01 00 00	 jmp	 $LN2005@Decoder_am
$LN1649@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01ea9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01eae	7d 0f		 jge	 SHORT $LN1647@Decoder_am

; 86   :         Overflow = 1;

  01eb0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01eba	e9 ef 00 00 00	 jmp	 $LN2005@Decoder_am
$LN1647@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1014 :                 st->prev_bf != 0) )

  01ebf	66 85 c0	 test	 ax, ax
  01ec2	0f 85 e6 00 00
	00		 jne	 $LN2005@Decoder_am
$LN23@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01ec8	0f b7 8b d0 01
	00 00		 movzx	 ecx, WORD PTR [ebx+464]
  01ecf	0f bf c1	 movsx	 eax, cx
  01ed2	83 e8 05	 sub	 eax, 5

; 79   :     if (L_var1 > 0X00007fffL)

  01ed5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01eda	7e 0c		 jle	 SHORT $LN1659@Decoder_am

; 81   :         Overflow = 1;

  01edc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01ee6	eb 1f		 jmp	 SHORT $LN1951@Decoder_am
$LN1659@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01ee8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01eed	7d 0f		 jge	 SHORT $LN1657@Decoder_am

; 86   :         Overflow = 1;

  01eef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01ef9	e9 b0 00 00 00	 jmp	 $LN2005@Decoder_am
$LN1657@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1014 :                 st->prev_bf != 0) )

  01efe	66 85 c0	 test	 ax, ax
  01f01	0f 8e a7 00 00
	00		 jle	 $LN2005@Decoder_am
$LN1951@Decoder_am:
  01f07	66 83 bb ce 01
	00 00 00	 cmp	 WORD PTR [ebx+462], 0
  01f0f	0f 84 ec 00 00
	00		 je	 $LN19@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01f15	0f bf 83 b8 01
	00 00		 movsx	 eax, WORD PTR [ebx+440]
  01f1c	83 e8 04	 sub	 eax, 4

; 79   :     if (L_var1 > 0X00007fffL)

  01f1f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01f24	7e 0c		 jle	 SHORT $LN1669@Decoder_am

; 81   :         Overflow = 1;

  01f26	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01f30	eb 7c		 jmp	 SHORT $LN2005@Decoder_am
$LN1669@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01f32	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01f37	7d 0c		 jge	 SHORT $LN1667@Decoder_am

; 86   :         Overflow = 1;

  01f39	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01f43	eb 05		 jmp	 SHORT $LN1952@Decoder_am
$LN1667@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1014 :                 st->prev_bf != 0) )

  01f45	66 85 c0	 test	 ax, ax
  01f48	79 64		 jns	 SHORT $LN2005@Decoder_am
$LN1952@Decoder_am:
  01f4a	8b bd 8c fe ff
	ff		 mov	 edi, DWORD PTR _pdfi$1$[ebp]
  01f50	66 85 ff	 test	 di, di
  01f53	74 0a		 je	 SHORT $LN21@Decoder_am
  01f55	66 83 bb b6 01
	00 00 00	 cmp	 WORD PTR [ebx+438], 0
  01f5d	75 16		 jne	 SHORT $LN2006@Decoder_am
$LN21@Decoder_am:
  01f5f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
  01f65	66 85 d2	 test	 dx, dx
  01f68	75 11		 jne	 SHORT $LN22@Decoder_am
  01f6a	66 39 93 b4 01
	00 00		 cmp	 WORD PTR [ebx+436], dx
  01f71	74 41		 je	 SHORT $LN24@Decoder_am
  01f73	eb 06		 jmp	 SHORT $LN22@Decoder_am
$LN2006@Decoder_am:
  01f75	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
$LN22@Decoder_am:

; 1015 :         {
; 1016 :            carefulFlag = 0;                          move32 ();

  01f7b	33 c0		 xor	 eax, eax

; 1017 :            test (); test ();           
; 1018 :            if ( pdfi != 0 && bfi == 0 )       

  01f7d	66 85 ff	 test	 di, di
  01f80	74 0b		 je	 SHORT $LN1680@Decoder_am
  01f82	66 85 d2	 test	 dx, dx
  01f85	ba 01 00 00 00	 mov	 edx, 1
  01f8a	0f 44 c2	 cmove	 eax, edx
$LN1680@Decoder_am:

; 1019 :            {
; 1020 :               carefulFlag = 1;                       move16 ();
; 1021 :            }
; 1022 : 
; 1023 :            Ex_ctrl(exc_enhanced,     
; 1024 :                    excEnergy,
; 1025 :                    st->excEnergyHist,
; 1026 :                    st->voicedHangover,
; 1027 :                    st->prev_bf,
; 1028 :                    carefulFlag);

  01f8d	50		 push	 eax
  01f8e	0f b7 83 b4 01
	00 00		 movzx	 eax, WORD PTR [ebx+436]
  01f95	8b d6		 mov	 edx, esi
  01f97	50		 push	 eax
  01f98	51		 push	 ecx
  01f99	8d 83 ba 01 00
	00		 lea	 eax, DWORD PTR [ebx+442]
  01f9f	50		 push	 eax
  01fa0	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  01fa6	e8 00 00 00 00	 call	 _Ex_ctrl
  01fab	83 c4 10	 add	 esp, 16			; 00000010H
$LN2005@Decoder_am:
  01fae	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _bfi$1$[ebp]
$LN24@Decoder_am:

; 1034 :              sub(st->state, 4) < 0 )

  01fb4	66 83 bb ce 01
	00 00 00	 cmp	 WORD PTR [ebx+462], 0
  01fbc	74 43		 je	 SHORT $LN19@Decoder_am
  01fbe	66 85 d2	 test	 dx, dx
  01fc1	75 09		 jne	 SHORT $LN18@Decoder_am
  01fc3	66 39 93 b4 01
	00 00		 cmp	 WORD PTR [ebx+436], dx
  01fca	74 35		 je	 SHORT $LN19@Decoder_am
$LN18@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  01fcc	0f bf 83 b8 01
	00 00		 movsx	 eax, WORD PTR [ebx+440]
  01fd3	83 e8 04	 sub	 eax, 4

; 79   :     if (L_var1 > 0X00007fffL)

  01fd6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  01fdb	7e 0c		 jle	 SHORT $LN1695@Decoder_am

; 81   :         Overflow = 1;

  01fdd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  01fe7	eb 18		 jmp	 SHORT $LN19@Decoder_am
$LN1695@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  01fe9	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  01fee	7d 0c		 jge	 SHORT $LN1693@Decoder_am

; 86   :         Overflow = 1;

  01ff0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  01ffa	eb 7c		 jmp	 SHORT $LN1702@Decoder_am
$LN1693@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1034 :              sub(st->state, 4) < 0 )

  01ffc	66 85 c0	 test	 ax, ax
  01fff	78 77		 js	 SHORT $LN1702@Decoder_am
$LN19@Decoder_am:

; 1035 :         { 
; 1036 :            ; /* do nothing! */
; 1037 :         }
; 1038 :         else
; 1039 :         {
; 1040 :            /* Update energy history for all modes */
; 1041 :            for (i = 0; i < 8; i++)
; 1042 :            {
; 1043 :               st->excEnergyHist[i] = st->excEnergyHist[i+1]; move16 ();

  02001	0f b7 83 bc 01
	00 00		 movzx	 eax, WORD PTR [ebx+444]
  02008	66 89 83 ba 01
	00 00		 mov	 WORD PTR [ebx+442], ax
  0200f	0f b7 83 be 01
	00 00		 movzx	 eax, WORD PTR [ebx+446]
  02016	66 89 83 bc 01
	00 00		 mov	 WORD PTR [ebx+444], ax
  0201d	0f b7 83 c0 01
	00 00		 movzx	 eax, WORD PTR [ebx+448]
  02024	66 89 83 be 01
	00 00		 mov	 WORD PTR [ebx+446], ax
  0202b	0f b7 83 c2 01
	00 00		 movzx	 eax, WORD PTR [ebx+450]
  02032	66 89 83 c0 01
	00 00		 mov	 WORD PTR [ebx+448], ax
  02039	0f b7 83 c4 01
	00 00		 movzx	 eax, WORD PTR [ebx+452]
  02040	66 89 83 c2 01
	00 00		 mov	 WORD PTR [ebx+450], ax
  02047	0f b7 83 c6 01
	00 00		 movzx	 eax, WORD PTR [ebx+454]
  0204e	66 89 83 c4 01
	00 00		 mov	 WORD PTR [ebx+452], ax
  02055	0f b7 83 c8 01
	00 00		 movzx	 eax, WORD PTR [ebx+456]
  0205c	66 89 83 c6 01
	00 00		 mov	 WORD PTR [ebx+454], ax
  02063	0f b7 83 ca 01
	00 00		 movzx	 eax, WORD PTR [ebx+458]
  0206a	66 89 83 c8 01
	00 00		 mov	 WORD PTR [ebx+456], ax

; 1044 :            }
; 1045 :            st->excEnergyHist[8] = excEnergy;   move16 ();

  02071	66 89 b3 ca 01
	00 00		 mov	 WORD PTR [ebx+458], si
$LN1702@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  02078	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _L_diff$1$[ebp]
  0207e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  02083	7e 0c		 jle	 SHORT $LN1713@Decoder_am

; 81   :         Overflow = 1;

  02085	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0208f	eb 14		 jmp	 SHORT $LN1953@Decoder_am
$LN1713@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  02091	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  02096	0f 8c b5 00 00
	00		 jl	 $LN13@Decoder_am
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1054 :         if (sub (pit_sharp, 16384) > 0)

  0209c	66 85 c0	 test	 ax, ax
  0209f	0f 8e ac 00 00
	00		 jle	 $LN13@Decoder_am
$LN1953@Decoder_am:

; 1055 :         {
; 1056 :            for (i = 0; i < L_SUBFR; i++)

  020a5	33 d2		 xor	 edx, edx
  020a7	8d 72 28	 lea	 esi, DWORD PTR [edx+40]
  020aa	8d 9b 00 00 00
	00		 npad	 6
$LL12@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  020b0	0f bf 8c 15 20
	ff ff ff	 movsx	 ecx, WORD PTR _exc_enhanced$[ebp+edx]
  020b8	0f bf 84 15 d0
	fe ff ff	 movsx	 eax, WORD PTR _excp$[ebp+edx]
  020c0	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  020c2	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  020c8	7e 11		 jle	 SHORT $LN1723@Decoder_am

; 81   :         Overflow = 1;

  020ca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  020d4	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  020d9	eb 1c		 jmp	 SHORT $LN1720@Decoder_am
$LN1723@Decoder_am:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  020db	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  020e1	7d 11		 jge	 SHORT $LN1721@Decoder_am

; 86   :         Overflow = 1;

  020e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  020ed	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  020f2	eb 03		 jmp	 SHORT $LN1720@Decoder_am
$LN1721@Decoder_am:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  020f4	0f b7 c1	 movzx	 eax, cx
$LN1720@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1058 :               excp[i] = add (excp[i], exc_enhanced[i]);              

  020f7	66 89 84 15 d0
	fe ff ff	 mov	 WORD PTR _excp$[ebp+edx], ax
  020ff	83 c2 02	 add	 edx, 2
  02102	4e		 dec	 esi
  02103	75 ab		 jne	 SHORT $LL12@Decoder_am

; 1059 :               move16 (); 
; 1060 :            }
; 1061 :            agc2 (exc_enhanced, excp, L_SUBFR);

  02105	51		 push	 ecx
  02106	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _excp$[ebp]
  0210c	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  02112	e8 00 00 00 00	 call	 _agc2

; 1062 :            Overflow = 0;                 move16 ();
; 1063 :            Syn_filt (Az, excp, &synth[i_subfr], L_SUBFR,
; 1064 :                      st->mem_syn, 0);

  02117	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _i_subfr$1$[ebp]
  0211d	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _excp$[ebp]
  02123	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _synth$GSCopy$1$[ebp]
  02129	0f bf f8	 movsx	 edi, ax
  0212c	8d 83 9c 01 00
	00		 lea	 eax, DWORD PTR [ebx+412]
  02132	6a 00		 push	 0
  02134	50		 push	 eax
  02135	89 35 00 00 00
	00		 mov	 DWORD PTR _Overflow, esi
  0213b	8d 34 79	 lea	 esi, DWORD PTR [ecx+edi*2]
  0213e	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _Az$1$[ebp]
  02144	6a 28		 push	 40			; 00000028H
  02146	56		 push	 esi
  02147	e8 00 00 00 00	 call	 _Syn_filt
  0214c	83 c4 14	 add	 esp, 20			; 00000014H

; 1065 :         }
; 1066 :         else

  0214f	eb 3c		 jmp	 SHORT $LN9@Decoder_am
$LN13@Decoder_am:

; 1067 :         {
; 1068 :            Overflow = 0;                 move16 ();
; 1069 :            Syn_filt (Az, exc_enhanced, &synth[i_subfr], L_SUBFR,
; 1070 :                      st->mem_syn, 0);

  02151	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _i_subfr$1$[ebp]
  02157	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _exc_enhanced$[ebp]
  0215d	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _synth$GSCopy$1$[ebp]
  02163	0f bf f8	 movsx	 edi, ax
  02166	8d 83 9c 01 00
	00		 lea	 eax, DWORD PTR [ebx+412]
  0216c	6a 00		 push	 0
  0216e	50		 push	 eax
  0216f	6a 28		 push	 40			; 00000028H
  02171	8d 34 79	 lea	 esi, DWORD PTR [ecx+edi*2]
  02174	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Overflow, 0
  0217e	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _Az$1$[ebp]
  02184	56		 push	 esi
  02185	e8 00 00 00 00	 call	 _Syn_filt
  0218a	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@Decoder_am:

; 1071 :         }
; 1072 : 
; 1073 :         test ();
; 1074 :         if (Overflow != 0)    /* Test for overflow */

  0218d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Overflow, 0
  02194	74 7e		 je	 SHORT $LN8@Decoder_am

; 1075 :         {
; 1076 :            for (i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++)

  02196	8b cb		 mov	 ecx, ebx
  02198	ba c2 00 00 00	 mov	 edx, 194		; 000000c2H
  0219d	8d 49 00	 npad	 3
$LL7@Decoder_am:

; 1078 :               st->old_exc[i] = shr(st->old_exc[i], 2);       move16 ();

  021a0	0f b7 01	 movzx	 eax, WORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  021a3	66 85 c0	 test	 ax, ax
  021a6	79 0a		 jns	 SHORT $LN1737@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  021a8	98		 cwde
  021a9	f7 d0		 not	 eax
  021ab	c1 f8 02	 sar	 eax, 2
  021ae	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  021b0	eb 04		 jmp	 SHORT $LN2037@Decoder_am
$LN1737@Decoder_am:

; 381  :                 var_out = var1 >> var2;

  021b2	66 c1 f8 02	 sar	 ax, 2
$LN2037@Decoder_am:
  021b6	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1078 :               st->old_exc[i] = shr(st->old_exc[i], 2);       move16 ();

  021b9	66 89 01	 mov	 WORD PTR [ecx], ax
  021bc	83 c1 02	 add	 ecx, 2
  021bf	4a		 dec	 edx
  021c0	75 de		 jne	 SHORT $LL7@Decoder_am

; 1079 :            }
; 1080 :            for (i = 0; i < L_SUBFR; i++)

  021c2	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _exc_enhanced$[ebp]
  021c8	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  021cd	8d 49 00	 npad	 3
$LL4@Decoder_am:

; 1082 :               exc_enhanced[i] = shr(exc_enhanced[i], 2);     move16 ();

  021d0	0f b7 01	 movzx	 eax, WORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  021d3	66 85 c0	 test	 ax, ax
  021d6	79 0a		 jns	 SHORT $LN1759@Decoder_am

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  021d8	98		 cwde
  021d9	f7 d0		 not	 eax
  021db	c1 f8 02	 sar	 eax, 2
  021de	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  021e0	eb 04		 jmp	 SHORT $LN2038@Decoder_am
$LN1759@Decoder_am:

; 381  :                 var_out = var1 >> var2;

  021e2	66 c1 f8 02	 sar	 ax, 2
$LN2038@Decoder_am:
  021e6	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1082 :               exc_enhanced[i] = shr(exc_enhanced[i], 2);     move16 ();

  021e9	66 89 01	 mov	 WORD PTR [ecx], ax
  021ec	83 c1 02	 add	 ecx, 2
  021ef	4a		 dec	 edx
  021f0	75 de		 jne	 SHORT $LL4@Decoder_am

; 1083 :            }
; 1084 :            Syn_filt(Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1);

  021f2	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _Az$1$[ebp]
  021f8	8d 83 9c 01 00
	00		 lea	 eax, DWORD PTR [ebx+412]
  021fe	6a 01		 push	 1
  02200	50		 push	 eax
  02201	6a 28		 push	 40			; 00000028H
  02203	56		 push	 esi
  02204	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _exc_enhanced$[ebp]
  0220a	e8 00 00 00 00	 call	 _Syn_filt
  0220f	83 c4 10	 add	 esp, 16			; 00000010H

; 1085 :         }
; 1086 :         else

  02212	eb 2b		 jmp	 SHORT $LN1780@Decoder_am
$LN8@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 60   :     for (i = 0; i < L; i++)

  02214	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _synth$GSCopy$1$[ebp]
  0221a	8d 8b 9c 01 00
	00		 lea	 ecx, DWORD PTR [ebx+412]
  02220	83 c2 3c	 add	 edx, 60			; 0000003cH
  02223	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  02228	8d 14 7a	 lea	 edx, DWORD PTR [edx+edi*2]
  0222b	eb 03 8d 49 00	 npad	 5
$LL1782@Decoder_am:

; 62   :         y[i] = x[i];            move16 (); 

  02230	66 8b 02	 mov	 ax, WORD PTR [edx]
  02233	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  02236	66 89 01	 mov	 WORD PTR [ecx], ax
  02239	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  0223c	4e		 dec	 esi
  0223d	75 f1		 jne	 SHORT $LL1782@Decoder_am
$LN1780@Decoder_am:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1104 :         st->old_T0 = T0;                move16 ();

  0223f	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _T0$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  02245	8d 73 50	 lea	 esi, DWORD PTR [ebx+80]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 1101 :         Az += MP1;                      move16 ();

  02248	83 85 a8 fe ff
	ff 16		 add	 DWORD PTR _Az$1$[ebp], 22 ; 00000016H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  0224f	b9 9a 00 00 00	 mov	 ecx, 154		; 0000009aH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 453  :     for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)

  02254	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _L_diff$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\copy.c

; 62   :         y[i] = x[i];            move16 (); 

  0225a	8b fb		 mov	 edi, ebx
  0225c	66 f3 a5	 rep movsw
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_amr.c

; 453  :     for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)

  0225f	8b b5 9c fe ff
	ff		 mov	 esi, DWORD PTR _i_subfr$1$[ebp]
  02265	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _subfrNr$1$[ebp]
  0226b	83 c6 28	 add	 esi, 40			; 00000028H

; 1104 :         st->old_T0 = T0;                move16 ();

  0226e	66 89 83 b2 01
	00 00		 mov	 WORD PTR [ebx+434], ax
  02275	b8 a0 00 00 00	 mov	 eax, 160		; 000000a0H
  0227a	89 b5 9c fe ff
	ff		 mov	 DWORD PTR _i_subfr$1$[ebp], esi
  02280	66 3b f0	 cmp	 si, ax
  02283	0f 8c d7 e1 ff
	ff		 jl	 $LL109@Decoder_am

; 1105 :     }
; 1106 :     
; 1107 :     /*-------------------------------------------------------*
; 1108 :      * Call the Source Characteristic Detector which updates *
; 1109 :      * st->inBackgroundNoise and st->voicedHangover.         *
; 1110 :      *-------------------------------------------------------*/
; 1111 : 
; 1112 :                             move16 (); /* function result */
; 1113 :     st->inBackgroundNoise = Bgn_scd(st->background_state,
; 1114 :                                     &(st->ltpGainHistory[0]),
; 1115 :                                     &(synth[0]),
; 1116 :                                     &(st->voicedHangover) );

  02289	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR _synth$GSCopy$1$[ebp]
  0228f	8d 83 d0 01 00
	00		 lea	 eax, DWORD PTR [ebx+464]
  02295	8b 8b e4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+484]
  0229b	8d 93 d2 01 00
	00		 lea	 edx, DWORD PTR [ebx+466]
  022a1	50		 push	 eax
  022a2	56		 push	 esi
  022a3	e8 00 00 00 00	 call	 _Bgn_scd

; 1117 : 
; 1118 :     dtx_dec_activity_update(st->dtxDecoderState, 
; 1119 :                             st->lsfState->past_lsf_q, 
; 1120 :                             synth);

  022a8	8b 93 f4 01 00
	00		 mov	 edx, DWORD PTR [ebx+500]
  022ae	8b 8b 08 02 00
	00		 mov	 ecx, DWORD PTR [ebx+520]
  022b4	83 c2 14	 add	 edx, 20			; 00000014H
  022b7	56		 push	 esi
  022b8	66 89 83 ce 01
	00 00		 mov	 WORD PTR [ebx+462], ax
  022bf	e8 00 00 00 00	 call	 _dtx_dec_activity_update

; 1121 :     
; 1122 :     fwc ();                     /* function worst case */
; 1123 : 
; 1124 :     /* store bfi for next subframe */
; 1125 :     st->prev_bf = bfi;                  move16 (); 

  022c4	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _bfi$1$[ebp]
  022ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1126 :     st->prev_pdf = pdfi;                move16 (); 
; 1127 :     
; 1128 :     /*--------------------------------------------------*
; 1129 :      * Calculate the LSF averages on the eight          *
; 1130 :      * previous frames                                  *
; 1131 :      *--------------------------------------------------*/
; 1132 :     
; 1133 :     lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);

  022cd	8b 93 f4 01 00
	00		 mov	 edx, DWORD PTR [ebx+500]
  022d3	8b 8b f0 01 00
	00		 mov	 ecx, DWORD PTR [ebx+496]
  022d9	83 c2 14	 add	 edx, 20			; 00000014H
  022dc	66 89 83 b4 01
	00 00		 mov	 WORD PTR [ebx+436], ax
  022e3	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _pdfi$1$[ebp]
  022e9	66 89 83 b6 01
	00 00		 mov	 WORD PTR [ebx+438], ax
  022f0	e8 00 00 00 00	 call	 _lsp_avg
  022f5	8b b5 7c fe ff
	ff		 mov	 esi, DWORD PTR _newDTXState$1$[ebp]
$the_end$2040:

; 1134 :     fwc ();                 /* function worst case */
; 1135 : 
; 1136 : the_end:
; 1137 :     st->dtxDecoderState->dtxGlobalState = newDTXState;  move16();

  022fb	8b 83 08 02 00
	00		 mov	 eax, DWORD PTR [ebx+520]

; 1138 :     
; 1139 :     return 0;
; 1140 : }

  02301	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02304	5f		 pop	 edi
  02305	33 cd		 xor	 ecx, ebp
  02307	89 b0 98 01 00
	00		 mov	 DWORD PTR [eax+408], esi
  0230d	33 c0		 xor	 eax, eax
  0230f	5e		 pop	 esi
  02310	5b		 pop	 ebx
  02311	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02316	8b e5		 mov	 esp, ebp
  02318	5d		 pop	 ebp
  02319	c3		 ret	 0
_Decoder_amr ENDP
_TEXT	ENDS
END
