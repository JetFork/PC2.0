; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\int_lpc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Int_lpc_1and3
PUBLIC	_Int_lpc_1to3
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
;	COMDAT _Int_lpc_1to3
_TEXT	SEGMENT
tv1308 = -40						; size = 4
_lsp_old$1$ = -36					; size = 4
_lsp_new$GSCopy$1$ = -32				; size = 4
_Az$GSCopy$1$ = -28					; size = 4
_lsp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_Az$ = 8						; size = 4
_Int_lpc_1to3 PROC					; COMDAT
; _lsp_old$ = ecx
; _lsp_new$ = edx

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _Az$[ebp]

; 183  :     Word16 i;
; 184  :     Word16 lsp[M];
; 185  : 
; 186  :     for (i = 0; i < M; i++) {

  00015	8d 5d e8	 lea	 ebx, DWORD PTR _lsp$[ebp]
  00018	57		 push	 edi
  00019	8b fa		 mov	 edi, edx
  0001b	89 75 e4	 mov	 DWORD PTR _Az$GSCopy$1$[ebp], esi
  0001e	8b c1		 mov	 eax, ecx
  00020	89 7d e0	 mov	 DWORD PTR _lsp_new$GSCopy$1$[ebp], edi
  00023	2b f8		 sub	 edi, eax
  00025	89 45 dc	 mov	 DWORD PTR _lsp_old$1$[ebp], eax
  00028	8b d0		 mov	 edx, eax
  0002a	89 7d d8	 mov	 DWORD PTR tv1308[ebp], edi
  0002d	2b d8		 sub	 ebx, eax
  0002f	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
$LL9@Int_lpc_1t:

; 187  :         lsp[i] = add(shr(lsp_new[i], 2), sub(lsp_old[i], shr(lsp_old[i], 2)));

  00034	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  00037	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00039	66 85 c0	 test	 ax, ax
  0003c	79 0a		 jns	 SHORT $LN13@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0003e	98		 cwde
  0003f	f7 d0		 not	 eax
  00041	c1 f8 02	 sar	 eax, 2
  00044	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00046	eb 04		 jmp	 SHORT $LN206@Int_lpc_1t
$LN13@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00048	66 c1 f8 02	 sar	 ax, 2
$LN206@Int_lpc_1t:
  0004c	0f b7 c0	 movzx	 eax, ax

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0004f	0f bf c9	 movsx	 ecx, cx
  00052	98		 cwde
  00053	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00055	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0005b	7e 11		 jle	 SHORT $LN37@Int_lpc_1t

; 80   :     {
; 81   :         Overflow = 1;

  0005d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00067	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0006c	eb 1c		 jmp	 SHORT $LN34@Int_lpc_1t
$LN37@Int_lpc_1t:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0006e	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00074	7d 11		 jge	 SHORT $LN35@Int_lpc_1t

; 85   :     {
; 86   :         Overflow = 1;

  00076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00080	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00085	eb 03		 jmp	 SHORT $LN34@Int_lpc_1t
$LN35@Int_lpc_1t:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00087	0f b7 c9	 movzx	 ecx, cx
$LN34@Int_lpc_1t:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 187  :         lsp[i] = add(shr(lsp_new[i], 2), sub(lsp_old[i], shr(lsp_old[i], 2)));

  0008a	0f b7 04 17	 movzx	 eax, WORD PTR [edi+edx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0008e	66 85 c0	 test	 ax, ax
  00091	79 0a		 jns	 SHORT $LN43@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00093	98		 cwde
  00094	f7 d0		 not	 eax
  00096	c1 f8 02	 sar	 eax, 2
  00099	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0009b	eb 04		 jmp	 SHORT $LN207@Int_lpc_1t
$LN43@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0009d	66 c1 f8 02	 sar	 ax, 2
$LN207@Int_lpc_1t:
  000a1	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  000a4	0f bf c9	 movsx	 ecx, cx
  000a7	98		 cwde
  000a8	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  000aa	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  000b0	7e 11		 jle	 SHORT $LN67@Int_lpc_1t

; 80   :     {
; 81   :         Overflow = 1;

  000b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000bc	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000c1	eb 1c		 jmp	 SHORT $LN64@Int_lpc_1t
$LN67@Int_lpc_1t:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000c3	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  000c9	7d 11		 jge	 SHORT $LN65@Int_lpc_1t

; 85   :     {
; 86   :         Overflow = 1;

  000cb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000d5	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000da	eb 03		 jmp	 SHORT $LN64@Int_lpc_1t
$LN65@Int_lpc_1t:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000dc	0f b7 c1	 movzx	 eax, cx
$LN64@Int_lpc_1t:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 187  :         lsp[i] = add(shr(lsp_new[i], 2), sub(lsp_old[i], shr(lsp_old[i], 2)));

  000df	66 89 04 13	 mov	 WORD PTR [ebx+edx], ax
  000e3	83 c2 02	 add	 edx, 2
  000e6	4e		 dec	 esi
  000e7	0f 85 47 ff ff
	ff		 jne	 $LL9@Int_lpc_1t

; 188  : 		                    move16 ();
; 189  :     }
; 190  : 
; 191  :     Lsp_Az(lsp, Az);        /* Subframe 1 */

  000ed	8b 75 e4	 mov	 esi, DWORD PTR _Az$GSCopy$1$[ebp]
  000f0	8d 4d e8	 lea	 ecx, DWORD PTR _lsp$[ebp]
  000f3	8b d6		 mov	 edx, esi
  000f5	e8 00 00 00 00	 call	 _Lsp_Az
  000fa	8b 55 dc	 mov	 edx, DWORD PTR _lsp_old$1$[ebp]

; 192  :     Az += MP1;              move16 (); 

  000fd	83 c6 16	 add	 esi, 22			; 00000016H
  00100	89 75 e4	 mov	 DWORD PTR _Az$GSCopy$1$[ebp], esi
  00103	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00108	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL6@Int_lpc_1t:

; 196  :         lsp[i] = add(shr(lsp_old[i], 1), shr(lsp_new[i], 1));

  00110	8b 45 d8	 mov	 eax, DWORD PTR tv1308[ebp]
  00113	0f b7 04 02	 movzx	 eax, WORD PTR [edx+eax]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00117	66 85 c0	 test	 ax, ax
  0011a	79 09		 jns	 SHORT $LN77@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0011c	98		 cwde
  0011d	f7 d0		 not	 eax
  0011f	d1 f8		 sar	 eax, 1
  00121	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00123	eb 03		 jmp	 SHORT $LN208@Int_lpc_1t
$LN77@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00125	66 d1 f8	 sar	 ax, 1
$LN208@Int_lpc_1t:
  00128	0f b7 f0	 movzx	 esi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 196  :         lsp[i] = add(shr(lsp_old[i], 1), shr(lsp_new[i], 1));

  0012b	0f b7 02	 movzx	 eax, WORD PTR [edx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0012e	66 85 c0	 test	 ax, ax
  00131	79 09		 jns	 SHORT $LN97@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00133	98		 cwde
  00134	f7 d0		 not	 eax
  00136	d1 f8		 sar	 eax, 1
  00138	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0013a	eb 03		 jmp	 SHORT $LN209@Int_lpc_1t
$LN97@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0013c	66 d1 f8	 sar	 ax, 1
$LN209@Int_lpc_1t:
  0013f	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00142	0f bf c8	 movsx	 ecx, ax
  00145	0f bf c6	 movsx	 eax, si
  00148	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0014a	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00150	7e 11		 jle	 SHORT $LN121@Int_lpc_1t

; 80   :     {
; 81   :         Overflow = 1;

  00152	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0015c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00161	eb 1c		 jmp	 SHORT $LN118@Int_lpc_1t
$LN121@Int_lpc_1t:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00163	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00169	7d 11		 jge	 SHORT $LN119@Int_lpc_1t

; 85   :     {
; 86   :         Overflow = 1;

  0016b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00175	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0017a	eb 03		 jmp	 SHORT $LN118@Int_lpc_1t
$LN119@Int_lpc_1t:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0017c	0f b7 c1	 movzx	 eax, cx
$LN118@Int_lpc_1t:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 196  :         lsp[i] = add(shr(lsp_old[i], 1), shr(lsp_new[i], 1));

  0017f	66 89 04 1a	 mov	 WORD PTR [edx+ebx], ax
  00183	83 c2 02	 add	 edx, 2
  00186	4f		 dec	 edi
  00187	75 87		 jne	 SHORT $LL6@Int_lpc_1t

; 197  : 		                    move16 ();
; 198  :     }
; 199  : 
; 200  :     Lsp_Az(lsp, Az);        /* Subframe 2 */

  00189	8b 5d e4	 mov	 ebx, DWORD PTR _Az$GSCopy$1$[ebp]
  0018c	8d 4d e8	 lea	 ecx, DWORD PTR _lsp$[ebp]
  0018f	8b d3		 mov	 edx, ebx
  00191	e8 00 00 00 00	 call	 _Lsp_Az
  00196	8b 45 e0	 mov	 eax, DWORD PTR _lsp_new$GSCopy$1$[ebp]

; 201  :     Az += MP1;              move16 ();
; 202  : 
; 203  :     for (i = 0; i < M; i++) {

  00199	8d 7d e8	 lea	 edi, DWORD PTR _lsp$[ebp]
  0019c	83 c3 16	 add	 ebx, 22			; 00000016H
  0019f	8b d0		 mov	 edx, eax
  001a1	89 5d e4	 mov	 DWORD PTR _Az$GSCopy$1$[ebp], ebx
  001a4	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  001a9	8b 5d dc	 mov	 ebx, DWORD PTR _lsp_old$1$[ebp]
  001ac	2b d8		 sub	 ebx, eax
  001ae	2b f8		 sub	 edi, eax
$LL3@Int_lpc_1t:

; 204  :         lsp[i] = add(shr(lsp_old[i], 2), sub(lsp_new[i], shr(lsp_new[i], 2)));

  001b0	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  001b3	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  001b5	66 85 c0	 test	 ax, ax
  001b8	79 0a		 jns	 SHORT $LN131@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001ba	98		 cwde
  001bb	f7 d0		 not	 eax
  001bd	c1 f8 02	 sar	 eax, 2
  001c0	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  001c2	eb 04		 jmp	 SHORT $LN210@Int_lpc_1t
$LN131@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  001c4	66 c1 f8 02	 sar	 ax, 2
$LN210@Int_lpc_1t:
  001c8	0f b7 c0	 movzx	 eax, ax

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  001cb	0f bf c9	 movsx	 ecx, cx
  001ce	98		 cwde
  001cf	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001d1	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  001d7	7e 11		 jle	 SHORT $LN155@Int_lpc_1t

; 80   :     {
; 81   :         Overflow = 1;

  001d9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001e3	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  001e8	eb 1c		 jmp	 SHORT $LN152@Int_lpc_1t
$LN155@Int_lpc_1t:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001ea	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  001f0	7d 11		 jge	 SHORT $LN153@Int_lpc_1t

; 85   :     {
; 86   :         Overflow = 1;

  001f2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001fc	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00201	eb 03		 jmp	 SHORT $LN152@Int_lpc_1t
$LN153@Int_lpc_1t:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00203	0f b7 c9	 movzx	 ecx, cx
$LN152@Int_lpc_1t:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 204  :         lsp[i] = add(shr(lsp_old[i], 2), sub(lsp_new[i], shr(lsp_new[i], 2)));

  00206	0f b7 04 13	 movzx	 eax, WORD PTR [ebx+edx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0020a	66 85 c0	 test	 ax, ax
  0020d	79 0a		 jns	 SHORT $LN161@Int_lpc_1t

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0020f	98		 cwde
  00210	f7 d0		 not	 eax
  00212	c1 f8 02	 sar	 eax, 2
  00215	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00217	eb 04		 jmp	 SHORT $LN211@Int_lpc_1t
$LN161@Int_lpc_1t:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00219	66 c1 f8 02	 sar	 ax, 2
$LN211@Int_lpc_1t:
  0021d	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00220	0f bf c9	 movsx	 ecx, cx
  00223	98		 cwde
  00224	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00226	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0022c	7e 11		 jle	 SHORT $LN185@Int_lpc_1t

; 80   :     {
; 81   :         Overflow = 1;

  0022e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00238	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0023d	eb 1c		 jmp	 SHORT $LN182@Int_lpc_1t
$LN185@Int_lpc_1t:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0023f	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00245	7d 11		 jge	 SHORT $LN183@Int_lpc_1t

; 85   :     {
; 86   :         Overflow = 1;

  00247	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00251	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00256	eb 03		 jmp	 SHORT $LN182@Int_lpc_1t
$LN183@Int_lpc_1t:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00258	0f b7 c1	 movzx	 eax, cx
$LN182@Int_lpc_1t:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 204  :         lsp[i] = add(shr(lsp_old[i], 2), sub(lsp_new[i], shr(lsp_new[i], 2)));

  0025b	66 89 04 17	 mov	 WORD PTR [edi+edx], ax
  0025f	83 c2 02	 add	 edx, 2
  00262	4e		 dec	 esi
  00263	0f 85 47 ff ff
	ff		 jne	 $LL3@Int_lpc_1t

; 205  : 		                    move16 ();
; 206  :     }
; 207  : 
; 208  :     Lsp_Az(lsp, Az);       /* Subframe 3 */

  00269	8b 75 e4	 mov	 esi, DWORD PTR _Az$GSCopy$1$[ebp]
  0026c	8d 4d e8	 lea	 ecx, DWORD PTR _lsp$[ebp]
  0026f	8b d6		 mov	 edx, esi
  00271	e8 00 00 00 00	 call	 _Lsp_Az

; 209  :     Az += MP1;              move16 ();
; 210  : 
; 211  :     Lsp_Az(lsp_new, Az);        /* Subframe 4 */

  00276	8b 4d e0	 mov	 ecx, DWORD PTR _lsp_new$GSCopy$1$[ebp]
  00279	8d 56 16	 lea	 edx, DWORD PTR [esi+22]
  0027c	e8 00 00 00 00	 call	 _Lsp_Az

; 212  : 
; 213  :     return;
; 214  : }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	5f		 pop	 edi
  00285	5e		 pop	 esi
  00286	33 cd		 xor	 ecx, ebp
  00288	5b		 pop	 ebx
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
_Int_lpc_1to3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c
;	COMDAT _Int_lpc_1and3
_TEXT	SEGMENT
_lsp_mid$GSCopy$1$ = -40				; size = 4
tv849 = -36						; size = 4
_lsp_new$GSCopy$1$ = -32				; size = 4
_Az$GSCopy$1$ = -28					; size = 4
_lsp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lsp_new$ = 8						; size = 4
_Az$ = 12						; size = 4
_Int_lpc_1and3 PROC					; COMDAT
; _lsp_old$ = ecx
; _lsp_mid$ = edx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lsp_new$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _Az$[ebp]
  00018	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  0001d	57		 push	 edi
  0001e	8b fa		 mov	 edi, edx
  00020	89 45 e0	 mov	 DWORD PTR _lsp_new$GSCopy$1$[ebp], eax

; 83   :     Word16 i;
; 84   :     Word16 lsp[M];
; 85   : 
; 86   :     /*  lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
; 87   : 
; 88   :     for (i = 0; i < M; i++)

  00023	2b cf		 sub	 ecx, edi
  00025	89 75 e4	 mov	 DWORD PTR _Az$GSCopy$1$[ebp], esi
  00028	8d 45 e8	 lea	 eax, DWORD PTR _lsp$[ebp]
  0002b	89 7d d8	 mov	 DWORD PTR _lsp_mid$GSCopy$1$[ebp], edi
  0002e	2b c7		 sub	 eax, edi
  00030	8b f7		 mov	 esi, edi
  00032	89 45 dc	 mov	 DWORD PTR tv849[ebp], eax
  00035	8b f9		 mov	 edi, ecx
$LL6@Int_lpc_1a:

; 90   :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_old[i], 1));

  00037	0f b7 04 37	 movzx	 eax, WORD PTR [edi+esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0003b	66 85 c0	 test	 ax, ax
  0003e	79 09		 jns	 SHORT $LN10@Int_lpc_1a

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00040	98		 cwde
  00041	f7 d0		 not	 eax
  00043	d1 f8		 sar	 eax, 1
  00045	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00047	eb 03		 jmp	 SHORT $LN127@Int_lpc_1a
$LN10@Int_lpc_1a:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00049	66 d1 f8	 sar	 ax, 1
$LN127@Int_lpc_1a:
  0004c	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 90   :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_old[i], 1));

  0004f	0f b7 06	 movzx	 eax, WORD PTR [esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00052	66 85 c0	 test	 ax, ax
  00055	79 09		 jns	 SHORT $LN30@Int_lpc_1a

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00057	98		 cwde
  00058	f7 d0		 not	 eax
  0005a	d1 f8		 sar	 eax, 1
  0005c	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0005e	eb 03		 jmp	 SHORT $LN128@Int_lpc_1a
$LN30@Int_lpc_1a:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00060	66 d1 f8	 sar	 ax, 1
$LN128@Int_lpc_1a:
  00063	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00066	0f bf c8	 movsx	 ecx, ax
  00069	0f bf c2	 movsx	 eax, dx
  0006c	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0006e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00074	7e 11		 jle	 SHORT $LN54@Int_lpc_1a

; 80   :     {
; 81   :         Overflow = 1;

  00076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00080	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00085	eb 1c		 jmp	 SHORT $LN51@Int_lpc_1a
$LN54@Int_lpc_1a:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00087	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0008d	7d 11		 jge	 SHORT $LN52@Int_lpc_1a

; 85   :     {
; 86   :         Overflow = 1;

  0008f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00099	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0009e	eb 03		 jmp	 SHORT $LN51@Int_lpc_1a
$LN52@Int_lpc_1a:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000a0	0f b7 c1	 movzx	 eax, cx
$LN51@Int_lpc_1a:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 90   :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_old[i], 1));

  000a3	8b 4d dc	 mov	 ecx, DWORD PTR tv849[ebp]
  000a6	66 89 04 31	 mov	 WORD PTR [ecx+esi], ax
  000aa	83 c6 02	 add	 esi, 2
  000ad	4b		 dec	 ebx
  000ae	75 87		 jne	 SHORT $LL6@Int_lpc_1a

; 91   :                                 move16 (); 
; 92   :     }
; 93   : 
; 94   :     Lsp_Az (lsp, Az);           /* Subframe 1 */

  000b0	8b 5d e4	 mov	 ebx, DWORD PTR _Az$GSCopy$1$[ebp]
  000b3	8d 4d e8	 lea	 ecx, DWORD PTR _lsp$[ebp]
  000b6	8b d3		 mov	 edx, ebx
  000b8	e8 00 00 00 00	 call	 _Lsp_Az

; 95   :     Az += MP1;                  move16 (); 
; 96   : 
; 97   :     Lsp_Az (lsp_mid, Az);       /* Subframe 2 */

  000bd	8b 7d d8	 mov	 edi, DWORD PTR _lsp_mid$GSCopy$1$[ebp]
  000c0	8d 53 16	 lea	 edx, DWORD PTR [ebx+22]
  000c3	8b cf		 mov	 ecx, edi
  000c5	e8 00 00 00 00	 call	 _Lsp_Az

; 98   :     Az += MP1;                  move16 (); 

  000ca	83 c3 2c	 add	 ebx, 44			; 0000002cH
  000cd	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  000d2	89 5d e4	 mov	 DWORD PTR _Az$GSCopy$1$[ebp], ebx

; 99   : 
; 100  :     for (i = 0; i < M; i++)

  000d5	8b 5d e0	 mov	 ebx, DWORD PTR _lsp_new$GSCopy$1$[ebp]
  000d8	2b df		 sub	 ebx, edi
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL3@Int_lpc_1a:

; 102  :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_new[i], 1));

  000e0	0f b7 04 3b	 movzx	 eax, WORD PTR [ebx+edi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  000e4	66 85 c0	 test	 ax, ax
  000e7	79 09		 jns	 SHORT $LN66@Int_lpc_1a

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  000e9	98		 cwde
  000ea	f7 d0		 not	 eax
  000ec	d1 f8		 sar	 eax, 1
  000ee	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  000f0	eb 03		 jmp	 SHORT $LN129@Int_lpc_1a
$LN66@Int_lpc_1a:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000f2	66 d1 f8	 sar	 ax, 1
$LN129@Int_lpc_1a:
  000f5	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 102  :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_new[i], 1));

  000f8	0f b7 07	 movzx	 eax, WORD PTR [edi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  000fb	66 85 c0	 test	 ax, ax
  000fe	79 09		 jns	 SHORT $LN86@Int_lpc_1a

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00100	98		 cwde
  00101	f7 d0		 not	 eax
  00103	d1 f8		 sar	 eax, 1
  00105	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00107	eb 03		 jmp	 SHORT $LN130@Int_lpc_1a
$LN86@Int_lpc_1a:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00109	66 d1 f8	 sar	 ax, 1
$LN130@Int_lpc_1a:
  0010c	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0010f	0f bf c8	 movsx	 ecx, ax
  00112	0f bf c2	 movsx	 eax, dx
  00115	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00117	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0011d	7e 11		 jle	 SHORT $LN110@Int_lpc_1a

; 80   :     {
; 81   :         Overflow = 1;

  0011f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00129	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0012e	eb 1c		 jmp	 SHORT $LN107@Int_lpc_1a
$LN110@Int_lpc_1a:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00130	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00136	7d 11		 jge	 SHORT $LN108@Int_lpc_1a

; 85   :     {
; 86   :         Overflow = 1;

  00138	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00142	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00147	eb 03		 jmp	 SHORT $LN107@Int_lpc_1a
$LN108@Int_lpc_1a:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00149	0f b7 c1	 movzx	 eax, cx
$LN107@Int_lpc_1a:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\int_lpc.c

; 102  :         lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_new[i], 1));

  0014c	8b 4d dc	 mov	 ecx, DWORD PTR tv849[ebp]
  0014f	66 89 04 0f	 mov	 WORD PTR [edi+ecx], ax
  00153	83 c7 02	 add	 edi, 2
  00156	4e		 dec	 esi
  00157	75 87		 jne	 SHORT $LL3@Int_lpc_1a

; 103  :                                 move16 (); 
; 104  :     }
; 105  : 
; 106  :     Lsp_Az (lsp, Az);           /* Subframe 3 */

  00159	8b 75 e4	 mov	 esi, DWORD PTR _Az$GSCopy$1$[ebp]
  0015c	8d 4d e8	 lea	 ecx, DWORD PTR _lsp$[ebp]
  0015f	8b d6		 mov	 edx, esi
  00161	e8 00 00 00 00	 call	 _Lsp_Az

; 107  :     Az += MP1;                  move16 (); 
; 108  : 
; 109  :     Lsp_Az (lsp_new, Az);       /* Subframe 4 */

  00166	8b 4d e0	 mov	 ecx, DWORD PTR _lsp_new$GSCopy$1$[ebp]
  00169	8d 56 16	 lea	 edx, DWORD PTR [esi+22]
  0016c	e8 00 00 00 00	 call	 _Lsp_Az

; 110  : 
; 111  :     return;
; 112  : }

  00171	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	33 cd		 xor	 ecx, ebp
  00178	5b		 pop	 ebx
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
_Int_lpc_1and3 ENDP
_TEXT	ENDS
END
