; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\ph_disp.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@ ; `string'
;	COMDAT ??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@ DB 'ph_disp_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@ DB 'ph_disp_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@ DB 'ph_disp_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
_ph_imp_mid_MR795 DW 07642H
	DW	0ef7H
	DW	0f03cH
	DW	0b9cH
	DW	0fbe8H
	DW	0fc16H
	DW	09adH
	DW	0f41dH
	DW	0affH
	DW	0f749H
	DW	06d9H
	DW	0f9b5H
	DW	06b2H
	DW	0f911H
	DW	0607H
	DW	0fc10H
	DW	01adH
	DW	0ff57H
	DW	01d8H
	DW	0fb10H
	DW	0880H
	DW	0f56eH
	DW	09dbH
	DW	0f9abH
	DW	0158H
	DW	033aH
	DW	0fa07H
	DW	06bcH
	DW	0f987H
	DW	06a5H
	DW	0f7f1H
	DW	0a54H
	DW	0f40cH
	DW	0b51H
	DW	0f846H
	DW	022dH
	DW	030cH
	DW	0faa7H
	DW	034aH
	DW	028fH
_ph_imp_low DW	03962H
	DW	02cfeH
	DW	04f4H
	DW	0f537H
	DW	0e9d9H
	DW	01d5aH
	DW	0ffddH
	DW	0f509H
	DW	0f420H
	DW	012d7H
	DW	0b88H
	DW	0df18H
	DW	0ec9H
	DW	05afH
	DW	0883H
	DW	0de43H
	DW	01f73H
	DW	0f7c9H
	DW	0fa52H
	DW	0309H
	DW	0454H
	DW	0f6afH
	DW	08ceH
	DW	0fe95H
	DW	0fd5eH
	DW	0f7c9H
	DW	0179eH
	DW	0e9cfH
	DW	0430H
	DW	0c33H
	DW	0ec3eH
	DW	014c0H
	DW	0f6e7H
	DW	0f170H
	DW	01b0cH
	DW	0f0cfH
	DW	02a3H
	DW	0f911H
	DW	01dH
	DW	027a1H
_ph_imp_low_MR795 DW 06899H
	DW	0321H
	DW	09c9H
	DW	0fd55H
	DW	0fa9aH
	DW	0246H
	DW	025cH
	DW	0fb06H
	DW	0db7H
	DW	0e8faH
	DW	011b6H
	DW	0fe0dH
	DW	0f86cH
	DW	0bc3H
	DW	0ec3eH
	DW	015eeH
	DW	0f83aH
	DW	0fbdbH
	DW	0fa4dH
	DW	0115aH
	DW	0fd44H
	DW	0eb29H
	DW	01201H
	DW	01c4H
	DW	0fdb3H
	DW	0f2e8H
	DW	0b89H
	DW	04f3H
	DW	0fb44H
	DW	0f5e2H
	DW	06c3H
	DW	0e56H
	DW	0ee85H
	DW	0fc31H
	DW	01127H
	DW	0f617H
	DW	03b5H
	DW	0faadH
	DW	0fc2dH
	DW	01666H
_ph_imp_mid DW	07642H
	DW	0ef7H
	DW	0f03cH
	DW	0b9cH
	DW	0fbe8H
	DW	0fc16H
	DW	09adH
	DW	0f41dH
	DW	0affH
	DW	0f749H
	DW	06d9H
	DW	0f9b5H
	DW	06b2H
	DW	0f911H
	DW	0607H
	DW	0fc10H
	DW	01adH
	DW	0ff57H
	DW	01d8H
	DW	0fb10H
	DW	0880H
	DW	0f56eH
	DW	09dbH
	DW	0f9abH
	DW	0158H
	DW	033aH
	DW	0fa07H
	DW	06bcH
	DW	0f987H
	DW	06a5H
	DW	0f7f1H
	DW	0a54H
	DW	0f40cH
	DW	0b51H
	DW	0f846H
	DW	022dH
	DW	030cH
	DW	0faa7H
	DW	034aH
	DW	028fH
PUBLIC	_ph_disp_release
PUBLIC	_ph_disp_init
PUBLIC	_ph_disp_lock
PUBLIC	_ph_disp_exit
PUBLIC	_ph_disp
PUBLIC	_ph_disp_reset
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_reset
_TEXT	SEGMENT
_ph_disp_reset PROC					; COMDAT
; _state$ = ecx

; 86   :   Word16 i;
; 87   : 
; 88   :    if (state == (ph_dispState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN4@ph_disp_re

; 89   :       fprintf(stderr, "ph_disp_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MCILOHDL@ph_disp_reset?3?5invalid?5parameter@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 90   :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 100  : 
; 101  :    return 0;
; 102  : }

  0001f	c3		 ret	 0
$LN4@ph_disp_re:
  00020	0f 57 c0	 xorps	 xmm0, xmm0

; 91   :    }
; 92   :    for (i=0; i<PHDGAINMEMSIZE; i++)
; 93   :    {
; 94   :        state->gainMem[i] = 0;
; 95   :    }
; 96   :    state->prevState = 0;
; 97   :    state->prevCbGain = 0;

  00023	33 c0		 xor	 eax, eax
  00025	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00029	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00030	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 98   :    state->lockFull = 0;
; 99   :    state->onset = 0;          /* assume no onset in start */ 

  00033	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 100  : 
; 101  :    return 0;
; 102  : }

  00037	c3		 ret	 0
_ph_disp_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp
_TEXT	SEGMENT
tv1739 = -196						; size = 4
tv1748 = -192						; size = 4
tv1727 = -188						; size = 4
_ppos$1$ = -184						; size = 4
tv1738 = -184						; size = 4
_x$GSCopy$1$ = -180					; size = 4
_mode$1$ = -176						; size = 4
tv1736 = -176						; size = 4
_inno$GSCopy$1$ = -172					; size = 4
_impNr$1$ = -168					; size = 4
_ph_imp$1$ = -168					; size = 4
_ps_poss$ = -164					; size = 80
_inno_sav$ = -84					; size = 80
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_cbGain$ = 12						; size = 2
_ltpGain$ = 16						; size = 2
_inno$ = 20						; size = 4
_pitch_fac$ = 24					; size = 2
_tmp_shift$ = 28					; size = 2
_ph_disp PROC						; COMDAT
; _state$ = ecx
; _mode$ = edx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx
  00019	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$GSCopy$1$[ebp], eax
  0001f	8b 45 14	 mov	 eax, DWORD PTR _inno$[ebp]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	89 95 50 ff ff
	ff		 mov	 DWORD PTR _mode$1$[ebp], edx
  0002a	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  0002d	89 85 54 ff ff
	ff		 mov	 DWORD PTR _inno$GSCopy$1$[ebp], eax

; 170  :    Word16 i, i1;
; 171  :    Word16 tmp1;
; 172  :    Word32 L_temp;
; 173  :    Word16 impNr;           /* indicator for amount of disp./filter used */
; 174  : 
; 175  :    Word16 inno_sav[L_SUBFR];
; 176  :    Word16 ps_poss[L_SUBFR];
; 177  :    Word16 j, nze, nPulse, ppos;
; 178  :    const Word16 *ph_imp;   /* Pointer to phase dispersion filter */
; 179  : 
; 180  :    /* Update LTP gain memory */
; 181  :    for (i = PHDGAINMEMSIZE-1; i > 0; i--)

  00033	bf 04 00 00 00	 mov	 edi, 4
$LL43@ph_disp:

; 182  :    {
; 183  :        state->gainMem[i] = state->gainMem[i-1];                    move16 ();

  00038	66 8b 46 fe	 mov	 ax, WORD PTR [esi-2]
  0003c	8d 76 fe	 lea	 esi, DWORD PTR [esi-2]
  0003f	4f		 dec	 edi
  00040	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00044	66 85 ff	 test	 di, di
  00047	7f ef		 jg	 SHORT $LL43@ph_disp

; 185  :    state->gainMem[0] = ltpGain;                                    move16 ();

  00049	66 8b 45 10	 mov	 ax, WORD PTR _ltpGain$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0004d	0f bf c8	 movsx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 185  :    state->gainMem[0] = ltpGain;                                    move16 ();

  00050	66 89 03	 mov	 WORD PTR [ebx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00053	8d 81 66 c6 ff
	ff		 lea	 eax, DWORD PTR [ecx-14746]

; 79   :     if (L_var1 > 0X00007fffL)

  00059	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0005e	7e 28		 jle	 SHORT $LN57@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00060	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN40@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 202  :       impNr = 2; /* no dispersion */                              move16 ();

  0006a	bf 02 00 00 00	 mov	 edi, 2
$LN508@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0006f	0f bf 4b 0c	 movsx	 ecx, WORD PTR [ebx+12]
  00073	c1 e1 0e	 shl	 ecx, 14			; 0000000eH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 202  :       impNr = 2; /* no dispersion */                              move16 ();

  00076	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0007c	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00082	74 5b		 je	 SHORT $LN83@ph_disp

; 488  :     {
; 489  :         L_var_out *= 2;

  00084	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  00086	eb 66		 jmp	 SHORT $LN82@ph_disp
$LN57@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00088	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0008d	7d 0c		 jge	 SHORT $LN55@ph_disp

; 86   :         Overflow = 1;

  0008f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00099	eb 05		 jmp	 SHORT $LN482@ph_disp
$LN55@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 189  :    if (sub(ltpGain, PHDTHR2LTP) < 0) {    /* if (ltpGain < 0.9) */

  0009b	66 85 c0	 test	 ax, ax
  0009e	79 ca		 jns	 SHORT $LN40@ph_disp
$LN482@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000a0	8d 81 9a d9 ff
	ff		 lea	 eax, DWORD PTR [ecx-9830]

; 79   :     if (L_var1 > 0X00007fffL)

  000a6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000ab	7e 11		 jle	 SHORT $LN69@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  000ad	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 193  :           impNr = 1; /* medium dispersion */                      move16 ();

  000b7	bf 01 00 00 00	 mov	 edi, 1

; 194  :        }
; 195  :        else

  000bc	eb b1		 jmp	 SHORT $LN508@ph_disp
$LN69@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000be	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000c3	7d 0e		 jge	 SHORT $LN67@ph_disp

; 86   :         Overflow = 1;

  000c5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN39@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 197  :           impNr = 0; /* maximum dispersion */                     move16 ();

  000cf	33 ff		 xor	 edi, edi

; 198  :        }
; 199  :    }
; 200  :    else

  000d1	eb 9c		 jmp	 SHORT $LN508@ph_disp
$LN67@ph_disp:

; 190  :        test ();
; 191  :        if (sub(ltpGain, PHDTHR1LTP) > 0)

  000d3	66 85 c0	 test	 ax, ax
  000d6	7e f7		 jle	 SHORT $LN39@ph_disp

; 193  :           impNr = 1; /* medium dispersion */                      move16 ();

  000d8	bf 01 00 00 00	 mov	 edi, 1

; 194  :        }
; 195  :        else

  000dd	eb 90		 jmp	 SHORT $LN508@ph_disp
$LN83@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 493  :         Overflow = 1;

  000df	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000e9	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN82@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 208  :    tmp1 = round(L_shl(L_mult(state->prevCbGain, ONFACTPLUS1), 2));

  000ee	b8 02 00 00 00	 mov	 eax, 2
$LL94@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  000f3	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  000f9	7f 19		 jg	 SHORT $LN451@ph_disp

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  000fb	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  00101	7c 0a		 jl	 SHORT $LN452@ph_disp

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00103	48		 dec	 eax
  00104	03 c9		 add	 ecx, ecx
  00106	66 85 c0	 test	 ax, ax
  00109	7f e8		 jg	 SHORT $LL94@ph_disp

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0010b	eb 16		 jmp	 SHORT $LN89@ph_disp
$LN452@ph_disp:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0010d	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00112	eb 05		 jmp	 SHORT $LN509@ph_disp
$LN451@ph_disp:

; 1360 :                 L_var_out = MAX_32;

  00114	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN509@ph_disp:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN89@ph_disp:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00123	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00129	85 c9		 test	 ecx, ecx
  0012b	78 1d		 js	 SHORT $LN99@ph_disp

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0012d	8b c2		 mov	 eax, edx
  0012f	33 c1		 xor	 eax, ecx
  00131	79 17		 jns	 SHORT $LN99@ph_disp

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00133	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00135	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0013f	85 c9		 test	 ecx, ecx
  00141	0f 98 c2	 sets	 dl
  00144	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN99@ph_disp:

; 186  :     L_diff = (Word32) var1 - var2;

  0014a	0f bf 4d 0c	 movsx	 ecx, WORD PTR _cbGain$[ebp]

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0014e	c1 fa 10	 sar	 edx, 16			; 00000010H

; 186  :     L_diff = (Word32) var1 - var2;

  00151	0f bf c2	 movsx	 eax, dx
  00154	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv1748[ebp], ecx
  0015a	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0015c	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00162	7e 11		 jle	 SHORT $LN112@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00164	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 212  :        state->onset = ONLENGTH;                                    move16 ();

  0016e	b8 02 00 00 00	 mov	 eax, 2

; 213  :    }
; 214  :    else

  00173	eb 5c		 jmp	 SHORT $LN123@ph_disp
$LN112@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00175	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0017b	7d 2d		 jge	 SHORT $LN110@ph_disp

; 86   :         Overflow = 1;

  0017d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN36@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 217  :        if (state->onset > 0)

  00187	0f b7 43 10	 movzx	 eax, WORD PTR [ebx+16]
  0018b	66 85 c0	 test	 ax, ax
  0018e	7e 45		 jle	 SHORT $LN131@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00190	98		 cwde
  00191	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00192	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00197	7e 1d		 jle	 SHORT $LN126@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00199	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001a3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001a8	eb 27		 jmp	 SHORT $LN123@ph_disp
$LN110@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 210  :    if (sub(cbGain, tmp1) > 0)

  001aa	66 85 c9	 test	 cx, cx
  001ad	7e d8		 jle	 SHORT $LN36@ph_disp

; 212  :        state->onset = ONLENGTH;                                    move16 ();

  001af	b8 02 00 00 00	 mov	 eax, 2

; 213  :    }
; 214  :    else

  001b4	eb 1b		 jmp	 SHORT $LN123@ph_disp
$LN126@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b6	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001bb	7d 11		 jge	 SHORT $LN124@ph_disp

; 86   :         Overflow = 1;

  001bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001c7	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001cc	eb 03		 jmp	 SHORT $LN123@ph_disp
$LN124@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  001ce	0f b7 c0	 movzx	 eax, ax
$LN123@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 219  :            state->onset = sub (state->onset, 1);                   move16 ();

  001d1	66 89 43 10	 mov	 WORD PTR [ebx+16], ax
$LN131@ph_disp:

; 220  :        }
; 221  :    }
; 222  :    
; 223  :    /* if not onset, check ltpGain buffer and use max phase dispersion if
; 224  :       half or more of the ltpGain-parameters say so */
; 225  :    test ();
; 226  :    if (state->onset == 0)

  001d5	0f b7 73 10	 movzx	 esi, WORD PTR [ebx+16]
  001d9	66 85 f6	 test	 si, si
  001dc	0f 85 be 00 00
	00		 jne	 $LN171@ph_disp

; 227  :    {
; 228  :        /* Check LTP gain memory and set filter accordingly */
; 229  :        i1 = 0;                                                     move16 ();

  001e2	33 d2		 xor	 edx, edx
  001e4	8b cb		 mov	 ecx, ebx
  001e6	8d 72 05	 lea	 esi, DWORD PTR [edx+5]
  001e9	8d a4 24 00 00
	00 00		 npad	 7
$LL32@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  001f0	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  001f3	2d 66 26 00 00	 sub	 eax, 9830		; 00002666H

; 79   :     if (L_var1 > 0X00007fffL)

  001f8	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001fd	7e 0c		 jle	 SHORT $LN144@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  001ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00209	eb 52		 jmp	 SHORT $LN31@ph_disp
$LN144@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0020b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00210	7d 0c		 jge	 SHORT $LN142@ph_disp

; 86   :         Overflow = 1;

  00212	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0021c	eb 05		 jmp	 SHORT $LN485@ph_disp
$LN142@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 233  :            if (sub(state->gainMem[i], PHDTHR1LTP) < 0)

  0021e	66 85 c0	 test	 ax, ax
  00221	79 3a		 jns	 SHORT $LN31@ph_disp
$LN485@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00223	0f bf c2	 movsx	 eax, dx
  00226	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00227	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0022c	7e 11		 jle	 SHORT $LN154@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  0022e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00238	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0023d	eb 1b		 jmp	 SHORT $LN151@ph_disp
$LN154@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0023f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00244	7d 11		 jge	 SHORT $LN152@ph_disp

; 86   :         Overflow = 1;

  00246	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00250	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00255	eb 03		 jmp	 SHORT $LN151@ph_disp
$LN152@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00257	0f b7 c0	 movzx	 eax, ax
$LN151@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 235  :                i1 = add (i1, 1);

  0025a	0f b7 d0	 movzx	 edx, ax
$LN31@ph_disp:

; 230  :        for (i = 0; i < PHDGAINMEMSIZE; i++)

  0025d	83 c1 02	 add	 ecx, 2
  00260	4e		 dec	 esi
  00261	75 8d		 jne	 SHORT $LL32@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00263	0f bf c2	 movsx	 eax, dx
  00266	83 e8 02	 sub	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  00269	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0026e	7e 0c		 jle	 SHORT $LN166@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00270	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0027a	eb 18		 jmp	 SHORT $LN486@ph_disp
$LN166@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0027c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00281	7d 0c		 jge	 SHORT $LN164@ph_disp

; 86   :         Overflow = 1;

  00283	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0028d	eb 0d		 jmp	 SHORT $LN506@ph_disp
$LN164@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 239  :        if (sub(i1, 2) > 0)

  0028f	66 85 c0	 test	 ax, ax
  00292	7e 08		 jle	 SHORT $LN506@ph_disp
$LN486@ph_disp:

; 240  :        {
; 241  :            impNr = 0;                                              move16 ();

  00294	33 ff		 xor	 edi, edi
  00296	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
$LN506@ph_disp:
  0029c	0f b7 73 10	 movzx	 esi, WORD PTR [ebx+16]
$LN171@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002a0	0f bf 43 0a	 movsx	 eax, WORD PTR [ebx+10]
  002a4	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  002a5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002aa	7e 11		 jle	 SHORT $LN182@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  002ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002b6	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002bb	eb 1b		 jmp	 SHORT $LN179@ph_disp
$LN182@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002bd	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002c2	7d 11		 jge	 SHORT $LN180@ph_disp

; 86   :         Overflow = 1;

  002c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002ce	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002d3	eb 03		 jmp	 SHORT $LN179@ph_disp
$LN180@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002d5	0f b7 c0	 movzx	 eax, ax
$LN179@ph_disp:

; 186  :     L_diff = (Word32) var1 - var2;

  002d8	0f bf d7	 movsx	 edx, di
  002db	98		 cwde
  002dc	8b ca		 mov	 ecx, edx
  002de	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  002e0	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  002e6	7e 0c		 jle	 SHORT $LN192@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  002e8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002f2	eb 19		 jmp	 SHORT $LN487@ph_disp
$LN192@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002f4	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  002fa	7d 0c		 jge	 SHORT $LN190@ph_disp

; 86   :         Overflow = 1;

  002fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00306	eb 49		 jmp	 SHORT $LN27@ph_disp
$LN190@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 247  :    if ((sub(impNr, add(state->prevState, 1)) > 0) && (state->onset == 0))

  00308	66 85 c9	 test	 cx, cx
  0030b	7e 44		 jle	 SHORT $LN27@ph_disp
$LN487@ph_disp:
  0030d	66 85 f6	 test	 si, si
  00310	75 3f		 jne	 SHORT $LN27@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00312	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]

; 79   :     if (L_var1 > 0X00007fffL)

  00315	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0031a	7e 11		 jle	 SHORT $LN202@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  0031c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00326	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0032b	eb 1b		 jmp	 SHORT $LN199@ph_disp
$LN202@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0032d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00332	7d 11		 jge	 SHORT $LN200@ph_disp

; 86   :         Overflow = 1;

  00334	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0033e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00343	eb 03		 jmp	 SHORT $LN199@ph_disp
$LN200@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00345	0f b7 c0	 movzx	 eax, ax
$LN199@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 249  :        impNr = sub (impNr, 1);

  00348	0f b7 f8	 movzx	 edi, ax
  0034b	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
$LN27@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00351	0f bf cf	 movsx	 ecx, di
  00354	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]

; 79   :     if (L_var1 > 0X00007fffL)

  00357	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0035c	7e 0c		 jle	 SHORT $LN216@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  0035e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00368	eb 5c		 jmp	 SHORT $LN26@ph_disp
$LN216@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0036a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0036f	7d 0c		 jge	 SHORT $LN214@ph_disp

; 86   :         Overflow = 1;

  00371	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0037b	eb 05		 jmp	 SHORT $LN488@ph_disp
$LN214@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 253  :    if((sub(impNr, 2) < 0) && (state->onset > 0))

  0037d	66 85 c0	 test	 ax, ax
  00380	79 44		 jns	 SHORT $LN26@ph_disp
$LN488@ph_disp:
  00382	66 85 f6	 test	 si, si
  00385	7e 3f		 jle	 SHORT $LN26@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00387	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 79   :     if (L_var1 > 0X00007fffL)

  0038a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0038f	7e 11		 jle	 SHORT $LN226@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00391	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0039b	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  003a0	eb 1b		 jmp	 SHORT $LN223@ph_disp
$LN226@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003a2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003a7	7d 11		 jge	 SHORT $LN224@ph_disp

; 86   :         Overflow = 1;

  003a9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  003b3	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  003b8	eb 03		 jmp	 SHORT $LN223@ph_disp
$LN224@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  003ba	0f b7 c0	 movzx	 eax, ax
$LN223@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 255  :        impNr = add (impNr, 1);

  003bd	0f b7 f8	 movzx	 edi, ax
  003c0	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
$LN26@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003c6	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv1748[ebp]
  003cc	83 c0 f6	 add	 eax, -10		; fffffff6H

; 79   :     if (L_var1 > 0X00007fffL)

  003cf	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003d4	7e 0c		 jle	 SHORT $LN238@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  003d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003e0	eb 23		 jmp	 SHORT $LN243@ph_disp
$LN238@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003e2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003e7	7d 0c		 jge	 SHORT $LN236@ph_disp

; 86   :         Overflow = 1;

  003e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  003f3	eb 05		 jmp	 SHORT $LN489@ph_disp
$LN236@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 260  :    if(sub(cbGain, 10) < 0)

  003f5	66 85 c0	 test	 ax, ax
  003f8	79 0b		 jns	 SHORT $LN243@ph_disp
$LN489@ph_disp:

; 261  :    {
; 262  :        impNr = 2;                                                  move16 ();

  003fa	bf 02 00 00 00	 mov	 edi, 2
  003ff	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
$LN243@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00405	0f bf 43 0e	 movsx	 eax, WORD PTR [ebx+14]
  00409	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0040a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0040f	7e 0c		 jle	 SHORT $LN252@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00411	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0041b	eb 21		 jmp	 SHORT $LN257@ph_disp
$LN252@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0041d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00422	7d 0c		 jge	 SHORT $LN250@ph_disp

; 86   :         Overflow = 1;

  00424	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0042e	eb 0e		 jmp	 SHORT $LN257@ph_disp
$LN250@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 266  :    if(sub(state->lockFull, 1) == 0)

  00430	33 c9		 xor	 ecx, ecx
  00432	66 85 c0	 test	 ax, ax
  00435	0f 44 f9	 cmove	 edi, ecx
  00438	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _impNr$1$[ebp], edi
$LN257@ph_disp:

; 273  :    state->prevCbGain = cbGain;                                     move16 ();

  0043e	66 8b 45 0c	 mov	 ax, WORD PTR _cbGain$[ebp]
  00442	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00446	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _mode$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 272  :    state->prevState = impNr;                                       move16 ();

  0044c	66 89 7b 0a	 mov	 WORD PTR [ebx+10], di
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00450	0f bf d8	 movsx	 ebx, ax
  00453	8d 43 f9	 lea	 eax, DWORD PTR [ebx-7]

; 79   :     if (L_var1 > 0X00007fffL)

  00456	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0045b	7e 0c		 jle	 SHORT $LN276@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  0045d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00467	eb 1c		 jmp	 SHORT $LN490@ph_disp
$LN276@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00469	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0046e	7d 0c		 jge	 SHORT $LN274@ph_disp

; 86   :         Overflow = 1;

  00470	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0047a	eb 09		 jmp	 SHORT $LN490@ph_disp
$LN274@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 281  :        sub(impNr, 2) < 0)

  0047c	66 85 c0	 test	 ax, ax
  0047f	0f 84 3d 03 00
	00		 je	 $LN10@ph_disp
$LN490@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00485	8d 43 fa	 lea	 eax, DWORD PTR [ebx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  00488	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0048d	7e 0c		 jle	 SHORT $LN286@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  0048f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00499	eb 1c		 jmp	 SHORT $LN491@ph_disp
$LN286@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0049b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004a0	7d 0c		 jge	 SHORT $LN284@ph_disp

; 86   :         Overflow = 1;

  004a2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  004ac	eb 09		 jmp	 SHORT $LN491@ph_disp
$LN284@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 281  :        sub(impNr, 2) < 0)

  004ae	66 85 c0	 test	 ax, ax
  004b1	0f 84 0b 03 00
	00		 je	 $LN10@ph_disp
$LN491@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004b7	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]

; 79   :     if (L_var1 > 0X00007fffL)

  004ba	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004bf	7e 0c		 jle	 SHORT $LN296@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  004c1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004cb	eb 1c		 jmp	 SHORT $LN492@ph_disp
$LN296@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004cd	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004d2	7d 0c		 jge	 SHORT $LN294@ph_disp

; 86   :         Overflow = 1;

  004d4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  004de	eb 09		 jmp	 SHORT $LN492@ph_disp
$LN294@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 281  :        sub(impNr, 2) < 0)

  004e0	66 85 c0	 test	 ax, ax
  004e3	0f 84 d9 02 00
	00		 je	 $LN10@ph_disp
$LN492@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004e9	0f bf c7	 movsx	 eax, di
  004ec	83 e8 02	 sub	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  004ef	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004f4	7e 0f		 jle	 SHORT $LN306@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  004f6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00500	e9 bd 02 00 00	 jmp	 $LN10@ph_disp
$LN306@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00505	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0050a	7d 0c		 jge	 SHORT $LN304@ph_disp

; 86   :         Overflow = 1;

  0050c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00516	eb 09		 jmp	 SHORT $LN493@ph_disp
$LN304@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 281  :        sub(impNr, 2) < 0)

  00518	66 85 c0	 test	 ax, ax
  0051b	0f 89 a1 02 00
	00		 jns	 $LN10@ph_disp
$LN493@ph_disp:

; 282  :    {
; 283  :        /* track pulse positions, save innovation,
; 284  :           and initialize new innovation          */
; 285  :        nze = 0;                                                    move16 ();

  00521	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _inno$GSCopy$1$[ebp]

; 293  :            }
; 294  :            inno_sav[i] = inno[i];                                  move16 ();

  00527	8d 7d ac	 lea	 edi, DWORD PTR _inno_sav$[ebp]
  0052a	33 c0		 xor	 eax, eax
  0052c	33 d2		 xor	 edx, edx
  0052e	2b f9		 sub	 edi, ecx
$LL22@ph_disp:

; 286  :        for (i = 0; i < L_SUBFR; i++)
; 287  :        {
; 288  :            move16 (); test();
; 289  :            if (inno[i] != 0)

  00530	0f b7 31	 movzx	 esi, WORD PTR [ecx]
  00533	66 85 f6	 test	 si, si
  00536	74 40		 je	 SHORT $LN19@ph_disp

; 290  :            {
; 291  :                ps_poss[nze] = i;                                   move16 ();

  00538	98		 cwde
  00539	66 89 94 45 5c
	ff ff ff	 mov	 WORD PTR _ps_poss$[ebp+eax*2], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00541	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00542	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00547	7e 11		 jle	 SHORT $LN324@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00549	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00553	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00558	eb 1b		 jmp	 SHORT $LN321@ph_disp
$LN324@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0055a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0055f	7d 11		 jge	 SHORT $LN322@ph_disp

; 86   :         Overflow = 1;

  00561	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0056b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00570	eb 03		 jmp	 SHORT $LN321@ph_disp
$LN322@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00572	0f b7 c0	 movzx	 eax, ax
$LN321@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 292  :                nze = add (nze, 1);

  00575	0f b7 c0	 movzx	 eax, ax
$LN19@ph_disp:

; 293  :            }
; 294  :            inno_sav[i] = inno[i];                                  move16 ();

  00578	66 89 34 0f	 mov	 WORD PTR [edi+ecx], si
  0057c	42		 inc	 edx

; 295  :            inno[i] = 0;                                            move16 ();

  0057d	33 f6		 xor	 esi, esi
  0057f	66 89 31	 mov	 WORD PTR [ecx], si
  00582	83 c1 02	 add	 ecx, 2
  00585	66 83 fa 28	 cmp	 dx, 40			; 00000028H
  00589	7c a5		 jl	 SHORT $LL22@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0058b	8d 4b fb	 lea	 ecx, DWORD PTR [ebx-5]

; 79   :     if (L_var1 > 0X00007fffL)

  0058e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00594	7f 19		 jg	 SHORT $LN511@ph_disp

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00596	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0059c	7c 11		 jl	 SHORT $LN511@ph_disp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 299  :        if (sub (mode, MR795) == 0)

  0059e	66 85 c9	 test	 cx, cx
  005a1	75 16		 jne	 SHORT $LN18@ph_disp

; 300  :        {
; 301  :            test ();
; 302  :            if (impNr == 0)

  005a3	b9 00 00 00 00	 mov	 ecx, OFFSET _ph_imp_low_MR795
  005a8	ba 00 00 00 00	 mov	 edx, OFFSET _ph_imp_mid_MR795

; 303  :            {
; 304  :                ph_imp = ph_imp_low_MR795;                            move16 ();
; 305  :            }
; 306  :            else
; 307  :            {
; 308  :                ph_imp = ph_imp_mid_MR795;                            move16 ();
; 309  :            }
; 310  :        }
; 311  :        else

  005ad	eb 14		 jmp	 SHORT $LN510@ph_disp
$LN511@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  005af	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN18@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 314  :            if (impNr == 0)

  005b9	b9 00 00 00 00	 mov	 ecx, OFFSET _ph_imp_low
  005be	ba 00 00 00 00	 mov	 edx, OFFSET _ph_imp_mid
$LN510@ph_disp:
  005c3	66 39 b5 58 ff
	ff ff		 cmp	 WORD PTR _impNr$1$[ebp], si
  005ca	0f 45 ca	 cmovne	 ecx, edx
  005cd	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _ph_imp$1$[ebp], ecx

; 315  :            {
; 316  :                ph_imp = ph_imp_low;                                  move16 ();
; 317  :            }
; 318  :            else
; 319  :            {
; 320  :                ph_imp = ph_imp_mid;                                  move16 ();
; 321  :            }
; 322  :        }
; 323  :        
; 324  :        /* Do phase dispersion of innovation */
; 325  :        for (nPulse = 0; nPulse < nze; nPulse++)

  005d3	33 c9		 xor	 ecx, ecx
  005d5	66 3b c8	 cmp	 cx, ax
  005d8	0f 8d e4 01 00
	00		 jge	 $LN10@ph_disp
  005de	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _ps_poss$[ebp]
  005e4	0f b7 c0	 movzx	 eax, ax
  005e7	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv1727[ebp], ecx
  005ed	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv1736[ebp], eax
$LL12@ph_disp:

; 326  :        {
; 327  :            ppos = ps_poss[nPulse];                                   move16 ();

  005f3	0f b7 19	 movzx	 ebx, WORD PTR [ecx]

; 328  :            
; 329  :            /* circular convolution with impulse response */
; 330  :            j = 0;                                                    move16 ();

  005f6	33 f6		 xor	 esi, esi
  005f8	89 9d 48 ff ff
	ff		 mov	 DWORD PTR _ppos$1$[ebp], ebx

; 331  :            for (i = ppos; i < L_SUBFR; i++)

  005fe	66 83 fb 28	 cmp	 bx, 40			; 00000028H
  00602	0f 8d d5 00 00
	00		 jge	 $LN7@ph_disp

; 334  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  00608	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _inno$GSCopy$1$[ebp]
  0060e	0f bf c3	 movsx	 eax, bx
  00611	03 c0		 add	 eax, eax
  00613	03 d0		 add	 edx, eax
  00615	0f bf 4c 05 ac	 movsx	 ecx, WORD PTR _inno_sav$[ebp+eax]
  0061a	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0061f	2b c3		 sub	 eax, ebx
  00621	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv1739[ebp], ecx
  00627	0f b7 f8	 movzx	 edi, ax
  0062a	8b d9		 mov	 ebx, ecx
  0062c	8d 64 24 00	 npad	 4
$LL9@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00630	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _ph_imp$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 334  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  00636	0f bf c6	 movsx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00639	0f bf 04 41	 movsx	 eax, WORD PTR [ecx+eax*2]
  0063d	0f af c3	 imul	 eax, ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00640	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00643	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00648	74 05		 je	 SHORT $LN361@ph_disp

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0064a	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN361@ph_disp:

; 79   :     if (L_var1 > 0X00007fffL)

  0064f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00654	7e 11		 jle	 SHORT $LN367@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00656	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00660	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00665	eb 1b		 jmp	 SHORT $LN364@ph_disp
$LN367@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00667	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0066c	7d 11		 jge	 SHORT $LN365@ph_disp

; 86   :         Overflow = 1;

  0066e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00678	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0067d	eb 03		 jmp	 SHORT $LN364@ph_disp
$LN365@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0067f	0f b7 c0	 movzx	 eax, ax
$LN364@ph_disp:

; 139  :     L_sum = (Word32) var1 + var2;

  00682	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 334  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  00685	46		 inc	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00686	98		 cwde
  00687	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00689	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0068f	7e 11		 jle	 SHORT $LN377@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00691	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0069b	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  006a0	eb 1c		 jmp	 SHORT $LN374@ph_disp
$LN377@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  006a2	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  006a8	7d 11		 jge	 SHORT $LN375@ph_disp

; 86   :         Overflow = 1;

  006aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  006b4	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  006b9	eb 03		 jmp	 SHORT $LN374@ph_disp
$LN375@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  006bb	0f b7 c1	 movzx	 eax, cx
$LN374@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 335  :                inno[i] = add(inno[i], tmp1);                         move16 ();

  006be	66 89 02	 mov	 WORD PTR [edx], ax
  006c1	83 c2 02	 add	 edx, 2
  006c4	4f		 dec	 edi
  006c5	0f 85 65 ff ff
	ff		 jne	 $LL9@ph_disp
  006cb	8b 9d 48 ff ff
	ff		 mov	 ebx, DWORD PTR _ppos$1$[ebp]
  006d1	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv1727[ebp]
  006d7	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv1736[ebp]
$LN7@ph_disp:

; 338  :            for (i = 0; i < ppos; i++)

  006dd	33 d2		 xor	 edx, edx
  006df	66 3b d3	 cmp	 dx, bx
  006e2	0f 8d c4 00 00
	00		 jge	 $LN11@ph_disp

; 341  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  006e8	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _inno$GSCopy$1$[ebp]
  006ee	0f bf c3	 movsx	 eax, bx
  006f1	0f b7 fb	 movzx	 edi, bx
  006f4	8b 9d 58 ff ff
	ff		 mov	 ebx, DWORD PTR _ph_imp$1$[ebp]
  006fa	0f bf 4c 45 ac	 movsx	 ecx, WORD PTR _inno_sav$[ebp+eax*2]
  006ff	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv1738[ebp], ecx
$LL6@ph_disp:
  00705	0f bf c6	 movsx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00708	0f bf 04 43	 movsx	 eax, WORD PTR [ebx+eax*2]
  0070c	0f af c1	 imul	 eax, ecx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0070f	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00712	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00717	74 05		 je	 SHORT $LN384@ph_disp

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00719	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN384@ph_disp:

; 79   :     if (L_var1 > 0X00007fffL)

  0071e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00723	7e 11		 jle	 SHORT $LN390@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00725	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0072f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00734	eb 1b		 jmp	 SHORT $LN387@ph_disp
$LN390@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00736	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0073b	7d 11		 jge	 SHORT $LN388@ph_disp

; 86   :         Overflow = 1;

  0073d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00747	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0074c	eb 03		 jmp	 SHORT $LN387@ph_disp
$LN388@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0074e	0f b7 c0	 movzx	 eax, ax
$LN387@ph_disp:

; 139  :     L_sum = (Word32) var1 + var2;

  00751	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 341  :                tmp1 = mult(inno_sav[ppos], ph_imp[j++]);

  00754	46		 inc	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00755	98		 cwde
  00756	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00758	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0075e	7e 11		 jle	 SHORT $LN400@ph_disp

; 80   :     {
; 81   :         Overflow = 1;

  00760	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0076a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0076f	eb 1c		 jmp	 SHORT $LN397@ph_disp
$LN400@ph_disp:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00771	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00777	7d 11		 jge	 SHORT $LN398@ph_disp

; 86   :         Overflow = 1;

  00779	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00783	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00788	eb 03		 jmp	 SHORT $LN397@ph_disp
$LN398@ph_disp:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0078a	0f b7 c1	 movzx	 eax, cx
$LN397@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 338  :            for (i = 0; i < ppos; i++)

  0078d	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv1738[ebp]

; 342  :                inno[i] = add(inno[i], tmp1);                         move16 ();

  00793	66 89 02	 mov	 WORD PTR [edx], ax
  00796	83 c2 02	 add	 edx, 2
  00799	4f		 dec	 edi
  0079a	0f 85 65 ff ff
	ff		 jne	 $LL6@ph_disp
  007a0	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv1727[ebp]
  007a6	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv1736[ebp]
$LN11@ph_disp:

; 315  :            {
; 316  :                ph_imp = ph_imp_low;                                  move16 ();
; 317  :            }
; 318  :            else
; 319  :            {
; 320  :                ph_imp = ph_imp_mid;                                  move16 ();
; 321  :            }
; 322  :        }
; 323  :        
; 324  :        /* Do phase dispersion of innovation */
; 325  :        for (nPulse = 0; nPulse < nze; nPulse++)

  007ac	83 c1 02	 add	 ecx, 2
  007af	48		 dec	 eax
  007b0	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv1727[ebp], ecx
  007b6	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv1736[ebp], eax
  007bc	0f 85 31 fe ff
	ff		 jne	 $LL12@ph_disp
$LN10@ph_disp:
  007c2	8b 45 18	 mov	 eax, DWORD PTR _pitch_fac$[ebp]

; 343  :            }
; 344  :        }
; 345  :    }
; 346  :        
; 347  :    /* compute total excitation for synthesis part of decoder
; 348  :       (using modified innovation if phase dispersion is active) */
; 349  :    for (i = 0; i < L_SUBFR; i++)

  007c5	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  007ca	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _inno$GSCopy$1$[ebp]
  007d0	66 8b 75 1c	 mov	 si, WORD PTR _tmp_shift$[ebp]
  007d4	0f bf d8	 movsx	 ebx, ax
  007d7	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$GSCopy$1$[ebp]
  007dd	2b c8		 sub	 ecx, eax
  007df	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _inno$GSCopy$1$[ebp], ecx
  007e5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL3@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  007f0	0f bf 10	 movsx	 edx, WORD PTR [eax]
  007f3	0f af d3	 imul	 edx, ebx

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  007f6	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  007fc	74 04		 je	 SHORT $LN408@ph_disp

; 488  :     {
; 489  :         L_var_out *= 2;

  007fe	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  00800	eb 0f		 jmp	 SHORT $LN407@ph_disp
$LN408@ph_disp:

; 493  :         Overflow = 1;

  00802	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0080c	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN407@ph_disp:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00811	0f bf 04 01	 movsx	 eax, WORD PTR [ecx+eax]
  00815	0f af 85 40 ff
	ff ff		 imul	 eax, DWORD PTR tv1748[ebp]

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0081c	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00821	74 04		 je	 SHORT $LN414@ph_disp

; 488  :     {
; 489  :         L_var_out *= 2;

  00823	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00825	eb 0f		 jmp	 SHORT $LN413@ph_disp
$LN414@ph_disp:

; 493  :         Overflow = 1;

  00827	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00831	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN413@ph_disp:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00836	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00839	33 c2		 xor	 eax, edx
  0083b	78 1d		 js	 SHORT $LN417@ph_disp

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0083d	8b c1		 mov	 eax, ecx
  0083f	33 c2		 xor	 eax, edx
  00841	79 17		 jns	 SHORT $LN417@ph_disp

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00843	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  00845	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0084f	85 d2		 test	 edx, edx
  00851	0f 98 c1	 sets	 cl
  00854	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN417@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 358  :        L_temp = L_shl (L_temp, tmp_shift);                 /* Q16 */           

  0085a	0f b7 c6	 movzx	 eax, si
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1344 :     if (var2 <= 0)

  0085d	66 85 f6	 test	 si, si
  00860	7f 1e		 jg	 SHORT $LL505@ph_disp

; 1345 :     {
; 1346 :         if (var2 < -32)

  00862	66 83 fe e0	 cmp	 si, -32			; ffffffe0H
  00866	ba e0 ff ff ff	 mov	 edx, -32		; ffffffe0H
  0086b	0f 4c c2	 cmovl	 eax, edx

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  0086e	f7 d8		 neg	 eax
  00870	8b d0		 mov	 edx, eax
  00872	e8 00 00 00 00	 call	 _L_shr
  00877	8b c8		 mov	 ecx, eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  00879	eb 35		 jmp	 SHORT $LN424@ph_disp
  0087b	eb 03 8d 49 00	 npad	 5
$LL505@ph_disp:

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00880	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00886	7f 19		 jg	 SHORT $LN453@ph_disp

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00888	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0088e	7c 0a		 jl	 SHORT $LN454@ph_disp

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00890	48		 dec	 eax
  00891	03 c9		 add	 ecx, ecx
  00893	66 85 c0	 test	 ax, ax
  00896	7f e8		 jg	 SHORT $LL505@ph_disp

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00898	eb 16		 jmp	 SHORT $LN424@ph_disp
$LN454@ph_disp:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0089a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0089f	eb 05		 jmp	 SHORT $LN512@ph_disp
$LN453@ph_disp:

; 1360 :                 L_var_out = MAX_32;

  008a1	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN512@ph_disp:

; 1358 :             {
; 1359 :                 Overflow = 1;

  008a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN424@ph_disp:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  008b0	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  008b6	85 c9		 test	 ecx, ecx
  008b8	78 1d		 js	 SHORT $LN434@ph_disp

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  008ba	8b c2		 mov	 eax, edx
  008bc	33 c1		 xor	 eax, ecx
  008be	79 17		 jns	 SHORT $LN434@ph_disp

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  008c0	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  008c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  008cc	85 c9		 test	 ecx, ecx
  008ce	0f 98 c2	 sets	 dl
  008d1	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN434@ph_disp:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 359  :        x[i] = round (L_temp);                                        move16 (); 

  008d7	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _x$GSCopy$1$[ebp]
  008dd	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _inno$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  008e3	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c

; 359  :        x[i] = round (L_temp);                                        move16 (); 

  008e6	66 89 10	 mov	 WORD PTR [eax], dx
  008e9	83 c0 02	 add	 eax, 2
  008ec	89 85 4c ff ff
	ff		 mov	 DWORD PTR _x$GSCopy$1$[ebp], eax
  008f2	4f		 dec	 edi
  008f3	0f 85 f7 fe ff
	ff		 jne	 $LL3@ph_disp

; 360  :    }
; 361  : 
; 362  :    return;
; 363  : }

  008f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008fc	5f		 pop	 edi
  008fd	5e		 pop	 esi
  008fe	33 cd		 xor	 ecx, ebp
  00900	5b		 pop	 ebx
  00901	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00906	8b e5		 mov	 esp, ebp
  00908	5d		 pop	 ebp
  00909	c3		 ret	 0
_ph_disp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_exit
_TEXT	SEGMENT
_ph_disp_exit PROC					; COMDAT
; _state$ = ecx

; 111  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 112  :   if ((state == NULL) || (*state == NULL))

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@ph_disp_ex
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@ph_disp_ex

; 113  :       return;
; 114  :   
; 115  :   /* deallocate memory */
; 116  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 117  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@ph_disp_ex:
  0001d	5e		 pop	 esi

; 118  :   
; 119  :   return;
; 120  : }

  0001e	c3		 ret	 0
_ph_disp_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_lock
_TEXT	SEGMENT
_ph_disp_lock PROC					; COMDAT
; _state$ = ecx

; 129  :   state->lockFull = 1;

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 130  :   return;
; 131  : }

  00009	c3		 ret	 0
_ph_disp_lock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_init
_TEXT	SEGMENT
_ph_disp_init PROC					; COMDAT
; _state$ = ecx

; 57   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 58   :   ph_dispState *s;
; 59   : 
; 60   :   if (state == (ph_dispState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@ph_disp_in

; 61   :       fprintf(stderr, "ph_disp_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JGLMFELL@ph_disp_init?3?5invalid?5parameter?6@
$LN15@ph_disp_in:
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 62   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 75   :   
; 76   : }

  00023	c3		 ret	 0
$LN2@ph_disp_in:

; 63   :   }
; 64   :   *state = NULL;
; 65   : 
; 66   :   /* allocate memory */
; 67   :   if ((s= (ph_dispState *) malloc(sizeof(ph_dispState))) == NULL){

  00024	6a 12		 push	 18			; 00000012H
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN1@ph_disp_in

; 68   :       fprintf(stderr, "ph_disp_init: can not malloc state structure\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CGFOOIJH@ph_disp_init?3?5can?5not?5malloc?5sta@

; 69   :       return -1;

  0003e	eb cc		 jmp	 SHORT $LN15@ph_disp_in
$LN1@ph_disp_in:
  00040	0f 57 c0	 xorps	 xmm0, xmm0

; 77   : 
; 78   : /*************************************************************************
; 79   : *
; 80   : *  Function:   ph_disp_reset
; 81   : *
; 82   : **************************************************************************
; 83   : */
; 84   : int ph_disp_reset (ph_dispState *state)
; 85   : {
; 86   :   Word16 i;
; 87   : 
; 88   :    if (state == (ph_dispState *) NULL){
; 89   :       fprintf(stderr, "ph_disp_reset: invalid parameter\n");
; 90   :       return -1;
; 91   :    }
; 92   :    for (i=0; i<PHDGAINMEMSIZE; i++)
; 93   :    {
; 94   :        state->gainMem[i] = 0;
; 95   :    }
; 96   :    state->prevState = 0;
; 97   :    state->prevCbGain = 0;

  00043	33 c9		 xor	 ecx, ecx
  00045	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00049	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00050	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 98   :    state->lockFull = 0;
; 99   :    state->onset = 0;          /* assume no onset in start */ 

  00053	66 89 48 10	 mov	 WORD PTR [eax+16], cx

; 70   :   }
; 71   :   ph_disp_reset(s);
; 72   :   *state = s;

  00057	89 06		 mov	 DWORD PTR [esi], eax

; 73   : 
; 74   :   return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	5e		 pop	 esi

; 75   :   
; 76   : }

  0005c	c3		 ret	 0
_ph_disp_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\ph_disp.c
;	COMDAT _ph_disp_release
_TEXT	SEGMENT
_ph_disp_release PROC					; COMDAT
; _state$ = ecx

; 141  :   state->lockFull = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 142  :   return;
; 143  : }

  00006	c3		 ret	 0
_ph_disp_release ENDP
_TEXT	ENDS
END
