; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d1035pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_dgray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	06H
	DW	04H
	DW	07H
PUBLIC	_dec_10i40_35bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c
;	COMDAT _dec_10i40_35bits
_TEXT	SEGMENT
_index$1$ = -12						; size = 4
tv756 = -8						; size = 4
_cod$1$ = -4						; size = 4
_dec_10i40_35bits PROC					; COMDAT
; _index$ = ecx
; _cod$ = edx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b c2		 mov	 eax, edx
  00008	89 4d f4	 mov	 DWORD PTR _index$1$[ebp], ecx
  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	89 45 fc	 mov	 DWORD PTR _cod$1$[ebp], eax
  00011	53		 push	 ebx
  00012	56		 push	 esi

; 64   :     Word16 i, j, pos1, pos2, sign, tmp;
; 65   : 
; 66   :     for (i = 0; i < L_CODE; i++)
; 67   :     {
; 68   :         cod[i] = 0;                                     move16 (); 

  00013	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00017	57		 push	 edi
  00018	f3 0f 7f 40 10	 movdqu	 XMMWORD PTR [eax+16], xmm0

; 69   :     }
; 70   : 
; 71   :     /* decode the positions and signs of pulses and build the codeword */
; 72   : 
; 73   :     for (j = 0; j < NB_TRACK; j++)

  0001d	bf 05 00 00 00	 mov	 edi, 5
  00022	8b d9		 mov	 ebx, ecx
  00024	f3 0f 7f 40 20	 movdqu	 XMMWORD PTR [eax+32], xmm0
  00029	89 7d f8	 mov	 DWORD PTR tv756[ebp], edi
  0002c	f3 0f 7f 40 30	 movdqu	 XMMWORD PTR [eax+48], xmm0
  00031	f3 0f 7f 40 40	 movdqu	 XMMWORD PTR [eax+64], xmm0
$LL6@dec_10i40_:

; 74   :     {
; 75   :         /* compute index i */
; 76   : 
; 77   :         tmp = index[j];                                 move16 ();

  00036	0f b7 13	 movzx	 edx, WORD PTR [ebx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00039	0f bf ca	 movsx	 ecx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 78   :         i = tmp & 7;                                    logic16 (); 

  0003c	8b c1		 mov	 eax, ecx
  0003e	83 e0 07	 and	 eax, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00041	0f bf 04 45 00
	00 00 00	 movsx	 eax, WORD PTR _dgray[eax*2]
  00049	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0004c	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00051	74 0c		 je	 SHORT $LN21@dec_10i40_

; 488  :     {
; 489  :         L_var_out *= 2;

  00053	03 c0		 add	 eax, eax

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  00055	79 17		 jns	 SHORT $LN25@dec_10i40_

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00057	f7 d0		 not	 eax
  00059	d1 f8		 sar	 eax, 1
  0005b	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  0005d	eb 11		 jmp	 SHORT $LN24@dec_10i40_
$LN21@dec_10i40_:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  0005f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00069	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN25@dec_10i40_:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0006e	d1 f8		 sar	 eax, 1
$LN24@dec_10i40_:

; 139  :     L_sum = (Word32) var1 + var2;

  00070	8d 77 fb	 lea	 esi, DWORD PTR [edi-5]
  00073	98		 cwde
  00074	03 c6		 add	 eax, esi

; 79   :     if (L_var1 > 0X00007fffL)

  00076	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0007b	7e 11		 jle	 SHORT $LN51@dec_10i40_

; 80   :     {
; 81   :         Overflow = 1;

  0007d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00087	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0008c	eb 1b		 jmp	 SHORT $LN48@dec_10i40_
$LN51@dec_10i40_:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0008e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00093	7d 11		 jge	 SHORT $LN49@dec_10i40_

; 85   :     {
; 86   :         Overflow = 1;

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0009f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000a4	eb 03		 jmp	 SHORT $LN48@dec_10i40_
$LN49@dec_10i40_:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000a6	0f b7 c0	 movzx	 eax, ax
$LN48@dec_10i40_:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);
; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;
; 304  :         }
; 305  :         else
; 306  :         {
; 307  :             var_out = extract_l (result);
; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)

  000a9	66 85 d2	 test	 dx, dx
  000ac	79 0c		 jns	 SHORT $LN57@dec_10i40_

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  000ae	f7 d1		 not	 ecx
  000b0	c1 f9 03	 sar	 ecx, 3
  000b3	f7 d1		 not	 ecx
  000b5	0f b7 c9	 movzx	 ecx, cx

; 378  :             }
; 379  :             else

  000b8	eb 07		 jmp	 SHORT $LN56@dec_10i40_
$LN57@dec_10i40_:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000ba	66 c1 fa 03	 sar	 dx, 3
  000be	0f b7 ca	 movzx	 ecx, dx
$LN56@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 84   :         i = shr (tmp, 3) & 1;                           logic16 (); 

  000c1	f6 c1 01	 test	 cl, 1

; 85   :         test (); 
; 86   :         if (i == 0)

  000c4	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000c9	b9 00 f0 ff ff	 mov	 ecx, -4096		; fffff000H
  000ce	0f 44 ca	 cmove	 ecx, edx

; 87   :         {
; 88   :             sign = 4096;                                move16 (); /* +1.0 */
; 89   :         }
; 90   :         else
; 91   :         {
; 92   :             sign = -4096;                               move16 (); /* -1.0 */
; 93   :         }
; 94   : 
; 95   :         cod[pos1] = sign;                               move16 (); 

  000d1	0f bf d0	 movsx	 edx, ax
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _cod$1$[ebp]
  000d7	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  000db	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  000e1	7e 11		 jle	 SHORT $LN91@dec_10i40_

; 80   :     {
; 81   :         Overflow = 1;

  000e3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000ed	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000f2	eb 1c		 jmp	 SHORT $LN88@dec_10i40_
$LN91@dec_10i40_:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000f4	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  000fa	7d 11		 jge	 SHORT $LN89@dec_10i40_

; 85   :     {
; 86   :         Overflow = 1;

  000fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00106	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0010b	eb 03		 jmp	 SHORT $LN88@dec_10i40_
$LN89@dec_10i40_:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0010d	0f b7 c7	 movzx	 eax, di
$LN88@dec_10i40_:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00110	8b 75 f4	 mov	 esi, DWORD PTR _index$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 99   :         i = index[add (j, 5)] & 7;                      logic16 (); 

  00113	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00114	0f bf 04 46	 movsx	 eax, WORD PTR [esi+eax*2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 99   :         i = index[add (j, 5)] & 7;                      logic16 (); 

  00118	83 e0 07	 and	 eax, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0011b	0f bf 04 45 00
	00 00 00	 movsx	 eax, WORD PTR _dgray[eax*2]
  00123	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00126	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0012b	74 0c		 je	 SHORT $LN101@dec_10i40_

; 488  :     {
; 489  :         L_var_out *= 2;

  0012d	03 c0		 add	 eax, eax

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)

  0012f	79 17		 jns	 SHORT $LN105@dec_10i40_

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00131	f7 d0		 not	 eax
  00133	d1 f8		 sar	 eax, 1
  00135	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  00137	eb 11		 jmp	 SHORT $LN104@dec_10i40_
$LN101@dec_10i40_:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  00139	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00143	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN105@dec_10i40_:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00148	d1 f8		 sar	 eax, 1
$LN104@dec_10i40_:

; 139  :     L_sum = (Word32) var1 + var2;

  0014a	98		 cwde
  0014b	8d 77 fb	 lea	 esi, DWORD PTR [edi-5]
  0014e	03 c6		 add	 eax, esi

; 79   :     if (L_var1 > 0X00007fffL)

  00150	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00155	7e 11		 jle	 SHORT $LN131@dec_10i40_

; 80   :     {
; 81   :         Overflow = 1;

  00157	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00161	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00166	eb 1b		 jmp	 SHORT $LN128@dec_10i40_
$LN131@dec_10i40_:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00168	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0016d	7d 11		 jge	 SHORT $LN129@dec_10i40_

; 85   :     {
; 86   :         Overflow = 1;

  0016f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00179	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0017e	eb 03		 jmp	 SHORT $LN128@dec_10i40_
$LN129@dec_10i40_:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00180	0f b7 c0	 movzx	 eax, ax
$LN128@dec_10i40_:

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00183	0f bf f0	 movsx	 esi, ax
  00186	8b c6		 mov	 eax, esi
  00188	2b c2		 sub	 eax, edx

; 79   :     if (L_var1 > 0X00007fffL)

  0018a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0018f	7e 0c		 jle	 SHORT $LN143@dec_10i40_

; 80   :     {
; 81   :         Overflow = 1;

  00191	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0019b	eb 31		 jmp	 SHORT $LN1@dec_10i40_
$LN143@dec_10i40_:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0019d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001a2	7d 0c		 jge	 SHORT $LN141@dec_10i40_

; 85   :     {
; 86   :         Overflow = 1;

  001a4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  001ae	eb 05		 jmp	 SHORT $LN184@dec_10i40_
$LN141@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 106  :         if (sub (pos2, pos1) < 0)

  001b0	66 85 c0	 test	 ax, ax
  001b3	79 19		 jns	 SHORT $LN1@dec_10i40_
$LN184@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  001b5	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001ba	66 3b c8	 cmp	 cx, ax
  001bd	75 07		 jne	 SHORT $LN150@dec_10i40_
  001bf	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001c4	eb 05		 jmp	 SHORT $LN151@dec_10i40_
$LN150@dec_10i40_:
  001c6	f7 d9		 neg	 ecx
  001c8	0f b7 c1	 movzx	 eax, cx
$LN151@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 108  :             sign = negate (sign);

  001cb	0f b7 c8	 movzx	 ecx, ax
$LN1@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  001ce	8b 45 fc	 mov	 eax, DWORD PTR _cod$1$[ebp]
  001d1	0f bf 14 70	 movsx	 edx, WORD PTR [eax+esi*2]
  001d5	0f bf c1	 movsx	 eax, cx
  001d8	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  001da	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  001e0	7e 11		 jle	 SHORT $LN157@dec_10i40_

; 80   :     {
; 81   :         Overflow = 1;

  001e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001ec	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001f1	eb 1c		 jmp	 SHORT $LN154@dec_10i40_
$LN157@dec_10i40_:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001f3	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  001f9	7d 11		 jge	 SHORT $LN155@dec_10i40_

; 85   :     {
; 86   :         Overflow = 1;

  001fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00205	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0020a	eb 03		 jmp	 SHORT $LN154@dec_10i40_
$LN155@dec_10i40_:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0020c	0f b7 c2	 movzx	 eax, dx
$LN154@dec_10i40_:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d1035pf.c

; 110  :         cod[pos2] = add (cod[pos2], sign);              move16 (); 

  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _cod$1$[ebp]
  00212	83 c3 02	 add	 ebx, 2
  00215	47		 inc	 edi
  00216	ff 4d f8	 dec	 DWORD PTR tv756[ebp]
  00219	66 89 04 71	 mov	 WORD PTR [ecx+esi*2], ax
  0021d	0f 85 13 fe ff
	ff		 jne	 $LL6@dec_10i40_
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx

; 111  :     }
; 112  : 
; 113  :     return;
; 114  : }

  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
_dec_10i40_35bits ENDP
_TEXT	ENDS
END
