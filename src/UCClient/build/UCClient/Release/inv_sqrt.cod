; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\inv_sqrt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_table	DW	07fffH
	DW	07c2eH
	DW	078aeH
	DW	07576H
	DW	0727dH
	DW	06fbaH
	DW	06d29H
	DW	06ac2H
	DW	06883H
	DW	06666H
	DW	06469H
	DW	06289H
	DW	060c2H
	DW	05f13H
	DW	05d7aH
	DW	05bf5H
	DW	05a82H
	DW	05921H
	DW	057cfH
	DW	0568bH
	DW	05555H
	DW	0542cH
	DW	0530fH
	DW	051fcH
	DW	050f4H
	DW	04ff6H
	DW	04f01H
	DW	04e14H
	DW	04d30H
	DW	04c53H
	DW	04b7eH
	DW	04aafH
	DW	049e7H
	DW	04925H
	DW	04868H
	DW	047b2H
	DW	04700H
	DW	04654H
	DW	045adH
	DW	0450aH
	DW	0446bH
	DW	043d1H
	DW	0433bH
	DW	042a8H
	DW	04219H
	DW	0418eH
	DW	04106H
	DW	04082H
	DW	04000H
PUBLIC	_Inv_sqrt
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c
;	COMDAT _Inv_sqrt
_TEXT	SEGMENT
_Inv_sqrt PROC						; COMDAT
; _L_x$ = ecx

; 63   :     Word16 exp, i, a, tmp;
; 64   :     Word32 L_y;
; 65   : 
; 66   :     test (); 
; 67   :     if (L_x <= (Word32) 0)

  00000	85 c9		 test	 ecx, ecx
  00002	7f 06		 jg	 SHORT $LN2@Inv_sqrt

; 68   :         return ((Word32) 0x3fffffffL);

  00004	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 97   : }

  00009	c3		 ret	 0
$LN2@Inv_sqrt:

; 69   : 
; 70   :     exp = norm_l (L_x);

  0000a	8b c1		 mov	 eax, ecx
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  0000e	83 f9 ff	 cmp	 ecx, -1
  00011	75 05		 jne	 SHORT $LN12@Inv_sqrt

; 2116 :         {
; 2117 :             var_out = 31;

  00013	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  00016	eb 14		 jmp	 SHORT $LN7@Inv_sqrt
$LN12@Inv_sqrt:

; 2120 :         {
; 2121 :             if (L_var1 < 0)
; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;
; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00018	33 f6		 xor	 esi, esi
  0001a	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00020	7d 0a		 jge	 SHORT $LN7@Inv_sqrt
$LL9@Inv_sqrt:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00022	03 c0		 add	 eax, eax
  00024	46		 inc	 esi
  00025	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0002a	7c f6		 jl	 SHORT $LL9@Inv_sqrt
$LN7@Inv_sqrt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 71   :     L_x = L_shl (L_x, exp);     /* L_x is normalize */

  0002c	8b d6		 mov	 edx, esi
  0002e	e8 00 00 00 00	 call	 _L_shl
  00033	8b d0		 mov	 edx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00035	0f bf ce	 movsx	 ecx, si
  00038	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  0003d	2b c1		 sub	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  0003f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00044	7e 11		 jle	 SHORT $LN22@Inv_sqrt

; 80   :     {
; 81   :         Overflow = 1;

  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00050	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00055	eb 1b		 jmp	 SHORT $LN19@Inv_sqrt
$LN22@Inv_sqrt:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00057	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0005c	7d 11		 jge	 SHORT $LN20@Inv_sqrt

; 85   :     {
; 86   :         Overflow = 1;

  0005e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00068	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0006d	eb 03		 jmp	 SHORT $LN19@Inv_sqrt
$LN20@Inv_sqrt:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0006f	0f b7 c0	 movzx	 eax, ax
$LN19@Inv_sqrt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 75   :     if ((exp & 1) == 0)         /* If exponent even -> shift right */

  00072	a8 01		 test	 al, 1
  00074	75 0e		 jne	 SHORT $LN31@Inv_sqrt
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  00076	85 d2		 test	 edx, edx
  00078	79 08		 jns	 SHORT $LN32@Inv_sqrt

; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0007a	f7 d2		 not	 edx
  0007c	d1 fa		 sar	 edx, 1
  0007e	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  00080	eb 02		 jmp	 SHORT $LN31@Inv_sqrt
$LN32@Inv_sqrt:

; 1443 :                 L_var_out = L_var1 >> var2;

  00082	d1 fa		 sar	 edx, 1
$LN31@Inv_sqrt:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);
; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;
; 304  :         }
; 305  :         else
; 306  :         {
; 307  :             var_out = extract_l (result);
; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)

  00084	66 85 c0	 test	 ax, ax
  00087	79 09		 jns	 SHORT $LN41@Inv_sqrt

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00089	98		 cwde
  0008a	f7 d0		 not	 eax
  0008c	d1 f8		 sar	 eax, 1
  0008e	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00090	eb 03		 jmp	 SHORT $LN119@Inv_sqrt
$LN41@Inv_sqrt:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00092	66 d1 f8	 sar	 ax, 1
$LN119@Inv_sqrt:
  00095	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00098	98		 cwde
  00099	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0009a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0009f	7e 11		 jle	 SHORT $LN54@Inv_sqrt

; 80   :     {
; 81   :         Overflow = 1;

  000a1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000ab	bb ff 7f 00 00	 mov	 ebx, 32767		; 00007fffH
  000b0	eb 1b		 jmp	 SHORT $LN51@Inv_sqrt
$LN54@Inv_sqrt:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000b2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000b7	7d 11		 jge	 SHORT $LN52@Inv_sqrt

; 85   :     {
; 86   :         Overflow = 1;

  000b9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000c3	bb 00 80 ff ff	 mov	 ebx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000c8	eb 03		 jmp	 SHORT $LN51@Inv_sqrt
$LN52@Inv_sqrt:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000ca	0f b7 d8	 movzx	 ebx, ax
$LN51@Inv_sqrt:

; 1437 :             if (L_var1 < 0)

  000cd	85 d2		 test	 edx, edx
  000cf	79 09		 jns	 SHORT $LN60@Inv_sqrt

; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  000d1	f7 d2		 not	 edx
  000d3	c1 fa 09	 sar	 edx, 9
  000d6	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  000d8	eb 03		 jmp	 SHORT $LN59@Inv_sqrt
$LN60@Inv_sqrt:

; 1443 :                 L_var_out = L_var1 >> var2;

  000da	c1 fa 09	 sar	 edx, 9
$LN59@Inv_sqrt:

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;
; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)
; 488  :     {
; 489  :         L_var_out *= 2;
; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;
; 494  :         L_var_out = MAX_32;
; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  000dd	8b c2		 mov	 eax, edx
  000df	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 83   :     i = extract_h (L_x);        /* Extract b25-b31 */

  000e2	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  000e5	85 d2		 test	 edx, edx
  000e7	79 08		 jns	 SHORT $LN71@Inv_sqrt

; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  000e9	f7 d2		 not	 edx
  000eb	d1 fa		 sar	 edx, 1
  000ed	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  000ef	eb 02		 jmp	 SHORT $LN70@Inv_sqrt
$LN71@Inv_sqrt:

; 1443 :                 L_var_out = L_var1 >> var2;

  000f1	d1 fa		 sar	 edx, 1
$LN70@Inv_sqrt:

; 186  :     L_diff = (Word32) var1 - var2;

  000f3	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 86   :     a = a & (Word16) 0x7fff;    logic16 (); 

  000f4	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000fa	83 e8 10	 sub	 eax, 16			; 00000010H

; 79   :     if (L_var1 > 0X00007fffL)

  000fd	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00102	7e 11		 jle	 SHORT $LN88@Inv_sqrt

; 80   :     {
; 81   :         Overflow = 1;

  00104	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0010e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00113	eb 1b		 jmp	 SHORT $LN85@Inv_sqrt
$LN88@Inv_sqrt:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00115	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0011a	7d 11		 jge	 SHORT $LN86@Inv_sqrt

; 85   :     {
; 86   :         Overflow = 1;

  0011c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00126	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0012b	eb 03		 jmp	 SHORT $LN85@Inv_sqrt
$LN86@Inv_sqrt:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0012d	0f b7 c0	 movzx	 eax, ax
$LN85@Inv_sqrt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 90   :     L_y = L_deposit_h (table[i]);       /* table[i] << 16          */

  00130	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1675 :     L_var_out = (Word32) var1 << 16;

  00131	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _table[eax*2]

; 186  :     L_diff = (Word32) var1 - var2;

  00139	0f bf 04 45 02
	00 00 00	 movsx	 eax, WORD PTR _table[eax*2+2]

; 1675 :     L_var_out = (Word32) var1 << 16;

  00141	8b f1		 mov	 esi, ecx

; 186  :     L_diff = (Word32) var1 - var2;

  00143	2b c8		 sub	 ecx, eax

; 1675 :     L_var_out = (Word32) var1 << 16;

  00145	c1 e6 10	 shl	 esi, 16			; 00000010H

; 79   :     if (L_var1 > 0X00007fffL)

  00148	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0014e	7e 11		 jle	 SHORT $LN100@Inv_sqrt

; 80   :     {
; 81   :         Overflow = 1;

  00150	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0015a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0015f	eb 1c		 jmp	 SHORT $LN97@Inv_sqrt
$LN100@Inv_sqrt:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00161	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00167	7d 11		 jge	 SHORT $LN98@Inv_sqrt

; 85   :     {
; 86   :         Overflow = 1;

  00169	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00173	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00178	eb 03		 jmp	 SHORT $LN97@Inv_sqrt
$LN98@Inv_sqrt:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0017a	0f b7 c1	 movzx	 eax, cx
$LN97@Inv_sqrt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 92   :     L_y = L_msu (L_y, tmp, a);  /* L_y -=  tmp*a*2         */

  0017d	52		 push	 edx
  0017e	8b d0		 mov	 edx, eax
  00180	8b ce		 mov	 ecx, esi
  00182	e8 00 00 00 00	 call	 _L_msu
  00187	83 c4 04	 add	 esp, 4

; 93   : 
; 94   :     L_y = L_shr (L_y, exp);     /* denormalization */

  0018a	0f b7 d3	 movzx	 edx, bx
  0018d	8b c8		 mov	 ecx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1420 :     if (var2 < 0)

  0018f	66 85 db	 test	 bx, bx
  00192	79 14		 jns	 SHORT $LN111@Inv_sqrt

; 1421 :     {
; 1422 :         if (var2 < -32)

  00194	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  00199	66 3b d8	 cmp	 bx, ax
  0019c	5e		 pop	 esi
  0019d	0f 4c d0	 cmovl	 edx, eax

; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);

  001a0	f7 da		 neg	 edx
  001a2	5b		 pop	 ebx
  001a3	e9 00 00 00 00	 jmp	 _L_shl
$LN111@Inv_sqrt:

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)

  001a8	66 83 fb 1f	 cmp	 bx, 31			; 0000001fH
  001ac	7c 0b		 jl	 SHORT $LN108@Inv_sqrt

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  001ae	33 c0		 xor	 eax, eax
  001b0	85 c9		 test	 ecx, ecx
  001b2	5e		 pop	 esi
  001b3	0f 99 c0	 setns	 al
  001b6	48		 dec	 eax
  001b7	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 97   : }

  001b8	c3		 ret	 0
$LN108@Inv_sqrt:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  001b9	8b c1		 mov	 eax, ecx
  001bb	85 c9		 test	 ecx, ecx
  001bd	8a cb		 mov	 cl, bl
  001bf	79 09		 jns	 SHORT $LN106@Inv_sqrt
  001c1	f7 d0		 not	 eax
  001c3	d3 f8		 sar	 eax, cl
  001c5	5e		 pop	 esi
  001c6	f7 d0		 not	 eax
  001c8	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 97   : }

  001c9	c3		 ret	 0
$LN106@Inv_sqrt:
  001ca	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1443 :                 L_var_out = L_var1 >> var2;

  001cb	d3 f8		 sar	 eax, cl
  001cd	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\inv_sqrt.c

; 97   : }

  001ce	c3		 ret	 0
_Inv_sqrt ENDP
_TEXT	ENDS
END
