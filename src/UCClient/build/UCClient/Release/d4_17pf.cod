; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d4_17pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_dgray	DW	00H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	06H
	DW	04H
	DW	07H
PUBLIC	_decode_4i40_17bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c
;	COMDAT _decode_4i40_17bits
_TEXT	SEGMENT
tv1093 = -28						; size = 4
tv1091 = -24						; size = 4
_i$1$ = -20						; size = 4
tv1114 = -20						; size = 4
tv1113 = -20						; size = 4
_i$4$ = -16						; size = 4
_i$3$ = -16						; size = 4
_i$2$ = -16						; size = 4
tv534 = -16						; size = 4
_pos$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_cod$ = 8						; size = 4
_decode_4i40_17bits PROC				; COMDAT
; _sign$ = ecx
; _index$ = dx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _cod$[ebp]
  00014	56		 push	 esi

; 68   :     i = dgray[i];                                        move16 ();

  00015	0f bf f2	 movsx	 esi, dx
  00018	8b c6		 mov	 eax, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0001a	c7 45 e4 00 80
	ff ff		 mov	 DWORD PTR tv1093[ebp], -32768 ; ffff8000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 67   :     i = index & 7;                                       logic16 ();

  00021	83 e0 07	 and	 eax, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00024	c7 45 e8 ff 7f
	00 00		 mov	 DWORD PTR tv1091[ebp], 32767 ; 00007fffH
  0002b	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 68   :     i = dgray[i];                                        move16 ();

  0002c	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _dgray[eax*2]
  00034	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00037	98		 cwde
  00038	89 45 f0	 mov	 DWORD PTR tv534[ebp], eax
  0003b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00042	0f bf c7	 movsx	 eax, di
  00045	3b f8		 cmp	 edi, eax
  00047	74 1b		 je	 SHORT $LN18@decode_4i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00049	66 83 7d ec 00	 cmp	 WORD PTR _i$1$[ebp], 0
  0004e	8b 45 e4	 mov	 eax, DWORD PTR tv1093[ebp]
  00051	0f 4f 45 e8	 cmovg	 eax, DWORD PTR tv1091[ebp]
  00055	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0005f	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00062	eb 03		 jmp	 SHORT $LN15@decode_4i4
$LN18@decode_4i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00064	0f b7 c7	 movzx	 eax, di
$LN15@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00067	98		 cwde
  00068	03 45 f0	 add	 eax, DWORD PTR tv534[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  0006b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00070	7e 11		 jle	 SHORT $LN31@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  00072	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0007c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00081	eb 1b		 jmp	 SHORT $LN28@decode_4i4
$LN31@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00083	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00088	7d 11		 jge	 SHORT $LN29@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00094	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00099	eb 03		 jmp	 SHORT $LN28@decode_4i4
$LN29@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0009b	0f b7 c0	 movzx	 eax, ax
$LN28@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 70   :     pos[0] = add(i, shl(i, 2));   /* pos0 =i*5 */        move16 ();

  0009e	66 89 45 f4	 mov	 WORD PTR _pos$[ebp], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  000a2	66 85 d2	 test	 dx, dx
  000a5	79 0c		 jns	 SHORT $LN39@decode_4i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  000a7	f7 d6		 not	 esi
  000a9	c1 fe 03	 sar	 esi, 3
  000ac	f7 d6		 not	 esi
  000ae	0f b7 f6	 movzx	 esi, si

; 378  :             }
; 379  :             else

  000b1	eb 07		 jmp	 SHORT $LN38@decode_4i4
$LN39@decode_4i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000b3	66 c1 fa 03	 sar	 dx, 3
  000b7	0f b7 f2	 movzx	 esi, dx
$LN38@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 74   :     i = dgray[i];                                        move16 ();

  000ba	0f bf d6	 movsx	 edx, si
  000bd	8b c2		 mov	 eax, edx
  000bf	83 e0 07	 and	 eax, 7
  000c2	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _dgray[eax*2]
  000ca	89 45 f0	 mov	 DWORD PTR _i$2$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000cd	98		 cwde
  000ce	89 45 ec	 mov	 DWORD PTR tv1114[ebp], eax
  000d1	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000d8	0f bf c7	 movsx	 eax, di
  000db	3b f8		 cmp	 edi, eax
  000dd	74 1b		 je	 SHORT $LN54@decode_4i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  000df	66 83 7d f0 00	 cmp	 WORD PTR _i$2$[ebp], 0
  000e4	8b 45 e4	 mov	 eax, DWORD PTR tv1093[ebp]
  000e7	0f 4f 45 e8	 cmovg	 eax, DWORD PTR tv1091[ebp]
  000eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000f5	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  000f8	eb 03		 jmp	 SHORT $LN51@decode_4i4
$LN54@decode_4i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000fa	0f b7 c7	 movzx	 eax, di
$LN51@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  000fd	98		 cwde
  000fe	03 45 ec	 add	 eax, DWORD PTR tv1114[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  00101	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00106	7e 11		 jle	 SHORT $LN67@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  00108	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00112	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00117	eb 1b		 jmp	 SHORT $LN64@decode_4i4
$LN67@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00119	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0011e	7d 11		 jge	 SHORT $LN65@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  00120	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0012a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0012f	eb 03		 jmp	 SHORT $LN64@decode_4i4
$LN65@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00131	0f b7 c0	 movzx	 eax, ax
$LN64@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00134	98		 cwde
  00135	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00136	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0013b	7e 11		 jle	 SHORT $LN77@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  0013d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00147	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0014c	eb 1b		 jmp	 SHORT $LN74@decode_4i4
$LN77@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0014e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00153	7d 11		 jge	 SHORT $LN75@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  00155	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0015f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00164	eb 03		 jmp	 SHORT $LN74@decode_4i4
$LN75@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00166	0f b7 c0	 movzx	 eax, ax
$LN74@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 77   :     pos[1] = add(i, 1);                                  move16 ();

  00169	66 89 45 f6	 mov	 WORD PTR _pos$[ebp+2], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0016d	66 85 f6	 test	 si, si
  00170	79 0c		 jns	 SHORT $LN85@decode_4i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00172	f7 d2		 not	 edx
  00174	c1 fa 03	 sar	 edx, 3
  00177	f7 d2		 not	 edx
  00179	0f b7 f2	 movzx	 esi, dx

; 378  :             }
; 379  :             else

  0017c	eb 07		 jmp	 SHORT $LN84@decode_4i4
$LN85@decode_4i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0017e	66 c1 fe 03	 sar	 si, 3
  00182	0f b7 f6	 movzx	 esi, si
$LN84@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 81   :     i = dgray[i];                                        move16 ();

  00185	0f bf d6	 movsx	 edx, si
  00188	8b c2		 mov	 eax, edx
  0018a	83 e0 07	 and	 eax, 7
  0018d	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _dgray[eax*2]
  00195	89 45 f0	 mov	 DWORD PTR _i$3$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00198	98		 cwde
  00199	89 45 ec	 mov	 DWORD PTR tv1113[ebp], eax
  0019c	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  001a3	0f bf c7	 movsx	 eax, di
  001a6	3b f8		 cmp	 edi, eax
  001a8	74 1b		 je	 SHORT $LN100@decode_4i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  001aa	66 83 7d f0 00	 cmp	 WORD PTR _i$3$[ebp], 0
  001af	8b 45 e4	 mov	 eax, DWORD PTR tv1093[ebp]
  001b2	0f 4f 45 e8	 cmovg	 eax, DWORD PTR tv1091[ebp]
  001b6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001c0	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  001c3	eb 03		 jmp	 SHORT $LN97@decode_4i4
$LN100@decode_4i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  001c5	0f b7 c7	 movzx	 eax, di
$LN97@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001c8	98		 cwde
  001c9	03 45 ec	 add	 eax, DWORD PTR tv1113[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  001cc	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001d1	7e 11		 jle	 SHORT $LN113@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  001d3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001dd	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001e2	eb 1b		 jmp	 SHORT $LN110@decode_4i4
$LN113@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001e4	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001e9	7d 11		 jge	 SHORT $LN111@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  001eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001f5	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001fa	eb 03		 jmp	 SHORT $LN110@decode_4i4
$LN111@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  001fc	0f b7 c0	 movzx	 eax, ax
$LN110@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  001ff	98		 cwde
  00200	83 c0 02	 add	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  00203	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00208	7e 11		 jle	 SHORT $LN123@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  0020a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00214	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00219	eb 1b		 jmp	 SHORT $LN120@decode_4i4
$LN123@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0021b	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00220	7d 11		 jge	 SHORT $LN121@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  00222	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0022c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00231	eb 03		 jmp	 SHORT $LN120@decode_4i4
$LN121@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00233	0f b7 c0	 movzx	 eax, ax
$LN120@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 84   :     pos[2] = add(i, 2);                                  move16 ();

  00236	66 89 45 f8	 mov	 WORD PTR _pos$[ebp+4], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0023a	66 85 f6	 test	 si, si
  0023d	79 0c		 jns	 SHORT $LN131@decode_4i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0023f	f7 d2		 not	 edx
  00241	c1 fa 03	 sar	 edx, 3
  00244	f7 d2		 not	 edx
  00246	0f b7 c2	 movzx	 eax, dx

; 378  :             }
; 379  :             else

  00249	eb 07		 jmp	 SHORT $LN130@decode_4i4
$LN131@decode_4i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0024b	66 c1 fe 03	 sar	 si, 3
  0024f	0f b7 c6	 movzx	 eax, si
$LN130@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 87   :     j = index & 1;                                       logic16 ();

  00252	8b f0		 mov	 esi, eax
  00254	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00257	66 85 c0	 test	 ax, ax
  0025a	79 09		 jns	 SHORT $LN142@decode_4i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0025c	98		 cwde
  0025d	f7 d0		 not	 eax
  0025f	d1 f8		 sar	 eax, 1
  00261	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00263	eb 03		 jmp	 SHORT $LN235@decode_4i4
$LN142@decode_4i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00265	66 d1 f8	 sar	 ax, 1
$LN235@decode_4i4:
  00268	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 89   :     i = index & 7;                                       logic16 ();

  0026b	83 e0 07	 and	 eax, 7

; 90   :     i = dgray[i];                                        move16 ();

  0026e	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _dgray[eax*2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00276	0f bf f8	 movsx	 edi, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 90   :     i = dgray[i];                                        move16 ();

  00279	89 45 f0	 mov	 DWORD PTR _i$4$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0027c	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00283	0f bf c2	 movsx	 eax, dx
  00286	3b d0		 cmp	 edx, eax
  00288	74 1b		 je	 SHORT $LN157@decode_4i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0028a	66 83 7d f0 00	 cmp	 WORD PTR _i$4$[ebp], 0
  0028f	8b 45 e4	 mov	 eax, DWORD PTR tv1093[ebp]
  00292	0f 4f 45 e8	 cmovg	 eax, DWORD PTR tv1091[ebp]
  00296	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  002a0	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  002a3	eb 03		 jmp	 SHORT $LN154@decode_4i4
$LN157@decode_4i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  002a5	0f b7 c2	 movzx	 eax, dx
$LN154@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  002a8	98		 cwde
  002a9	03 c7		 add	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  002ab	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002b0	7e 11		 jle	 SHORT $LN170@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  002b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002bc	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002c1	eb 1b		 jmp	 SHORT $LN167@decode_4i4
$LN170@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002c3	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002c8	7d 11		 jge	 SHORT $LN168@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  002ca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002d4	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002d9	eb 03		 jmp	 SHORT $LN167@decode_4i4
$LN168@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002db	0f b7 c0	 movzx	 eax, ax
$LN167@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  002de	98		 cwde
  002df	83 c0 03	 add	 eax, 3

; 79   :     if (L_var1 > 0X00007fffL)

  002e2	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002e7	7e 11		 jle	 SHORT $LN180@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  002e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002f3	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002f8	eb 1b		 jmp	 SHORT $LN177@decode_4i4
$LN180@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002fa	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002ff	7d 11		 jge	 SHORT $LN178@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  00301	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0030b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00310	eb 03		 jmp	 SHORT $LN177@decode_4i4
$LN178@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00312	0f b7 c0	 movzx	 eax, ax
$LN177@decode_4i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00315	0f bf d0	 movsx	 edx, ax
  00318	0f bf c6	 movsx	 eax, si
  0031b	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0031d	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00323	7e 11		 jle	 SHORT $LN190@decode_4i4

; 80   :     {
; 81   :         Overflow = 1;

  00325	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0032f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00334	eb 1c		 jmp	 SHORT $LN187@decode_4i4
$LN190@decode_4i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00336	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0033c	7d 11		 jge	 SHORT $LN188@decode_4i4

; 85   :     {
; 86   :         Overflow = 1;

  0033e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00348	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0034d	eb 03		 jmp	 SHORT $LN187@decode_4i4
$LN188@decode_4i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0034f	0f b7 c2	 movzx	 eax, dx
$LN187@decode_4i4:
  00352	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 94   :     pos[3] = add(i, j);                                  move16 ();

  00355	66 89 45 fa	 mov	 WORD PTR _pos$[ebp+6], ax

; 95   : 
; 96   :     /* decode the signs  and build the codeword */
; 97   : 
; 98   :     for (i = 0; i < L_SUBFR; i++) {
; 99   :         cod[i] = 0;                                      move16 ();

  00359	f3 0f 7f 03	 movdqu	 XMMWORD PTR [ebx], xmm0

; 100  :     }
; 101  : 
; 102  :     for (j = 0; j < NB_PULSE; j++) {

  0035d	8d 55 f4	 lea	 edx, DWORD PTR _pos$[ebp]
  00360	bf 04 00 00 00	 mov	 edi, 4
  00365	f3 0f 7f 43 10	 movdqu	 XMMWORD PTR [ebx+16], xmm0
  0036a	f3 0f 7f 43 20	 movdqu	 XMMWORD PTR [ebx+32], xmm0
  0036f	f3 0f 7f 43 30	 movdqu	 XMMWORD PTR [ebx+48], xmm0
  00374	f3 0f 7f 43 40	 movdqu	 XMMWORD PTR [ebx+64], xmm0
  00379	8d a4 24 00 00
	00 00		 npad	 7
$LL5@decode_4i4:

; 103  :         i = sign & 1;                                    logic16 ();

  00380	8b f1		 mov	 esi, ecx
  00382	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00385	66 85 c9	 test	 cx, cx
  00388	79 0e		 jns	 SHORT $LN202@decode_4i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0038a	0f bf c1	 movsx	 eax, cx
  0038d	f7 d0		 not	 eax
  0038f	d1 f8		 sar	 eax, 1
  00391	f7 d0		 not	 eax
  00393	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  00396	eb 06		 jmp	 SHORT $LN201@decode_4i4
$LN202@decode_4i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00398	66 d1 f9	 sar	 cx, 1
  0039b	0f b7 c1	 movzx	 eax, cx
$LN201@decode_4i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d4_17pf.c

; 104  :         sign = shr(sign, 1);

  0039e	0f b7 c8	 movzx	 ecx, ax

; 105  : 
; 106  :         test ();
; 107  :         if (i != 0) {

  003a1	66 85 f6	 test	 si, si

; 108  :             cod[pos[j]] = 8191;                          move16 ();

  003a4	0f bf 02	 movsx	 eax, WORD PTR [edx]
  003a7	be ff 1f 00 00	 mov	 esi, 8191		; 00001fffH
  003ac	75 05		 jne	 SHORT $LN236@decode_4i4

; 109  :         } else {
; 110  :             cod[pos[j]] = -8192;                         move16 ();

  003ae	be 00 e0 ff ff	 mov	 esi, -8192		; ffffe000H
$LN236@decode_4i4:

; 100  :     }
; 101  : 
; 102  :     for (j = 0; j < NB_PULSE; j++) {

  003b3	83 c2 02	 add	 edx, 2

; 109  :         } else {
; 110  :             cod[pos[j]] = -8192;                         move16 ();

  003b6	66 89 34 43	 mov	 WORD PTR [ebx+eax*2], si
  003ba	4f		 dec	 edi
  003bb	75 c3		 jne	 SHORT $LL5@decode_4i4

; 111  :         }
; 112  :     }
; 113  : 
; 114  :     return;
; 115  : }

  003bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c0	5f		 pop	 edi
  003c1	5e		 pop	 esi
  003c2	33 cd		 xor	 ecx, ebp
  003c4	5b		 pop	 ebx
  003c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
_decode_4i40_17bits ENDP
_TEXT	ENDS
END
