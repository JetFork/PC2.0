; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d3_14pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_decode_3i40_14bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c
;	COMDAT _decode_3i40_14bits
_TEXT	SEGMENT
tv1120 = -32						; size = 4
_j$1$ = -28						; size = 4
tv1119 = -28						; size = 4
_result$1$ = -24					; size = 4
tv1121 = -24						; size = 4
tv1104 = -20						; size = 4
tv1102 = -16						; size = 4
_pos$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_cod$ = 8						; size = 4
_decode_3i40_14bits PROC				; COMDAT
; _sign$ = ecx
; _index$ = edx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _cod$[ebp]
  00014	56		 push	 esi

; 65   :     i = index & 7;                                       logic16 ();

  00015	8b f2		 mov	 esi, edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00017	c7 45 ec 00 80
	ff ff		 mov	 DWORD PTR tv1104[ebp], -32768 ; ffff8000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 65   :     i = index & 7;                                       logic16 ();

  0001e	83 e6 07	 and	 esi, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00021	c7 45 f0 ff 7f
	00 00		 mov	 DWORD PTR tv1102[ebp], 32767 ; 00007fffH
  00028	0f bf c6	 movsx	 eax, si
  0002b	57		 push	 edi

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0002c	89 45 e8	 mov	 DWORD PTR tv1121[ebp], eax
  0002f	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00036	0f bf c7	 movsx	 eax, di
  00039	3b f8		 cmp	 edi, eax
  0003b	74 19		 je	 SHORT $LN16@decode_3i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0003d	8b 45 ec	 mov	 eax, DWORD PTR tv1104[ebp]
  00040	66 85 f6	 test	 si, si
  00043	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0004d	0f 4f 45 f0	 cmovg	 eax, DWORD PTR tv1102[ebp]
  00051	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00054	eb 03		 jmp	 SHORT $LN13@decode_3i4
$LN16@decode_3i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00056	0f b7 c7	 movzx	 eax, di
$LN13@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00059	98		 cwde
  0005a	03 45 e8	 add	 eax, DWORD PTR tv1121[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  0005d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00062	7e 11		 jle	 SHORT $LN29@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  00064	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0006e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00073	eb 1b		 jmp	 SHORT $LN26@decode_3i4
$LN29@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00075	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0007a	7d 11		 jge	 SHORT $LN27@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  0007c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00086	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0008b	eb 03		 jmp	 SHORT $LN26@decode_3i4
$LN27@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0008d	0f b7 c0	 movzx	 eax, ax
$LN26@decode_3i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 67   :     pos[0] = add(i, shl(i, 2));   /* pos0 =i*5 */        move16 ();

  00090	66 89 45 f4	 mov	 WORD PTR _pos$[ebp], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00094	66 85 d2	 test	 dx, dx
  00097	79 0f		 jns	 SHORT $LN37@decode_3i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00099	0f bf c2	 movsx	 eax, dx
  0009c	f7 d0		 not	 eax
  0009e	c1 f8 03	 sar	 eax, 3
  000a1	f7 d0		 not	 eax
  000a3	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  000a6	eb 07		 jmp	 SHORT $LN36@decode_3i4
$LN37@decode_3i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000a8	66 c1 fa 03	 sar	 dx, 3
  000ac	0f b7 c2	 movzx	 eax, dx
$LN36@decode_3i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 70   :     j = index & 1;                                       logic16 ();

  000af	8b f0		 mov	 esi, eax
  000b1	83 e6 01	 and	 esi, 1
  000b4	89 75 e4	 mov	 DWORD PTR _j$1$[ebp], esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  000b7	66 85 c0	 test	 ax, ax
  000ba	79 09		 jns	 SHORT $LN48@decode_3i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  000bc	98		 cwde
  000bd	f7 d0		 not	 eax
  000bf	d1 f8		 sar	 eax, 1
  000c1	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  000c3	eb 03		 jmp	 SHORT $LN226@decode_3i4
$LN48@decode_3i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  000c5	66 d1 f8	 sar	 ax, 1
$LN226@decode_3i4:
  000c8	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 72   :     i = index & 7;                                       logic16 ();

  000cb	8b fa		 mov	 edi, edx
  000cd	83 e7 07	 and	 edi, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000d0	0f bf c7	 movsx	 eax, di
  000d3	89 45 e0	 mov	 DWORD PTR tv1120[ebp], eax
  000d6	c1 e0 02	 shl	 eax, 2
  000d9	89 45 e8	 mov	 DWORD PTR _result$1$[ebp], eax

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000dc	98		 cwde
  000dd	39 45 e8	 cmp	 DWORD PTR _result$1$[ebp], eax
  000e0	74 16		 je	 SHORT $LN61@decode_3i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  000e2	8b 45 ec	 mov	 eax, DWORD PTR tv1104[ebp]
  000e5	66 85 ff	 test	 di, di
  000e8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000f2	0f 4f 45 f0	 cmovg	 eax, DWORD PTR tv1102[ebp]

; 304  :         }
; 305  :         else

  000f6	eb 03		 jmp	 SHORT $LN227@decode_3i4
$LN61@decode_3i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _result$1$[ebp]
$LN227@decode_3i4:
  000fb	0f b7 c0	 movzx	 eax, ax

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  000fe	98		 cwde
  000ff	03 45 e0	 add	 eax, DWORD PTR tv1120[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  00102	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00107	7e 11		 jle	 SHORT $LN74@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  00109	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00113	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00118	eb 1b		 jmp	 SHORT $LN71@decode_3i4
$LN74@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0011a	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0011f	7d 11		 jge	 SHORT $LN72@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  00121	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0012b	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00130	eb 03		 jmp	 SHORT $LN71@decode_3i4
$LN72@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00132	0f b7 c0	 movzx	 eax, ax
$LN71@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00135	98		 cwde
  00136	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00137	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0013c	7e 11		 jle	 SHORT $LN84@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  0013e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00148	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  0014d	eb 1b		 jmp	 SHORT $LN81@decode_3i4
$LN84@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0014f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00154	7d 11		 jge	 SHORT $LN82@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  00156	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00160	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00165	eb 03		 jmp	 SHORT $LN81@decode_3i4
$LN82@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00167	0f b7 f8	 movzx	 edi, ax
$LN81@decode_3i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0016a	0f bf f6	 movsx	 esi, si
  0016d	03 f6		 add	 esi, esi

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0016f	0f bf c6	 movsx	 eax, si
  00172	3b f0		 cmp	 esi, eax
  00174	74 1b		 je	 SHORT $LN92@decode_3i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00176	66 83 7d e4 00	 cmp	 WORD PTR _j$1$[ebp], 0
  0017b	8b 45 ec	 mov	 eax, DWORD PTR tv1104[ebp]
  0017e	0f 4f 45 f0	 cmovg	 eax, DWORD PTR tv1102[ebp]
  00182	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0018c	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0018f	eb 03		 jmp	 SHORT $LN89@decode_3i4
$LN92@decode_3i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00191	0f b7 c6	 movzx	 eax, si
$LN89@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00194	0f bf f0	 movsx	 esi, ax
  00197	0f bf c7	 movsx	 eax, di
  0019a	03 f0		 add	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0019c	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  001a2	7e 11		 jle	 SHORT $LN105@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  001a4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001ae	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001b3	eb 1c		 jmp	 SHORT $LN102@decode_3i4
$LN105@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b5	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  001bb	7d 11		 jge	 SHORT $LN103@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  001bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001c7	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001cc	eb 03		 jmp	 SHORT $LN102@decode_3i4
$LN103@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  001ce	0f b7 c6	 movzx	 eax, si
$LN102@decode_3i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 77   :     pos[1] = add(i, j);                                  move16 ();

  001d1	66 89 45 f6	 mov	 WORD PTR _pos$[ebp+2], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  001d5	66 85 d2	 test	 dx, dx
  001d8	79 0f		 jns	 SHORT $LN113@decode_3i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001da	0f bf c2	 movsx	 eax, dx
  001dd	f7 d0		 not	 eax
  001df	c1 f8 03	 sar	 eax, 3
  001e2	f7 d0		 not	 eax
  001e4	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  001e7	eb 07		 jmp	 SHORT $LN112@decode_3i4
$LN113@decode_3i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  001e9	66 c1 fa 03	 sar	 dx, 3
  001ed	0f b7 c2	 movzx	 eax, dx
$LN112@decode_3i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 80   :     j = index & 1;                                       logic16 ();

  001f0	8b f8		 mov	 edi, eax
  001f2	83 e7 01	 and	 edi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  001f5	66 85 c0	 test	 ax, ax
  001f8	79 09		 jns	 SHORT $LN124@decode_3i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  001fa	98		 cwde
  001fb	f7 d0		 not	 eax
  001fd	d1 f8		 sar	 eax, 1
  001ff	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00201	eb 03		 jmp	 SHORT $LN228@decode_3i4
$LN124@decode_3i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00203	66 d1 f8	 sar	 ax, 1
$LN228@decode_3i4:
  00206	0f b7 d0	 movzx	 edx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 82   :     i = index & 7;                                       logic16 ();

  00209	83 e2 07	 and	 edx, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  0020c	0f bf c2	 movsx	 eax, dx
  0020f	89 45 e4	 mov	 DWORD PTR tv1119[ebp], eax
  00212	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00219	0f bf c6	 movsx	 eax, si
  0021c	3b f0		 cmp	 esi, eax
  0021e	74 19		 je	 SHORT $LN137@decode_3i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00220	8b 45 ec	 mov	 eax, DWORD PTR tv1104[ebp]
  00223	66 85 d2	 test	 dx, dx
  00226	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00230	0f 4f 45 f0	 cmovg	 eax, DWORD PTR tv1102[ebp]
  00234	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00237	eb 03		 jmp	 SHORT $LN134@decode_3i4
$LN137@decode_3i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00239	0f b7 c6	 movzx	 eax, si
$LN134@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0023c	98		 cwde
  0023d	03 45 e4	 add	 eax, DWORD PTR tv1119[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  00240	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00245	7e 11		 jle	 SHORT $LN150@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  00247	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00251	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00256	eb 1b		 jmp	 SHORT $LN147@decode_3i4
$LN150@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00258	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0025d	7d 11		 jge	 SHORT $LN148@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  0025f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00269	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0026e	eb 03		 jmp	 SHORT $LN147@decode_3i4
$LN148@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00270	0f b7 c0	 movzx	 eax, ax
$LN147@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00273	98		 cwde
  00274	83 c0 02	 add	 eax, 2

; 79   :     if (L_var1 > 0X00007fffL)

  00277	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0027c	7e 11		 jle	 SHORT $LN160@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  0027e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00288	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  0028d	eb 1b		 jmp	 SHORT $LN157@decode_3i4
$LN160@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0028f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00294	7d 11		 jge	 SHORT $LN158@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  00296	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002a0	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002a5	eb 03		 jmp	 SHORT $LN157@decode_3i4
$LN158@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002a7	0f b7 f0	 movzx	 esi, ax
$LN157@decode_3i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  002aa	0f bf d7	 movsx	 edx, di
  002ad	03 d2		 add	 edx, edx

; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  002af	0f bf c2	 movsx	 eax, dx
  002b2	3b d0		 cmp	 edx, eax
  002b4	74 19		 je	 SHORT $LN168@decode_3i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  002b6	8b 45 ec	 mov	 eax, DWORD PTR tv1104[ebp]
  002b9	66 85 ff	 test	 di, di
  002bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  002c6	0f 4f 45 f0	 cmovg	 eax, DWORD PTR tv1102[ebp]
  002ca	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  002cd	eb 03		 jmp	 SHORT $LN165@decode_3i4
$LN168@decode_3i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  002cf	0f b7 c2	 movzx	 eax, dx
$LN165@decode_3i4:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  002d2	0f bf d0	 movsx	 edx, ax
  002d5	0f bf c6	 movsx	 eax, si
  002d8	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  002da	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  002e0	7e 11		 jle	 SHORT $LN181@decode_3i4

; 80   :     {
; 81   :         Overflow = 1;

  002e2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002ec	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002f1	eb 1c		 jmp	 SHORT $LN178@decode_3i4
$LN181@decode_3i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002f3	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  002f9	7d 11		 jge	 SHORT $LN179@decode_3i4

; 85   :     {
; 86   :         Overflow = 1;

  002fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00305	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0030a	eb 03		 jmp	 SHORT $LN178@decode_3i4
$LN179@decode_3i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0030c	0f b7 c2	 movzx	 eax, dx
$LN178@decode_3i4:
  0030f	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 87   :     pos[2] = add(i, j);                                  move16 ();

  00312	66 89 45 f8	 mov	 WORD PTR _pos$[ebp+4], ax

; 88   : 
; 89   :     /* decode the signs  and build the codeword */
; 90   : 
; 91   :     for (i = 0; i < L_SUBFR; i++) {
; 92   :         cod[i] = 0;                                      move16 ();

  00316	f3 0f 7f 03	 movdqu	 XMMWORD PTR [ebx], xmm0

; 93   :     }
; 94   : 
; 95   :     for (j = 0; j < NB_PULSE; j++) {

  0031a	8d 55 f4	 lea	 edx, DWORD PTR _pos$[ebp]
  0031d	bf 03 00 00 00	 mov	 edi, 3
  00322	f3 0f 7f 43 10	 movdqu	 XMMWORD PTR [ebx+16], xmm0
  00327	f3 0f 7f 43 20	 movdqu	 XMMWORD PTR [ebx+32], xmm0
  0032c	f3 0f 7f 43 30	 movdqu	 XMMWORD PTR [ebx+48], xmm0
  00331	f3 0f 7f 43 40	 movdqu	 XMMWORD PTR [ebx+64], xmm0
$LL5@decode_3i4:

; 96   :         i = sign & 1;                                    logic16 ();

  00336	8b f1		 mov	 esi, ecx
  00338	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0033b	66 85 c9	 test	 cx, cx
  0033e	79 0e		 jns	 SHORT $LN193@decode_3i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00340	0f bf c1	 movsx	 eax, cx
  00343	f7 d0		 not	 eax
  00345	d1 f8		 sar	 eax, 1
  00347	f7 d0		 not	 eax
  00349	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  0034c	eb 06		 jmp	 SHORT $LN192@decode_3i4
$LN193@decode_3i4:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  0034e	66 d1 f9	 sar	 cx, 1
  00351	0f b7 c1	 movzx	 eax, cx
$LN192@decode_3i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d3_14pf.c

; 97   :         sign = shr(sign, 1);

  00354	0f b7 c8	 movzx	 ecx, ax

; 98   : 
; 99   :         test ();
; 100  :         if (i > 0) {

  00357	66 85 f6	 test	 si, si

; 101  :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  0035a	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0035d	be ff 1f 00 00	 mov	 esi, 8191		; 00001fffH
  00362	7f 05		 jg	 SHORT $LN229@decode_3i4

; 102  :         } else {
; 103  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  00364	be 00 e0 ff ff	 mov	 esi, -8192		; ffffe000H
$LN229@decode_3i4:

; 93   :     }
; 94   : 
; 95   :     for (j = 0; j < NB_PULSE; j++) {

  00369	83 c2 02	 add	 edx, 2

; 102  :         } else {
; 103  :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  0036c	66 89 34 43	 mov	 WORD PTR [ebx+eax*2], si
  00370	4f		 dec	 edi
  00371	75 c3		 jne	 SHORT $LL5@decode_3i4

; 104  :         }
; 105  :     }
; 106  : 
; 107  :     return;
; 108  : }

  00373	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00376	5f		 pop	 edi
  00377	5e		 pop	 esi
  00378	33 cd		 xor	 ecx, ebp
  0037a	5b		 pop	 ebx
  0037b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00380	8b e5		 mov	 esp, ebp
  00382	5d		 pop	 ebp
  00383	c3		 ret	 0
_decode_3i40_14bits ENDP
_TEXT	ENDS
END
