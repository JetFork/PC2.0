; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\log2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_table	DW	00H
	DW	05afH
	DW	0b32H
	DW	0108cH
	DW	015c0H
	DW	01acfH
	DW	01fbcH
	DW	02488H
	DW	02935H
	DW	02dc4H
	DW	03237H
	DW	0368fH
	DW	03aceH
	DW	03ef5H
	DW	04304H
	DW	046fcH
	DW	04adfH
	DW	04eaeH
	DW	05269H
	DW	05611H
	DW	059a7H
	DW	05d2cH
	DW	0609fH
	DW	06403H
	DW	06757H
	DW	06a9bH
	DW	06dd1H
	DW	070faH
	DW	07414H
	DW	07721H
	DW	07a22H
	DW	07d17H
	DW	07fffH
PUBLIC	_Log2_norm
PUBLIC	_Log2
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
;	COMDAT _Log2
_TEXT	SEGMENT
_fraction$ = 8						; size = 4
_Log2	PROC						; COMDAT
; _L_x$ = ecx
; _exponent$ = edx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  :     Word16 exp;
; 119  : 
; 120  :     exp = norm_l (L_x);

  00003	8b c1		 mov	 eax, ecx
  00005	56		 push	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN10@Log2

; 2110 :     {
; 2111 :         var_out = 0;

  0000a	33 f6		 xor	 esi, esi

; 2112 :     }
; 2113 :     else

  0000c	eb 23		 jmp	 SHORT $LN3@Log2
$LN10@Log2:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  0000e	83 f9 ff	 cmp	 ecx, -1
  00011	75 05		 jne	 SHORT $LN8@Log2

; 2116 :         {
; 2117 :             var_out = 31;

  00013	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  00016	eb 19		 jmp	 SHORT $LN3@Log2
$LN8@Log2:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00018	85 c9		 test	 ecx, ecx
  0001a	79 02		 jns	 SHORT $LN6@Log2

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  0001c	f7 d0		 not	 eax
$LN6@Log2:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  0001e	33 f6		 xor	 esi, esi
  00020	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00025	7d 0a		 jge	 SHORT $LN3@Log2
$LL5@Log2:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00027	03 c0		 add	 eax, eax
  00029	46		 inc	 esi
  0002a	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0002f	7c f6		 jl	 SHORT $LL5@Log2
$LN3@Log2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  00031	ff 75 08	 push	 DWORD PTR _fraction$[ebp]
  00034	52		 push	 edx
  00035	8b d6		 mov	 edx, esi
  00037	e8 00 00 00 00	 call	 _L_shl
  0003c	8b d6		 mov	 edx, esi
  0003e	8b c8		 mov	 ecx, eax
  00040	e8 00 00 00 00	 call	 _Log2_norm
  00045	83 c4 08	 add	 esp, 8
  00048	5e		 pop	 esi

; 122  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_Log2	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
;	COMDAT _Log2_norm
_TEXT	SEGMENT
_exponent$ = 8						; size = 4
_fraction$ = 12						; size = 4
_Log2_norm PROC						; COMDAT
; _L_x$ = ecx
; _exp$ = dx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   :     Word16 i, a, tmp;
; 72   :     Word32 L_y;
; 73   : 
; 74   :     test (); 
; 75   :     if (L_x <= (Word32) 0)

  00003	85 c9		 test	 ecx, ecx
  00005	7f 10		 jg	 SHORT $LN1@Log2_norm

; 76   :     {
; 77   :         *exponent = 0;          move16 (); 

  00007	8b 45 08	 mov	 eax, DWORD PTR _exponent$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 78   :         *fraction = 0;          move16 (); 

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _fraction$[ebp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx

; 97   : 
; 98   :     return;
; 99   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN1@Log2_norm:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00017	0f bf c2	 movsx	 eax, dx
  0001a	ba 1e 00 00 00	 mov	 edx, 30			; 0000001eH
  0001f	2b d0		 sub	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00021	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00027	7e 11		 jle	 SHORT $LN15@Log2_norm

; 80   :     {
; 81   :         Overflow = 1;

  00029	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00033	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00038	eb 1c		 jmp	 SHORT $LN12@Log2_norm
$LN15@Log2_norm:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0003a	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  00040	7d 11		 jge	 SHORT $LN13@Log2_norm

; 85   :     {
; 86   :         Overflow = 1;

  00042	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0004c	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00051	eb 03		 jmp	 SHORT $LN12@Log2_norm
$LN13@Log2_norm:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00053	0f b7 d2	 movzx	 edx, dx
$LN12@Log2_norm:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 82   :     *exponent = sub (30, exp);  move16 (); 

  00056	8b 45 08	 mov	 eax, DWORD PTR _exponent$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1443 :                 L_var_out = L_var1 >> var2;

  00059	c1 f9 09	 sar	 ecx, 9
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 82   :     *exponent = sub (30, exp);  move16 (); 

  0005c	66 89 10	 mov	 WORD PTR [eax], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0005f	8b c1		 mov	 eax, ecx
  00061	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 85   :     i = extract_h (L_x);                /* Extract b25-b31 */

  00064	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  00067	85 c9		 test	 ecx, ecx
  00069	79 08		 jns	 SHORT $LN34@Log2_norm

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0006b	f7 d1		 not	 ecx
  0006d	d1 f9		 sar	 ecx, 1
  0006f	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  00071	eb 02		 jmp	 SHORT $LN33@Log2_norm
$LN34@Log2_norm:

; 1443 :                 L_var_out = L_var1 >> var2;

  00073	d1 f9		 sar	 ecx, 1
$LN33@Log2_norm:

; 186  :     L_diff = (Word32) var1 - var2;

  00075	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 88   :     a = a & (Word16) 0x7fff;    logic16 (); 

  00076	81 e1 ff 7f 00
	00		 and	 ecx, 32767		; 00007fffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0007c	83 e8 20	 sub	 eax, 32			; 00000020H

; 79   :     if (L_var1 > 0X00007fffL)

  0007f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00084	7e 11		 jle	 SHORT $LN51@Log2_norm

; 80   :     {
; 81   :         Overflow = 1;

  00086	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00090	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00095	eb 1b		 jmp	 SHORT $LN48@Log2_norm
$LN51@Log2_norm:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00097	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0009c	7d 11		 jge	 SHORT $LN49@Log2_norm

; 85   :     {
; 86   :         Overflow = 1;

  0009e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000a8	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000ad	eb 03		 jmp	 SHORT $LN48@Log2_norm
$LN49@Log2_norm:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000af	0f b7 c0	 movzx	 eax, ax
$LN48@Log2_norm:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 92   :     L_y = L_deposit_h (table[i]);       /* table[i] << 16        */

  000b2	98		 cwde
  000b3	56		 push	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1675 :     L_var_out = (Word32) var1 << 16;

  000b4	0f bf 14 45 00
	00 00 00	 movsx	 edx, WORD PTR _table[eax*2]

; 186  :     L_diff = (Word32) var1 - var2;

  000bc	0f bf 04 45 02
	00 00 00	 movsx	 eax, WORD PTR _table[eax*2+2]

; 1675 :     L_var_out = (Word32) var1 << 16;

  000c4	8b f2		 mov	 esi, edx

; 186  :     L_diff = (Word32) var1 - var2;

  000c6	2b d0		 sub	 edx, eax

; 1675 :     L_var_out = (Word32) var1 << 16;

  000c8	c1 e6 10	 shl	 esi, 16			; 00000010H

; 79   :     if (L_var1 > 0X00007fffL)

  000cb	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  000d1	7e 11		 jle	 SHORT $LN63@Log2_norm

; 80   :     {
; 81   :         Overflow = 1;

  000d3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000dd	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  000e2	eb 1c		 jmp	 SHORT $LN60@Log2_norm
$LN63@Log2_norm:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000e4	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  000ea	7d 11		 jge	 SHORT $LN61@Log2_norm

; 85   :     {
; 86   :         Overflow = 1;

  000ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000f6	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000fb	eb 03		 jmp	 SHORT $LN60@Log2_norm
$LN61@Log2_norm:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  000fd	0f b7 d2	 movzx	 edx, dx
$LN60@Log2_norm:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 94   :     L_y = L_msu (L_y, tmp, a);          /* L_y -= tmp*a*2        */

  00100	51		 push	 ecx
  00101	8b ce		 mov	 ecx, esi
  00103	e8 00 00 00 00	 call	 _L_msu

; 96   :     *fraction = extract_h (L_y);move16 (); 

  00108	8b 4d 0c	 mov	 ecx, DWORD PTR _fraction$[ebp]
  0010b	83 c4 04	 add	 esp, 4
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0010e	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 96   :     *fraction = extract_h (L_y);move16 (); 

  00111	66 89 01	 mov	 WORD PTR [ecx], ax
  00114	5e		 pop	 esi

; 97   : 
; 98   :     return;
; 99   : }

  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
_Log2_norm ENDP
_TEXT	ENDS
END
