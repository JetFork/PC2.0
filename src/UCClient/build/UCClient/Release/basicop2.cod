; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\basicop2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Overflow
PUBLIC	??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@ ; `string'
PUBLIC	??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@ ; `string'
EXTRN	__imp__printf:PROC
EXTRN	__imp__abort:PROC
_Overflow DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@
CONST	SEGMENT
??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@ DB 'Division '
	DB	'by 0, Fatal error ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@
CONST	SEGMENT
??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@ DB 'D'
	DB	'ivision Error var1=%d  var2=%d', 0aH, 00H	; `string'
PUBLIC	_norm_l
PUBLIC	_norm_s
PUBLIC	_L_abs
PUBLIC	_L_shr_r
PUBLIC	_L_deposit_l
PUBLIC	_L_deposit_h
PUBLIC	_shr_r
PUBLIC	_L_sub
PUBLIC	_L_msu
PUBLIC	_negate
PUBLIC	_abs_s
PUBLIC	_saturate
PUBLIC	_L_shr
PUBLIC	_extract_l
PUBLIC	_shr
PUBLIC	_div_s
PUBLIC	_mult
PUBLIC	_extract_h
PUBLIC	_L_mult
PUBLIC	_L_mac
PUBLIC	_L_add
PUBLIC	_L_shl
PUBLIC	_round
PUBLIC	_shl
PUBLIC	_add
PUBLIC	_sub
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _sub
_TEXT	SEGMENT
_sub	PROC						; COMDAT
; _var1$ = cx
; _var2$ = dx

; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00000	0f bf c9	 movsx	 ecx, cx
  00003	0f bf c2	 movsx	 eax, dx
  00006	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00008	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0000e	7e 10		 jle	 SHORT $LN6@sub

; 80   :     {
; 81   :         Overflow = 1;

  00010	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0001a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }

  0001f	c3		 ret	 0
$LN6@sub:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00020	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00026	7d 10		 jge	 SHORT $LN4@sub

; 85   :     {
; 86   :         Overflow = 1;

  00028	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00032	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }

  00037	c3		 ret	 0
$LN4@sub:

; 88   :     }
; 89   :     else
; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00038	0f b7 c1	 movzx	 eax, cx

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }

  0003b	c3		 ret	 0
_sub	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _add
_TEXT	SEGMENT
_add	PROC						; COMDAT
; _var1$ = cx
; _var2$ = dx

; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  00000	0f bf c9	 movsx	 ecx, cx
  00003	0f bf c2	 movsx	 eax, dx
  00006	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00008	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0000e	7e 10		 jle	 SHORT $LN6@add

; 80   :     {
; 81   :         Overflow = 1;

  00010	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0001a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }

  0001f	c3		 ret	 0
$LN6@add:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00020	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00026	7d 10		 jge	 SHORT $LN4@add

; 85   :     {
; 86   :         Overflow = 1;

  00028	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00032	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }

  00037	c3		 ret	 0
$LN4@add:

; 88   :     }
; 89   :     else
; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00038	0f b7 c1	 movzx	 eax, cx

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }

  0003b	c3		 ret	 0
_add	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shl
_TEXT	SEGMENT
_shl	PROC						; COMDAT
; _var1$ = ecx
; _var2$ = edx

; 283  : {

  00000	53		 push	 ebx
  00001	8b da		 mov	 ebx, edx
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)

  00006	66 85 db	 test	 bx, bx
  00009	79 1a		 jns	 SHORT $LN7@shl

; 288  :     {
; 289  :         if (var2 < -16)

  0000b	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00010	66 3b d8	 cmp	 bx, ax
  00013	0f 4c d8	 cmovl	 ebx, eax

; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);

  00016	f7 db		 neg	 ebx
  00018	8b d3		 mov	 edx, ebx
  0001a	e8 00 00 00 00	 call	 _shr
  0001f	5e		 pop	 esi
  00020	0f b7 c0	 movzx	 eax, ax
  00023	5b		 pop	 ebx

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }

  00024	c3		 ret	 0
$LN7@shl:

; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	0f bf c6	 movsx	 eax, si
  0002d	8a cb		 mov	 cl, bl
  0002f	d3 e2		 shl	 edx, cl
  00031	0f af d0	 imul	 edx, eax

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00034	66 83 fb 0f	 cmp	 bx, 15			; 0000000fH
  00038	7e 05		 jle	 SHORT $LN2@shl
  0003a	66 85 f6	 test	 si, si
  0003d	75 07		 jne	 SHORT $LN3@shl
$LN2@shl:
  0003f	0f bf c2	 movsx	 eax, dx
  00042	3b d0		 cmp	 edx, eax
  00044	74 20		 je	 SHORT $LN4@shl
$LN3@shl:

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00046	66 85 f6	 test	 si, si
  00049	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00053	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00058	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0005d	0f 4f c1	 cmovg	 eax, ecx
  00060	5e		 pop	 esi
  00061	0f b7 c0	 movzx	 eax, ax
  00064	5b		 pop	 ebx

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }

  00065	c3		 ret	 0
$LN4@shl:
  00066	5e		 pop	 esi

; 304  :         }
; 305  :         else
; 306  :         {
; 307  :             var_out = extract_l (result);

  00067	0f b7 c2	 movzx	 eax, dx
  0006a	5b		 pop	 ebx

; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }

  0006b	c3		 ret	 0
_shl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _round
_TEXT	SEGMENT
_round	PROC						; COMDAT
; _L_var1$ = ecx

; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00000	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00006	85 c9		 test	 ecx, ecx
  00008	78 1d		 js	 SHORT $LN3@round

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0000a	8b c2		 mov	 eax, edx
  0000c	33 c1		 xor	 eax, ecx
  0000e	79 17		 jns	 SHORT $LN3@round

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00010	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00012	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0001c	85 c9		 test	 ecx, ecx
  0001e	0f 98 c2	 sets	 dl
  00021	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN3@round:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00027	c1 fa 10	 sar	 edx, 16			; 00000010H

; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);

  0002a	66 8b c2	 mov	 ax, dx

; 667  : }

  0002d	c3		 ret	 0
_round	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shl
_TEXT	SEGMENT
_L_shl	PROC						; COMDAT
; _L_var1$ = ecx
; _var2$ = edx

; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)

  00000	66 85 d2	 test	 dx, dx
  00003	7f 12		 jg	 SHORT $LL29@L_shl

; 1345 :     {
; 1346 :         if (var2 < -32)

  00005	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  0000a	66 3b d0	 cmp	 dx, ax
  0000d	0f 4c d0	 cmovl	 edx, eax

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  00010	f7 da		 neg	 edx
  00012	e9 00 00 00 00	 jmp	 _L_shr
$LL29@L_shl:

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00017	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0001d	7f 23		 jg	 SHORT $LN22@L_shl

; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0001f	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  00025	7c 0b		 jl	 SHORT $LN23@L_shl

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00027	4a		 dec	 edx
  00028	03 c9		 add	 ecx, ecx
  0002a	66 85 d2	 test	 dx, dx
  0002d	7f e8		 jg	 SHORT $LL29@L_shl

; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);

  0002f	8b c1		 mov	 eax, ecx

; 1380 : }

  00031	c3		 ret	 0
$LN23@L_shl:

; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);

  00032	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H

; 1358 :             {
; 1359 :                 Overflow = 1;

  00037	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1380 : }

  00041	c3		 ret	 0
$LN22@L_shl:

; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);

  00042	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00047	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1380 : }

  00051	c3		 ret	 0
_L_shl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_add
_TEXT	SEGMENT
_L_add	PROC						; COMDAT
; _L_var1$ = ecx
; _L_var_out$ = edx

; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00000	8b c2		 mov	 eax, edx
  00002	33 c1		 xor	 eax, ecx
  00004	79 17		 jns	 SHORT $LN8@L_add

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00006	33 c0		 xor	 eax, eax

; 938  :             Overflow = 1;

  00008	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00012	85 c9		 test	 ecx, ecx
  00014	0f 98 c0	 sets	 al
  00017	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH

; 945  : }

  0001c	c3		 ret	 0
$LN8@L_add:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);

  0001d	8b c2		 mov	 eax, edx

; 945  : }

  0001f	c3		 ret	 0
_L_add	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_mac
_TEXT	SEGMENT
_var2$ = 8						; size = 2
_L_mac	PROC						; COMDAT
; _L_var3$ = ecx
; _var1$ = dx

; 707  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00003	8b 45 08	 mov	 eax, DWORD PTR _var2$[ebp]
  00006	56		 push	 esi

; 707  : {

  00007	8b f1		 mov	 esi, ecx

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00009	98		 cwde
  0000a	0f bf ca	 movsx	 ecx, dx
  0000d	0f af c8	 imul	 ecx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00010	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00016	74 05		 je	 SHORT $LN4@L_mac

; 488  :     {
; 489  :         L_var_out *= 2;

  00018	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 490  :     }
; 491  :     else

  0001b	eb 0f		 jmp	 SHORT $LN3@L_mac
$LN4@L_mac:

; 492  :     {
; 493  :         Overflow = 1;

  0001d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00027	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN3@L_mac:

; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  0002c	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0002f	33 c6		 xor	 eax, esi

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00031	8b c1		 mov	 eax, ecx
  00033	78 1f		 js	 SHORT $LN7@L_mac
  00035	33 c6		 xor	 eax, esi
  00037	79 19		 jns	 SHORT $LN11@L_mac

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00039	33 c0		 xor	 eax, eax

; 938  :             Overflow = 1;

  0003b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00045	85 f6		 test	 esi, esi
  00047	5e		 pop	 esi

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00048	0f 98 c0	 sets	 al
  0004b	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH

; 721  : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN11@L_mac:

; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);

  00052	8b c1		 mov	 eax, ecx
$LN7@L_mac:
  00054	5e		 pop	 esi

; 721  : }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_L_mac	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_mult
_TEXT	SEGMENT
_L_mult	PROC						; COMDAT
; _var1$ = cx
; _var2$ = dx

; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00000	0f bf c9	 movsx	 ecx, cx
  00003	0f bf c2	 movsx	 eax, dx
  00006	0f af c8	 imul	 ecx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00009	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  0000f	74 04		 je	 SHORT $LN2@L_mult

; 488  :     {
; 489  :         L_var_out *= 2;

  00011	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 501  : }

  00014	c3		 ret	 0
$LN2@L_mult:

; 490  :     }
; 491  :     else
; 492  :     {
; 493  :         Overflow = 1;

  00015	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;
; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);

  0001f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 501  : }

  00024	c3		 ret	 0
_L_mult	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _extract_h
_TEXT	SEGMENT
_extract_h PROC						; COMDAT
; _L_var1$ = ecx

; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  00000	c1 f9 10	 sar	 ecx, 16			; 00000010H

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);

  00003	66 8b c1	 mov	 ax, cx

; 580  : }

  00006	c3		 ret	 0
_extract_h ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _mult
_TEXT	SEGMENT
_mult	PROC						; COMDAT
; _var1$ = cx
; _var2$ = dx

; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00000	0f bf c9	 movsx	 ecx, cx
  00003	0f bf c2	 movsx	 eax, dx
  00006	0f af c8	 imul	 ecx, eax

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00009	c1 f9 0f	 sar	 ecx, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0000c	f7 c1 00 00 01
	00		 test	 ecx, 65536		; 00010000H
  00012	74 06		 je	 SHORT $LN1@mult

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00014	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN1@mult:

; 79   :     if (L_var1 > 0X00007fffL)

  0001a	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00020	7e 10		 jle	 SHORT $LN7@mult

; 80   :     {
; 81   :         Overflow = 1;

  00022	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0002c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }

  00031	c3		 ret	 0
$LN7@mult:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00032	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00038	7d 10		 jge	 SHORT $LN5@mult

; 85   :     {
; 86   :         Overflow = 1;

  0003a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00044	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }

  00049	c3		 ret	 0
$LN5@mult:

; 88   :     }
; 89   :     else
; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0004a	0f b7 c1	 movzx	 eax, cx

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }

  0004d	c3		 ret	 0
_mult	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _div_s
_TEXT	SEGMENT
tv186 = -4						; size = 4
_div_s	PROC						; COMDAT
; _var1$ = cx
; _var2$ = dx

; 2009 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2010 :     Word16 var_out = 0;

  00005	33 ff		 xor	 edi, edi

; 2011 :     Word16 iteration;
; 2012 :     Word32 L_num;
; 2013 :     Word32 L_denom;
; 2014 : 
; 2015 :     if ((var1 > var2) || (var1 < 0) || (var2 < 0))

  00007	66 3b ca	 cmp	 cx, dx
  0000a	0f 8f a1 00 00
	00		 jg	 $LN10@div_s
  00010	66 85 c9	 test	 cx, cx
  00013	0f 88 98 00 00
	00		 js	 $LN10@div_s
  00019	66 85 d2	 test	 dx, dx
  0001c	0f 88 8f 00 00
	00		 js	 $LN10@div_s

; 2019 :     }
; 2020 :     if (var2 == 0)

  00022	75 14		 jne	 SHORT $LN9@div_s

; 2021 :     {
; 2022 :         printf ("Division by 0, Fatal error \n");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DCEEAPMO@Division?5by?50?0?5Fatal?5error?5?6?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0002f	83 c4 04	 add	 esp, 4

; 2023 :         abort(); /* exit (0); */

  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
$LN30@div_s:
$LN9@div_s:

; 2024 :     }
; 2025 :     if (var1 == 0)

  00038	66 85 c9	 test	 cx, cx
  0003b	75 0a		 jne	 SHORT $LN8@div_s

; 2026 :     {
; 2027 :         var_out = 0;

  0003d	33 ff		 xor	 edi, edi

; 2058 : #if (WMOPS)
; 2059 :                     multiCounter[currCounter].add--;
; 2060 : #endif
; 2061 :                 }
; 2062 :             }
; 2063 :         }
; 2064 :     }
; 2065 : 
; 2066 : #if (WMOPS)
; 2067 :     multiCounter[currCounter].div_s++;
; 2068 : #endif
; 2069 :     return (var_out);

  0003f	66 8b c7	 mov	 ax, di
  00042	5f		 pop	 edi

; 2070 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN8@div_s:

; 2028 :     }
; 2029 :     else
; 2030 :     {
; 2031 :         if (var1 == var2)

  00047	66 3b ca	 cmp	 cx, dx
  0004a	75 0d		 jne	 SHORT $LN6@div_s

; 2032 :         {
; 2033 :             var_out = MAX_16;

  0004c	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH

; 2058 : #if (WMOPS)
; 2059 :                     multiCounter[currCounter].add--;
; 2060 : #endif
; 2061 :                 }
; 2062 :             }
; 2063 :         }
; 2064 :     }
; 2065 : 
; 2066 : #if (WMOPS)
; 2067 :     multiCounter[currCounter].div_s++;
; 2068 : #endif
; 2069 :     return (var_out);

  00051	66 8b c7	 mov	 ax, di
  00054	5f		 pop	 edi

; 2070 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN6@div_s:
  00059	53		 push	 ebx

; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);
; 1440 :             }
; 1441 :             else
; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;
; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);
; 1451 : }
; 1452 : 
; 1453 : /*___________________________________________________________________________
; 1454 :  |                                                                           |
; 1455 :  |   Function Name : shr_r                                                   |
; 1456 :  |                                                                           |
; 1457 :  |   Purpose :                                                               |
; 1458 :  |                                                                           |
; 1459 :  |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
; 1460 :  |   underflows or overflows :                                               |
; 1461 :  |    - If var2 is greater than zero :                                       |
; 1462 :  |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
; 1463 :  |          is equal to zero                                                 |
; 1464 :  |                     then                                                  |
; 1465 :  |                     shr_r(var1,var2) = shr(var1,var2)                     |
; 1466 :  |                     else                                                  |
; 1467 :  |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
; 1468 :  |    - If var2 is less than or equal to zero :                              |
; 1469 :  |                     shr_r(var1,var2) = shr(var1,var2).                    |
; 1470 :  |                                                                           |
; 1471 :  |   Complexity weight : 2                                                   |
; 1472 :  |                                                                           |
; 1473 :  |   Inputs :                                                                |
; 1474 :  |                                                                           |
; 1475 :  |    var1                                                                   |
; 1476 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1477 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1478 :  |                                                                           |
; 1479 :  |    var2                                                                   |
; 1480 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1481 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1482 :  |                                                                           |
; 1483 :  |   Outputs :                                                               |
; 1484 :  |                                                                           |
; 1485 :  |    none                                                                   |
; 1486 :  |                                                                           |
; 1487 :  |   Return Value :                                                          |
; 1488 :  |                                                                           |
; 1489 :  |    var_out                                                                |
; 1490 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1491 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1492 :  |___________________________________________________________________________|
; 1493 : */
; 1494 : 
; 1495 : Word16 shr_r (Word16 var1, Word16 var2)
; 1496 : {
; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);
; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
; 1513 :             {
; 1514 :                 var_out++;
; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }
; 1523 : 
; 1524 : /*___________________________________________________________________________
; 1525 :  |                                                                           |
; 1526 :  |   Function Name : mac_r                                                   |
; 1527 :  |                                                                           |
; 1528 :  |   Purpose :                                                               |
; 1529 :  |                                                                           |
; 1530 :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 1531 :  |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
; 1532 :  |   into the MS 16 bits with saturation and shift the result right by 16.   |
; 1533 :  |   Return a 16 bit result.                                                 |
; 1534 :  |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
; 1535 :  |                                                                           |
; 1536 :  |   Complexity weight : 2                                                   |
; 1537 :  |                                                                           |
; 1538 :  |   Inputs :                                                                |
; 1539 :  |                                                                           |
; 1540 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1541 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1542 :  |                                                                           |
; 1543 :  |    var1                                                                   |
; 1544 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1545 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1546 :  |                                                                           |
; 1547 :  |    var2                                                                   |
; 1548 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1549 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1550 :  |                                                                           |
; 1551 :  |   Outputs :                                                               |
; 1552 :  |                                                                           |
; 1553 :  |    none                                                                   |
; 1554 :  |                                                                           |
; 1555 :  |   Return Value :                                                          |
; 1556 :  |                                                                           |
; 1557 :  |    var_out                                                                |
; 1558 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1559 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1560 :  |___________________________________________________________________________|
; 1561 : */
; 1562 : 
; 1563 : Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1564 : {
; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);
; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);
; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);
; 1581 : }
; 1582 : 
; 1583 : /*___________________________________________________________________________
; 1584 :  |                                                                           |
; 1585 :  |   Function Name : msu_r                                                   |
; 1586 :  |                                                                           |
; 1587 :  |   Purpose :                                                               |
; 1588 :  |                                                                           |
; 1589 :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 1590 :  |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
; 1591 :  |   ult into the MS 16 bits with saturation and shift the result right by   |
; 1592 :  |   16. Return a 16 bit result.                                             |
; 1593 :  |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
; 1594 :  |                                                                           |
; 1595 :  |   Complexity weight : 2                                                   |
; 1596 :  |                                                                           |
; 1597 :  |   Inputs :                                                                |
; 1598 :  |                                                                           |
; 1599 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1600 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1601 :  |                                                                           |
; 1602 :  |    var1                                                                   |
; 1603 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1604 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1605 :  |                                                                           |
; 1606 :  |    var2                                                                   |
; 1607 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1608 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1609 :  |                                                                           |
; 1610 :  |   Outputs :                                                               |
; 1611 :  |                                                                           |
; 1612 :  |    none                                                                   |
; 1613 :  |                                                                           |
; 1614 :  |   Return Value :                                                          |
; 1615 :  |                                                                           |
; 1616 :  |    var_out                                                                |
; 1617 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1618 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1619 :  |___________________________________________________________________________|
; 1620 : */
; 1621 : 
; 1622 : Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1623 : {
; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);
; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);
; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);
; 1640 : }
; 1641 : 
; 1642 : /*___________________________________________________________________________
; 1643 :  |                                                                           |
; 1644 :  |   Function Name : L_deposit_h                                             |
; 1645 :  |                                                                           |
; 1646 :  |   Purpose :                                                               |
; 1647 :  |                                                                           |
; 1648 :  |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
; 1649 :  |   16 LS bits of the output are zeroed.                                    |
; 1650 :  |                                                                           |
; 1651 :  |   Complexity weight : 2                                                   |
; 1652 :  |                                                                           |
; 1653 :  |   Inputs :                                                                |
; 1654 :  |                                                                           |
; 1655 :  |    var1                                                                   |
; 1656 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1657 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1658 :  |                                                                           |
; 1659 :  |   Outputs :                                                               |
; 1660 :  |                                                                           |
; 1661 :  |    none                                                                   |
; 1662 :  |                                                                           |
; 1663 :  |   Return Value :                                                          |
; 1664 :  |                                                                           |
; 1665 :  |    L_var_out                                                              |
; 1666 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1667 :  |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
; 1668 :  |___________________________________________________________________________|
; 1669 : */
; 1670 : 
; 1671 : Word32 L_deposit_h (Word16 var1)
; 1672 : {
; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;
; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);
; 1680 : }
; 1681 : 
; 1682 : /*___________________________________________________________________________
; 1683 :  |                                                                           |
; 1684 :  |   Function Name : L_deposit_l                                             |
; 1685 :  |                                                                           |
; 1686 :  |   Purpose :                                                               |
; 1687 :  |                                                                           |
; 1688 :  |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
; 1689 :  |   16 MS bits of the output are sign extended.                             |
; 1690 :  |                                                                           |
; 1691 :  |   Complexity weight : 2                                                   |
; 1692 :  |                                                                           |
; 1693 :  |   Inputs :                                                                |
; 1694 :  |                                                                           |
; 1695 :  |    var1                                                                   |
; 1696 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1697 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1698 :  |                                                                           |
; 1699 :  |   Outputs :                                                               |
; 1700 :  |                                                                           |
; 1701 :  |    none                                                                   |
; 1702 :  |                                                                           |
; 1703 :  |   Return Value :                                                          |
; 1704 :  |                                                                           |
; 1705 :  |    L_var_out                                                              |
; 1706 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1707 :  |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
; 1708 :  |___________________________________________________________________________|
; 1709 : */
; 1710 : 
; 1711 : Word32 L_deposit_l (Word16 var1)
; 1712 : {
; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;

  0005a	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0005f	0f bf da	 movsx	 ebx, dx
  00062	56		 push	 esi
  00063	0f bf f1	 movsx	 esi, cx
  00066	89 45 fc	 mov	 DWORD PTR tv186[ebp], eax
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL4@div_s:

; 2047 :             {
; 2048 :                 var_out <<= 1;
; 2049 :                 L_num <<= 1;

  00070	03 f6		 add	 esi, esi
  00072	03 ff		 add	 edi, edi

; 2050 : 
; 2051 :                 if (L_num >= L_denom)

  00074	3b f3		 cmp	 esi, ebx
  00076	7c 29		 jl	 SHORT $LN3@div_s

; 983  :     L_var_out = L_var1 - L_var2;

  00078	8b d6		 mov	 edx, esi

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  0007a	8b c3		 mov	 eax, ebx
  0007c	2b d3		 sub	 edx, ebx
  0007e	33 c6		 xor	 eax, esi
  00080	79 0b		 jns	 SHORT $LN19@div_s
  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 _L_sub
  00089	8b f0		 mov	 esi, eax
  0008b	eb 02		 jmp	 SHORT $LN20@div_s
$LN19@div_s:

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)
; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
; 990  :             Overflow = 1;
; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);

  0008d	8b f2		 mov	 esi, edx
$LN20@div_s:

; 2052 :                 {
; 2053 :                     L_num = L_sub (L_num, L_denom);
; 2054 : #if (WMOPS)
; 2055 :                     multiCounter[currCounter].L_sub--;
; 2056 : #endif
; 2057 :                     var_out = add (var_out, 1);

  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	8b cf		 mov	 ecx, edi
  00096	e8 00 00 00 00	 call	 _add
  0009b	0f b7 f8	 movzx	 edi, ax
  0009e	8b 45 fc	 mov	 eax, DWORD PTR tv186[ebp]
$LN3@div_s:

; 2034 :         }
; 2035 :         else
; 2036 :         {
; 2037 :             L_num = L_deposit_l (var1);
; 2038 : #if (WMOPS)
; 2039 :             multiCounter[currCounter].L_deposit_l--;
; 2040 : #endif
; 2041 :             L_denom = L_deposit_l (var2);
; 2042 : #if (WMOPS)
; 2043 :             multiCounter[currCounter].L_deposit_l--;
; 2044 : #endif
; 2045 : 
; 2046 :             for (iteration = 0; iteration < 15; iteration++)

  000a1	48		 dec	 eax
  000a2	89 45 fc	 mov	 DWORD PTR tv186[ebp], eax
  000a5	75 c9		 jne	 SHORT $LL4@div_s

; 2058 : #if (WMOPS)
; 2059 :                     multiCounter[currCounter].add--;
; 2060 : #endif
; 2061 :                 }
; 2062 :             }
; 2063 :         }
; 2064 :     }
; 2065 : 
; 2066 : #if (WMOPS)
; 2067 :     multiCounter[currCounter].div_s++;
; 2068 : #endif
; 2069 :     return (var_out);

  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	66 8b c7	 mov	 ax, di
  000ac	5f		 pop	 edi

; 2070 : }

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN10@div_s:

; 2016 :     {
; 2017 :         printf ("Division Error var1=%d  var2=%d\n", var1, var2);

  000b1	0f bf c2	 movsx	 eax, dx
  000b4	50		 push	 eax
  000b5	0f bf c1	 movsx	 eax, cx
  000b8	50		 push	 eax
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NAKJBPPG@Division?5Error?5var1?$DN?$CFd?5?5var2?$DN?$CFd?6@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2018 :         abort(); /* exit (0); */

  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__abort
$LN31@div_s:
$LN29@div_s:
  000cd	cc		 int	 3
_div_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shr
_TEXT	SEGMENT
_shr	PROC						; COMDAT
; _var1$ = ecx
; _var2$ = edx

; 355  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)

  00003	66 85 d2	 test	 dx, dx
  00006	79 17		 jns	 SHORT $LN7@shr

; 359  :     {
; 360  :         if (var2 < -16)

  00008	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  0000d	66 3b d0	 cmp	 dx, ax
  00010	0f 4c d0	 cmovl	 edx, eax

; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);

  00013	f7 da		 neg	 edx
  00015	e8 00 00 00 00	 call	 _shl
  0001a	0f b7 c0	 movzx	 eax, ax
  0001d	5e		 pop	 esi

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }

  0001e	c3		 ret	 0
$LN7@shr:

; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)

  0001f	66 83 fa 0f	 cmp	 dx, 15			; 0000000fH
  00023	7c 0e		 jl	 SHORT $LN4@shr

; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;

  00025	33 c0		 xor	 eax, eax
  00027	66 85 f6	 test	 si, si
  0002a	5e		 pop	 esi
  0002b	0f 99 c0	 setns	 al
  0002e	48		 dec	 eax
  0002f	0f b7 c0	 movzx	 eax, ax

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }

  00032	c3		 ret	 0
$LN4@shr:

; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)

  00033	66 85 f6	 test	 si, si
  00036	79 10		 jns	 SHORT $LN2@shr

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00038	0f bf c6	 movsx	 eax, si
  0003b	8a ca		 mov	 cl, dl
  0003d	f7 d0		 not	 eax
  0003f	d3 f8		 sar	 eax, cl
  00041	f7 d0		 not	 eax
  00043	0f b7 c0	 movzx	 eax, ax
  00046	5e		 pop	 esi

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }

  00047	c3		 ret	 0
$LN2@shr:

; 378  :             }
; 379  :             else
; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00048	66 8b ca	 mov	 cx, dx
  0004b	66 d3 fe	 sar	 si, cl
  0004e	0f b7 c6	 movzx	 eax, si
  00051	5e		 pop	 esi

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }

  00052	c3		 ret	 0
_shr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _extract_l
_TEXT	SEGMENT
_extract_l PROC						; COMDAT
; _L_var1$ = ecx

; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);

  00000	66 8b c1	 mov	 ax, cx

; 619  : }

  00003	c3		 ret	 0
_extract_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shr
_TEXT	SEGMENT
_L_shr	PROC						; COMDAT
; _L_var1$ = ecx
; _var2$ = edx

; 1417 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)

  00003	66 85 d2	 test	 dx, dx
  00006	79 13		 jns	 SHORT $LN7@L_shr

; 1421 :     {
; 1422 :         if (var2 < -32)

  00008	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  0000d	66 3b d0	 cmp	 dx, ax
  00010	5e		 pop	 esi
  00011	0f 4c d0	 cmovl	 edx, eax

; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);

  00014	f7 da		 neg	 edx
  00016	e9 00 00 00 00	 jmp	 _L_shl
$LN7@L_shr:

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)

  0001b	66 83 fa 1f	 cmp	 dx, 31			; 0000001fH
  0001f	7c 0a		 jl	 SHORT $LN4@L_shr

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  00021	33 c0		 xor	 eax, eax
  00023	85 f6		 test	 esi, esi
  00025	5e		 pop	 esi
  00026	0f 99 c0	 setns	 al
  00029	48		 dec	 eax

; 1451 : }

  0002a	c3		 ret	 0
$LN4@L_shr:

; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0002b	8a ca		 mov	 cl, dl
  0002d	85 f6		 test	 esi, esi
  0002f	79 0a		 jns	 SHORT $LN2@L_shr
  00031	f7 d6		 not	 esi
  00033	d3 fe		 sar	 esi, cl
  00035	f7 d6		 not	 esi

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi

; 1451 : }

  0003a	c3		 ret	 0
$LN2@L_shr:

; 1440 :             }
; 1441 :             else
; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0003b	d3 fe		 sar	 esi, cl

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi

; 1451 : }

  00040	c3		 ret	 0
_L_shr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _saturate
_TEXT	SEGMENT
_saturate PROC						; COMDAT
; _L_var1$ = ecx

; 77   :     Word16 var_out;
; 78   : 
; 79   :     if (L_var1 > 0X00007fffL)

  00000	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00006	7e 10		 jle	 SHORT $LN4@saturate

; 80   :     {
; 81   :         Overflow = 1;

  00008	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00012	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }

  00017	c3		 ret	 0
$LN4@saturate:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00018	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0001e	7d 10		 jge	 SHORT $LN2@saturate

; 85   :     {
; 86   :         Overflow = 1;

  00020	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0002a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }

  0002f	c3		 ret	 0
$LN2@saturate:

; 88   :     }
; 89   :     else
; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00030	0f b7 c1	 movzx	 eax, cx

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }

  00033	c3		 ret	 0
_saturate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _abs_s
_TEXT	SEGMENT
_abs_s	PROC						; COMDAT
; _var1$ = ecx

; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)

  00000	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00005	66 3b c8	 cmp	 cx, ax
  00008	75 06		 jne	 SHORT $LN4@abs_s

; 227  :     {
; 228  :         var_out = MAX_16;

  0000a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }

  0000f	c3		 ret	 0
$LN4@abs_s:

; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)

  00010	66 85 c9	 test	 cx, cx
  00013	79 02		 jns	 SHORT $LN2@abs_s

; 233  :         {
; 234  :             var_out = -var1;

  00015	f7 d9		 neg	 ecx
$LN2@abs_s:

; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;

  00017	0f b7 c1	 movzx	 eax, cx

; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }

  0001a	c3		 ret	 0
_abs_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _negate
_TEXT	SEGMENT
_negate	PROC						; COMDAT
; _var1$ = ecx

; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  00000	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00005	66 3b c8	 cmp	 cx, ax
  00008	75 06		 jne	 SHORT $LN3@negate
  0000a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }

  0000f	c3		 ret	 0
$LN3@negate:

; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;

  00010	f7 d9		 neg	 ecx
  00012	0f b7 c1	 movzx	 eax, cx

; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }

  00015	c3		 ret	 0
_negate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_msu
_TEXT	SEGMENT
_var2$ = 8						; size = 2
_L_msu	PROC						; COMDAT
; _L_var3$ = ecx
; _var1$ = dx

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00003	8b 45 08	 mov	 eax, DWORD PTR _var2$[ebp]
  00006	56		 push	 esi

; 761  : {

  00007	8b f1		 mov	 esi, ecx

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00009	98		 cwde
  0000a	0f bf ca	 movsx	 ecx, dx
  0000d	0f af c8	 imul	 ecx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00010	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00016	74 05		 je	 SHORT $LN4@L_msu

; 488  :     {
; 489  :         L_var_out *= 2;

  00018	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 490  :     }
; 491  :     else

  0001b	eb 0f		 jmp	 SHORT $LN3@L_msu
$LN4@L_msu:

; 492  :     {
; 493  :         Overflow = 1;

  0001d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00027	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN3@L_msu:

; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;
; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)
; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)
; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
; 938  :             Overflow = 1;
; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  0002c	8b ce		 mov	 ecx, esi
  0002e	2b c8		 sub	 ecx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00030	33 c6		 xor	 eax, esi

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00032	8b c1		 mov	 eax, ecx
  00034	79 1f		 jns	 SHORT $LN7@L_msu
  00036	33 c6		 xor	 eax, esi
  00038	79 19		 jns	 SHORT $LN11@L_msu

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0003a	33 c0		 xor	 eax, eax

; 990  :             Overflow = 1;

  0003c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00046	85 f6		 test	 esi, esi
  00048	5e		 pop	 esi

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00049	0f 98 c0	 sets	 al
  0004c	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH

; 775  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN11@L_msu:

; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);

  00053	8b c1		 mov	 eax, ecx
$LN7@L_msu:
  00055	5e		 pop	 esi

; 775  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_L_msu	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_sub
_TEXT	SEGMENT
_L_sub	PROC						; COMDAT
; _L_var1$ = ecx
; _L_var_out$ = edx

; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;
; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)
; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00000	8b c2		 mov	 eax, edx
  00002	33 c1		 xor	 eax, ecx
  00004	79 17		 jns	 SHORT $LN8@L_sub

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00006	33 c0		 xor	 eax, eax

; 990  :             Overflow = 1;

  00008	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00012	85 c9		 test	 ecx, ecx
  00014	0f 98 c0	 sets	 al
  00017	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH

; 997  : }

  0001c	c3		 ret	 0
$LN8@L_sub:

; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);

  0001d	8b c2		 mov	 eax, edx

; 997  : }

  0001f	c3		 ret	 0
_L_sub	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _shr_r
_TEXT	SEGMENT
_shr_r	PROC						; COMDAT
; _var1$ = ecx
; _var2$dead$ = dx

; 1496 : {

  00000	53		 push	 ebx

; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);

  00001	ba 05 00 00 00	 mov	 edx, 5
  00006	8b d9		 mov	 ebx, ecx
  00008	e8 00 00 00 00	 call	 _shr

; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)

  0000d	f6 c3 10	 test	 bl, 16			; 00000010H
  00010	0f b7 c0	 movzx	 eax, ax
  00013	5b		 pop	 ebx
  00014	74 01		 je	 SHORT $LN1@shr_r

; 1513 :             {
; 1514 :                 var_out++;

  00016	40		 inc	 eax
$LN1@shr_r:

; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }

  00017	c3		 ret	 0
_shr_r	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_deposit_h
_TEXT	SEGMENT
_L_deposit_h PROC					; COMDAT
; _var1$ = cx

; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;

  00000	0f bf c1	 movsx	 eax, cx
  00003	c1 e0 10	 shl	 eax, 16			; 00000010H

; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);
; 1680 : }

  00006	c3		 ret	 0
_L_deposit_h ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_deposit_l
_TEXT	SEGMENT
_L_deposit_l PROC					; COMDAT
; _var1$ = cx

; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;

  00000	0f bf c1	 movsx	 eax, cx

; 1716 : #if (WMOPS)
; 1717 :     multiCounter[currCounter].L_deposit_l++;
; 1718 : #endif
; 1719 :     return (L_var_out);
; 1720 : }

  00003	c3		 ret	 0
_L_deposit_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_shr_r
_TEXT	SEGMENT
_L_shr_r PROC						; COMDAT
; _L_var1$ = ecx
; _var2$ = edx

; 1765 : {

  00000	53		 push	 ebx
  00001	8b da		 mov	 ebx, edx
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1766 :     Word32 L_var_out;
; 1767 : 
; 1768 :     if (var2 > 31)

  00006	66 83 fb 1f	 cmp	 bx, 31			; 0000001fH
  0000a	7e 05		 jle	 SHORT $LN4@L_shr_r

; 1783 :             }
; 1784 :         }
; 1785 :     }
; 1786 : #if (WMOPS)
; 1787 :     multiCounter[currCounter].L_shr_r++;
; 1788 : #endif
; 1789 :     return (L_var_out);

  0000c	5e		 pop	 esi
  0000d	33 c0		 xor	 eax, eax
  0000f	5b		 pop	 ebx

; 1790 : }

  00010	c3		 ret	 0
$LN4@L_shr_r:

; 1769 :     {
; 1770 :         L_var_out = 0;
; 1771 :     }
; 1772 :     else
; 1773 :     {
; 1774 :         L_var_out = L_shr (L_var1, var2);

  00011	0f b7 d3	 movzx	 edx, bx

; 1420 :     if (var2 < 0)

  00014	66 85 db	 test	 bx, bx
  00017	79 16		 jns	 SHORT $LN13@L_shr_r

; 1421 :     {
; 1422 :         if (var2 < -32)

  00019	b8 e0 ff ff ff	 mov	 eax, -32		; ffffffe0H
  0001e	66 3b d8	 cmp	 bx, ax
  00021	0f 4c d0	 cmovl	 edx, eax

; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);

  00024	f7 da		 neg	 edx
  00026	e8 00 00 00 00	 call	 _L_shl
  0002b	8b d0		 mov	 edx, eax

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  0002d	eb 22		 jmp	 SHORT $LN7@L_shr_r
$LN13@L_shr_r:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  0002f	66 83 fb 1f	 cmp	 bx, 31			; 0000001fH
  00033	7c 0a		 jl	 SHORT $LN10@L_shr_r

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  00035	33 d2		 xor	 edx, edx
  00037	85 f6		 test	 esi, esi
  00039	0f 99 c2	 setns	 dl
  0003c	4a		 dec	 edx

; 1434 :         }
; 1435 :         else

  0003d	eb 12		 jmp	 SHORT $LN7@L_shr_r
$LN10@L_shr_r:

; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0003f	8b d6		 mov	 edx, esi
  00041	8a cb		 mov	 cl, bl
  00043	85 f6		 test	 esi, esi
  00045	79 08		 jns	 SHORT $LN8@L_shr_r
  00047	f7 d2		 not	 edx
  00049	d3 fa		 sar	 edx, cl
  0004b	f7 d2		 not	 edx

; 1440 :             }
; 1441 :             else

  0004d	eb 02		 jmp	 SHORT $LN7@L_shr_r
$LN8@L_shr_r:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0004f	d3 fa		 sar	 edx, cl
$LN7@L_shr_r:

; 1775 : #if (WMOPS)
; 1776 :         multiCounter[currCounter].L_shr--;
; 1777 : #endif
; 1778 :         if (var2 > 0)

  00051	66 85 db	 test	 bx, bx
  00054	7e 11		 jle	 SHORT $LN17@L_shr_r

; 1779 :         {
; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  00056	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	d3 e0		 shl	 eax, cl
  00060	85 c6		 test	 eax, esi

; 1781 :             {
; 1782 :                 L_var_out++;

  00062	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00065	75 02		 jne	 SHORT $LN1@L_shr_r
$LN17@L_shr_r:

; 1783 :             }
; 1784 :         }
; 1785 :     }
; 1786 : #if (WMOPS)
; 1787 :     multiCounter[currCounter].L_shr_r++;
; 1788 : #endif
; 1789 :     return (L_var_out);

  00067	8b c2		 mov	 eax, edx
$LN1@L_shr_r:
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 1790 : }

  0006b	c3		 ret	 0
_L_shr_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _L_abs
_TEXT	SEGMENT
_L_abs	PROC						; COMDAT
; _L_var1$ = ecx

; 1823 :     Word32 L_var_out;
; 1824 : 
; 1825 :     if (L_var1 == MIN_32)

  00000	81 f9 00 00 00
	80		 cmp	 ecx, -2147483648	; 80000000H
  00006	75 06		 jne	 SHORT $LN4@L_abs

; 1834 :         }
; 1835 :         else
; 1836 :         {
; 1837 :             L_var_out = L_var1;
; 1838 :         }
; 1839 :     }
; 1840 : 
; 1841 : #if (WMOPS)
; 1842 :     multiCounter[currCounter].L_abs++;
; 1843 : #endif
; 1844 :     return (L_var_out);

  00008	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1845 : }

  0000d	c3		 ret	 0
$LN4@L_abs:

; 1826 :     {
; 1827 :         L_var_out = MAX_32;
; 1828 :     }
; 1829 :     else
; 1830 :     {
; 1831 :         if (L_var1 < 0)

  0000e	85 c9		 test	 ecx, ecx
  00010	79 02		 jns	 SHORT $LN2@L_abs

; 1832 :         {
; 1833 :             L_var_out = -L_var1;

  00012	f7 d9		 neg	 ecx
$LN2@L_abs:

; 1834 :         }
; 1835 :         else
; 1836 :         {
; 1837 :             L_var_out = L_var1;
; 1838 :         }
; 1839 :     }
; 1840 : 
; 1841 : #if (WMOPS)
; 1842 :     multiCounter[currCounter].L_abs++;
; 1843 : #endif
; 1844 :     return (L_var_out);

  00014	8b c1		 mov	 eax, ecx

; 1845 : }

  00016	c3		 ret	 0
_L_abs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _norm_s
_TEXT	SEGMENT
_norm_s	PROC						; COMDAT
; _var1$ = ecx

; 1940 :     Word16 var_out;
; 1941 : 
; 1942 :     if (var1 == 0)

  00000	66 85 c9	 test	 cx, cx
  00003	75 03		 jne	 SHORT $LN8@norm_s

; 1943 :     {
; 1944 :         var_out = 0;

  00005	33 c0		 xor	 eax, eax

; 1961 :             }
; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 : #if (WMOPS)
; 1966 :     multiCounter[currCounter].norm_s++;
; 1967 : #endif
; 1968 :     return (var_out);
; 1969 : }

  00007	c3		 ret	 0
$LN8@norm_s:

; 1945 :     }
; 1946 :     else
; 1947 :     {
; 1948 :         if (var1 == (Word16) 0xffff)

  00008	66 83 f9 ff	 cmp	 cx, -1
  0000c	75 06		 jne	 SHORT $LN6@norm_s

; 1949 :         {
; 1950 :             var_out = 15;

  0000e	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 1961 :             }
; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 : #if (WMOPS)
; 1966 :     multiCounter[currCounter].norm_s++;
; 1967 : #endif
; 1968 :     return (var_out);
; 1969 : }

  00013	c3		 ret	 0
$LN6@norm_s:

; 1951 :         }
; 1952 :         else
; 1953 :         {
; 1954 :             if (var1 < 0)

  00014	66 85 c9	 test	 cx, cx
  00017	79 05		 jns	 SHORT $LN4@norm_s

; 1955 :             {
; 1956 :                 var1 = ~var1;

  00019	f7 d1		 not	 ecx
  0001b	0f b7 c9	 movzx	 ecx, cx
$LN4@norm_s:

; 1957 :             }
; 1958 :             for (var_out = 0; var1 < 0x4000; var_out++)

  0001e	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  00023	33 c0		 xor	 eax, eax
  00025	66 3b ca	 cmp	 cx, dx
  00028	7d 0e		 jge	 SHORT $LN1@norm_s
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL3@norm_s:

; 1959 :             {
; 1960 :                 var1 <<= 1;

  00030	03 c9		 add	 ecx, ecx
  00032	40		 inc	 eax
  00033	66 3b ca	 cmp	 cx, dx
  00036	7c f8		 jl	 SHORT $LL3@norm_s
$LN1@norm_s:

; 1961 :             }
; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 : #if (WMOPS)
; 1966 :     multiCounter[currCounter].norm_s++;
; 1967 : #endif
; 1968 :     return (var_out);
; 1969 : }

  00038	c3		 ret	 0
_norm_s	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
;	COMDAT _norm_l
_TEXT	SEGMENT
_norm_l	PROC						; COMDAT
; _L_var1$ = ecx

; 2107 :     Word16 var_out;
; 2108 : 
; 2109 :     if (L_var1 == 0)

  00000	85 c9		 test	 ecx, ecx
  00002	75 03		 jne	 SHORT $LN8@norm_l

; 2110 :     {
; 2111 :         var_out = 0;

  00004	33 c0		 xor	 eax, eax

; 2128 :             }
; 2129 :         }
; 2130 :     }
; 2131 : 
; 2132 : #if (WMOPS)
; 2133 :     multiCounter[currCounter].norm_l++;
; 2134 : #endif
; 2135 :     return (var_out);
; 2136 : }

  00006	c3		 ret	 0
$LN8@norm_l:

; 2112 :     }
; 2113 :     else
; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00007	83 f9 ff	 cmp	 ecx, -1
  0000a	75 04		 jne	 SHORT $LN6@norm_l

; 2116 :         {
; 2117 :             var_out = 31;

  0000c	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]

; 2128 :             }
; 2129 :         }
; 2130 :     }
; 2131 : 
; 2132 : #if (WMOPS)
; 2133 :     multiCounter[currCounter].norm_l++;
; 2134 : #endif
; 2135 :     return (var_out);
; 2136 : }

  0000f	c3		 ret	 0
$LN6@norm_l:

; 2118 :         }
; 2119 :         else
; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00010	85 c9		 test	 ecx, ecx
  00012	79 02		 jns	 SHORT $LN4@norm_l

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00014	f7 d1		 not	 ecx
$LN4@norm_l:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00016	33 c0		 xor	 eax, eax
  00018	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  0001e	7d 0b		 jge	 SHORT $LN1@norm_l
$LL3@norm_l:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00020	03 c9		 add	 ecx, ecx
  00022	40		 inc	 eax
  00023	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00029	7c f5		 jl	 SHORT $LL3@norm_l
$LN1@norm_l:

; 2128 :             }
; 2129 :         }
; 2130 :     }
; 2131 : 
; 2132 : #if (WMOPS)
; 2133 :     multiCounter[currCounter].norm_l++;
; 2134 : #endif
; 2135 :     return (var_out);
; 2136 : }

  0002b	c3		 ret	 0
_norm_l	ENDP
_TEXT	ENDS
END
