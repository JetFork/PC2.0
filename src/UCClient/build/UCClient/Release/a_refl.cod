; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\a_refl.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_A_Refl
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c
;	COMDAT _A_Refl
_TEXT	SEGMENT
tv979 = -76						; size = 4
tv983 = -72						; size = 4
tv982 = -68						; size = 4
_j$1$ = -64						; size = 4
tv987 = -60						; size = 4
tv980 = -56						; size = 4
_i$1$ = -52						; size = 4
_refl$GSCopy$1$ = -48					; size = 4
_bState$ = -44						; size = 20
_aState$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_A_Refl	PROC						; COMDAT
; _a$ = ecx
; _refl$ = edx

; 58   : {				       

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 59   :    /* local variables */
; 60   :    Word16 i,j;
; 61   :    Word16 aState[M];
; 62   :    Word16 bState[M];
; 63   :    Word16 normShift;
; 64   :    Word16 normProd;
; 65   :    Word32 L_acc;
; 66   :    Word16 scale;
; 67   :    Word32 L_temp;
; 68   :    Word16 temp;
; 69   :    Word16 mult;
; 70   : 
; 71   :    /* initialize states */
; 72   :    for (i = 0; i < M; i++)
; 73   :    {
; 74   :       aState[i] = a[i];                         move16 ();

  00010	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  00014	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b fa		 mov	 edi, edx
  0001c	89 45 f8	 mov	 DWORD PTR _aState$[ebp+16], eax

; 75   :    }
; 76   :    
; 77   :    /* backward Levinson recursion */
; 78   :    for (i = M-1; i >= 0; i--)

  0001f	bb 09 00 00 00	 mov	 ebx, 9
  00024	89 7d d0	 mov	 DWORD PTR _refl$GSCopy$1$[ebp], edi
  00027	f3 0f 7f 45 e8	 movdqu	 XMMWORD PTR _aState$[ebp], xmm0
  0002c	89 5d cc	 mov	 DWORD PTR _i$1$[ebp], ebx
$LN222@A_Refl:

; 80   :       if (sub(abs_s(aState[i]), 4096) >= 0)

  0002f	0f bf f3	 movsx	 esi, bx
  00032	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H
  00037	89 75 c4	 mov	 DWORD PTR tv987[ebp], esi
  0003a	0f b7 4c 75 e8	 movzx	 ecx, WORD PTR _aState$[ebp+esi*2]
  0003f	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 226  :     if (var1 == (Word16) 0X8000)

  00041	66 3b c2	 cmp	 ax, dx
  00044	75 07		 jne	 SHORT $LN25@A_Refl

; 227  :     {
; 228  :         var_out = MAX_16;

  00046	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH

; 229  :     }
; 230  :     else

  0004b	eb 0a		 jmp	 SHORT $LN22@A_Refl
$LN25@A_Refl:

; 231  :     {
; 232  :         if (var1 < 0)

  0004d	66 85 c0	 test	 ax, ax
  00050	79 05		 jns	 SHORT $LN22@A_Refl

; 233  :         {
; 234  :             var_out = -var1;

  00052	f7 d8		 neg	 eax
  00054	0f b7 c0	 movzx	 eax, ax
$LN22@A_Refl:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00057	98		 cwde
  00058	2d 00 10 00 00	 sub	 eax, 4096		; 00001000H

; 79   :     if (L_var1 > 0X00007fffL)

  0005d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00062	0f 8f be 03 00
	00		 jg	 $LN206@A_Refl

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00068	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0006d	7d 0c		 jge	 SHORT $LN31@A_Refl

; 85   :     {
; 86   :         Overflow = 1;

  0006f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00079	eb 09		 jmp	 SHORT $LN200@A_Refl
$LN31@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 80   :       if (sub(abs_s(aState[i]), 4096) >= 0)

  0007b	66 85 c0	 test	 ax, ax
  0007e	0f 89 b1 03 00
	00		 jns	 $ExitRefl$224
$LN200@A_Refl:

; 85   :       refl[i] = shl(aState[i], 3);

  00084	8b d1		 mov	 edx, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00086	0f bf ca	 movsx	 ecx, dx
  00089	c1 e1 03	 shl	 ecx, 3

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  0008c	0f bf c1	 movsx	 eax, cx
  0008f	3b c8		 cmp	 ecx, eax
  00091	74 1f		 je	 SHORT $LN41@A_Refl

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00093	66 85 d2	 test	 dx, dx
  00096	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000a0	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  000a5	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  000aa	0f 4f c1	 cmovg	 eax, ecx
  000ad	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  000b0	eb 03		 jmp	 SHORT $LN38@A_Refl
$LN41@A_Refl:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000b2	0f b7 c1	 movzx	 eax, cx
$LN38@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 85   :       refl[i] = shl(aState[i], 3);

  000b5	66 89 04 77	 mov	 WORD PTR [edi+esi*2], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000b9	98		 cwde
  000ba	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000bd	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000c2	74 04		 je	 SHORT $LN50@A_Refl

; 488  :     {
; 489  :         L_var_out *= 2;

  000c4	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  000c6	eb 0f		 jmp	 SHORT $LN49@A_Refl
$LN50@A_Refl:

; 492  :     {
; 493  :         Overflow = 1;

  000c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000d2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN49@A_Refl:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  000d7	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  000dc	2b c8		 sub	 ecx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  000de	85 c0		 test	 eax, eax
  000e0	79 13		 jns	 SHORT $LN53@A_Refl

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  000e2	85 c9		 test	 ecx, ecx
  000e4	79 0f		 jns	 SHORT $LN53@A_Refl

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  000e6	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH

; 990  :             Overflow = 1;

  000eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN53@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 90   :       normShift = norm_l(L_acc);

  000f5	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  000f7	85 c9		 test	 ecx, ecx
  000f9	75 04		 jne	 SHORT $LN64@A_Refl

; 2110 :     {
; 2111 :         var_out = 0;

  000fb	33 d2		 xor	 edx, edx

; 2112 :     }
; 2113 :     else

  000fd	eb 2b		 jmp	 SHORT $LN57@A_Refl
$LN64@A_Refl:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  000ff	83 f9 ff	 cmp	 ecx, -1
  00102	75 05		 jne	 SHORT $LN62@A_Refl

; 2116 :         {
; 2117 :             var_out = 31;

  00104	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  00107	eb 21		 jmp	 SHORT $LN57@A_Refl
$LN62@A_Refl:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00109	85 c9		 test	 ecx, ecx
  0010b	79 04		 jns	 SHORT $LN60@A_Refl

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  0010d	8b c1		 mov	 eax, ecx
  0010f	f7 d0		 not	 eax
$LN60@A_Refl:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00111	33 d2		 xor	 edx, edx
  00113	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00118	7d 10		 jge	 SHORT $LN57@A_Refl
  0011a	8d 9b 00 00 00
	00		 npad	 6
$LL59@A_Refl:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00120	03 c0		 add	 eax, eax
  00122	42		 inc	 edx
  00123	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00128	7c f6		 jl	 SHORT $LL59@A_Refl
$LN57@A_Refl:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0012a	0f bf c2	 movsx	 eax, dx
  0012d	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  00132	2b f0		 sub	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00134	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  0013a	7e 11		 jle	 SHORT $LN72@A_Refl

; 80   :     {
; 81   :         Overflow = 1;

  0013c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00146	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  0014b	eb 1c		 jmp	 SHORT $LN69@A_Refl
$LN72@A_Refl:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0014d	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  00153	7d 11		 jge	 SHORT $LN70@A_Refl

; 85   :     {
; 86   :         Overflow = 1;

  00155	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0015f	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00164	eb 03		 jmp	 SHORT $LN69@A_Refl
$LN70@A_Refl:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00166	0f b7 fe	 movzx	 edi, si
$LN69@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 93   :       L_acc = L_shl(L_acc, normShift);

  00169	0f b7 c2	 movzx	 eax, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1344 :     if (var2 <= 0)

  0016c	66 85 d2	 test	 dx, dx
  0016f	7f 1f		 jg	 SHORT $LL214@A_Refl

; 1345 :     {
; 1346 :         if (var2 < -32)

  00171	66 83 fa e0	 cmp	 dx, -32			; ffffffe0H
  00175	ba e0 ff ff ff	 mov	 edx, -32		; ffffffe0H
  0017a	0f 4c c2	 cmovl	 eax, edx

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  0017d	f7 d8		 neg	 eax
  0017f	8b d0		 mov	 edx, eax
  00181	e8 00 00 00 00	 call	 _L_shr
  00186	8b c8		 mov	 ecx, eax

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  00188	eb 36		 jmp	 SHORT $LN80@A_Refl
  0018a	8d 9b 00 00 00
	00		 npad	 6
$LL214@A_Refl:

; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00190	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00196	7f 19		 jg	 SHORT $LN170@A_Refl

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00198	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0019e	7c 0a		 jl	 SHORT $LN171@A_Refl

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  001a0	48		 dec	 eax
  001a1	03 c9		 add	 ecx, ecx
  001a3	66 85 c0	 test	 ax, ax
  001a6	7f e8		 jg	 SHORT $LL214@A_Refl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 80   :       if (sub(abs_s(aState[i]), 4096) >= 0)

  001a8	eb 16		 jmp	 SHORT $LN80@A_Refl
$LN171@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1368 :                     L_var_out = MIN_32;

  001aa	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001af	eb 05		 jmp	 SHORT $LN221@A_Refl
$LN170@A_Refl:

; 1360 :                 L_var_out = MAX_32;

  001b1	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN221@A_Refl:

; 1358 :             {
; 1359 :                 Overflow = 1;

  001b6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN80@A_Refl:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  001c0	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001c6	85 c9		 test	 ecx, ecx
  001c8	78 1d		 js	 SHORT $LN90@A_Refl

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001ca	8b c2		 mov	 eax, edx
  001cc	33 c1		 xor	 eax, ecx
  001ce	79 17		 jns	 SHORT $LN90@A_Refl

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  001d0	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  001d2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001dc	85 c9		 test	 ecx, ecx
  001de	0f 98 c2	 sets	 dl
  001e1	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN90@A_Refl:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  001e7	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 96   :       mult = div_s(16384, normProd);

  001ea	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  001ef	e8 00 00 00 00	 call	 _div_s

; 97   :       
; 98   :       for (j = 0; j < i; j++)

  001f4	33 c9		 xor	 ecx, ecx
  001f6	0f b7 c0	 movzx	 eax, ax
  001f9	33 d2		 xor	 edx, edx
  001fb	89 4d c0	 mov	 DWORD PTR _j$1$[ebp], ecx
  001fe	66 3b d3	 cmp	 dx, bx
  00201	0f 8d 2c 01 00
	00		 jge	 $LN8@A_Refl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  00207	0f bf df	 movsx	 ebx, di
  0020a	0f bf f0	 movsx	 esi, ax
  0020d	89 5d c8	 mov	 DWORD PTR tv980[ebp], ebx
  00210	89 75 bc	 mov	 DWORD PTR tv982[ebp], esi
  00213	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00216	89 55 b4	 mov	 DWORD PTR tv979[ebp], edx
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL10@A_Refl:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00220	8b 5d d0	 mov	 ebx, DWORD PTR _refl$GSCopy$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 100  :          L_acc = L_deposit_h(aState[j]);

  00223	0f bf c9	 movsx	 ecx, cx
  00226	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1675 :     L_var_out = (Word32) var1 << 16;

  00229	0f bf 54 05 e8	 movsx	 edx, WORD PTR _aState$[ebp+eax]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 100  :          L_acc = L_deposit_h(aState[j]);

  0022e	89 45 b8	 mov	 DWORD PTR tv983[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00231	8b 45 c4	 mov	 eax, DWORD PTR tv987[ebp]
  00234	2b c1		 sub	 eax, ecx

; 1675 :     L_var_out = (Word32) var1 << 16;

  00236	c1 e2 10	 shl	 edx, 16			; 00000010H

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00239	0f bf 4c 45 e6	 movsx	 ecx, WORD PTR _aState$[ebp+eax*2-2]
  0023e	8b 45 c4	 mov	 eax, DWORD PTR tv987[ebp]
  00241	0f bf 04 43	 movsx	 eax, WORD PTR [ebx+eax*2]

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00245	8b 5d c8	 mov	 ebx, DWORD PTR tv980[ebp]
  00248	0f af c8	 imul	 ecx, eax
  0024b	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  00251	74 05		 je	 SHORT $LN101@A_Refl

; 488  :     {
; 489  :         L_var_out *= 2;

  00253	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 490  :     }
; 491  :     else

  00256	eb 0f		 jmp	 SHORT $LN100@A_Refl
$LN101@A_Refl:

; 492  :     {
; 493  :         Overflow = 1;

  00258	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00262	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN100@A_Refl:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  00267	8b ca		 mov	 ecx, edx
  00269	2b c8		 sub	 ecx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  0026b	33 c2		 xor	 eax, edx
  0026d	79 1d		 jns	 SHORT $LN104@A_Refl

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  0026f	8b c1		 mov	 eax, ecx
  00271	33 c2		 xor	 eax, edx
  00273	79 17		 jns	 SHORT $LN104@A_Refl

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00275	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  00277	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00281	85 d2		 test	 edx, edx
  00283	0f 98 c1	 sets	 cl
  00286	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN104@A_Refl:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  0028c	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00292	85 c9		 test	 ecx, ecx
  00294	78 1d		 js	 SHORT $LN110@A_Refl

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00296	8b c2		 mov	 eax, edx
  00298	33 c1		 xor	 eax, ecx
  0029a	79 17		 jns	 SHORT $LN110@A_Refl

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0029c	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  0029e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  002a8	85 c9		 test	 ecx, ecx
  002aa	0f 98 c2	 sets	 dl
  002ad	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN110@A_Refl:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);

  002b3	c1 fa 10	 sar	 edx, 16			; 00000010H

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  002b6	0f bf c2	 movsx	 eax, dx
  002b9	0f af c6	 imul	 eax, esi

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  002bc	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  002c1	74 05		 je	 SHORT $LN117@A_Refl

; 488  :     {
; 489  :         L_var_out *= 2;

  002c3	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]

; 490  :     }
; 491  :     else

  002c6	eb 0f		 jmp	 SHORT $LN116@A_Refl
$LN117@A_Refl:

; 492  :     {
; 493  :         Overflow = 1;

  002c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  002d2	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
$LN116@A_Refl:

; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);
; 1680 : }
; 1681 : 
; 1682 : /*___________________________________________________________________________
; 1683 :  |                                                                           |
; 1684 :  |   Function Name : L_deposit_l                                             |
; 1685 :  |                                                                           |
; 1686 :  |   Purpose :                                                               |
; 1687 :  |                                                                           |
; 1688 :  |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
; 1689 :  |   16 MS bits of the output are sign extended.                             |
; 1690 :  |                                                                           |
; 1691 :  |   Complexity weight : 2                                                   |
; 1692 :  |                                                                           |
; 1693 :  |   Inputs :                                                                |
; 1694 :  |                                                                           |
; 1695 :  |    var1                                                                   |
; 1696 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1697 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1698 :  |                                                                           |
; 1699 :  |   Outputs :                                                               |
; 1700 :  |                                                                           |
; 1701 :  |    none                                                                   |
; 1702 :  |                                                                           |
; 1703 :  |   Return Value :                                                          |
; 1704 :  |                                                                           |
; 1705 :  |    L_var_out                                                              |
; 1706 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1707 :  |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
; 1708 :  |___________________________________________________________________________|
; 1709 : */
; 1710 : 
; 1711 : Word32 L_deposit_l (Word16 var1)
; 1712 : {
; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;
; 1716 : #if (WMOPS)
; 1717 :     multiCounter[currCounter].L_deposit_l++;
; 1718 : #endif
; 1719 :     return (L_var_out);
; 1720 : }
; 1721 : 
; 1722 : /*___________________________________________________________________________
; 1723 :  |                                                                           |
; 1724 :  |   Function Name : L_shr_r                                                 |
; 1725 :  |                                                                           |
; 1726 :  |   Purpose :                                                               |
; 1727 :  |                                                                           |
; 1728 :  |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
; 1729 :  |   case of underflows or overflows :                                       |
; 1730 :  |    - If var2 is greater than zero :                                       |
; 1731 :  |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
; 1732 :  |          is equal to zero                                                 |
; 1733 :  |                     then                                                  |
; 1734 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
; 1735 :  |                     else                                                  |
; 1736 :  |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
; 1737 :  |    - If var2 is less than or equal to zero :                              |
; 1738 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
; 1739 :  |                                                                           |
; 1740 :  |   Complexity weight : 3                                                   |
; 1741 :  |                                                                           |
; 1742 :  |   Inputs :                                                                |
; 1743 :  |                                                                           |
; 1744 :  |    L_var1                                                                 |
; 1745 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1746 :  |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
; 1747 :  |                                                                           |
; 1748 :  |    var2                                                                   |
; 1749 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1750 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1751 :  |                                                                           |
; 1752 :  |   Outputs :                                                               |
; 1753 :  |                                                                           |
; 1754 :  |    none                                                                   |
; 1755 :  |                                                                           |
; 1756 :  |   Return Value :                                                          |
; 1757 :  |                                                                           |
; 1758 :  |    L_var_out                                                              |
; 1759 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1760 :  |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
; 1761 :  |___________________________________________________________________________|
; 1762 : */
; 1763 : 
; 1764 : Word32 L_shr_r (Word32 L_var1, Word16 var2)
; 1765 : {
; 1766 :     Word32 L_var_out;
; 1767 : 
; 1768 :     if (var2 > 31)

  002d7	66 83 ff 1f	 cmp	 di, 31			; 0000001fH
  002db	0f 8e 80 00 00
	00		 jle	 $LN123@A_Refl

; 1769 :     {
; 1770 :         L_var_out = 0;

  002e1	33 c0		 xor	 eax, eax
$LN147@A_Refl:

; 1836 :         {
; 1837 :             L_var_out = L_var1;

  002e3	8b d0		 mov	 edx, eax
$LN146@A_Refl:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  002e5	8d 9a 01 80 ff
	ff		 lea	 ebx, DWORD PTR [edx-32767]

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  002eb	85 d2		 test	 edx, edx
  002ed	79 1d		 jns	 SHORT $LN152@A_Refl

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  002ef	8b cb		 mov	 ecx, ebx
  002f1	33 ca		 xor	 ecx, edx
  002f3	79 17		 jns	 SHORT $LN152@A_Refl

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  002f5	33 db		 xor	 ebx, ebx

; 990  :             Overflow = 1;

  002f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00301	85 d2		 test	 edx, edx
  00303	0f 98 c3	 sets	 bl
  00306	81 c3 ff ff ff
	7f		 add	 ebx, 2147483647		; 7fffffffH
$LN152@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 107  :          if (L_sub(L_abs(L_temp), 32767) > 0)

  0030c	85 db		 test	 ebx, ebx
  0030e	0f 8f 1e 01 00
	00		 jg	 $LN217@A_Refl

; 108  :          {
; 109  :             goto ExitRefl;
; 110  :          }
; 111  :          
; 112  :          bState[j] = extract_l(L_temp);

  00314	8b 4d b8	 mov	 ecx, DWORD PTR tv983[ebp]
  00317	8b 75 bc	 mov	 esi, DWORD PTR tv982[ebp]
  0031a	66 89 44 0d d4	 mov	 WORD PTR _bState$[ebp+ecx], ax
  0031f	8b 4d c0	 mov	 ecx, DWORD PTR _j$1$[ebp]
  00322	41		 inc	 ecx
  00323	89 4d c0	 mov	 DWORD PTR _j$1$[ebp], ecx
  00326	66 3b 4d cc	 cmp	 cx, WORD PTR _i$1$[ebp]
  0032a	0f 8c f0 fe ff
	ff		 jl	 $LL10@A_Refl
  00330	8b 5d cc	 mov	 ebx, DWORD PTR _i$1$[ebp]
$LN8@A_Refl:

; 113  :       }
; 114  :       
; 115  :       for (j = 0; j < i; j++)

  00333	33 c0		 xor	 eax, eax
  00335	66 3b c3	 cmp	 ax, bx
  00338	7d 12		 jge	 SHORT $LN13@A_Refl
  0033a	0f b7 cb	 movzx	 ecx, bx
  0033d	8d 75 d4	 lea	 esi, DWORD PTR _bState$[ebp]
  00340	d1 e9		 shr	 ecx, 1
  00342	8d 7d e8	 lea	 edi, DWORD PTR _aState$[ebp]
  00345	f3 a5		 rep movsd
  00347	13 c9		 adc	 ecx, ecx
  00349	66 f3 a5	 rep movsw
$LN13@A_Refl:

; 75   :    }
; 76   :    
; 77   :    /* backward Levinson recursion */
; 78   :    for (i = M-1; i >= 0; i--)

  0034c	4b		 dec	 ebx
  0034d	89 5d cc	 mov	 DWORD PTR _i$1$[ebp], ebx
  00350	66 85 db	 test	 bx, bx
  00353	0f 88 ea 00 00
	00		 js	 $LN3@A_Refl
  00359	8b 7d d0	 mov	 edi, DWORD PTR _refl$GSCopy$1$[ebp]
  0035c	e9 ce fc ff ff	 jmp	 $LN222@A_Refl
$LN123@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1774 :         L_var_out = L_shr (L_var1, var2);

  00361	0f b7 c7	 movzx	 eax, di

; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)

  00364	66 85 ff	 test	 di, di
  00367	79 65		 jns	 SHORT $LN132@A_Refl

; 1421 :     {
; 1422 :         if (var2 < -32)

  00369	66 83 ff e0	 cmp	 di, -32			; ffffffe0H
  0036d	ba e0 ff ff ff	 mov	 edx, -32		; ffffffe0H
  00372	0f 4c c2	 cmovl	 eax, edx

; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);

  00375	f7 d8		 neg	 eax
  00377	0f b7 c8	 movzx	 ecx, ax
  0037a	8b c6		 mov	 eax, esi

; 1344 :     if (var2 <= 0)

  0037c	66 85 c9	 test	 cx, cx
  0037f	7f 13		 jg	 SHORT $LL216@A_Refl

; 1345 :     {
; 1346 :         if (var2 < -32)

  00381	66 3b ca	 cmp	 cx, dx
  00384	0f 4c ca	 cmovl	 ecx, edx

; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);

  00387	f7 d9		 neg	 ecx
  00389	8b d1		 mov	 edx, ecx
  0038b	8b ce		 mov	 ecx, esi
  0038d	e8 00 00 00 00	 call	 _L_shr

; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else

  00392	eb 5c		 jmp	 SHORT $LN126@A_Refl
$LL216@A_Refl:

; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00394	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00399	7f 22		 jg	 SHORT $LN172@A_Refl

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0039b	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  003a0	7c 0a		 jl	 SHORT $LN173@A_Refl

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  003a2	49		 dec	 ecx
  003a3	03 c0		 add	 eax, eax
  003a5	66 85 c9	 test	 cx, cx
  003a8	7f ea		 jg	 SHORT $LL216@A_Refl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 80   :       if (sub(abs_s(aState[i]), 4096) >= 0)

  003aa	eb 44		 jmp	 SHORT $LN126@A_Refl
$LN173@A_Refl:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1367 :                     Overflow = 1;

  003ac	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1368 :                     L_var_out = MIN_32;

  003b6	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  003bb	eb 33		 jmp	 SHORT $LN126@A_Refl
$LN172@A_Refl:

; 1358 :             {
; 1359 :                 Overflow = 1;

  003bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 1360 :                 L_var_out = MAX_32;

  003c7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else

  003cc	eb 22		 jmp	 SHORT $LN126@A_Refl
$LN132@A_Refl:

; 1430 :     {
; 1431 :         if (var2 >= 31)

  003ce	66 83 ff 1f	 cmp	 di, 31			; 0000001fH
  003d2	7c 0a		 jl	 SHORT $LN129@A_Refl

; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;

  003d4	33 c0		 xor	 eax, eax
  003d6	85 f6		 test	 esi, esi
  003d8	0f 99 c0	 setns	 al
  003db	48		 dec	 eax

; 1434 :         }
; 1435 :         else

  003dc	eb 12		 jmp	 SHORT $LN126@A_Refl
$LN129@A_Refl:

; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  003de	8b c6		 mov	 eax, esi
  003e0	8b cb		 mov	 ecx, ebx
  003e2	85 f6		 test	 esi, esi
  003e4	79 08		 jns	 SHORT $LN127@A_Refl
  003e6	f7 d0		 not	 eax
  003e8	d3 f8		 sar	 eax, cl
  003ea	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  003ec	eb 02		 jmp	 SHORT $LN126@A_Refl
$LN127@A_Refl:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  003ee	d3 f8		 sar	 eax, cl
$LN126@A_Refl:

; 1775 : #if (WMOPS)
; 1776 :         multiCounter[currCounter].L_shr--;
; 1777 : #endif
; 1778 :         if (var2 > 0)

  003f0	66 85 ff	 test	 di, di
  003f3	7e 0f		 jle	 SHORT $LN120@A_Refl

; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  003f5	8b 4d b4	 mov	 ecx, DWORD PTR tv979[ebp]
  003f8	ba 01 00 00 00	 mov	 edx, 1
  003fd	d3 e2		 shl	 edx, cl
  003ff	85 d6		 test	 edx, esi
  00401	74 01		 je	 SHORT $LN120@A_Refl

; 1781 :             {
; 1782 :                 L_var_out++;

  00403	40		 inc	 eax
$LN120@A_Refl:

; 1783 :             }
; 1784 :         }
; 1785 :     }
; 1786 : #if (WMOPS)
; 1787 :     multiCounter[currCounter].L_shr_r++;
; 1788 : #endif
; 1789 :     return (L_var_out);
; 1790 : }
; 1791 : 
; 1792 : /*___________________________________________________________________________
; 1793 :  |                                                                           |
; 1794 :  |   Function Name : L_abs                                                   |
; 1795 :  |                                                                           |
; 1796 :  |   Purpose :                                                               |
; 1797 :  |                                                                           |
; 1798 :  |    Absolute value of L_var1; Saturate in case where the input is          |
; 1799 :  |                                                               -214783648  |
; 1800 :  |                                                                           |
; 1801 :  |   Complexity weight : 3                                                   |
; 1802 :  |                                                                           |
; 1803 :  |   Inputs :                                                                |
; 1804 :  |                                                                           |
; 1805 :  |    L_var1                                                                 |
; 1806 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1807 :  |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
; 1808 :  |                                                                           |
; 1809 :  |   Outputs :                                                               |
; 1810 :  |                                                                           |
; 1811 :  |    none                                                                   |
; 1812 :  |                                                                           |
; 1813 :  |   Return Value :                                                          |
; 1814 :  |                                                                           |
; 1815 :  |    L_var_out                                                              |
; 1816 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1817 :  |             range : 0x0000 0000 <= var_out <= 0x7fff ffff.                |
; 1818 :  |___________________________________________________________________________|
; 1819 : */
; 1820 : 
; 1821 : Word32 L_abs (Word32 L_var1)
; 1822 : {
; 1823 :     Word32 L_var_out;
; 1824 : 
; 1825 :     if (L_var1 == MIN_32)

  00404	3d 00 00 00 80	 cmp	 eax, -2147483648	; 80000000H
  00409	75 0a		 jne	 SHORT $LN149@A_Refl

; 1826 :     {
; 1827 :         L_var_out = MAX_32;

  0040b	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH

; 1828 :     }
; 1829 :     else

  00410	e9 d0 fe ff ff	 jmp	 $LN146@A_Refl
$LN149@A_Refl:

; 1830 :     {
; 1831 :         if (L_var1 < 0)

  00415	85 c0		 test	 eax, eax
  00417	0f 89 c6 fe ff
	ff		 jns	 $LN147@A_Refl

; 1832 :         {
; 1833 :             L_var_out = -L_var1;

  0041d	8b d0		 mov	 edx, eax
  0041f	f7 da		 neg	 edx

; 1834 :         }
; 1835 :         else

  00421	e9 bf fe ff ff	 jmp	 $LN146@A_Refl
$LN206@A_Refl:

; 80   :     {
; 81   :         Overflow = 1;

  00426	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00430	eb 03		 jmp	 SHORT $ExitRefl$224
$LN217@A_Refl:
  00432	8b 7d d0	 mov	 edi, DWORD PTR _refl$GSCopy$1$[ebp]
$ExitRefl$224:
  00435	0f 57 c0	 xorps	 xmm0, xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\a_refl.c

; 125  :       refl[i] = 0;                           move16 ();

  00438	f3 0f 7f 07	 movdqu	 XMMWORD PTR [edi], xmm0
  0043c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
$LN3@A_Refl:

; 126  :    }
; 127  : }

  00443	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00446	5f		 pop	 edi
  00447	5e		 pop	 esi
  00448	33 cd		 xor	 ecx, ebp
  0044a	5b		 pop	 ebx
  0044b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00450	8b e5		 mov	 esp, ebp
  00452	5d		 pop	 ebp
  00453	c3		 ret	 0
_A_Refl	ENDP
_TEXT	ENDS
END
