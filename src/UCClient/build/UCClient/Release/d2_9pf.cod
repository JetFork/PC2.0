; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d2_9pf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_startPos DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	04H
PUBLIC	_decode_2i40_9bits
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c
;	COMDAT _decode_2i40_9bits
_TEXT	SEGMENT
_var_out$1$ = -16					; size = 4
tv1032 = -16						; size = 4
_pos$ = -16						; size = 4
_var_out$1$ = -12					; size = 4
_var_out$1$ = -8					; size = 4
tv1031 = -8						; size = 4
_subNr$1$ = -2						; size = 2
tv1007 = 8						; size = 4
_index$ = 8						; size = 2
_cod$ = 12						; size = 4
_decode_2i40_9bits PROC					; COMDAT
; _subNr$ = cx
; _sign$ = edx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 64   :     Word16 i, j, k;
; 65   :     Word16 pos[NB_PULSE];
; 66   : 
; 67   :     /* Decode the positions */
; 68   :     /* table bit  is the MSB */ 
; 69   :     j = shr((index & 64),6);                                 logic16 ();

  00008	8b 75 08	 mov	 esi, DWORD PTR _index$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	66 89 4d fe	 mov	 WORD PTR _subNr$1$[ebp], cx
  00011	57		 push	 edi
  00012	83 e0 40	 and	 eax, 64			; 00000040H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00015	7d 0a		 jge	 SHORT $LN12@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00017	98		 cwde
  00018	f7 d0		 not	 eax
  0001a	c1 f8 06	 sar	 eax, 6
  0001d	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  0001f	eb 04		 jmp	 SHORT $LN213@decode_2i4
$LN12@decode_2i4:

; 381  :                 var_out = var1 >> var2;

  00021	66 c1 f8 06	 sar	 ax, 6
$LN213@decode_2i4:
  00025	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 71   :     i = index & 7;                                       logic16 ();

  00028	8b ce		 mov	 ecx, esi
  0002a	83 e1 07	 and	 ecx, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 381  :                 var_out = var1 >> var2;

  0002d	89 45 f4	 mov	 DWORD PTR _var_out$1$[ebp], eax

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00030	0f bf c1	 movsx	 eax, cx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00033	bb 00 80 ff ff	 mov	 ebx, -32768		; ffff8000H
  00038	89 45 f0	 mov	 DWORD PTR tv1032[ebp], eax
  0003b	c7 45 08 ff 7f
	00 00		 mov	 DWORD PTR tv1007[ebp], 32767 ; 00007fffH
  00042	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00049	0f bf c7	 movsx	 eax, di
  0004c	3b f8		 cmp	 edi, eax
  0004e	74 18		 je	 SHORT $LN27@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00050	66 85 c9	 test	 cx, cx
  00053	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0005d	8b c3		 mov	 eax, ebx
  0005f	0f 4f 45 08	 cmovg	 eax, DWORD PTR tv1007[ebp]
  00063	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  00066	eb 03		 jmp	 SHORT $LN24@decode_2i4
$LN27@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00068	0f b7 c7	 movzx	 eax, di
$LN24@decode_2i4:

; 139  :     L_sum = (Word32) var1 + var2;

  0006b	98		 cwde
  0006c	03 45 f0	 add	 eax, DWORD PTR tv1032[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  0006f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00074	7e 13		 jle	 SHORT $LN40@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00076	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00080	c7 45 f8 ff 7f
	00 00		 mov	 DWORD PTR _var_out$1$[ebp], 32767 ; 00007fffH
  00087	eb 1c		 jmp	 SHORT $LN37@decode_2i4
$LN40@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00089	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0008e	7d 0f		 jge	 SHORT $LN38@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  00090	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0009a	89 5d f8	 mov	 DWORD PTR _var_out$1$[ebp], ebx

; 88   :     }
; 89   :     else

  0009d	eb 06		 jmp	 SHORT $LN37@decode_2i4
$LN38@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0009f	0f b7 c0	 movzx	 eax, ax
  000a2	89 45 f8	 mov	 DWORD PTR _var_out$1$[ebp], eax
$LN37@decode_2i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000a5	66 8b 7d fe	 mov	 di, WORD PTR _subNr$1$[ebp]
  000a9	0f bf cf	 movsx	 ecx, di
  000ac	03 c9		 add	 ecx, ecx

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000ae	0f bf c1	 movsx	 eax, cx
  000b1	3b c8		 cmp	 ecx, eax
  000b3	74 1b		 je	 SHORT $LN48@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  000b5	66 85 ff	 test	 di, di
  000b8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000c2	8b c3		 mov	 eax, ebx
  000c4	0f 4f 45 08	 cmovg	 eax, DWORD PTR tv1007[ebp]
  000c8	0f b7 f8	 movzx	 edi, ax
  000cb	89 7d f0	 mov	 DWORD PTR _var_out$1$[ebp], edi

; 304  :         }
; 305  :         else

  000ce	eb 06		 jmp	 SHORT $LN45@decode_2i4
$LN48@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  000d0	0f b7 c1	 movzx	 eax, cx
  000d3	89 45 f0	 mov	 DWORD PTR _var_out$1$[ebp], eax
$LN45@decode_2i4:

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000d6	8b 7d f4	 mov	 edi, DWORD PTR _var_out$1$[ebp]
  000d9	0f bf df	 movsx	 ebx, di
  000dc	c1 e3 03	 shl	 ebx, 3

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000df	0f bf c3	 movsx	 eax, bx
  000e2	3b d8		 cmp	 ebx, eax
  000e4	74 1b		 je	 SHORT $LN59@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  000e6	66 85 ff	 test	 di, di
  000e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000f3	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  000f8	0f 4f 45 08	 cmovg	 eax, DWORD PTR tv1007[ebp]
  000fc	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  000ff	eb 03		 jmp	 SHORT $LN56@decode_2i4
$LN59@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00101	0f b7 c3	 movzx	 eax, bx
$LN56@decode_2i4:

; 139  :     L_sum = (Word32) var1 + var2;

  00104	0f bf f8	 movsx	 edi, ax
  00107	8b 45 f0	 mov	 eax, DWORD PTR _var_out$1$[ebp]
  0010a	98		 cwde
  0010b	03 f8		 add	 edi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0010d	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00113	7e 11		 jle	 SHORT $LN72@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00115	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0011f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00124	eb 1c		 jmp	 SHORT $LN69@decode_2i4
$LN72@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00126	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  0012c	7d 11		 jge	 SHORT $LN70@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  0012e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00138	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0013d	eb 03		 jmp	 SHORT $LN69@decode_2i4
$LN70@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0013f	0f b7 c7	 movzx	 eax, di
$LN69@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 74   :     k = startPos[add(shl(j, 3), shl(subNr, 1))];

  00142	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00143	0f bf 3c 45 00
	00 00 00	 movsx	 edi, WORD PTR _startPos[eax*2]
  0014b	8b 45 f8	 mov	 eax, DWORD PTR _var_out$1$[ebp]
  0014e	98		 cwde
  0014f	03 f8		 add	 edi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00151	81 ff ff 7f 00
	00		 cmp	 edi, 32767		; 00007fffH
  00157	7e 11		 jle	 SHORT $LN82@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00159	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00163	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00168	eb 1c		 jmp	 SHORT $LN79@decode_2i4
$LN82@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0016a	81 ff 00 80 ff
	ff		 cmp	 edi, -32768		; ffff8000H
  00170	7d 11		 jge	 SHORT $LN80@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  00172	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0017c	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00181	eb 03		 jmp	 SHORT $LN79@decode_2i4
$LN80@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00183	0f b7 c7	 movzx	 eax, di
$LN79@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 75   :     pos[0] = add(i, k);                                  move16 ();    

  00186	66 89 45 f0	 mov	 WORD PTR _pos$[ebp], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0018a	66 85 f6	 test	 si, si
  0018d	79 0f		 jns	 SHORT $LN90@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0018f	0f bf c6	 movsx	 eax, si
  00192	f7 d0		 not	 eax
  00194	c1 f8 03	 sar	 eax, 3
  00197	f7 d0		 not	 eax
  00199	0f b7 f0	 movzx	 esi, ax

; 378  :             }
; 379  :             else

  0019c	eb 07		 jmp	 SHORT $LN89@decode_2i4
$LN90@decode_2i4:

; 381  :                 var_out = var1 >> var2;

  0019e	66 c1 fe 03	 sar	 si, 3
  001a2	0f b7 f6	 movzx	 esi, si
$LN89@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 78   :     i = index & 7;                                       logic16 ();

  001a5	83 e6 07	 and	 esi, 7
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  001a8	0f bf c6	 movsx	 eax, si
  001ab	89 45 f8	 mov	 DWORD PTR tv1031[ebp], eax
  001ae	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  001b5	0f bf c7	 movsx	 eax, di
  001b8	3b f8		 cmp	 edi, eax
  001ba	74 1d		 je	 SHORT $LN103@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  001bc	8b 7d 08	 mov	 edi, DWORD PTR tv1007[ebp]
  001bf	66 85 f6	 test	 si, si
  001c2	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  001c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001d1	0f 4f c7	 cmovg	 eax, edi
  001d4	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  001d7	eb 06		 jmp	 SHORT $LN100@decode_2i4
$LN103@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  001d9	0f b7 c7	 movzx	 eax, di
  001dc	8b 7d 08	 mov	 edi, DWORD PTR tv1007[ebp]
$LN100@decode_2i4:

; 139  :     L_sum = (Word32) var1 + var2;

  001df	98		 cwde
  001e0	03 45 f8	 add	 eax, DWORD PTR tv1031[ebp]

; 79   :     if (L_var1 > 0X00007fffL)

  001e3	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001e8	7e 11		 jle	 SHORT $LN116@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  001ea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001f4	be ff 7f 00 00	 mov	 esi, 32767		; 00007fffH
  001f9	eb 1b		 jmp	 SHORT $LN113@decode_2i4
$LN116@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001fb	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00200	7d 11		 jge	 SHORT $LN114@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  00202	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0020c	be 00 80 ff ff	 mov	 esi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00211	eb 03		 jmp	 SHORT $LN113@decode_2i4
$LN114@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00213	0f b7 f0	 movzx	 esi, ax
$LN113@decode_2i4:

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00216	0f bf c1	 movsx	 eax, cx
  00219	3b c8		 cmp	 ecx, eax
  0021b	74 1e		 je	 SHORT $LN124@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0021d	66 83 7d fe 00	 cmp	 WORD PTR _subNr$1$[ebp], 0
  00222	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00227	8b c1		 mov	 eax, ecx
  00229	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00233	0f 4f c7	 cmovg	 eax, edi
  00236	0f b7 f8	 movzx	 edi, ax

; 304  :         }
; 305  :         else

  00239	eb 08		 jmp	 SHORT $LN121@decode_2i4
$LN124@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  0023b	0f b7 f9	 movzx	 edi, cx
  0023e	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
$LN121@decode_2i4:

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00243	0f bf c3	 movsx	 eax, bx
  00246	3b d8		 cmp	 ebx, eax
  00248	74 18		 je	 SHORT $LN135@decode_2i4

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0024a	66 83 7d f4 00	 cmp	 WORD PTR _var_out$1$[ebp], 0
  0024f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00259	0f 4f 4d 08	 cmovg	 ecx, DWORD PTR tv1007[ebp]
  0025d	0f b7 c1	 movzx	 eax, cx

; 304  :         }
; 305  :         else

  00260	eb 03		 jmp	 SHORT $LN132@decode_2i4
$LN135@decode_2i4:

; 306  :         {
; 307  :             var_out = extract_l (result);

  00262	0f b7 c3	 movzx	 eax, bx
$LN132@decode_2i4:

; 139  :     L_sum = (Word32) var1 + var2;

  00265	0f bf c8	 movsx	 ecx, ax
  00268	0f bf c7	 movsx	 eax, di
  0026b	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0026d	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00273	7e 11		 jle	 SHORT $LN148@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  00275	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0027f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00284	eb 1c		 jmp	 SHORT $LN145@decode_2i4
$LN148@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00286	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0028c	7d 11		 jge	 SHORT $LN146@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  0028e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00298	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0029d	eb 03		 jmp	 SHORT $LN145@decode_2i4
$LN146@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0029f	0f b7 c1	 movzx	 eax, cx
$LN145@decode_2i4:

; 139  :     L_sum = (Word32) var1 + var2;

  002a2	98		 cwde
  002a3	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  002a4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002a9	7e 11		 jle	 SHORT $LN158@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  002ab	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002b5	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002ba	eb 1b		 jmp	 SHORT $LN155@decode_2i4
$LN158@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002bc	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002c1	7d 11		 jge	 SHORT $LN156@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  002c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002cd	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002d2	eb 03		 jmp	 SHORT $LN155@decode_2i4
$LN156@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002d4	0f b7 c0	 movzx	 eax, ax
$LN155@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 81   :     k = startPos[add(add(shl(j, 3), shl(subNr, 1)), 1)];

  002d7	98		 cwde
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002d8	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR _startPos[eax*2]
  002e0	0f bf c6	 movsx	 eax, si
  002e3	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  002e5	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  002eb	7e 11		 jle	 SHORT $LN168@decode_2i4

; 80   :     {
; 81   :         Overflow = 1;

  002ed	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002f7	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002fc	eb 1c		 jmp	 SHORT $LN165@decode_2i4
$LN168@decode_2i4:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002fe	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00304	7d 11		 jge	 SHORT $LN166@decode_2i4

; 85   :     {
; 86   :         Overflow = 1;

  00306	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00310	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00315	eb 03		 jmp	 SHORT $LN165@decode_2i4
$LN166@decode_2i4:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00317	0f b7 c1	 movzx	 eax, cx
$LN165@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 87   :         cod[i] = 0;                                      move16 ();

  0031a	8b 7d 0c	 mov	 edi, DWORD PTR _cod$[ebp]

; 88   :     }
; 89   : 
; 90   :     for (j = 0; j < NB_PULSE; j++) {

  0031d	8d 4d f0	 lea	 ecx, DWORD PTR _pos$[ebp]
  00320	0f 57 c0	 xorps	 xmm0, xmm0
  00323	66 89 45 f2	 mov	 WORD PTR _pos$[ebp+2], ax
  00327	bb 02 00 00 00	 mov	 ebx, 2
  0032c	f3 0f 7f 07	 movdqu	 XMMWORD PTR [edi], xmm0
  00330	f3 0f 7f 47 10	 movdqu	 XMMWORD PTR [edi+16], xmm0
  00335	f3 0f 7f 47 20	 movdqu	 XMMWORD PTR [edi+32], xmm0
  0033a	f3 0f 7f 47 30	 movdqu	 XMMWORD PTR [edi+48], xmm0
  0033f	f3 0f 7f 47 40	 movdqu	 XMMWORD PTR [edi+64], xmm0
$LL5@decode_2i4:

; 91   :         i = sign & 1;                                    logic16 ();

  00344	8b f2		 mov	 esi, edx
  00346	83 e6 01	 and	 esi, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00349	66 85 d2	 test	 dx, dx
  0034c	79 0e		 jns	 SHORT $LN180@decode_2i4

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0034e	0f bf c2	 movsx	 eax, dx
  00351	f7 d0		 not	 eax
  00353	d1 f8		 sar	 eax, 1
  00355	f7 d0		 not	 eax
  00357	0f b7 c0	 movzx	 eax, ax

; 378  :             }
; 379  :             else

  0035a	eb 06		 jmp	 SHORT $LN179@decode_2i4
$LN180@decode_2i4:

; 381  :                 var_out = var1 >> var2;

  0035c	66 d1 fa	 sar	 dx, 1
  0035f	0f b7 c2	 movzx	 eax, dx
$LN179@decode_2i4:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d2_9pf.c

; 92   :         sign = shr(sign, 1);

  00362	0f b7 d0	 movzx	 edx, ax

; 93   : 
; 94   :         test ();
; 95   :         if (i != 0) {

  00365	66 85 f6	 test	 si, si

; 96   :             cod[pos[j]] = 8191;                          move16 (); /* +1.0 */

  00368	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  0036b	be ff 1f 00 00	 mov	 esi, 8191		; 00001fffH
  00370	75 05		 jne	 SHORT $LN214@decode_2i4

; 97   :         } else {
; 98   :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  00372	be 00 e0 ff ff	 mov	 esi, -8192		; ffffe000H
$LN214@decode_2i4:

; 88   :     }
; 89   : 
; 90   :     for (j = 0; j < NB_PULSE; j++) {

  00377	83 c1 02	 add	 ecx, 2

; 97   :         } else {
; 98   :             cod[pos[j]] = -8192;                         move16 (); /* -1.0 */

  0037a	66 89 34 47	 mov	 WORD PTR [edi+eax*2], si
  0037e	4b		 dec	 ebx
  0037f	75 c3		 jne	 SHORT $LL5@decode_2i4
  00381	5f		 pop	 edi
  00382	5e		 pop	 esi
  00383	5b		 pop	 ebx

; 99   :         }
; 100  :     }
; 101  : 
; 102  :     return;
; 103  : }

  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
_decode_2i40_9bits ENDP
_TEXT	ENDS
END
