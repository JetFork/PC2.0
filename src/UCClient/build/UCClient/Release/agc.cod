; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\agc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@ ; `string'
PUBLIC	??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@ ; `string'
;	COMDAT ??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@ DB 'agc_reset: '
	DB	'invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@
CONST	SEGMENT
??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@ DB 'agc_init: c'
	DB	'an not malloc state structure', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@ DB 'agc_init: in'
	DB	'valid parameter', 0aH, 00H			; `string'
PUBLIC	_agc2
PUBLIC	_agc
PUBLIC	_agc_exit
PUBLIC	_agc_init
PUBLIC	_agc_reset
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_reset
_TEXT	SEGMENT
_agc_reset PROC						; COMDAT

; 145  :   if (state == (agcState *) NULL){
; 146  :       fprintf(stderr, "agc_reset: invalid parameter\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FONHCIDC@agc_reset?3?5invalid?5parameter?6?$AA@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000b	83 c0 40	 add	 eax, 64			; 00000040H
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00015	83 c4 08	 add	 esp, 8

; 147  :       return -1;

  00018	83 c8 ff	 or	 eax, -1

; 148  :   }
; 149  :   
; 150  :   state->past_gain = 4096;   /* initial value of past_gain = 1.0  */
; 151  :   
; 152  :   return 0;
; 153  : }

  0001b	c3		 ret	 0
_agc_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_init
_TEXT	SEGMENT
_agc_init PROC						; COMDAT
; _state$ = ecx

; 114  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 115  :   agcState* s;
; 116  :  
; 117  :   if (state == (agcState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@agc_init

; 118  :       fprintf(stderr, "agc_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MDHFPEHP@agc_init?3?5invalid?5parameter?6?$AA@
$LN8@agc_init:
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 119  :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 133  : }

  00023	c3		 ret	 0
$LN2@agc_init:

; 120  :   }
; 121  :   *state = NULL;
; 122  :  
; 123  :   /* allocate memory */
; 124  :   if ((s= (agcState *) malloc(sizeof(agcState))) == NULL){

  00024	6a 02		 push	 2
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN1@agc_init

; 125  :       fprintf(stderr, "agc_init: can not malloc state structure\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@GCPNNFM@agc_init?3?5can?5not?5malloc?5state?5s@

; 126  :       return -1;

  0003e	eb cc		 jmp	 SHORT $LN8@agc_init
$LN1@agc_init:

; 134  :  
; 135  : /*
; 136  : **************************************************************************
; 137  : *
; 138  : *  Function    : agc_reset
; 139  : *  Purpose     : Reset of agc (i.e. set state memory to 1.0)
; 140  : *
; 141  : **************************************************************************
; 142  : */
; 143  : int agc_reset (agcState *state)
; 144  : {
; 145  :   if (state == (agcState *) NULL){
; 146  :       fprintf(stderr, "agc_reset: invalid parameter\n");
; 147  :       return -1;
; 148  :   }
; 149  :   
; 150  :   state->past_gain = 4096;   /* initial value of past_gain = 1.0  */

  00040	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00045	66 89 08	 mov	 WORD PTR [eax], cx

; 127  :   }
; 128  :   
; 129  :   agc_reset(s);
; 130  :   *state = s;

  00048	89 06		 mov	 DWORD PTR [esi], eax

; 131  :   
; 132  :   return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	5e		 pop	 esi

; 133  : }

  0004d	c3		 ret	 0
_agc_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc_exit
_TEXT	SEGMENT
_agc_exit PROC						; COMDAT
; _state$ = ecx

; 164  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 165  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@agc_exit
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@agc_exit

; 166  :       return;
; 167  :  
; 168  :   /* deallocate memory */
; 169  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 170  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@agc_exit:
  0001d	5e		 pop	 esi

; 171  :   
; 172  :   return;
; 173  : }

  0001e	c3		 ret	 0
_agc_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc
_TEXT	SEGMENT
_gain_out$1$ = -8					; size = 4
tv815 = -8						; size = 4
_st$1$ = -4						; size = 4
_sig_out$ = 8						; size = 4
_agc_fac$dead$ = 12					; size = 2
_l_trm$dead$ = 16					; size = 2
_agc	PROC						; COMDAT
; _st$ = ecx
; _sig_in$ = edx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b da		 mov	 ebx, edx

; 191  :     Word16 i, exp;
; 192  :     Word16 gain_in, gain_out, g0, gain;
; 193  :     Word32 s;
; 194  :             
; 195  :     /* calculate gain_out with exponent */
; 196  :     s = energy_new(sig_out, l_trm); move32 (); /* function result */

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _sig_out$[ebp]
  00010	89 7d fc	 mov	 DWORD PTR _st$1$[ebp], edi
  00013	e8 00 00 00 00	 call	 _energy_new
  00018	8b f0		 mov	 esi, eax

; 197  :         
; 198  :     test (); 
; 199  :     if (s == 0)

  0001a	85 f6		 test	 esi, esi
  0001c	75 0a		 jne	 SHORT $LN6@agc

; 200  :     {
; 201  :         st->past_gain = 0;          move16 (); 

  0001e	66 89 07	 mov	 WORD PTR [edi], ax
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx

; 253  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN6@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00028	83 fe ff	 cmp	 esi, -1
  0002b	75 05		 jne	 SHORT $LN20@agc

; 2116 :         {
; 2117 :             var_out = 31;

  0002d	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]

; 2118 :         }
; 2119 :         else

  00030	eb 19		 jmp	 SHORT $LN15@agc
$LN20@agc:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00032	85 f6		 test	 esi, esi
  00034	79 02		 jns	 SHORT $LN18@agc

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00036	f7 d0		 not	 eax
$LN18@agc:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00038	33 c9		 xor	 ecx, ecx
  0003a	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0003f	7d 0a		 jge	 SHORT $LN15@agc
$LL17@agc:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00041	03 c0		 add	 eax, eax
  00043	41		 inc	 ecx
  00044	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00049	7c f6		 jl	 SHORT $LL17@agc
$LN15@agc:

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0004b	0f bf c1	 movsx	 eax, cx
  0004e	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0004f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00054	7e 11		 jle	 SHORT $LN30@agc

; 80   :     {
; 81   :         Overflow = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00060	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  00065	eb 1b		 jmp	 SHORT $LN27@agc
$LN30@agc:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00067	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0006c	7d 11		 jge	 SHORT $LN28@agc

; 85   :     {
; 86   :         Overflow = 1;

  0006e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00078	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0007d	eb 03		 jmp	 SHORT $LN27@agc
$LN28@agc:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0007f	0f b7 f8	 movzx	 edi, ax
$LN27@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 205  :     gain_out = round (L_shl (s, exp));

  00082	8b d7		 mov	 edx, edi
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 _L_shl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  0008b	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00091	85 c0		 test	 eax, eax
  00093	78 1d		 js	 SHORT $LN37@agc

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00095	8b ca		 mov	 ecx, edx
  00097	33 c8		 xor	 ecx, eax
  00099	79 17		 jns	 SHORT $LN37@agc

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0009b	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  0009d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000a7	85 c0		 test	 eax, eax
  000a9	0f 98 c2	 sets	 dl
  000ac	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN37@agc:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  000b2	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 208  :     s = energy_new(sig_in, l_trm);   move32 (); /* function result */

  000b5	8b cb		 mov	 ecx, ebx
  000b7	0f b7 c2	 movzx	 eax, dx
  000ba	89 45 f8	 mov	 DWORD PTR _gain_out$1$[ebp], eax
  000bd	e8 00 00 00 00	 call	 _energy_new
  000c2	8b c8		 mov	 ecx, eax

; 209  :     
; 210  :     test (); 
; 211  :     if (s == 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	0f 84 53 01 00
	00		 je	 $LN4@agc
$LN5@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  000cc	83 f9 ff	 cmp	 ecx, -1
  000cf	75 05		 jne	 SHORT $LN54@agc

; 2116 :         {
; 2117 :             var_out = 31;

  000d1	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  000d4	eb 19		 jmp	 SHORT $LN49@agc
$LN54@agc:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  000d6	85 c9		 test	 ecx, ecx
  000d8	79 02		 jns	 SHORT $LN52@agc

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  000da	f7 d0		 not	 eax
$LN52@agc:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  000dc	33 f6		 xor	 esi, esi
  000de	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000e3	7d 0a		 jge	 SHORT $LN49@agc
$LL51@agc:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  000e5	03 c0		 add	 eax, eax
  000e7	46		 inc	 esi
  000e8	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000ed	7c f6		 jl	 SHORT $LL51@agc
$LN49@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 218  :         gain_in = round (L_shl (s, i));

  000ef	8b d6		 mov	 edx, esi
  000f1	e8 00 00 00 00	 call	 _L_shl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  000f6	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000fc	85 c0		 test	 eax, eax
  000fe	78 1d		 js	 SHORT $LN61@agc

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00100	8b ca		 mov	 ecx, edx
  00102	33 c8		 xor	 ecx, eax
  00104	79 17		 jns	 SHORT $LN61@agc

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00106	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00108	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00112	85 c0		 test	 eax, eax
  00114	0f 98 c2	 sets	 dl
  00117	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN61@agc:

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0011d	0f bf c6	 movsx	 eax, si
  00120	0f bf cf	 movsx	 ecx, di

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00123	c1 fa 10	 sar	 edx, 16			; 00000010H

; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00126	2b c8		 sub	 ecx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 218  :         gain_in = round (L_shl (s, i));

  00128	0f b7 d2	 movzx	 edx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  0012b	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00131	7e 11		 jle	 SHORT $LN72@agc

; 80   :     {
; 81   :         Overflow = 1;

  00133	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0013d	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  00142	eb 1c		 jmp	 SHORT $LN69@agc
$LN72@agc:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00144	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0014a	7d 11		 jge	 SHORT $LN70@agc

; 85   :     {
; 86   :         Overflow = 1;

  0014c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00156	bf 00 80 ff ff	 mov	 edi, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0015b	eb 03		 jmp	 SHORT $LN69@agc
$LN70@agc:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0015d	0f b7 f9	 movzx	 edi, cx
$LN69@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 225  :         s = L_deposit_l (div_s (gain_out, gain_in));

  00160	8b 4d f8	 mov	 ecx, DWORD PTR _gain_out$1$[ebp]

; 226  :         s = L_shl (s, 7);       /* s = gain_out / gain_in */

  00163	be 07 00 00 00	 mov	 esi, 7
  00168	e8 00 00 00 00	 call	 _div_s
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1715 :     L_var_out = (Word32) var1;

  0016d	0f bf c8	 movsx	 ecx, ax
$LL87@agc:

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00170	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00176	7f 19		 jg	 SHORT $LN198@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00178	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0017e	7c 0a		 jl	 SHORT $LN199@agc

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00180	4e		 dec	 esi
  00181	03 c9		 add	 ecx, ecx
  00183	66 85 f6	 test	 si, si
  00186	7f e8		 jg	 SHORT $LL87@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00188	eb 16		 jmp	 SHORT $LN82@agc
$LN199@agc:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0018a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0018f	eb 05		 jmp	 SHORT $LN227@agc
$LN198@agc:

; 1360 :                 L_var_out = MAX_32;

  00191	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN227@agc:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00196	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN82@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 227  :         s = L_shr (s, exp);     /* add exponent */

  001a0	8b d7		 mov	 edx, edi
  001a2	e8 00 00 00 00	 call	 _L_shr

; 228  : 
; 229  :         s = Inv_sqrt (s); move32 (); /* function result */

  001a7	8b c8		 mov	 ecx, eax

; 230  :         i = round (L_shl (s, 9));

  001a9	be 09 00 00 00	 mov	 esi, 9
  001ae	e8 00 00 00 00	 call	 _Inv_sqrt
  001b3	8b c8		 mov	 ecx, eax
$LL109@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  001b5	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  001bb	7f 19		 jg	 SHORT $LN200@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  001bd	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  001c3	7c 0a		 jl	 SHORT $LN201@agc

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  001c5	4e		 dec	 esi
  001c6	03 c9		 add	 ecx, ecx
  001c8	66 85 f6	 test	 si, si
  001cb	7f e8		 jg	 SHORT $LL109@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  001cd	eb 16		 jmp	 SHORT $LN104@agc
$LN201@agc:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  001cf	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001d4	eb 05		 jmp	 SHORT $LN228@agc
$LN200@agc:

; 1360 :                 L_var_out = MAX_32;

  001d6	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN228@agc:

; 1358 :             {
; 1359 :                 Overflow = 1;

  001db	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN104@agc:

; 931  :     L_var_out = L_var1 + L_var2;

  001e5	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001eb	85 c9		 test	 ecx, ecx
  001ed	78 1d		 js	 SHORT $LN123@agc

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001ef	8b c2		 mov	 eax, edx
  001f1	33 c1		 xor	 eax, ecx
  001f3	79 17		 jns	 SHORT $LN123@agc

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  001f5	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  001f7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00201	85 c9		 test	 ecx, ecx
  00203	0f 98 c2	 sets	 dl
  00206	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN123@agc:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0020c	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 230  :         i = round (L_shl (s, 9));

  0020f	0f b7 ca	 movzx	 ecx, dx

; 231  : 
; 232  :         /* g0 = i * (1-agc_fac) */
; 233  :         g0 = mult (i, sub (32767, agc_fac));

  00212	ba cc 0c 00 00	 mov	 edx, 3276		; 00000cccH
  00217	e8 00 00 00 00	 call	 _mult
  0021c	0f b7 c0	 movzx	 eax, ax
$LN4@agc:

; 234  :     }
; 235  : 
; 236  :     /* compute gain[n] = agc_fac * gain[n-1]
; 237  :                         + (1-agc_fac) * sqrt(gain_in/gain_out) */
; 238  :     /* sig_out[n] = gain[n] * sig_out[n]                        */
; 239  : 
; 240  :     gain = st->past_gain;           move16 (); 

  0021f	8b 4d fc	 mov	 ecx, DWORD PTR _st$1$[ebp]
  00222	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  00227	8b 5d 08	 mov	 ebx, DWORD PTR _sig_out$[ebp]
  0022a	0f b7 31	 movzx	 esi, WORD PTR [ecx]
  0022d	0f bf c8	 movsx	 ecx, ax
  00230	89 4d f8	 mov	 DWORD PTR tv815[ebp], ecx
$LL3@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00233	0f bf c6	 movsx	 eax, si
  00236	69 c0 33 73 00
	00		 imul	 eax, eax, 29491

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0023c	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0023f	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00244	74 05		 je	 SHORT $LN141@agc

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00246	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN141@agc:

; 79   :     if (L_var1 > 0X00007fffL)

  0024b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00250	7e 11		 jle	 SHORT $LN147@agc

; 80   :     {
; 81   :         Overflow = 1;

  00252	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0025c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00261	eb 1b		 jmp	 SHORT $LN144@agc
$LN147@agc:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00263	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00268	7d 11		 jge	 SHORT $LN145@agc

; 85   :     {
; 86   :         Overflow = 1;

  0026a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00274	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00279	eb 03		 jmp	 SHORT $LN144@agc
$LN145@agc:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0027b	0f b7 c0	 movzx	 eax, ax
$LN144@agc:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;

  0027e	98		 cwde
  0027f	03 c1		 add	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  00281	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00286	7e 11		 jle	 SHORT $LN157@agc

; 80   :     {
; 81   :         Overflow = 1;

  00288	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00292	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00297	eb 1b		 jmp	 SHORT $LN154@agc
$LN157@agc:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00299	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0029e	7d 11		 jge	 SHORT $LN155@agc

; 85   :     {
; 86   :         Overflow = 1;

  002a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002aa	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002af	eb 03		 jmp	 SHORT $LN154@agc
$LN155@agc:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002b1	0f b7 d0	 movzx	 edx, ax
$LN154@agc:

; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  002b4	0f bf 0b	 movsx	 ecx, WORD PTR [ebx]
  002b7	0f bf c2	 movsx	 eax, dx
  002ba	0f af c8	 imul	 ecx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 245  :         gain = add (gain, g0);

  002bd	0f b7 f2	 movzx	 esi, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 487  :     if (L_var_out != (Word32) 0x40000000L)

  002c0	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  002c6	74 05		 je	 SHORT $LN163@agc

; 488  :     {
; 489  :         L_var_out *= 2;

  002c8	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 490  :     }
; 491  :     else

  002cb	eb 0f		 jmp	 SHORT $LN162@agc
$LN163@agc:

; 492  :     {
; 493  :         Overflow = 1;

  002cd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  002d7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN162@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 246  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], gain), 3));

  002dc	b9 03 00 00 00	 mov	 ecx, 3
$LL174@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  002e1	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  002e6	7f 18		 jg	 SHORT $LN202@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  002e8	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  002ed	7c 0a		 jl	 SHORT $LN203@agc

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  002ef	49		 dec	 ecx
  002f0	03 c0		 add	 eax, eax
  002f2	66 85 c9	 test	 cx, cx
  002f5	7f ea		 jg	 SHORT $LL174@agc

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  002f7	eb 16		 jmp	 SHORT $LN169@agc
$LN203@agc:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  002f9	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  002fe	eb 05		 jmp	 SHORT $LN229@agc
$LN202@agc:

; 1360 :                 L_var_out = MAX_32;

  00300	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN229@agc:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00305	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN169@agc:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 242  :     for (i = 0; i < l_trm; i++)

  0030f	8b 4d f8	 mov	 ecx, DWORD PTR tv815[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00312	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 246  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], gain), 3));

  00315	66 89 03	 mov	 WORD PTR [ebx], ax
  00318	83 c3 02	 add	 ebx, 2
  0031b	4f		 dec	 edi
  0031c	0f 85 11 ff ff
	ff		 jne	 $LL3@agc

; 247  :                                 move16 (); 
; 248  :     }
; 249  : 
; 250  :     st->past_gain = gain;           move16 (); 

  00322	8b 45 fc	 mov	 eax, DWORD PTR _st$1$[ebp]
  00325	5f		 pop	 edi
  00326	5e		 pop	 esi
  00327	5b		 pop	 ebx
  00328	66 89 10	 mov	 WORD PTR [eax], dx

; 251  : 
; 252  :     return 0;

  0032b	33 c0		 xor	 eax, eax

; 253  : }

  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c3		 ret	 0
_agc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _agc2
_TEXT	SEGMENT
_gain_out$1$ = -12					; size = 4
_sig_in$1$ = -8						; size = 4
_var_out$1$ = -4					; size = 4
_l_trm$dead$ = 8					; size = 2
_agc2	PROC						; COMDAT
; _sig_in$ = ecx
; _sig_out$ = edx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	89 4d f8	 mov	 DWORD PTR _sig_in$1$[ebp], ecx

; 269  :     Word16 i, exp;
; 270  :     Word16 gain_in, gain_out, g0;
; 271  :     Word32 s;
; 272  :     
; 273  :     /* calculate gain_out with exponent */
; 274  :     s = energy_new(sig_out, l_trm);   move32 (); /* function result */

  0000d	8b cf		 mov	 ecx, edi
  0000f	e8 00 00 00 00	 call	 _energy_new
  00014	8b d8		 mov	 ebx, eax

; 275  :         
; 276  :     test (); 
; 277  :     if (s == 0)

  00016	85 db		 test	 ebx, ebx
  00018	0f 84 72 02 00
	00		 je	 $LN1@agc2

; 278  :     {
; 279  :         return;
; 280  :     }
; 281  :     exp = sub (norm_l (s), 1);

  0001e	56		 push	 esi
  0001f	8b f3		 mov	 esi, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00021	83 fb ff	 cmp	 ebx, -1
  00024	75 05		 jne	 SHORT $LN18@agc2

; 2116 :         {
; 2117 :             var_out = 31;

  00026	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]

; 2118 :         }
; 2119 :         else

  00029	eb 20		 jmp	 SHORT $LN13@agc2
$LN18@agc2:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  0002b	85 db		 test	 ebx, ebx
  0002d	79 02		 jns	 SHORT $LN16@agc2

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  0002f	f7 d6		 not	 esi
$LN16@agc2:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  00031	33 c9		 xor	 ecx, ecx
  00033	81 fe 00 00 00
	40		 cmp	 esi, 1073741824		; 40000000H
  00039	7d 10		 jge	 SHORT $LN13@agc2
  0003b	eb 03 8d 49 00	 npad	 5
$LL15@agc2:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00040	03 f6		 add	 esi, esi
  00042	41		 inc	 ecx
  00043	81 fe 00 00 00
	40		 cmp	 esi, 1073741824		; 40000000H
  00049	7c f5		 jl	 SHORT $LL15@agc2
$LN13@agc2:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  0004b	0f bf c1	 movsx	 eax, cx
  0004e	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0004f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00054	7e 11		 jle	 SHORT $LN28@agc2

; 80   :     {
; 81   :         Overflow = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00060	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00065	eb 1b		 jmp	 SHORT $LN189@agc2
$LN28@agc2:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00067	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0006c	7d 11		 jge	 SHORT $LN26@agc2

; 85   :     {
; 86   :         Overflow = 1;

  0006e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00078	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0007d	eb 03		 jmp	 SHORT $LN189@agc2
$LN26@agc2:

; 91   :         var_out = extract_l (L_var1);

  0007f	0f b7 c0	 movzx	 eax, ax
$LN189@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 282  :     gain_out = round (L_shl (s, exp));

  00082	8b d0		 mov	 edx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  00084	89 45 fc	 mov	 DWORD PTR _var_out$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 282  :     gain_out = round (L_shl (s, exp));

  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 _L_shl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  0008e	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00094	85 c0		 test	 eax, eax
  00096	78 1d		 js	 SHORT $LN35@agc2

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00098	8b ca		 mov	 ecx, edx
  0009a	33 c8		 xor	 ecx, eax
  0009c	79 17		 jns	 SHORT $LN35@agc2

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0009e	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  000a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000aa	85 c0		 test	 eax, eax
  000ac	0f 98 c2	 sets	 dl
  000af	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN35@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 285  :     s = energy_new(sig_in, l_trm);   move32 (); /* function result */

  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _sig_in$1$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  000b8	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 282  :     gain_out = round (L_shl (s, exp));

  000bb	0f b7 c2	 movzx	 eax, dx
  000be	89 45 f4	 mov	 DWORD PTR _gain_out$1$[ebp], eax

; 285  :     s = energy_new(sig_in, l_trm);   move32 (); /* function result */

  000c1	e8 00 00 00 00	 call	 _energy_new
  000c6	8b c8		 mov	 ecx, eax

; 286  :     
; 287  :     test (); 
; 288  :     if (s == 0)

  000c8	85 c9		 test	 ecx, ecx
  000ca	0f 84 52 01 00
	00		 je	 $LN4@agc2
$LN5@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  000d0	83 f9 ff	 cmp	 ecx, -1
  000d3	75 05		 jne	 SHORT $LN52@agc2

; 2116 :         {
; 2117 :             var_out = 31;

  000d5	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  000d8	eb 20		 jmp	 SHORT $LN47@agc2
$LN52@agc2:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  000da	85 c9		 test	 ecx, ecx
  000dc	79 02		 jns	 SHORT $LN50@agc2

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  000de	f7 d0		 not	 eax
$LN50@agc2:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  000e0	33 f6		 xor	 esi, esi
  000e2	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000e7	7d 11		 jge	 SHORT $LN47@agc2
  000e9	8d a4 24 00 00
	00 00		 npad	 7
$LL49@agc2:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  000f0	03 c0		 add	 eax, eax
  000f2	46		 inc	 esi
  000f3	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000f8	7c f6		 jl	 SHORT $LL49@agc2
$LN47@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 295  :         gain_in = round (L_shl (s, i));

  000fa	8b d6		 mov	 edx, esi
  000fc	e8 00 00 00 00	 call	 _L_shl
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  00101	8d 90 00 80 00
	00		 lea	 edx, DWORD PTR [eax+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00107	85 c0		 test	 eax, eax
  00109	78 1d		 js	 SHORT $LN59@agc2

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  0010b	8b ca		 mov	 ecx, edx
  0010d	33 c8		 xor	 ecx, eax
  0010f	79 17		 jns	 SHORT $LN59@agc2

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00111	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00113	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0011d	85 c0		 test	 eax, eax
  0011f	0f 98 c2	 sets	 dl
  00122	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN59@agc2:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _var_out$1$[ebp]
  0012b	0f bf c6	 movsx	 eax, si
  0012e	0f bf c9	 movsx	 ecx, cx

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00131	c1 fa 10	 sar	 edx, 16			; 00000010H

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00134	2b c8		 sub	 ecx, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 295  :         gain_in = round (L_shl (s, i));

  00136	0f b7 d2	 movzx	 edx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 79   :     if (L_var1 > 0X00007fffL)

  00139	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0013f	7e 11		 jle	 SHORT $LN70@agc2

; 80   :     {
; 81   :         Overflow = 1;

  00141	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0014b	bb ff 7f 00 00	 mov	 ebx, 32767		; 00007fffH
  00150	eb 1c		 jmp	 SHORT $LN67@agc2
$LN70@agc2:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00152	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00158	7d 11		 jge	 SHORT $LN68@agc2

; 85   :     {
; 86   :         Overflow = 1;

  0015a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00164	bb 00 80 ff ff	 mov	 ebx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00169	eb 03		 jmp	 SHORT $LN67@agc2
$LN68@agc2:

; 91   :         var_out = extract_l (L_var1);

  0016b	0f b7 d9	 movzx	 ebx, cx
$LN67@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 302  :         s = L_deposit_l (div_s (gain_out, gain_in));

  0016e	8b 4d f4	 mov	 ecx, DWORD PTR _gain_out$1$[ebp]

; 303  :         s = L_shl (s, 7);       /* s = gain_out / gain_in */

  00171	be 07 00 00 00	 mov	 esi, 7
  00176	e8 00 00 00 00	 call	 _div_s
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1715 :     L_var_out = (Word32) var1;

  0017b	0f bf c8	 movsx	 ecx, ax
  0017e	8b ff		 npad	 2
$LL85@agc2:

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00180	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00186	7f 19		 jg	 SHORT $LN161@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00188	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0018e	7c 0a		 jl	 SHORT $LN162@agc2

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00190	4e		 dec	 esi
  00191	03 c9		 add	 ecx, ecx
  00193	66 85 f6	 test	 si, si
  00196	7f e8		 jg	 SHORT $LL85@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00198	eb 16		 jmp	 SHORT $LN80@agc2
$LN162@agc2:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0019a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0019f	eb 05		 jmp	 SHORT $LN190@agc2
$LN161@agc2:

; 1360 :                 L_var_out = MAX_32;

  001a1	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN190@agc2:

; 1358 :             {
; 1359 :                 Overflow = 1;

  001a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN80@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 304  :         s = L_shr (s, exp);     /* add exponent */

  001b0	8b d3		 mov	 edx, ebx
  001b2	e8 00 00 00 00	 call	 _L_shr

; 305  : 
; 306  :         s = Inv_sqrt (s); move32 (); /* function result */

  001b7	8b c8		 mov	 ecx, eax

; 307  :         g0 = round (L_shl (s, 9));

  001b9	be 09 00 00 00	 mov	 esi, 9
  001be	e8 00 00 00 00	 call	 _Inv_sqrt
  001c3	8b c8		 mov	 ecx, eax
$LL107@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  001c5	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  001cb	7f 19		 jg	 SHORT $LN163@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  001cd	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  001d3	7c 0a		 jl	 SHORT $LN164@agc2

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  001d5	4e		 dec	 esi
  001d6	03 c9		 add	 ecx, ecx
  001d8	66 85 f6	 test	 si, si
  001db	7f e8		 jg	 SHORT $LL107@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  001dd	eb 16		 jmp	 SHORT $LN102@agc2
$LN164@agc2:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  001df	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001e4	eb 05		 jmp	 SHORT $LN191@agc2
$LN163@agc2:

; 1360 :                 L_var_out = MAX_32;

  001e6	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN191@agc2:

; 1358 :             {
; 1359 :                 Overflow = 1;

  001eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN102@agc2:

; 931  :     L_var_out = L_var1 + L_var2;

  001f5	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001fb	85 c9		 test	 ecx, ecx
  001fd	78 1d		 js	 SHORT $LN121@agc2

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001ff	8b c2		 mov	 eax, edx
  00201	33 c1		 xor	 eax, ecx
  00203	79 17		 jns	 SHORT $LN121@agc2

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00205	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  00207	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00211	85 c9		 test	 ecx, ecx
  00213	0f 98 c2	 sets	 dl
  00216	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN121@agc2:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  0021c	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 307  :         g0 = round (L_shl (s, 9));

  0021f	0f b7 c2	 movzx	 eax, dx
$LN4@agc2:

; 308  :     }
; 309  : 
; 310  :     /* sig_out(n) = gain(n) sig_out(n) */
; 311  : 
; 312  :     for (i = 0; i < l_trm; i++)

  00222	0f bf f0	 movsx	 esi, ax
  00225	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0022a	8d 9b 00 00 00
	00		 npad	 6
$LL3@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00230	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00233	0f af c6	 imul	 eax, esi

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00236	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0023b	74 04		 je	 SHORT $LN128@agc2

; 488  :     {
; 489  :         L_var_out *= 2;

  0023d	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0023f	eb 0f		 jmp	 SHORT $LN127@agc2
$LN128@agc2:

; 492  :     {
; 493  :         Overflow = 1;

  00241	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0024b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN127@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 314  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], g0), 3));

  00250	b9 03 00 00 00	 mov	 ecx, 3
$LL139@agc2:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00255	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0025a	7f 18		 jg	 SHORT $LN165@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0025c	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  00261	7c 0a		 jl	 SHORT $LN166@agc2

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00263	49		 dec	 ecx
  00264	03 c0		 add	 eax, eax
  00266	66 85 c9	 test	 cx, cx
  00269	7f ea		 jg	 SHORT $LL139@agc2

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0026b	eb 16		 jmp	 SHORT $LN134@agc2
$LN166@agc2:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0026d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00272	eb 05		 jmp	 SHORT $LN192@agc2
$LN165@agc2:

; 1360 :                 L_var_out = MAX_32;

  00274	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN192@agc2:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00279	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN134@agc2:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00283	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 314  :         sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], g0), 3));

  00286	66 89 07	 mov	 WORD PTR [edi], ax
  00289	83 c7 02	 add	 edi, 2
  0028c	4a		 dec	 edx
  0028d	75 a1		 jne	 SHORT $LL3@agc2
  0028f	5e		 pop	 esi
$LN1@agc2:
  00290	5f		 pop	 edi
  00291	5b		 pop	 ebx

; 315  :                                 move16 (); 
; 316  :     }
; 317  : 
; 318  :     return;
; 319  : }

  00292	8b e5		 mov	 esp, ebp
  00294	5d		 pop	 ebp
  00295	c3		 ret	 0
_agc2	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _energy_old
_TEXT	SEGMENT
_energy_old PROC					; COMDAT
; _in$ = ecx
; _l_trm$dead$ = dx

; 53   :     Word32 s;
; 54   :     Word16 i, temp;
; 55   : 
; 56   :     temp = shr (in[0], 2);

  00000	0f b7 01	 movzx	 eax, WORD PTR [ecx]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00003	66 85 c0	 test	 ax, ax
  00006	79 0a		 jns	 SHORT $LN7@energy_old

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  00008	98		 cwde
  00009	f7 d0		 not	 eax
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00010	eb 04		 jmp	 SHORT $LN53@energy_old
$LN7@energy_old:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00012	66 c1 f8 02	 sar	 ax, 2
$LN53@energy_old:
  00016	0f b7 c0	 movzx	 eax, ax

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00019	0f bf d0	 movsx	 edx, ax
  0001c	0f af d2	 imul	 edx, edx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0001f	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  00025	74 04		 je	 SHORT $LN16@energy_old

; 488  :     {
; 489  :         L_var_out *= 2;

  00027	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  00029	eb 0f		 jmp	 SHORT $LN15@energy_old
$LN16@energy_old:

; 492  :     {
; 493  :         Overflow = 1;

  0002b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00035	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN15@energy_old:
  0003a	56		 push	 esi
  0003b	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 57   :     s = L_mult (temp, temp);

  0003c	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
  0003f	bf 27 00 00 00	 mov	 edi, 39			; 00000027H
$LL3@energy_old:

; 60   :     {
; 61   :         temp = shr (in[i], 2);

  00044	0f b7 06	 movzx	 eax, WORD PTR [esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  00047	66 85 c0	 test	 ax, ax
  0004a	79 0a		 jns	 SHORT $LN20@energy_old

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0004c	98		 cwde
  0004d	f7 d0		 not	 eax
  0004f	c1 f8 02	 sar	 eax, 2
  00052	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00054	eb 04		 jmp	 SHORT $LN54@energy_old
$LN20@energy_old:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00056	66 c1 f8 02	 sar	 ax, 2
$LN54@energy_old:
  0005a	0f b7 c0	 movzx	 eax, ax

; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;
; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;
; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)
; 437  :         L_product = L_product | (Word32) 0xffff0000L;
; 438  : 
; 439  :     var_out = saturate (L_product);
; 440  : #if (WMOPS)
; 441  :     multiCounter[currCounter].mult++;
; 442  : #endif
; 443  :     return (var_out);
; 444  : }
; 445  : 
; 446  : /*___________________________________________________________________________
; 447  :  |                                                                           |
; 448  :  |   Function Name : L_mult                                                  |
; 449  :  |                                                                           |
; 450  :  |   Purpose :                                                               |
; 451  :  |                                                                           |
; 452  :  |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
; 453  :  |   with one shift left i.e.:                                               |
; 454  :  |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
; 455  :  |        L_mult(-32768,-32768) = 2147483647.                                |
; 456  :  |                                                                           |
; 457  :  |   Complexity weight : 1                                                   |
; 458  :  |                                                                           |
; 459  :  |   Inputs :                                                                |
; 460  :  |                                                                           |
; 461  :  |    var1                                                                   |
; 462  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 463  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 464  :  |                                                                           |
; 465  :  |    var2                                                                   |
; 466  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 467  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 468  :  |                                                                           |
; 469  :  |   Outputs :                                                               |
; 470  :  |                                                                           |
; 471  :  |    none                                                                   |
; 472  :  |                                                                           |
; 473  :  |   Return Value :                                                          |
; 474  :  |                                                                           |
; 475  :  |    L_var_out                                                              |
; 476  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 477  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 478  :  |___________________________________________________________________________|
; 479  : */
; 480  : 
; 481  : Word32 L_mult (Word16 var1, Word16 var2)
; 482  : {
; 483  :     Word32 L_var_out;
; 484  : 
; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0005d	98		 cwde
  0005e	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00061	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00066	74 04		 je	 SHORT $LN42@energy_old

; 488  :     {
; 489  :         L_var_out *= 2;

  00068	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0006a	eb 0f		 jmp	 SHORT $LN41@energy_old
$LN42@energy_old:

; 492  :     {
; 493  :         Overflow = 1;

  0006c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00076	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN41@energy_old:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  0007b	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0007e	33 c2		 xor	 eax, edx
  00080	78 1d		 js	 SHORT $LN45@energy_old

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00082	8b c1		 mov	 eax, ecx
  00084	33 c2		 xor	 eax, edx
  00086	79 17		 jns	 SHORT $LN45@energy_old

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00088	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00094	85 d2		 test	 edx, edx
  00096	0f 98 c1	 sets	 cl
  00099	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN45@energy_old:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 59   :     for (i = 1; i < l_trm; i++)

  0009f	83 c6 02	 add	 esi, 2

; 62   :         s = L_mac (s, temp, temp);

  000a2	8b d1		 mov	 edx, ecx
  000a4	4f		 dec	 edi
  000a5	75 9d		 jne	 SHORT $LL3@energy_old

; 63   :     }
; 64   : 
; 65   :     return s;

  000a7	5f		 pop	 edi
  000a8	8b c1		 mov	 eax, ecx
  000aa	5e		 pop	 esi

; 66   : }

  000ab	c3		 ret	 0
_energy_old ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c
;	COMDAT _energy_new
_TEXT	SEGMENT
_ov_save$1$ = -4					; size = 4
_energy_new PROC					; COMDAT
; _in$ = ecx
; _l_trm$dead$ = dx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   :     Word32 s;
; 74   :     Word16 i;
; 75   :     Flag ov_save;
; 76   : 
; 77   :     ov_save = Overflow; move16 (); /* save overflow flag in case energy_old */

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR _Overflow
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	89 45 fc	 mov	 DWORD PTR _ov_save$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0000f	0f bf 13	 movsx	 edx, WORD PTR [ebx]
  00012	0f af d2	 imul	 edx, edx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00015	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  0001b	74 04		 je	 SHORT $LN11@energy_new

; 488  :     {
; 489  :         L_var_out *= 2;

  0001d	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  0001f	eb 0f		 jmp	 SHORT $LN10@energy_new
$LN11@energy_new:

; 492  :     {
; 493  :         Overflow = 1;

  00021	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0002b	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN10@energy_new:
  00030	56		 push	 esi
  00031	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 79   :     s = L_mult(in[0], in[0]);

  00032	8d 73 02	 lea	 esi, DWORD PTR [ebx+2]
  00035	bf 27 00 00 00	 mov	 edi, 39			; 00000027H
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL5@energy_new:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00040	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00043	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00046	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0004b	74 05		 je	 SHORT $LN17@energy_new

; 488  :     {
; 489  :         L_var_out *= 2;

  0004d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]

; 490  :     }
; 491  :     else

  00050	eb 0f		 jmp	 SHORT $LN16@energy_new
$LN17@energy_new:

; 492  :     {
; 493  :         Overflow = 1;

  00052	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0005c	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN16@energy_new:

; 495  :     }
; 496  : 
; 497  : #if (WMOPS)
; 498  :     multiCounter[currCounter].L_mult++;
; 499  : #endif
; 500  :     return (L_var_out);
; 501  : }
; 502  : 
; 503  : /*___________________________________________________________________________
; 504  :  |                                                                           |
; 505  :  |   Function Name : negate                                                  |
; 506  :  |                                                                           |
; 507  :  |   Purpose :                                                               |
; 508  :  |                                                                           |
; 509  :  |   Negate var1 with saturation, saturate in the case where input is -32768:|
; 510  :  |                negate(var1) = sub(0,var1).                                |
; 511  :  |                                                                           |
; 512  :  |   Complexity weight : 1                                                   |
; 513  :  |                                                                           |
; 514  :  |   Inputs :                                                                |
; 515  :  |                                                                           |
; 516  :  |    var1                                                                   |
; 517  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 518  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 519  :  |                                                                           |
; 520  :  |   Outputs :                                                               |
; 521  :  |                                                                           |
; 522  :  |    none                                                                   |
; 523  :  |                                                                           |
; 524  :  |   Return Value :                                                          |
; 525  :  |                                                                           |
; 526  :  |    var_out                                                                |
; 527  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 528  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 529  :  |___________________________________________________________________________|
; 530  : */
; 531  : 
; 532  : Word16 negate (Word16 var1)
; 533  : {
; 534  :     Word16 var_out;
; 535  : 
; 536  :     var_out = (var1 == MIN_16) ? MAX_16 : -var1;
; 537  : #if (WMOPS)
; 538  :     multiCounter[currCounter].negate++;
; 539  : #endif
; 540  :     return (var_out);
; 541  : }
; 542  : 
; 543  : /*___________________________________________________________________________
; 544  :  |                                                                           |
; 545  :  |   Function Name : extract_h                                               |
; 546  :  |                                                                           |
; 547  :  |   Purpose :                                                               |
; 548  :  |                                                                           |
; 549  :  |   Return the 16 MSB of L_var1.                                            |
; 550  :  |                                                                           |
; 551  :  |   Complexity weight : 1                                                   |
; 552  :  |                                                                           |
; 553  :  |   Inputs :                                                                |
; 554  :  |                                                                           |
; 555  :  |    L_var1                                                                 |
; 556  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 557  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 558  :  |                                                                           |
; 559  :  |   Outputs :                                                               |
; 560  :  |                                                                           |
; 561  :  |    none                                                                   |
; 562  :  |                                                                           |
; 563  :  |   Return Value :                                                          |
; 564  :  |                                                                           |
; 565  :  |    var_out                                                                |
; 566  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 567  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 568  :  |___________________________________________________________________________|
; 569  : */
; 570  : 
; 571  : Word16 extract_h (Word32 L_var1)
; 572  : {
; 573  :     Word16 var_out;
; 574  : 
; 575  :     var_out = (Word16) (L_var1 >> 16);
; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00061	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00064	33 ca		 xor	 ecx, edx
  00066	78 1c		 js	 SHORT $LN20@energy_new

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00068	8b c8		 mov	 ecx, eax
  0006a	33 ca		 xor	 ecx, edx
  0006c	79 16		 jns	 SHORT $LN20@energy_new

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0006e	33 c0		 xor	 eax, eax

; 938  :             Overflow = 1;

  00070	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0007a	85 d2		 test	 edx, edx
  0007c	0f 98 c0	 sets	 al
  0007f	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
$LN20@energy_new:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 80   :     for (i = 1; i < l_trm; i++)

  00084	83 c6 02	 add	 esi, 2

; 81   :     {
; 82   :         s = L_mac(s, in[i], in[i]);

  00087	8b d0		 mov	 edx, eax
  00089	4f		 dec	 edi
  0008a	75 b4		 jne	 SHORT $LL5@energy_new
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 983  :     L_var_out = L_var1 - L_var2;

  0008c	8d 90 01 00 00
	80		 lea	 edx, DWORD PTR [eax-2147483647]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00094	85 c0		 test	 eax, eax
  00096	79 1d		 jns	 SHORT $LN26@energy_new

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00098	8b c8		 mov	 ecx, eax
  0009a	33 ca		 xor	 ecx, edx
  0009c	79 17		 jns	 SHORT $LN26@energy_new

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0009e	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  000a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000aa	85 c0		 test	 eax, eax
  000ac	0f 98 c2	 sets	 dl
  000af	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN26@energy_new:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 87   :     if (L_sub (s, MAX_32) == 0L)

  000b5	85 d2		 test	 edx, edx
  000b7	75 14		 jne	 SHORT $LN2@energy_new

; 88   :     {
; 89   :         Overflow = ov_save; move16 (); /* restore overflow flag */

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _ov_save$1$[ebp]

; 90   :         s = energy_old (in, l_trm); move32 (); /* function result */

  000bc	8b cb		 mov	 ecx, ebx
  000be	a3 00 00 00 00	 mov	 DWORD PTR _Overflow, eax
  000c3	e8 00 00 00 00	 call	 _energy_old
  000c8	5b		 pop	 ebx

; 98   : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN2@energy_new:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  000cd	85 c0		 test	 eax, eax
  000cf	79 0c		 jns	 SHORT $LN35@energy_new

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  000d1	f7 d0		 not	 eax
  000d3	c1 f8 04	 sar	 eax, 4
  000d6	f7 d0		 not	 eax
  000d8	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 98   : }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
$LN35@energy_new:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1443 :                 L_var_out = L_var1 >> var2;

  000dd	c1 f8 04	 sar	 eax, 4
  000e0	5b		 pop	 ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\agc.c

; 98   : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_energy_new ENDP
_TEXT	ENDS
END
