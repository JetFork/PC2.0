; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\gc_pred.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@ ; `string'
PUBLIC	??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@ ; `string'
;	COMDAT ??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@ DB 'gc_pred_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@ DB 'gc_pred_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@ DB 'gc_pred_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
_pred	DW	015c3H
	DW	0128fH
	DW	0ae1H
	DW	0614H
_pred_MR122 DW	02cH
	DW	025H
	DW	016H
	DW	0cH
PUBLIC	_gc_pred_average_limited
PUBLIC	_gc_pred_update
PUBLIC	_gc_pred
PUBLIC	_gc_pred_reset
PUBLIC	_gc_pred_init
PUBLIC	_gc_pred_exit
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_exit
_TEXT	SEGMENT
_gc_pred_exit PROC					; COMDAT
; _state$ = ecx

; 124  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 125  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@gc_pred_ex
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@gc_pred_ex

; 126  :       return;
; 127  : 
; 128  :   /* deallocate memory */
; 129  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 130  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@gc_pred_ex:
  0001d	5e		 pop	 esi

; 131  : 
; 132  :   return;
; 133  : }

  0001e	c3		 ret	 0
_gc_pred_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_init
_TEXT	SEGMENT
_gc_pred_init PROC					; COMDAT
; _state$ = ecx

; 73   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 74   :   gc_predState* s;
; 75   : 
; 76   :   if (state == (gc_predState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@gc_pred_in

; 77   :       fprintf(stderr, "gc_pred_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MIAEBFFM@gc_pred_init?3?5invalid?5parameter?6@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 78   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 91   : }

  00023	c3		 ret	 0
$LN2@gc_pred_in:
  00024	57		 push	 edi

; 79   :   }
; 80   :   *state = NULL;
; 81   : 
; 82   :   /* allocate memory */
; 83   :   if ((s= (gc_predState *) malloc(sizeof(gc_predState))) == NULL){

  00025	6a 10		 push	 16			; 00000010H
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	75 1e		 jne	 SHORT $LN1@gc_pred_in

; 84   :       fprintf(stderr, "gc_pred_init: can not malloc state structure\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BMOHMDCE@gc_pred_init?3?5can?5not?5malloc?5sta@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00047	83 c0 40	 add	 eax, 64			; 00000040H
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00051	83 c4 08	 add	 esp, 8

; 85   :       return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 91   : }

  00059	c3		 ret	 0
$LN1@gc_pred_in:

; 86   :   }
; 87   :   gc_pred_reset(s);

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _gc_pred_reset

; 88   :   *state = s;

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 89   : 
; 90   :   return 0;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 91   : }

  00067	c3		 ret	 0
_gc_pred_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_reset
_TEXT	SEGMENT
_gc_pred_reset PROC					; COMDAT
; _state$ = ecx

; 101  :    Word16 i;
; 102  : 
; 103  :    if (state == (gc_predState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN4@gc_pred_re

; 104  :       fprintf(stderr, "gc_pred_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PMLLCIKB@gc_pred_reset?3?5invalid?5parameter@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 105  :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 112  :    }
; 113  :   return 0;
; 114  : }

  0001f	c3		 ret	 0
$LN4@gc_pred_re:
  00020	56		 push	 esi

; 106  :    }
; 107  : 
; 108  :    for(i = 0; i < NPRED; i++)

  00021	b8 04 00 00 00	 mov	 eax, 4
  00026	ba 00 c8 ff ff	 mov	 edx, -14336		; ffffc800H
  0002b	be b3 f6 ff ff	 mov	 esi, -2381		; fffff6b3H
$LL3@gc_pred_re:

; 109  :    {
; 110  :       state->past_qua_en[i] = MIN_ENERGY;

  00030	66 89 11	 mov	 WORD PTR [ecx], dx
  00033	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]

; 111  :       state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;

  00036	66 89 71 06	 mov	 WORD PTR [ecx+6], si
  0003a	48		 dec	 eax
  0003b	75 f3		 jne	 SHORT $LL3@gc_pred_re
  0003d	5e		 pop	 esi

; 112  :    }
; 113  :   return 0;
; 114  : }

  0003e	c3		 ret	 0
_gc_pred_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred
_TEXT	SEGMENT
_mode$1$ = -12						; size = 4
_exp$ = -8						; size = 2
_st$1$ = -4						; size = 4
_L_var_out$1$ = 8					; size = 4
_frac$ = 8						; size = 2
_code$ = 8						; size = 4
_exp_gcode0$ = 12					; size = 4
_frac_gcode0$ = 16					; size = 4
_exp_en$ = 20						; size = 4
_frac_en$ = 24						; size = 4
_gc_pred PROC						; COMDAT
; _st$ = ecx
; _mode$ = edx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00008	8b 75 08	 mov	 esi, DWORD PTR _code$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 173  : {

  0000b	8b da		 mov	 ebx, edx
  0000d	57		 push	 edi
  0000e	89 5d f4	 mov	 DWORD PTR _mode$1$[ebp], ebx
  00011	89 4d fc	 mov	 DWORD PTR _st$1$[ebp], ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00014	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00017	0f af d2	 imul	 edx, edx

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0001a	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  00020	74 04		 je	 SHORT $LN27@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  00022	03 d2		 add	 edx, edx

; 490  :     }
; 491  :     else

  00024	eb 0f		 jmp	 SHORT $LN26@gc_pred
$LN27@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  00026	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00030	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
$LN26@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 183  :     ener_code = L_mac((Word32) 0, code[0], code[0]);

  00035	83 c6 02	 add	 esi, 2
  00038	bf 27 00 00 00	 mov	 edi, 39			; 00000027H
  0003d	8d 49 00	 npad	 3
$LL21@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00040	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00043	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00046	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0004b	74 04		 je	 SHORT $LN37@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  0004d	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0004f	eb 0f		 jmp	 SHORT $LN36@gc_pred
$LN37@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  00051	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0005b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN36@gc_pred:

; 931  :     L_var_out = L_var1 + L_var2;

  00060	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00063	33 c2		 xor	 eax, edx
  00065	78 1d		 js	 SHORT $LN40@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00067	8b c1		 mov	 eax, ecx
  00069	33 c2		 xor	 eax, edx
  0006b	79 17		 jns	 SHORT $LN40@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0006d	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  0006f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00079	85 d2		 test	 edx, edx
  0007b	0f 98 c1	 sets	 cl
  0007e	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN40@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 186  :     for (i = 1; i < L_SUBFR; i++)

  00084	83 c6 02	 add	 esi, 2

; 187  :         ener_code = L_mac(ener_code, code[i], code[i]);

  00087	8b d1		 mov	 edx, ecx
  00089	4f		 dec	 edi
  0008a	75 b4		 jne	 SHORT $LL21@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0008c	0f bf c3	 movsx	 eax, bx
  0008f	83 c0 f9	 add	 eax, -7			; fffffff9H

; 79   :     if (L_var1 > 0X00007fffL)

  00092	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00097	0f 8f da 01 00
	00		 jg	 $LN433@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0009d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000a2	0f 8c cf 01 00
	00		 jl	 $LN433@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 190  :     if (sub (mode, MR122) == 0)

  000a8	66 85 c0	 test	 ax, ax
  000ab	0f 85 d0 01 00
	00		 jne	 $LN18@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  000b1	8d 91 00 80 00
	00		 lea	 edx, DWORD PTR [ecx+32768]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000b7	85 c9		 test	 ecx, ecx
  000b9	78 1d		 js	 SHORT $LN58@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  000bb	8b c2		 mov	 eax, edx
  000bd	33 c1		 xor	 eax, ecx
  000bf	79 17		 jns	 SHORT $LN58@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  000c1	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  000c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000cd	85 c9		 test	 ecx, ecx
  000cf	0f 98 c2	 sets	 dl
  000d2	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN58@gc_pred:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  000d8	c1 fa 10	 sar	 edx, 16			; 00000010H

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  000db	0f bf c2	 movsx	 eax, dx
  000de	69 c8 66 66 00
	00		 imul	 ecx, eax, 26214

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  000e4	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  000ea	74 04		 je	 SHORT $LN65@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  000ec	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  000ee	eb 0f		 jmp	 SHORT $LN64@gc_pred
$LN65@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  000f0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000fa	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN64@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 120  :     exp = norm_l (L_x);

  000ff	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  00101	85 c9		 test	 ecx, ecx
  00103	75 04		 jne	 SHORT $LN77@gc_pred

; 2110 :     {
; 2111 :         var_out = 0;

  00105	33 f6		 xor	 esi, esi

; 2112 :     }
; 2113 :     else

  00107	eb 25		 jmp	 SHORT $LN70@gc_pred
$LN77@gc_pred:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  00109	83 f9 ff	 cmp	 ecx, -1
  0010c	75 05		 jne	 SHORT $LN75@gc_pred

; 2116 :         {
; 2117 :             var_out = 31;

  0010e	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  00111	eb 1b		 jmp	 SHORT $LN70@gc_pred
$LN75@gc_pred:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00113	85 c9		 test	 ecx, ecx
  00115	79 04		 jns	 SHORT $LN73@gc_pred

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00117	8b c1		 mov	 eax, ecx
  00119	f7 d0		 not	 eax
$LN73@gc_pred:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  0011b	33 f6		 xor	 esi, esi
  0011d	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00122	7d 0a		 jge	 SHORT $LN70@gc_pred
$LL72@gc_pred:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  00124	03 c0		 add	 eax, eax
  00126	46		 inc	 esi
  00127	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0012c	7c f6		 jl	 SHORT $LL72@gc_pred
$LN70@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  0012e	8d 45 08	 lea	 eax, DWORD PTR _frac$[ebp]
  00131	8b d6		 mov	 edx, esi
  00133	50		 push	 eax
  00134	8d 45 f8	 lea	 eax, DWORD PTR _exp$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 _L_shl
  0013d	8b d6		 mov	 edx, esi
  0013f	8b c8		 mov	 ecx, eax
  00141	e8 00 00 00 00	 call	 _Log2_norm
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00146	0f bf 45 f8	 movsx	 eax, WORD PTR _exp$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\log2.c

; 121  :     Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);

  0014a	83 c4 08	 add	 esp, 8
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0014d	83 e8 1e	 sub	 eax, 30			; 0000001eH

; 79   :     if (L_var1 > 0X00007fffL)

  00150	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00155	7e 11		 jle	 SHORT $LN85@gc_pred

; 80   :     {
; 81   :         Overflow = 1;

  00157	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00161	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00166	eb 1b		 jmp	 SHORT $LN82@gc_pred
$LN85@gc_pred:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00168	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0016d	7d 11		 jge	 SHORT $LN83@gc_pred

; 86   :         Overflow = 1;

  0016f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00179	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0017e	eb 03		 jmp	 SHORT $LN82@gc_pred
$LN83@gc_pred:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00180	0f b7 c0	 movzx	 eax, ax
$LN82@gc_pred:

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);
; 1451 : }
; 1452 : 
; 1453 : /*___________________________________________________________________________
; 1454 :  |                                                                           |
; 1455 :  |   Function Name : shr_r                                                   |
; 1456 :  |                                                                           |
; 1457 :  |   Purpose :                                                               |
; 1458 :  |                                                                           |
; 1459 :  |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
; 1460 :  |   underflows or overflows :                                               |
; 1461 :  |    - If var2 is greater than zero :                                       |
; 1462 :  |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
; 1463 :  |          is equal to zero                                                 |
; 1464 :  |                     then                                                  |
; 1465 :  |                     shr_r(var1,var2) = shr(var1,var2)                     |
; 1466 :  |                     else                                                  |
; 1467 :  |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
; 1468 :  |    - If var2 is less than or equal to zero :                              |
; 1469 :  |                     shr_r(var1,var2) = shr(var1,var2).                    |
; 1470 :  |                                                                           |
; 1471 :  |   Complexity weight : 2                                                   |
; 1472 :  |                                                                           |
; 1473 :  |   Inputs :                                                                |
; 1474 :  |                                                                           |
; 1475 :  |    var1                                                                   |
; 1476 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1477 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1478 :  |                                                                           |
; 1479 :  |    var2                                                                   |
; 1480 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1481 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1482 :  |                                                                           |
; 1483 :  |   Outputs :                                                               |
; 1484 :  |                                                                           |
; 1485 :  |    none                                                                   |
; 1486 :  |                                                                           |
; 1487 :  |   Return Value :                                                          |
; 1488 :  |                                                                           |
; 1489 :  |    var_out                                                                |
; 1490 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1491 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1492 :  |___________________________________________________________________________|
; 1493 : */
; 1494 : 
; 1495 : Word16 shr_r (Word16 var1, Word16 var2)
; 1496 : {
; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);
; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
; 1513 :             {
; 1514 :                 var_out++;
; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }
; 1523 : 
; 1524 : /*___________________________________________________________________________
; 1525 :  |                                                                           |
; 1526 :  |   Function Name : mac_r                                                   |
; 1527 :  |                                                                           |
; 1528 :  |   Purpose :                                                               |
; 1529 :  |                                                                           |
; 1530 :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 1531 :  |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
; 1532 :  |   into the MS 16 bits with saturation and shift the result right by 16.   |
; 1533 :  |   Return a 16 bit result.                                                 |
; 1534 :  |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
; 1535 :  |                                                                           |
; 1536 :  |   Complexity weight : 2                                                   |
; 1537 :  |                                                                           |
; 1538 :  |   Inputs :                                                                |
; 1539 :  |                                                                           |
; 1540 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1541 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1542 :  |                                                                           |
; 1543 :  |    var1                                                                   |
; 1544 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1545 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1546 :  |                                                                           |
; 1547 :  |    var2                                                                   |
; 1548 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1549 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1550 :  |                                                                           |
; 1551 :  |   Outputs :                                                               |
; 1552 :  |                                                                           |
; 1553 :  |    none                                                                   |
; 1554 :  |                                                                           |
; 1555 :  |   Return Value :                                                          |
; 1556 :  |                                                                           |
; 1557 :  |    var_out                                                                |
; 1558 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1559 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1560 :  |___________________________________________________________________________|
; 1561 : */
; 1562 : 
; 1563 : Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1564 : {
; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);
; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);
; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);
; 1581 : }
; 1582 : 
; 1583 : /*___________________________________________________________________________
; 1584 :  |                                                                           |
; 1585 :  |   Function Name : msu_r                                                   |
; 1586 :  |                                                                           |
; 1587 :  |   Purpose :                                                               |
; 1588 :  |                                                                           |
; 1589 :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 1590 :  |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
; 1591 :  |   ult into the MS 16 bits with saturation and shift the result right by   |
; 1592 :  |   16. Return a 16 bit result.                                             |
; 1593 :  |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
; 1594 :  |                                                                           |
; 1595 :  |   Complexity weight : 2                                                   |
; 1596 :  |                                                                           |
; 1597 :  |   Inputs :                                                                |
; 1598 :  |                                                                           |
; 1599 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1600 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1601 :  |                                                                           |
; 1602 :  |    var1                                                                   |
; 1603 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1604 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1605 :  |                                                                           |
; 1606 :  |    var2                                                                   |
; 1607 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1608 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1609 :  |                                                                           |
; 1610 :  |   Outputs :                                                               |
; 1611 :  |                                                                           |
; 1612 :  |    none                                                                   |
; 1613 :  |                                                                           |
; 1614 :  |   Return Value :                                                          |
; 1615 :  |                                                                           |
; 1616 :  |    var_out                                                                |
; 1617 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1618 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1619 :  |___________________________________________________________________________|
; 1620 : */
; 1621 : 
; 1622 : Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1623 : {
; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);
; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);
; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);
; 1640 : }
; 1641 : 
; 1642 : /*___________________________________________________________________________
; 1643 :  |                                                                           |
; 1644 :  |   Function Name : L_deposit_h                                             |
; 1645 :  |                                                                           |
; 1646 :  |   Purpose :                                                               |
; 1647 :  |                                                                           |
; 1648 :  |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
; 1649 :  |   16 LS bits of the output are zeroed.                                    |
; 1650 :  |                                                                           |
; 1651 :  |   Complexity weight : 2                                                   |
; 1652 :  |                                                                           |
; 1653 :  |   Inputs :                                                                |
; 1654 :  |                                                                           |
; 1655 :  |    var1                                                                   |
; 1656 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1657 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1658 :  |                                                                           |
; 1659 :  |   Outputs :                                                               |
; 1660 :  |                                                                           |
; 1661 :  |    none                                                                   |
; 1662 :  |                                                                           |
; 1663 :  |   Return Value :                                                          |
; 1664 :  |                                                                           |
; 1665 :  |    L_var_out                                                              |
; 1666 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1667 :  |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
; 1668 :  |___________________________________________________________________________|
; 1669 : */
; 1670 : 
; 1671 : Word32 L_deposit_h (Word16 var1)
; 1672 : {
; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;

  00183	0f bf c8	 movsx	 ecx, ax

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00186	0f bf 45 08	 movsx	 eax, WORD PTR _frac$[ebp]

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);
; 1451 : }
; 1452 : 
; 1453 : /*___________________________________________________________________________
; 1454 :  |                                                                           |
; 1455 :  |   Function Name : shr_r                                                   |
; 1456 :  |                                                                           |
; 1457 :  |   Purpose :                                                               |
; 1458 :  |                                                                           |
; 1459 :  |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
; 1460 :  |   underflows or overflows :                                               |
; 1461 :  |    - If var2 is greater than zero :                                       |
; 1462 :  |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
; 1463 :  |          is equal to zero                                                 |
; 1464 :  |                     then                                                  |
; 1465 :  |                     shr_r(var1,var2) = shr(var1,var2)                     |
; 1466 :  |                     else                                                  |
; 1467 :  |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
; 1468 :  |    - If var2 is less than or equal to zero :                              |
; 1469 :  |                     shr_r(var1,var2) = shr(var1,var2).                    |
; 1470 :  |                                                                           |
; 1471 :  |   Complexity weight : 2                                                   |
; 1472 :  |                                                                           |
; 1473 :  |   Inputs :                                                                |
; 1474 :  |                                                                           |
; 1475 :  |    var1                                                                   |
; 1476 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1477 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1478 :  |                                                                           |
; 1479 :  |    var2                                                                   |
; 1480 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1481 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1482 :  |                                                                           |
; 1483 :  |   Outputs :                                                               |
; 1484 :  |                                                                           |
; 1485 :  |    none                                                                   |
; 1486 :  |                                                                           |
; 1487 :  |   Return Value :                                                          |
; 1488 :  |                                                                           |
; 1489 :  |    var_out                                                                |
; 1490 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1491 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1492 :  |___________________________________________________________________________|
; 1493 : */
; 1494 : 
; 1495 : Word16 shr_r (Word16 var1, Word16 var2)
; 1496 : {
; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);
; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
; 1513 :             {
; 1514 :                 var_out++;
; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }
; 1523 : 
; 1524 : /*___________________________________________________________________________
; 1525 :  |                                                                           |
; 1526 :  |   Function Name : mac_r                                                   |
; 1527 :  |                                                                           |
; 1528 :  |   Purpose :                                                               |
; 1529 :  |                                                                           |
; 1530 :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 1531 :  |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
; 1532 :  |   into the MS 16 bits with saturation and shift the result right by 16.   |
; 1533 :  |   Return a 16 bit result.                                                 |
; 1534 :  |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
; 1535 :  |                                                                           |
; 1536 :  |   Complexity weight : 2                                                   |
; 1537 :  |                                                                           |
; 1538 :  |   Inputs :                                                                |
; 1539 :  |                                                                           |
; 1540 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1541 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1542 :  |                                                                           |
; 1543 :  |    var1                                                                   |
; 1544 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1545 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1546 :  |                                                                           |
; 1547 :  |    var2                                                                   |
; 1548 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1549 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1550 :  |                                                                           |
; 1551 :  |   Outputs :                                                               |
; 1552 :  |                                                                           |
; 1553 :  |    none                                                                   |
; 1554 :  |                                                                           |
; 1555 :  |   Return Value :                                                          |
; 1556 :  |                                                                           |
; 1557 :  |    var_out                                                                |
; 1558 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1559 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1560 :  |___________________________________________________________________________|
; 1561 : */
; 1562 : 
; 1563 : Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1564 : {
; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);
; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);
; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);
; 1581 : }
; 1582 : 
; 1583 : /*___________________________________________________________________________
; 1584 :  |                                                                           |
; 1585 :  |   Function Name : msu_r                                                   |
; 1586 :  |                                                                           |
; 1587 :  |   Purpose :                                                               |
; 1588 :  |                                                                           |
; 1589 :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 1590 :  |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
; 1591 :  |   ult into the MS 16 bits with saturation and shift the result right by   |
; 1592 :  |   16. Return a 16 bit result.                                             |
; 1593 :  |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
; 1594 :  |                                                                           |
; 1595 :  |   Complexity weight : 2                                                   |
; 1596 :  |                                                                           |
; 1597 :  |   Inputs :                                                                |
; 1598 :  |                                                                           |
; 1599 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1600 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1601 :  |                                                                           |
; 1602 :  |    var1                                                                   |
; 1603 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1604 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1605 :  |                                                                           |
; 1606 :  |    var2                                                                   |
; 1607 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1608 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1609 :  |                                                                           |
; 1610 :  |   Outputs :                                                               |
; 1611 :  |                                                                           |
; 1612 :  |    none                                                                   |
; 1613 :  |                                                                           |
; 1614 :  |   Return Value :                                                          |
; 1615 :  |                                                                           |
; 1616 :  |    var_out                                                                |
; 1617 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1618 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1619 :  |___________________________________________________________________________|
; 1620 : */
; 1621 : 
; 1622 : Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1623 : {
; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);
; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);
; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);
; 1640 : }
; 1641 : 
; 1642 : /*___________________________________________________________________________
; 1643 :  |                                                                           |
; 1644 :  |   Function Name : L_deposit_h                                             |
; 1645 :  |                                                                           |
; 1646 :  |   Purpose :                                                               |
; 1647 :  |                                                                           |
; 1648 :  |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
; 1649 :  |   16 LS bits of the output are zeroed.                                    |
; 1650 :  |                                                                           |
; 1651 :  |   Complexity weight : 2                                                   |
; 1652 :  |                                                                           |
; 1653 :  |   Inputs :                                                                |
; 1654 :  |                                                                           |
; 1655 :  |    var1                                                                   |
; 1656 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1657 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1658 :  |                                                                           |
; 1659 :  |   Outputs :                                                               |
; 1660 :  |                                                                           |
; 1661 :  |    none                                                                   |
; 1662 :  |                                                                           |
; 1663 :  |   Return Value :                                                          |
; 1664 :  |                                                                           |
; 1665 :  |    L_var_out                                                              |
; 1666 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1667 :  |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
; 1668 :  |___________________________________________________________________________|
; 1669 : */
; 1670 : 
; 1671 : Word32 L_deposit_h (Word16 var1)
; 1672 : {
; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;

  0018a	c1 e1 10	 shl	 ecx, 16			; 00000010H

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0018d	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00192	74 04		 je	 SHORT $LN97@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  00194	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  00196	eb 0f		 jmp	 SHORT $LN96@gc_pred
$LN97@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  00198	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  001a2	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN96@gc_pred:

; 931  :     L_var_out = L_var1 + L_var2;

  001a7	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  001aa	33 c1		 xor	 eax, ecx
  001ac	89 5d 08	 mov	 DWORD PTR _L_var_out$1$[ebp], ebx
  001af	78 20		 js	 SHORT $LN100@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  001b1	8b c3		 mov	 eax, ebx
  001b3	33 c1		 xor	 eax, ecx
  001b5	79 1a		 jns	 SHORT $LN100@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  001b7	33 db		 xor	 ebx, ebx

; 938  :             Overflow = 1;

  001b9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001c3	85 c9		 test	 ecx, ecx
  001c5	0f 98 c3	 sets	 bl
  001c8	81 c3 ff ff ff
	7f		 add	 ebx, 2147483647		; 7fffffffH
  001ce	89 5d 08	 mov	 DWORD PTR _L_var_out$1$[ebp], ebx
$LN100@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 217  :         ener = MEAN_ENER_MR122; move32 ();                  /* Q24 (Q17) */

  001d1	8b 7d fc	 mov	 edi, DWORD PTR _st$1$[ebp]
  001d4	b9 7d f5 0b 00	 mov	 ecx, 783741		; 000bf57dH
  001d9	be 00 00 00 00	 mov	 esi, OFFSET _pred_MR122
  001de	83 c7 08	 add	 edi, 8
  001e1	bb 04 00 00 00	 mov	 ebx, 4
$LL17@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  001e6	0f bf 17	 movsx	 edx, WORD PTR [edi]
  001e9	0f bf 06	 movsx	 eax, WORD PTR [esi]
  001ec	0f af d0	 imul	 edx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  001ef	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  001f5	74 05		 je	 SHORT $LN109@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  001f7	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]

; 490  :     }
; 491  :     else

  001fa	eb 0f		 jmp	 SHORT $LN108@gc_pred
$LN109@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  001fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00206	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN108@gc_pred:

; 931  :     L_var_out = L_var1 + L_var2;

  0020b	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0020e	33 c1		 xor	 eax, ecx
  00210	78 1d		 js	 SHORT $LN112@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00212	8b c2		 mov	 eax, edx
  00214	33 c1		 xor	 eax, ecx
  00216	79 17		 jns	 SHORT $LN112@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00218	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  0021a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00224	85 c9		 test	 ecx, ecx
  00226	0f 98 c2	 sets	 dl
  00229	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN112@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 218  :         for (i = 0; i < NPRED; i++)

  0022f	83 c7 02	 add	 edi, 2
  00232	83 c6 02	 add	 esi, 2

; 219  :         {
; 220  :             ener = L_mac (ener, st->past_qua_en_MR122[i], pred_MR122[i]);

  00235	8b ca		 mov	 ecx, edx
  00237	4b		 dec	 ebx
  00238	75 ac		 jne	 SHORT $LL17@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 983  :     L_var_out = L_var1 - L_var2;

  0023a	2b 4d 08	 sub	 ecx, DWORD PTR _L_var_out$1$[ebp]

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  0023d	8b c2		 mov	 eax, edx
  0023f	33 45 08	 xor	 eax, DWORD PTR _L_var_out$1$[ebp]
  00242	79 1d		 jns	 SHORT $LN116@gc_pred

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00244	8b c2		 mov	 eax, edx
  00246	33 c1		 xor	 eax, ecx
  00248	79 17		 jns	 SHORT $LN116@gc_pred

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0024a	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  0024c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00256	85 d2		 test	 edx, edx
  00258	0f 98 c1	 sets	 cl
  0025b	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN116@gc_pred:

; 1437 :             if (L_var1 < 0)

  00261	85 c9		 test	 ecx, ecx
  00263	79 0b		 jns	 SHORT $LN121@gc_pred

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00265	f7 d1		 not	 ecx
  00267	d1 f9		 sar	 ecx, 1
  00269	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  0026b	e9 e2 02 00 00	 jmp	 $LN322@gc_pred
$LN121@gc_pred:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00270	d1 f9		 sar	 ecx, 1

; 1440 :             }
; 1441 :             else

  00272	e9 db 02 00 00	 jmp	 $LN322@gc_pred
$LN433@gc_pred:

; 86   :         Overflow = 1;

  00277	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN18@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 247  :         exp_code = norm_l (ener_code);

  00281	8b c1		 mov	 eax, ecx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 2109 :     if (L_var1 == 0)

  00283	85 c9		 test	 ecx, ecx
  00285	75 04		 jne	 SHORT $LN183@gc_pred

; 2110 :     {
; 2111 :         var_out = 0;

  00287	33 f6		 xor	 esi, esi

; 2112 :     }
; 2113 :     else

  00289	eb 25		 jmp	 SHORT $LN176@gc_pred
$LN183@gc_pred:

; 2114 :     {
; 2115 :         if (L_var1 == (Word32) 0xffffffffL)

  0028b	83 f9 ff	 cmp	 ecx, -1
  0028e	75 05		 jne	 SHORT $LN181@gc_pred

; 2116 :         {
; 2117 :             var_out = 31;

  00290	8d 71 20	 lea	 esi, DWORD PTR [ecx+32]

; 2118 :         }
; 2119 :         else

  00293	eb 1b		 jmp	 SHORT $LN176@gc_pred
$LN181@gc_pred:

; 2120 :         {
; 2121 :             if (L_var1 < 0)

  00295	85 c9		 test	 ecx, ecx
  00297	79 04		 jns	 SHORT $LN179@gc_pred

; 2122 :             {
; 2123 :                 L_var1 = ~L_var1;

  00299	8b c1		 mov	 eax, ecx
  0029b	f7 d0		 not	 eax
$LN179@gc_pred:

; 2124 :             }
; 2125 :             for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)

  0029d	33 f6		 xor	 esi, esi
  0029f	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  002a4	7d 0a		 jge	 SHORT $LN176@gc_pred
$LL178@gc_pred:

; 2126 :             {
; 2127 :                 L_var1 <<= 1;

  002a6	03 c0		 add	 eax, eax
  002a8	46		 inc	 esi
  002a9	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  002ae	7c f6		 jl	 SHORT $LL178@gc_pred
$LN176@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 248  :         ener_code = L_shl (ener_code, exp_code);

  002b0	8b d6		 mov	 edx, esi
  002b2	e8 00 00 00 00	 call	 _L_shl
  002b7	8b d8		 mov	 ebx, eax

; 249  :         
; 250  :         /* Log2 = log2 + 27 */
; 251  :         Log2_norm (ener_code, exp_code, &exp, &frac);

  002b9	8b d6		 mov	 edx, esi
  002bb	8d 45 08	 lea	 eax, DWORD PTR _frac$[ebp]
  002be	8b cb		 mov	 ecx, ebx
  002c0	50		 push	 eax
  002c1	8d 45 f8	 lea	 eax, DWORD PTR _exp$[ebp]
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _Log2_norm

; 252  :         
; 253  :         /* fact = 10/log2(10) = 3.01 = 24660 Q13 */
; 254  :         L_tmp = Mpy_32_16(exp, frac, -24660); /* Q0.Q15 * Q13 -> Q14 */

  002ca	8b 55 08	 mov	 edx, DWORD PTR _frac$[ebp]
  002cd	8b 4d f8	 mov	 ecx, DWORD PTR _exp$[ebp]
  002d0	68 ac 9f ff ff	 push	 -24660			; ffff9facH
  002d5	e8 00 00 00 00	 call	 _Mpy_32_16
  002da	8b f8		 mov	 edi, eax
  002dc	83 c4 0c	 add	 esp, 12			; 0000000cH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  002df	8b 45 f4	 mov	 eax, DWORD PTR _mode$1$[ebp]
  002e2	0f bf c8	 movsx	 ecx, ax
  002e5	8d 41 fa	 lea	 eax, DWORD PTR [ecx-6]

; 79   :     if (L_var1 > 0X00007fffL)

  002e8	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002ed	7f 40		 jg	 SHORT $LN434@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002ef	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002f4	7c 39		 jl	 SHORT $LN434@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 278  :         if (test (), sub (mode, MR102) == 0)

  002f6	66 85 c0	 test	 ax, ax
  002f9	75 3e		 jne	 SHORT $LN13@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  002fb	8d 8f 00 93 20
	00		 lea	 ecx, DWORD PTR [edi+2134784]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00301	85 ff		 test	 edi, edi
  00303	0f 88 40 01 00
	00		 js	 $LN6@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00309	8b c1		 mov	 eax, ecx
  0030b	33 c7		 xor	 eax, edi
  0030d	0f 89 36 01 00
	00		 jns	 $LN6@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00313	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  00315	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0031f	85 ff		 test	 edi, edi
  00321	0f 98 c1	 sets	 cl
  00324	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 283  :         else if (test (), sub (mode, MR795) == 0)

  0032a	e9 1a 01 00 00	 jmp	 $LN6@gc_pred
$LN434@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  0032f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN13@gc_pred:

; 186  :     L_diff = (Word32) var1 - var2;

  00339	8d 41 fb	 lea	 eax, DWORD PTR [ecx-5]

; 79   :     if (L_var1 > 0X00007fffL)

  0033c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00341	0f 8f 93 00 00
	00		 jg	 $LN435@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00347	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0034c	0f 8c 88 00 00
	00		 jl	 $LN435@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 283  :         else if (test (), sub (mode, MR795) == 0)

  00352	66 85 c0	 test	 ax, ax
  00355	0f 85 89 00 00
	00		 jne	 $LN11@gc_pred

; 293  :             *frac_en = extract_h (ener_code); move16 ();

  0035b	8b 45 18	 mov	 eax, DWORD PTR _frac_en$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0035e	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00363	c1 fb 10	 sar	 ebx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 293  :             *frac_en = extract_h (ener_code); move16 ();

  00366	66 89 18	 mov	 WORD PTR [eax], bx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00369	0f bf c6	 movsx	 eax, si
  0036c	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0036e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00374	7e 11		 jle	 SHORT $LN229@gc_pred

; 80   :     {
; 81   :         Overflow = 1;

  00376	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00380	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00385	eb 1c		 jmp	 SHORT $LN226@gc_pred
$LN229@gc_pred:

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00387	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0038d	7d 11		 jge	 SHORT $LN227@gc_pred

; 86   :         Overflow = 1;

  0038f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00399	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0039e	eb 03		 jmp	 SHORT $LN226@gc_pred
$LN227@gc_pred:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  003a0	0f b7 c9	 movzx	 ecx, cx
$LN226@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 294  :             *exp_en = sub (-11, exp_code);    move16 ();

  003a3	8b 45 14	 mov	 eax, DWORD PTR _exp_en$[ebp]
  003a6	66 89 08	 mov	 WORD PTR [eax], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 931  :     L_var_out = L_var1 + L_var2;

  003a9	8d 8f 00 53 21
	00		 lea	 ecx, DWORD PTR [edi+2183936]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  003af	85 ff		 test	 edi, edi
  003b1	0f 88 92 00 00
	00		 js	 $LN6@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  003b7	8b c1		 mov	 eax, ecx
  003b9	33 c7		 xor	 eax, edi
  003bb	0f 89 88 00 00
	00		 jns	 $LN6@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  003c1	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  003c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  003cd	85 ff		 test	 edi, edi
  003cf	0f 98 c1	 sets	 cl
  003d2	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 299  :         else if (test (), sub (mode, MR74) == 0)

  003d8	eb 6f		 jmp	 SHORT $LN6@gc_pred
$LN435@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  003da	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN11@gc_pred:

; 186  :     L_diff = (Word32) var1 - var2;

  003e4	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]

; 79   :     if (L_var1 > 0X00007fffL)

  003e7	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003ec	7f 15		 jg	 SHORT $LN437@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003ee	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003f3	7c 0e		 jl	 SHORT $LN437@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 299  :         else if (test (), sub (mode, MR74) == 0)

  003f5	66 85 c0	 test	 ax, ax
  003f8	75 13		 jne	 SHORT $LN9@gc_pred

; 300  :         {
; 301  :             /* mean = 30 dB */
; 302  :             L_tmp = L_mac(L_tmp, 32588, 32);     /* Q14 */

  003fa	6a 20		 push	 32			; 00000020H
  003fc	ba 4c 7f 00 00	 mov	 edx, 32588		; 00007f4cH

; 304  :         else if (test (), sub (mode, MR67) == 0)

  00401	eb 3a		 jmp	 SHORT $LN436@gc_pred
$LN437@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00403	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN9@gc_pred:

; 186  :     L_diff = (Word32) var1 - var2;

  0040d	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]

; 79   :     if (L_var1 > 0X00007fffL)

  00410	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00415	7f 15		 jg	 SHORT $LN438@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00417	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0041c	7c 0e		 jl	 SHORT $LN438@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 304  :         else if (test (), sub (mode, MR67) == 0)

  0041e	66 85 c0	 test	 ax, ax
  00421	75 13		 jne	 SHORT $LN7@gc_pred

; 305  :         {
; 306  :             /* mean = 28.75 dB */
; 307  :             L_tmp = L_mac(L_tmp, 32268, 32);     /* Q14 */

  00423	6a 20		 push	 32			; 00000020H
  00425	ba 0c 7e 00 00	 mov	 edx, 32268		; 00007e0cH

; 308  :         }
; 309  :         else /* MR59, MR515, MR475 */

  0042a	eb 11		 jmp	 SHORT $LN436@gc_pred
$LN438@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  0042c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN7@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 312  :             L_tmp = L_mac(L_tmp, 16678, 64);     /* Q14 */

  00436	6a 40		 push	 64			; 00000040H
  00438	ba 26 41 00 00	 mov	 edx, 16678		; 00004126H
$LN436@gc_pred:
  0043d	8b cf		 mov	 ecx, edi
  0043f	e8 00 00 00 00	 call	 _L_mac
  00444	83 c4 04	 add	 esp, 4
  00447	8b c8		 mov	 ecx, eax
$LN6@gc_pred:

; 313  :         }
; 314  :         
; 315  :         /*-----------------------------------------------------------------*
; 316  :          * Compute gcode0.                                                 *
; 317  :          *  = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + mean_ener    *
; 318  :          *-----------------------------------------------------------------*/
; 319  : 
; 320  :         L_tmp = L_shl(L_tmp, 10);                /* Q24 */

  00449	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0044e	8b ff		 npad	 2
$LL278@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00450	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00456	7f 19		 jg	 SHORT $LN392@gc_pred

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00458	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0045e	7c 0a		 jl	 SHORT $LN393@gc_pred

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00460	48		 dec	 eax
  00461	03 c9		 add	 ecx, ecx
  00463	66 85 c0	 test	 ax, ax
  00466	7f e8		 jg	 SHORT $LL278@gc_pred

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00468	eb 16		 jmp	 SHORT $LN273@gc_pred
$LN393@gc_pred:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0046a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0046f	eb 05		 jmp	 SHORT $LN439@gc_pred
$LN392@gc_pred:

; 1360 :                 L_var_out = MAX_32;

  00471	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN439@gc_pred:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00476	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN273@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 321  :         for (i = 0; i < 4; i++)

  00480	8b 45 fc	 mov	 eax, DWORD PTR _st$1$[ebp]
  00483	be 00 00 00 00	 mov	 esi, OFFSET _pred
  00488	2b c6		 sub	 eax, esi
  0048a	bf 04 00 00 00	 mov	 edi, 4
  0048f	89 45 fc	 mov	 DWORD PTR _st$1$[ebp], eax
$LL5@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00492	0f bf 14 30	 movsx	 edx, WORD PTR [eax+esi]
  00496	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00499	0f af d0	 imul	 edx, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0049c	81 fa 00 00 00
	40		 cmp	 edx, 1073741824		; 40000000H
  004a2	74 05		 je	 SHORT $LN293@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  004a4	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]

; 490  :     }
; 491  :     else

  004a7	eb 0f		 jmp	 SHORT $LN292@gc_pred
$LN293@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  004a9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  004b3	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN292@gc_pred:

; 931  :     L_var_out = L_var1 + L_var2;

  004b8	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  004bb	33 c1		 xor	 eax, ecx
  004bd	78 1d		 js	 SHORT $LN296@gc_pred

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  004bf	8b c2		 mov	 eax, edx
  004c1	33 c1		 xor	 eax, ecx
  004c3	79 17		 jns	 SHORT $LN296@gc_pred

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  004c5	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  004c7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  004d1	85 c9		 test	 ecx, ecx
  004d3	0f 98 c2	 sets	 dl
  004d6	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN296@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 321  :         for (i = 0; i < 4; i++)

  004dc	8b 45 fc	 mov	 eax, DWORD PTR _st$1$[ebp]
  004df	83 c6 02	 add	 esi, 2

; 322  :             L_tmp = L_mac(L_tmp, pred[i], st->past_qua_en[i]);

  004e2	8b ca		 mov	 ecx, edx
  004e4	4f		 dec	 edi
  004e5	75 ab		 jne	 SHORT $LL5@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  004e7	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 325  :         gcode0 = extract_h(L_tmp);               /* Q8  */

  004ea	0f b7 ca	 movzx	 ecx, dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004ed	8b 55 f4	 mov	 edx, DWORD PTR _mode$1$[ebp]
  004f0	0f bf c2	 movsx	 eax, dx
  004f3	83 c0 fc	 add	 eax, -4			; fffffffcH

; 79   :     if (L_var1 > 0X00007fffL)

  004f6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004fb	7f 17		 jg	 SHORT $LN443@gc_pred

; 83   :     }
; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004fd	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00502	7c 10		 jl	 SHORT $LN443@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 336  :         if (sub (mode, MR74) == 0) /* For IS641 bitexactness */

  00504	66 85 c0	 test	 ax, ax
  00507	75 15		 jne	 SHORT $LN2@gc_pred
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00509	0f bf c1	 movsx	 eax, cx
  0050c	69 c8 3f 15 00
	00		 imul	 ecx, eax, 5439
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 338  :         else

  00512	eb 13		 jmp	 SHORT $LN442@gc_pred
$LN443@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  00514	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2@gc_pred:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0051e	0f bf c1	 movsx	 eax, cx
  00521	69 c8 43 15 00
	00		 imul	 ecx, eax, 5443
$LN442@gc_pred:

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00527	81 f9 00 00 00
	40		 cmp	 ecx, 1073741824		; 40000000H
  0052d	74 04		 je	 SHORT $LN319@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  0052f	03 c9		 add	 ecx, ecx

; 490  :     }
; 491  :     else

  00531	eb 0f		 jmp	 SHORT $LN318@gc_pred
$LN319@gc_pred:

; 494  :         L_var_out = MAX_32;

  00533	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00538	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN318@gc_pred:

; 1437 :             if (L_var1 < 0)

  00542	85 c9		 test	 ecx, ecx
  00544	79 09		 jns	 SHORT $LN323@gc_pred

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00546	f7 d1		 not	 ecx
  00548	c1 f9 08	 sar	 ecx, 8
  0054b	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  0054d	eb 03		 jmp	 SHORT $LN322@gc_pred
$LN323@gc_pred:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  0054f	c1 f9 08	 sar	 ecx, 8
$LN322@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 47   :     *hi = extract_h (L_32);

  00552	8b 45 0c	 mov	 eax, DWORD PTR _exp_gcode0$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00555	8b d1		 mov	 edx, ecx
  00557	c1 fa 10	 sar	 edx, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 47   :     *hi = extract_h (L_32);

  0055a	66 89 10	 mov	 WORD PTR [eax], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  0055d	85 c9		 test	 ecx, ecx
  0055f	79 08		 jns	 SHORT $LN347@gc_pred

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00561	f7 d1		 not	 ecx
  00563	d1 f9		 sar	 ecx, 1
  00565	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  00567	eb 02		 jmp	 SHORT $LN346@gc_pred
$LN347@gc_pred:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00569	d1 f9		 sar	 ecx, 1
$LN346@gc_pred:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0056b	0f bf c2	 movsx	 eax, dx
  0056e	c1 e0 0e	 shl	 eax, 14			; 0000000eH

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00571	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00576	74 04		 je	 SHORT $LN369@gc_pred

; 488  :     {
; 489  :         L_var_out *= 2;

  00578	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0057a	eb 0f		 jmp	 SHORT $LN368@gc_pred
$LN369@gc_pred:

; 492  :     {
; 493  :         Overflow = 1;

  0057c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  00586	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN368@gc_pred:

; 983  :     L_var_out = L_var1 - L_var2;

  0058b	8b d1		 mov	 edx, ecx
  0058d	2b d0		 sub	 edx, eax

; 984  : 
; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  0058f	33 c1		 xor	 eax, ecx
  00591	79 1d		 jns	 SHORT $LN372@gc_pred

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00593	8b c2		 mov	 eax, edx
  00595	33 c1		 xor	 eax, ecx
  00597	79 17		 jns	 SHORT $LN372@gc_pred

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00599	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  0059b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  005a5	85 c9		 test	 ecx, ecx
  005a7	0f 98 c2	 sets	 dl
  005aa	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN372@gc_pred:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 48   :     *lo = extract_l (L_msu (L_shr (L_32, 1), *hi, 16384));

  005b0	8b 45 10	 mov	 eax, DWORD PTR _frac_gcode0$[ebp]
  005b3	5f		 pop	 edi
  005b4	5e		 pop	 esi
  005b5	5b		 pop	 ebx
  005b6	66 89 10	 mov	 WORD PTR [eax], dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 344  : }

  005b9	8b e5		 mov	 esp, ebp
  005bb	5d		 pop	 ebp
  005bc	c3		 ret	 0
_gc_pred ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_update
_TEXT	SEGMENT
_qua_ener$ = 8						; size = 2
_gc_pred_update PROC					; COMDAT
; _st$ = ecx
; _qua_ener_MR122$ = dx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	66 8b da	 mov	 bx, dx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 362  :     Word16 i;
; 363  : 
; 364  :     for (i = 3; i > 0; i--)

  0000b	bf 03 00 00 00	 mov	 edi, 3
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
$LL3@gc_pred_up:

; 365  :     {
; 366  :         st->past_qua_en[i] = st->past_qua_en[i - 1];             move16 ();

  00013	66 8b 70 f8	 mov	 si, WORD PTR [eax-8]
  00017	8d 40 fe	 lea	 eax, DWORD PTR [eax-2]

; 367  :         st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1]; move16 ();

  0001a	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0001e	4f		 dec	 edi
  0001f	66 89 70 fc	 mov	 WORD PTR [eax-4], si
  00023	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  00027	66 85 ff	 test	 di, di
  0002a	7f e7		 jg	 SHORT $LL3@gc_pred_up

; 368  :     }
; 369  : 
; 370  :     st->past_qua_en_MR122[0] = qua_ener_MR122;  /*    log2 (qua_err), Q10 */
; 371  : 	                                                             move16 ();
; 372  :     st->past_qua_en[0] = qua_ener;              /* 20*log10(qua_err), Q10 */

  0002c	66 8b 45 08	 mov	 ax, WORD PTR _qua_ener$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	66 89 5a 08	 mov	 WORD PTR [edx+8], bx
  00036	66 89 02	 mov	 WORD PTR [edx], ax
  00039	5b		 pop	 ebx

; 373  : 	                                                             move16 ();
; 374  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_gc_pred_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c
;	COMDAT _gc_pred_average_limited
_TEXT	SEGMENT
_ener_avg_MR122$1$ = -4					; size = 4
_ener_avg$ = 8						; size = 4
_gc_pred_average_limited PROC				; COMDAT
; _st$ = ecx
; _ener_avg_MR122$ = edx

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	89 55 fc	 mov	 DWORD PTR _ener_avg_MR122$1$[ebp], edx

; 392  :     Word16 av_pred_en;
; 393  :     Word16 i;
; 394  : 
; 395  :     /* do average in MR122 mode (log2() domain) */
; 396  :     av_pred_en = 0;                                        move16 ();

  0000c	33 ff		 xor	 edi, edi
  0000e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00011	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
$LL8@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00014	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00017	0f bf c7	 movsx	 eax, di
  0001a	03 d0		 add	 edx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0001c	81 fa ff 7f 00
	00		 cmp	 edx, 32767		; 00007fffH
  00022	7e 11		 jle	 SHORT $LN18@gc_pred_av

; 81   :         Overflow = 1;

  00024	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0002e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00033	eb 1c		 jmp	 SHORT $LN15@gc_pred_av
$LN18@gc_pred_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00035	81 fa 00 80 ff
	ff		 cmp	 edx, -32768		; ffff8000H
  0003b	7d 11		 jge	 SHORT $LN16@gc_pred_av

; 86   :         Overflow = 1;

  0003d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00047	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0004c	eb 03		 jmp	 SHORT $LN15@gc_pred_av
$LN16@gc_pred_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0004e	0f b7 c2	 movzx	 eax, dx
$LN15@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 397  :     for (i = 0; i < NPRED; i++)

  00051	83 c1 02	 add	 ecx, 2

; 398  :     {
; 399  :         av_pred_en = add (av_pred_en, st->past_qua_en_MR122[i]);

  00054	0f b7 f8	 movzx	 edi, ax
  00057	4b		 dec	 ebx
  00058	75 ba		 jne	 SHORT $LL8@gc_pred_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  0005a	98		 cwde
  0005b	c1 e0 0d	 shl	 eax, 13			; 0000000dH

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0005e	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00061	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00066	74 05		 je	 SHORT $LN23@gc_pred_av

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00068	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN23@gc_pred_av:

; 79   :     if (L_var1 > 0X00007fffL)

  0006d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00072	7e 11		 jle	 SHORT $LN29@gc_pred_av

; 81   :         Overflow = 1;

  00074	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0007e	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00083	eb 1b		 jmp	 SHORT $LN26@gc_pred_av
$LN29@gc_pred_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00085	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0008a	7d 11		 jge	 SHORT $LN27@gc_pred_av

; 86   :         Overflow = 1;

  0008c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00096	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0009b	eb 03		 jmp	 SHORT $LN26@gc_pred_av
$LN27@gc_pred_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0009d	0f b7 c0	 movzx	 eax, ax
$LN26@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 403  :     av_pred_en = mult (av_pred_en, 8192);

  000a0	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  000a3	98		 cwde
  000a4	05 4d 09 00 00	 add	 eax, 2381		; 0000094dH

; 79   :     if (L_var1 > 0X00007fffL)

  000a9	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000ae	7e 0c		 jle	 SHORT $LN41@gc_pred_av

; 81   :         Overflow = 1;

  000b0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000ba	eb 1d		 jmp	 SHORT $LN46@gc_pred_av
$LN41@gc_pred_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000bc	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000c1	7d 0c		 jge	 SHORT $LN39@gc_pred_av

; 86   :         Overflow = 1;

  000c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000cd	eb 05		 jmp	 SHORT $LN97@gc_pred_av
$LN39@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 407  :     if (sub (av_pred_en, MIN_ENERGY_MR122) < 0)

  000cf	66 85 c0	 test	 ax, ax
  000d2	79 05		 jns	 SHORT $LN46@gc_pred_av
$LN97@gc_pred_av:

; 408  :     {
; 409  :         av_pred_en = MIN_ENERGY_MR122;                     move16 ();

  000d4	b9 b3 f6 ff ff	 mov	 ecx, -2381		; fffff6b3H
$LN46@gc_pred_av:

; 410  :     }
; 411  :     *ener_avg_MR122 = av_pred_en;                          move16 ();

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _ener_avg_MR122$1$[ebp]

; 412  : 
; 413  :     /* do average for other modes (20*log10() domain) */
; 414  :     av_pred_en = 0;                                        move16 ();

  000dc	33 d2		 xor	 edx, edx
  000de	66 89 08	 mov	 WORD PTR [eax], cx
  000e1	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
$LL4@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  000e4	0f bf 0e	 movsx	 ecx, WORD PTR [esi]
  000e7	0f bf c2	 movsx	 eax, dx
  000ea	03 c8		 add	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  000ec	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  000f2	7e 11		 jle	 SHORT $LN57@gc_pred_av

; 81   :         Overflow = 1;

  000f4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000fe	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00103	eb 1c		 jmp	 SHORT $LN54@gc_pred_av
$LN57@gc_pred_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00105	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0010b	7d 11		 jge	 SHORT $LN55@gc_pred_av

; 86   :         Overflow = 1;

  0010d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00117	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0011c	eb 03		 jmp	 SHORT $LN54@gc_pred_av
$LN55@gc_pred_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0011e	0f b7 c1	 movzx	 eax, cx
$LN54@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 415  :     for (i = 0; i < NPRED; i++)

  00121	83 c6 02	 add	 esi, 2

; 416  :     {
; 417  :         av_pred_en = add (av_pred_en, st->past_qua_en[i]);

  00124	0f b7 d0	 movzx	 edx, ax
  00127	4f		 dec	 edi
  00128	75 ba		 jne	 SHORT $LL4@gc_pred_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  0012a	98		 cwde
  0012b	c1 e0 0d	 shl	 eax, 13			; 0000000dH
  0012e	5f		 pop	 edi

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  0012f	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00134	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  00139	74 05		 je	 SHORT $LN62@gc_pred_av

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0013b	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN62@gc_pred_av:

; 79   :     if (L_var1 > 0X00007fffL)

  00140	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00145	7e 11		 jle	 SHORT $LN68@gc_pred_av

; 81   :         Overflow = 1;

  00147	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00151	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00156	eb 1b		 jmp	 SHORT $LN65@gc_pred_av
$LN68@gc_pred_av:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00158	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0015d	7d 11		 jge	 SHORT $LN66@gc_pred_av

; 86   :         Overflow = 1;

  0015f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00169	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0016e	eb 03		 jmp	 SHORT $LN65@gc_pred_av
$LN66@gc_pred_av:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00170	0f b7 c0	 movzx	 eax, ax
$LN65@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 421  :     av_pred_en = mult (av_pred_en, 8192);

  00173	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00176	98		 cwde
  00177	05 00 38 00 00	 add	 eax, 14336		; 00003800H

; 79   :     if (L_var1 > 0X00007fffL)

  0017c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00181	7e 14		 jle	 SHORT $LN80@gc_pred_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 429  :     *ener_avg = av_pred_en;                                move16 ();

  00183	8b 45 08	 mov	 eax, DWORD PTR _ener_avg$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  00186	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 429  :     *ener_avg = av_pred_en;                                move16 ();

  00190	66 89 08	 mov	 WORD PTR [eax], cx

; 430  : }

  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
$LN80@gc_pred_av:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00197	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0019c	7d 19		 jge	 SHORT $LN78@gc_pred_av
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 427  :         av_pred_en = MIN_ENERGY;                           move16 ();

  0019e	8b 45 08	 mov	 eax, DWORD PTR _ener_avg$[ebp]
  001a1	b9 00 c8 ff ff	 mov	 ecx, -14336		; ffffc800H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  001a6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\gc_pred.c

; 429  :     *ener_avg = av_pred_en;                                move16 ();

  001b0	66 89 08	 mov	 WORD PTR [eax], cx

; 430  : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
$LN78@gc_pred_av:

; 422  : 
; 423  :     /* if (av_pred_en < -14) av_pred_en = .. */
; 424  :     test ();
; 425  :     if (sub (av_pred_en, MIN_ENERGY) < 0)

  001b7	66 85 c0	 test	 ax, ax
  001ba	79 05		 jns	 SHORT $LN99@gc_pred_av

; 427  :         av_pred_en = MIN_ENERGY;                           move16 ();

  001bc	b9 00 c8 ff ff	 mov	 ecx, -14336		; ffffc800H
$LN99@gc_pred_av:

; 429  :     *ener_avg = av_pred_en;                                move16 ();

  001c1	8b 45 08	 mov	 eax, DWORD PTR _ener_avg$[ebp]
  001c4	66 89 08	 mov	 WORD PTR [eax], cx

; 430  : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
_gc_pred_average_limited ENDP
_TEXT	ENDS
END
