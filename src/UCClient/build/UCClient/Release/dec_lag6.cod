; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\dec_lag6.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Dec_lag6
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c
;	COMDAT _Dec_lag6
_TEXT	SEGMENT
_pit_max$dead$ = 8					; size = 2
_i_subfr$ = 12						; size = 2
_T0$ = 16						; size = 4
_T0_frac$ = 20						; size = 4
_Dec_lag6 PROC						; COMDAT
; _index$ = cx
; _pit_min$dead$ = dx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   :     Word16 i;
; 70   :     Word16 T0_min, T0_max;
; 71   : 
; 72   :     test ();
; 73   :     if (i_subfr == 0)          /* if 1st or 3rd subframe */

  00003	66 83 7d 0c 00	 cmp	 WORD PTR _i_subfr$[ebp], 0
  00008	66 8b d1	 mov	 dx, cx
  0000b	56		 push	 esi
  0000c	0f 85 20 02 00
	00		 jne	 $LN6@Dec_lag6
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00012	0f bf f2	 movsx	 esi, dx
  00015	8d 86 31 fe ff
	ff		 lea	 eax, DWORD PTR [esi-463]

; 79   :     if (L_var1 > 0X00007fffL)

  0001b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00020	7e 3c		 jle	 SHORT $LN18@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00022	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN5@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  0002c	81 c6 90 fe ff
	ff		 add	 esi, -368		; fffffe90H

; 79   :     if (L_var1 > 0X00007fffL)

  00032	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  00038	0f 8e b8 01 00
	00		 jle	 $LN100@Dec_lag6
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 87   :           *T0 = sub (index, 368);

  0003e	8b 45 10	 mov	 eax, DWORD PTR _T0$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 82   :         var_out = MAX_16;

  00041	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00050	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 87   :           *T0 = sub (index, 368);

  00051	66 89 08	 mov	 WORD PTR [eax], cx

; 88   :           *T0_frac = 0;                     move16 (); 

  00054	33 c9		 xor	 ecx, ecx

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00056	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
  00059	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN18@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0005e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00063	7d 0c		 jge	 SHORT $LN16@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00065	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0006f	eb 05		 jmp	 SHORT $LN258@Dec_lag6
$LN16@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 76   :        if (sub (index, 463) < 0)

  00071	66 85 c0	 test	 ax, ax
  00074	79 b6		 jns	 SHORT $LN5@Dec_lag6
$LN258@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00076	8d 46 05	 lea	 eax, DWORD PTR [esi+5]

; 79   :     if (L_var1 > 0X00007fffL)

  00079	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0007e	7e 11		 jle	 SHORT $LN28@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0008a	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  0008f	eb 1b		 jmp	 SHORT $LN25@Dec_lag6
$LN28@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00091	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00096	7d 11		 jge	 SHORT $LN26@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00098	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000a2	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000a7	eb 03		 jmp	 SHORT $LN25@Dec_lag6
$LN26@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  000a9	0f b7 c8	 movzx	 ecx, ax
$LN25@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 79   :           *T0 = add (mult (add (index, 5), 5462), 17);

  000ac	ba 56 15 00 00	 mov	 edx, 5462		; 00001556H
  000b1	e8 00 00 00 00	 call	 _mult
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  000b6	98		 cwde
  000b7	83 c0 11	 add	 eax, 17			; 00000011H

; 79   :     if (L_var1 > 0X00007fffL)

  000ba	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000bf	7e 11		 jle	 SHORT $LN38@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  000c1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000cb	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  000d0	eb 1b		 jmp	 SHORT $LN35@Dec_lag6
$LN38@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000d2	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000d7	7d 11		 jge	 SHORT $LN36@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  000d9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000e3	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000e8	eb 03		 jmp	 SHORT $LN35@Dec_lag6
$LN36@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  000ea	0f b7 c8	 movzx	 ecx, ax
$LN35@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 79   :           *T0 = add (mult (add (index, 5), 5462), 17);

  000ed	8b 45 10	 mov	 eax, DWORD PTR _T0$[ebp]
  000f0	66 89 08	 mov	 WORD PTR [eax], cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  000f3	0f bf c9	 movsx	 ecx, cx
  000f6	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 79   :     if (L_var1 > 0X00007fffL)

  000f9	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000fe	7e 11		 jle	 SHORT $LN48@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00100	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0010a	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0010f	eb 1b		 jmp	 SHORT $LN45@Dec_lag6
$LN48@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00111	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00116	7d 11		 jge	 SHORT $LN46@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00118	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00122	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00127	eb 03		 jmp	 SHORT $LN45@Dec_lag6
$LN46@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  00129	0f b7 c0	 movzx	 eax, ax
$LN45@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  0012c	98		 cwde
  0012d	03 c1		 add	 eax, ecx

; 79   :     if (L_var1 > 0X00007fffL)

  0012f	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00134	7e 11		 jle	 SHORT $LN58@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00136	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00140	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00145	eb 1b		 jmp	 SHORT $LN55@Dec_lag6
$LN58@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00147	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0014c	7d 11		 jge	 SHORT $LN56@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  0014e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00158	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0015d	eb 03		 jmp	 SHORT $LN55@Dec_lag6
$LN56@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  0015f	0f b7 c0	 movzx	 eax, ax
$LN55@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  00162	98		 cwde
  00163	03 c0		 add	 eax, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00165	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0016a	7e 11		 jle	 SHORT $LN68@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  0016c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00176	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0017b	eb 1b		 jmp	 SHORT $LN65@Dec_lag6
$LN68@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0017d	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00182	7d 11		 jge	 SHORT $LN66@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00184	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0018e	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00193	eb 03		 jmp	 SHORT $LN65@Dec_lag6
$LN66@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  00195	0f b7 c0	 movzx	 eax, ax
$LN65@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  00198	98		 cwde
  00199	2b f0		 sub	 esi, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0019b	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  001a1	7e 11		 jle	 SHORT $LN78@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001ad	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  001b2	eb 1c		 jmp	 SHORT $LN75@Dec_lag6
$LN78@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b4	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  001ba	7d 11		 jge	 SHORT $LN76@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  001bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  001c6	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  001cb	eb 03		 jmp	 SHORT $LN75@Dec_lag6
$LN76@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  001cd	0f b7 c6	 movzx	 eax, si
$LN75@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  001d0	98		 cwde
  001d1	83 c0 69	 add	 eax, 105		; 00000069H

; 79   :     if (L_var1 > 0X00007fffL)

  001d4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001d9	0f 8f 14 03 00
	00		 jg	 $LN262@Dec_lag6

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001df	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001e4	0f 8c 29 03 00
	00		 jl	 $LN261@Dec_lag6

; 91   :         var_out = extract_l (L_var1);

  001ea	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  001ed	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
  001f0	5e		 pop	 esi
  001f1	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  001f4	5d		 pop	 ebp
  001f5	c3		 ret	 0
$LN100@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001f6	81 fe 00 80 ff
	ff		 cmp	 esi, -32768		; ffff8000H
  001fc	7d 20		 jge	 SHORT $LN98@Dec_lag6
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 87   :           *T0 = sub (index, 368);

  001fe	8b 45 10	 mov	 eax, DWORD PTR _T0$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 87   :         var_out = MIN_16;

  00201	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  00206	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00210	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 87   :           *T0 = sub (index, 368);

  00211	66 89 08	 mov	 WORD PTR [eax], cx

; 88   :           *T0_frac = 0;                     move16 (); 

  00214	33 c9		 xor	 ecx, ecx

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00216	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
  00219	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  0021c	5d		 pop	 ebp
  0021d	c3		 ret	 0
$LN98@Dec_lag6:

; 87   :           *T0 = sub (index, 368);

  0021e	8b 45 10	 mov	 eax, DWORD PTR _T0$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  00221	0f b7 ce	 movzx	 ecx, si
  00224	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 87   :           *T0 = sub (index, 368);

  00225	66 89 08	 mov	 WORD PTR [eax], cx

; 88   :           *T0_frac = 0;                     move16 (); 

  00228	33 c9		 xor	 ecx, ecx

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  0022a	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
  0022d	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
$LN6@Dec_lag6:
  00232	57		 push	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00233	8b 7d 10	 mov	 edi, DWORD PTR _T0$[ebp]
  00236	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00239	83 e8 05	 sub	 eax, 5

; 79   :     if (L_var1 > 0X00007fffL)

  0023c	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00241	7e 11		 jle	 SHORT $LN112@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00243	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0024d	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00252	eb 1b		 jmp	 SHORT $LN109@Dec_lag6
$LN112@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00254	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00259	7d 11		 jge	 SHORT $LN110@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  0025b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00265	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0026a	eb 03		 jmp	 SHORT $LN109@Dec_lag6
$LN110@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  0026c	0f b7 c0	 movzx	 eax, ax
$LN109@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 96   :        T0_min = sub (*T0, 5);

  0026f	0f b7 c8	 movzx	 ecx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00272	98		 cwde
  00273	83 e8 12	 sub	 eax, 18			; 00000012H

; 79   :     if (L_var1 > 0X00007fffL)

  00276	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0027b	7e 0c		 jle	 SHORT $LN124@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  0027d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00287	eb 1d		 jmp	 SHORT $LN129@Dec_lag6
$LN124@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00289	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0028e	7d 0c		 jge	 SHORT $LN122@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00290	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0029a	eb 05		 jmp	 SHORT $LN259@Dec_lag6
$LN122@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 99   :        if (sub (T0_min, pit_min) < 0)

  0029c	66 85 c0	 test	 ax, ax
  0029f	79 05		 jns	 SHORT $LN129@Dec_lag6
$LN259@Dec_lag6:

; 100  :        {
; 101  :           T0_min = pit_min;                 move16 (); 

  002a1	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
$LN129@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002a6	0f bf c1	 movsx	 eax, cx
  002a9	83 c0 09	 add	 eax, 9

; 79   :     if (L_var1 > 0X00007fffL)

  002ac	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002b1	7e 11		 jle	 SHORT $LN136@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  002b3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002bd	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  002c2	eb 1b		 jmp	 SHORT $LN133@Dec_lag6
$LN136@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002c4	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002c9	7d 11		 jge	 SHORT $LN134@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  002cb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002d5	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002da	eb 03		 jmp	 SHORT $LN133@Dec_lag6
$LN134@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  002dc	0f b7 c0	 movzx	 eax, ax
$LN133@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  002df	98		 cwde
  002e0	2d 8f 00 00 00	 sub	 eax, 143		; 0000008fH

; 79   :     if (L_var1 > 0X00007fffL)

  002e5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002ea	7e 0c		 jle	 SHORT $LN148@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  002ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002f6	eb 18		 jmp	 SHORT $LN260@Dec_lag6
$LN148@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002f8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002fd	7d 0c		 jge	 SHORT $LN146@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  002ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00309	eb 0a		 jmp	 SHORT $LN1@Dec_lag6
$LN146@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 106  :        if (sub (T0_max, pit_max) > 0)

  0030b	66 85 c0	 test	 ax, ax
  0030e	7e 05		 jle	 SHORT $LN1@Dec_lag6
$LN260@Dec_lag6:

; 107  :        {
; 108  :           T0_max = pit_max;                 move16 (); 
; 109  :           T0_min = sub (T0_max, 9);

  00310	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
$LN1@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  00315	0f bf f2	 movsx	 esi, dx
  00318	8d 46 05	 lea	 eax, DWORD PTR [esi+5]

; 79   :     if (L_var1 > 0X00007fffL)

  0031b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00320	7e 11		 jle	 SHORT $LN170@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00322	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0032c	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00331	eb 1b		 jmp	 SHORT $LN167@Dec_lag6
$LN170@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00333	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00338	7d 11		 jge	 SHORT $LN168@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  0033a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00344	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00349	eb 03		 jmp	 SHORT $LN167@Dec_lag6
$LN168@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  0034b	0f b7 c0	 movzx	 eax, ax
$LN167@Dec_lag6:

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);
; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;
; 304  :         }
; 305  :         else
; 306  :         {
; 307  :             var_out = extract_l (result);
; 308  : #if (WMOPS)
; 309  :             multiCounter[currCounter].extract_l--;
; 310  : #endif
; 311  :         }
; 312  :     }
; 313  : #if (WMOPS)
; 314  :     multiCounter[currCounter].shl++;
; 315  : #endif
; 316  :     return (var_out);
; 317  : }
; 318  : 
; 319  : /*___________________________________________________________________________
; 320  :  |                                                                           |
; 321  :  |   Function Name : shr                                                     |
; 322  :  |                                                                           |
; 323  :  |   Purpose :                                                               |
; 324  :  |                                                                           |
; 325  :  |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
; 326  :  |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
; 327  :  |   -var2 with sign extension. Saturate the result in case of underflows or |
; 328  :  |   overflows.                                                              |
; 329  :  |                                                                           |
; 330  :  |   Complexity weight : 1                                                   |
; 331  :  |                                                                           |
; 332  :  |   Inputs :                                                                |
; 333  :  |                                                                           |
; 334  :  |    var1                                                                   |
; 335  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 336  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 337  :  |                                                                           |
; 338  :  |    var2                                                                   |
; 339  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 340  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 341  :  |                                                                           |
; 342  :  |   Outputs :                                                               |
; 343  :  |                                                                           |
; 344  :  |    none                                                                   |
; 345  :  |                                                                           |
; 346  :  |   Return Value :                                                          |
; 347  :  |                                                                           |
; 348  :  |    var_out                                                                |
; 349  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 350  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 351  :  |___________________________________________________________________________|
; 352  : */
; 353  : 
; 354  : Word16 shr (Word16 var1, Word16 var2)
; 355  : {
; 356  :     Word16 var_out;
; 357  : 
; 358  :     if (var2 < 0)
; 359  :     {
; 360  :         if (var2 < -16)
; 361  :             var2 = -16;
; 362  :         var_out = shl (var1, -var2);
; 363  : #if (WMOPS)
; 364  :         multiCounter[currCounter].shl--;
; 365  : #endif
; 366  :     }
; 367  :     else
; 368  :     {
; 369  :         if (var2 >= 15)
; 370  :         {
; 371  :             var_out = (var1 < 0) ? -1 : 0;
; 372  :         }
; 373  :         else
; 374  :         {
; 375  :             if (var1 < 0)
; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);
; 378  :             }
; 379  :             else
; 380  :             {
; 381  :                 var_out = var1 >> var2;
; 382  :             }
; 383  :         }
; 384  :     }
; 385  : 
; 386  : #if (WMOPS)
; 387  :     multiCounter[currCounter].shr++;
; 388  : #endif
; 389  :     return (var_out);
; 390  : }
; 391  : 
; 392  : /*___________________________________________________________________________
; 393  :  |                                                                           |
; 394  :  |   Function Name : mult                                                    |
; 395  :  |                                                                           |
; 396  :  |   Purpose :                                                               |
; 397  :  |                                                                           |
; 398  :  |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
; 399  :  |    which is scaled i.e.:                                                  |
; 400  :  |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
; 401  :  |             mult(-32768,-32768) = 32767.                                  |
; 402  :  |                                                                           |
; 403  :  |   Complexity weight : 1                                                   |
; 404  :  |                                                                           |
; 405  :  |   Inputs :                                                                |
; 406  :  |                                                                           |
; 407  :  |    var1                                                                   |
; 408  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 409  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 410  :  |                                                                           |
; 411  :  |    var2                                                                   |
; 412  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 413  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 414  :  |                                                                           |
; 415  :  |   Outputs :                                                               |
; 416  :  |                                                                           |
; 417  :  |    none                                                                   |
; 418  :  |                                                                           |
; 419  :  |   Return Value :                                                          |
; 420  :  |                                                                           |
; 421  :  |    var_out                                                                |
; 422  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 423  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 424  :  |___________________________________________________________________________|
; 425  : */
; 426  : 
; 427  : Word16 mult (Word16 var1, Word16 var2)
; 428  : {
; 429  :     Word16 var_out;
; 430  :     Word32 L_product;
; 431  : 
; 432  :     L_product = (Word32) var1 *(Word32) var2;

  0034e	98		 cwde
  0034f	69 c0 56 15 00
	00		 imul	 eax, eax, 5462

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00355	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  00358	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0035d	74 05		 je	 SHORT $LN175@Dec_lag6

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  0035f	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN175@Dec_lag6:

; 79   :     if (L_var1 > 0X00007fffL)

  00364	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00369	7e 11		 jle	 SHORT $LN181@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  0036b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00375	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0037a	eb 1b		 jmp	 SHORT $LN178@Dec_lag6
$LN181@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0037c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00381	7d 11		 jge	 SHORT $LN179@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00383	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0038d	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00392	eb 03		 jmp	 SHORT $LN178@Dec_lag6
$LN179@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  00394	0f b7 c0	 movzx	 eax, ax
$LN178@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  00397	98		 cwde
  00398	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00399	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0039e	7e 11		 jle	 SHORT $LN191@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  003a0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003aa	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  003af	eb 1b		 jmp	 SHORT $LN188@Dec_lag6
$LN191@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003b1	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003b6	7d 11		 jge	 SHORT $LN189@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  003b8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  003c2	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  003c7	eb 03		 jmp	 SHORT $LN188@Dec_lag6
$LN189@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  003c9	0f b7 c0	 movzx	 eax, ax
$LN188@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  003cc	0f bf d0	 movsx	 edx, ax
  003cf	0f bf c1	 movsx	 eax, cx
  003d2	03 c2		 add	 eax, edx

; 79   :     if (L_var1 > 0X00007fffL)

  003d4	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003d9	7e 11		 jle	 SHORT $LN201@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  003db	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003e5	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  003ea	eb 1b		 jmp	 SHORT $LN198@Dec_lag6
$LN201@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003ec	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003f1	7d 11		 jge	 SHORT $LN199@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  003f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  003fd	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00402	eb 03		 jmp	 SHORT $LN198@Dec_lag6
$LN199@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  00404	0f b7 c0	 movzx	 eax, ax
$LN198@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 114  :        *T0 = add (i, T0_min);

  00407	66 89 07	 mov	 WORD PTR [edi], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  0040a	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  0040d	5f		 pop	 edi

; 79   :     if (L_var1 > 0X00007fffL)

  0040e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00413	7e 11		 jle	 SHORT $LN211@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00415	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0041f	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00424	eb 1b		 jmp	 SHORT $LN208@Dec_lag6
$LN211@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00426	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0042b	7d 11		 jge	 SHORT $LN209@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  0042d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00437	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0043c	eb 03		 jmp	 SHORT $LN208@Dec_lag6
$LN209@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  0043e	0f b7 c0	 movzx	 eax, ax
$LN208@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  00441	98		 cwde
  00442	03 c2		 add	 eax, edx

; 79   :     if (L_var1 > 0X00007fffL)

  00444	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00449	7e 11		 jle	 SHORT $LN221@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  0044b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00455	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0045a	eb 1b		 jmp	 SHORT $LN218@Dec_lag6
$LN221@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0045c	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00461	7d 11		 jge	 SHORT $LN219@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00463	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0046d	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00472	eb 03		 jmp	 SHORT $LN218@Dec_lag6
$LN219@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  00474	0f b7 c0	 movzx	 eax, ax
$LN218@Dec_lag6:

; 139  :     L_sum = (Word32) var1 + var2;

  00477	98		 cwde
  00478	03 c0		 add	 eax, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0047a	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0047f	7e 11		 jle	 SHORT $LN231@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  00481	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0048b	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00490	eb 1b		 jmp	 SHORT $LN228@Dec_lag6
$LN231@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00492	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00497	7d 11		 jge	 SHORT $LN229@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  00499	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  004a3	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  004a8	eb 03		 jmp	 SHORT $LN228@Dec_lag6
$LN229@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  004aa	0f b7 d0	 movzx	 edx, ax
$LN228@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  004ad	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]

; 79   :     if (L_var1 > 0X00007fffL)

  004b0	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004b5	7e 11		 jle	 SHORT $LN241@Dec_lag6

; 80   :     {
; 81   :         Overflow = 1;

  004b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004c1	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  004c6	eb 1b		 jmp	 SHORT $LN238@Dec_lag6
$LN241@Dec_lag6:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004c8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004cd	7d 11		 jge	 SHORT $LN239@Dec_lag6

; 85   :     {
; 86   :         Overflow = 1;

  004cf	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  004d9	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  004de	eb 03		 jmp	 SHORT $LN238@Dec_lag6
$LN239@Dec_lag6:

; 91   :         var_out = extract_l (L_var1);

  004e0	0f b7 c0	 movzx	 eax, ax
$LN238@Dec_lag6:

; 186  :     L_diff = (Word32) var1 - var2;

  004e3	0f bf c8	 movsx	 ecx, ax
  004e6	0f bf c2	 movsx	 eax, dx
  004e9	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  004eb	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  004f1	7e 18		 jle	 SHORT $LN251@Dec_lag6
$LN262@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  004f3	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 82   :         var_out = MAX_16;

  004f6	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  004fb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00505	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00506	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  00509	5d		 pop	 ebp
  0050a	c3		 ret	 0
$LN251@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0050b	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00511	7d 18		 jge	 SHORT $LN249@Dec_lag6
$LN261@Dec_lag6:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00513	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 87   :         var_out = MIN_16;

  00516	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H
  0051b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00525	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00526	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  00529	5d		 pop	 ebp
  0052a	c3		 ret	 0
$LN249@Dec_lag6:

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  0052b	8b 45 14	 mov	 eax, DWORD PTR _T0_frac$[ebp]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  0052e	0f b7 c9	 movzx	 ecx, cx
  00531	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\dec_lag6.c

; 116  :        *T0_frac = sub (sub (index, 3), add (i, i));

  00532	66 89 08	 mov	 WORD PTR [eax], cx

; 117  :                                             move16 (); 
; 118  :     }
; 119  : }

  00535	5d		 pop	 ebp
  00536	c3		 ret	 0
_Dec_lag6 ENDP
_TEXT	ENDS
END
