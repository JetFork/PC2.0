; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\bgnscd.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@PJKCAIBL@Bgn_scd_reset?3?5invalid?5parameter@ ; `string'
PUBLIC	??_C@_0CB@NBHDLMJL@Bgn_scd_init?3?5invalid?5parameter?6@ ; `string'
PUBLIC	??_C@_0CO@JFIOBCBL@Bgn_scd_init?3?5can?5not?5malloc?5sta@ ; `string'
;	COMDAT ??_C@_0CO@JFIOBCBL@Bgn_scd_init?3?5can?5not?5malloc?5sta@
CONST	SEGMENT
??_C@_0CO@JFIOBCBL@Bgn_scd_init?3?5can?5not?5malloc?5sta@ DB 'Bgn_scd_ini'
	DB	't: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NBHDLMJL@Bgn_scd_init?3?5invalid?5parameter?6@
CONST	SEGMENT
??_C@_0CB@NBHDLMJL@Bgn_scd_init?3?5invalid?5parameter?6@ DB 'Bgn_scd_init'
	DB	': invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PJKCAIBL@Bgn_scd_reset?3?5invalid?5parameter@
CONST	SEGMENT
??_C@_0CC@PJKCAIBL@Bgn_scd_reset?3?5invalid?5parameter@ DB 'Bgn_scd_reset'
	DB	': invalid parameter', 0aH, 00H		; `string'
PUBLIC	_Bgn_scd_exit
PUBLIC	_Bgn_scd_reset
PUBLIC	_Bgn_scd_init
PUBLIC	_Bgn_scd
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
;	COMDAT _Bgn_scd
_TEXT	SEGMENT
_ltpGainHist$1$ = -20					; size = 4
_currEnergy$1$ = -16					; size = 4
_var_out$1$ = -12					; size = 4
_maxEnergy$1$ = -8					; size = 4
_st$1$ = -4						; size = 4
_speech$ = 8						; size = 4
_voicedHangover$ = 12					; size = 4
_Bgn_scd PROC						; COMDAT
; _st$ = ecx
; _ltpGainHist$ = edx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	89 55 ec	 mov	 DWORD PTR _ltpGainHist$1$[ebp], edx
  0000d	57		 push	 edi

; 141  :    Word16 i;
; 142  :    Word16 prevVoiced, inbgNoise;
; 143  :    Word16 temp;
; 144  :    Word16 ltpLimit, frameEnergyMin;
; 145  :    Word16 currEnergy, noiseFloor, maxEnergy, maxEnergyLastPart;
; 146  :    Word32 s;
; 147  :    
; 148  :    /* Update the inBackgroundNoise flag (valid for use in next frame if BFI) */
; 149  :    /* it now works as a energy detector floating on top                      */ 
; 150  :    /* not as good as a VAD.                                                  */
; 151  : 
; 152  :    currEnergy = 0;                                   move16 ();
; 153  :    s = (Word32) 0;                                   move32 ();

  0000e	8b 7d 08	 mov	 edi, DWORD PTR _speech$[ebp]
  00011	33 f6		 xor	 esi, esi
  00013	89 5d fc	 mov	 DWORD PTR _st$1$[ebp], ebx
  00016	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  0001b	eb 03 8d 49 00	 npad	 5
$LL34@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00020	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00023	0f af c0	 imul	 eax, eax

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00026	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0002b	74 04		 je	 SHORT $LN44@Bgn_scd

; 488  :     {
; 489  :         L_var_out *= 2;

  0002d	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0002f	eb 0f		 jmp	 SHORT $LN43@Bgn_scd
$LN44@Bgn_scd:

; 492  :     {
; 493  :         Overflow = 1;

  00031	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0003b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN43@Bgn_scd:

; 576  : #if (WMOPS)
; 577  :     multiCounter[currCounter].extract_h++;
; 578  : #endif
; 579  :     return (var_out);
; 580  : }
; 581  : 
; 582  : /*___________________________________________________________________________
; 583  :  |                                                                           |
; 584  :  |   Function Name : extract_l                                               |
; 585  :  |                                                                           |
; 586  :  |   Purpose :                                                               |
; 587  :  |                                                                           |
; 588  :  |   Return the 16 LSB of L_var1.                                            |
; 589  :  |                                                                           |
; 590  :  |   Complexity weight : 1                                                   |
; 591  :  |                                                                           |
; 592  :  |   Inputs :                                                                |
; 593  :  |                                                                           |
; 594  :  |    L_var1                                                                 |
; 595  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 596  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 597  :  |                                                                           |
; 598  :  |   Outputs :                                                               |
; 599  :  |                                                                           |
; 600  :  |    none                                                                   |
; 601  :  |                                                                           |
; 602  :  |   Return Value :                                                          |
; 603  :  |                                                                           |
; 604  :  |    var_out                                                                |
; 605  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 606  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 607  :  |___________________________________________________________________________|
; 608  : */
; 609  : 
; 610  : Word16 extract_l (Word32 L_var1)
; 611  : {
; 612  :     Word16 var_out;
; 613  : 
; 614  :     var_out = (Word16) L_var1;
; 615  : #if (WMOPS)
; 616  :     multiCounter[currCounter].extract_l++;
; 617  : #endif
; 618  :     return (var_out);
; 619  : }
; 620  : 
; 621  : /*___________________________________________________________________________
; 622  :  |                                                                           |
; 623  :  |   Function Name : round                                                   |
; 624  :  |                                                                           |
; 625  :  |   Purpose :                                                               |
; 626  :  |                                                                           |
; 627  :  |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
; 628  :  |   with saturation. Shift the resulting bits right by 16 and return the 16 |
; 629  :  |   bit number:                                                             |
; 630  :  |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
; 631  :  |                                                                           |
; 632  :  |   Complexity weight : 1                                                   |
; 633  :  |                                                                           |
; 634  :  |   Inputs :                                                                |
; 635  :  |                                                                           |
; 636  :  |    L_var1                                                                 |
; 637  :  |             32 bit long signed integer (Word32 ) whose value falls in the |
; 638  :  |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
; 639  :  |                                                                           |
; 640  :  |   Outputs :                                                               |
; 641  :  |                                                                           |
; 642  :  |    none                                                                   |
; 643  :  |                                                                           |
; 644  :  |   Return Value :                                                          |
; 645  :  |                                                                           |
; 646  :  |    var_out                                                                |
; 647  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 648  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 649  :  |___________________________________________________________________________|
; 650  : */
; 651  : 
; 652  : Word16 round (Word32 L_var1)
; 653  : {
; 654  :     Word16 var_out;
; 655  :     Word32 L_rounded;
; 656  : 
; 657  :     L_rounded = L_add (L_var1, (Word32) 0x00008000L);
; 658  : #if (WMOPS)
; 659  :     multiCounter[currCounter].L_add--;
; 660  : #endif
; 661  :     var_out = extract_h (L_rounded);
; 662  : #if (WMOPS)
; 663  :     multiCounter[currCounter].extract_h--;
; 664  :     multiCounter[currCounter].round++;
; 665  : #endif
; 666  :     return (var_out);
; 667  : }
; 668  : 
; 669  : /*___________________________________________________________________________
; 670  :  |                                                                           |
; 671  :  |   Function Name : L_mac                                                   |
; 672  :  |                                                                           |
; 673  :  |   Purpose :                                                               |
; 674  :  |                                                                           |
; 675  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 676  :  |   result to L_var3 with saturation, return a 32 bit result:               |
; 677  :  |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
; 678  :  |                                                                           |
; 679  :  |   Complexity weight : 1                                                   |
; 680  :  |                                                                           |
; 681  :  |   Inputs :                                                                |
; 682  :  |                                                                           |
; 683  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 684  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 685  :  |                                                                           |
; 686  :  |    var1                                                                   |
; 687  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 688  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 689  :  |                                                                           |
; 690  :  |    var2                                                                   |
; 691  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 692  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 693  :  |                                                                           |
; 694  :  |   Outputs :                                                               |
; 695  :  |                                                                           |
; 696  :  |    none                                                                   |
; 697  :  |                                                                           |
; 698  :  |   Return Value :                                                          |
; 699  :  |                                                                           |
; 700  :  |    L_var_out                                                              |
; 701  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 702  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 703  :  |___________________________________________________________________________|
; 704  : */
; 705  : 
; 706  : Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
; 707  : {
; 708  :     Word32 L_var_out;
; 709  :     Word32 L_product;
; 710  : 
; 711  :     L_product = L_mult (var1, var2);
; 712  : #if (WMOPS)
; 713  :     multiCounter[currCounter].L_mult--;
; 714  : #endif
; 715  :     L_var_out = L_add (L_var3, L_product);
; 716  : #if (WMOPS)
; 717  :     multiCounter[currCounter].L_add--;
; 718  :     multiCounter[currCounter].L_mac++;
; 719  : #endif
; 720  :     return (L_var_out);
; 721  : }
; 722  : 
; 723  : /*___________________________________________________________________________
; 724  :  |                                                                           |
; 725  :  |   Function Name : L_msu                                                   |
; 726  :  |                                                                           |
; 727  :  |   Purpose :                                                               |
; 728  :  |                                                                           |
; 729  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 730  :  |   bit result to L_var3 with saturation, return a 32 bit result:           |
; 731  :  |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
; 732  :  |                                                                           |
; 733  :  |   Complexity weight : 1                                                   |
; 734  :  |                                                                           |
; 735  :  |   Inputs :                                                                |
; 736  :  |                                                                           |
; 737  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 738  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 739  :  |                                                                           |
; 740  :  |    var1                                                                   |
; 741  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 742  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 743  :  |                                                                           |
; 744  :  |    var2                                                                   |
; 745  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 746  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 747  :  |                                                                           |
; 748  :  |   Outputs :                                                               |
; 749  :  |                                                                           |
; 750  :  |    none                                                                   |
; 751  :  |                                                                           |
; 752  :  |   Return Value :                                                          |
; 753  :  |                                                                           |
; 754  :  |    L_var_out                                                              |
; 755  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 756  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 757  :  |___________________________________________________________________________|
; 758  : */
; 759  : 
; 760  : Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
; 761  : {
; 762  :     Word32 L_var_out;
; 763  :     Word32 L_product;
; 764  : 
; 765  :     L_product = L_mult (var1, var2);
; 766  : #if (WMOPS)
; 767  :     multiCounter[currCounter].L_mult--;
; 768  : #endif
; 769  :     L_var_out = L_sub (L_var3, L_product);
; 770  : #if (WMOPS)
; 771  :     multiCounter[currCounter].L_sub--;
; 772  :     multiCounter[currCounter].L_msu++;
; 773  : #endif
; 774  :     return (L_var_out);
; 775  : }
; 776  : 
; 777  : /*___________________________________________________________________________
; 778  :  |                                                                           |
; 779  :  |   Function Name : L_macNs                                                 |
; 780  :  |                                                                           |
; 781  :  |   Purpose :                                                               |
; 782  :  |                                                                           |
; 783  :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 784  :  |   result to L_var3 without saturation, return a 32 bit result. Generate   |
; 785  :  |   carry and overflow values :                                             |
; 786  :  |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
; 787  :  |                                                                           |
; 788  :  |   Complexity weight : 1                                                   |
; 789  :  |                                                                           |
; 790  :  |   Inputs :                                                                |
; 791  :  |                                                                           |
; 792  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 793  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 794  :  |                                                                           |
; 795  :  |    var1                                                                   |
; 796  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 797  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 798  :  |                                                                           |
; 799  :  |    var2                                                                   |
; 800  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 801  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 802  :  |                                                                           |
; 803  :  |   Outputs :                                                               |
; 804  :  |                                                                           |
; 805  :  |    none                                                                   |
; 806  :  |                                                                           |
; 807  :  |   Return Value :                                                          |
; 808  :  |                                                                           |
; 809  :  |    L_var_out                                                              |
; 810  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 811  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 812  :  |                                                                           |
; 813  :  |   Caution :                                                               |
; 814  :  |                                                                           |
; 815  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 816  :  |    operators which take into account its value.                           |
; 817  :  |___________________________________________________________________________|
; 818  : */
; 819  : 
; 820  : Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
; 821  : {
; 822  :     Word32 L_var_out;
; 823  : 
; 824  :     L_var_out = L_mult (var1, var2);
; 825  : #if (WMOPS)
; 826  :     multiCounter[currCounter].L_mult--;
; 827  : #endif
; 828  :     L_var_out = L_add_c (L_var3, L_var_out);
; 829  : #if (WMOPS)
; 830  :     multiCounter[currCounter].L_add_c--;
; 831  :     multiCounter[currCounter].L_macNs++;
; 832  : #endif
; 833  :     return (L_var_out);
; 834  : }
; 835  : 
; 836  : /*___________________________________________________________________________
; 837  :  |                                                                           |
; 838  :  |   Function Name : L_msuNs                                                 |
; 839  :  |                                                                           |
; 840  :  |   Purpose :                                                               |
; 841  :  |                                                                           |
; 842  :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 843  :  |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
; 844  :  |   nerate carry and overflow values :                                      |
; 845  :  |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
; 846  :  |                                                                           |
; 847  :  |   Complexity weight : 1                                                   |
; 848  :  |                                                                           |
; 849  :  |   Inputs :                                                                |
; 850  :  |                                                                           |
; 851  :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 852  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 853  :  |                                                                           |
; 854  :  |    var1                                                                   |
; 855  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 856  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 857  :  |                                                                           |
; 858  :  |    var2                                                                   |
; 859  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 860  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 861  :  |                                                                           |
; 862  :  |   Outputs :                                                               |
; 863  :  |                                                                           |
; 864  :  |    none                                                                   |
; 865  :  |                                                                           |
; 866  :  |   Return Value :                                                          |
; 867  :  |                                                                           |
; 868  :  |    L_var_out                                                              |
; 869  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 870  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 871  :  |                                                                           |
; 872  :  |   Caution :                                                               |
; 873  :  |                                                                           |
; 874  :  |    In some cases the Carry flag has to be cleared or set before using     |
; 875  :  |    operators which take into account its value.                           |
; 876  :  |___________________________________________________________________________|
; 877  : */
; 878  : 
; 879  : Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
; 880  : {
; 881  :     Word32 L_var_out;
; 882  : 
; 883  :     L_var_out = L_mult (var1, var2);
; 884  : #if (WMOPS)
; 885  :     multiCounter[currCounter].L_mult--;
; 886  : #endif
; 887  :     L_var_out = L_sub_c (L_var3, L_var_out);
; 888  : #if (WMOPS)
; 889  :     multiCounter[currCounter].L_sub_c--;
; 890  :     multiCounter[currCounter].L_msuNs++;
; 891  : #endif
; 892  :     return (L_var_out);
; 893  : }
; 894  : 
; 895  : /*___________________________________________________________________________
; 896  :  |                                                                           |
; 897  :  |   Function Name : L_add                                                   |
; 898  :  |                                                                           |
; 899  :  |   Purpose :                                                               |
; 900  :  |                                                                           |
; 901  :  |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
; 902  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 903  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 904  :  |                                                                           |
; 905  :  |   Complexity weight : 2                                                   |
; 906  :  |                                                                           |
; 907  :  |   Inputs :                                                                |
; 908  :  |                                                                           |
; 909  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 910  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 911  :  |                                                                           |
; 912  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 913  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 914  :  |                                                                           |
; 915  :  |   Outputs :                                                               |
; 916  :  |                                                                           |
; 917  :  |    none                                                                   |
; 918  :  |                                                                           |
; 919  :  |   Return Value :                                                          |
; 920  :  |                                                                           |
; 921  :  |    L_var_out                                                              |
; 922  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 923  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 924  :  |___________________________________________________________________________|
; 925  : */
; 926  : 
; 927  : Word32 L_add (Word32 L_var1, Word32 L_var2)
; 928  : {
; 929  :     Word32 L_var_out;
; 930  : 
; 931  :     L_var_out = L_var1 + L_var2;

  00040	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]

; 932  : 
; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00043	33 c6		 xor	 eax, esi
  00045	78 1d		 js	 SHORT $LN47@Bgn_scd

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00047	8b c1		 mov	 eax, ecx
  00049	33 c6		 xor	 eax, esi
  0004b	79 17		 jns	 SHORT $LN47@Bgn_scd

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  0004d	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  0004f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00059	85 f6		 test	 esi, esi
  0005b	0f 98 c1	 sets	 cl
  0005e	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN47@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 155  :    for (i = 0; i < L_FRAME; i++)

  00064	83 c7 02	 add	 edi, 2

; 156  :    {
; 157  :        s = L_mac (s, speech[i], speech[i]);

  00067	8b f1		 mov	 esi, ecx
  00069	4a		 dec	 edx
  0006a	75 b4		 jne	 SHORT $LL34@Bgn_scd

; 158  :    }
; 159  : 
; 160  :    s = L_shl(s, 2);  

  0006c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0006f	90		 npad	 1
$LL59@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  00070	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00076	7f 19		 jg	 SHORT $LN347@Bgn_scd

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00078	81 f9 00 00 00
	c0		 cmp	 ecx, -1073741824	; c0000000H
  0007e	7c 0a		 jl	 SHORT $LN348@Bgn_scd

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00080	48		 dec	 eax
  00081	03 c9		 add	 ecx, ecx
  00083	66 85 c0	 test	 ax, ax
  00086	7f e8		 jg	 SHORT $LL59@Bgn_scd

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  00088	eb 16		 jmp	 SHORT $LN54@Bgn_scd
$LN348@Bgn_scd:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0008a	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0008f	eb 05		 jmp	 SHORT $LN390@Bgn_scd
$LN347@Bgn_scd:

; 1360 :                 L_var_out = MAX_32;

  00091	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN390@Bgn_scd:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00096	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN54@Bgn_scd:

; 575  :     var_out = (Word16) (L_var1 >> 16);

  000a0	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000a3	8b d3		 mov	 edx, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 162  :    currEnergy = extract_h (s);

  000a5	0f b7 c1	 movzx	 eax, cx

; 163  : 
; 164  :    frameEnergyMin = 32767;                     move16 ();

  000a8	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  000ad	89 45 f0	 mov	 DWORD PTR _currEnergy$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  000b0	bb 3c 00 00 00	 mov	 ebx, 60			; 0000003cH
$LL31@Bgn_scd:

; 186  :     L_diff = (Word32) var1 - var2;

  000b5	0f b7 32	 movzx	 esi, WORD PTR [edx]
  000b8	0f bf ce	 movsx	 ecx, si
  000bb	0f bf c7	 movsx	 eax, di
  000be	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  000c0	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  000c6	7e 0c		 jle	 SHORT $LN73@Bgn_scd

; 81   :         Overflow = 1;

  000c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000d2	eb 1b		 jmp	 SHORT $LN30@Bgn_scd
$LN73@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000d4	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  000da	7d 0c		 jge	 SHORT $LN71@Bgn_scd

; 86   :         Overflow = 1;

  000dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  000e6	eb 05		 jmp	 SHORT $LN367@Bgn_scd
$LN71@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 169  :       if (sub(st->frameEnergyHist[i], frameEnergyMin) < 0)

  000e8	66 85 c9	 test	 cx, cx
  000eb	79 02		 jns	 SHORT $LN30@Bgn_scd
$LN367@Bgn_scd:

; 170  :          frameEnergyMin = st->frameEnergyHist[i];           move16 ();

  000ed	8b fe		 mov	 edi, esi
$LN30@Bgn_scd:

; 165  : 
; 166  :    for (i = 0; i < L_ENERGYHIST; i++)

  000ef	83 c2 02	 add	 edx, 2
  000f2	4b		 dec	 ebx
  000f3	75 c0		 jne	 SHORT $LL31@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  000f5	0f bf cf	 movsx	 ecx, di
  000f8	c1 e1 04	 shl	 ecx, 4

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  000fb	0f bf c1	 movsx	 eax, cx
  000fe	3b c8		 cmp	 ecx, eax
  00100	74 1f		 je	 SHORT $LN83@Bgn_scd

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  00102	66 85 ff	 test	 di, di
  00105	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0010f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  00114	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00119	0f 4f c1	 cmovg	 eax, ecx
  0011c	0f b7 c0	 movzx	 eax, ax

; 304  :         }
; 305  :         else

  0011f	eb 03		 jmp	 SHORT $LN391@Bgn_scd
$LN83@Bgn_scd:

; 307  :             var_out = extract_l (result);

  00121	0f b7 c1	 movzx	 eax, cx
$LN391@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 175  :    maxEnergy = st->frameEnergyHist[0];               move16 ();

  00124	8b 5d fc	 mov	 ebx, DWORD PTR _st$1$[ebp]
  00127	bf 37 00 00 00	 mov	 edi, 55			; 00000037H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  0012c	89 45 f4	 mov	 DWORD PTR _var_out$1$[ebp], eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 175  :    maxEnergy = st->frameEnergyHist[0];               move16 ();

  0012f	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  00132	8d 53 02	 lea	 edx, DWORD PTR [ebx+2]
  00135	89 4d f8	 mov	 DWORD PTR _maxEnergy$1$[ebp], ecx
  00138	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL27@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00140	0f b7 32	 movzx	 esi, WORD PTR [edx]
  00143	0f bf c6	 movsx	 eax, si
  00146	0f bf c9	 movsx	 ecx, cx
  00149	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0014b	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00151	7e 41		 jle	 SHORT $LN100@Bgn_scd

; 81   :         Overflow = 1;

  00153	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN388@Bgn_scd:
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _maxEnergy$1$[ebp]
$LN26@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 176  :    for (i = 1; i < L_ENERGYHIST-4; i++)

  00160	83 c2 02	 add	 edx, 2
  00163	4f		 dec	 edi
  00164	75 da		 jne	 SHORT $LL27@Bgn_scd

; 182  :       }
; 183  :    }
; 184  :    
; 185  :    maxEnergyLastPart = st->frameEnergyHist[2*L_ENERGYHIST/3]; move16 ();

  00166	8b 55 fc	 mov	 edx, DWORD PTR _st$1$[ebp]
  00169	bf 13 00 00 00	 mov	 edi, 19			; 00000013H
  0016e	0f b7 5b 50	 movzx	 ebx, WORD PTR [ebx+80]
  00172	83 c2 52	 add	 edx, 82			; 00000052H
$LL23@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00175	0f b7 32	 movzx	 esi, WORD PTR [edx]
  00178	0f bf c6	 movsx	 eax, si
  0017b	0f bf cb	 movsx	 ecx, bx
  0017e	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00180	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00186	7e 31		 jle	 SHORT $LN116@Bgn_scd

; 81   :         Overflow = 1;

  00188	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00192	eb 40		 jmp	 SHORT $LN22@Bgn_scd
$LN100@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00194	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0019a	7d 11		 jge	 SHORT $LN98@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 181  :          maxEnergy = st->frameEnergyHist[i];         move16 ();

  0019c	8b ce		 mov	 ecx, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 86   :         Overflow = 1;

  0019e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 181  :          maxEnergy = st->frameEnergyHist[i];         move16 ();

  001a8	89 4d f8	 mov	 DWORD PTR _maxEnergy$1$[ebp], ecx
  001ab	eb b3		 jmp	 SHORT $LN26@Bgn_scd
$LN98@Bgn_scd:

; 177  :    {
; 178  :       test ();
; 179  :       if ( sub (maxEnergy, st->frameEnergyHist[i]) < 0)

  001ad	66 85 c9	 test	 cx, cx
  001b0	79 ab		 jns	 SHORT $LN388@Bgn_scd

; 181  :          maxEnergy = st->frameEnergyHist[i];         move16 ();

  001b2	8b ce		 mov	 ecx, esi
  001b4	89 4d f8	 mov	 DWORD PTR _maxEnergy$1$[ebp], ecx
  001b7	eb a7		 jmp	 SHORT $LN26@Bgn_scd
$LN116@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001b9	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  001bf	7d 0c		 jge	 SHORT $LN114@Bgn_scd

; 86   :         Overflow = 1;

  001c1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  001cb	eb 05		 jmp	 SHORT $LN369@Bgn_scd
$LN114@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 189  :       if ( sub (maxEnergyLastPart, st->frameEnergyHist[i] ) < 0)

  001cd	66 85 c9	 test	 cx, cx
  001d0	79 02		 jns	 SHORT $LN22@Bgn_scd
$LN369@Bgn_scd:

; 190  :       {
; 191  :          maxEnergyLastPart = st->frameEnergyHist[i]; move16 ();     

  001d2	8b de		 mov	 ebx, esi
$LN22@Bgn_scd:

; 186  :    for (i = 2*L_ENERGYHIST/3+1; i < L_ENERGYHIST; i++)

  001d4	83 c2 02	 add	 edx, 2
  001d7	4f		 dec	 edi
  001d8	75 9b		 jne	 SHORT $LL23@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  001da	8b 45 f8	 mov	 eax, DWORD PTR _maxEnergy$1$[ebp]
  001dd	98		 cwde
  001de	83 e8 14	 sub	 eax, 20			; 00000014H

; 79   :     if (L_var1 > 0X00007fffL)

  001e1	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  001e6	7e 0c		 jle	 SHORT $LN140@Bgn_scd

; 81   :         Overflow = 1;

  001e8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  001f2	eb 14		 jmp	 SHORT $LN370@Bgn_scd
$LN140@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  001f4	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  001f9	0f 8c 75 01 00
	00		 jl	 $LN393@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 208  :           (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))

  001ff	66 85 c0	 test	 ax, ax
  00202	0f 8e 76 01 00
	00		 jle	 $LN19@Bgn_scd
$LN370@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00208	8b 45 f0	 mov	 eax, DWORD PTR _currEnergy$1$[ebp]
  0020b	0f bf c8	 movsx	 ecx, ax
  0020e	8d 81 56 bb ff
	ff		 lea	 eax, DWORD PTR [ecx-17578]

; 79   :     if (L_var1 > 0X00007fffL)

  00214	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00219	0f 8f 55 01 00
	00		 jg	 $LN393@Bgn_scd

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0021f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00224	7d 0c		 jge	 SHORT $LN148@Bgn_scd

; 86   :         Overflow = 1;

  00226	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00230	eb 09		 jmp	 SHORT $LN371@Bgn_scd
$LN148@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 208  :           (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))

  00232	66 85 c0	 test	 ax, ax
  00235	0f 89 43 01 00
	00		 jns	 $LN19@Bgn_scd
$LN371@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0023b	8d 41 ec	 lea	 eax, DWORD PTR [ecx-20]

; 79   :     if (L_var1 > 0X00007fffL)

  0023e	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00243	7e 0c		 jle	 SHORT $LN160@Bgn_scd

; 81   :         Overflow = 1;

  00245	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0024f	eb 14		 jmp	 SHORT $LN372@Bgn_scd
$LN160@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00251	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00256	0f 8c 18 01 00
	00		 jl	 $LN393@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 208  :           (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))

  0025c	66 85 c0	 test	 ax, ax
  0025f	0f 8e 19 01 00
	00		 jle	 $LN19@Bgn_scd
$LN372@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00265	8b 45 f4	 mov	 eax, DWORD PTR _var_out$1$[ebp]
  00268	98		 cwde
  00269	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0026b	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00271	7e 0c		 jle	 SHORT $LN170@Bgn_scd

; 81   :         Overflow = 1;

  00273	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0027d	eb 19		 jmp	 SHORT $LN373@Bgn_scd
$LN170@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0027f	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00285	7d 0c		 jge	 SHORT $LN168@Bgn_scd

; 86   :         Overflow = 1;

  00287	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00291	eb 34		 jmp	 SHORT $LN18@Bgn_scd
$LN168@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 208  :           (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))

  00293	66 85 c9	 test	 cx, cx
  00296	78 2f		 js	 SHORT $LN18@Bgn_scd
$LN373@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00298	0f bf c3	 movsx	 eax, bx
  0029b	2d a1 07 00 00	 sub	 eax, 1953		; 000007a1H

; 79   :     if (L_var1 > 0X00007fffL)

  002a0	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002a5	0f 8f c9 00 00
	00		 jg	 $LN393@Bgn_scd

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002ab	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002b0	7d 0c		 jge	 SHORT $LN178@Bgn_scd

; 86   :         Overflow = 1;

  002b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  002bc	eb 09		 jmp	 SHORT $LN18@Bgn_scd
$LN178@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 208  :           (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))

  002be	66 85 c0	 test	 ax, ax
  002c1	0f 89 b7 00 00
	00		 jns	 $LN19@Bgn_scd
$LN18@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 139  :     L_sum = (Word32) var1 + var2;

  002c7	8b 55 fc	 mov	 edx, DWORD PTR _st$1$[ebp]
  002ca	0f bf 42 78	 movsx	 eax, WORD PTR [edx+120]
  002ce	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  002cf	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  002d4	7e 11		 jle	 SHORT $LN192@Bgn_scd

; 81   :         Overflow = 1;

  002d6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  002e0	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  002e5	eb 1b		 jmp	 SHORT $LN189@Bgn_scd
$LN192@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  002e7	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  002ec	7d 11		 jge	 SHORT $LN190@Bgn_scd

; 86   :         Overflow = 1;

  002ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  002f8	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  002fd	eb 03		 jmp	 SHORT $LN189@Bgn_scd
$LN190@Bgn_scd:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  002ff	0f b7 c8	 movzx	 ecx, ax
$LN189@Bgn_scd:

; 186  :     L_diff = (Word32) var1 - var2;

  00302	0f bf c9	 movsx	 ecx, cx
  00305	83 e9 1e	 sub	 ecx, 30			; 0000001eH

; 79   :     if (L_var1 > 0X00007fffL)

  00308	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0030e	7e 11		 jle	 SHORT $LN202@Bgn_scd

; 81   :         Overflow = 1;

  00310	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 213  :          st->bgHangover = 30;                         move16 ();

  0031a	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH

; 214  :       } else

  0031f	eb 62		 jmp	 SHORT $LN392@Bgn_scd
$LN202@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00321	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00327	7d 22		 jge	 SHORT $LN200@Bgn_scd

; 86   :         Overflow = 1;

  00329	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN17@Bgn_scd:

; 79   :     if (L_var1 > 0X00007fffL)

  00333	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00338	7e 1d		 jle	 SHORT $LN214@Bgn_scd

; 81   :         Overflow = 1;

  0033a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00344	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00349	eb 38		 jmp	 SHORT $LN392@Bgn_scd
$LN200@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 211  :       if (sub(add(st->bgHangover, 1), 30) > 0)

  0034b	66 85 c9	 test	 cx, cx
  0034e	7e e3		 jle	 SHORT $LN17@Bgn_scd

; 213  :          st->bgHangover = 30;                         move16 ();

  00350	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH

; 214  :       } else

  00355	eb 2c		 jmp	 SHORT $LN392@Bgn_scd
$LN214@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00357	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0035c	7d 11		 jge	 SHORT $LN212@Bgn_scd

; 86   :         Overflow = 1;

  0035e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00368	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0036d	eb 14		 jmp	 SHORT $LN392@Bgn_scd
$LN212@Bgn_scd:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  0036f	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 219  :    else

  00372	eb 0f		 jmp	 SHORT $LN392@Bgn_scd
$LN393@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  00374	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN19@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 221  :       st->bgHangover = 0;                             move16 ();    

  0037e	8b 55 fc	 mov	 edx, DWORD PTR _st$1$[ebp]
  00381	33 c0		 xor	 eax, eax
$LN392@Bgn_scd:
  00383	66 89 42 78	 mov	 WORD PTR [edx+120], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00387	0f bf c0	 movsx	 eax, ax
  0038a	48		 dec	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  0038b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00390	7e 11		 jle	 SHORT $LN228@Bgn_scd

; 81   :         Overflow = 1;

  00392	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 227  :       inbgNoise = 1;       /* true  */               move16 ();  

  0039c	bb 01 00 00 00	 mov	 ebx, 1
  003a1	eb 13		 jmp	 SHORT $LN14@Bgn_scd
$LN228@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003a3	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003a8	7d 3f		 jge	 SHORT $LN226@Bgn_scd

; 86   :         Overflow = 1;

  003aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN389@Bgn_scd:
  003b4	33 db		 xor	 ebx, ebx
$LN14@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 233  :    st->frameEnergyHist[L_ENERGYHIST-1] = currEnergy;              move16 ();

  003b6	8b 45 f0	 mov	 eax, DWORD PTR _currEnergy$1$[ebp]
  003b9	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
  003bc	8b fa		 mov	 edi, edx
  003be	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  003c3	66 f3 a5	 rep movsw
  003c6	66 89 42 76	 mov	 WORD PTR [edx+118], ax

; 234  :    
; 235  :    /* prepare for voicing decision; tighten the threshold after some 
; 236  :       time in noise */
; 237  :    ltpLimit = 13926;             /* 0.85  Q14 */     move16 (); 

  003ca	b9 66 36 00 00	 mov	 ecx, 13926		; 00003666H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  003cf	0f bf 52 78	 movsx	 edx, WORD PTR [edx+120]
  003d3	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]

; 79   :     if (L_var1 > 0X00007fffL)

  003d6	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  003db	7e 18		 jle	 SHORT $LN248@Bgn_scd

; 81   :         Overflow = 1;

  003dd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  003e7	eb 24		 jmp	 SHORT $LN376@Bgn_scd
$LN226@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 226  :    if (sub(st->bgHangover,1) > 0)

  003e9	66 85 c0	 test	 ax, ax
  003ec	7e c6		 jle	 SHORT $LN389@Bgn_scd

; 227  :       inbgNoise = 1;       /* true  */               move16 ();  

  003ee	bb 01 00 00 00	 mov	 ebx, 1
  003f3	eb c1		 jmp	 SHORT $LN14@Bgn_scd
$LN248@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  003f5	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  003fa	7d 0c		 jge	 SHORT $LN246@Bgn_scd

; 86   :         Overflow = 1;

  003fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00406	eb 0a		 jmp	 SHORT $LN253@Bgn_scd
$LN246@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 239  :    if (sub(st->bgHangover, 8) > 0)

  00408	66 85 c0	 test	 ax, ax
  0040b	7e 05		 jle	 SHORT $LN253@Bgn_scd
$LN376@Bgn_scd:

; 240  :    {
; 241  :       ltpLimit = 15565;          /* 0.95  Q14 */     move16 ();

  0040d	b9 cd 3c 00 00	 mov	 ecx, 15565		; 00003ccdH
$LN253@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00412	8d 42 f1	 lea	 eax, DWORD PTR [edx-15]

; 79   :     if (L_var1 > 0X00007fffL)

  00415	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0041a	7e 0c		 jle	 SHORT $LN262@Bgn_scd

; 81   :         Overflow = 1;

  0041c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00426	eb 18		 jmp	 SHORT $LN377@Bgn_scd
$LN262@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00428	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0042d	7d 0c		 jge	 SHORT $LN260@Bgn_scd

; 86   :         Overflow = 1;

  0042f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  00439	eb 0a		 jmp	 SHORT $LN267@Bgn_scd
$LN260@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 244  :    if (sub(st->bgHangover, 15) > 0)

  0043b	66 85 c0	 test	 ax, ax
  0043e	7e 05		 jle	 SHORT $LN267@Bgn_scd
$LN377@Bgn_scd:

; 245  :    {
; 246  :       ltpLimit = 16383;          /* 1.00  Q14 */     move16 ();

  00440	b9 ff 3f 00 00	 mov	 ecx, 16383		; 00003fffH
$LN267@Bgn_scd:

; 247  :    }
; 248  : 
; 249  :    /* weak sort of voicing indication. */
; 250  :    prevVoiced = 0;        /* false */                move16 ();

  00445	33 f6		 xor	 esi, esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00447	0f bf f9	 movsx	 edi, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 253  :    if (sub(gmed_n(&ltpGainHist[4], 5), ltpLimit) > 0)

  0044a	8b 4d ec	 mov	 ecx, DWORD PTR _ltpGainHist$1$[ebp]
  0044d	83 c1 08	 add	 ecx, 8
  00450	8d 56 05	 lea	 edx, DWORD PTR [esi+5]
  00453	e8 00 00 00 00	 call	 _gmed_n
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00458	98		 cwde
  00459	2b c7		 sub	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  0045b	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00460	7e 0c		 jle	 SHORT $LN278@Bgn_scd

; 81   :         Overflow = 1;

  00462	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  0046c	eb 18		 jmp	 SHORT $LN378@Bgn_scd
$LN278@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0046e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00473	7d 0c		 jge	 SHORT $LN276@Bgn_scd

; 86   :         Overflow = 1;

  00475	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 88   :     }
; 89   :     else

  0047f	eb 0a		 jmp	 SHORT $LN283@Bgn_scd
$LN276@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 253  :    if (sub(gmed_n(&ltpGainHist[4], 5), ltpLimit) > 0)

  00481	66 85 c0	 test	 ax, ax
  00484	7e 05		 jle	 SHORT $LN283@Bgn_scd
$LN378@Bgn_scd:

; 254  :    {
; 255  :       prevVoiced = 1;     /* true  */                move16 ();

  00486	be 01 00 00 00	 mov	 esi, 1
$LN283@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  0048b	8b 45 fc	 mov	 eax, DWORD PTR _st$1$[ebp]
  0048e	0f bf 40 78	 movsx	 eax, WORD PTR [eax+120]
  00492	83 e8 14	 sub	 eax, 20			; 00000014H

; 79   :     if (L_var1 > 0X00007fffL)

  00495	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0049a	7e 0c		 jle	 SHORT $LN292@Bgn_scd

; 81   :         Overflow = 1;

  0049c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  004a6	eb 2d		 jmp	 SHORT $LN379@Bgn_scd
$LN292@Bgn_scd:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  004a8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  004ad	7d 21		 jge	 SHORT $LN290@Bgn_scd

; 86   :         Overflow = 1;

  004af	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN309@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 270  :    if (prevVoiced)

  004b9	66 85 f6	 test	 si, si
  004bc	74 5b		 je	 SHORT $LN4@Bgn_scd

; 272  :       *voicedHangover = 0;                        move16 ();

  004be	8b 4d 0c	 mov	 ecx, DWORD PTR _voicedHangover$[ebp]
  004c1	33 c0		 xor	 eax, eax
  004c3	5f		 pop	 edi
  004c4	5e		 pop	 esi
  004c5	66 89 01	 mov	 WORD PTR [ecx], ax

; 288  :    return inbgNoise;

  004c8	66 8b c3	 mov	 ax, bx
  004cb	5b		 pop	 ebx

; 289  : }

  004cc	8b e5		 mov	 esp, ebp
  004ce	5d		 pop	 ebp
  004cf	c3		 ret	 0
$LN290@Bgn_scd:

; 256  :    }
; 257  :    test ();   
; 258  :    if (sub(st->bgHangover, 20) > 0) {

  004d0	66 85 c0	 test	 ax, ax
  004d3	7e e4		 jle	 SHORT $LN309@Bgn_scd
$LN379@Bgn_scd:

; 259  :       if (sub(gmed_n(ltpGainHist, 9), ltpLimit) > 0)

  004d5	8b 4d ec	 mov	 ecx, DWORD PTR _ltpGainHist$1$[ebp]
  004d8	ba 09 00 00 00	 mov	 edx, 9
  004dd	e8 00 00 00 00	 call	 _gmed_n
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  004e2	98		 cwde
  004e3	2b c7		 sub	 eax, edi

; 79   :     if (L_var1 > 0X00007fffL)

  004e5	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  004ea	7e 1c		 jle	 SHORT $LN302@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 272  :       *voicedHangover = 0;                        move16 ();

  004ec	8b 4d 0c	 mov	 ecx, DWORD PTR _voicedHangover$[ebp]
  004ef	33 c0		 xor	 eax, eax
  004f1	5f		 pop	 edi
  004f2	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  004f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 272  :       *voicedHangover = 0;                        move16 ();

  004fd	66 89 01	 mov	 WORD PTR [ecx], ax

; 288  :    return inbgNoise;

  00500	66 8b c3	 mov	 ax, bx
  00503	5b		 pop	 ebx

; 289  : }

  00504	8b e5		 mov	 esp, ebp
  00506	5d		 pop	 ebp
  00507	c3		 ret	 0
$LN302@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00508	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  0050d	7d 29		 jge	 SHORT $LN300@Bgn_scd

; 86   :         Overflow = 1;

  0050f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN4@Bgn_scd:

; 139  :     L_sum = (Word32) var1 + var2;

  00519	8b 55 0c	 mov	 edx, DWORD PTR _voicedHangover$[ebp]
  0051c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0051f	40		 inc	 eax

; 79   :     if (L_var1 > 0X00007fffL)

  00520	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00525	7e 28		 jle	 SHORT $LN320@Bgn_scd

; 81   :         Overflow = 1;

  00527	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00531	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00536	eb 32		 jmp	 SHORT $LN317@Bgn_scd
$LN300@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 259  :       if (sub(gmed_n(ltpGainHist, 9), ltpLimit) > 0)

  00538	66 85 c0	 test	 ax, ax
  0053b	7e dc		 jle	 SHORT $LN4@Bgn_scd

; 272  :       *voicedHangover = 0;                        move16 ();

  0053d	8b 4d 0c	 mov	 ecx, DWORD PTR _voicedHangover$[ebp]
  00540	33 c0		 xor	 eax, eax
  00542	5f		 pop	 edi
  00543	5e		 pop	 esi
  00544	66 89 01	 mov	 WORD PTR [ecx], ax

; 288  :    return inbgNoise;

  00547	66 8b c3	 mov	 ax, bx
  0054a	5b		 pop	 ebx

; 289  : }

  0054b	8b e5		 mov	 esp, ebp
  0054d	5d		 pop	 ebp
  0054e	c3		 ret	 0
$LN320@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0054f	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00554	7d 11		 jge	 SHORT $LN318@Bgn_scd

; 86   :         Overflow = 1;

  00556	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  00560	b9 00 80 ff ff	 mov	 ecx, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00565	eb 03		 jmp	 SHORT $LN317@Bgn_scd
$LN318@Bgn_scd:

; 90   :     {
; 91   :         var_out = extract_l (L_var1);

  00567	0f b7 c8	 movzx	 ecx, ax
$LN317@Bgn_scd:

; 186  :     L_diff = (Word32) var1 - var2;

  0056a	0f bf c1	 movsx	 eax, cx
  0056d	83 e8 0a	 sub	 eax, 10			; 0000000aH

; 79   :     if (L_var1 > 0X00007fffL)

  00570	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00575	7e 1c		 jle	 SHORT $LN332@Bgn_scd
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 280  :          *voicedHangover = 10;                    move16 ();

  00577	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 81   :         Overflow = 1;

  0057c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00586	5f		 pop	 edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 280  :          *voicedHangover = 10;                    move16 ();

  00587	66 89 02	 mov	 WORD PTR [edx], ax

; 288  :    return inbgNoise;

  0058a	66 8b c3	 mov	 ax, bx
  0058d	5e		 pop	 esi
  0058e	5b		 pop	 ebx

; 289  : }

  0058f	8b e5		 mov	 esp, ebp
  00591	5d		 pop	 ebp
  00592	c3		 ret	 0
$LN332@Bgn_scd:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00593	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00598	7d 17		 jge	 SHORT $LN330@Bgn_scd

; 86   :         Overflow = 1;

  0059a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2@Bgn_scd:
  005a4	5f		 pop	 edi
  005a5	5e		 pop	 esi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 288  :    return inbgNoise;

  005a6	66 8b c3	 mov	 ax, bx
  005a9	66 89 0a	 mov	 WORD PTR [edx], cx
  005ac	5b		 pop	 ebx

; 289  : }

  005ad	8b e5		 mov	 esp, ebp
  005af	5d		 pop	 ebp
  005b0	c3		 ret	 0
$LN330@Bgn_scd:

; 273  :    }
; 274  :    else
; 275  :    {
; 276  :       temp = add(*voicedHangover, 1);
; 277  :       test ();
; 278  :       if (sub(temp, 10) > 0)

  005b1	66 85 c0	 test	 ax, ax
  005b4	7e ee		 jle	 SHORT $LN2@Bgn_scd

; 280  :          *voicedHangover = 10;                    move16 ();

  005b6	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  005bb	5f		 pop	 edi
  005bc	66 89 02	 mov	 WORD PTR [edx], ax

; 288  :    return inbgNoise;

  005bf	66 8b c3	 mov	 ax, bx
  005c2	5e		 pop	 esi
  005c3	5b		 pop	 ebx

; 289  : }

  005c4	8b e5		 mov	 esp, ebp
  005c6	5d		 pop	 ebp
  005c7	c3		 ret	 0
_Bgn_scd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
;	COMDAT _Bgn_scd_init
_TEXT	SEGMENT
_Bgn_scd_init PROC					; COMDAT
; _state$ = ecx

; 60   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 61   :    Bgn_scdState* s;
; 62   :    
; 63   :    if (state == (Bgn_scdState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@Bgn_scd_in

; 64   :       fprintf(stderr, "Bgn_scd_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NBHDLMJL@Bgn_scd_init?3?5invalid?5parameter?6@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 65   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 79   : }

  00023	c3		 ret	 0
$LN2@Bgn_scd_in:
  00024	57		 push	 edi

; 66   :    }
; 67   :    *state = NULL;
; 68   :    
; 69   :    /* allocate memory */
; 70   :    if ((s= (Bgn_scdState *) malloc(sizeof(Bgn_scdState))) == NULL){

  00025	6a 7a		 push	 122			; 0000007aH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	75 1e		 jne	 SHORT $LN1@Bgn_scd_in

; 71   :      fprintf(stderr, "Bgn_scd_init: can not malloc state structure\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JFIOBCBL@Bgn_scd_init?3?5can?5not?5malloc?5sta@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00047	83 c0 40	 add	 eax, 64			; 00000040H
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00051	83 c4 08	 add	 esp, 8

; 72   :      return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 79   : }

  00059	c3		 ret	 0
$LN1@Bgn_scd_in:

; 73   :    }
; 74   :    
; 75   :    Bgn_scd_reset(s);

  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _Bgn_scd_reset

; 76   :    *state = s;

  00061	89 3e		 mov	 DWORD PTR [esi], edi

; 77   :    
; 78   :    return 0;

  00063	33 c0		 xor	 eax, eax
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 79   : }

  00067	c3		 ret	 0
_Bgn_scd_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
;	COMDAT _Bgn_scd_reset
_TEXT	SEGMENT
_Bgn_scd_reset PROC					; COMDAT
; _state$ = ecx

; 91   :    if (state == (Bgn_scdState *) NULL){

  00000	85 c9		 test	 ecx, ecx
  00002	75 1c		 jne	 SHORT $LN1@Bgn_scd_re

; 92   :       fprintf(stderr, "Bgn_scd_reset: invalid parameter\n");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PJKCAIBL@Bgn_scd_reset?3?5invalid?5parameter@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00019	83 c4 08	 add	 esp, 8

; 93   :       return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 101  :    
; 102  :    return 0;
; 103  : }

  0001f	c3		 ret	 0
$LN1@Bgn_scd_re:
  00020	0f 57 c0	 xorps	 xmm0, xmm0

; 100  :    state->bgHangover = 0;

  00023	33 c0		 xor	 eax, eax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\set_zero.c

; 44   :         x[i] = 0;               move16 (); 

  00025	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00029	f3 0f 7f 41 10	 movdqu	 XMMWORD PTR [ecx+16], xmm0
  0002e	f3 0f 7f 41 20	 movdqu	 XMMWORD PTR [ecx+32], xmm0
  00033	f3 0f 7f 41 30	 movdqu	 XMMWORD PTR [ecx+48], xmm0
  00038	f3 0f 7f 41 40	 movdqu	 XMMWORD PTR [ecx+64], xmm0
  0003d	f3 0f 7f 41 50	 movdqu	 XMMWORD PTR [ecx+80], xmm0
  00042	f3 0f 7f 41 60	 movdqu	 XMMWORD PTR [ecx+96], xmm0
  00047	66 0f d6 41 70	 movq	 QWORD PTR [ecx+112], xmm0
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c

; 100  :    state->bgHangover = 0;

  0004c	66 89 41 78	 mov	 WORD PTR [ecx+120], ax

; 101  :    
; 102  :    return 0;
; 103  : }

  00050	c3		 ret	 0
_Bgn_scd_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\bgnscd.c
;	COMDAT _Bgn_scd_exit
_TEXT	SEGMENT
_Bgn_scd_exit PROC					; COMDAT
; _state$ = ecx

; 114  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 115  :    if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@Bgn_scd_ex
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@Bgn_scd_ex

; 116  :       return;
; 117  : 
; 118  :    /* deallocate memory */
; 119  :    free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 120  :    *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Bgn_scd_ex:
  0001d	5e		 pop	 esi

; 121  :    
; 122  :    return;
; 123  : }

  0001e	c3		 ret	 0
_Bgn_scd_exit ENDP
_TEXT	ENDS
END
