; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\lsp_az.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Lsp_Az
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
;	COMDAT _Lsp_Az
_TEXT	SEGMENT
_a$GSCopy$1$ = -64					; size = 4
tv788 = -60						; size = 4
tv784 = -56						; size = 4
_f1$ = -52						; size = 24
_f2$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_Lsp_Az	PROC						; COMDAT
; _lsp$ = ecx
; _a$ = edx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	89 55 c0	 mov	 DWORD PTR _a$GSCopy$1$[ebp], edx
  00015	8b f1		 mov	 esi, ecx
  00017	57		 push	 edi

; 136  :     Word16 i, j;
; 137  :     Word32 f1[6], f2[6];
; 138  :     Word32 t0;
; 139  : 
; 140  :     Get_lsp_pol (&lsp[0], f1);

  00018	8d 55 cc	 lea	 edx, DWORD PTR _f1$[ebp]
  0001b	e8 00 00 00 00	 call	 _Get_lsp_pol

; 141  :     Get_lsp_pol (&lsp[1], f2);

  00020	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  00023	8d 55 e4	 lea	 edx, DWORD PTR _f2$[ebp]
  00026	e8 00 00 00 00	 call	 _Get_lsp_pol

; 142  : 
; 143  :     for (i = 5; i > 0; i--)

  0002b	bb 05 00 00 00	 mov	 ebx, 5
  00030	33 f6		 xor	 esi, esi
$LL6@Lsp_Az:

; 144  :     {
; 145  :         f1[i] = L_add (f1[i], f1[i - 1]);    move32 (); /* f1[i] += f1[i-1]; */

  00032	8b 4c 35 dc	 mov	 ecx, DWORD PTR _f1$[ebp+esi+16]
  00036	8b 7c 35 e0	 mov	 edi, DWORD PTR _f1$[ebp+esi+20]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  0003a	8b c7		 mov	 eax, edi
  0003c	33 c1		 xor	 eax, ecx
  0003e	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  00041	78 1d		 js	 SHORT $LN9@Lsp_Az

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00043	8b c2		 mov	 eax, edx
  00045	33 c7		 xor	 eax, edi
  00047	79 17		 jns	 SHORT $LN9@Lsp_Az

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00049	33 d2		 xor	 edx, edx

; 938  :             Overflow = 1;

  0004b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00055	85 ff		 test	 edi, edi
  00057	0f 98 c2	 sets	 dl
  0005a	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN9@Lsp_Az:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 146  :         f2[i] = L_sub (f2[i], f2[i - 1]);    move32 (); /* f2[i] -= f2[i-1]; */

  00060	8b 7c 35 f8	 mov	 edi, DWORD PTR _f2$[ebp+esi+20]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00064	8b c7		 mov	 eax, edi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 146  :         f2[i] = L_sub (f2[i], f2[i - 1]);    move32 (); /* f2[i] -= f2[i-1]; */

  00066	8b 4c 35 f4	 mov	 ecx, DWORD PTR _f2$[ebp+esi+16]
  0006a	89 54 35 e0	 mov	 DWORD PTR _f1$[ebp+esi+20], edx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 983  :     L_var_out = L_var1 - L_var2;

  0006e	8b d7		 mov	 edx, edi
  00070	2b d1		 sub	 edx, ecx

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00072	33 c1		 xor	 eax, ecx
  00074	79 1d		 jns	 SHORT $LN15@Lsp_Az

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00076	8b c2		 mov	 eax, edx
  00078	33 c7		 xor	 eax, edi
  0007a	79 17		 jns	 SHORT $LN15@Lsp_Az

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0007c	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  0007e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00088	85 ff		 test	 edi, edi
  0008a	0f 98 c2	 sets	 dl
  0008d	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN15@Lsp_Az:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 146  :         f2[i] = L_sub (f2[i], f2[i - 1]);    move32 (); /* f2[i] -= f2[i-1]; */

  00093	89 54 35 f8	 mov	 DWORD PTR _f2$[ebp+esi+20], edx
  00097	4b		 dec	 ebx
  00098	83 ee 04	 sub	 esi, 4
  0009b	66 85 db	 test	 bx, bx
  0009e	7f 92		 jg	 SHORT $LL6@Lsp_Az

; 147  :     }
; 148  : 
; 149  :     a[0] = 4096;                             move16 (); 

  000a0	8b 45 c0	 mov	 eax, DWORD PTR _a$GSCopy$1$[ebp]
  000a3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H

; 150  :     for (i = 1, j = 10; i <= 5; i++, j--)

  000a8	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  000ad	c7 45 c4 05 00
	00 00		 mov	 DWORD PTR tv788[ebp], 5
  000b4	66 89 08	 mov	 WORD PTR [eax], cx
  000b7	83 c0 02	 add	 eax, 2
  000ba	89 45 c8	 mov	 DWORD PTR tv784[ebp], eax
  000bd	33 ff		 xor	 edi, edi
  000bf	90		 npad	 1
$LL3@Lsp_Az:

; 151  :     {
; 152  :         t0 = L_add (f1[i], f2[i]);           /* f1[i] + f2[i] */

  000c0	8b 74 3d e8	 mov	 esi, DWORD PTR _f2$[ebp+edi+4]
  000c4	8b 54 3d d0	 mov	 edx, DWORD PTR _f1$[ebp+edi+4]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  000c8	8b c2		 mov	 eax, edx
  000ca	33 c6		 xor	 eax, esi
  000cc	8d 0c 32	 lea	 ecx, DWORD PTR [edx+esi]
  000cf	78 1d		 js	 SHORT $LN23@Lsp_Az

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  000d1	8b c1		 mov	 eax, ecx
  000d3	33 c2		 xor	 eax, edx
  000d5	79 17		 jns	 SHORT $LN23@Lsp_Az

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  000d7	33 c9		 xor	 ecx, ecx

; 938  :             Overflow = 1;

  000d9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000e3	85 d2		 test	 edx, edx
  000e5	0f 98 c1	 sets	 cl
  000e8	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN23@Lsp_Az:

; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  000ee	8b c1		 mov	 eax, ecx
  000f0	85 c9		 test	 ecx, ecx
  000f2	79 09		 jns	 SHORT $LN34@Lsp_Az
  000f4	f7 d0		 not	 eax
  000f6	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  000f9	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  000fb	eb 03		 jmp	 SHORT $LN33@Lsp_Az
$LN34@Lsp_Az:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  000fd	c1 f8 0d	 sar	 eax, 13			; 0000000dH
$LN33@Lsp_Az:

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);
; 1451 : }
; 1452 : 
; 1453 : /*___________________________________________________________________________
; 1454 :  |                                                                           |
; 1455 :  |   Function Name : shr_r                                                   |
; 1456 :  |                                                                           |
; 1457 :  |   Purpose :                                                               |
; 1458 :  |                                                                           |
; 1459 :  |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
; 1460 :  |   underflows or overflows :                                               |
; 1461 :  |    - If var2 is greater than zero :                                       |
; 1462 :  |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
; 1463 :  |          is equal to zero                                                 |
; 1464 :  |                     then                                                  |
; 1465 :  |                     shr_r(var1,var2) = shr(var1,var2)                     |
; 1466 :  |                     else                                                  |
; 1467 :  |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
; 1468 :  |    - If var2 is less than or equal to zero :                              |
; 1469 :  |                     shr_r(var1,var2) = shr(var1,var2).                    |
; 1470 :  |                                                                           |
; 1471 :  |   Complexity weight : 2                                                   |
; 1472 :  |                                                                           |
; 1473 :  |   Inputs :                                                                |
; 1474 :  |                                                                           |
; 1475 :  |    var1                                                                   |
; 1476 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1477 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1478 :  |                                                                           |
; 1479 :  |    var2                                                                   |
; 1480 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1481 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1482 :  |                                                                           |
; 1483 :  |   Outputs :                                                               |
; 1484 :  |                                                                           |
; 1485 :  |    none                                                                   |
; 1486 :  |                                                                           |
; 1487 :  |   Return Value :                                                          |
; 1488 :  |                                                                           |
; 1489 :  |    var_out                                                                |
; 1490 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1491 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1492 :  |___________________________________________________________________________|
; 1493 : */
; 1494 : 
; 1495 : Word16 shr_r (Word16 var1, Word16 var2)
; 1496 : {
; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);
; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
; 1513 :             {
; 1514 :                 var_out++;
; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }
; 1523 : 
; 1524 : /*___________________________________________________________________________
; 1525 :  |                                                                           |
; 1526 :  |   Function Name : mac_r                                                   |
; 1527 :  |                                                                           |
; 1528 :  |   Purpose :                                                               |
; 1529 :  |                                                                           |
; 1530 :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 1531 :  |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
; 1532 :  |   into the MS 16 bits with saturation and shift the result right by 16.   |
; 1533 :  |   Return a 16 bit result.                                                 |
; 1534 :  |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
; 1535 :  |                                                                           |
; 1536 :  |   Complexity weight : 2                                                   |
; 1537 :  |                                                                           |
; 1538 :  |   Inputs :                                                                |
; 1539 :  |                                                                           |
; 1540 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1541 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1542 :  |                                                                           |
; 1543 :  |    var1                                                                   |
; 1544 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1545 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1546 :  |                                                                           |
; 1547 :  |    var2                                                                   |
; 1548 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1549 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1550 :  |                                                                           |
; 1551 :  |   Outputs :                                                               |
; 1552 :  |                                                                           |
; 1553 :  |    none                                                                   |
; 1554 :  |                                                                           |
; 1555 :  |   Return Value :                                                          |
; 1556 :  |                                                                           |
; 1557 :  |    var_out                                                                |
; 1558 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1559 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1560 :  |___________________________________________________________________________|
; 1561 : */
; 1562 : 
; 1563 : Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1564 : {
; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);
; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);
; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);
; 1581 : }
; 1582 : 
; 1583 : /*___________________________________________________________________________
; 1584 :  |                                                                           |
; 1585 :  |   Function Name : msu_r                                                   |
; 1586 :  |                                                                           |
; 1587 :  |   Purpose :                                                               |
; 1588 :  |                                                                           |
; 1589 :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 1590 :  |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
; 1591 :  |   ult into the MS 16 bits with saturation and shift the result right by   |
; 1592 :  |   16. Return a 16 bit result.                                             |
; 1593 :  |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
; 1594 :  |                                                                           |
; 1595 :  |   Complexity weight : 2                                                   |
; 1596 :  |                                                                           |
; 1597 :  |   Inputs :                                                                |
; 1598 :  |                                                                           |
; 1599 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1600 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1601 :  |                                                                           |
; 1602 :  |    var1                                                                   |
; 1603 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1604 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1605 :  |                                                                           |
; 1606 :  |    var2                                                                   |
; 1607 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1608 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1609 :  |                                                                           |
; 1610 :  |   Outputs :                                                               |
; 1611 :  |                                                                           |
; 1612 :  |    none                                                                   |
; 1613 :  |                                                                           |
; 1614 :  |   Return Value :                                                          |
; 1615 :  |                                                                           |
; 1616 :  |    var_out                                                                |
; 1617 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1618 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1619 :  |___________________________________________________________________________|
; 1620 : */
; 1621 : 
; 1622 : Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1623 : {
; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);
; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);
; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);
; 1640 : }
; 1641 : 
; 1642 : /*___________________________________________________________________________
; 1643 :  |                                                                           |
; 1644 :  |   Function Name : L_deposit_h                                             |
; 1645 :  |                                                                           |
; 1646 :  |   Purpose :                                                               |
; 1647 :  |                                                                           |
; 1648 :  |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
; 1649 :  |   16 LS bits of the output are zeroed.                                    |
; 1650 :  |                                                                           |
; 1651 :  |   Complexity weight : 2                                                   |
; 1652 :  |                                                                           |
; 1653 :  |   Inputs :                                                                |
; 1654 :  |                                                                           |
; 1655 :  |    var1                                                                   |
; 1656 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1657 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1658 :  |                                                                           |
; 1659 :  |   Outputs :                                                               |
; 1660 :  |                                                                           |
; 1661 :  |    none                                                                   |
; 1662 :  |                                                                           |
; 1663 :  |   Return Value :                                                          |
; 1664 :  |                                                                           |
; 1665 :  |    L_var_out                                                              |
; 1666 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1667 :  |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
; 1668 :  |___________________________________________________________________________|
; 1669 : */
; 1670 : 
; 1671 : Word32 L_deposit_h (Word16 var1)
; 1672 : {
; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;
; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);
; 1680 : }
; 1681 : 
; 1682 : /*___________________________________________________________________________
; 1683 :  |                                                                           |
; 1684 :  |   Function Name : L_deposit_l                                             |
; 1685 :  |                                                                           |
; 1686 :  |   Purpose :                                                               |
; 1687 :  |                                                                           |
; 1688 :  |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
; 1689 :  |   16 MS bits of the output are sign extended.                             |
; 1690 :  |                                                                           |
; 1691 :  |   Complexity weight : 2                                                   |
; 1692 :  |                                                                           |
; 1693 :  |   Inputs :                                                                |
; 1694 :  |                                                                           |
; 1695 :  |    var1                                                                   |
; 1696 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1697 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1698 :  |                                                                           |
; 1699 :  |   Outputs :                                                               |
; 1700 :  |                                                                           |
; 1701 :  |    none                                                                   |
; 1702 :  |                                                                           |
; 1703 :  |   Return Value :                                                          |
; 1704 :  |                                                                           |
; 1705 :  |    L_var_out                                                              |
; 1706 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1707 :  |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
; 1708 :  |___________________________________________________________________________|
; 1709 : */
; 1710 : 
; 1711 : Word32 L_deposit_l (Word16 var1)
; 1712 : {
; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;
; 1716 : #if (WMOPS)
; 1717 :     multiCounter[currCounter].L_deposit_l++;
; 1718 : #endif
; 1719 :     return (L_var_out);
; 1720 : }
; 1721 : 
; 1722 : /*___________________________________________________________________________
; 1723 :  |                                                                           |
; 1724 :  |   Function Name : L_shr_r                                                 |
; 1725 :  |                                                                           |
; 1726 :  |   Purpose :                                                               |
; 1727 :  |                                                                           |
; 1728 :  |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
; 1729 :  |   case of underflows or overflows :                                       |
; 1730 :  |    - If var2 is greater than zero :                                       |
; 1731 :  |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
; 1732 :  |          is equal to zero                                                 |
; 1733 :  |                     then                                                  |
; 1734 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
; 1735 :  |                     else                                                  |
; 1736 :  |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
; 1737 :  |    - If var2 is less than or equal to zero :                              |
; 1738 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
; 1739 :  |                                                                           |
; 1740 :  |   Complexity weight : 3                                                   |
; 1741 :  |                                                                           |
; 1742 :  |   Inputs :                                                                |
; 1743 :  |                                                                           |
; 1744 :  |    L_var1                                                                 |
; 1745 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1746 :  |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
; 1747 :  |                                                                           |
; 1748 :  |    var2                                                                   |
; 1749 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1750 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1751 :  |                                                                           |
; 1752 :  |   Outputs :                                                               |
; 1753 :  |                                                                           |
; 1754 :  |    none                                                                   |
; 1755 :  |                                                                           |
; 1756 :  |   Return Value :                                                          |
; 1757 :  |                                                                           |
; 1758 :  |    L_var_out                                                              |
; 1759 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1760 :  |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
; 1761 :  |___________________________________________________________________________|
; 1762 : */
; 1763 : 
; 1764 : Word32 L_shr_r (Word32 L_var1, Word16 var2)
; 1765 : {
; 1766 :     Word32 L_var_out;
; 1767 : 
; 1768 :     if (var2 > 31)
; 1769 :     {
; 1770 :         L_var_out = 0;
; 1771 :     }
; 1772 :     else
; 1773 :     {
; 1774 :         L_var_out = L_shr (L_var1, var2);
; 1775 : #if (WMOPS)
; 1776 :         multiCounter[currCounter].L_shr--;
; 1777 : #endif
; 1778 :         if (var2 > 0)
; 1779 :         {
; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  00100	f7 c1 00 10 00
	00		 test	 ecx, 4096		; 00001000H
  00106	74 01		 je	 SHORT $LN27@Lsp_Az

; 1781 :             {
; 1782 :                 L_var_out++;

  00108	40		 inc	 eax
$LN27@Lsp_Az:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 153  :         a[i] = extract_l (L_shr_r (t0, 13)); move16 (); 

  00109	8b 4d c8	 mov	 ecx, DWORD PTR tv784[ebp]
  0010c	66 89 01	 mov	 WORD PTR [ecx], ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 983  :     L_var_out = L_var1 - L_var2;

  0010f	8b ca		 mov	 ecx, edx
  00111	2b ce		 sub	 ecx, esi

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00113	33 f2		 xor	 esi, edx
  00115	79 1d		 jns	 SHORT $LN57@Lsp_Az

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00117	8b c1		 mov	 eax, ecx
  00119	33 c2		 xor	 eax, edx
  0011b	79 17		 jns	 SHORT $LN57@Lsp_Az

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0011d	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  0011f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00129	85 d2		 test	 edx, edx
  0012b	0f 98 c1	 sets	 cl
  0012e	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN57@Lsp_Az:

; 991  :         }
; 992  :     }
; 993  : #if (WMOPS)
; 994  :     multiCounter[currCounter].L_sub++;
; 995  : #endif
; 996  :     return (L_var_out);
; 997  : }
; 998  : 
; 999  : /*___________________________________________________________________________
; 1000 :  |                                                                           |
; 1001 :  |   Function Name : L_add_c                                                 |
; 1002 :  |                                                                           |
; 1003 :  |   Purpose :                                                               |
; 1004 :  |                                                                           |
; 1005 :  |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
; 1006 :  |   with carry. No saturation. Generate carry and Overflow values. The car- |
; 1007 :  |   ry and overflow values are binary variables which can be tested and as- |
; 1008 :  |   signed values.                                                          |
; 1009 :  |                                                                           |
; 1010 :  |   Complexity weight : 2                                                   |
; 1011 :  |                                                                           |
; 1012 :  |   Inputs :                                                                |
; 1013 :  |                                                                           |
; 1014 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1015 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1016 :  |                                                                           |
; 1017 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1018 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1019 :  |                                                                           |
; 1020 :  |   Outputs :                                                               |
; 1021 :  |                                                                           |
; 1022 :  |    none                                                                   |
; 1023 :  |                                                                           |
; 1024 :  |   Return Value :                                                          |
; 1025 :  |                                                                           |
; 1026 :  |    L_var_out                                                              |
; 1027 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1028 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1029 :  |                                                                           |
; 1030 :  |   Caution :                                                               |
; 1031 :  |                                                                           |
; 1032 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1033 :  |    operators which take into account its value.                           |
; 1034 :  |___________________________________________________________________________|
; 1035 : */
; 1036 : Word32 L_add_c (Word32 L_var1, Word32 L_var2)
; 1037 : {
; 1038 :     Word32 L_var_out;
; 1039 :     Word32 L_test;
; 1040 :     Flag carry_int = 0;
; 1041 : 
; 1042 :     L_var_out = L_var1 + L_var2 + Carry;
; 1043 : 
; 1044 :     L_test = L_var1 + L_var2;
; 1045 : 
; 1046 :     if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
; 1047 :     {
; 1048 :         Overflow = 1;
; 1049 :         carry_int = 0;
; 1050 :     }
; 1051 :     else
; 1052 :     {
; 1053 :         if ((L_var1 < 0) && (L_var2 < 0))
; 1054 :         {
; 1055 :             if (L_test >= 0)
; 1056 : 	    {
; 1057 :                 Overflow = 1;
; 1058 :                 carry_int = 1;
; 1059 : 	    }
; 1060 :             else
; 1061 : 	    {
; 1062 :                 Overflow = 0;
; 1063 :                 carry_int = 1;
; 1064 : 	    }
; 1065 :         }
; 1066 :         else
; 1067 :         {
; 1068 :             if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
; 1069 :             {
; 1070 :                 Overflow = 0;
; 1071 :                 carry_int = 1;
; 1072 :             }
; 1073 :             else
; 1074 :             {
; 1075 :                 Overflow = 0;
; 1076 :                 carry_int = 0;
; 1077 :             }
; 1078 :         }
; 1079 :     }
; 1080 : 
; 1081 :     if (Carry)
; 1082 :     {
; 1083 :         if (L_test == MAX_32)
; 1084 :         {
; 1085 :             Overflow = 1;
; 1086 :             Carry = carry_int;
; 1087 :         }
; 1088 :         else
; 1089 :         {
; 1090 :             if (L_test == (Word32) 0xFFFFFFFFL)
; 1091 :             {
; 1092 :                 Carry = 1;
; 1093 :             }
; 1094 :             else
; 1095 :             {
; 1096 :                 Carry = carry_int;
; 1097 :             }
; 1098 :         }
; 1099 :     }
; 1100 :     else
; 1101 :     {
; 1102 :         Carry = carry_int;
; 1103 :     }
; 1104 : 
; 1105 : #if (WMOPS)
; 1106 :     multiCounter[currCounter].L_add_c++;
; 1107 : #endif
; 1108 :     return (L_var_out);
; 1109 : }
; 1110 : 
; 1111 : /*___________________________________________________________________________
; 1112 :  |                                                                           |
; 1113 :  |   Function Name : L_sub_c                                                 |
; 1114 :  |                                                                           |
; 1115 :  |   Purpose :                                                               |
; 1116 :  |                                                                           |
; 1117 :  |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
; 1118 :  |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
; 1119 :  |   values. The carry and overflow values are binary variables which can    |
; 1120 :  |   be tested and assigned values.                                          |
; 1121 :  |                                                                           |
; 1122 :  |   Complexity weight : 2                                                   |
; 1123 :  |                                                                           |
; 1124 :  |   Inputs :                                                                |
; 1125 :  |                                                                           |
; 1126 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1127 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1128 :  |                                                                           |
; 1129 :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 1130 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1131 :  |                                                                           |
; 1132 :  |   Outputs :                                                               |
; 1133 :  |                                                                           |
; 1134 :  |    none                                                                   |
; 1135 :  |                                                                           |
; 1136 :  |   Return Value :                                                          |
; 1137 :  |                                                                           |
; 1138 :  |    L_var_out                                                              |
; 1139 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1140 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1141 :  |                                                                           |
; 1142 :  |   Caution :                                                               |
; 1143 :  |                                                                           |
; 1144 :  |    In some cases the Carry flag has to be cleared or set before using     |
; 1145 :  |    operators which take into account its value.                           |
; 1146 :  |___________________________________________________________________________|
; 1147 : */
; 1148 : 
; 1149 : Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
; 1150 : {
; 1151 :     Word32 L_var_out;
; 1152 :     Word32 L_test;
; 1153 :     Flag carry_int = 0;
; 1154 : 
; 1155 :     if (Carry)
; 1156 :     {
; 1157 :         Carry = 0;
; 1158 :         if (L_var2 != MIN_32)
; 1159 :         {
; 1160 :             L_var_out = L_add_c (L_var1, -L_var2);
; 1161 : #if (WMOPS)
; 1162 :             multiCounter[currCounter].L_add_c--;
; 1163 : #endif
; 1164 :         }
; 1165 :         else
; 1166 :         {
; 1167 :             L_var_out = L_var1 - L_var2;
; 1168 :             if (L_var1 > 0L)
; 1169 :             {
; 1170 :                 Overflow = 1;
; 1171 :                 Carry = 0;
; 1172 :             }
; 1173 :         }
; 1174 :     }
; 1175 :     else
; 1176 :     {
; 1177 :         L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
; 1178 :         L_test = L_var1 - L_var2;
; 1179 : 
; 1180 :         if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
; 1181 :         {
; 1182 :             Overflow = 1;
; 1183 :             carry_int = 0;
; 1184 :         }
; 1185 :         else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
; 1186 :         {
; 1187 :             Overflow = 1;
; 1188 :             carry_int = 1;
; 1189 :         }
; 1190 :         else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
; 1191 :         {
; 1192 :             Overflow = 0;
; 1193 :             carry_int = 1;
; 1194 :         }
; 1195 :         if (L_test == MIN_32)
; 1196 :         {
; 1197 :             Overflow = 1;
; 1198 :             Carry = carry_int;
; 1199 :         }
; 1200 :         else
; 1201 :         {
; 1202 :             Carry = carry_int;
; 1203 :         }
; 1204 :     }
; 1205 : 
; 1206 : #if (WMOPS)
; 1207 :     multiCounter[currCounter].L_sub_c++;
; 1208 : #endif
; 1209 :     return (L_var_out);
; 1210 : }
; 1211 : 
; 1212 : /*___________________________________________________________________________
; 1213 :  |                                                                           |
; 1214 :  |   Function Name : L_negate                                                |
; 1215 :  |                                                                           |
; 1216 :  |   Purpose :                                                               |
; 1217 :  |                                                                           |
; 1218 :  |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
; 1219 :  |   where input is -2147483648 (0x8000 0000).                               |
; 1220 :  |                                                                           |
; 1221 :  |   Complexity weight : 2                                                   |
; 1222 :  |                                                                           |
; 1223 :  |   Inputs :                                                                |
; 1224 :  |                                                                           |
; 1225 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1226 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1227 :  |                                                                           |
; 1228 :  |   Outputs :                                                               |
; 1229 :  |                                                                           |
; 1230 :  |    none                                                                   |
; 1231 :  |                                                                           |
; 1232 :  |   Return Value :                                                          |
; 1233 :  |                                                                           |
; 1234 :  |    L_var_out                                                              |
; 1235 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1236 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1237 :  |___________________________________________________________________________|
; 1238 : */
; 1239 : 
; 1240 : Word32 L_negate (Word32 L_var1)
; 1241 : {
; 1242 :     Word32 L_var_out;
; 1243 : 
; 1244 :     L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
; 1245 : #if (WMOPS)
; 1246 :     multiCounter[currCounter].L_negate++;
; 1247 : #endif
; 1248 :     return (L_var_out);
; 1249 : }
; 1250 : 
; 1251 : /*___________________________________________________________________________
; 1252 :  |                                                                           |
; 1253 :  |   Function Name : mult_r                                                  |
; 1254 :  |                                                                           |
; 1255 :  |   Purpose :                                                               |
; 1256 :  |                                                                           |
; 1257 :  |   Same as mult with rounding, i.e.:                                       |
; 1258 :  |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
; 1259 :  |     mult_r(-32768,-32768) = 32767.                                        |
; 1260 :  |                                                                           |
; 1261 :  |   Complexity weight : 2                                                   |
; 1262 :  |                                                                           |
; 1263 :  |   Inputs :                                                                |
; 1264 :  |                                                                           |
; 1265 :  |    var1                                                                   |
; 1266 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1267 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1268 :  |                                                                           |
; 1269 :  |    var2                                                                   |
; 1270 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1271 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1272 :  |                                                                           |
; 1273 :  |   Outputs :                                                               |
; 1274 :  |                                                                           |
; 1275 :  |    none                                                                   |
; 1276 :  |                                                                           |
; 1277 :  |   Return Value :                                                          |
; 1278 :  |                                                                           |
; 1279 :  |    var_out                                                                |
; 1280 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1281 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1282 :  |___________________________________________________________________________|
; 1283 : */
; 1284 : 
; 1285 : Word16 mult_r (Word16 var1, Word16 var2)
; 1286 : {
; 1287 :     Word16 var_out;
; 1288 :     Word32 L_product_arr;
; 1289 : 
; 1290 :     L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
; 1291 :     L_product_arr += (Word32) 0x00004000L;      /* round */
; 1292 :     L_product_arr &= (Word32) 0xffff8000L;
; 1293 :     L_product_arr >>= 15;       /* shift */
; 1294 : 
; 1295 :     if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
; 1296 :     {
; 1297 :         L_product_arr |= (Word32) 0xffff0000L;
; 1298 :     }
; 1299 :     var_out = saturate (L_product_arr);
; 1300 : #if (WMOPS)
; 1301 :     multiCounter[currCounter].mult_r++;
; 1302 : #endif
; 1303 :     return (var_out);
; 1304 : }
; 1305 : 
; 1306 : /*___________________________________________________________________________
; 1307 :  |                                                                           |
; 1308 :  |   Function Name : L_shl                                                   |
; 1309 :  |                                                                           |
; 1310 :  |   Purpose :                                                               |
; 1311 :  |                                                                           |
; 1312 :  |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
; 1313 :  |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
; 1314 :  |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
; 1315 :  |   case of underflows or overflows.                                        |
; 1316 :  |                                                                           |
; 1317 :  |   Complexity weight : 2                                                   |
; 1318 :  |                                                                           |
; 1319 :  |   Inputs :                                                                |
; 1320 :  |                                                                           |
; 1321 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1322 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1323 :  |                                                                           |
; 1324 :  |    var2                                                                   |
; 1325 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1326 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1327 :  |                                                                           |
; 1328 :  |   Outputs :                                                               |
; 1329 :  |                                                                           |
; 1330 :  |    none                                                                   |
; 1331 :  |                                                                           |
; 1332 :  |   Return Value :                                                          |
; 1333 :  |                                                                           |
; 1334 :  |    L_var_out                                                              |
; 1335 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1336 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1337 :  |___________________________________________________________________________|
; 1338 : */
; 1339 : 
; 1340 : Word32 L_shl (Word32 L_var1, Word16 var2)
; 1341 : {
; 1342 :     Word32 L_var_out;
; 1343 : 
; 1344 :     if (var2 <= 0)
; 1345 :     {
; 1346 :         if (var2 < -32)
; 1347 :             var2 = -32;
; 1348 :         L_var_out = L_shr (L_var1, -var2);
; 1349 : #if (WMOPS)
; 1350 :         multiCounter[currCounter].L_shr--;
; 1351 : #endif
; 1352 :     }
; 1353 :     else
; 1354 :     {
; 1355 :         for (; var2 > 0; var2--)
; 1356 :         {
; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)
; 1358 :             {
; 1359 :                 Overflow = 1;
; 1360 :                 L_var_out = MAX_32;
; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)
; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;
; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;
; 1373 :             L_var_out = L_var1;
; 1374 :         }
; 1375 :     }
; 1376 : #if (WMOPS)
; 1377 :     multiCounter[currCounter].L_shl++;
; 1378 : #endif
; 1379 :     return (L_var_out);
; 1380 : }
; 1381 : 
; 1382 : /*___________________________________________________________________________
; 1383 :  |                                                                           |
; 1384 :  |   Function Name : L_shr                                                   |
; 1385 :  |                                                                           |
; 1386 :  |   Purpose :                                                               |
; 1387 :  |                                                                           |
; 1388 :  |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
; 1389 :  |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
; 1390 :  |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
; 1391 :  |   in case of underflows or overflows.                                     |
; 1392 :  |                                                                           |
; 1393 :  |   Complexity weight : 2                                                   |
; 1394 :  |                                                                           |
; 1395 :  |   Inputs :                                                                |
; 1396 :  |                                                                           |
; 1397 :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 1398 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1399 :  |                                                                           |
; 1400 :  |    var2                                                                   |
; 1401 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1402 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1403 :  |                                                                           |
; 1404 :  |   Outputs :                                                               |
; 1405 :  |                                                                           |
; 1406 :  |    none                                                                   |
; 1407 :  |                                                                           |
; 1408 :  |   Return Value :                                                          |
; 1409 :  |                                                                           |
; 1410 :  |    L_var_out                                                              |
; 1411 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1412 :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 1413 :  |___________________________________________________________________________|
; 1414 : */
; 1415 : 
; 1416 : Word32 L_shr (Word32 L_var1, Word16 var2)
; 1417 : {
; 1418 :     Word32 L_var_out;
; 1419 : 
; 1420 :     if (var2 < 0)
; 1421 :     {
; 1422 :         if (var2 < -32)
; 1423 :             var2 = -32;
; 1424 :         L_var_out = L_shl (L_var1, -var2);
; 1425 : #if (WMOPS)
; 1426 :         multiCounter[currCounter].L_shl--;
; 1427 : #endif
; 1428 :     }
; 1429 :     else
; 1430 :     {
; 1431 :         if (var2 >= 31)
; 1432 :         {
; 1433 :             L_var_out = (L_var1 < 0L) ? -1 : 0;
; 1434 :         }
; 1435 :         else
; 1436 :         {
; 1437 :             if (L_var1 < 0)
; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  00134	8b c1		 mov	 eax, ecx
  00136	85 c9		 test	 ecx, ecx
  00138	79 09		 jns	 SHORT $LN68@Lsp_Az
  0013a	f7 d0		 not	 eax
  0013c	c1 f8 0d	 sar	 eax, 13			; 0000000dH
  0013f	f7 d0		 not	 eax

; 1440 :             }
; 1441 :             else

  00141	eb 03		 jmp	 SHORT $LN67@Lsp_Az
$LN68@Lsp_Az:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00143	c1 f8 0d	 sar	 eax, 13			; 0000000dH
$LN67@Lsp_Az:

; 1444 :             }
; 1445 :         }
; 1446 :     }
; 1447 : #if (WMOPS)
; 1448 :     multiCounter[currCounter].L_shr++;
; 1449 : #endif
; 1450 :     return (L_var_out);
; 1451 : }
; 1452 : 
; 1453 : /*___________________________________________________________________________
; 1454 :  |                                                                           |
; 1455 :  |   Function Name : shr_r                                                   |
; 1456 :  |                                                                           |
; 1457 :  |   Purpose :                                                               |
; 1458 :  |                                                                           |
; 1459 :  |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
; 1460 :  |   underflows or overflows :                                               |
; 1461 :  |    - If var2 is greater than zero :                                       |
; 1462 :  |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
; 1463 :  |          is equal to zero                                                 |
; 1464 :  |                     then                                                  |
; 1465 :  |                     shr_r(var1,var2) = shr(var1,var2)                     |
; 1466 :  |                     else                                                  |
; 1467 :  |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
; 1468 :  |    - If var2 is less than or equal to zero :                              |
; 1469 :  |                     shr_r(var1,var2) = shr(var1,var2).                    |
; 1470 :  |                                                                           |
; 1471 :  |   Complexity weight : 2                                                   |
; 1472 :  |                                                                           |
; 1473 :  |   Inputs :                                                                |
; 1474 :  |                                                                           |
; 1475 :  |    var1                                                                   |
; 1476 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1477 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1478 :  |                                                                           |
; 1479 :  |    var2                                                                   |
; 1480 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1481 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1482 :  |                                                                           |
; 1483 :  |   Outputs :                                                               |
; 1484 :  |                                                                           |
; 1485 :  |    none                                                                   |
; 1486 :  |                                                                           |
; 1487 :  |   Return Value :                                                          |
; 1488 :  |                                                                           |
; 1489 :  |    var_out                                                                |
; 1490 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1491 :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 1492 :  |___________________________________________________________________________|
; 1493 : */
; 1494 : 
; 1495 : Word16 shr_r (Word16 var1, Word16 var2)
; 1496 : {
; 1497 :     Word16 var_out;
; 1498 : 
; 1499 :     if (var2 > 15)
; 1500 :     {
; 1501 :         var_out = 0;
; 1502 :     }
; 1503 :     else
; 1504 :     {
; 1505 :         var_out = shr (var1, var2);
; 1506 : #if (WMOPS)
; 1507 :         multiCounter[currCounter].shr--;
; 1508 : #endif
; 1509 : 
; 1510 :         if (var2 > 0)
; 1511 :         {
; 1512 :             if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
; 1513 :             {
; 1514 :                 var_out++;
; 1515 :             }
; 1516 :         }
; 1517 :     }
; 1518 : #if (WMOPS)
; 1519 :     multiCounter[currCounter].shr_r++;
; 1520 : #endif
; 1521 :     return (var_out);
; 1522 : }
; 1523 : 
; 1524 : /*___________________________________________________________________________
; 1525 :  |                                                                           |
; 1526 :  |   Function Name : mac_r                                                   |
; 1527 :  |                                                                           |
; 1528 :  |   Purpose :                                                               |
; 1529 :  |                                                                           |
; 1530 :  |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
; 1531 :  |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
; 1532 :  |   into the MS 16 bits with saturation and shift the result right by 16.   |
; 1533 :  |   Return a 16 bit result.                                                 |
; 1534 :  |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
; 1535 :  |                                                                           |
; 1536 :  |   Complexity weight : 2                                                   |
; 1537 :  |                                                                           |
; 1538 :  |   Inputs :                                                                |
; 1539 :  |                                                                           |
; 1540 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1541 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1542 :  |                                                                           |
; 1543 :  |    var1                                                                   |
; 1544 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1545 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1546 :  |                                                                           |
; 1547 :  |    var2                                                                   |
; 1548 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1549 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1550 :  |                                                                           |
; 1551 :  |   Outputs :                                                               |
; 1552 :  |                                                                           |
; 1553 :  |    none                                                                   |
; 1554 :  |                                                                           |
; 1555 :  |   Return Value :                                                          |
; 1556 :  |                                                                           |
; 1557 :  |    var_out                                                                |
; 1558 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1559 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1560 :  |___________________________________________________________________________|
; 1561 : */
; 1562 : 
; 1563 : Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1564 : {
; 1565 :     Word16 var_out;
; 1566 : 
; 1567 :     L_var3 = L_mac (L_var3, var1, var2);
; 1568 : #if (WMOPS)
; 1569 :     multiCounter[currCounter].L_mac--;
; 1570 : #endif
; 1571 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1572 : #if (WMOPS)
; 1573 :     multiCounter[currCounter].L_add--;
; 1574 : #endif
; 1575 :     var_out = extract_h (L_var3);
; 1576 : #if (WMOPS)
; 1577 :     multiCounter[currCounter].extract_h--;
; 1578 :     multiCounter[currCounter].mac_r++;
; 1579 : #endif
; 1580 :     return (var_out);
; 1581 : }
; 1582 : 
; 1583 : /*___________________________________________________________________________
; 1584 :  |                                                                           |
; 1585 :  |   Function Name : msu_r                                                   |
; 1586 :  |                                                                           |
; 1587 :  |   Purpose :                                                               |
; 1588 :  |                                                                           |
; 1589 :  |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
; 1590 :  |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
; 1591 :  |   ult into the MS 16 bits with saturation and shift the result right by   |
; 1592 :  |   16. Return a 16 bit result.                                             |
; 1593 :  |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
; 1594 :  |                                                                           |
; 1595 :  |   Complexity weight : 2                                                   |
; 1596 :  |                                                                           |
; 1597 :  |   Inputs :                                                                |
; 1598 :  |                                                                           |
; 1599 :  |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
; 1600 :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 1601 :  |                                                                           |
; 1602 :  |    var1                                                                   |
; 1603 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1604 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1605 :  |                                                                           |
; 1606 :  |    var2                                                                   |
; 1607 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1608 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1609 :  |                                                                           |
; 1610 :  |   Outputs :                                                               |
; 1611 :  |                                                                           |
; 1612 :  |    none                                                                   |
; 1613 :  |                                                                           |
; 1614 :  |   Return Value :                                                          |
; 1615 :  |                                                                           |
; 1616 :  |    var_out                                                                |
; 1617 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1618 :  |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
; 1619 :  |___________________________________________________________________________|
; 1620 : */
; 1621 : 
; 1622 : Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
; 1623 : {
; 1624 :     Word16 var_out;
; 1625 : 
; 1626 :     L_var3 = L_msu (L_var3, var1, var2);
; 1627 : #if (WMOPS)
; 1628 :     multiCounter[currCounter].L_msu--;
; 1629 : #endif
; 1630 :     L_var3 = L_add (L_var3, (Word32) 0x00008000L);
; 1631 : #if (WMOPS)
; 1632 :     multiCounter[currCounter].L_add--;
; 1633 : #endif
; 1634 :     var_out = extract_h (L_var3);
; 1635 : #if (WMOPS)
; 1636 :     multiCounter[currCounter].extract_h--;
; 1637 :     multiCounter[currCounter].msu_r++;
; 1638 : #endif
; 1639 :     return (var_out);
; 1640 : }
; 1641 : 
; 1642 : /*___________________________________________________________________________
; 1643 :  |                                                                           |
; 1644 :  |   Function Name : L_deposit_h                                             |
; 1645 :  |                                                                           |
; 1646 :  |   Purpose :                                                               |
; 1647 :  |                                                                           |
; 1648 :  |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
; 1649 :  |   16 LS bits of the output are zeroed.                                    |
; 1650 :  |                                                                           |
; 1651 :  |   Complexity weight : 2                                                   |
; 1652 :  |                                                                           |
; 1653 :  |   Inputs :                                                                |
; 1654 :  |                                                                           |
; 1655 :  |    var1                                                                   |
; 1656 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1657 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1658 :  |                                                                           |
; 1659 :  |   Outputs :                                                               |
; 1660 :  |                                                                           |
; 1661 :  |    none                                                                   |
; 1662 :  |                                                                           |
; 1663 :  |   Return Value :                                                          |
; 1664 :  |                                                                           |
; 1665 :  |    L_var_out                                                              |
; 1666 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1667 :  |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
; 1668 :  |___________________________________________________________________________|
; 1669 : */
; 1670 : 
; 1671 : Word32 L_deposit_h (Word16 var1)
; 1672 : {
; 1673 :     Word32 L_var_out;
; 1674 : 
; 1675 :     L_var_out = (Word32) var1 << 16;
; 1676 : #if (WMOPS)
; 1677 :     multiCounter[currCounter].L_deposit_h++;
; 1678 : #endif
; 1679 :     return (L_var_out);
; 1680 : }
; 1681 : 
; 1682 : /*___________________________________________________________________________
; 1683 :  |                                                                           |
; 1684 :  |   Function Name : L_deposit_l                                             |
; 1685 :  |                                                                           |
; 1686 :  |   Purpose :                                                               |
; 1687 :  |                                                                           |
; 1688 :  |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
; 1689 :  |   16 MS bits of the output are sign extended.                             |
; 1690 :  |                                                                           |
; 1691 :  |   Complexity weight : 2                                                   |
; 1692 :  |                                                                           |
; 1693 :  |   Inputs :                                                                |
; 1694 :  |                                                                           |
; 1695 :  |    var1                                                                   |
; 1696 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1697 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1698 :  |                                                                           |
; 1699 :  |   Outputs :                                                               |
; 1700 :  |                                                                           |
; 1701 :  |    none                                                                   |
; 1702 :  |                                                                           |
; 1703 :  |   Return Value :                                                          |
; 1704 :  |                                                                           |
; 1705 :  |    L_var_out                                                              |
; 1706 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1707 :  |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
; 1708 :  |___________________________________________________________________________|
; 1709 : */
; 1710 : 
; 1711 : Word32 L_deposit_l (Word16 var1)
; 1712 : {
; 1713 :     Word32 L_var_out;
; 1714 : 
; 1715 :     L_var_out = (Word32) var1;
; 1716 : #if (WMOPS)
; 1717 :     multiCounter[currCounter].L_deposit_l++;
; 1718 : #endif
; 1719 :     return (L_var_out);
; 1720 : }
; 1721 : 
; 1722 : /*___________________________________________________________________________
; 1723 :  |                                                                           |
; 1724 :  |   Function Name : L_shr_r                                                 |
; 1725 :  |                                                                           |
; 1726 :  |   Purpose :                                                               |
; 1727 :  |                                                                           |
; 1728 :  |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
; 1729 :  |   case of underflows or overflows :                                       |
; 1730 :  |    - If var2 is greater than zero :                                       |
; 1731 :  |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
; 1732 :  |          is equal to zero                                                 |
; 1733 :  |                     then                                                  |
; 1734 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
; 1735 :  |                     else                                                  |
; 1736 :  |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
; 1737 :  |    - If var2 is less than or equal to zero :                              |
; 1738 :  |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
; 1739 :  |                                                                           |
; 1740 :  |   Complexity weight : 3                                                   |
; 1741 :  |                                                                           |
; 1742 :  |   Inputs :                                                                |
; 1743 :  |                                                                           |
; 1744 :  |    L_var1                                                                 |
; 1745 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1746 :  |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
; 1747 :  |                                                                           |
; 1748 :  |    var2                                                                   |
; 1749 :  |             16 bit short signed integer (Word16) whose value falls in the |
; 1750 :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 1751 :  |                                                                           |
; 1752 :  |   Outputs :                                                               |
; 1753 :  |                                                                           |
; 1754 :  |    none                                                                   |
; 1755 :  |                                                                           |
; 1756 :  |   Return Value :                                                          |
; 1757 :  |                                                                           |
; 1758 :  |    L_var_out                                                              |
; 1759 :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 1760 :  |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
; 1761 :  |___________________________________________________________________________|
; 1762 : */
; 1763 : 
; 1764 : Word32 L_shr_r (Word32 L_var1, Word16 var2)
; 1765 : {
; 1766 :     Word32 L_var_out;
; 1767 : 
; 1768 :     if (var2 > 31)
; 1769 :     {
; 1770 :         L_var_out = 0;
; 1771 :     }
; 1772 :     else
; 1773 :     {
; 1774 :         L_var_out = L_shr (L_var1, var2);
; 1775 : #if (WMOPS)
; 1776 :         multiCounter[currCounter].L_shr--;
; 1777 : #endif
; 1778 :         if (var2 > 0)
; 1779 :         {
; 1780 :             if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)

  00146	f7 c1 00 10 00
	00		 test	 ecx, 4096		; 00001000H
  0014c	74 01		 je	 SHORT $LN61@Lsp_Az

; 1781 :             {
; 1782 :                 L_var_out++;

  0014e	40		 inc	 eax
$LN61@Lsp_Az:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 155  :         a[j] = extract_l (L_shr_r (t0, 13)); move16 (); 

  0014f	8b 55 c0	 mov	 edx, DWORD PTR _a$GSCopy$1$[ebp]
  00152	83 c7 04	 add	 edi, 4
  00155	83 45 c8 02	 add	 DWORD PTR tv784[ebp], 2
  00159	0f bf cb	 movsx	 ecx, bx
  0015c	4b		 dec	 ebx
  0015d	ff 4d c4	 dec	 DWORD PTR tv788[ebp]
  00160	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00164	0f 85 56 ff ff
	ff		 jne	 $LL3@Lsp_Az

; 156  :     }
; 157  : 
; 158  :     return;
; 159  : }

  0016a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016d	5f		 pop	 edi
  0016e	5e		 pop	 esi
  0016f	33 cd		 xor	 ecx, ebp
  00171	5b		 pop	 ebx
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
_Lsp_Az	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c
;	COMDAT _Get_lsp_pol
_TEXT	SEGMENT
_i$1$ = -12						; size = 4
tv638 = -8						; size = 4
_lsp$1$ = -4						; size = 4
_Get_lsp_pol PROC					; COMDAT
; _lsp$ = ecx
; _f$ = edx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	8b f1		 mov	 esi, ecx

; 83   :     Word16 i, j, hi, lo;
; 84   :     Word32 t0;
; 85   :     
; 86   :     /* f[0] = 1.0;             */
; 87   :     *f = L_mult (4096, 2048);              move32 (); 

  0000d	c7 07 00 00 00
	01		 mov	 DWORD PTR [edi], 16777216 ; 01000000H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00013	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00016	c1 e0 09	 shl	 eax, 9

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00019	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0001e	74 05		 je	 SHORT $LN20@Get_lsp_po

; 488  :     {
; 489  :         L_var_out *= 2;

  00020	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]

; 490  :     }
; 491  :     else

  00023	eb 0f		 jmp	 SHORT $LN19@Get_lsp_po
$LN20@Get_lsp_po:

; 492  :     {
; 493  :         Overflow = 1;

  00025	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  0002f	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN19@Get_lsp_po:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  00034	8b c1		 mov	 eax, ecx
  00036	f7 d8		 neg	 eax

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00038	85 c9		 test	 ecx, ecx
  0003a	79 13		 jns	 SHORT $LN23@Get_lsp_po

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  0003c	85 c0		 test	 eax, eax
  0003e	79 0f		 jns	 SHORT $LN23@Get_lsp_po

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  00040	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 990  :             Overflow = 1;

  00045	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN23@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 89   :     *f = L_msu ((Word32) 0, *lsp, 512);    /* f[1] =  -2.0 * lsp[0];  */

  0004f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 90   :     f++;                                   move32 (); 
; 91   :     lsp += 2;                              /* Advance lsp pointer     */
; 92   : 
; 93   :     for (i = 2; i <= 5; i++)

  00052	bb 02 00 00 00	 mov	 ebx, 2
  00057	83 c7 08	 add	 edi, 8
  0005a	89 5d f4	 mov	 DWORD PTR _i$1$[ebp], ebx
  0005d	83 c6 04	 add	 esi, 4
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	89 75 fc	 mov	 DWORD PTR _lsp$1$[ebp], esi
$LL6@Get_lsp_po:

; 94   :     {
; 95   :         *f = f[-2];                        move32 (); 

  00068	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0006b	89 07		 mov	 DWORD PTR [edi], eax

; 96   : 
; 97   :         for (j = 1; j < i; j++, f--)

  0006d	66 3b cb	 cmp	 cx, bx
  00070	0f 8d 14 01 00
	00		 jge	 $LN1@Get_lsp_po

; 94   :     {
; 95   :         *f = f[-2];                        move32 (); 

  00076	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00079	0f b7 c0	 movzx	 eax, ax
  0007c	89 45 f8	 mov	 DWORD PTR tv638[ebp], eax
  0007f	90		 npad	 1
$LL3@Get_lsp_po:

; 98   :         {
; 99   :             L_Extract (f[-1], &hi, &lo);

  00080	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 575  :     var_out = (Word16) (L_var1 >> 16);

  00083	8b c1		 mov	 eax, ecx
  00085	c1 f8 10	 sar	 eax, 16			; 00000010H
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\oper_32b.c

; 47   :     *hi = extract_h (L_32);

  00088	0f b7 d8	 movzx	 ebx, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1437 :             if (L_var1 < 0)

  0008b	85 c9		 test	 ecx, ecx
  0008d	79 08		 jns	 SHORT $LN36@Get_lsp_po

; 1438 :             {
; 1439 :                 L_var_out = ~((~L_var1) >> var2);

  0008f	f7 d1		 not	 ecx
  00091	d1 f9		 sar	 ecx, 1
  00093	f7 d1		 not	 ecx

; 1440 :             }
; 1441 :             else

  00095	eb 02		 jmp	 SHORT $LN35@Get_lsp_po
$LN36@Get_lsp_po:

; 1442 :             {
; 1443 :                 L_var_out = L_var1 >> var2;

  00097	d1 f9		 sar	 ecx, 1
$LN35@Get_lsp_po:

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  00099	0f bf c3	 movsx	 eax, bx
  0009c	c1 e0 0e	 shl	 eax, 14			; 0000000eH

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  0009f	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  000a4	74 04		 je	 SHORT $LN58@Get_lsp_po

; 488  :     {
; 489  :         L_var_out *= 2;

  000a6	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  000a8	eb 0f		 jmp	 SHORT $LN57@Get_lsp_po
$LN58@Get_lsp_po:

; 492  :     {
; 493  :         Overflow = 1;

  000aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  000b4	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN57@Get_lsp_po:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  000b9	8b d1		 mov	 edx, ecx
  000bb	2b d0		 sub	 edx, eax

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  000bd	33 c1		 xor	 eax, ecx
  000bf	79 1d		 jns	 SHORT $LN61@Get_lsp_po

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  000c1	8b c2		 mov	 eax, edx
  000c3	33 c1		 xor	 eax, ecx
  000c5	79 17		 jns	 SHORT $LN61@Get_lsp_po

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  000c7	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  000c9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  000d3	85 c9		 test	 ecx, ecx
  000d5	0f 98 c2	 sets	 dl
  000d8	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN61@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 100  :             t0 = Mpy_32_16 (hi, lo, *lsp); /* t0 = f[-1] * lsp    */

  000de	8b 45 fc	 mov	 eax, DWORD PTR _lsp$1$[ebp]
  000e1	8b cb		 mov	 ecx, ebx

; 101  :             t0 = L_shl (t0, 1);

  000e3	be 01 00 00 00	 mov	 esi, 1
  000e8	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _Mpy_32_16
  000f1	83 c4 04	 add	 esp, 4
$LL75@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 1357 :             if (L_var1 > (Word32) 0X3fffffffL)

  000f4	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  000f9	7f 18		 jg	 SHORT $LN117@Get_lsp_po

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  000fb	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  00100	7c 0a		 jl	 SHORT $LN118@Get_lsp_po

; 1369 :                     break;
; 1370 :                 }
; 1371 :             }
; 1372 :             L_var1 *= 2;

  00102	4e		 dec	 esi
  00103	03 c0		 add	 eax, eax
  00105	66 85 f6	 test	 si, si
  00108	7f ea		 jg	 SHORT $LL75@Get_lsp_po

; 1361 :                 break;
; 1362 :             }
; 1363 :             else
; 1364 :             {
; 1365 :                 if (L_var1 < (Word32) 0xc0000000L)

  0010a	eb 16		 jmp	 SHORT $LN70@Get_lsp_po
$LN118@Get_lsp_po:

; 1366 :                 {
; 1367 :                     Overflow = 1;
; 1368 :                     L_var_out = MIN_32;

  0010c	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00111	eb 05		 jmp	 SHORT $LN132@Get_lsp_po
$LN117@Get_lsp_po:

; 1360 :                 L_var_out = MAX_32;

  00113	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN132@Get_lsp_po:

; 1358 :             {
; 1359 :                 Overflow = 1;

  00118	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN70@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 102  :             *f = L_add (*f, f[-2]);        move32 (); /* *f += f[-2]      */

  00122	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  00125	8b 37		 mov	 esi, DWORD PTR [edi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 933  :     if (((L_var1 ^ L_var2) & MIN_32) == 0)

  00127	8b ce		 mov	 ecx, esi
  00129	33 ca		 xor	 ecx, edx
  0012b	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  0012e	78 1d		 js	 SHORT $LN87@Get_lsp_po

; 934  :     {
; 935  :         if ((L_var_out ^ L_var1) & MIN_32)

  00130	8b cb		 mov	 ecx, ebx
  00132	33 ce		 xor	 ecx, esi
  00134	79 17		 jns	 SHORT $LN87@Get_lsp_po

; 936  :         {
; 937  :             L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;

  00136	33 db		 xor	 ebx, ebx

; 938  :             Overflow = 1;

  00138	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  00142	85 f6		 test	 esi, esi
  00144	0f 98 c3	 sets	 bl
  00147	81 c3 ff ff ff
	7f		 add	 ebx, 2147483647		; 7fffffffH
$LN87@Get_lsp_po:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  0014d	8b d3		 mov	 edx, ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 102  :             *f = L_add (*f, f[-2]);        move32 (); /* *f += f[-2]      */

  0014f	89 1f		 mov	 DWORD PTR [edi], ebx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  00151	8b cb		 mov	 ecx, ebx
  00153	2b d0		 sub	 edx, eax
  00155	33 c8		 xor	 ecx, eax
  00157	79 1d		 jns	 SHORT $LN93@Get_lsp_po

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  00159	8b c2		 mov	 eax, edx
  0015b	33 c3		 xor	 eax, ebx
  0015d	79 17		 jns	 SHORT $LN93@Get_lsp_po

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  0015f	33 d2		 xor	 edx, edx

; 990  :             Overflow = 1;

  00161	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0016b	85 db		 test	 ebx, ebx
  0016d	0f 98 c2	 sets	 dl
  00170	81 c2 ff ff ff
	7f		 add	 edx, 2147483647		; 7fffffffH
$LN93@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 103  :             *f = L_sub (*f, t0);move32 (); /* *f -= t0            */

  00176	89 17		 mov	 DWORD PTR [edi], edx
  00178	83 ef 04	 sub	 edi, 4
  0017b	ff 4d f8	 dec	 DWORD PTR tv638[ebp]
  0017e	0f 85 fc fe ff
	ff		 jne	 $LL3@Get_lsp_po
  00184	8b 5d f4	 mov	 ebx, DWORD PTR _i$1$[ebp]
  00187	8b 75 fc	 mov	 esi, DWORD PTR _lsp$1$[ebp]
$LN1@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0018a	0f bf 06	 movsx	 eax, WORD PTR [esi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 105  :         *f = L_msu (*f, *lsp, 512);        move32 (); /* *f -= lsp<<9     */

  0018d	8b 17		 mov	 edx, DWORD PTR [edi]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 485  :     L_var_out = (Word32) var1 *(Word32) var2;

  0018f	c1 e0 09	 shl	 eax, 9

; 486  : 
; 487  :     if (L_var_out != (Word32) 0x40000000L)

  00192	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00197	74 04		 je	 SHORT $LN102@Get_lsp_po

; 488  :     {
; 489  :         L_var_out *= 2;

  00199	03 c0		 add	 eax, eax

; 490  :     }
; 491  :     else

  0019b	eb 0f		 jmp	 SHORT $LN101@Get_lsp_po
$LN102@Get_lsp_po:

; 492  :     {
; 493  :         Overflow = 1;

  0019d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 494  :         L_var_out = MAX_32;

  001a7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN101@Get_lsp_po:

; 939  :         }
; 940  :     }
; 941  : #if (WMOPS)
; 942  :     multiCounter[currCounter].L_add++;
; 943  : #endif
; 944  :     return (L_var_out);
; 945  : }
; 946  : 
; 947  : /*___________________________________________________________________________
; 948  :  |                                                                           |
; 949  :  |   Function Name : L_sub                                                   |
; 950  :  |                                                                           |
; 951  :  |   Purpose :                                                               |
; 952  :  |                                                                           |
; 953  :  |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
; 954  :  |   overflow control and saturation; the result is set at +2147483647 when  |
; 955  :  |   overflow occurs or at -2147483648 when underflow occurs.                |
; 956  :  |                                                                           |
; 957  :  |   Complexity weight : 2                                                   |
; 958  :  |                                                                           |
; 959  :  |   Inputs :                                                                |
; 960  :  |                                                                           |
; 961  :  |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
; 962  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 963  :  |                                                                           |
; 964  :  |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
; 965  :  |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
; 966  :  |                                                                           |
; 967  :  |   Outputs :                                                               |
; 968  :  |                                                                           |
; 969  :  |    none                                                                   |
; 970  :  |                                                                           |
; 971  :  |   Return Value :                                                          |
; 972  :  |                                                                           |
; 973  :  |    L_var_out                                                              |
; 974  :  |             32 bit long signed integer (Word32) whose value falls in the  |
; 975  :  |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
; 976  :  |___________________________________________________________________________|
; 977  : */
; 978  : 
; 979  : Word32 L_sub (Word32 L_var1, Word32 L_var2)
; 980  : {
; 981  :     Word32 L_var_out;
; 982  : 
; 983  :     L_var_out = L_var1 - L_var2;

  001ac	8b ca		 mov	 ecx, edx
  001ae	2b c8		 sub	 ecx, eax

; 985  :     if (((L_var1 ^ L_var2) & MIN_32) != 0)

  001b0	33 c2		 xor	 eax, edx
  001b2	79 1d		 jns	 SHORT $LN105@Get_lsp_po

; 986  :     {
; 987  :         if ((L_var_out ^ L_var1) & MIN_32)

  001b4	8b c1		 mov	 eax, ecx
  001b6	33 c2		 xor	 eax, edx
  001b8	79 17		 jns	 SHORT $LN105@Get_lsp_po

; 988  :         {
; 989  :             L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;

  001ba	33 c9		 xor	 ecx, ecx

; 990  :             Overflow = 1;

  001bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  001c6	85 d2		 test	 edx, edx
  001c8	0f 98 c1	 sets	 cl
  001cb	81 c1 ff ff ff
	7f		 add	 ecx, 2147483647		; 7fffffffH
$LN105@Get_lsp_po:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\lsp_az.c

; 106  :         f += i;                            /* Advance f pointer   */

  001d1	0f bf c3	 movsx	 eax, bx

; 107  :         lsp += 2;                          /* Advance lsp pointer */

  001d4	83 c6 04	 add	 esi, 4
  001d7	43		 inc	 ebx
  001d8	89 0f		 mov	 DWORD PTR [edi], ecx
  001da	89 75 fc	 mov	 DWORD PTR _lsp$1$[ebp], esi
  001dd	b9 01 00 00 00	 mov	 ecx, 1
  001e2	89 5d f4	 mov	 DWORD PTR _i$1$[ebp], ebx
  001e5	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  001e8	66 83 fb 05	 cmp	 bx, 5
  001ec	0f 8e 76 fe ff
	ff		 jle	 $LL6@Get_lsp_po
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx

; 108  :     }
; 109  : 
; 110  :     return;
; 111  : }

  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c3		 ret	 0
_Get_lsp_pol ENDP
_TEXT	ENDS
END
