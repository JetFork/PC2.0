; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\d_gain_p.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_qua_gain_pitch DW 00H
	DW	0ccdH
	DW	0199cH
	DW	02000H
	DW	02666H
	DW	02ccdH
	DW	03000H
	DW	03333H
	DW	03666H
	DW	0399aH
	DW	03ccdH
	DW	04000H
	DW	04333H
	DW	04666H
	DW	0499aH
	DW	04ccdH
PUBLIC	_d_gain_pitch
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c
;	COMDAT _d_gain_pitch
_TEXT	SEGMENT
_d_gain_pitch PROC					; COMDAT
; _mode$ = ecx
; _index$ = dx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 186  :     L_diff = (Word32) var1 - var2;

  00000	0f bf c1	 movsx	 eax, cx
  00003	83 e8 07	 sub	 eax, 7

; 79   :     if (L_var1 > 0X00007fffL)

  00006	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0000b	7e 16		 jle	 SHORT $LN12@d_gain_pit
$LN42@d_gain_pit:

; 80   :     {
; 81   :         Overflow = 1;

  0000d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
$LN2@d_gain_pit:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c

; 75   :        gain = qua_gain_pitch[index];                      move16 (); 

  00017	0f bf c2	 movsx	 eax, dx
  0001a	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _qua_gain_pitch[eax*2]

; 76   :     }
; 77   :     
; 78   :     return gain;
; 79   : }

  00022	c3		 ret	 0
$LN12@d_gain_pit:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00023	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00028	7c e3		 jl	 SHORT $LN42@d_gain_pit
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c

; 68   :     if (sub(mode, MR122) == 0)

  0002a	66 85 c0	 test	 ax, ax
  0002d	75 e8		 jne	 SHORT $LN2@d_gain_pit

; 71   :        gain = shl (shr (qua_gain_pitch[index], 2), 2);    move16 ();

  0002f	0f bf c2	 movsx	 eax, dx
  00032	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR _qua_gain_pitch[eax*2]
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 375  :             if (var1 < 0)

  0003a	66 85 c0	 test	 ax, ax
  0003d	79 0a		 jns	 SHORT $LN18@d_gain_pit

; 376  :             {
; 377  :                 var_out = ~((~var1) >> var2);

  0003f	98		 cwde
  00040	f7 d0		 not	 eax
  00042	c1 f8 02	 sar	 eax, 2
  00045	f7 d0		 not	 eax

; 378  :             }
; 379  :             else

  00047	eb 04		 jmp	 SHORT $LN41@d_gain_pit
$LN18@d_gain_pit:

; 380  :             {
; 381  :                 var_out = var1 >> var2;

  00049	66 c1 f8 02	 sar	 ax, 2
$LN41@d_gain_pit:
  0004d	0f b7 d0	 movzx	 edx, ax

; 187  :     var_out = saturate (L_diff);
; 188  : #if (WMOPS)
; 189  :     multiCounter[currCounter].sub++;
; 190  : #endif
; 191  :     return (var_out);
; 192  : }
; 193  : 
; 194  : /*___________________________________________________________________________
; 195  :  |                                                                           |
; 196  :  |   Function Name : abs_s                                                   |
; 197  :  |                                                                           |
; 198  :  |   Purpose :                                                               |
; 199  :  |                                                                           |
; 200  :  |    Absolute value of var1; abs_s(-32768) = 32767.                         |
; 201  :  |                                                                           |
; 202  :  |   Complexity weight : 1                                                   |
; 203  :  |                                                                           |
; 204  :  |   Inputs :                                                                |
; 205  :  |                                                                           |
; 206  :  |    var1                                                                   |
; 207  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 208  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 209  :  |                                                                           |
; 210  :  |   Outputs :                                                               |
; 211  :  |                                                                           |
; 212  :  |    none                                                                   |
; 213  :  |                                                                           |
; 214  :  |   Return Value :                                                          |
; 215  :  |                                                                           |
; 216  :  |    var_out                                                                |
; 217  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 218  :  |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
; 219  :  |___________________________________________________________________________|
; 220  : */
; 221  : 
; 222  : Word16 abs_s (Word16 var1)
; 223  : {
; 224  :     Word16 var_out;
; 225  : 
; 226  :     if (var1 == (Word16) 0X8000)
; 227  :     {
; 228  :         var_out = MAX_16;
; 229  :     }
; 230  :     else
; 231  :     {
; 232  :         if (var1 < 0)
; 233  :         {
; 234  :             var_out = -var1;
; 235  :         }
; 236  :         else
; 237  :         {
; 238  :             var_out = var1;
; 239  :         }
; 240  :     }
; 241  : #if (WMOPS)
; 242  :     multiCounter[currCounter].abs_s++;
; 243  : #endif
; 244  :     return (var_out);
; 245  : }
; 246  : 
; 247  : /*___________________________________________________________________________
; 248  :  |                                                                           |
; 249  :  |   Function Name : shl                                                     |
; 250  :  |                                                                           |
; 251  :  |   Purpose :                                                               |
; 252  :  |                                                                           |
; 253  :  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
; 254  :  |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
; 255  :  |   var1 right by -var2 with sign extension. Saturate the result in case of |
; 256  :  |   underflows or overflows.                                                |
; 257  :  |                                                                           |
; 258  :  |   Complexity weight : 1                                                   |
; 259  :  |                                                                           |
; 260  :  |   Inputs :                                                                |
; 261  :  |                                                                           |
; 262  :  |    var1                                                                   |
; 263  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 264  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 265  :  |                                                                           |
; 266  :  |    var2                                                                   |
; 267  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 268  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 269  :  |                                                                           |
; 270  :  |   Outputs :                                                               |
; 271  :  |                                                                           |
; 272  :  |    none                                                                   |
; 273  :  |                                                                           |
; 274  :  |   Return Value :                                                          |
; 275  :  |                                                                           |
; 276  :  |    var_out                                                                |
; 277  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 278  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 279  :  |___________________________________________________________________________|
; 280  : */
; 281  : 
; 282  : Word16 shl (Word16 var1, Word16 var2)
; 283  : {
; 284  :     Word16 var_out;
; 285  :     Word32 result;
; 286  : 
; 287  :     if (var2 < 0)
; 288  :     {
; 289  :         if (var2 < -16)
; 290  :             var2 = -16;
; 291  :         var_out = shr (var1, -var2);
; 292  : #if (WMOPS)
; 293  :         multiCounter[currCounter].shr--;
; 294  : #endif
; 295  :     }
; 296  :     else
; 297  :     {
; 298  :         result = (Word32) var1 *((Word32) 1 << var2);

  00050	0f bf ca	 movsx	 ecx, dx
  00053	c1 e1 02	 shl	 ecx, 2

; 299  : 
; 300  :         if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))

  00056	0f bf c1	 movsx	 eax, cx
  00059	3b c8		 cmp	 ecx, eax
  0005b	74 21		 je	 SHORT $LN29@d_gain_pit

; 301  :         {
; 302  :             Overflow = 1;
; 303  :             var_out = (var1 > 0) ? MAX_16 : MIN_16;

  0005d	66 85 d2	 test	 dx, dx
  00060	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
  0006a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0006f	b9 ff 7f 00 00	 mov	 ecx, 32767		; 00007fffH
  00074	0f 4f c1	 cmovg	 eax, ecx
  00077	0f b7 c0	 movzx	 eax, ax
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c

; 71   :        gain = shl (shr (qua_gain_pitch[index], 2), 2);    move16 ();

  0007a	0f b7 c0	 movzx	 eax, ax

; 76   :     }
; 77   :     
; 78   :     return gain;
; 79   : }

  0007d	c3		 ret	 0
$LN29@d_gain_pit:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 307  :             var_out = extract_l (result);

  0007e	0f b7 c1	 movzx	 eax, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\d_gain_p.c

; 71   :        gain = shl (shr (qua_gain_pitch[index], 2), 2);    move16 ();

  00081	0f b7 c0	 movzx	 eax, ax

; 76   :     }
; 77   :     
; 78   :     return gain;
; 79   : }

  00084	c3		 ret	 0
_d_gain_pitch ENDP
_TEXT	ENDS
END
