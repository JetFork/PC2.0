; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	E:\mywork\client\PC2.0TRUNK\PC2.0\third_party\libAMRPlayer\AMR\preemph.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@ ; `string'
PUBLIC	??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@ ; `string'
PUBLIC	??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@ ; `string'
;	COMDAT ??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@
CONST	SEGMENT
??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@ DB 'preemphasis_r'
	DB	'eset: invalid parameter', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@
CONST	SEGMENT
??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@ DB 'preemphasis_'
	DB	'init: can not malloc state structure', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@
CONST	SEGMENT
??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@ DB 'preemphasis_i'
	DB	'nit: invalid parameter', 0aH, 00H		; `string'
PUBLIC	_preemphasis
PUBLIC	_preemphasis_init
PUBLIC	_preemphasis_exit
PUBLIC	_preemphasis_reset
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_reset
_TEXT	SEGMENT
_preemphasis_reset PROC					; COMDAT

; 87   :   if (state == (preemphasisState *) NULL){
; 88   :       fprintf(stderr, "preemphasis_reset: invalid parameter\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JOBMJPIB@preemphasis_reset?3?5invalid?5param@
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0000b	83 c0 40	 add	 eax, 64			; 00000040H
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  00015	83 c4 08	 add	 esp, 8

; 89   :       return -1;

  00018	83 c8 ff	 or	 eax, -1

; 90   :   }
; 91   :   
; 92   :   state->mem_pre = 0;
; 93   :  
; 94   :   return 0;
; 95   : }

  0001b	c3		 ret	 0
_preemphasis_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_exit
_TEXT	SEGMENT
_preemphasis_exit PROC					; COMDAT
; _state$ = ecx

; 105  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 106  :   if (state == NULL || *state == NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 16		 je	 SHORT $LN1@preemphasi
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	85 c0		 test	 eax, eax
  0000b	74 10		 je	 SHORT $LN1@preemphasi

; 107  :       return;
; 108  :  
; 109  :   /* deallocate memory */
; 110  :   free(*state);

  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00014	83 c4 04	 add	 esp, 4

; 111  :   *state = NULL;

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@preemphasi:
  0001d	5e		 pop	 esi

; 112  :   
; 113  :   return;
; 114  : }

  0001e	c3		 ret	 0
_preemphasis_exit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis_init
_TEXT	SEGMENT
_preemphasis_init PROC					; COMDAT
; _state$ = ecx

; 57   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 58   :   preemphasisState* s;
; 59   :  
; 60   :   if (state == (preemphasisState **) NULL){

  00003	85 f6		 test	 esi, esi
  00005	75 1d		 jne	 SHORT $LN2@preemphasi

; 61   :       fprintf(stderr, "preemphasis_init: invalid parameter\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LCKOOKAA@preemphasis_init?3?5invalid?5parame@
$LN8@preemphasi:
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00012	83 c0 40	 add	 eax, 64			; 00000040H
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  0001c	83 c4 08	 add	 esp, 8

; 62   :       return -1;

  0001f	83 c8 ff	 or	 eax, -1
  00022	5e		 pop	 esi

; 76   : }

  00023	c3		 ret	 0
$LN2@preemphasi:

; 63   :   }
; 64   :   *state = NULL;
; 65   :  
; 66   :   /* allocate memory */
; 67   :   if ((s= (preemphasisState *) malloc(sizeof(preemphasisState))) == NULL){

  00024	6a 02		 push	 2
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN1@preemphasi

; 68   :       fprintf(stderr, "preemphasis_init: can not malloc state structure\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ELHHMLFG@preemphasis_init?3?5can?5not?5malloc@

; 69   :       return -1;

  0003e	eb cc		 jmp	 SHORT $LN8@preemphasi
$LN1@preemphasi:

; 77   : 
; 78   : /*************************************************************************
; 79   : *
; 80   : *  Function:   preemphasis_reset
; 81   : *  Purpose:    Initializes state memory to zero
; 82   : *
; 83   : **************************************************************************
; 84   : */
; 85   : int preemphasis_reset (preemphasisState *state)
; 86   : {
; 87   :   if (state == (preemphasisState *) NULL){
; 88   :       fprintf(stderr, "preemphasis_reset: invalid parameter\n");
; 89   :       return -1;
; 90   :   }
; 91   :   
; 92   :   state->mem_pre = 0;

  00040	33 c9		 xor	 ecx, ecx
  00042	66 89 08	 mov	 WORD PTR [eax], cx

; 70   :   }
; 71   :   
; 72   :   preemphasis_reset(s);
; 73   :   *state = s;

  00045	89 06		 mov	 DWORD PTR [esi], eax

; 74   :   
; 75   :   return 0;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 76   : }

  0004a	c3		 ret	 0
_preemphasis_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c
;	COMDAT _preemphasis
_TEXT	SEGMENT
_temp$1$ = -8						; size = 4
_st$1$ = -4						; size = 4
_g$ = 8							; size = 2
_L$dead$ = 12						; size = 2
_preemphasis PROC					; COMDAT
; _st$ = ecx
; _signal$ = edx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 130  :     Word16 *p1, *p2, temp, i;
; 131  : 
; 132  :     p1 = signal + L - 1;                    move16 (); 
; 133  :     p2 = p1 - 1;                            move16 (); 
; 134  :     temp = *p1;                             move16 (); 

  00006	0f b7 42 4e	 movzx	 eax, WORD PTR [edx+78]
  0000a	83 c2 4e	 add	 edx, 78			; 0000004eH
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	89 45 f8	 mov	 DWORD PTR _temp$1$[ebp], eax
  00012	8b 45 08	 mov	 eax, DWORD PTR _g$[ebp]
  00015	8d 72 fe	 lea	 esi, DWORD PTR [edx-2]
  00018	57		 push	 edi
  00019	89 4d fc	 mov	 DWORD PTR _st$1$[ebp], ecx

; 135  : 
; 136  :     for (i = 0; i <= L - 2; i++)

  0001c	33 ff		 xor	 edi, edi
  0001e	0f bf d8	 movsx	 ebx, ax
$LL3@preemphasi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  00021	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00024	0f af c3	 imul	 eax, ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  00027	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  0002a	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  0002f	74 05		 je	 SHORT $LN12@preemphasi

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  00031	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN12@preemphasi:

; 79   :     if (L_var1 > 0X00007fffL)

  00036	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0003b	7e 11		 jle	 SHORT $LN18@preemphasi

; 80   :     {
; 81   :         Overflow = 1;

  0003d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00047	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  0004c	eb 1b		 jmp	 SHORT $LN15@preemphasi
$LN18@preemphasi:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  0004e	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  00053	7d 11		 jge	 SHORT $LN16@preemphasi

; 85   :     {
; 86   :         Overflow = 1;

  00055	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0005f	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  00064	eb 03		 jmp	 SHORT $LN15@preemphasi
$LN16@preemphasi:

; 91   :         var_out = extract_l (L_var1);

  00066	0f b7 c0	 movzx	 eax, ax
$LN15@preemphasi:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00069	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
  0006c	98		 cwde
  0006d	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  0006f	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00075	7e 11		 jle	 SHORT $LN28@preemphasi

; 80   :     {
; 81   :         Overflow = 1;

  00077	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  00081	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00086	eb 1c		 jmp	 SHORT $LN25@preemphasi
$LN28@preemphasi:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00088	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  0008e	7d 11		 jge	 SHORT $LN26@preemphasi

; 85   :     {
; 86   :         Overflow = 1;

  00090	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  0009a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  0009f	eb 03		 jmp	 SHORT $LN25@preemphasi
$LN26@preemphasi:

; 91   :         var_out = extract_l (L_var1);

  000a1	0f b7 c1	 movzx	 eax, cx
$LN25@preemphasi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 138  :         *p1 = sub (*p1, mult (g, *p2--));   move16 (); 

  000a4	66 89 02	 mov	 WORD PTR [edx], ax
  000a7	47		 inc	 edi
  000a8	83 ee 02	 sub	 esi, 2

; 139  :         p1--;

  000ab	83 ea 02	 sub	 edx, 2
  000ae	66 83 ff 26	 cmp	 di, 38			; 00000026H
  000b2	0f 8e 69 ff ff
	ff		 jle	 $LL3@preemphasi
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 432  :     L_product = (Word32) var1 *(Word32) var2;

  000b8	8b 75 fc	 mov	 esi, DWORD PTR _st$1$[ebp]
  000bb	0f bf 06	 movsx	 eax, WORD PTR [esi]
  000be	0f af c3	 imul	 eax, ebx

; 433  : 
; 434  :     L_product = (L_product & (Word32) 0xffff8000L) >> 15;

  000c1	c1 f8 0f	 sar	 eax, 15			; 0000000fH

; 435  : 
; 436  :     if (L_product & (Word32) 0x00010000L)

  000c4	a9 00 00 01 00	 test	 eax, 65536		; 00010000H
  000c9	74 05		 je	 SHORT $LN35@preemphasi

; 437  :         L_product = L_product | (Word32) 0xffff0000L;

  000cb	0d 00 00 ff ff	 or	 eax, -65536		; ffff0000H
$LN35@preemphasi:

; 79   :     if (L_var1 > 0X00007fffL)

  000d0	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  000d5	7e 11		 jle	 SHORT $LN41@preemphasi

; 80   :     {
; 81   :         Overflow = 1;

  000d7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 82   :         var_out = MAX_16;

  000e1	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  000e6	eb 1b		 jmp	 SHORT $LN38@preemphasi
$LN41@preemphasi:

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  000e8	3d 00 80 ff ff	 cmp	 eax, -32768		; ffff8000H
  000ed	7d 11		 jge	 SHORT $LN39@preemphasi

; 85   :     {
; 86   :         Overflow = 1;

  000ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1

; 87   :         var_out = MIN_16;

  000f9	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H

; 88   :     }
; 89   :     else

  000fe	eb 03		 jmp	 SHORT $LN38@preemphasi
$LN39@preemphasi:

; 91   :         var_out = extract_l (L_var1);

  00100	0f b7 c0	 movzx	 eax, ax
$LN38@preemphasi:

; 92   : #if (WMOPS)
; 93   :         multiCounter[currCounter].extract_l--;
; 94   : #endif
; 95   :     }
; 96   : 
; 97   :     return (var_out);
; 98   : }
; 99   : 
; 100  : /*___________________________________________________________________________
; 101  :  |                                                                           |
; 102  :  |   Function Name : add                                                     |
; 103  :  |                                                                           |
; 104  :  |   Purpose :                                                               |
; 105  :  |                                                                           |
; 106  :  |    Performs the addition (var1+var2) with overflow control and saturation;|
; 107  :  |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
; 108  :  |    when underflow occurs.                                                 |
; 109  :  |                                                                           |
; 110  :  |   Complexity weight : 1                                                   |
; 111  :  |                                                                           |
; 112  :  |   Inputs :                                                                |
; 113  :  |                                                                           |
; 114  :  |    var1                                                                   |
; 115  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 116  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 117  :  |                                                                           |
; 118  :  |    var2                                                                   |
; 119  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 120  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 121  :  |                                                                           |
; 122  :  |   Outputs :                                                               |
; 123  :  |                                                                           |
; 124  :  |    none                                                                   |
; 125  :  |                                                                           |
; 126  :  |   Return Value :                                                          |
; 127  :  |                                                                           |
; 128  :  |    var_out                                                                |
; 129  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 130  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 131  :  |___________________________________________________________________________|
; 132  : */
; 133  : 
; 134  : Word16 add (Word16 var1, Word16 var2)
; 135  : {
; 136  :     Word16 var_out;
; 137  :     Word32 L_sum;
; 138  : 
; 139  :     L_sum = (Word32) var1 + var2;
; 140  :     var_out = saturate (L_sum);
; 141  : #if (WMOPS)
; 142  :     multiCounter[currCounter].add++;
; 143  : #endif
; 144  :     return (var_out);
; 145  : }
; 146  : 
; 147  : /*___________________________________________________________________________
; 148  :  |                                                                           |
; 149  :  |   Function Name : sub                                                     |
; 150  :  |                                                                           |
; 151  :  |   Purpose :                                                               |
; 152  :  |                                                                           |
; 153  :  |    Performs the subtraction (var1+var2) with overflow control and satu-   |
; 154  :  |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
; 155  :  |    -32768 when underflow occurs.                                          |
; 156  :  |                                                                           |
; 157  :  |   Complexity weight : 1                                                   |
; 158  :  |                                                                           |
; 159  :  |   Inputs :                                                                |
; 160  :  |                                                                           |
; 161  :  |    var1                                                                   |
; 162  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 163  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 164  :  |                                                                           |
; 165  :  |    var2                                                                   |
; 166  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 167  :  |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
; 168  :  |                                                                           |
; 169  :  |   Outputs :                                                               |
; 170  :  |                                                                           |
; 171  :  |    none                                                                   |
; 172  :  |                                                                           |
; 173  :  |   Return Value :                                                          |
; 174  :  |                                                                           |
; 175  :  |    var_out                                                                |
; 176  :  |             16 bit short signed integer (Word16) whose value falls in the |
; 177  :  |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
; 178  :  |___________________________________________________________________________|
; 179  : */
; 180  : 
; 181  : Word16 sub (Word16 var1, Word16 var2)
; 182  : {
; 183  :     Word16 var_out;
; 184  :     Word32 L_diff;
; 185  : 
; 186  :     L_diff = (Word32) var1 - var2;

  00103	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
  00106	98		 cwde
  00107	2b c8		 sub	 ecx, eax

; 79   :     if (L_var1 > 0X00007fffL)

  00109	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  0010f	7e 21		 jle	 SHORT $LN51@preemphasi

; 82   :         var_out = MAX_16;

  00111	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00116	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 142  :     *p1 = sub (*p1, mult (g, st->mem_pre));     move16 (); 

  00120	66 89 02	 mov	 WORD PTR [edx], ax

; 143  : 
; 144  :     st->mem_pre = temp;                         move16 (); 

  00123	8b 45 f8	 mov	 eax, DWORD PTR _temp$1$[ebp]
  00126	5f		 pop	 edi
  00127	66 89 06	 mov	 WORD PTR [esi], ax

; 145  : 
; 146  :     return 0;

  0012a	33 c0		 xor	 eax, eax
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx

; 147  : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
$LN51@preemphasi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 84   :     else if (L_var1 < (Word32) 0xffff8000L)

  00132	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffff8000H
  00138	7d 21		 jge	 SHORT $LN49@preemphasi

; 87   :         var_out = MIN_16;

  0013a	b8 00 80 ff ff	 mov	 eax, -32768		; ffff8000H
  0013f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Overflow, 1
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 142  :     *p1 = sub (*p1, mult (g, st->mem_pre));     move16 (); 

  00149	66 89 02	 mov	 WORD PTR [edx], ax

; 143  : 
; 144  :     st->mem_pre = temp;                         move16 (); 

  0014c	8b 45 f8	 mov	 eax, DWORD PTR _temp$1$[ebp]
  0014f	5f		 pop	 edi
  00150	66 89 06	 mov	 WORD PTR [esi], ax

; 145  : 
; 146  :     return 0;

  00153	33 c0		 xor	 eax, eax
  00155	5e		 pop	 esi
  00156	5b		 pop	 ebx

; 147  : }

  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
$LN49@preemphasi:
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\basicop2.c

; 91   :         var_out = extract_l (L_var1);

  0015b	0f b7 c1	 movzx	 eax, cx
; File e:\mywork\client\pc2.0trunk\pc2.0\third_party\libamrplayer\amr\preemph.c

; 142  :     *p1 = sub (*p1, mult (g, st->mem_pre));     move16 (); 

  0015e	66 89 02	 mov	 WORD PTR [edx], ax

; 143  : 
; 144  :     st->mem_pre = temp;                         move16 (); 

  00161	8b 45 f8	 mov	 eax, DWORD PTR _temp$1$[ebp]
  00164	5f		 pop	 edi
  00165	66 89 06	 mov	 WORD PTR [esi], ax

; 145  : 
; 146  :     return 0;

  00168	33 c0		 xor	 eax, eax
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx

; 147  : }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_preemphasis ENDP
_TEXT	ENDS
END
